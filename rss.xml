<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes|笔记站</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2025-12-25T09:11:19.118Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025-12-25-JavaScript中的数组方法与栈（Stack）和队列（Queue）的实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/28254.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/28254.html</id>
    <published>2025-12-25T08:58:15.000Z</published>
    <updated>2025-12-25T09:11:19.118Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能</p><p>这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在<strong>两端</strong>高效操作的能力</p><p>以下以清晰的方式说明如何实现，以及优缺点分析</p><h3 id="1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）"><a href="#1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）" class="headerlink" title="1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）"></a>1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）</h3><p>主要使用数组的<strong>末尾</strong>操作实现：</p><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入栈（push）</td><td>array.push(item)</td><td>stack.push(1)</td><td>O(1)</td></tr><tr><td>出栈（pop）</td><td>array.pop()</td><td>const item = stack.pop()</td><td>O(1)</td></tr></tbody></table></div><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> stack = [];<br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// [1]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// [1, 2]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack);        <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><h3 id="2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）"><a href="#2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）" class="headerlink" title="2. 实现队列（Queue）——先进先出（FIFO，First In First Out）"></a>2. 实现队列（Queue）——先进先出（FIFO，First In First Out）</h3><h4 id="方式一：头部删除-尾部插入"><a href="#方式一：头部删除-尾部插入" class="headerlink" title="方式一：头部删除 + 尾部插入"></a>方式一：<strong>头部删除 + 尾部插入</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队（enqueue）</td><td>array.push(item)</td><td>queue.push(1)</td><td>O(1)</td></tr><tr><td>出队（dequeue）</td><td>array.shift()</td><td>const item = queue.shift()</td><td>O(n)</td></tr></tbody></table></div><p>问题：shift() 会导致数组所有元素向前移动，时间复杂度为 O(n)，频繁操作时性能很差</p><h4 id="方式二：尾部插入-头部删除"><a href="#方式二：尾部插入-头部删除" class="headerlink" title="方式二：尾部插入 + 头部删除"></a>方式二：<strong>尾部插入 + 头部删除</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队</td><td>array.unshift(item)</td><td>queue.unshift(1)</td><td>O(n)</td></tr><tr><td>出队</td><td>array.pop()</td><td>const item = queue.pop()</td><td>O(1)</td></tr></tbody></table></div><p>同样存在 O(n) 操作</p><p>如果需要高效队列，可以使用<strong>双端队列</strong>实现或第三方库，有几种方式</p><ol><li><strong>使用两个数组模拟</strong>（常见面试实现）：<ul><li>一个栈用于入队，一个栈用于出队，需要时倒腾。</li></ul></li><li><strong>使用 JavaScript 的 Deque（双端队列）库</strong>：<ul><li>如 js-deque 或其他库，支持 O(1) 的头尾操作。</li></ul></li><li><strong>ES6+ 原生替代</strong>：虽然没有内置 Queue，但可以用 Array + 手动索引模拟环形队列（较复杂）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能&lt;/p&gt;
&lt;p&gt;这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在&lt;strong&gt;两端&lt;/str</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-关于JavaScript Set 方法</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/27040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/27040.html</id>
    <published>2025-12-25T07:26:18.000Z</published>
    <updated>2025-12-25T07:53:56.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Set-方法详解"><a href="#JavaScript-Set-方法详解" class="headerlink" title="JavaScript Set 方法详解"></a>JavaScript Set 方法详解</h1><h2 id="1-Set-是什么？"><a href="#1-Set-是什么？" class="headerlink" title="1. Set 是什么？"></a>1. Set 是什么？</h2><p><strong>Set</strong>​ 是 ES6 引入的一种新的数据结构，它类似于数组，但<strong>成员的值都是唯一的</strong>，没有重复的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 创建一个 Set</span><br><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 或者从数组创建</span><br><span class="hljs-keyword">const</span> setFromArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// 会自动去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setFromArray); <span class="hljs-comment">// Set(4) {1, 2, 3, 4}</span><br></code></pre></td></tr></table></figure><h2 id="2-Set-的基本方法"><a href="#2-Set-的基本方法" class="headerlink" title="2. Set 的基本方法"></a>2. Set 的基本方法</h2><h3 id="2-1-添加元素：add"><a href="#2-1-添加元素：add" class="headerlink" title="2.1 添加元素：add()"></a>2.1 添加元素：<code>add()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 添加单个元素</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复添加，不会被添加进去</span><br><br><span class="hljs-comment">// 链式调用</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 可以添加任意类型的值</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"hello"</span>);<br>set.<span class="hljs-title function_">add</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> });<br>set.<span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// NaN 在 Set 中也是唯一的</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// 不会添加第二个 NaN</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 查看大小</span><br></code></pre></td></tr></table></figure><h3 id="2-2-删除元素：delete"><a href="#2-2-删除元素：delete" class="headerlink" title="2.2 删除元素：delete()"></a>2.2 删除元素：<code>delete()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-comment">// 删除指定值</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(4) {1, 2, 4, 5}</span><br><br><span class="hljs-comment">// 删除不存在的值返回 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 删除对象引用需要相同的引用</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> })); <span class="hljs-comment">// false，因为不是同一个引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(obj)); <span class="hljs-comment">// true，删除成功</span><br></code></pre></td></tr></table></figure><h3 id="2-3-检查存在：has"><a href="#2-3-检查存在：has" class="headerlink" title="2.3 检查存在：has()"></a>2.3 检查存在：<code>has()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 对于 NaN，Set 能正确处理</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="2-4-清空-Set：clear"><a href="#2-4-清空-Set：clear" class="headerlink" title="2.4 清空 Set：clear()"></a>2.4 清空 Set：<code>clear()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 5</span><br><br>set.<span class="hljs-title function_">clear</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(0) {}</span><br></code></pre></td></tr></table></figure><h2 id="3-Set-的遍历方法"><a href="#3-Set-的遍历方法" class="headerlink" title="3. Set 的遍历方法"></a>3. Set 的遍历方法</h2><h3 id="3-1-forEach"><a href="#3-1-forEach" class="headerlink" title="3.1 forEach()"></a>3.1 <code>forEach()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>]);<br><br><span class="hljs-comment">// 遍历每个元素</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key, set</span>) =&gt;</span> {<br>  <span class="hljs-comment">// Set 的 key 和 value 相同</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);<br>});<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// apple: apple</span><br><span class="hljs-comment">// banana: banana</span><br><span class="hljs-comment">// orange: orange</span><br></code></pre></td></tr></table></figure><h3 id="3-2-keys-、values-、entries"><a href="#3-2-keys-、values-、entries" class="headerlink" title="3.2 keys()、values()、entries()"></a>3.2 <code>keys()</code>、<code>values()</code>、<code>entries()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]);<br><br><span class="hljs-comment">// keys() - 返回键名的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">keys</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// values() - 返回键值的遍历器（Set 的键和值相同）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// entries() - 返回键值对的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">entries</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry); <span class="hljs-comment">// ['a', 'a'], ['b', 'b'], ['c', 'c']</span><br>}<br></code></pre></td></tr></table></figure><h2 id="4-Set-的特性"><a href="#4-Set-的特性" class="headerlink" title="4. Set 的特性"></a>4. Set 的特性</h2><h3 id="4-1-唯一性"><a href="#4-1-唯一性" class="headerlink" title="4.1 唯一性"></a>4.1 唯一性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 自动去重</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> uniqueSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...uniqueSet]); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 对象引用不同，不算重复</span><br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> objSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([obj1, obj2, obj1]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objSet.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，obj1 和 obj2 被认为是不同的</span><br></code></pre></td></tr></table></figure><h3 id="4-2-与数组的对比"><a href="#4-2-与数组的对比" class="headerlink" title="4.2 与数组的对比"></a>4.2 与数组的对比</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 查找元素</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><br><span class="hljs-comment">// 数组查找是 O(n)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，需要遍历</span><br><br><span class="hljs-comment">// Set 查找是 O(1)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，哈希查找，更快</span><br><br><span class="hljs-comment">// 判断是否重复</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicates</span> = (<span class="hljs-params">array</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array).<span class="hljs-property">size</span> !== array.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="4-3-迭代顺序"><a href="#4-3-迭代顺序" class="headerlink" title="4.3 迭代顺序"></a>4.3 迭代顺序</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 的遍历顺序就是插入顺序</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 3, 1, 2（插入顺序）</span><br>}<br><br><span class="hljs-comment">// 与对象不同，对象的键顺序不保证</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-number">3</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>: <span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>: <span class="hljs-string">"c"</span> };<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)); <span class="hljs-comment">// ['1', '2', '3']（数字键会排序）</span><br></code></pre></td></tr></table></figure><h2 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h2><h3 id="5-1-数组去重（最常用）"><a href="#5-1-数组去重（最常用）" class="headerlink" title="5.1 数组去重（最常用）"></a>5.1 数组去重（最常用）</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传统方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniqueArray</span>(numbers)); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 字符串去重</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"hello world"</span>;<br><span class="hljs-keyword">const</span> uniqueChars = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueChars); <span class="hljs-comment">// 'helo wrd'</span><br></code></pre></td></tr></table></figure><h3 id="5-2-求交集、并集、差集"><a href="#5-2-求交集、并集、差集" class="headerlink" title="5.2 求交集、并集、差集"></a>5.2 求交集、并集、差集</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> setA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">const</span> setB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">const</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...union]); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">const</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...intersection]); <span class="hljs-comment">// [3, 4]</span><br><br><span class="hljs-comment">// 差集（A 有 B 没有）</span><br><span class="hljs-keyword">const</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...difference]); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="5-3-数据筛选"><a href="#5-3-数据筛选" class="headerlink" title="5.3 数据筛选"></a>5.3 数据筛选</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 从数组中过滤出唯一的元素</span><br><span class="hljs-keyword">const</span> data = [<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Bob"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> }, <span class="hljs-comment">// 重复</span><br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Charlie"</span> },<br>];<br><br><span class="hljs-comment">// 基于 id 去重</span><br><span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> uniqueData = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(item.<span class="hljs-property">id</span>)) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    seen.<span class="hljs-title function_">add</span>(item.<span class="hljs-property">id</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>});<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueData);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//     { id: 1, name: 'Alice' },</span><br><span class="hljs-comment">//     { id: 2, name: 'Bob' },</span><br><span class="hljs-comment">//     { id: 3, name: 'Charlie' }</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h3 id="5-4-标签-分类系统"><a href="#5-4-标签-分类系统" class="headerlink" title="5.4 标签/分类系统"></a>5.4 标签/分类系统</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TagSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-title function_">addTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">removeTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">delete</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">hasTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">has</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>  }<br><br>  <span class="hljs-title function_">getAllTags</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>];<br>  }<br><br>  <span class="hljs-title function_">merge</span>(<span class="hljs-params">otherTagSystem</span>) {<br>    otherTagSystem.<span class="hljs-property">tags</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">tag</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> articleTags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagSystem</span>();<br>articleTags.<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"Tutorial"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>); <span class="hljs-comment">// 不会重复添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(articleTags.<span class="hljs-title function_">getAllTags</span>()); <span class="hljs-comment">// ['javascript', 'tutorial']</span><br></code></pre></td></tr></table></figure><h2 id="6-Set-性能优势"><a href="#6-Set-性能优势" class="headerlink" title="6. Set 性能优势"></a>6. Set 性能优势</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 测试查找性能</span><br><span class="hljs-keyword">const</span> largeArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);<br><span class="hljs-keyword">const</span> largeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(largeArray);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Array查找"</span>);<br>largeArray.<span class="hljs-title function_">includes</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Array查找"</span>); <span class="hljs-comment">// 约 0.5-1ms</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set查找"</span>);<br>largeSet.<span class="hljs-title function_">has</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set查找"</span>); <span class="hljs-comment">// 约 0.01ms</span><br><br><span class="hljs-comment">// 测试重复检查性能</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesArray</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (arr[i] === arr[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesSet</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-keyword">const</span> testArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">() =&gt;</span><br>  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)<br>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"数组检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesArray</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"数组检查重复"</span>); <span class="hljs-comment">// 慢</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesSet</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set检查重复"</span>); <span class="hljs-comment">// 快</span><br></code></pre></td></tr></table></figure><h2 id="7-WeakSet"><a href="#7-WeakSet" class="headerlink" title="7. WeakSet"></a>7. WeakSet</h2><h3 id="7-1-与-Set-的区别"><a href="#7-1-与-Set-的区别" class="headerlink" title="7.1 与 Set 的区别"></a>7.1 与 Set 的区别</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 可以存储任何类型的值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// WeakSet 只能存储对象引用</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>weakSet.<span class="hljs-title function_">add</span>(obj); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// weakSet.add(1); // TypeError: Invalid value used in weak set</span><br><br><span class="hljs-comment">// WeakSet 的引用是弱引用，不会阻止垃圾回收</span><br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除引用</span><br><span class="hljs-comment">// 等待垃圾回收后，weakSet 中的对应项会自动被移除</span><br></code></pre></td></tr></table></figure><h3 id="7-2-WeakSet-的方法"><a href="#7-2-WeakSet-的方法" class="headerlink" title="7.2 WeakSet 的方法"></a>7.2 WeakSet 的方法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><span class="hljs-keyword">const</span> obj1 = {};<br><span class="hljs-keyword">const</span> obj2 = {};<br><br>weakSet.<span class="hljs-title function_">add</span>(obj1);<br>weakSet.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// true</span><br>weakSet.<span class="hljs-title function_">delete</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// WeakSet 没有 size 属性，不能遍历</span><br><span class="hljs-comment">// console.log(weakSet.size); // undefined</span><br><span class="hljs-comment">// weakSet.forEach(...) // 没有 forEach 方法</span><br></code></pre></td></tr></table></figure><h3 id="7-3-WeakSet-的应用场景"><a href="#7-3-WeakSet-的应用场景" class="headerlink" title="7.3 WeakSet 的应用场景"></a>7.3 WeakSet 的应用场景</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 1. 存储 DOM 节点，避免内存泄漏</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">"button"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button</span>) =&gt;</span> {<br>  weakSet.<span class="hljs-title function_">add</span>(button);<br>  button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (weakSet.<span class="hljs-title function_">has</span>(button)) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"按钮在集合中"</span>);<br>    }<br>  });<br>});<br><br><span class="hljs-comment">// 当按钮从 DOM 中移除时，会被自动垃圾回收</span><br><span class="hljs-comment">// weakSet 中的引用也会自动移除</span><br><br><span class="hljs-comment">// 2. 私有属性模拟</span><br><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    privateData.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 标记为"初始化"</span><br>  }<br><br>  <span class="hljs-title function_">isInitialized</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">has</span>(<span class="hljs-variable language_">this</span>);<br>  }<br>}<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Alice"</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-title function_">isInitialized</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="8-常见的一些陷阱和注意事项"><a href="#8-常见的一些陷阱和注意事项" class="headerlink" title="8. 常见的一些陷阱和注意事项"></a>8. 常见的一些陷阱和注意事项</h2><h3 id="8-1-NaN-的处理"><a href="#8-1-NaN-的处理" class="headerlink" title="8.1 NaN 的处理"></a>8.1 NaN 的处理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 注意：NaN === NaN 为 false，但 Set 认为 NaN 等于自身</span><br></code></pre></td></tr></table></figure><h3 id="8-2-对象引用"><a href="#8-2-对象引用" class="headerlink" title="8.2 对象引用"></a>8.2 对象引用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><br>set.<span class="hljs-title function_">add</span>(obj1);<br>set.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，因为 obj1 和 obj2 是不同的对象引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> })); <span class="hljs-comment">// false，新对象不是同一个引用</span><br></code></pre></td></tr></table></figure><h3 id="8-3-类型转换"><a href="#8-3-类型转换" class="headerlink" title="8.3 类型转换"></a>8.3 类型转换</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"1"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，1 和 '1' 类型不同，不会去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">"1"</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="8-4-遍历时修改"><a href="#8-4-遍历时修改" class="headerlink" title="8.4 遍历时修改"></a>8.4 遍历时修改</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 在遍历时删除元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">2</span>) {<br>    set.<span class="hljs-title function_">delete</span>(item); <span class="hljs-comment">// 当前正在遍历的元素可以安全删除</span><br>  }<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 1, 2, 3（会正常遍历完）</span><br>}<br><br><span class="hljs-comment">// 在遍历时添加元素可能有问题</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">1</span>) {<br>    set.<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加的元素在本次遍历中可能不会被访问</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="9-与其它数据结构的转换"><a href="#9-与其它数据结构的转换" class="headerlink" title="9. 与其它数据结构的转换"></a>9. 与其它数据结构的转换</h2><h3 id="9-1-Set-与-Array"><a href="#9-1-Set-与-Array" class="headerlink" title="9.1 Set 与 Array"></a>9.1 Set 与 Array</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set → Array</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> arr1 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set);<br><span class="hljs-keyword">const</span> arr2 = [...set];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1, arr2); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// Array → Set</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...newSet]); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="9-2-Set-与-String"><a href="#9-2-Set-与-String" class="headerlink" title="9.2 Set 与 String"></a>9.2 Set 与 String</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 字符串去重并排序</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"javascript"</span>;<br><span class="hljs-keyword">const</span> uniqueSorted = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueSorted); <span class="hljs-comment">// 'aijprstv'</span><br></code></pre></td></tr></table></figure><h3 id="9-3-Set-与-Map"><a href="#9-3-Set-与-Map" class="headerlink" title="9.3 Set 与 Map"></a>9.3 Set 与 Map</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用 Set 存储 Map 的键</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>],<br>]);<br><br><span class="hljs-keyword">const</span> keysSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(map.<span class="hljs-title function_">keys</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...keysSet]); <span class="hljs-comment">// ['a', 'b', 'c']</span><br></code></pre></td></tr></table></figure><h2 id="10-综合示例"><a href="#10-综合示例" class="headerlink" title="10. 综合示例"></a>10. 综合示例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实现一个简单的权限系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-comment">// 添加权限</span><br>  <span class="hljs-title function_">addPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 批量添加权限</span><br>  <span class="hljs-title function_">addPermissions</span>(<span class="hljs-params">permissionsArray</span>) {<br>    permissionsArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 检查是否有某个权限</span><br>  <span class="hljs-title function_">hasPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(permission);<br>  }<br><br>  <span class="hljs-comment">// 检查是否有所有指定权限</span><br>  <span class="hljs-title function_">hasAllPermissions</span>(<span class="hljs-params">requiredPermissions</span>) {<br>    <span class="hljs-keyword">return</span> requiredPermissions.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 检查是否有任一指定权限</span><br>  <span class="hljs-title function_">hasAnyPermission</span>(<span class="hljs-params">permissions</span>) {<br>    <span class="hljs-keyword">return</span> permissions.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 获取所有权限</span><br>  <span class="hljs-title function_">getAllPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>];<br>  }<br><br>  <span class="hljs-comment">// 移除权限</span><br>  <span class="hljs-title function_">removePermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">delete</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 清空所有权限</span><br>  <span class="hljs-title function_">clearPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">clear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> userPermissions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionSystem</span>();<br>userPermissions<br>  .<span class="hljs-title function_">addPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>, <span class="hljs-string">"delete"</span>])<br>  .<span class="hljs-title function_">addPermission</span>(<span class="hljs-string">"execute"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasPermission</span>(<span class="hljs-string">"write"</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasAllPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">getAllPermissions</span>()); <span class="hljs-comment">// ['read', 'write', 'delete', 'execute']</span><br></code></pre></td></tr></table></figure><hr><p>总之</p><ul><li>高效查找：<code>has()</code>方法的时间复杂度是 O(1)</li><li>遍历时按插入顺序输出</li><li>需要去重时，优先考虑 Set</li><li>需要快速查找元素是否存在时，用 Set 代替数组</li><li>存储唯一值集合时，Set 是最佳选择</li><li>需要存储对象引用并自动清理时，考虑 WeakSet</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-Set-方法详解&quot;&gt;&lt;a href=&quot;#JavaScript-Set-方法详解&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Set 方法详解&quot;&gt;&lt;/a&gt;JavaScript Set 方法详解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-关于滑动窗口</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/25943.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/25943.html</id>
    <published>2025-12-25T07:04:40.000Z</published>
    <updated>2025-12-25T08:06:02.161Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口（Sliding Window）是一种经典的算法设计技巧，主要用于处理<strong>线性数据结构</strong>（如数组、字符串、链表）上的<strong>连续子序列</strong>（子数组或子串）问题。它通过维护一个“窗口”在数据上滑动，避免重复计算，从而将暴力枚举的 O(n²) 或更高复杂度优化至 O(n)。</p><p class='item-img' data-src='https://miro.medium.com/v2/resize:fit:1400/1*Wl4bBtOCKkcVhVEcTCEh-A.png'><img src="https://miro.medium.com/v2/resize:fit:1400/1*Wl4bBtOCKkcVhVEcTCEh-A.png" alt=""></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li><strong>窗口</strong>：数据中一段连续的区间 [left, right]（左闭右开）或 [left, right]。</li><li><strong>左指针（left）</strong>：窗口左侧边界。</li><li><strong>右指针（right）</strong>：窗口右侧边界。</li><li><strong>滑动过程</strong>：<ul><li>先扩展右指针（right++），扩大窗口。</li><li>当窗口状态不满足条件时，收缩左指针（left++），缩小窗口。</li><li>每次窗口合法时，记录或更新答案。</li></ul></li></ul><h3 id="算法设计通用模板（以数组为例）"><a href="#算法设计通用模板（以数组为例）" class="headerlink" title="算法设计通用模板（以数组为例）"></a>算法设计通用模板（以数组为例）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">slidingWindow</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> maxResult = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 或 minResult、count 等，根据题目</span><br>    <span class="hljs-keyword">let</span> windowState = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 维护窗口内的某种状态（如和、元素个数、唯一字符等）</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; arr.<span class="hljs-property">length</span>; right++) {<br>        <span class="hljs-comment">// 1. 扩展右边界：加入 arr[right]</span><br>        windowState = <span class="hljs-title function_">updateWhenAdd</span>(windowState, arr[right]);<br><br>        <span class="hljs-comment">// 2. 当窗口不合法时，收缩左边界</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-title function_">windowInvalid</span>(windowState, target) &amp;&amp; left &lt;= right) {<br>            windowState = <span class="hljs-title function_">updateWhenRemove</span>(windowState, arr[left]);<br>            left++;<br>        }<br><br>        <span class="hljs-comment">// 3. 此时窗口合法，更新答案</span><br>        maxResult = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxResult, right - left + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 例如求最大长度</span><br>    }<br><br>    <span class="hljs-keyword">return</span> maxResult;<br>}<br></code></pre></td></tr></table></figure><h3 id="常见滑动窗口类型"><a href="#常见滑动窗口类型" class="headerlink" title="常见滑动窗口类型"></a>常见滑动窗口类型</h3><ol><li><strong>固定窗口大小</strong>（窗口长度固定为 k）<ul><li>典型问题：求长度为 k 的子数组的最大/最小和、最大平均值等。</li><li>方法：右指针移动 k 步后开始记录，左指针始终与右指针保持距离 k。</li><li>示例：LeetCode 209（最小长度子数组和 ≥ target）可变形为固定窗口。</li></ul></li><li><strong>可变窗口大小</strong>（窗口长度动态变化）<ul><li><strong>最大/最小长度</strong>：求满足条件的最长或最短子数组。</li><li><strong>计数类</strong>：统计满足条件的子数组个数。</li><li>典型问题：<ul><li>LeetCode 3：无重复字符的最长子串（窗口内字符唯一）。</li><li>LeetCode 76：最小覆盖子串（窗口包含所有目标字符）。</li><li>LeetCode 424：最多替换 k 个字符后的最长重复字符子串。</li></ul></li></ul></li></ol><h3 id="设计滑动窗口的关键步骤"><a href="#设计滑动窗口的关键步骤" class="headerlink" title="设计滑动窗口的关键步骤"></a>设计滑动窗口的关键步骤</h3><ol><li><strong>明确窗口代表什么</strong>：窗口内维护的是一段连续子数组/子串。</li><li><strong>定义窗口的合法状态</strong>：例如，和 ≤ target、无重复字符、包含所有所需元素等。</li><li><strong>维护窗口状态</strong>：<ul><li>使用变量（如 sum、count）、哈希表（Map/Set 统计频率或位置）、双指针等。</li><li>高效更新：添加右元素 O(1)，移除左元素 O(1)。</li></ul></li><li><strong>决定何时移动左/右指针</strong>：<ul><li>右指针通常在外层 for 循环中单向移动（保证总时间 O(n)）。</li><li>左指针在内层 while 循环中移动，直到窗口重新合法。</li></ul></li><li><strong>记录答案</strong>：在窗口合法时更新全局最优解。</li></ol><p><strong>适用问题特征</strong>：</p><ul><li>要求连续子数组/子串的极值（最大、最小、个数）。</li><li>数据具有线性顺序。</li><li>条件具有单调性（扩大窗口使条件更严格，缩小则更宽松）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;滑动窗口（Sliding Window）是一种经典的算法设计技巧，主要用于处理&lt;strong&gt;线性数据结构&lt;/strong&gt;（如数组、字符串、链表）上的&lt;strong&gt;连续子序列&lt;/strong&gt;（子数组或子串）问题。它通过维护一个“窗口”在数据上滑动，避免重复计算，从而将</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-力扣百题速练（Javascript/TypeScript）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39687.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39687.html</id>
    <published>2025-12-25T05:57:08.000Z</published>
    <updated>2025-12-25T10:04:24.830Z</updated>
    
    <content type="html"><![CDATA[<p>简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要过一趟，还有几天字节面试了都</p><hr><h1 id="1-两数之和："><a href="#1-两数之和：" class="headerlink" title="1.两数之和："></a>1.两数之和：</h1><p>给定一个整数数组 nums 和一个整数目标值 target<br>在该数组中找出 <strong>和为目标值 target</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标<br>你可以假设每种输入只会对应一个答案，并且同一个元素不能重复使用</p><p><strong>示例</strong>：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1] 解释：因为 nums[0] + nums[1] = 2 + 7 = 9。</p><p>直接用双重循环解，优化的话其实可以上哈希表</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) {<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) {<br>                <span class="hljs-keyword">return</span> [i, j];<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> [];<br>}<br></code></pre></td></tr></table></figure><hr><h1 id="2-两数相加："><a href="#2-两数相加：" class="headerlink" title="2.两数相加："></a>2.两数相加：</h1><p>给定两个非空单向链表，表示两个非负整数<br>每个节点存储一位数字，数字以逆序存储（个位在头部），要求返回一个新链表表示它们的和（同样逆序存储）<br>不允许修改原链表</p><p><strong>示例：</strong><br>输入：l1 = 2 → 4 → 3（表示 342），l2 = 5 → 6 → 4（表示 465）<br>输出：7 → 0 → 8（表示 807）</p><p>本质上是模拟竖式加法，从低位到高位逐位相加。由于链表逆序存储，正好从个位开始遍历</p><ol><li><strong>逐位相加并处理进位</strong>：<ul><li>同时遍历两个链表的节点，取当前节点值相加，加上上一位的进位（初始进位为 0）。</li><li>当前位结果 = (val1 + val2 + carry) % 10</li><li>新进位 carry = Math.floor((val1 + val2 + carry) / 10)</li></ul></li><li><strong>使用哑节点（dummy head）简化代码</strong>：<ul><li>创建一个哑节点，尾指针指向它，便于统一处理头部节点，避免单独处理第一个节点。</li></ul></li><li><strong>处理链表长度不等和最终进位</strong>：<ul><li>当一个链表遍历完时，将另一个链表的剩余节点视为 val = 0 继续相加。</li><li>遍历结束后，若仍有进位（carry = 1），需添加一个新节点值为 1。</li></ul></li></ol><p>提供以下 ListNode 类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params"><span class="hljs-attr">l1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">l2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dummy</span>: <span class="hljs-title class_">ListNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);  <br>  <span class="hljs-comment">// 哑节点，没有 dummy，直接从第一个节点开始构建，结果链表的头节点会在循环中不断变化</span><br>  <span class="hljs-comment">//需要额外判断是否是第一个节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">ListNode</span> = dummy;<br>  <span class="hljs-comment">//始终指向结果链表的“当前最后一个节点”。</span><br>  <span class="hljs-comment">//每次计算出一位新数字后，直接在 tail 后面添加新节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">carry</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;  <br>  <span class="hljs-comment">// 进位，当前这一位加完后，是否需要给下一位（更高位）额外加 1</span><br><br>  <span class="hljs-keyword">while</span> (l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span> || carry !== <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val1</span>: <span class="hljs-built_in">number</span> = l1 ? l1.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val2</span>: <span class="hljs-built_in">number</span> = l2 ? l2.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">sum</span>: <span class="hljs-built_in">number</span> = val1 + val2 + carry;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">digit</span>: <span class="hljs-built_in">number</span> = sum % <span class="hljs-number">10</span>;<br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br><br>    tail.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(digit);<br>    tail = tail.<span class="hljs-property">next</span>;<br><br>    <span class="hljs-keyword">if</span> (l1) l1 = l1.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (l2) l2 = l2.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h1><p>要求给定一个字符串 s，找出其中不含有重复字符的最长<strong>子串</strong>的长度<br>（而非子序列）</p><p><strong>示例：</strong></p><ul><li>输入：”abcabcbb” → 输出：3（子串 “abc”）</li><li>输入：”bbbbb” → 输出：1</li><li>输入：”pwwkew” → 输出：3（子串 “wke”）</li></ul><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp" alt="Longest Substring Without Repeating Characters - GeeksforGeeks"></p><p>直接上滑动窗口，结合哈希集合（Set）或映射</p><ul><li>使用左指针 left 和右指针 right 维护一个窗口 (left, right)</li><li>扩展右指针，若遇到重复字符，则收缩左指针直到无重复</li><li>每次更新最大长度 maxLength = Math.max(maxLength, right - left)</li></ul><p class='item-img' data-src='https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png'><img src="https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png" alt=""></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// 记录窗口内字符</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 左指针</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-property">length</span>; right++) {<br>        <span class="hljs-comment">// 若当前字符已存在，收缩左指针</span><br>        <span class="hljs-keyword">while</span> (charSet.<span class="hljs-title function_">has</span>(s[right])) {<br>            charSet.<span class="hljs-title function_">delete</span>(s[left]);<br>            left++;<br>        }<br>        charSet.<span class="hljs-title function_">add</span>(s[right]);<br>        maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLength, right - left + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> maxLength;<br>}<br></code></pre></td></tr></table></figure><hr><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h1><p>要求在两个已排序数组 nums1 和 nums2 中找到合并后的中位数，且时间复杂度必须为 O(log(m + n))，其中 m 和 n 分别为数组长度</p><p><strong>示例</strong>：</p><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><h3 id="最初思路"><a href="#最初思路" class="headerlink" title="最初思路"></a>最初思路</h3><p>最开始打算做双指针合并，使用两个指针 i 和 j 分别指向 nums1 和 nums2 的当前待比较位置（初始为 0），每次比较 nums1[i] 和 nums2[j]，将较小的元素放入结果数组 merged，并将对应指针后移，当某个数组遍历完后，将另一个数组剩余元素全部追加到 merged，合并完成后，merged 就是一个完整有序数组</p><p>然后就可以根据总长度奇偶性计算中位数：<br>奇数直接取第 (total+1)/2 个元素（索引 mid）<br>偶数取第 total/2 和第 total/2 + 1 个元素的平均（索引 mid-1 和 mid）</p><p>想了40分钟，但是复杂度m * n，直接寄了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; nums2.<span class="hljs-property">length</span>; j++) {<br>        <span class="hljs-keyword">while</span>(nums2[j] &lt;= nums1[i]);<br>            merged.<span class="hljs-title function_">push</span>(nums2[j]);<br>        }<br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; nums2.<span class="hljs-property">length</span>; k++) {<br>        merged.<span class="hljs-title function_">push</span>(nums2[k]);<br>    }<br>    <br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> ? merged[mid] : (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li><strong>外层 for</strong>：遍历 nums1 的每一个元素 nums1[i]。</li><li><strong>内层 while</strong>（代替 for，避免重复遍历）：在放入 nums1[i] 之前，先检查 nums2 的头部元素（nums2[0]）。<ul><li>只要 nums2[0] &lt;= nums1[i]，就说明这个元素应该排在 nums1[i] 前面，先放入 merged，并从 nums2 中移除（使用 shift()）。</li><li>这样保证了顺序正确。</li></ul></li><li>放入当前 nums1[i]。</li><li>外层循环结束后，如果 nums2 还有剩余元素（说明它们都大于 nums1 所有元素），直接全部追加。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <br>    <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入 merged</span><br>        <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>            merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);  <br>            <span class="hljs-comment">// 这个元素应该排在 nums1[i] 前面，取出 nums2 头部元素</span><br>        }<br>        <br>        <span class="hljs-comment">// 放入当前 nums1[i]</span><br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br>    <br>    <span class="hljs-comment">// 处理 nums2 中剩余的所有元素，直接全部追加</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>    }<br>    <br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> merged[mid];<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>暴力合并为 O(m + n)，但题目要求对数复杂度，因此需避免完整合并。核心思路是将问题转化为<strong>在较短数组上二分查找一个分区点</strong>，使左右部分满足中位数条件：</p><ul><li>总元素数 total = m + n。</li><li>中位数位置：若 total 奇数，为第 (total + 1)/2 个元素；若偶数，为第 total/2 和第 total/2 + 1 个元素的平均。</li><li>我们需要在合并数组的“左侧”选取 total/2 个元素（使用 (total + 1)/2 以统一奇偶处理）。</li><li>在较短数组 A 上二分查找左侧元素个数 i（0 ≤ i ≤ m），则较长数组 B 左侧元素个数 j = (total + 1)/2 - i。</li><li>分区条件：<ul><li>左侧最大值 ≤ 右侧最小值：max(A[i-1], B[j-1]) ≤ min(A[i], B[j])。</li></ul></li><li>处理边界：使用 -∞ 和 +∞ 填充空侧。</li></ul><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>确保 nums1 为较短数组（若不是，交换）。</li><li>二分范围：low = 0, high = nums1.length。</li><li>计算分区：i = (low + high) / 2, j = (m + n + 1) / 2 - i。</li><li>检查分区：<ul><li>若 A[i-1] &gt; B[j]，则 i 太大，high = i - 1。</li><li>若 B[j-1] &gt; A[i]，则 i 太小，low = i + 1。</li><li>否则，分区正确。</li></ul></li><li>计算中位数：<ul><li>左侧最大：max(A[i-1], B[j-1])。</li><li>右侧最小：min(A[i], B[j])。</li><li>若 total 奇数，返回左侧最大；偶数，返回平均。</li></ul></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <br>    <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入 merged</span><br>        <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>            merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);  <span class="hljs-comment">// 取出 nums2 头部元素</span><br>        }<br>        <br>        <span class="hljs-comment">// 放入当前 nums1[i]</span><br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br>    <br>    <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>    }<br>    <br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> merged[mid];<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要过一趟，还有几天字节面试了都&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-两数之和：&quot;&gt;&lt;a href=&quot;#1-两数之和：&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和：&quot;&gt;&lt;/a&gt;1</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于JavaScript链表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33314.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33314.html</id>
    <published>2025-12-25T05:00:48.000Z</published>
    <updated>2025-12-25T06:02:22.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-JavaScript-链表"><a href="#关于-JavaScript-链表" class="headerlink" title="关于 JavaScript 链表"></a>关于 JavaScript 链表</h1><p>链表是一种常见的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用。链表在 JavaScript 中广泛应用于算法问题和实际开发中。</p><h2 id="链表的基本结构"><a href="#链表的基本结构" class="headerlink" title="链表的基本结构"></a>链表的基本结构</h2><p>首先理解链表的结构：每个节点只知道<strong>自己的值</strong>和<strong>下一个节点的地址</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义链表节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-attr">val</span>: number; <span class="hljs-comment">// 当前节点的值</span><br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向下一个节点的指针/引用</span><br><br>  <span class="hljs-comment">// 构造函数，接受可选的值和下一个节点</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val?: number, next?: ListNode | <span class="hljs-literal">null</span></span>) {<br>    <span class="hljs-comment">// 如果值未定义则默认为0，否则使用传入的值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>    <span class="hljs-comment">// 如果下一个节点未定义则为null，否则使用传入的节点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="链表操作详解"><a href="#链表操作详解" class="headerlink" title="链表操作详解"></a>链表操作详解</h2><h3 id="1-获取第-n-个节点的值"><a href="#1-获取第-n-个节点的值" class="headerlink" title="1. 获取第 n 个节点的值"></a>1. 获取第 n 个节点的值</h3><p>在链表中，<strong>没有直接的索引访问</strong>（不像数组的 <code>arr[index]</code>）。要获取第 n 个节点的值，必须<strong>从头开始遍历</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取链表第n个节点的值（从0开始计数）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNodeValue</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span>, index: number</span>): number | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">let</span> current = head; <span class="hljs-comment">// 从头节点开始</span><br>  <span class="hljs-keyword">let</span> currentIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前索引</span><br><br>  <span class="hljs-comment">// 遍历链表直到当前节点为空</span><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-comment">// 如果当前索引等于目标索引</span><br>    <span class="hljs-keyword">if</span> (currentIndex === index) {<br>      <span class="hljs-keyword">return</span> current.<span class="hljs-property">val</span>; <span class="hljs-comment">// 返回当前节点的值</span><br>    }<br>    current = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 移动到下一个节点</span><br>    currentIndex++; <span class="hljs-comment">// 索引加1</span><br>  }<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 索引超出链表长度，返回null</span><br>}<br></code></pre></td></tr></table></figure><h3 id="2-在链表中插入节点"><a href="#2-在链表中插入节点" class="headerlink" title="2. 在链表中插入节点"></a>2. 在链表中插入节点</h3><p>在链表中插入节点有三种情况：</p><ul><li>在头部插入</li><li>在尾部插入</li><li>在中间指定位置插入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在头部插入节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtHead</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span>, val: number</span>): <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-comment">// 创建新节点，值为val，下一个节点为原来的头节点</span><br>  <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>  <span class="hljs-comment">// 新节点的下一个节点指向原来的头节点</span><br>  newNode.<span class="hljs-property">next</span> = head;<br>  <span class="hljs-comment">// 返回新节点作为新的头节点</span><br>  <span class="hljs-keyword">return</span> newNode;<br>}<br><br><span class="hljs-comment">// 在尾部插入节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtTail</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span>, val: number</span>): <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-comment">// 创建新节点</span><br>  <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br><br>  <span class="hljs-comment">// 如果链表为空，直接返回新节点作为头节点</span><br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> newNode;<br><br>  <span class="hljs-comment">// 从头节点开始遍历</span><br>  <span class="hljs-keyword">let</span> current = head;<br>  <span class="hljs-comment">// 遍历直到找到最后一个节点（next为null）</span><br>  <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span>) {<br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 将最后一个节点的next指向新节点</span><br>  current.<span class="hljs-property">next</span> = newNode;<br>  <span class="hljs-comment">// 返回原始头节点（因为头节点没有改变）</span><br>  <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 在指定位置插入节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtIndex</span>(<span class="hljs-params"></span><br><span class="hljs-params">  head: ListNode | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  val: number,</span><br><span class="hljs-params">  index: number</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 如果索引为0，在头部插入</span><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val, head);<br>  }<br><br>  <span class="hljs-comment">// 从头节点开始遍历</span><br>  <span class="hljs-keyword">let</span> current = head;<br>  <span class="hljs-comment">// 当前索引从0开始</span><br>  <span class="hljs-keyword">let</span> currentIndex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 遍历到要插入位置的前一个节点</span><br>  <span class="hljs-keyword">while</span> (current &amp;&amp; currentIndex &lt; index - <span class="hljs-number">1</span>) {<br>    current = current.<span class="hljs-property">next</span>;<br>    currentIndex++;<br>  }<br><br>  <span class="hljs-comment">// 如果当前节点为空，说明索引超出范围</span><br>  <span class="hljs-keyword">if</span> (!current) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 索引超出范围</span><br><br>  <span class="hljs-comment">// 创建新节点</span><br>  <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>  <span class="hljs-comment">// 新节点的next指向当前节点的下一个节点</span><br>  newNode.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;<br>  <span class="hljs-comment">// 当前节点的next指向新节点</span><br>  current.<span class="hljs-property">next</span> = newNode;<br><br>  <span class="hljs-comment">// 返回头节点（因为头节点可能未改变）</span><br>  <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><h3 id="3-删除链表中的节点"><a href="#3-删除链表中的节点" class="headerlink" title="3. 删除链表中的节点"></a>3. 删除链表中的节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除指定值的第一个节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span>, val: number</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 如果头节点为空，返回null</span><br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 如果头节点的值就是要删除的值</span><br>  <span class="hljs-keyword">if</span> (head.<span class="hljs-property">val</span> === val) {<br>    <span class="hljs-comment">// 返回头节点的下一个节点作为新的头节点</span><br>    <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 从头节点开始遍历</span><br>  <span class="hljs-keyword">let</span> current = head;<br>  <span class="hljs-comment">// 遍历直到找到值为val的节点的前一个节点</span><br>  <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span> &amp;&amp; current.<span class="hljs-property">next</span>.<span class="hljs-property">val</span> !== val) {<br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 如果找到了值为val的节点</span><br>  <span class="hljs-keyword">if</span> (current.<span class="hljs-property">next</span>) {<br>    <span class="hljs-comment">// 将当前节点的next指向要删除节点的下一个节点</span><br>    current.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 返回原始头节点</span><br>  <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 删除指定索引的节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAtIndex</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span>, index: number</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 如果头节点为空，返回null</span><br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 如果要删除的是头节点（索引为0），返回头节点的下一个节点</span><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>;<br><br>  <span class="hljs-comment">// 从头节点开始遍历</span><br>  <span class="hljs-keyword">let</span> current = head;<br>  <span class="hljs-comment">// 当前索引从0开始</span><br>  <span class="hljs-keyword">let</span> currentIndex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 遍历到要删除节点的前一个节点</span><br>  <span class="hljs-keyword">while</span> (current &amp;&amp; currentIndex &lt; index - <span class="hljs-number">1</span>) {<br>    current = current.<span class="hljs-property">next</span>;<br>    currentIndex++;<br>  }<br><br>  <span class="hljs-comment">// 如果当前节点为空或当前节点的下一个节点为空，说明索引超出范围</span><br>  <span class="hljs-keyword">if</span> (!current || !current.<span class="hljs-property">next</span>) <span class="hljs-keyword">return</span> head;<br><br>  <span class="hljs-comment">// 将当前节点的next指向要删除节点的下一个节点</span><br>  current.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  <span class="hljs-comment">// 返回头节点</span><br>  <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><h3 id="4-查找节点"><a href="#4-查找节点" class="headerlink" title="4. 查找节点"></a>4. 查找节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据值查找节点（返回索引）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findNode</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span>, val: number</span>): number {<br>  <span class="hljs-comment">// 从头节点开始遍历</span><br>  <span class="hljs-keyword">let</span> current = head;<br>  <span class="hljs-comment">// 索引从0开始</span><br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 遍历链表直到当前节点为空</span><br>  <span class="hljs-keyword">while</span> (current) {<br>    <span class="hljs-comment">// 如果当前节点的值等于目标值</span><br>    <span class="hljs-keyword">if</span> (current.<span class="hljs-property">val</span> === val) {<br>      <span class="hljs-comment">// 返回当前索引</span><br>      <span class="hljs-keyword">return</span> index;<br>    }<br>    <span class="hljs-comment">// 移动到下一个节点</span><br>    current = current.<span class="hljs-property">next</span>;<br>    <span class="hljs-comment">// 索引加1</span><br>  }<br><br>  <span class="hljs-comment">// 如果未找到，返回-1</span><br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到</span><br>}<br><br><span class="hljs-comment">// 计算链表长度</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span></span>): number {<br>  <span class="hljs-comment">// 初始化长度为0</span><br>  <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 从头节点开始遍历</span><br>  <span class="hljs-keyword">let</span> current = head;<br><br>  <span class="hljs-comment">// 遍历链表直到当前节点为空</span><br>  <span class="hljs-keyword">while</span> (current) {<br>    <span class="hljs-comment">// 长度加1</span><br>    length++;<br>    <span class="hljs-comment">// 移动到下一个节点</span><br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 返回链表长度</span><br>  <span class="hljs-keyword">return</span> length;<br>}<br></code></pre></td></tr></table></figure><h3 id="5-反转链表"><a href="#5-反转链表" class="headerlink" title="5. 反转链表"></a>5. 反转链表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 反转链表</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 初始化前一个节点为null</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 当前节点从头节点开始</span><br>  <span class="hljs-keyword">let</span> current = head;<br><br>  <span class="hljs-comment">// 遍历链表直到当前节点为空</span><br>  <span class="hljs-keyword">while</span> (current) {<br>    <span class="hljs-comment">// 保存下一个节点</span><br>    <span class="hljs-keyword">const</span> next = current.<span class="hljs-property">next</span>;<br>    <span class="hljs-comment">// 将当前节点的next指向前一个节点（反转指针）</span><br>    current.<span class="hljs-property">next</span> = prev;<br>    <span class="hljs-comment">// 前一个节点移动到当前节点</span><br>    prev = current;<br>    <span class="hljs-comment">// 当前节点移动到下一个节点</span><br>    current = next;<br>  }<br><br>  <span class="hljs-comment">// 返回新的头节点（原来的最后一个节点）</span><br>  <span class="hljs-keyword">return</span> prev; <span class="hljs-comment">// prev现在是新的头节点</span><br>}<br></code></pre></td></tr></table></figure><h3 id="6-遍历链表"><a href="#6-遍历链表" class="headerlink" title="6. 遍历链表"></a>6. 遍历链表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 打印链表所有值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printList</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span></span>): <span class="hljs-keyword">void</span> {<br>  <span class="hljs-comment">// 创建数组存储节点值</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">values</span>: number[] = [];<br>  <span class="hljs-comment">// 从头节点开始遍历</span><br>  <span class="hljs-keyword">let</span> current = head;<br><br>  <span class="hljs-comment">// 遍历链表直到当前节点为空</span><br>  <span class="hljs-keyword">while</span> (current) {<br>    <span class="hljs-comment">// 将当前节点的值添加到数组</span><br>    values.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>    <span class="hljs-comment">// 移动到下一个节点</span><br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 打印节点值，用箭头连接</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values.<span class="hljs-title function_">join</span>(<span class="hljs-string">" -&gt; "</span>));<br>}<br></code></pre></td></tr></table></figure><h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li><strong>动态大小</strong>：可以在运行时根据需要扩展</li><li><strong>高效插入/删除</strong>：在已知节点位置的情况下，插入和删除操作是 O(1)时间复杂度</li><li><strong>内存利用率</strong>：只分配需要的内存，不浪费空间</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li><strong>无索引访问</strong>：访问特定位置的元素需要 O(n)时间</li><li><strong>额外内存开销</strong>：每个节点需要存储指针</li><li><strong>缓存性能差</strong>：节点在内存中不连续，缓存命中率低</li></ul><hr><p>链表是重要的数据结构，适用于以下场景：</p><ul><li>需要频繁插入和删除操作的场景</li><li>不确定数据大小的情况</li><li>实现其他数据结构，如栈、队列等</li></ul><p>虽然访问特定元素不如数组高效，但在需要频繁插入和删除操作的场景下具有优势。理解链表的基本操作对于算法设计和解决实际问题非常重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于-JavaScript-链表&quot;&gt;&lt;a href=&quot;#关于-JavaScript-链表&quot; class=&quot;headerlink&quot; title=&quot;关于 JavaScript 链表&quot;&gt;&lt;/a&gt;关于 JavaScript 链表&lt;/h1&gt;&lt;p&gt;链表是一种常见的数据结构，由</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="链表" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-前端学习-关于JavaScript 实现哈希表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39960.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39960.html</id>
    <published>2025-12-25T03:31:39.000Z</published>
    <updated>2025-12-25T04:59:17.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-实现哈希表"><a href="#JavaScript-实现哈希表" class="headerlink" title="JavaScript 实现哈希表"></a>JavaScript 实现哈希表</h1><p><strong>哈希表</strong>（Hash Table，散列表）是一种通过键（Key）直接访问值（Value）的数据结构，通过哈希函数将键映射到表中的位置</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 简单的哈希函数示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashString</span>(<span class="hljs-params">key, tableSize</span>) {<br>  let <span class="hljs-built_in">hash</span> = <span class="hljs-number">17</span>;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-built_in">length</span>; i++) {<br>    <span class="hljs-built_in">hash</span> = (<span class="hljs-number">13</span> * <span class="hljs-built_in">hash</span> * key.charCodeAt(i)) % tableSize;<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="用-JavaScript-实现哈希表"><a href="#用-JavaScript-实现哈希表" class="headerlink" title="用 JavaScript 实现哈希表"></a>用 JavaScript 实现哈希表</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 哈希函数</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX_LENGTH</span> = <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(key.<span class="hljs-property">length</span>, <span class="hljs-variable constant_">MAX_LENGTH</span>); i++) {<br>      <span class="hljs-keyword">const</span> char = key[i];<br>      <span class="hljs-keyword">const</span> value = char.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">96</span>; <span class="hljs-comment">// a=1, b=2...</span><br>      total = (total * <span class="hljs-variable constant_">PRIME</span> + value) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>;<br>    }<br>    <span class="hljs-keyword">return</span> total;<br>  }<br><br>  <span class="hljs-comment">// 插入键值对</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index] = [];<br>    }<br>    <br>    <span class="hljs-comment">// 检查键是否已存在，存在则更新</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>  }<br><br>  <span class="hljs-comment">// 获取值</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>];<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-comment">// 删除键值对</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取所有键</span><br>  <span class="hljs-title function_">keys</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> keysArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!keysArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>])) {<br>            keysArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> keysArr;<br>  }<br><br>  <span class="hljs-comment">// 获取所有值</span><br>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> valuesArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!valuesArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>])) {<br>            valuesArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> valuesArr;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialCapacity = <span class="hljs-number">8</span>, loadFactor = <span class="hljs-number">0.75</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = initialCapacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span> = loadFactor;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>  }<br><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> hashCode = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <br>    <span class="hljs-comment">// 处理不同类型的键</span><br>    <span class="hljs-keyword">const</span> keyStr = <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span> ? key : <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keyStr.<span class="hljs-property">length</span>; i++) {<br>      hashCode = (<span class="hljs-variable constant_">PRIME</span> * hashCode + keyStr.<span class="hljs-title function_">charCodeAt</span>(i)) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>    }<br>    <span class="hljs-keyword">return</span> hashCode;<br>  }<br><br>  <span class="hljs-title function_">_resize</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> oldBuckets = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> *= <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bucket <span class="hljs-keyword">of</span> oldBuckets) {<br>      <span class="hljs-keyword">if</span> (bucket) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> bucket) {<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">set</span>(key, value);<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-comment">// 检查是否需要扩容</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_resize</span>();<br>    }<br><br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index] = [];<br>    }<br><br>    <span class="hljs-comment">// 更新或添加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">const</span> bucket = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index];<br>    <br>    <span class="hljs-keyword">if</span> (bucket) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> bucket) {<br>        <span class="hljs-keyword">if</span> (k === key) <span class="hljs-keyword">return</span> v;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(key) !== <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取负载因子</span><br>  <span class="hljs-title function_">getLoadFactor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="支持任何类型键的通用哈希表"><a href="#支持任何类型键的通用哈希表" class="headerlink" title="支持任何类型键的通用哈希表"></a>支持任何类型键的通用哈希表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniversalHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 通用哈希函数，支持多种类型</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'number'</span>) {<br>      <span class="hljs-keyword">return</span> key % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span>) {<br>      <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-property">length</span>; i++) {<br>        hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + key.<span class="hljs-title function_">charCodeAt</span>(i);<br>        hash = hash &amp; hash; <span class="hljs-comment">// 转为32位整数</span><br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'object'</span> &amp;&amp; key !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 对象使用JSON字符串化</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key));<br>    }<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希解决冲突</span><br>  <span class="hljs-title function_">_hash2</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key) % <span class="hljs-number">7</span>);<br>  }<br><br>  <span class="hljs-comment">// 使用线性探测开放寻址</span><br>  <span class="hljs-title function_">_findSlot</span>(<span class="hljs-params">key, forInsert = <span class="hljs-literal">false</span></span>) {<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">let</span> step = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">undefined</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到键</span><br>      }<br>      <br>      <span class="hljs-keyword">if</span> (forInsert &amp;&amp; (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">undefined</span>)) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到可插入的空槽</span><br>      }<br>      <br>      <span class="hljs-comment">// 线性探测</span><br>      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>      step++;<br>      <br>      <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Hash table is full'</span>);<br>      }<br>    }<br>    <br>    <span class="hljs-keyword">return</span> forInsert ? index : -<span class="hljs-number">1</span>;<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">true</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = { key, value };<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> index !== -<span class="hljs-number">1</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">value</span> : <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 标记为删除</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="使用-JavaScript-内置结构"><a href="#使用-JavaScript-内置结构" class="headerlink" title="使用 JavaScript 内置结构"></a>使用 JavaScript 内置结构</h2><p>使用 Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 最简单的哈希表实现</span><br><span class="hljs-keyword">const</span> hashTable = {};<br>hashTable[<span class="hljs-string">'key1'</span>] = <span class="hljs-string">'value1'</span>;<br>hashTable[<span class="hljs-string">'key2'</span>] = <span class="hljs-string">'value2'</span>;<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-keyword">const</span> value = hashTable[<span class="hljs-string">'key1'</span>];<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> hashTable[<span class="hljs-string">'key1'</span>];<br></code></pre></td></tr></table></figure><p>使用 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 Map 是更好的哈希表实现</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 设置键值对</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'name'</span>, <span class="hljs-string">'Alice'</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">42</span>, <span class="hljs-string">'The Answer'</span>);<br>map.<span class="hljs-title function_">set</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }, <span class="hljs-string">'Object Key'</span>);<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'name'</span>)); <span class="hljs-comment">// Alice</span><br><br><span class="hljs-comment">// 检查是否存在</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br>map.<span class="hljs-title function_">delete</span>(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// 大小</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>);<br><br><span class="hljs-comment">// 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>});<br><br><span class="hljs-comment">// 清空</span><br>map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>使用 Set（类似哈希集合）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用于存储唯一值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复，不会被添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>);   <span class="hljs-comment">// 2</span><br><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>选择合适的哈希函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 更好的字符串哈希函数（djb2算法）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashDJB2</span>(<span class="hljs-params">str, tableSize</span>) {<br>  <span class="hljs-keyword">let</span> hash = <span class="hljs-number">5381</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) {<br>    hash = (hash * <span class="hljs-number">33</span>) ^ str.<span class="hljs-title function_">charCodeAt</span>(i);<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % tableSize;<br>}<br></code></pre></td></tr></table></figure><p>优化冲突处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleted</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'deleted'</span>); <span class="hljs-comment">// 特殊标记删除</span><br>  }<br><br>  <span class="hljs-comment">// 二次探测</span><br>  <span class="hljs-title function_">_probe</span>(<span class="hljs-params">index, i, tableSize</span>) {<br>    <span class="hljs-keyword">return</span> (index + i * i) % tableSize;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希</span><br>  <span class="hljs-title function_">_doubleHash</span>(<span class="hljs-params">index, i, tableSize, key</span>) {<br>    <span class="hljs-keyword">const</span> hash2 = <span class="hljs-number">1</span> + (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash2</span>(key) % (tableSize - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> (index + i * hash2) % tableSize;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>频率计数器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">frequencyCounter</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">const</span> frequency = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) {<br>    frequency.<span class="hljs-title function_">set</span>(item, (frequency.<span class="hljs-title function_">get</span>(item) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> frequency;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'banana'</span>];<br><span class="hljs-keyword">const</span> freq = <span class="hljs-title function_">frequencyCounter</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(freq.<span class="hljs-title function_">get</span>(<span class="hljs-string">'banana'</span>)); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>缓存实现（LRU Cache）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 哈希表 + 维护顺序</span><br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value); <span class="hljs-comment">// 更新为最近使用</span><br>    <br>    <span class="hljs-keyword">return</span> value;<br>  }<br><br>  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>      <span class="hljs-comment">// 删除最久未使用的</span><br>      <span class="hljs-keyword">const</span> oldestKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(oldestKey);<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value);<br>  }<br>}<br></code></pre></td></tr></table></figure><p>分组算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">groupBy</span>(<span class="hljs-params">array, keyFn</span>) {<br>  <span class="hljs-keyword">const</span> groups = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) {<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">typeof</span> keyFn === <span class="hljs-string">'function'</span> <br>      ? <span class="hljs-title function_">keyFn</span>(item) <br>      : item[keyFn];<br>    <br>    <span class="hljs-keyword">if</span> (!groups.<span class="hljs-title function_">has</span>(key)) {<br>      groups.<span class="hljs-title function_">set</span>(key, []);<br>    }<br>    <br>    groups.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">push</span>(item);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> groups;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> people = [<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> }<br>];<br><br><span class="hljs-keyword">const</span> groupedByAge = <span class="hljs-title function_">groupBy</span>(people, <span class="hljs-string">'age'</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(groupedByAge.<span class="hljs-title function_">get</span>(<span class="hljs-number">25</span>));<br><span class="hljs-comment">// [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }]</span><br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><div class="table-container"><table><thead><tr><th>操作</th><th>Object</th><th>Map</th><th>自定义哈希表</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>遍历键</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div><p>最坏情况（所有键冲突）会退化为 O(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-实现哈希表&quot;&gt;&lt;a href=&quot;#JavaScript-实现哈希表&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 实现哈希表&quot;&gt;&lt;/a&gt;JavaScript 实现哈希表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;哈希表&lt;/s</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-JavaScript / TypeScript 语法速记</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/23505.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/23505.html</id>
    <published>2025-12-25T03:19:07.000Z</published>
    <updated>2025-12-25T03:23:33.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-TypeScript-语法速记表"><a href="#JavaScript-TypeScript-语法速记表" class="headerlink" title="JavaScript / TypeScript 语法速记表"></a>JavaScript / TypeScript 语法速记表</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// ES5</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;           <span class="hljs-comment">// 函数作用域</span><br><br><span class="hljs-comment">// ES6+</span><br><span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;           <span class="hljs-comment">// 块级作用域，可重新赋值</span><br><span class="hljs-keyword">const</span> z = <span class="hljs-number">30</span>;         <span class="hljs-comment">// 块级作用域，不可重新赋值</span><br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 基本类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"Hello"</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">bool</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">undef</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">nul</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sym</span>: <span class="hljs-built_in">symbol</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"id"</span>);<br><br><span class="hljs-comment">// 引用类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-built_in">object</span> = { <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">func</span>: <span class="hljs-title class_">Function</span> = <span class="hljs-function">() =&gt;</span> {};<br><br><span class="hljs-comment">// TS特有类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">anyType</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">"anything"</span>;      <span class="hljs-comment">// 任意类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>];  <span class="hljs-comment">// 元组</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> { <span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span> };    <span class="hljs-comment">// 枚举</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">unknownType</span>: <span class="hljs-built_in">unknown</span>;           <span class="hljs-comment">// 未知类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">neverType</span>: <span class="hljs-built_in">never</span>;               <span class="hljs-comment">// 永不存在的值</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">voidType</span>: <span class="hljs-built_in">void</span>;                 <span class="hljs-comment">// 无返回值</span><br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 算术运算符</span><br>+ - * / % ** ++ --<br><br><span class="hljs-comment">// 比较运算符</span><br>==  ===  !=  !==  &gt;  &lt;  &gt;=  &lt;=<br><br><span class="hljs-comment">// 逻辑运算符</span><br>&amp;&amp;  ||  !<br><br><span class="hljs-comment">// 赋值运算符</span><br>=  +=  -=  *=  /=  %=<br><br><span class="hljs-comment">// ES6新增</span><br>??    <span class="hljs-comment">// 空值合并</span><br>?.    <span class="hljs-comment">// 可选链</span><br>...   <span class="hljs-comment">// 展开/剩余运算符</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 函数声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">return</span> a + b;<br>}<br><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">const</span> multiply = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) { <span class="hljs-keyword">return</span> a * b; };<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">divide</span> = (<span class="hljs-params">a, b</span>) =&gt; a / b;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHi</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hi"</span>);<br><br><span class="hljs-comment">// 参数默认值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name = <span class="hljs-string">"Guest"</span></span>) { }<br><br><span class="hljs-comment">// 剩余参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>) { }<br><br><span class="hljs-comment">// TS函数类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AddFunc</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br></code></pre></td></tr></table></figure><h2 id="类与面向对象"><a href="#类与面向对象" class="headerlink" title="类与面向对象"></a>类与面向对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {<br>  <span class="hljs-comment">// 属性</span><br>  <span class="hljs-attr">name</span>: string;<br>  private <span class="hljs-attr">age</span>: number;<br>  protected <span class="hljs-attr">species</span>: string;<br>  <span class="hljs-keyword">static</span> <span class="hljs-attr">count</span>: number = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  }<br>  <br>  <span class="hljs-comment">// 方法</span><br>  <span class="hljs-title function_">speak</span>(): <span class="hljs-keyword">void</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sound"</span>);<br>  }<br>  <br>  <span class="hljs-comment">// Getter/Setter</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">getAge</span>(): number { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>; }<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">value: number</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = value; }<br>}<br><br><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {<br>  <span class="hljs-title function_">bark</span>(): <span class="hljs-keyword">void</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Woof!"</span>);<br>  }<br>  <br>  <span class="hljs-comment">// 方法重写</span><br>  override <span class="hljs-title function_">speak</span>(): <span class="hljs-keyword">void</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Woof!"</span>);<br>  }<br>}<br><br><span class="hljs-comment">// 抽象类 (TS)</span><br>abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {<br>  abstract <span class="hljs-title function_">area</span>(): number;<br>}<br><br><span class="hljs-comment">// 接口 (TS)</span><br>interface <span class="hljs-title class_">Person</span> {<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>  <span class="hljs-title function_">greet</span>(): <span class="hljs-keyword">void</span>;<br>}<br><br><span class="hljs-comment">// 实现接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> implements <span class="hljs-title class_">Person</span> {<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>); }<br>}<br></code></pre></td></tr></table></figure><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 数组方法</span><br>arr.<span class="hljs-title function_">push</span>(), arr.<span class="hljs-title function_">pop</span>(), arr.<span class="hljs-title function_">shift</span>(), arr.<span class="hljs-title function_">unshift</span>()<br>arr.<span class="hljs-title function_">map</span>(), arr.<span class="hljs-title function_">filter</span>(), arr.<span class="hljs-title function_">reduce</span>(), arr.<span class="hljs-title function_">forEach</span>()<br>arr.<span class="hljs-title function_">find</span>(), arr.<span class="hljs-title function_">findIndex</span>(), arr.<span class="hljs-title function_">some</span>(), arr.<span class="hljs-title function_">every</span>()<br>arr.<span class="hljs-title function_">slice</span>(), arr.<span class="hljs-title function_">splice</span>(), arr.<span class="hljs-title function_">concat</span>(), arr.<span class="hljs-title function_">join</span>()<br>arr.<span class="hljs-title function_">sort</span>(), arr.<span class="hljs-title function_">reverse</span>()<br><br><span class="hljs-comment">// 解构赋值</span><br><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> { name, age } = person;<br><br><span class="hljs-comment">// 扩展运算符</span><br><span class="hljs-keyword">const</span> newArr = [...oldArr, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> newObj = { ...oldObj, <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };<br></code></pre></td></tr></table></figure><h2 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 对象字面量增强</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">"John"</span>;<br><span class="hljs-keyword">const</span> person = { name, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };  <span class="hljs-comment">// 属性简写</span><br><span class="hljs-keyword">const</span> obj = { [<span class="hljs-string">"key"</span> + <span class="hljs-number">1</span>]: <span class="hljs-string">"value"</span> };  <span class="hljs-comment">// 计算属性名</span><br><br><span class="hljs-comment">// 方法简写</span><br><span class="hljs-keyword">const</span> obj = {<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>; }<br>};<br><br><span class="hljs-comment">// 对象方法</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj), <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(obj)<br></code></pre></td></tr></table></figure><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Promise</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Done"</span>), <span class="hljs-number">1000</span>);<br>});<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error))<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Complete"</span>));<br><br><span class="hljs-comment">// Async/Await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> data.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> result;<br>  } <span class="hljs-keyword">catch</span> (error) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  }<br>}<br><br><span class="hljs-comment">// Promise方法</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2])<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2])<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1, p2])<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([p1, p2])<br></code></pre></td></tr></table></figure><h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) { }<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> { }<br><span class="hljs-keyword">export</span> { var1, var2 <span class="hljs-keyword">as</span> alias };<br><br><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;<br><span class="hljs-keyword">import</span> { var1, var2 <span class="hljs-keyword">as</span> alias } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;<br><span class="hljs-keyword">import</span>(<span class="hljs-string">'./module'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> { });  <span class="hljs-comment">// 动态导入</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 模板字符串</span><br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>, you are <span class="hljs-subst">${age}</span> years old`</span>;<br><br><span class="hljs-comment">// 字符串方法</span><br>str.<span class="hljs-title function_">includes</span>(), str.<span class="hljs-title function_">startsWith</span>(), str.<span class="hljs-title function_">endsWith</span>()<br>str.<span class="hljs-title function_">repeat</span>(), str.<span class="hljs-title function_">padStart</span>(), str.<span class="hljs-title function_">padEnd</span>()<br>str.<span class="hljs-title function_">trim</span>(), str.<span class="hljs-title function_">trimStart</span>(), str.<span class="hljs-title function_">trimEnd</span>()<br>str.<span class="hljs-title function_">replace</span>(), str.<span class="hljs-title function_">replaceAll</span>()<br>str.<span class="hljs-title function_">slice</span>(), str.<span class="hljs-title function_">substring</span>(), str.<span class="hljs-title function_">substr</span>()<br></code></pre></td></tr></table></figure><h2 id="类型操作-TypeScript"><a href="#类型操作-TypeScript" class="headerlink" title="类型操作 (TypeScript)"></a>类型操作 (TypeScript)</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 类型注解</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 类型别名</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">ID</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = { <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };<br><br><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><br><span class="hljs-comment">// 交叉类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Combined</span> = <span class="hljs-title class_">TypeA</span> &amp; <span class="hljs-title class_">TypeB</span>;<br><br><span class="hljs-comment">// 类型断言</span><br><span class="hljs-keyword">let</span> str = (value <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">let</span> len = (&lt;<span class="hljs-built_in">string</span>&gt;value).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// 泛型</span><br><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T { <span class="hljs-keyword">return</span> arg; }<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generic</span>&lt;T&gt; { <span class="hljs-attr">value</span>: T; }<br><br><span class="hljs-comment">// 条件类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 映射类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = { <span class="hljs-keyword">readonly</span> [K <span class="hljs-keyword">in</span> keyof T]: T[K] };<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = { [K <span class="hljs-keyword">in</span> keyof T]?: T[K] };<br></code></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Try-Catch</span><br><span class="hljs-keyword">try</span> {<br>  <span class="hljs-comment">// 可能出错的代码</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Something went wrong"</span>);<br>} <span class="hljs-keyword">catch</span> (error) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>} <span class="hljs-keyword">finally</span> {<br>  <span class="hljs-comment">// 始终执行</span><br>}<br></code></pre></td></tr></table></figure><h2 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6+ 新特性"></a>ES6+ 新特性</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 解构赋值</span><br><span class="hljs-keyword">const</span> { a, b } = obj;<br><span class="hljs-keyword">const</span> [x, y] = arr;<br><br><span class="hljs-comment">// 默认参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span></span>) { }<br><br><span class="hljs-comment">// 剩余参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">...args</span>) { }<br><br><span class="hljs-comment">// 可选链</span><br><span class="hljs-keyword">const</span> value = obj?.<span class="hljs-property">prop</span>?.<span class="hljs-property">nested</span>;<br><br><span class="hljs-comment">// 空值合并</span><br><span class="hljs-keyword">const</span> result = input ?? <span class="hljs-string">"default"</span>;<br><br><span class="hljs-comment">// BigInt</span><br><span class="hljs-keyword">const</span> big = <span class="hljs-number">9007199254740991n</span>;<br><br><span class="hljs-comment">// 动态导入</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">'./module.js'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> { });<br></code></pre></td></tr></table></figure><h2 id="常用数组-对象方法链"><a href="#常用数组-对象方法链" class="headerlink" title="常用数组/对象方法链"></a>常用数组/对象方法链</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 常见处理模式</span><br>array<br>  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">processed</span>: <span class="hljs-literal">true</span> }))<br>  .<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>)<br>  .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr.<span class="hljs-property">value</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="实用代码片段"><a href="#实用代码片段" class="headerlink" title="实用代码片段"></a>实用代码片段</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 深拷贝</span><br><span class="hljs-keyword">const</span> deepCopy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">const</span> deepCopy = <span class="hljs-title function_">structuredClone</span>(obj);<br><br><span class="hljs-comment">// 去重</span><br><span class="hljs-keyword">const</span> unique = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)];<br><br><span class="hljs-comment">// 对象合并</span><br><span class="hljs-keyword">const</span> merged = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj1, obj2);<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">const</span> merged = { ...obj1, ...obj2 };<br><br><span class="hljs-comment">// 检查空对象</span><br><span class="hljs-keyword">const</span> isEmpty = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 延迟执行</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">delay</span> = ms =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br><br><span class="hljs-comment">// 节流防抖</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">func, wait</span>) =&gt; {<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {<br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">func</span>(...args), wait);<br>  };<br>};<br></code></pre></td></tr></table></figure><hr><h2 id="DST"><a href="#DST" class="headerlink" title="DST:"></a>DST:</h2><ol><li><strong>const &gt; let &gt; var</strong>​ - 优先使用 const</li><li>**=== 代替 ==  - 严格相等判断</li><li><strong>箭头函数保持 this 绑定</strong></li><li><strong>模板字符串代替拼接</strong></li><li><strong>解构简化代码</strong></li><li><strong>Promise 处理异步，async/await 更可读</strong></li><li><strong>可选链和空值合并处理 null/undefined</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-TypeScript-语法速记表&quot;&gt;&lt;a href=&quot;#JavaScript-TypeScript-语法速记表&quot; class=&quot;headerlink&quot; title=&quot;JavaScript / TypeScript 语法速记表&quot;&gt;&lt;/a&gt;Jav</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-15-杂谈-系统问题</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/48096.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/48096.html</id>
    <published>2025-12-15T03:51:13.000Z</published>
    <updated>2025-12-25T03:23:33.852Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="请联系站长。WXID:Zhong_ye1" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">      <script id="hbeData" type="hbeData" data-hmacdigest="0fe04ed3253505b79224da0782c7301b1a65468396bfb850e5b4276f548f74ee" data-keysalt="d345c470c4bd5fcb85dc3a08f10b505ae22f6dce2d87928e361c4767c55979f2" data-ivsalt="79b1f8add64b32954165c904db16980d33da243d79d545170dc6436cbcbdb819">        f59bf7a7e5ff14c074b28ad633918e4513a83f1bf27d972f1f9fce7cc8dcec87ed736a41472fa1a809c29d6f65cb9ba4ed78162a14c4a389ff8b96abf6705884c75b855f2101850ce1e870de0aba90c18e6be9272b5e6764a3298b29b3d1cd527ed68f63d17975f371ca042f4a3a3c6615c19f479c5ff06b844f0d132e60c84ca02ea9ee6fce6623a7d056450fef07e326f6c4262bab4b900b0c4d6f0ee90bdc1cca75933c4076d7716aa8ac7d12432e192d34dd9ec0fbaf6af3e607575d8cdab0a2917a5e40f7cf2a003f1e070451711438948373dbc0ef13c18d947f51b47ff5163b7e15858ae9534d0e74f3d12b09e6d3e5e484748cc54346adaca545530ade8f02f56e40aae8f1c7a566d5e94a76deca3ed9bf58c6b14f6f65bfd51d8714bddec83b7e23543281cbce484907073f99a4acfd9031446b2e29fc0c81b83a4a8597f1cd0e18ce75103e25df17a2e874e3c291c7870fcdd2cec8f43a6429ac8e21373a8f58d9b0ea66147040c326d753862793c77ea9a0c5289daafb0e6170ab62ca1e9f833b7fc4fa340b510ad849dde41f3a2328ef745801e13268d04d84cb9dc45bf0e0960635f751fb5fad74c621129fd274fa520f8e9bd78238363db8e279eec095637ef71325b9259a546d67b07b710358e8aeb0a008e4abf25899059bc4a4d0dee81d8956b9b4007e4924e387c10118f667905776122b3d04fb3b3290ad5360137e24b06f0e3d9ab98f9e877c341ea5e083ae8351aeecd2395a5880dc1a5ddb6d8e606f0a29e24df61990fe8ba4ddc74cc76fb566b594f933295704eb069d2da5d249c3e38657ceb2b1266f280f87d2b2034f328137336d309188cfff38249f50077fc3cc15df6c39bc27c93efbc55175fbdee1b472f1e7ccb42fc70efa48aacba33b42131bbd05d63ed81dabaf1aa7b2d158f32f56762dfef56d277dc1e32f2e969e63e4a7d9deb8c5668290def6a2658fe5d7918edb192b88e4dd3eb3a3d4885500e0882c11613a66b9b7f50e74824b8e31cdd60c2781537b8ee47e7572d1717159cfcb4d4696715444fa2e86cbe8f2a9c8dfb4e6da3debcb7c5634c0bf57322f6472d9fa24364de60a9a7e71e4a52f009b037e78aad05faf548f95547d0132cf6296357b1c0ded0b45d652373149b69e6cbae5da62ed69f9babbffa0fad3f418c682d2d347d7bbc936e1f792afdc6f7347e8cf1f68813d8bb2bd12bf87e3dbec25157c078280395b206bababd16967f34643dc5204d657baa7115eb11706df6d5051123d8b4142d93a40543b2be32b795f1faaae03fa485d120fdab922f7789ce611b1565fd3c504a8a65fec15a0f95cf3ac9d1c251f6523349b04682fde3067c16b3cfda47e2e259acabaa8c50d3d30b30e0e27d90a8694ab138657cae5f9b6505d865696c41df260938591520aed1ce3ff8e9eb76e001b93755930eef0abe100d7f935cf1490adaf6fa7a27733a78fb842975b93e969017acc5facba4b5a6a7e8aaf13c7196aa210e0c1278ecc88b6c1660e03c77e23df0c768249b269ec7906108556dbdb0581689f12b09ff3211adf69fc1d6ea753fb022e4371fb17e600126d04d87ca661dc4347cbdbe9217b2e86c0c24a559304e3214448bc7b51bc5ba7463204bc8b915cb20e0fc743964a06993baa40c9d2f07604da990855bab94870d0b43b6f0a9aefcc121f63fe06b25149beeb358fe00fe7de6008a4cbb67f26aabedd6f9ed2d18082e35c91a7bccde5f50d7743bc9da1c1c23bdc294d2d2e48c2213bc273f5cd16858a1730ede237b1fab949fcb39fb418240b923f6b224194d75aab0691bff295ed170bcb3935729f60c8cf41cee4bbadc59bd09c207816c1401eb2c0ed0edd15c08c4e981a3f26adfbbdbbdb5435515a2eb5bc12bf9e842a24d42854b3f24780c18701060423d9f16852593d9d625c27434fcfec8b2090e89704402e3f7306d5a27145260c6e5f6a8c040366e6cbfe308bb8e052f5c8763193951025773d68c705d0d68708b5583f3d6f0c94b47982e428b55e9b1a44720d86ed97f93bd8b23202e504d58521ea1bd1b70d24c6e6fba067b3ac9174f92997e339b6d54db57548581ef84573fe8130655d2aae2a6d479c7a0554046bf849bbc8e55e66ec2712eee365d29cf450cb2402da9dba130d8060e1231c6569f8f75d18ebf1e3a93c5f959a6436c2615426caed5aa75df59f95745246910ece7c773dec72184c3aa01d3c56a6c7d47c47e2477c3f93a00790122d0f0e2594410bbb626e2510a856d8a13f5451b4677bd897b47379db1b8c728c7140bd34f5799ea76f9715ecdefca495218e7eafcff4e897d7bd7275511a1a24883396da342d6ff3b2964888f24c762a086a17c3b07895c10be7d82ea6227bca22aa7cf0c8050ee2ad22768d288884c7178a9cc1bf89521ee8cbc8ce3a222c95e0532e0be6e4f3c419c5b682f1ff6472945f294e5d74cfb60889a838768b0100610c6697fd336115868157562ac613e00b969624326bd4dc63746cb239b7ccba4b2a2aed07534c6a0351f4745efde5aca393e290e6fb6879321bad23db6c48bf4b9f1b5d1926f0888787849cffe851b1ef61d3bd2479bda8b59a56b2e61f6c0ce29d9e3a002e888b4eff8ffb7bd91c194de386ff9ea532ac8fd42a39af851cafaf1bd4b54d1893b7fc45b7b25df5cd656deaeee5be7de93df8542cd2f77ee421e1a9a4d2a5534f37cf77990186aa5b21034e0e439c14a63788d74588435c1fa0ce4482acfc1d2c79cc57effcbe9518e6dfc4492fb0233818148f0eac1c5b90d6302bf1f14478e22fcf8e44f5ba9608ad42b20c6c38f147706413f7054b737a167f41bdea7b57a6bdf67c5fd1c664d956ac950b202dea17f61af51c4b106c15d60c1f501cc64590854b977b2181e7b344bc9836813fc2f1f15a4dd78f91c69039baa2b355f0d5c5a9ea6b7635793495a27e5d37feff1c6979e3b0ec6abebe9828a28366ec0fceb6ffebfa9d8ea44534a889e112687641be4343470c5c28500df17299b8856708c967315fb86276cfb5b82f59103620f87dcff5c4edf8903a8be18a8e0690c45f636d377b3928e2553e342fa3f1b906c41ac71a8709e71f8ad813b34deb92ba5ac0e0904a40400d31033e75b642d975888349d234cdfc29d05b15817d63faeea8e6f3ce9bff13852aba13b749d826516a23d6f72165d0dc3a4284504c8000e0f78f713b641e1b5a706a65d102b546dc725c09c52c39af7e47d4b6c1353991fe7eeda8e745a632092ef006ffe0b608c3e48eea5c2c0af616c2221da5a6021922eb964d2c6696773c9761536f8e123b879222f3de514efe7e9344231345c99829bcbc6549306f39d6fed36f371d553a49b61a34ef1306ee1c7bf9aeae4bd1a0da81add6919cdcdd196190011acf58562a3d866154ff2d62702ed85e72843185065f7708da7ec0920a23c0d0578e3d2e98f81b7ffacceee2ff291c20f1ededfc9a43f3dcf3bf027f997602b0bcecfa4665036f9630569b67deea39f534e173d204e4d5f59e63a81cb3bd41ce948dd8c1b932c66a10249dfced32c5a0e48af2523e0e2946460fb77b41b8985973f211a6286b33780948939ebfa8c95a3bba3b02aafc6cef8570cde4d00c0d3ab3d154f0740dd7fc6e39666ee821f0459be3ae82c1337aebc1f2fffc7f48b35be9f80c71d20c49aa73ef9c69696b21905584e9ba730d9989cb41e5d2821cf0fe5f025b15396003c4c9edb3fa63a2010e494214e742bbe06402934a95e8b78ca1c683248f6ea0ad607a5ca7305e4b699abdf9565bb4a646a811fe6cfbe106d61896f6208b6066d723c5295ac4776733ee82d9760ff04915f98571303647fb98b7e7fb0b92543eece2968d7e7c97db049017256dc025d7b33d9b06aa07f67f04757b986362fb065d03b158b5d896633e33b26ee8e32dc176d2caea8a821f70a3a4d5efe4f91b45db8f4f53faa4295cf0105c9addfca68afc97444b7b3c125920f05f6b84439684e02d2087cadb9c3dbce954930bec1571643cfc11802f9288aaeb97aeff661cc6127e79bf365cab93132f353a1428faee5c6cef2e8093766fed1a3888ad2eeceb84d4325c48b003781073847322f27a85cd2f685a00d73a4910aab8c063cbbb730d90893b293a6b91d30feb4b75ccb24a5e0b1b022b0b08c2df8b3ce9075c8c946469ea8b973e31cf47030b3c2403a7199ee96afecb2f8de4b25d3e459df7af0327a2bc023dbb098a00df6fd429ac340bf18ade5a7085b48bfd21fb2c623d5ca85590c7842774e1b3d43f744408fc54faf1706bc6f5f8333369ab3627ea86e50ac3040db03663fd834241dff193207e699cb556d177b05e7e404216037e3227f41854f2eb143e3736744a8521951b63398441d51503c175dee45d0ff2a7de0014e6ce391c8a1559c1abaee32768a39db1b1746c52e92003eb7da52b41c43aea625b65c124f2d38399a0de29ce71adb5abcb4ad1d34d5d50f8de1412eda612a227e52ca89949a8890ca7cd2f307d0c4c35b37f4c4d4a92d0e97b1ac09ad0a26a51b0c25d1f53de04d1b4ba2d0ce3fa328814714c92de371b5504bf17b6da423f8058157a631da62ecbcbcdaf753c5a0f801ced37c747b200d40a59e6d00cb35c738571bed75c2a1986c5c74dfc49b035531f0ae5ecdc07de74c512c4e41537212c90f732024d0ed40b3db7bc457761297b9de65d4169e4f84bc1d68d331d19254b44640e6f81d4fa77786ab02ccb065d48f94f102427b38c55ed63680f4ab05eb3b488f60ccaebd59735086273188535af683600fbaada76c22dc1d5a0da416c1e6955488e3de1a7643189d5c995179e74d46738d6037e05765331c3078d81bc0fcec4e796fbb1afc98ee6ca8cc2023d9f7819ec0d70c88ba5b9adf9f86891f6e90a632c634347440fa356edf785af47db54d636228f81089b8f10f9cb0fad7c208124e97cea590c5f7df3f50d53959b2a3c64433c52eb268db5b7760f179a90f2aa72a3c6ea59b0aa9152fcfd2b684f375480d4c95064be3bcbe6d1550fd513d59c20b0d11de82056508a35423501dcfbe1ab0915afd53976f6785cbc5b6076c6def2a1c4c8f676f8188ddf221884b3a25c6cba7d4ebcc8e3caac4e0d5f6ebb253e38a0d46f1dd253a91edfca8640407b205b184b045fd9c7274e0587d1d66b17ada1ff429b28c8855e241cd21d55dbbf12de6d00e533f65476a63bb80a2a75ca17a38ac85580cd873f566420d2c95b9f3b60b310de509a53f07897aac5aee245e5fc554d91dd081950975ee9d87e67d45cfad68772dcf3c7d212e54b20de9c30fb206051201a14d422d9fccf9eb3d41c3e032a26c879c49b120bbd5fe1c13dbd91ee4a004159bbe525451b835b37e458e2fc34532516fdaf17e2fb92f8704c3ea708349e70525978f9c3f8d2568dae29d0cdd58d2b6ab3f4a6a44b1f77197e5ad6fe5e9e8a8d4148423fd911b2980eb0876465df2e10a6686f001666a64748d52ba8ac6e899d4c9e8b980e5d2ff742510c5679edf07ec243fbda3b7801a33d51f248686117784bf861585e09f961bbdab8708f884ece39046fa4dc90a99acfe370126acaecff3e71fd625fe7fc5e2f9511a11c701c0694d7282d7b0117fa3cfd1b1f391c7705ea54dedf5028fb3657dbe74b77f4b6e96235bf09cf97f3c59869c69250b5e4996231e1b49e1b92f17887e9707f352d1c9a73abb9d8946525789c1dc3e0052d3c1672460e6e5f402ded957264752a4c838ea836bf3b115c65b1bcef30b5e6425afb7d6683335dfd5cf65e2792795aa56a086c52e1bf426f97d8db72ee6dcbfd4b103c2f8fb71e40dd467efccb3a0b42c1c4a59a3fb18cdd58dfac0375eaedd8da583ded5e73456d6a863c68020ed9a49884440bf1b260dc918da370bf0434ab3814b7c57a49c7c67c9b28204199481f712ed702d2aef0436d709b2d51d22e3233c625e8d391b889afb70cb07bbdc03dee7d4a518aefcca3e2528430d5a4dc54c7a6fe6e1535591da1c4c6273a9bb43eac5ffc6af3dc52fbe55b3a681b867f25bc73dbcfadf99caeb44c3b58ca53be17443c9d97f1e5f4c18876c3fbdb4e7fc819f588f74b5433959e292e5da018b68c9fa336a08c9583e01d9e6f5d3b0b19d116301a97dde78488bfd35b0a8a452162ddf9c8550fd3fc66dd9daa9116cdd2b58292dbcc643953a7c706ef6094c87a50bd6dddc9d3139ee72d18404a45068888faf6946751f0ba36d3bccaaeba7cab1f0e9ffc49291491979331b07fcb836faead0edb5cc3f213e3db86855dc399d6b18a241d38f5412de60794e9b8aadbb616702e8d1011fc973e51e4a07f84721ae1dae838c33c1fcf095139953080cb996252fcb2ec4c55451b3386d292fb2fed392fbc722679c1918b1adb875bbdf3f198103695ad89b113b6052595e1c00ec2f221dbf51fd9f47998340caa4465c6cff650b2f1a6724b6798a5089dfbaeb07181417738985157d3bafe5b65de5c9e11027f87b45c49a40c10837b6c38fb155a223c30f55968d03f69de95bed6f8bf12f7d7c48e6d6adcf8e68432d08dbda839b31e2e2f0f5a38608269896a58c327f7ead896cd17e86d0deaad4399e786512bc7a9c87948ff1df2dcf91fdbb6e5b451ffe063251a198cc86e185d5e3c5a0516b685b72ac55a82e403df16ecfc05757418e5cb25b48dee84829dd71423b5489274f9db95d60430ce700d6af5add5fb88f14dc96bfb87e9051240361aad3b709121804503fc8751c30e2c02c4bcff5f1fc3966c1240cad4dc69ab84d91943020f10f21065103c9ed81f1ec4d5fd22cc93119cd688b67942c0ae0944d52550eeca86628bc216e0d870eda3cc831d76ee7d9f37e03403aac8e533fb0a1b8a686b53f251b33d58cb317e7c54c0dfab4975998343b939245516615c5031cf6b21ea0a37259cc26c62cd9e8ea7c31fbb7e4d5ab9156c878cac0fc81fede2baf4472a77fe7b6e4b8a73920bb7e5958abe1a7bb1edd7de63dac61146f9df4ab64e1068ebe0711e8c3c47477ea1a388c5dea8379a140a7cbfb5af359671edc33d65c85e3a4ec2baaad626af1803a2aef4dbeb91005a2e7e0f4788e6c91212d8f1312eae72d90fffc3f777963c21ff1a7dc869f077f51365821c5e6b28151e596d1f9099c6fd7a8cfacf72aa164aa71f55c07c8664805955aea4b98d9bf275bbad0848941625540b86a70a30d8f39a6678b8d2fd806514cf70eadc41b1cc6694fad15353fb89f9bc3692ef0c361a4d45f6360a2e91a38569e8cb06cc756c43e36fde69cc59ac64113a8d0bc4a7a5e6713a9f76465e3f8fb01abf6a25cc4a559c835f6deeac7d54f1618253d5ec5ceb59357e3b30e9631dd909eda2f4ee59f8be88a517bd0fe21bd12d90f4b472c732f3f99820b6f2c5ff783681eb5a3121dc8ca5dceb524f96af5a8b946a53a7b03e0c7dc7dfa517265fde1c518913e1b8894d78ca0fd8c5188da367665e92216504968ad62b132add1cb6bce45f2b02c7f82dbaf513a97f5815a7e5b9c8f081ff4b96e3e2e4b65385da8fbf78de7a607b735ed577c20077aba42ea881759fa7f4e153e5e4d85da7f603c80eb1740eb16f7714ab95fa5a8311bb54e3053a77f97fecb463cd32a5054106ff0a97313a09d4390c83028ff6f1032abee4f2fba0fa6c356538bca17d16544f6ef0336dfa8a115f82a9912a4688a02263e51d8976b4301816b1829a3d04a7b465e2d88fd707153420851ead92e4bd512ecb3159b06dfcbabc4a42c9decb88372be8395b035e79c32d2f1d9eac7663356673c83d37a921444796a48a76ebdbca17dd30baaf3c7caee0c96e995f9b894445cac05a7537a28d3a29b997fd4a4a7ac6148d001b6b91d790d45ff032aa847d2d053f81bda3b368bd6353cb467677fc8c6ff2cfd951e4fc2b2d3e66f57451b61a44cc78afd9138ec82a713ce4ded2b5bb82c1c4fd60abbbc0cccc783ee55b548d2d8b67f1d72b0e053001f6862f5da28c156c6f656c0250f7d6d30c03ed1a8a22b739ef962b360d7bc454ad3da530b79d58841f61875d6725b2c3ec65a86a0e49842552ad2432a198e6449fcec56f710440ec933491f69e1e2b1d92901bf14b0c09aeb29977f3ae9efe55cc62cc5408cdba0bcc0e08663cee0e48823729552c4fc4f5f73d390f4e76267f3327f30f9376aebeffaf3d01d22122b5562036c5199c7035020b5998ddb9e327f798510db9396b1291244f37a226eb7e9274e49ebaa49161bbbf6367705615ca85fcfc4c61045b72bb446d4f1be20e10a3f58491f4ddde563d501ef3f30af0b20257a22ad9e68bd9730e650a856bfe32264b087eba49aa0ebaf70279a2ed2238f596b28c851e3a84f6df08816a6e1fecb3a6adb92567f0062c7ed6fb3c1a22b4235bb9d8647dc5119c357af0dc38e7e00a1099a5bd6e9fdc9d3047a1f554f8d02402b0acf07da4d8c07eac81e5b9545749328c6c650e204b3c9c69c2d0d9e68b3050cba95c03b4ec2d2159b08e66b9b6a211a3c1bde8c8f38798fdc4518911f90c3b455edff791cf61e633d489494193d251d581ea9d819b0bf084917d6d7677923da698a9a2a90bf7e4cb1283fcab7de0315a403567cefb2cde62548fc2f6ef196b22a504d0114cc040fbc39e965d185f199fc3be2fa44b18b214a05fec0d33fe06338510870e765b3e77711fb294db9d537daa91834a7bc71985d7d414f4af87001cdf29eccec7ad7c4a17cfa0c4cd25078521db1821dc76a211297c9cb68016847299b4d9f9c75c892c28b3c44c2d5801aaa954fdf00f6cc34a190fa54354ccb4c3f7fe0a6704b813378613598922a490d89b875e9545bcda0366e836de8793d8a1285699dd901109532e8b06d2e03f4739500362945e36d133ec0f163006adfe4069e7c0d65147de28209a539ffc28241351741c42abf4c28c13f479e6e536002a59696869587bea9dd0fb28c4e29b5db71deaaabc4b4791fbcbdf3e0e0acc6d620092c34d4a6dface04eb3c2817c290563e73d8b44a8a4e00a47ddf0dcfa66f3d320cc0a240cb15d73310f8568fe947e9392a93bd86628831d2dbcbdcee975ef2a1c98faefabd7c1b2580ab09ea8f9162add21f8ff94b941de4ffd66579b99f86e227e4a5aad4ca0b2b8f9a680f715a75aee96b050b09384b51c060846f259b88697ff0326e3d290f029140b294028e1145346a9d2f90800f0cde85cfc4570a504ad9d0dab4adcbf35234c24a9b5eb0ccdcc94e3e2db5d9d863c0aa7818bec637859e53ed71cbf45389a198eacaf1ccece7a7eec31a0739b3a2f755b837a42abf3a86d807ee7d9436d78bf7d181b3fd294722f18b0455f9fb0c105401e814ab10cfeaf8685b3ba11a8dab4276610cb1651c5b54ff228a6befc3c1e7b50a004f67b68d3a16489870dd0275f0cf65d7647d5b026c46bd789d7ddb96daebdf9c35a83a83ba57a8fe82c634298eb6f92974f41c3f57fda4aabaafb39f7a865022fc80260f27eeae317c1a71859e2dab4e2e764dcc012f12e994ece3d29e9243b46d7908cdc78b58138bf73b0e5ff40afe9adf9e00c661e252fe8d35cbf3e419637f90564d1de83667cabf68e316716980797caefcf98eb2ebacafd5a0dbeb5e316dfeaf8ef616fb1752dcd6922dd6c01ca101df9815fbb7531aadaeba6a314ecc7eb30804ce6262b53e3932f6e73d3a53f0f7405549cae829230a8e8784da497165ae6417d0e8ef8ea64753df17b21708d17a4d0c52cd8987cdf6f35cf5245c3c21c552c392abe3c5defd6ae96f448fad031f789a718bb541463d3064ee1f9fdb08c5513a518dfd71c1006777036ac19aee0cc53ee22b625a349cdd6f1cb8edb97de7f40dd0cbde4660e52be8efa177586ef3e376d49f074f8da345d46e99973e33cea7fb7b856fa95facba6c3512468831d7a18a5ad03d389742fede0bc938ebfe62708c630f8b8ce5ae3249c80a0c979c08a5c1b6c38c5b3735c1bfe1f9f0553225480c24f6c1658366b898efb9c48bc2669a2e85cbd72eb6ead519bd9171467e0e87db84629db19c61b3654188f0f9cfa0861af2a53dcec0653a41b9fd60dd423f099650f550d61ea269b3e18ee111f1665a3fd3d13222fcb7413249a102449bc8c12747633c873eb3cc9688c65ff72ad7d6ea7b4164e5eae5cff44bbc74fba101f7b545e45190edca26b6d77fb9c6fca58f2da2c804ea9c4aad1cefca12629062e68444d0753a704a4be93f753334abb0ac572b457fa9d9e6ec0488e48aebc769efd91b499f45a964e32004f60b7a6addc475bab4e3bfba38507482a808a3443f26628da2cdb57d662f5fa6b15acc75f626f00dd672193983501028787ead5f7bc3168550810fabdb0b97090553b25b11a6b2aee38799fb12e9114d4fc37c525ae5a8823a1cd3303a2ec8ddcfa66b83abb501849e4a85f458ca2093921dc7d40529ba4c3966173a63ca4c6e394d08c47c3e67b48e2d19416079f4d461ffaa37e7633c6179f964cc956ef95a178663955eeb3efe9ef2c83c68938dcae56c06bdb0329be875850ec6281a99f306cd09b3cf1d1ad995878cbe56c5c19e3d7bc6ec9553ee708e5770974dbe9348ac55946694b24a9ff5b999c0febe2c6a8198eec21f4dc4ec08d444ba4de00fe1c1e83d4c1953ac76a73422ee5a94634c6da58a5ef50f59d738d19ca6afe3265b6a49ced1d3919cfe192e0ca9b7b91cf255a0a0d60db1e171b7db7ab27da42c848d4157f96e3ddfe5b7dba58524bb20ba18f465c05f0a344ea3cb4a5084eb821aadae025078cad9ff82cc06ea2bfcc4e69bb50916aac31adcbc97e5ba37c38132cb558e563987adba9488ef3e45022020377e6cf5d4b5931eb36f5646778d0319edbfe69574adc61e7726fbc88cfee7158c0664d1dd1c577fdd8a333f4e9521cca115736ba9392617e1e89246498e7e0eb60b6ce2dbbef08e8ca25334a9884114632eed4a53c49ff813d9bf8327b1dc1d77bd11a5ce62408ea5c42fc1f54c2f2c74848e5f605a2869da6e59518e7e591a178636229f56437e4b632a37786a581b81f6298770e6a73cacc9a9f40f4cca2e8c9ffb4b37171b0b237c098b75b4cb0c90d0c896477e72d04efa3821b2bed37a507716d5dd7bdfa9f7c381d395de81c006653ba014e3fcbeeff31bf284f8fd4fdfdc366ae33b0ee9aff7584a1e9725ce052c05f79e0d5f9a9f3390bd6ab3dbf0fdb02313cb39ca86f3827e5e5eff0863f0f5a434ed99508607a4f4e0af4bc6df0a5aa77bc99135c6b66674a81205cae367e7cae0762308bdb768610bb547c40d9869b74bbb1a7369c6bb68d69b1cc38dd0fa1eaaab552b341195b5db754f9b8e7a8de90aad930e2e0cadc92579e1aa90e69cbcfe37ce63be60f01d1cdc0583fc0afedfc190bed30d68c274cea69296407487af8264be9bebe5f9ff756bd3277ac4ecc8b72a063fd2940703251ff0c7ba1d39800ed254188815779a89386a3bf305176f0051dae87670f3f3d2515ff4f4a24075847506182641080269f1fbaa73e58539b05635b8126cffd61d260e56b3113cdfbc83ee781a601ab62b7f4b1d287c6bc42da4bb3de03f94a021205ed39bbfb41094db86430b350294df0d42b4b28e68e3e842d7eb241ec7966b5b110a189d3b5a156a69ebac384dea663340f2ed2e120e08ef4e959982a333535d9ae2d9028eaeb12c8a530b0b8340fda59bc0f6901ece9d4ed88a5358497197272b86d176be3d61bbaacd02d36d6d7e2e36bfcbb503bd42cd208fbc847e27c0bda4d6a84b3298c60d5271056981b6ba26c5481dd94fb3f60107b8ff4900d9748101d503f6c810ae564b21989add56f508e7876c64d2b201527d154aa1405e77e4c1c26eab913fa05bfe3e1922108c2f6f7a6bfe0faa39431b851c1f83234fe0de512c1be0c98746fae32d67d978321390365e437f3f90fc0dd78b3c333dec5108f1c4969cc24d73096244f117fe383eaa829cbfc0bba3d8fa4fe618e907bf39782b0e722371168cb7f227033118b0927b6cfc661e16ce6e7c5f00b07d64fc6b45b7d0c0b3b67005ebd963047cb23a54360ac2e1d92f41125410b9e7a76cd7df2890f190f283f4be259109761921468d4aa021ed821e580027babb45f1c3b84c178fe54e7ac595d786291f85bf8b0733051d6869bf52bebe93e3d1a949bb5e1d7cf828ac512e522bc50e39ebec55f82f8e60f2a04e5bbcd8e4a2a03fc90fe9751fc1a45bbd54b71ed5c8ea6f1219928ad7bb4adab8cf66a764fd58157d69335c37f71eb54df8259ecd2ac4648995a16c0e99d697ff8ca9c87ed4b17e7deb78cc945f530481edf8f46a06d7cc3b1a7dade9c0c1fa49cac7b0ec15c742d9be214b6afed7d33cfc08fc7c3bf9a5c070fcc6104e59c874f6266bcbe79ca6f00a76a418cd7eecbdda170bf95d65cecffd66c060653241126481a2213188c5866eb09e86ffe941e2129bb099132e875a5b8e8597c538ddc77f381a0b1557dccaeae6e3660616a000773331d7f7a2d7af5e5d929c6d2094b219afc9bc766ed1b1c87012e40a837e0d684f9569d1ec88918fee75993d476e39952f741b081ab25acf451740b5bd1a11ef64de364149385a7f6c27fad6ddff71f6887d11f268557f01cff1a48a4b44dc6820871c97daa8196601ae267df1e6245eae93d90561f9a9be1732d479f670dd706996a6616c9dafd392321b7a876b7352d218931915cd66663748d84b61bb998880b90e48a7771333738456fda1fe10d6b52b412fd6c39633d231b159a85a8be0c3873c48f44595e4cb07086e768abd4009eca8f0787b59b6d34e37013befdfbe00a5af091dfe1a0aec92ec831fd4f27bb5efbad957be03d08e303e6b3e0aca9df33c257e21c49795434f21b2978692ac20693497c7166e6addc8b0d9a9f2aa5abc4f7980ae37a752fb89dd5136d533b245a64f730eea7326c4f3870a361748b56e3919f2f0d64339665f62a3eae271c498ae20c04e73a6021616da01c875996a29b12f28eeae84dccd579f8a92ecbd0cfa43d1e94bfe530f3df71c238692dcc5302935fa42abcede2b7c35d765daafbc9a5e6f34f8b9e4f817d871142dbfd6d82063c4556277f9f6ae63e50320323d50393c363fa28378fc256d3d93485bb78632a560a0990a631e47a883bb27806ae4921780f467fbbca11aa25505208263497c0f0f7b2c73537566295113d6e3c6f237d3b3bb1a4bef07e166616b51b7146cd1250ceb26ed5c64a43257432bdccd21f4e43acda44b77c1d3293c793965372318b78142415a19a0b1ad78ce11382752168d7a2e77950601d593b90b8a98fff036c50079557b8c719dc81b940105e9ff5c551e8b52e86b90065a5093e2b34fe3e84d1f63988ff564774c32ae1c404cc6d5c72ea3487fa8d213b9194fa4b2ddaba5dc9ca166a593d896e4a2d41e06f7f9dc983c51180973c1bb496896d39fb3cc7d8cc0ba7bb2ccf98a83f6e315d9b736bd3cde950c5e26cb111941286443051aee5a5a350faabb6a3fdd2a4569906c436ab75f5784325af77e77c6081db9510bae188a975fbef5450111c01f3e4f10874ac0491ac1679ab6bd5257ecd303f2b120fde4913a3a71d3c1b6e39ff767251f22fafb5e628c137cf34c77a098c4522335798397c3820be827158c8531e4586ca4d2523228d5205f4123bcaa00d922e2e7aeb4e3447e5b58598e099bc3d7a66f90c83788634fad9d74bcec95a12bd3e3ad17b7482fee93d1629ba6e1f6bf70b1271350c5df41216703b5c84109e7e2f91b896935ad18050f0f8ee6a1da3dc4e0900feed540207bea0bf6192e9de2a3af6f50af9f8ec679c4dfabb1b03bf694dc943f88ff07876bf01fc4373e57d1a6f95bfd3f6fa14ea83e5a83643b82d8d0288753d2810ec14ff9751c284b274bf3292e742277cd45b9f1cfc672b0a49e65ae644d6d3fae09cc437bff636caa61f3544e68140dfdbc3557de13cf1d6a2f9eef29f6723b2764578a122a81da3ffeade730de27b137f75842f463858851453543020cdcb04b6624f4904c72c8ffd11955151792ee23695739702f0e703e9f2b1ae546599bab374274e9c613771ee4a866015b9a3f3925b608666b2fe71861f434fdd4f9f32eac08ad67618e569dcdb4a1b3e51b815438d62a15113de2b56cf5ccc7d18b1121632e2434017ca2717e5619025f815c805dd42ed372a57a6350c7343169a65da9c1305edd13b700e1bcde328d6edb2021332f53c3d6b04f46980d0b44dd3a021bd637a9f837a41694a17ea571378aa796cec4e084f69d01f13e9a359c584e85349ae4b1554d90fe37fdd2e645480cc2fbac973227dce2a9c175e5110c44ece385d0d167fdd4b95da66eeb90295433ab44f39913aa608c2ffd330df684bb3bddc5630d334c9a6b06d88b50611d87a1d28dd742beb9e4db4fe0b88e5c22c87e60c570209639a478b3209dd3387cf24c441f20c5ce7b386a15e3c59db12f0f709d717f9a3f42ba401d89e7ce60f69e9c84b06e5b59257e524f6fd302fe9e4144a8ff306ad9f5e9d55ec3e1ea7ed762e172f56a7cba693eec1fc84fe4905c00e7488adf1d64bc250eeb1f27f0c02c849ddfc3c9b9c99ec33f9fd0c4c90a84374a6f4db5046b22b7a1d824fcfdca64046a6b6b08a06371c9b0cbc00a02f7165d8f61faf9b8df31566b6449b94415ac80d5e864c2a8737baf294bb507fff6dd155ce3ad324ed7891805a824624f0f507fe5d4aef13d19e9603d9e99ea90f1ed29e7d0c9709b2beb3f10118b03ce587c11a4c8c3d2dc2f11c3ffd259ccc2475bba3ed6150d11f6babca1d467d4bb17bc9ee3f78c90f3fd4349a451eb8a6ca1053743b6a6116038cda4e7f60d48f547d1b9c0277092801552a3f43075bc9a247f188f262845afad3c35717ab2a125ef3a02c2957688c56d79bd1878d5bd73ff07cdd432b7d5e1c30b4e4e81a676146da2d8580474fbf1994445e968bf7d55b670fc8e4d535bbb6ce62641cce669b8548d1f55723e2bb72ee507285ceda37c32c79c0de055c394a5f29f8f873d470867f7aa896e5bb5330a715eae72dc94a2cc765751c90429177abf1f5a07cf7349cdcc91d626b6d9998264c224957e18fb6cd2432d902428ad02dfdd1b5454dee1b43a75cf11431f54fa495998c06dd73c872513c2c3c72b302dca34890483b11b72bfbebfc7152b04dc76780e48d2018edc2633f093eeb2b3f90664556724e16ef1d170546dea029ca7e35cb8ebaa5386b9090792ae5589e11e3086f12404647d0969266d822a5b8dcaba8d3583e31cc365deee3527ffba6a4fcc086dbd9d304306ef2b9e86b53c0f30f1a3ece7735cac0d28d8506e0872b93038e901b1d40e614b4053311abad3c2cdec2ca83f200df61c85aaf3c4edfe85a3327465a160e51f98ee3417e16846f9e41adb87a6d8ea195d36b71f1a0a5c517d79ab70d4b0fcdb6163ba0036796e028e4eeb2e0fe1e46d17327658d8835cafb625b669411a48685ec830e7cf7d24d0e36c4282444c916888647e23dfe8094057ae330c7727121743d278e404e625d76a0e265d8101023cff2d027989763237a7a4b3a8eac6a323c9030c18f50017a1486b853474b79b100d512f74ad3daf9d33d4e2bb64681b7650ffe2d71eec2e32a04d2bc994802ca3dae37f9f094d84f21694f735e008ee217bd257544fecacf912683fa3eb8e2a40663e840237b904c3b47602c99c07349c58bef3aea60f9bce1154f7454d7860c555cb13b226bf021dbc3cf320aafcf76cacdee258fa8f9a70f17a9936b8ea416d4808369e83aaa1fc3ff40e37df79b6237462c08acc9e63ab91d515198cca656330a68b73e8528aa03ee246a71dac95a540acd6332330abaf48ad68f9447f37b2ec7046ce0c8365f836d9dccd3e180e4b9e8781808a14253b31cc97692f5e6eb76544cde24c0f9e201ed35286eeeac0cdab23f47502deeac5ad77fde7284257586e9398758e49f66f3ae3ae6fd2250153d31497cda8e993ef054cb5841188aba75a55faee56627e6210ce91880f4e2362df8cb41b87f522d5f3c2430ee00e89983792b2654e33924b3889c49f5dd24c25ce9cc0084ae58bd2021224c58f970da96849400863abb083534322a7b231918c4bcf83e9bda089750c9a7e0ce7a88cbb9bc3ebae86c342033a5dfba2c49307c9b7fd4cb8750a7dc01f3ae1b684d6087cc430fa4905594eebd763f05b24eb402375a0dab9d8bc9bfe1f89a5db845d9cfeaf66b17fce56aec97a13a282d18326de5f6f2ad1ec5791034bd09cf176c21797617ecb4520f9f41ab2904c85cb35bd069c0a675e0248ee3cb3b65e0c5900e06ecef7dfbee0a9710a962f785af706a969fb5fb4586173e2ba82defb486fd16099955b9394724550ae285709a8a55df75d2cafdad9018360a0c0ca7d78be79399aab6b0cb9c7a3b18c98ffe75a13528d6628131d0a6a8e7be0da31fc09ccbf37bbaf71d1c514a07800ba424ead8880bc1b6263d80317fa3c6094966c9fee7de8e8a0aa1af2540b3ef49e8347eca4ce5466f115d12333da6c46752d9405bfd53d553ccb68908f133dd99f830a3c28f946dc4f5b7b1e532a2f393b77cf03bd2e8b11b91ab3ee4306fb2a70eca5bf0c676aac106724af1ba3d790644109a96c9b639517555375780b538c9dedc9e19fdb70d4972029787bf924f1ef5aca53a0185f7107ff0a4782d8dda05a6d47642c32c4d55a991110dc784a605f3140f200624a6c40a2397d4261e4a4e94d695fac64fb1bc16f0b37406cd777f018f13cb7445e4b28b4cf9a645632275e82250db2c45ecbcd4a4a8dc8d576854f1b7a4b4a04e8ab08d2aac59cc937f019f847652e8c64b5edb8df546a581f3266a06cf27ee5f53d4227734b04af0c4a80a7173f37f94e69d9b0e83679164483ad6264917640601f2bdbb57095510a03b30bdf90b9ac80de9784c91b8e650d3d2ee3dd6b7d90bad80f65f9b8d0fcc1658e4631c5457dcc8dfdd6a48b1f33a63dc59e4f456723af66327d9b7aeb9e98c6f117dcf6ae6a0deaaf97fe02a37fdd715a32f52f670f47014afd4718c25a17af8c60dd2c47783829b6cdae070282c5b31f1ca8b7d20654b5bb07dfdf10f11fcb8373858efb3a02a03d4e50b29e733c85d466f2272239eff11feaec221ac21ad1a79c31d330f617caf0f8d795e38d7a92cce6f06b28ea7578870288703be708402c99949d8a5a3c8fe9e78efd57049a5d9f1d5eff4f30a350d4ba257bef8bd52736e30596198395107d8200fdc4a86d015df0ae873e912fb91da40b4d6d1dcb5d43bfbb672ff0b97e11486569981fe2c9e9a680e5718922f00e396d338dcf58c94ad48d9958b203dc764bdeaa991d417499e22544c862252b0e8cbe54a83d52d25bebf4c8c9d47f1cbbb794e3806cccb623235de89a64c7e0a89108d19cd3a7bf79c18578308c646c63a3ee8fc53c76a34cfd192a34ec1fe6e7b97b9f8773bf06b131063b10a64c38b38168c42db29687197a4b3e17de473bd3aca7f3747acc70884783ddc6c54060df3da46b310cf0c6d339b5ec4b307cc9ef513a6fd378e17d3d92a88b7005eeba718e8c81d1c71aa0058a365312cff0a3edcb916856180f8f7694f6dc4174184f684f9cb6fb3318ed1caeb7a772a920983347124ec80433f464708c9b44930b9a291c40171002b8700287cc327a7b82ad967d7d1abaffca48903b384e612d4a808ac4b24da3110334799b07848284a4d8476e851511bcf59b016ff4abf1328abf9c8273bddf0456e51dcf45c922904baaee2e0849a57950c740b07723dc1c9046769eb8363756b72bd1ea88ba1a9e8ca959647405fe8f15dd6a1f4aab1993f880a9ec0b01cfb6f4232d4f1ae3ae7fd113b28d2b08e8599bb4e656831624d09c0b69193dc3c4840051dfc6d3761f08e2e7d0f6f9b8d32e90ecbf800d62f4eeef2a0848cd79d9b5c9d69a27c005a0d7ecc44ef38deeeb7191156b3be4ec94b296f75d518e240b6b57d862e5db64bf4a76ec3fc7655d0b51c049cab637c8d86ef39a7584d0bf498c6f6c78d08b03b1b5c22cc2da0029ddab1c79702ed21746b66c280cb688ea48895105d769168ac7bb4818d3bc60ee08b36ae44baa8b4ba742adc6a7a4ee3f45c38cbbfec4ab01fb6e7c2ba47b9f139f7776a6a01880d1f05b8bcfe44cf05bb62439a8e74cd5813c834f009695e8335629eef19283546efb285c1a23f56610af32ec79cd0e9c954018775d733f8a7d340586dd8bbc7117bbba832b9e8da41d169fbcd892494e9a58c2c737bc6ff07938418ea46b054dad7cc9eeb20f5b076018e09fc7823095b586802db2bf7da7f627a4a300a2d74c26f8dce5790a5d537b3178ade9a622833957713493b2658e011789dc0a49538ed9b4c9774f8f2b46df3a434bb5e7f23cb2b6ca4726c80a96ac65071d0b9d47118933f3d617e2510b29dfebc2834cd6942cf4627a65e3b092a87f54d89275314064386cd73a99ec9eac59f4e2e09e7289e8a21eedb21ca84250e0f1341e12113c96c8e8891c23804fb9bfa0015e46fb27ced446d5e207497bf24abdb90dec74a60969c31e1cd6bd2e18ad2e0e8fe63cbc95324b7a4d99d0f1ac25d8264fcdc09c5c90b609a5401248fc33844d3149d685ddf078b725d3adf6867207f4d8516236ab57e7a4999479d1ceefb03803258e92cc9813550c17b24c5438466c3bee6bb79a3cad8deda2a4df28baa6c64351c7852f5683bae072f64ee3ccb992750063dcb47e976487290b28d5c31b950ff07b1106aecd8425204e5d000a4fa703a35a81983d11b8ea4dedce213fac49a8648763fd242c1d231ace667e1c2b504490bf3ad7f0fffef3b425b82595d1fea2b91a6deb980a420f6d2a86f01ec82554c3980771840b7084b260b794fafc47168b8c561cddd8f0cbf0e63c691b47afc8899809d94082f39cd10a1751f5b8ccf4e301b4042c8f88b10840478e534fb6c72d5a19d42e40c4b55a7cf2b46589c1372cf8644bd202d73a72a448ca4f3e7e90b27346d265729a8b77507e934cd2e0c3a87c4ee77d2713f36d1996431f3d738a154092efa4896fe49bab12c97dee8370159d0802dbc2504d08a3ec1ff0362b06719d581f8d7e633999c61282f74e9236b40cebd10397a7ff9849d80eccb7a8e06ee994a421814116c008e040eb98ee1e7a11747c8894e28efb7109980b73e8e97934e02428b3451f2f4d64cdc03adcd425f5619511594b1704b38ecfeaabad6a30c3110e46361e9912dba794abbabb48ad964ce0e3dc30779b06c6384f8f1ea76ca99fbb10fba089bfffc0a24aa7f6cbb580554808470a06ee79bc1d881a822ec42c90f913ba84ad659ddc7cae59ed2d07c38fc7f9ce39f77e2bca534c5c15bc107d84111f907c567cd993ef9c9a1d54136c6700458e133a2aab03cf9ed148767a51681fcfeff149a2ff857de6be58da962424c3ffa4c663e57d9bac473751333d7fc0f45403957f7788c569e094181cd1bd3ed91d0c2d108c04f4b1e72e74b192ebb97ece671af7166bad52bdc412774101211cf94844a6e982a5250b571c93f1afa6273248d71431f491699ecf7eff075a3cd4807dd3ccd1066d61939dd3d7823550dd1a29373274bc1c7822ee46964d0cd44a969d3d0b5abd5cef6807e1e515b0ef8dfdf6f835a5a542500e09f33c99975c7106092544f2f362bfef3d8dff0a38b3a9dc16e12fe0d264a79c587fa0dcef5b6338ab144a92e672054e72a2365309e7427dafcce8479a1e0ff2ccb20492e1433016ab579a989c49dedaaea91cc1307f2f7cdda9482216f0b8e7774c0b8e4ab5cb6eaf0913e23a120f53f8355d508ea1d1f17c078ca1e3d5c1716d32fc80906adf269da94d242817e1441dd7e91c65c6353861b8a2835456d3bf1a8e8c3c0c6da2d3e27298d57993e3001fd55f6be54342e92d46f9b27a29d9826ab6b97f859e95d53c72f3c2fc2f7bbcbd00fc7193bf47d797678586e61e299abbe86407709d3369013c35e38f15f8c132c122f46287161ad86efeb570a485297f9e7681260efba16ce4050a9d5505311b3a7ca7baef4a7a9f1683499743c67f98b573312b72abf6bd8b0c8254f2df05c8012961d6168ec41c888f2b1bd57c42e3cdb909574213ecef87dbcfde3f4d3ce555fb3e9472bdb4c2675768a991cfb9c9ed48d43133b9c0f17ebb7ab8d02c8d249c4acb2f4513bb7e8b69b343bccd96060f2cf516407b8b8ac49d792a83fe70f9df2e2980e5f14f7a93aa9c38e1b5df8a3347fa0487fda88d90dba0a762f1507498e99e9df0e6676a69265baf917b058e4539070d88f95ced304c63a3781213cd634b239382f4c1293ac0b806bc3c5453d5b94af00328376b312319dcccfaac5b81e69d48ee83dc999079629e4dd3efeb8474e8b57b6c183463603d8c4b775a165e4c3ab2ed82b2da053184311e42c8590dd2b09678d0c2974749f1153196603c99e750bcc66a55f23dbf2d02532899af6288ab737c7c5566c4dc4e102b4a30702d16c29fcfd9e630ced9c67cde5da436f48dc2451b692d43ff939ab8dea60b72ae0a0950dbf99d5fa21ff7622d546d30fa98091ba30047a63322dd462fd609485e4b75b38cd8ce33dcedfecc8d207d9423a9fb09839e9c685e32021ad022a3b65d42e32e94f64930f5b4f6a52cff6491021b2146afea3bd0f82511a50aa00efd2289e8ac37ee1d140eae56df6fd5539d7d165c982838e6d8ec63d34b72b81273867bad386fe3a98ee88f09f80587b695b3674a4120220a7e5ab9e2251461f108e7c1b9b52af78a41d9525291db33dfdaa65eb95808eded7796a53ae3c1dad233a790d3834b547a2e328ff4d5a6c6e2553fe46a307b8ae3cc      </script>      <div class="hbe hbe-content">        <div class="hbe hbe-input hbe-input-default">          <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">          <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">            <span class="hbe hbe-input-label-content hbe-input-label-content-default" data-content="联系站长以查看密码">联系站长以查看密码</span>          </label>        </div>        <button class="hbe hbe-confirm"></button>      </div>    </div>    ]]></content>
    
    
    <summary type="html">联系站长以查看密码</summary>
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-07-杂谈-复杂异构系统监控与可视化项目设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/51477.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/51477.html</id>
    <published>2025-12-07T13:09:33.000Z</published>
    <updated>2025-12-15T03:40:34.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复杂异构系统监控与可视化项目设计"><a href="#复杂异构系统监控与可视化项目设计" class="headerlink" title="复杂异构系统监控与可视化项目设计"></a><strong>复杂异构系统监控与可视化</strong>项目设计</h2><h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><p>现在需要设计一个系统，使用py的fastapi作为后端</p><p>目前有一个使用 Docker Compose 编排的复杂容器化环境，基于 SeedEmu（SEED Internet Emulator）框架构建。该框架专用于模拟大规模互联网基础设施，常用于网络安全研究、教育和实验，特别是区块链网络的安全性测试。<br>此 docker-compose.yml 定义了一个模拟的互联网环境，其中部署了一个完整的 Ethereum Proof-of-Stake (PoS) 区块链网络，分布在多个自治系统（Autonomous Systems, AS）中，并通过互联网交换点（Internet Exchange Points, IXP）和路由器实现互联。该环境的主要目的是：</p><p>模拟真实互联网拓扑下的区块链网络行为。<br>支持研究区块链在复杂网络环境下的安全性、性能、攻击与防御（如 Eclipse 攻击、分区攻击、路由攻击等）。<br>提供可视化监控、数据采集和分析工具。</p><p>主要组件与功能有：</p><p>数据库与辅助服务：<br>postgresql: 用于存储区块链监控数据（数据库名为 ethereum_monitor）。<br>redis: 作为缓存或消息队列，可能用于节点间协调或数据临时存储。<br>neo4j: 图数据库，用于存储和分析网络拓扑、区块链节点关系等复杂关系数据。</p><p>Ethereum 区块链网络：<br>在 AS 101–112（共12个自治系统）中部署了大量 Ethereum PoS 节点。<br>每个 AS 内部包含 3 个本地网络（inet0、inet1、inet2），每个网络内有 3 个 Ethereum 节点（共9个节点/AS）。<br>总计约 108 个 Ethereum validator/miner 节点（节点ID从2到108），加上一个 BootNode 和 BeaconSetup 节点。<br>所有节点运行在自定义的链上（chain_id: 1337, chain_name: posCurrentEnhancedNet）。<br>部分节点（如 AS101 的 host0）暴露了 JSON-RPC (8545)、WebSocket (8546) 和 Web 界面 (8000) 端口，便于外部交互。</p><p>网络路由基础设施（基于 SeedEmu）：<br>AS 2：作为一个骨干/中转 AS，包含四个边界路由器（r51–r54），通过点对点链路（net_2_net_51_52 等）连接。<br>IXP（互联网交换点）：ix51–ix54 四个全球 IXP，每个有 Route Server（路由服务器），用于多边对等互联。<br>AS 21–24：作为 IXP 的参与者（peering AS），每个连接一个 IXP。<br>AS 101–112：每个 AS 有一个边界路由器连接到对应的 IXP（例如 AS101 连接 ix51），实现与外部互联网的连通。<br>所有路由器运行真实路由协议（如 BGP），支持模拟路由攻击、劫持等。</p><p>可视化与监控工具：<br>seedemu-internet-client：运行 SeedEmu 的互联网拓扑可视化界面，映射端口 8080，提供整个网络拓扑的图形化视图。<br>seedemu-ether-client：运行 Ethereum 网络专用可视化界面，映射端口 5000，用于查看区块链节点状态、同步情况、交易等。<br>eth_node_cleaner：自定义服务，暴露端口 8888，可能用于中央数据收集、节点状态清理或监控指标聚合，连接 PostgreSQL、Redis 和 Neo4j。</p><p>其他特性：<br>大量自定义网络（local 和 global 类型），精确分配 IP 地址段。<br>节点标签丰富（org.seedsecuritylabs.seedemu.meta.*），便于 SeedEmu 工具识别和渲染。<br>部分服务使用 privileged 模式和 cap_add: ALL，以支持模拟路由所需的网络权限。</p><p>现在需要实现一系列功能，提供基于FastAPI框架的RESTful API路由模块（topology_router），专用于提供区块链仿真环境（特别是结合SeedEmu和Ethereum PoS网络）的完整拓扑数据访问接口如下：</p><p>GET /overview<br>获取整个仿真环境的拓扑概览信息（如节点总数、层级结构等）。<br>GET /statistics<br>获取拓扑统计数据（如节点、链路数量等汇总指标）。<br>GET /health<br>检查拓扑服务的健康状态，返回组件运行状况。</p><p>GET /ethereum<br>获取完整的以太坊网络拓扑数据（节点与P2P连接）。<br>GET /ethereum/nodes<br>获取所有以太坊节点列表，支持按层级过滤（execution或consensus）。<br>GET /ethereum/nodes/{node_id}<br>获取指定以太坊节点（执行层或共识层）的详细信息。<br>GET /ethereum/validators/{validator_id}<br>根据验证者公钥获取单个验证者节点的详细状态和信息。</p><p>GET /physical<br>获取纯物理拓扑结构（不包含容器运行时监控数据）。<br>GET /physical/devices<br>获取物理设备列表（路由器、主机等），支持按设备类型过滤。<br>GET /physical/links<br>获取物理链路（网络连接）列表，支持按连接类型过滤。<br>GET /physical/networks<br>获取所有物理网络的配置信息（网络ID、名称、子网、网关等）。</p><p>GET /contract<br>获取智能合约相关的拓扑视图（合约部署、调用关系等）。<br>GET /contract/statistics<br>获取合约层面的统计信息（如合约数量、调用频率等）。</p><p>GET /transaction<br>获取交易拓扑数据，支持通过时间范围（start_time和end_time）过滤。<br>GET /transaction/statistics<br>获取交易层面的统计信息。<br>GET /transaction/address/{address}/analysis<br>分析特定以太坊地址的资金/交易流向（流入流出关系图）。</p><p>GET /layer/{layer}<br>根据指定拓扑层（枚举值，如ethereum、physical等）获取对应层级的完整拓扑数据。<br>POST /combined<br>支持组合多个拓扑层（如以太坊层+物理层）生成统一的拓扑视图，可指定渲染格式。</p><p>POST /render<br>接收任意拓扑数据和渲染请求（格式如cytoscape、graphviz等），返回经过布局算法处理的可直接用于前端可视化的数据。</p><p>GET /nodes/{node_id}<br>获取任意节点（跨层级）的详细信息，支持指定层级。<br>GET /analysis/{layer}<br>对指定层级进行网络分析（如连通性、中心性、社区检测等指标）。</p><p>POST /cache/clear<br>清空服务内部所有缓存（用于强制刷新数据）。<br>GET /debug/info<br>获取详细的调试信息，包括服务组件状态、各处理器缓存大小、支持的层级与渲染格式等，便于开发与运维排查。</p><hr><h2 id="针对该环境和需求的系统设计方案"><a href="#针对该环境和需求的系统设计方案" class="headerlink" title="针对该环境和需求的系统设计方案"></a>针对该环境和需求的<strong>系统设计方案</strong></h2><p>需要设计一个 FastAPI 后端，它充当一个“中间层（Middleware）”或“聚合层（Aggregator）”，将底层分散的基础设施（Docker）、网络拓扑（SeedEmu/Neo4j）和应用状态（Ethereum/PostgreSQL）整合成统一的 API 暴露给前端</p><h3 id="1-系统架构概览"><a href="#1-系统架构概览" class="headerlink" title="1. 系统架构概览"></a>1. 系统架构概览</h3><p>由于涉及 140+ 容器和多种数据源，系统的核心挑战在于<strong>数据聚合</strong>和<strong>性能优化</strong>。建议采用分层架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    User[前端/可视化大屏] &lt;--&gt; API[FastAPI 网关]<br>    <br>    subgraph "FastAPI 后端应用"<br>        API --&gt; Cache[Redis 缓存层]<br>        API --&gt; Service[业务逻辑层 TopologyService]<br>        <br>        Service --&gt; Adapter1[Docker Adapter]<br>        Service --&gt; Adapter2[Neo4j Adapter]<br>        Service --&gt; Adapter3[Ethereum Adapter Web3.py]<br>        Service --&gt; Adapter4[DB Adapter SQLAlchemy]<br>    end<br>    <br>    subgraph "基础设施 Docker Compose"<br>        Adapter1 --&gt; DockerDaemon[Docker Socket]<br>        Adapter2 --&gt; Neo4j[Neo4j 图数据库]<br>        Adapter3 --&gt; EthNodes[JSON-RPC AS101 Host0]<br>        Adapter4 --&gt; PG[PostgreSQL ethereum_monitor]<br>    end<br></code></pre></td></tr></table></figure><hr><h3 id="2-核心模块设计"><a href="#2-核心模块设计" class="headerlink" title="2. 核心模块设计"></a>2. 核心模块设计</h3><p>我们需要将代码组织为清晰的模块，以应对你列出的 9 大类接口。</p><h4 id="2-1-数据模型层-Models-Schemas"><a href="#2-1-数据模型层-Models-Schemas" class="headerlink" title="2.1 数据模型层 (Models/Schemas)"></a>2.1 数据模型层 (Models/Schemas)</h4><p>使用 Pydantic 定义统一的拓扑数据结构，这是所有接口返回的基础。</p><p>网络拓扑系统采用了分层架构设计，主要包括以下几个层级：</p><ol><li><strong>API层</strong> - topology_api.py 提供RESTful接口</li><li><strong>服务层</strong> - topology_service.py 协调各种拓扑功能</li><li><strong>数据层</strong> - real_topology_service.py 处理真实数据获取</li><li><strong>专门处理器层</strong> - 处理合约、交易等特定类型的拓扑</li><li><p><strong>管理与渲染层</strong> - 负责生命周期管理和数据渲染</p></li><li><p>用户通过API请求拓扑数据（如 /topology/ethereum）</p></li><li>API调用 TopologyService 的 get_ethereum_topology() 方法</li><li>TopologyService 委托给 _real_data_service（即 RealTopologyService）</li><li>RealTopologyService 从Neo4j数据库获取真实的以太坊P2P网络拓扑数据</li><li>数据经过处理和格式化后返回给用户</li></ol><p>对于以太坊拓扑：</p><ol><li>从Neo4j数据库查询执行层和共识层节点及其连接关系</li><li>查询验证者节点并与共识节点关联</li><li>将原始数据转换为前端友好的拓扑格式</li><li>通过Docker客户端获取容器信息，建立IP地址与容器名称的映射</li></ol><p>对于物理拓扑：</p><ol><li>通过Docker客户端获取所有容器的详细信息</li><li>根据容器名称识别设备类型（路由器、主机等）</li><li>根据容器连接的网络建立设备间连接关系</li><li>使用共享网络原则确定设备连接</li></ol><p>在 topology_interfaces.py 中定义了核心抽象类：</p><ol><li><p><strong>TopologyNode</strong> - 拓扑节点基类</p><ul><li>id: 节点唯一标识</li><li>name: 节点名称</li><li>node_type: 节点类型（执行层、共识层、验证者等）</li><li>ip_address: IP地址</li><li>layer: 所属层级</li><li>status: 状态</li><li>metadata: 元数据</li></ul></li><li><p><strong>TopologyLink</strong> - 拓扑连接基类</p><ul><li>source: 源节点ID</li><li>target: 目标节点ID</li><li>link_type: 连接类型</li><li>layer: 所属层级</li><li>direction: 连接方向</li><li>metadata: 元数据</li></ul></li></ol><p>不同类型的拓扑节点</p><ol><li><p><strong>以太坊节点</strong>：</p><ul><li>执行层节点（execution）</li><li>共识层节点（consensus）</li><li>验证者节点（validator）</li></ul></li><li><p><strong>物理节点</strong>：</p><ul><li>路由器（border_router）</li><li>主机（ethernet_host）</li><li>交换机（ixp_core）</li></ul></li></ol><p>拓扑数据最终以以下格式组织：</p><ul><li><strong>nodes</strong>: 节点列表，每个节点包含id、name、type、ip_address、status等属性</li><li><strong>links</strong>: 连接列表，每个连接包含source、target、type等属性</li><li><strong>元数据</strong>: 时间戳、数据源、统计信息等</li></ul><p>这是与底层交互的关键。</p><ol><li><p><strong>InfrastructureAdapter (Docker &amp; SeedEmu):</strong></p><ul><li><p><strong>作用:</strong> 获取物理拓扑。</p></li><li><p><strong>实现:</strong> 使用 docker Python 库读取容器列表。解析 com.docker.compose.service 和 org.seedsecuritylabs.seedemu.meta.* 标签来识别节点角色（AS、路由器、主机）。</p></li><li><p><strong>对应接口:</strong> /physical/*</p></li></ul></li><li><p><strong>GraphDBAdapter (Neo4j):</strong></p><ul><li><p><strong>作用:</strong> 获取网络静态拓扑和关联关系。</p></li><li><p><strong>实现:</strong> 使用 neo4j Python 驱动。SeedEmu 通常会将生成的拓扑导入 Neo4j。查询 Cypher 语句来获取节点间的连接。</p></li><li><p><strong>对应接口:</strong> /overview, /analysis/{layer}</p></li></ul></li><li><p><strong>BlockchainAdapter (Web3.py &amp; Postgres):</strong></p><ul><li><p><strong>作用:</strong> 获取链上实时状态。</p></li><li><p><strong>实现:</strong></p><ul><li><p>实时数据: 使用 web3.py (AsyncHTTPProvider) 连接开放 RPC 端口的节点（如 AS101 的 8545）。获取 Block Height, Peer Count。</p></li><li><p>历史/统计: 连接 PostgreSQL (ethereum_monitor)，查询交易历史、合约调用统计。</p></li></ul></li><li><p><strong>对应接口:</strong> /ethereum/<em>, /contract/</em>, /transaction/*</p></li></ul></li></ol><h4 id="2-3-业务服务层-Services"><a href="#2-3-业务服务层-Services" class="headerlink" title="2.3 业务服务层 (Services)"></a>2.3 业务服务层 (Services)</h4><p>这是实现 RealTopologyService 的地方，负责组装数据。</p><ul><li><p><strong>TopologyService:</strong></p><ul><li><p><strong>Layer Filtering:</strong> 能够根据请求的 layer (physical, ethereum) 调用不同的 Adapter。</p></li><li><p><strong>Merging:</strong> 实现 /combined 接口，将 Docker 的运行状态（Up/Down）注入到 Neo4j 查出的静态拓扑中，并将 Ethereum 节点的逻辑 ID（Validator ID）映射到物理容器 IP。</p></li><li><p><strong>Caching:</strong> <strong>非常重要</strong>。遍历 140 个容器和查询区块链是耗时的。</p><ul><li><p>使用 Redis 缓存完整的拓扑 JSON。</p></li><li><p>设置后台定时任务（FastAPI lifespan 或 APScheduler）每 5-10 秒刷新一次缓存。</p></li></ul></li></ul></li><li><p><strong>AnalysisService:</strong></p><ul><li><p><strong>NetworkX 集成:</strong> 将拓扑数据加载到 Python 的 networkx 库中。</p></li><li><p><strong>算法:</strong> 计算中心性（Centrality）、最短路径（用于分析攻击传播）、社区发现。</p></li><li><p><strong>对应接口:</strong> /analysis/*</p></li></ul></li></ul><hr><h3 id="3-具体接口实现策略"><a href="#3-具体接口实现策略" class="headerlink" title="3. 具体接口实现策略"></a>3. 具体接口实现策略</h3><p>针对你提供的文档，以下是具体实现建议：</p><h4 id="A-物理层-Physical-Layer"><a href="#A-物理层-Physical-Layer" class="headerlink" title="A. 物理层 (Physical Layer)"></a>A. 物理层 (Physical Layer)</h4><ul><li><p><strong>挑战:</strong> 如何知道哪个容器连接哪个？</p></li><li><p><strong>方案:</strong> SeedEmu 通常会在生成容器时将连接信息写入 Neo4j 或生成的 metadata 文件。优先从 <strong>Neo4j</strong> 读取链路关系，从 <strong>Docker API</strong> 读取节点存活状态（Status: Running/Exited）。</p></li></ul><h4 id="B-以太坊层-Ethereum-Layer"><a href="#B-以太坊层-Ethereum-Layer" class="headerlink" title="B. 以太坊层 (Ethereum Layer)"></a>B. 以太坊层 (Ethereum Layer)</h4><ul><li><p><strong>挑战:</strong> 108 个节点，如何获取所有节点状态？</p></li><li><p><strong>方案:</strong></p><ol><li><p><strong>信标链数据 (Consensus):</strong> 连接 Beacon Node API (如果环境中有) 获取验证者状态 (Active/Slashed)。</p></li><li><p><strong>P2P 拓扑:</strong> 使用 admin_peers RPC 方法（需要节点开启该 API）查询节点的连接对象。由于无法轮询所有 108 个节点，可以只轮询几个关键 Bootnode 和 AS 网关节点，构建局部图。</p></li><li><p><strong>Postgres 补充:</strong> 从数据库中读取已知的节点列表和 Validator ID 映射。</p></li></ol></li></ul><h4 id="C-交易与合约-Transaction-amp-Contract"><a href="#C-交易与合约-Transaction-amp-Contract" class="headerlink" title="C. 交易与合约 (Transaction & Contract)"></a>C. 交易与合约 (Transaction &amp; Contract)</h4><ul><li><p><strong>挑战:</strong> 实时分析交易流向。</p></li><li><p><strong>方案:</strong></p><ul><li><p>不要直接扫描链。</p></li><li><p>利用环境中的 postgresql (ethereum_monitor)。SeedEmu 的监控器应该已经将区块和交易写入库中。</p></li><li><p>接口 /transaction/address/{address}/analysis 直接执行 SQL 聚合查询（Group by to/from），返回资金流向图。</p></li></ul></li></ul><h4 id="D-可视化渲染-Rendering"><a href="#D-可视化渲染-Rendering" class="headerlink" title="D. 可视化渲染 (Rendering)"></a>D. 可视化渲染 (Rendering)</h4><ul><li><p><strong>接口:</strong> POST /render</p></li><li><p><strong>逻辑:</strong> 前端可能只需传递原始数据，后端使用 networkx 计算布局（如 ForceAtlas2 或层级布局），计算出每个节点的 (x, y) 坐标，返回给前端直接绘制。这能减轻前端浏览器处理 140+ 节点布局的压力。</p></li></ul><hr><h3 id="4-代码结构示例"><a href="#4-代码结构示例" class="headerlink" title="4. 代码结构示例"></a>4. 代码结构示例</h3><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/topology.py</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">from</span> app.schemas.topology <span class="hljs-keyword">import</span> TopologyGraph<br><br>router = APIRouter(prefix=<span class="hljs-string">"/topology"</span>, tags=[<span class="hljs-string">"Topology"</span>])<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/overview"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_overview</span>(<span class="hljs-params">service: TopologyService = Depends(<span class="hljs-params">get_topology_service</span>)</span>):<br>    <span class="hljs-comment"># 从缓存获取，如果无则计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.get_system_overview()<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/ethereum/nodes/{node_id}"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eth_node_detail</span>(<span class="hljs-params">node_id: <span class="hljs-built_in">str</span>, service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 1. 查 Neo4j 获取节点基础信息</span><br>    <span class="hljs-comment"># 2. 查 Docker 确认容器是否在线</span><br>    <span class="hljs-comment"># 3. 查 Web3/DB 获取链上余额和状态</span><br>    data = <span class="hljs-keyword">await</span> service.get_node_composite_info(node_id, layer=<span class="hljs-string">"ethereum"</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"Node not found"</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">"/combined"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_combined_view</span>(<span class="hljs-params">layers: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 融合物理层和区块链层</span><br>    <span class="hljs-comment"># 例如：展示 区块链P2P连线 覆盖在 物理AS拓扑 上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.generate_combined_topology(layers)<br></code></pre></td></tr></table></figure><h3 id="5-关键技术难点与解决方案"><a href="#5-关键技术难点与解决方案" class="headerlink" title="5. 关键技术难点与解决方案"></a>5. 关键技术难点与解决方案</h3><ol><li><p><strong>Docker 网络访问:</strong></p><ul><li><p>FastAPI 容器需要挂载 /var/run/docker.sock 才能查询兄弟容器的状态。</p></li><li><p>docker-compose.yml 配置:</p><p>  codeYaml</p>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">volumes:</span><br>  - <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/docker.sock:/</span><span class="hljs-keyword">var</span><span class="hljs-regexp">/run/</span>docker.sock<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>跨容器数据库连接:</strong></p><ul><li>连接 Neo4j 和 Postgres 时，Host 应使用 Docker Compose 服务名（如 neo4j, postgresql），而不是 localhost。</li></ul></li><li><p><strong>性能瓶颈:</strong></p><ul><li><p><strong>问题:</strong> /ethereum 接口如果实时调用 100+ 次 RPC 会超时。</p></li><li><p><strong>解决:</strong> 使用 <strong>“后台采集 + 前端读取”</strong> 模式。编写一个后台 Task (使用 asyncio 或 Celery) 每 10 秒扫描一次网络状态存入 Redis。API 接口只读 Redis。</p></li></ul></li><li><p><strong>IP地址管理:</strong></p><ul><li><p>SeedEmu 的自定义网络（inet0, net_2_net_51_52）非常复杂。</p></li><li><p>在返回 /physical 拓扑时，务必解析 Docker inspect 结果中的 NetworkSettings，将特定网段 IP 映射给前端，否则前端无法理解路由关系。</p></li></ul></li></ol><h3 id="6-总结建议"><a href="#6-总结建议" class="headerlink" title="6. 总结建议"></a>6. 总结建议</h3><p>设计这个系统时，请遵循以下步骤：</p><ol><li><p><strong>优先打通 Neo4j:</strong> 它是拓扑的真理来源（Source of Truth）。确保能查询出 AS、Router 和 Host 的关系。</p></li><li><p><strong>实现缓存机制:</strong> 复杂的 Docker 集群状态获取很慢，不要让 API 直接穿透到 Docker Daemon。</p></li><li><p><strong>定义清晰的 ID 映射:</strong> 最大的坑在于关联 “Docker Container Name” (e.g., as101_host0) 和 “Ethereum Node ID” (e.g., Validator-3)。需要在服务启动时建立这个映射表。</p></li><li><p><strong>按层开发:</strong> 先做 Physical（最简单，只读 Docker），再做 Ethereum（读 DB），最后做高级的 Contract/Transaction 分析。</p></li></ol><hr><p>实现“实时更新”并“高亮变化”的核心在于结合 <strong>FastAPI 的 WebSocket</strong> 推送机制与 <strong>D3.js 的 General Update Pattern（通用更新模式）</strong>。</p><p>这里有三个关键点：</p><ol><li><p><strong>后端推送</strong>：只推送最新的全量/增量状态。</p></li><li><p><strong>前端数据绑定</strong>：D3 必须通过 Key Function 识别哪些是新节点、哪些是旧节点，而不是每次清空画布重绘。</p></li><li><p><strong>视觉反馈</strong>：利用 CSS 动画或 D3 Transition 让变化的节点产生“闪烁”或“颜色渐变”。</p></li></ol><hr><h3 id="1-整体架构设计"><a href="#1-整体架构设计" class="headerlink" title="1. 整体架构设计"></a>1. 整体架构设计</h3><ul><li><p><strong>后端 (FastAPI)</strong>: 运行一个后台任务（Background Task），每隔几秒扫描一次 Docker/Ethereum 状态，通过 WebSocket 广播给前端。</p></li><li><p><strong>前端 (D3.js)</strong>: 维护一个长连接，收到数据后，执行 updateGraph(newData)。</p></li></ul><hr><h3 id="2-后端：FastAPI-WebSocket-实现"><a href="#2-后端：FastAPI-WebSocket-实现" class="headerlink" title="2. 后端：FastAPI WebSocket 实现"></a>2. 后端：FastAPI WebSocket 实现</h3><p>我们需要一个 ConnectionManager 来管理前端连接，并推送拓扑数据。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/ws_topology.py</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, WebSocket, WebSocketDisconnect<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><br>router = APIRouter()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections: <span class="hljs-built_in">list</span>[WebSocket] = []<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-keyword">await</span> websocket.accept()<br>        <span class="hljs-variable language_">self</span>.active_connections.append(websocket)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections.remove(websocket)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">self, message: <span class="hljs-built_in">dict</span></span>):<br>        <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.active_connections:<br>            <span class="hljs-keyword">await</span> connection.send_json(message)<br><br>manager = ConnectionManager()<br><br><span class="hljs-comment"># 模拟后台数据推送任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">topology_broadcaster</span>(<span class="hljs-params">service: TopologyService</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    这个函数需要在 main.py 的 @app.on_event("startup") 中启动</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 获取最新拓扑（包含 Docker 状态 + Geth 连接）</span><br>        topology_data = <span class="hljs-keyword">await</span> service.get_full_topology_snapshot()<br>        <br>        <span class="hljs-comment"># 广播数据</span><br>        <span class="hljs-keyword">if</span> manager.active_connections:<br>            <span class="hljs-keyword">await</span> manager.broadcast(topology_data)<br>        <br>        <span class="hljs-comment"># 每 5 秒推送一次，避免前端渲染压力过大</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-meta">@router.websocket(<span class="hljs-params"><span class="hljs-string">"/ws/topology"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">websocket_endpoint</span>(<span class="hljs-params">websocket: WebSocket</span>):<br>    <span class="hljs-keyword">await</span> manager.connect(websocket)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 保持连接活跃，也可以接收前端的控制指令（比如点击了某个节点）</span><br>            data = <span class="hljs-keyword">await</span> websocket.receive_text() <br>    <span class="hljs-keyword">except</span> WebSocketDisconnect:<br>        manager.disconnect(websocket)<br></code></pre></td></tr></table></figure><hr><h3 id="3-前端：D3-js-实时更新与高亮逻辑"><a href="#3-前端：D3-js-实时更新与高亮逻辑" class="headerlink" title="3. 前端：D3.js 实时更新与高亮逻辑"></a>3. 前端：D3.js 实时更新与高亮逻辑</h3><p>这是最关键的部分。不要清空 SVG！使用 D3 的 <strong>Enter (新增), Update (更新), Exit (删除)</strong> 模式。</p><h4 id="核心策略："><a href="#核心策略：" class="headerlink" title="核心策略："></a>核心策略：</h4><ol><li><p><strong>ID 绑定</strong>：告诉 D3 如何通过 ID（如 enode_id 或 container_name）区分节点，而不是数组索引。</p></li><li><p><strong>平滑模拟</strong>：数据更新时，不要将 alpha 重置为 1（会导致整个图剧烈爆炸），而是重置为 0.3 左右（轻微调整）。</p></li><li><p><strong>样式Diff</strong>：比对新旧数据，如果状态变化（如 IP 变了，Peer 数变了），添加 CSS 类名触发动画。</p></li></ol><h4 id="代码实现-HTML-JS"><a href="#代码实现-HTML-JS" class="headerlink" title="代码实现 (HTML/JS)"></a>代码实现 (HTML/JS)</h4><p>codeJavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化 SVG 和 Simulation</span><br><span class="hljs-keyword">const</span> svg = d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">"#topology-svg"</span>);<br><span class="hljs-keyword">const</span> width = +svg.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"width"</span>);<br><span class="hljs-keyword">const</span> height = +svg.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"height"</span>);<br><br><span class="hljs-keyword">let</span> simulation = d3.<span class="hljs-title function_">forceSimulation</span>()<br>    .<span class="hljs-title function_">force</span>(<span class="hljs-string">"link"</span>, d3.<span class="hljs-title function_">forceLink</span>().<span class="hljs-title function_">id</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">id</span>).<span class="hljs-title function_">distance</span>(<span class="hljs-number">100</span>))<br>    .<span class="hljs-title function_">force</span>(<span class="hljs-string">"charge"</span>, d3.<span class="hljs-title function_">forceManyBody</span>().<span class="hljs-title function_">strength</span>(-<span class="hljs-number">300</span>))<br>    .<span class="hljs-title function_">force</span>(<span class="hljs-string">"center"</span>, d3.<span class="hljs-title function_">forceCenter</span>(width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 定义箭头和样式</span><br><span class="hljs-comment">// ... (省略定义 marker 的代码) ...</span><br><br><span class="hljs-comment">// 建立 WebSocket 连接</span><br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">"ws://localhost:8000/ws/topology"</span>);<br><br><span class="hljs-comment">// 本地存储当前数据，用于 diff</span><br><span class="hljs-keyword">let</span> currentNodes = [];<br><span class="hljs-keyword">let</span> currentEdges = [];<br><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);<br>    <span class="hljs-title function_">updateGraph</span>(data);<br>};<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateGraph</span>(<span class="hljs-params">data</span>) {<br>    <span class="hljs-comment">// 1. 保留旧节点的位置信息！</span><br>    <span class="hljs-comment">// 如果不这样做，每次更新所有节点都会瞬间跳回原点或随机位置</span><br>    <span class="hljs-keyword">const</span> nodeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(currentNodes.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> [n.<span class="hljs-property">id</span>, n]));<br>    data.<span class="hljs-property">nodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">newNode</span> =&gt;</span> {<br>        <span class="hljs-keyword">const</span> oldNode = nodeMap.<span class="hljs-title function_">get</span>(newNode.<span class="hljs-property">id</span>);<br>        <span class="hljs-keyword">if</span> (oldNode) {<br>            newNode.<span class="hljs-property">x</span> = oldNode.<span class="hljs-property">x</span>;<br>            newNode.<span class="hljs-property">y</span> = oldNode.<span class="hljs-property">y</span>;<br>            newNode.<span class="hljs-property">vx</span> = oldNode.<span class="hljs-property">vx</span>;<br>            newNode.<span class="hljs-property">vy</span> = oldNode.<span class="hljs-property">vy</span>;<br>        }<br>    });<br>    <br>    currentNodes = data.<span class="hljs-property">nodes</span>;<br>    currentEdges = data.<span class="hljs-property">edges</span>;<br><br>    <span class="hljs-comment">// ================= 处理连线 (Links) =================</span><br>    <span class="hljs-comment">// key function: d =&gt; d.source.id + "-" + d.target.id</span><br>    <span class="hljs-comment">// 确保连线唯一性</span><br>    <span class="hljs-keyword">const</span> links = svg.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">".link"</span>)<br>        .<span class="hljs-title function_">data</span>(data.<span class="hljs-property">edges</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${d.source}</span>-<span class="hljs-subst">${d.target}</span>`</span>);<br><br>    links.<span class="hljs-title function_">exit</span>()<br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">style</span>(<span class="hljs-string">"opacity"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 消失动画</span><br>        .<span class="hljs-title function_">remove</span>();<br><br>    <span class="hljs-keyword">const</span> linksEnter = links.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">"line"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"link"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"#999"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke-width"</span>, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// MERGE: 合并新老连线</span><br>    <span class="hljs-keyword">const</span> linksMerge = linksEnter.<span class="hljs-title function_">merge</span>(links);<br><br>    <span class="hljs-comment">// ================= 处理节点 (Nodes) =================</span><br>    <span class="hljs-keyword">const</span> nodes = svg.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">".node"</span>)<br>        .<span class="hljs-title function_">data</span>(data.<span class="hljs-property">nodes</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">id</span>); <span class="hljs-comment">// 关键：使用 id 作为 key</span><br><br>    <span class="hljs-comment">// EXIT: 节点消失</span><br>    nodes.<span class="hljs-title function_">exit</span>()<br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">1000</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">0</span>)<br>        .<span class="hljs-title function_">style</span>(<span class="hljs-string">"opacity"</span>, <span class="hljs-number">0</span>)<br>        .<span class="hljs-title function_">remove</span>();<br><br>    <span class="hljs-comment">// UPDATE: 节点状态更新（比如颜色变化）</span><br>    <span class="hljs-comment">// 可以在这里判断状态，比如 d.status === 'mining'</span><br>    nodes.<span class="hljs-title function_">classed</span>(<span class="hljs-string">"node-updated"</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 添加一个类触发 CSS 闪烁</span><br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">500</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">layer</span> === <span class="hljs-string">'ethereum'</span> ? <span class="hljs-string">"#69b3a2"</span> : <span class="hljs-string">"#ffcc00"</span>);<br><br>    <span class="hljs-comment">// ENTER: 新节点出现</span><br>    <span class="hljs-keyword">const</span> nodesEnter = nodes.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"node"</span>)<br>        .<span class="hljs-title function_">call</span>(d3.<span class="hljs-title function_">drag</span>()<br>            .<span class="hljs-title function_">on</span>(<span class="hljs-string">"start"</span>, dragstarted)<br>            .<span class="hljs-title function_">on</span>(<span class="hljs-string">"drag"</span>, dragged)<br>            .<span class="hljs-title function_">on</span>(<span class="hljs-string">"end"</span>, dragended));<br><br>    nodesEnter.<span class="hljs-title function_">append</span>(<span class="hljs-string">"circle"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 初始大小为0，产生弹出的效果</span><br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"red"</span>) <span class="hljs-comment">//以此高亮新节点</span><br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">750</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">layer</span> === <span class="hljs-string">'ethereum'</span> ? <span class="hljs-string">"#69b3a2"</span> : <span class="hljs-string">"#ffcc00"</span>);<br><br>    nodesEnter.<span class="hljs-title function_">append</span>(<span class="hljs-string">"text"</span>)<br>        .<span class="hljs-title function_">text</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">id</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x"</span>, <span class="hljs-number">12</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y"</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// MERGE: 合并</span><br>    <span class="hljs-keyword">const</span> nodesMerge = nodesEnter.<span class="hljs-title function_">merge</span>(nodes);<br><br>    <span class="hljs-comment">// ================= 重启模拟 =================</span><br>    simulation.<span class="hljs-title function_">nodes</span>(data.<span class="hljs-property">nodes</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">"tick"</span>, ticked);<br>    simulation.<span class="hljs-title function_">force</span>(<span class="hljs-string">"link"</span>).<span class="hljs-title function_">links</span>(data.<span class="hljs-property">edges</span>);<br>    <br>    <span class="hljs-comment">// 关键：温和地重启模拟，而不是完全重置</span><br>    <span class="hljs-comment">// alpha(0.3) 意味着只进行微调，不会导致布局剧烈震荡</span><br>    simulation.<span class="hljs-title function_">alpha</span>(<span class="hljs-number">0.3</span>).<span class="hljs-title function_">restart</span>();<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">ticked</span>(<span class="hljs-params"></span>) {<br>        linksMerge<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x1"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">source</span>.<span class="hljs-property">x</span>)<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y1"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">source</span>.<span class="hljs-property">y</span>)<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x2"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">target</span>.<span class="hljs-property">x</span>)<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y2"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">target</span>.<span class="hljs-property">y</span>);<br><br>        nodesMerge<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"transform"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-string">`translate(<span class="hljs-subst">${d.x}</span>,<span class="hljs-subst">${d.y}</span>)`</span>);<br>    }<br>}<br><br><span class="hljs-comment">// 拖拽函数（标准 D3 代码，略）</span><br></code></pre></td></tr></table></figure><h3 id="4-视觉高亮变化的技巧"><a href="#4-视觉高亮变化的技巧" class="headerlink" title="4. 视觉高亮变化的技巧"></a>4. 视觉高亮变化的技巧</h3><p>为了让用户明显看到“发生了什么变化”，建议配合 CSS 动画：</p><p><strong>技巧 A：新节点闪烁</strong><br>当节点 enter() 时，给它设置一个临时的高亮颜色（如亮绿色），然后 transition 回正常颜色。</p><p><strong>技巧 B：状态变更光环</strong><br>如果节点还在列表里，但状态变了（例如从 syncing 变成 mining），在 nodes (Update set) 中检测：</p><p>codeJavaScript</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs q">nodes.<span class="hljs-built_in">each</span>(function(d) {<br>    <span class="hljs-comment">// d 是新数据，this 是 DOM 元素</span><br>    const oldStatus = d3.<span class="hljs-keyword">select</span>(this).<span class="hljs-built_in">attr</span>(<span class="hljs-string">"data-status"</span>);<br>    if (oldStatus &amp;&amp; oldStatus !== d.status) {<br>        <span class="hljs-comment">// 状态变了！添加一个临时 SVG 圆环扩散动画</span><br>        d3.<span class="hljs-keyword">select</span>(this).append(<span class="hljs-string">"circle"</span>)<br>            .<span class="hljs-built_in">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">10</span>)<br>            .<span class="hljs-built_in">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"ripple"</span>)<br>            .transition().duration(<span class="hljs-number">1000</span>)<br>            .<span class="hljs-built_in">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">30</span>)<br>            .style(<span class="hljs-string">"opacity"</span>, <span class="hljs-number">0</span>)<br>            .remove();<br>    }<br>    <span class="hljs-comment">// 更新 DOM 上的状态标记</span><br>    d3.<span class="hljs-keyword">select</span>(this).<span class="hljs-built_in">attr</span>(<span class="hljs-string">"data-status"</span>, d.status);<br>});<br></code></pre></td></tr></table></figure><p><strong>技巧 C：固定骨干网（针对 SeedEmu）</strong><br>你的环境中有 AS 路由器（骨干网）和 Host（叶子节点）。</p><ul><li><p><strong>建议</strong>：在 D3 中，将骨干路由器（r51-r54, AS路由器）的坐标<strong>根据逻辑预设好并固定</strong>（设置 fx, fy）。</p></li><li><p><strong>效果</strong>：这样即使以太坊节点上线下线，整个网络的“骨架”不会乱跑，只有边缘节点在动，视觉上更清晰，更容易看清变化。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p><strong>FastAPI</strong>：使用 WebSocket + Background Task 推送全量快照。</p></li><li><p><strong>D3.js</strong>：使用 data(dataset, d =&gt; d.id) 绑定 ID。</p></li><li><p><strong>Diff 逻辑</strong>：</p><ul><li><p><strong>Enter</strong>: 初始半径为 0 -&gt; 放大，颜色高亮。</p></li><li><p><strong>Exit</strong>: 透明度变 0 -&gt; 移除。</p></li><li><p><strong>Update</strong>: 继承旧节点的 x, y 坐标，避免位置重置；利用 transition 表现状态变更。</p></li><li><p><strong>Simulation</strong>: 使用 alpha(0.3).restart() 进行温和重绘。</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;a href=&quot;#复杂异构系统监控与可视化项目设计&quot; class=&quot;headerlink&quot; title=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;复杂异构系统监控与可视化&lt;/strong&gt;项目设计&lt;/h2&gt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-06-杂记-前端图拓扑渲染优化</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/7900.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/7900.html</id>
    <published>2025-12-06T03:25:47.000Z</published>
    <updated>2025-12-14T17:56:13.795Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>性能优化 (Web Workers)</strong>: 目前的数据获取、解析和Diff算法都在<strong>主线程</strong>运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 <strong>Web Worker</strong>。</p></li><li><p><strong>D3 渲染优化</strong>: 目前的设计倾向于每次更新都全量替换 filteredNodes，这会导致 D3 力导向图重新初始化或位置抖动。应该利用 Diff 结果进行<strong>增量渲染 (Enter/Update/Exit)</strong>。</p></li><li><p><strong>状态管理解耦</strong>: useTopologyData 承担了太多职责（数据存储、UI状态、标签逻辑）。应该拆分为“数据层”和“视觉层”。</p></li><li><p><strong>数据结构优化</strong>: 数组查找（.find）效率低，应更多使用 Map/Set 索引。</p></li></ol><h3 id="优化后文件结构"><a href="#优化后文件结构" class="headerlink" title="优化后文件结构"></a>优化后文件结构</h3><p>采用了 <strong>Core (数据核心) + Visual (视觉逻辑) + Worker (后台计算)</strong> 的分层结构。</p><p>codeText</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span>/<br>  ├── types/<br>  │   └── topology<span class="hljs-selector-class">.ts</span>           <span class="hljs-comment">// (保持不变) 类型定义</span><br>  ├── workers/<br>  │   └── topology<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [新] 负责Fetch、解析数据、计算Diff</span><br>  ├── composables/<br>  │   ├── useTopologyCore<span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [优化] 负责与Worker通信，持有原始数据</span><br>  │   ├── useTopologyVisual<span class="hljs-selector-class">.ts</span>  <span class="hljs-comment">// [拆分] 负责过滤、标签、高亮等UI逻辑</span><br>  │   └── useD3Renderer<span class="hljs-selector-class">.ts</span>      <span class="hljs-comment">// [新] 封装D3的具体操作，接受Diff指令</span><br>  └── components/<br>      └── EthereumTopology<span class="hljs-selector-class">.vue</span>  <span class="hljs-comment">// [优化] 变得很薄，只负责组装</span><br></code></pre></td></tr></table></figure><p>现在的以太坊拓扑渲染架构采用了 <strong>“分层响应式架构” (Layered Reactive Architecture)</strong>，结合了 <strong>Web Worker 多线程计算</strong> 和 <strong>D3 增量渲染</strong> 技术。</p><p>这是一种高性能、低耦合的现代前端架构，专门为了处理大量节点（数千级）的实时动态拓扑而设计。</p><p>以下是该架构的详细层级解析：</p><h3 id="1-架构总览图"><a href="#1-架构总览图" class="headerlink" title="1. 架构总览图"></a>1. 架构总览图</h3><p>数据流向是单向的，状态管理是响应式的：</p><p>codeMermaid</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">graph TD<br>    BackEnd[FastAPI 后端] --&gt;|<span class="hljs-type">JSON</span> Stream| <span class="hljs-type">Worker</span>[Web Worker (后台线程)]<br>    <br>    subgraph <span class="hljs-string">"Main Thread (主线程)"</span><br>        Worker --&gt;|<span class="hljs-type">Diff</span> Update (增量/全量)| <span class="hljs-type">Store</span>[useTopologyCore (数据层)]<br>        Store --&gt;|<span class="hljs-type">Raw</span> Data| <span class="hljs-type">Visual</span>[useTopologyVisual (视觉层)]<br>        <br>        subgraph <span class="hljs-string">"UI Components (视图层)"</span><br>            Visual --&gt;|<span class="hljs-type">Filtered</span> Data| <span class="hljs-type">Renderer</span>[useD3Renderer (渲染层)]<br>            Visual --&gt;|<span class="hljs-type">Filters</span>/<span class="hljs-keyword">Mode</span>| <span class="hljs-type">Controls</span>[TopologyVisualization (控制面板)]<br>            Renderer --&gt;|<span class="hljs-type">Click</span> Event| <span class="hljs-type">Details</span>[PhysicalTopology (详情抽屉)]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br>    Renderer --&gt;|<span class="hljs-type">Draw</span>| <span class="hljs-type">DOM</span>[SVG/Canvas]<br></code></pre></td></tr></table></figure><hr><h3 id="2-核心层级详细解析"><a href="#2-核心层级详细解析" class="headerlink" title="2. 核心层级详细解析"></a>2. 核心层级详细解析</h3><h4 id="第一层：数据处理层-Worker-Thread"><a href="#第一层：数据处理层-Worker-Thread" class="headerlink" title="第一层：数据处理层 (Worker Thread)"></a>第一层：数据处理层 (Worker Thread)</h4><p><strong>文件</strong>: workers/topology.worker.ts<br>这是架构的“发动机”，完全脱离主线程运行。</p><ul><li><p><strong>职责</strong>：</p><ol><li><p><strong>数据拉取</strong>：直接发起 Fetch 请求，不占用主线程网络资源。</p></li><li><p><strong>数据清洗</strong>：解析复杂的 JSON 结构，标准化为 TopologyNode 和 TopologyLink。</p></li><li><p><strong>智能 Diff (差异计算)</strong>：</p><ul><li><p>这是性能优化的关键。它对比新旧数据，计算出新增、删除和更新的节点。</p></li><li><p><strong>坐标继承</strong>：在 Worker 中将旧节点的 x, y 坐标赋值给新节点，防止 D3 在数据更新时重新计算布局导致视图“爆炸”或闪烁。</p></li></ul></li></ol></li></ul><h4 id="第二层：状态管理层-Composables"><a href="#第二层：状态管理层-Composables" class="headerlink" title="第二层：状态管理层 (Composables)"></a>第二层：状态管理层 (Composables)</h4><p>这一层利用 Vue 3 的 Composition API 将业务逻辑拆分为独立的模块。</p><ul><li><p><strong>数据持有 (useTopologyCore.ts)</strong>：</p><ul><li><p>与 Worker 通信的桥梁。</p></li><li><p>使用 shallowRef 存储庞大的拓扑数据。<strong>优化点</strong>：shallowRef 不会深度监听节点内部属性的变化（如 x, y 坐标），这极大减轻了 Vue 响应式系统的负担，因为 D3 会直接操作这些原生对象。</p></li></ul></li><li><p><strong>视觉逻辑 (useTopologyVisual.ts)</strong>：</p><ul><li><p><strong>纯粹的计算层</strong>。它不关心数据怎么来的，只关心怎么显示。</p></li><li><p><strong>动态过滤</strong>：利用 computed 属性，根据 filters（如隐藏共识节点）实时生成 filteredNodes。</p></li><li><p><strong>样式映射</strong>：集中管理颜色 (getNodeColor) 和标签 (getNodeLabel) 逻辑，实现逻辑与渲染分离。</p></li></ul></li></ul><h4 id="第三层：渲染驱动层-Render-Engine"><a href="#第三层：渲染驱动层-Render-Engine" class="headerlink" title="第三层：渲染驱动层 (Render Engine)"></a>第三层：渲染驱动层 (Render Engine)</h4><p><strong>文件</strong>: useD3Renderer.ts<br>这是 D3.js 与 Vue 的结合点。</p><ul><li><p><strong>生命周期接管</strong>：它在 onMounted 时初始化 D3 仿真器。</p></li><li><p><strong>增量渲染 (Incremental Rendering)</strong>：</p><ul><li><p>使用 Vue 的 watch 监听过滤后的数据。</p></li><li><p>利用 D3 的 enter(), update(), exit() 模式。</p></li><li><p><strong>Enter</strong>: 新节点淡入。</p></li><li><p><strong>Exit</strong>: 被过滤或删除的节点淡出移除。</p></li><li><p><strong>Update</strong>: 现有节点平滑移动到新位置。</p></li></ul></li><li><p><strong>事件桥接</strong>：将 D3 的 click、drag 事件转换为 Vue 的回调函数，传递给上层组件。</p></li></ul><h4 id="第四层：视图组装层-View-Integration"><a href="#第四层：视图组装层-View-Integration" class="headerlink" title="第四层：视图组装层 (View Integration)"></a>第四层：视图组装层 (View Integration)</h4><p><strong>文件</strong>: EthereumTopology.vue (父组件)<br>这是架构的“容器”和“胶水”。</p><ul><li><p><strong>依赖注入 (Dependency Injection)</strong>：</p><ul><li><p>父组件通过 provide(‘topology-state’, …) 将 mode、filters 等状态下发。</p></li><li><p>子组件 TopologyVisualization 通过 inject 直接获取并修改这些状态。避免了深层 Prop 传递（Prop Drilling）。</p></li></ul></li><li><p><strong>组件编排</strong>：</p><ul><li><p>负责布局：左上角悬浮控制面板、中间 D3 画布、右侧详情抽屉。</p></li><li><p>负责联动：当 D3 点击节点时，控制 showPhysicalDetails 变量来弹出侧边栏。</p></li></ul></li></ul><hr><h3 id="3-关键性能优化点总结"><a href="#3-关键性能优化点总结" class="headerlink" title="3. 关键性能优化点总结"></a>3. 关键性能优化点总结</h3><ol><li><p><strong>非阻塞主线程 (Off-Main-Thread)</strong>:</p><ul><li><p><strong>旧架构</strong>：在组件内 fetch 数据 -&gt; 解析 -&gt; 赋值。数据量大时 UI 会卡顿。</p></li><li><p><strong>新架构</strong>：所有数据处理都在 Worker 中完成，主线程只负责接收“准备好渲染”的数据。</p></li></ul></li><li><p><strong>浅层响应式 (Shallow Reactivity)</strong>:</p><ul><li>使用 shallowRef 代替 ref 存储节点数组。D3 内部高频修改 node.x 和 node.y 时，不会触发 Vue 的依赖更新系统，显著提升动画帧率。</li></ul></li><li><p><strong>状态保持 (State Preservation)</strong>:</p><ul><li>Worker 在处理新数据时，会查找旧数据的 ID，并将 x, y, vx, vy (速度向量) 复制给新数据。这保证了在轮询更新时，节点不会重置位置，实现了“流式”的平滑更新效果。</li></ul></li><li><p><strong>按需计算 (Computed Filtering)</strong>:</p><ul><li>连接 (links) 的过滤依赖于节点 (nodes) 的过滤结果。新架构使用了 Set 来建立索引，将连接过滤的时间复杂度从 O(N*M) 降低到 O(M)（其中 N 是节点数，M 是连接数）。</li></ul></li></ol><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>现在的架构是一个 <strong>“重后台、轻前台、数据驱动视图”</strong> 的专业可视化架构。</p><ul><li><p><strong>Worker</strong> 负责“脏活累活”（数据处理）。</p></li><li><p><strong>D3</strong> 负责“精细活”（物理仿真和绘图）。</p></li><li><p><strong>Vue</strong> 负责“指挥”（状态管理和组件通信）。</p></li></ul><p>这种架构非常适合需要长时间运行、实时监控网络状态的生产级系统。</p><hr><p>根据提供的代码（EthereumTopologyHandler 和 RealTopologyService），以太坊网络拓扑的处理流程是一个<strong>分层获取、数据融合、格式化输出</strong>的过程。核心逻辑依赖于 <strong>Neo4j 图数据库</strong>（存储P2P关系）和 <strong>Docker 守护进程</strong>（提供容器运行时信息）。</p><p>以下是详细的处理步骤解析：</p><h3 id="1-数据源获取-Data-Acquisition"><a href="#1-数据源获取-Data-Acquisition" class="headerlink" title="1. 数据源获取 (Data Acquisition)"></a>1. 数据源获取 (Data Acquisition)</h3><p>系统主要通过两个渠道获取数据：</p><ul><li><p><strong>Neo4j 数据库 (核心数据源)</strong>：存储了爬虫或客户端上报的节点发现数据，包含节点ID、IP、以及节点间的 P2P 连接关系。</p></li><li><p><strong>Docker Client (辅助数据源)</strong>：用于获取运行中容器的实时状态、名称映射和网络设置。</p></li></ul><h3 id="2-核心处理流程"><a href="#2-核心处理流程" class="headerlink" title="2. 核心处理流程"></a>2. 核心处理流程</h3><p>整个拓扑生成的逻辑主要集中在 _get_real_topology_from_neo4j 和 _convert_topology_format 方法中。</p><h4 id="步骤-A：从-Neo4j-提取原始拓扑结构"><a href="#步骤-A：从-Neo4j-提取原始拓扑结构" class="headerlink" title="步骤 A：从 Neo4j 提取原始拓扑结构"></a>步骤 A：从 Neo4j 提取原始拓扑结构</h4><p>代码通过 Cypher 查询语句分三步提取数据：</p><ol><li><p><strong>查询执行层 (Execution Layer)</strong>：</p><ul><li><p>查找所有 ExecNode 标签的节点。</p></li><li><p>查找 EXEC_PEERS_WITH 关系，获取该节点的对等节点（Peers）。</p></li></ul></li><li><p><strong>查询共识层 (Consensus Layer)</strong>：</p><ul><li><p>查找所有 ConsNode 标签的节点。</p></li><li><p>查找 CONS_PEERS_WITH 关系。</p></li></ul></li><li><p><strong>查询验证者 (Validators)</strong>：</p><ul><li><p>查找与共识节点通过 MANAGES_VALIDATOR 关系连接的 Validator 节点。</p></li><li><p>这反映了哪个信标节点（Beacon Node）管理着哪些验证者客户端。</p></li></ul></li></ol><h4 id="步骤-B：容器身份映射-Container-Mapping"><a href="#步骤-B：容器身份映射-Container-Mapping" class="headerlink" title="步骤 B：容器身份映射 (Container Mapping)"></a>步骤 B：容器身份映射 (Container Mapping)</h4><ul><li><p><strong>目的</strong>：数据库中只有 IP 地址，但在前端展示时，最好能显示具体的 Docker 容器名称（如 geth-node-1）。</p></li><li><p><strong>实现</strong>：_create_ip_to_container_mapping 方法遍历所有 Docker 容器，提取其网络设置中的 IP 地址，建立 IP -&gt; ContainerName 的映射表。</p></li></ul><h4 id="步骤-C：构建拓扑对象-Topology-Construction"><a href="#步骤-C：构建拓扑对象-Topology-Construction" class="headerlink" title="步骤 C：构建拓扑对象 (Topology Construction)"></a>步骤 C：构建拓扑对象 (Topology Construction)</h4><p>系统将原始数据转换为前端可视化的 JSON 格式，包含 nodes 和 links。</p><p><strong>1. 节点生成 (Nodes):</strong><br>代码根据逻辑自动计算节点的坐标 (x, y) 以便可视化布局：</p><ul><li><p><strong>执行层节点</strong>：</p><ul><li><p>type: execution</p></li><li><p>位置：固定在 Y=150 的水平线上。</p></li></ul></li><li><p><strong>共识层节点</strong>：</p><ul><li><p>type: consensus</p></li><li><p>位置：固定在 Y=350 的水平线上（位于执行层下方）。</p></li></ul></li><li><p><strong>验证者节点</strong>：</p><ul><li><p>type: validator</p></li><li><p>位置：簇拥在所属共识节点的下方 (y + 60)，通过计算偏移量排成小方阵。</p></li></ul></li></ul><p><strong>2. 连接生成 (Links):</strong><br>系统构建了四种类型的连接：</p><ul><li><p><strong>执行层 P2P (exec_peer)</strong>：基于 Neo4j 中的 EXEC_PEERS_WITH 关系，表示 Geth/Nethermind 节点间的 Gossip 协议连接。</p></li><li><p><strong>共识层 P2P (cons_peer)</strong>：基于 CONS_PEERS_WITH 关系，表示 Lighthouse/Prysm 节点间的连接。</p></li><li><p><strong>管理关系 (manages_validator)</strong>：连接共识节点和它管理的验证者节点。</p></li><li><p><strong>跨层连接 (cross_layer)</strong>：<strong>关键逻辑</strong>。代码会自动匹配 IP 地址相同的执行层节点和共识层节点，并创建一个垂直连接。这代表了以太坊客户端组合（Engine API 通信，例如 Geth &lt;-&gt; Lighthouse 在同一台机器/Pod内）。</p></li></ul><h3 id="3-容错与缓存机制"><a href="#3-容错与缓存机制" class="headerlink" title="3. 容错与缓存机制"></a>3. 容错与缓存机制</h3><p>为了保证性能和稳定性，代码中包含了以下机制：</p><ul><li><p><strong>缓存 (Caching)</strong>：</p><ul><li><p>使用 self.cache 存储计算好的拓扑。</p></li><li><p>设置 cache_ttl (20-30秒)，防止频繁查询 Neo4j 导致数据库过载。</p></li></ul></li><li><p><strong>降级模式 (Fallback - 仅在 Service 中)</strong>：</p><ul><li><p>如果 Neo4j 连接失败或返回空数据，RealTopologyService 会调用 _get_container_based_topology。</p></li><li><p><strong>Fallback 逻辑</strong>：直接扫描 Docker 容器，如果发现名为 ethereum 的容器，就根据容器数量“伪造”一个链式的拓扑结构（非网状），以确保界面上至少能看到节点存在，而不是一片空白。</p></li></ul></li></ul><h3 id="4-统计与验证-Statistics-amp-Validation"><a href="#4-统计与验证-Statistics-amp-Validation" class="headerlink" title="4. 统计与验证 (Statistics & Validation)"></a>4. 统计与验证 (Statistics &amp; Validation)</h3><p>EthereumTopologyHandler 还提供了额外的高级功能：</p><ul><li><p><strong>独立查询</strong>：get_nodes 和 get_links 可以不依赖完整拓扑逻辑，直接查询特定层的数据，提高效率。</p></li><li><p><strong>拓扑验证</strong>：validate_topology 检查数据一致性：</p><ul><li><p>节点 ID 是否唯一。</p></li><li><p>连接的源/目标节点是否存在。</p></li><li><p>是否存在孤立节点。</p></li><li><p>IP 地址分布是否异常（例如一个 IP 运行了超过2个主要节点）。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该系统处理以太坊拓扑的核心思想是：<strong>“数据库定义逻辑关系，Docker 定义物理属性，代码负责视觉组装”</strong>。</p><ol><li><p><strong>逻辑层</strong>：谁连谁？由 Neo4j 决定。</p></li><li><p><strong>物理层</strong>：你是谁？由 Docker IP 映射决定。</p></li><li><p><strong>视觉层</strong>：你在哪？由代码中的分层坐标计算逻辑决定（执行层在上，共识层在中，验证者在下）。</p></li></ol><hr><p>目前的实现逻辑虽然功能完整，但在性能上存在几个显著的<strong>瓶颈</strong>，特别是在节点数量增多或 Docker 容器较多时，响应速度会明显下降。</p><p>以下是针对代码的具体性能优化方案，按<strong>提升幅度从大到小</strong>排序：</p><h3 id="1-痛点分析：目前的性能瓶颈在哪里？"><a href="#1-痛点分析：目前的性能瓶颈在哪里？" class="headerlink" title="1. 痛点分析：目前的性能瓶颈在哪里？"></a>1. 痛点分析：目前的性能瓶颈在哪里？</h3><ol><li><p><strong>Docker API 调用过于频繁 (主要瓶颈)</strong>：</p><ul><li><p>_create_ip_to_container_mapping 每次生成拓扑都会被调用。它会遍历<strong>所有</strong>容器并检查网络设置。Docker API 的响应通常是毫秒级到秒级的，如果不缓存，这会严重阻塞主线程。</p></li><li><p>在物理拓扑中，_get_link_bandwidth 会对每个连接进入容器执行 tc 命令。如果有 50 个连接，就要串行执行 50 次 docker exec，这是极慢的 IO 操作。</p></li></ul></li><li><p><strong>串行数据库查询</strong>：</p><ul><li>在 _get_real_topology_from_neo4j 中，执行层查询及处理完之后，才开始共识层的查询。这两者没有依赖关系，完全可以并行。</li></ul></li><li><p><strong>计算密集型的重复操作</strong>：</p><ul><li>每次请求都重新计算所有节点的坐标和映射关系，即使数据没有变化。</li></ul></li></ol><hr><h3 id="2-优化方案一：Docker-数据的独立缓存与后台更新"><a href="#2-优化方案一：Docker-数据的独立缓存与后台更新" class="headerlink" title="2. 优化方案一：Docker 数据的独立缓存与后台更新"></a>2. 优化方案一：Docker 数据的独立缓存与后台更新</h3><p>Docker 的元数据（IP、容器名）变化频率远低于 P2P 网络连接的变化频率。<strong>不要在每次请求拓扑时都去查询 Docker。</strong></p><p><strong>优化策略：</strong> 使用“读写分离”的策略，后台任务更新 Docker 映射，前台请求只读内存变量。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 原有初始化 ...</span><br>        <span class="hljs-variable language_">self</span>.ip_container_map_cache = {}<br>        <span class="hljs-variable language_">self</span>.map_last_update = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.map_update_lock = asyncio.Lock()<br>        <br>        <span class="hljs-comment"># 启动时预热</span><br>        <span class="hljs-comment"># 注意：实际代码中建议使用 apscheduler 或 asyncio.create_task 在后台循环运行</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_ip_to_container_map_optimized</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化后的获取映射方法：</span><br><span class="hljs-string">        1. 优先返回内存缓存</span><br><span class="hljs-string">        2. 缓存过期（如5分钟）才异步更新</span><br><span class="hljs-string">        """</span><br>        current_time = time.time()<br>        <span class="hljs-comment"># 缓存有效期设为 300秒 (Docker容器IP不会频繁变动)</span><br>        <span class="hljs-keyword">if</span> current_time - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br><br>        <span class="hljs-comment"># 如果需要更新，且未被锁定</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.map_update_lock.locked():<br>             <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.map_update_lock:<br>                 <span class="hljs-comment"># 二次检查</span><br>                 <span class="hljs-keyword">if</span> time.time() - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span>: <br>                     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br>                 <br>                 <span class="hljs-comment"># 执行耗时的 Docker 查询</span><br>                 <span class="hljs-comment"># 建议：在一个线程池中运行同步的 docker client 操作，避免阻塞事件循环</span><br>                 loop = asyncio.get_running_loop()<br>                 <span class="hljs-variable language_">self</span>.ip_container_map_cache = <span class="hljs-keyword">await</span> loop.run_in_executor(<br>                     <span class="hljs-literal">None</span>, <span class="hljs-variable language_">self</span>._create_ip_to_container_mapping<br>                 )<br>                 <span class="hljs-variable language_">self</span>.map_last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br></code></pre></td></tr></table></figure><h3 id="3-优化方案二：物理拓扑带宽检测的“非阻塞化”"><a href="#3-优化方案二：物理拓扑带宽检测的“非阻塞化”" class="headerlink" title="3. 优化方案二：物理拓扑带宽检测的“非阻塞化”"></a>3. 优化方案二：物理拓扑带宽检测的“非阻塞化”</h3><p>在 RealTopologyService 中，物理连接的带宽检测（tc 命令）是极其耗时的。绝对不能在用户请求 API 时实时去跑 tc 命令。</p><p><strong>优化策略：</strong> 将带宽数据设为“最终一致性”。主接口只返回拓扑结构，带宽字段先返回缓存值或 “Checking…”，后台任务专门负责轮询更新带宽。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealTopologyService</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-variable language_">self</span>.bandwidth_cache = {} <span class="hljs-comment"># Key: "container_ip", Value: "100Mbit"</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_dynamic_physical_topology_from_containers</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 前面生成 nodes 和 links 的逻辑保持不变 ...</span><br>        <br>        <span class="hljs-comment"># --- 优化点：移除实时 await _get_link_bandwidth ---</span><br>        <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>            target_id = link[<span class="hljs-string">'target'</span>]<br>            target_node = nodes_by_id[target_id]<br>            container_name = target_node[<span class="hljs-string">'container_name'</span>]<br>            link_ip = target_node[<span class="hljs-string">'networks'</span>].get(link[<span class="hljs-string">'shared_network'</span>])<br>            <br>            <span class="hljs-comment"># 1. 尝试从缓存获取</span><br>            cache_key = <span class="hljs-string">f"<span class="hljs-subst">{container_name}</span>::<span class="hljs-subst">{link_ip}</span>"</span><br>            cached_bw = <span class="hljs-variable language_">self</span>.bandwidth_cache.get(cache_key)<br>            <br>            <span class="hljs-keyword">if</span> cached_bw:<br>                link[<span class="hljs-string">'bandwidth'</span>] = cached_bw<br>            <span class="hljs-keyword">else</span>:<br>                link[<span class="hljs-string">'bandwidth'</span>] = <span class="hljs-string">"Querying..."</span><br>                <span class="hljs-comment"># 2. 触发后台更新任务 (Fire and Forget)</span><br>                asyncio.create_task(<span class="hljs-variable language_">self</span>._update_bandwidth_cache(container_name, link_ip, cache_key))<br>                <br>        <span class="hljs-keyword">return</span> nodes, links<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bandwidth_cache</span>(<span class="hljs-params">self, container_name, link_ip, cache_key</span>):<br>        <span class="hljs-string">"""后台单独更新带宽"""</span><br>        bw = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>._get_link_bandwidth(container_name, link_ip)<br>        <span class="hljs-variable language_">self</span>.bandwidth_cache[cache_key] = bw<br></code></pre></td></tr></table></figure><h3 id="4-优化方案三：Neo4j-并发查询"><a href="#4-优化方案三：Neo4j-并发查询" class="headerlink" title="4. 优化方案三：Neo4j 并发查询"></a>4. 优化方案三：Neo4j 并发查询</h3><p>Neo4j 的 Python Driver (尤其是 Bolt 协议) 支持并发。执行层和共识层的查询是独立的，可以使用 asyncio.gather 同时发起查询。</p><p><strong>注意</strong>：这需要你的 database_manager 支持异步操作。如果底层是同步驱动，可以用 run_in_executor 包装。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 EthereumTopologyHandler 中</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_real_topology_from_neo4j</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Dict</span>, <span class="hljs-type">Dict</span>]:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># ... 连接检查 ...</span><br><br>            <span class="hljs-comment"># 定义查询函数</span><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_exec</span>():<br>                <span class="hljs-comment"># 这里假设 database_manager 提供了某种异步执行方式，</span><br>                <span class="hljs-comment"># 或者我们将同步的 session.run 放入线程池</span><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        result = session.run(<span class="hljs-string">"MATCH (n:ExecNode)..."</span>) <span class="hljs-comment"># 填入完整的 Cypher</span><br>                        <span class="hljs-keyword">return</span> {r[<span class="hljs-string">'node_id'</span>]: ... <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result} <span class="hljs-comment"># 处理结果</span><br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_cons_and_validators</span>():<br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        <span class="hljs-comment"># 合并共识节点和验证者的查询逻辑，减少一次 session 创建开销</span><br>                        cons_result = session.run(<span class="hljs-string">"MATCH (n:ConsNode)..."</span>) <br>                        <span class="hljs-comment"># ... 处理共识 ...</span><br>                        validator_result = session.run(<span class="hljs-string">"MATCH ... validators ..."</span>)<br>                        <span class="hljs-comment"># ... 处理验证者 ...</span><br>                        <span class="hljs-keyword">return</span> cons_data<br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-comment"># 并发执行</span><br>            exec_nodes_data, cons_nodes_data = <span class="hljs-keyword">await</span> asyncio.gather(<br>                fetch_exec(), <br>                fetch_cons_and_validators()<br>            )<br><br>            <span class="hljs-keyword">return</span> exec_nodes_data, cons_nodes_data<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># ... Error handling</span><br></code></pre></td></tr></table></figure><h3 id="5-优化方案四：Cypher-查询语句优化"><a href="#5-优化方案四：Cypher-查询语句优化" class="headerlink" title="5. 优化方案四：Cypher 查询语句优化"></a>5. 优化方案四：Cypher 查询语句优化</h3><p>目前的 Cypher 使用了 OPTIONAL MATCH 和 collect，这在数据量大时比较慢。</p><p><strong>原查询：</strong></p><p>codeCypher</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">MATCH (n:ExecNode)<br>OPTIONAL MATCH (n)-<span class="hljs-selector-attr">[r:EXEC_PEERS_WITH]</span>-&gt;(p:ExecNode)<br>RETURN ... <span class="hljs-built_in">collect</span>(...)<br></code></pre></td></tr></table></figure><p>如果在节点很多的情况下，这个查询会扫描整个图。</p><p><strong>优化建议：</strong></p><ol><li><p><strong>分批次</strong>：如果节点超过 1000 个，不要一次性 collect 所有 Peers。前端通常不需要展示所有几千条连线（会卡死浏览器）。可以限制返回的 Peer 数量，例如 LIMIT 10。</p></li><li><p><strong>索引</strong>：确保 node_id, ip 在 Neo4j 中建立了索引 (CREATE INDEX ON :ExecNode(node_id)).</p></li><li><p><strong>只查 ID</strong>：先查出所有 Node 的基础信息，再查 Relation 表（Links），在内存中组装，通常比 Graph DB 做复杂的聚合（Map/Collect）要快。</p></li></ol><h3 id="6-综合改进后的代码结构建议"><a href="#6-综合改进后的代码结构建议" class="headerlink" title="6. 综合改进后的代码结构建议"></a>6. 综合改进后的代码结构建议</h3><p>这里给出一个集成优化思路的 EthereumTopologyHandler 核心方法重构示例：</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-comment"># ... init ...</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_topology</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        <span class="hljs-string">"""获取完整的以太坊拓扑 (优化版)"""</span><br>        <span class="hljs-comment"># 1. 检查拓扑缓存 (Short TTL: e.g., 5s)</span><br>        <span class="hljs-comment"># 拓扑结构变化很快，缓存时间短一点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._is_cache_valid(<span class="hljs-string">"full_ethereum_topology"</span>, ttl=<span class="hljs-number">5</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>]<br><br>        <span class="hljs-comment"># 2. 并行获取数据</span><br>        <span class="hljs-comment"># A. 获取 Docker 映射 (从长效缓存或后台任务获取，极快)</span><br>        <span class="hljs-comment"># B. 获取 Neo4j 数据 (并发查询)</span><br>        <br>        task_docker = <span class="hljs-variable language_">self</span>._get_ip_to_container_map_optimized() <span class="hljs-comment"># 优化点1</span><br>        task_neo4j = <span class="hljs-variable language_">self</span>._get_real_topology_from_neo4j()       <span class="hljs-comment"># 优化点3 (并发内部实现)</span><br>        <br>        ip_map, (exec_data, cons_data) = <span class="hljs-keyword">await</span> asyncio.gather(task_docker, task_neo4j)<br><br>        <span class="hljs-comment"># 3. 转换数据 (CPU 密集型)</span><br>        <span class="hljs-comment"># 如果节点数非常多 (&gt;5000)，可以考虑放入 ProcessPoolExecutor</span><br>        nodes, links = <span class="hljs-variable language_">self</span>._convert_topology_format_optimized(exec_data, cons_data, ip_map)<br><br>        topology_data = {<br>            <span class="hljs-string">'nodes'</span>: nodes, <span class="hljs-string">'links'</span>: links, <span class="hljs-string">'timestamp'</span>: time.time(),<br>            <span class="hljs-comment"># ...</span><br>        }<br><br>        <span class="hljs-comment"># 更新缓存</span><br>        <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>] = topology_data<br>        <span class="hljs-variable language_">self</span>.last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> topology_data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_convert_topology_format_optimized</span>(<span class="hljs-params">self, exec_data, cons_data, ip_map</span>):<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化点：</span><br><span class="hljs-string">        1. 使用 ip_map.get 避免重复循环</span><br><span class="hljs-string">        2. 预计算 positions 字典，避免列表遍历查找</span><br><span class="hljs-string">        """</span><br>        nodes = []<br>        links = []<br>        <span class="hljs-comment"># 使用字典加速查找: key=node_id, value={idx, type, ...}</span><br>        node_lookup = {} <br>        <br>        <span class="hljs-comment"># ... 处理 Exec 节点 ...</span><br>        <span class="hljs-keyword">for</span> i, (nid, data) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exec_data.items()):<br>            <span class="hljs-comment"># 直接查预热好的 Map，O(1)</span><br>            container = ip_map.get(data[<span class="hljs-string">'ip'</span>], <span class="hljs-string">f"exec-<span class="hljs-subst">{data[<span class="hljs-string">'ip'</span>]}</span>"</span>)<br>            <span class="hljs-comment"># ... 创建 node ...</span><br>            node_lookup[nid] = {<span class="hljs-string">'type'</span>: <span class="hljs-string">'execution'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-string">f'<span class="hljs-subst">{nid}</span>-exec'</span>}<br>            <br>        <span class="hljs-comment"># ... 处理 Cons 节点 ...</span><br>        <br>        <span class="hljs-comment"># ... 处理连接 ...</span><br>        <span class="hljs-comment"># 只需要遍历一次 exec_data 的 peers，利用 node_lookup 快速验证</span><br>        <span class="hljs-keyword">for</span> nid, data <span class="hljs-keyword">in</span> exec_data.items():<br>             source_full_id = <span class="hljs-string">f"<span class="hljs-subst">{nid}</span>-exec"</span><br>             <span class="hljs-keyword">for</span> peer <span class="hljs-keyword">in</span> data.get(<span class="hljs-string">'peers'</span>, []):<br>                 target_nid = peer[<span class="hljs-string">'peer_id'</span>]<br>                 <span class="hljs-comment"># O(1) 检查目标是否存在</span><br>                 <span class="hljs-keyword">if</span> target_nid <span class="hljs-keyword">in</span> node_lookup <span class="hljs-keyword">and</span> node_lookup[target_nid][<span class="hljs-string">'type'</span>] == <span class="hljs-string">'execution'</span>:<br>                     links.append({<br>                         <span class="hljs-string">'source'</span>: source_full_id,<br>                         <span class="hljs-string">'target'</span>: <span class="hljs-string">f"<span class="hljs-subst">{target_nid}</span>-exec"</span>,<br>                         <span class="hljs-comment"># ...</span><br>                     })<br>                     <br>        <span class="hljs-keyword">return</span> nodes, links<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>要进行性能优化，最关键的修改是：</p><ol><li><p><strong>Docker 映射</strong>：改为后台定时更新或长缓存，不要每秒都去 inspect 容器。</p></li><li><p><strong>物理带宽 (tc)</strong>：改为异步/后台获取，不要阻塞 API 响应。</p></li><li><p><strong>Neo4j</strong>：使用并发查询，并限制 Cypher 复杂度。</p></li></ol><hr><h2 id="攻击方式（Attack-Strategies）"><a href="#攻击方式（Attack-Strategies）" class="headerlink" title="攻击方式（Attack Strategies）"></a>攻击方式（Attack Strategies）</h2><p>系统目前支持以下6种攻击方式：</p><h3 id="1-节点断网攻击（Node-Disconnection-Attack）"><a href="#1-节点断网攻击（Node-Disconnection-Attack）" class="headerlink" title="1. 节点断网攻击（Node Disconnection Attack）"></a>1. 节点断网攻击（Node Disconnection Attack）</h3><p>通过网络隔离手段切断目标节点与其他节点的连接。支持的方法包括：</p><ul><li><code>interface_down</code>: 禁用网络接口</li><li><code>route_flush</code>: 清除路由表</li><li><code>firewall_block</code>: 防火墙阻断</li><li><code>p2p_block</code>: P2P连接阻断</li></ul><h3 id="2-通信干扰攻击（Communication-Interference-Attack）"><a href="#2-通信干扰攻击（Communication-Interference-Attack）" class="headerlink" title="2. 通信干扰攻击（Communication Interference Attack）"></a>2. 通信干扰攻击（Communication Interference Attack）</h3><p>通过大量无效通信干扰目标节点正常通信。支持的方法包括：</p><ul><li><code>json_rpc_flood</code>: JSON-RPC请求泛洪</li><li><code>p2p_flood</code>: P2P消息泛洪</li><li><code>memory_exhaustion</code>: 内存耗尽攻击</li></ul><h3 id="3-时间攻击（Timestamp-Attack）"><a href="#3-时间攻击（Timestamp-Attack）" class="headerlink" title="3. 时间攻击（Timestamp Attack）"></a>3. 时间攻击（Timestamp Attack）</h3><p>针对共识机制的时间同步进行攻击。支持的方法包括：</p><ul><li>time_shift: 时间偏移</li><li><code>ntp_block</code>: 阻断NTP时间同步</li><li><code>time_drift</code>: 时间漂移</li></ul><h3 id="4-简化Sybil攻击（Simplified-Sybil-Attack）"><a href="#4-简化Sybil攻击（Simplified-Sybil-Attack）" class="headerlink" title="4. 简化Sybil攻击（Simplified Sybil Attack）"></a>4. 简化Sybil攻击（Simplified Sybil Attack）</h3><p>创建虚假节点来影响网络。可以配置：</p><ul><li>虚假节点数量（1-20）</li><li>节点类型（轻节点、全节点、验证者节点）</li><li>网络环境（主网、测试网、开发网）</li><li>连接真实节点选项</li></ul><h3 id="5-存储攻击（Storage-Attack）"><a href="#5-存储攻击（Storage-Attack）" class="headerlink" title="5. 存储攻击（Storage Attack）"></a>5. 存储攻击（Storage Attack）</h3><p>针对节点存储系统的攻击。支持的方法包括：</p><ul><li><code>disk_fill</code>: 磁盘空间填充</li><li><code>database_corruption</code>: 数据库损坏</li><li><code>state_pollution</code>: 状态污染</li><li><code>chain_data_spam</code>: 链上数据垃圾信息</li></ul><h3 id="6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）"><a href="#6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）" class="headerlink" title="6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）"></a>6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）</h3><p>针对特定以太坊客户端的攻击。支持的方法包括：</p><ul><li><code>process_kill</code>: 终止进程</li><li><code>db_corruption</code>: 数据库损坏</li><li><code>port_blocking</code>: 端口阻断</li><li><code>config_modification</code>: 配置文件修改</li></ul><h2 id="攻击模式（Execution-Modes）"><a href="#攻击模式（Execution-Modes）" class="headerlink" title="攻击模式（Execution Modes）"></a>攻击模式（Execution Modes）</h2><p>系统支持三种攻击执行模式：</p><h3 id="1-一次性攻击（One-shot）"><a href="#1-一次性攻击（One-shot）" class="headerlink" title="1. 一次性攻击（One-shot）"></a>1. 一次性攻击（One-shot）</h3><p>执行一次攻击，持续指定时间后自动清理恢复。 配置参数：</p><ul><li>duration_seconds: 攻击持续时间（秒）</li></ul><h3 id="2-重复攻击（Repeated）"><a href="#2-重复攻击（Repeated）" class="headerlink" title="2. 重复攻击（Repeated）"></a>2. 重复攻击（Repeated）</h3><p>按指定间隔重复执行多次攻击。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>repeat_count: 重复次数</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h3 id="3-持续攻击（Continuous）"><a href="#3-持续攻击（Continuous）" class="headerlink" title="3. 持续攻击（Continuous）"></a>3. 持续攻击（Continuous）</h3><p>持续不断地执行攻击，直到手动停止。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h2 id="动态目标攻击"><a href="#动态目标攻击" class="headerlink" title="动态目标攻击"></a>动态目标攻击</h2><p>系统还支持一种特殊的动态目标攻击功能，可以根据网络拓扑分析结果自动选择攻击目标。支持的中心性指标包括：</p><ul><li>度中心性（Degree Centrality）</li><li>介数中心性（Betweenness Centrality）</li><li>接近中心性（Closeness Centrality）</li><li>特征向量中心性（Eigenvector Centrality）</li></ul><p>通过这些攻击方式和模式的组合，系统可以模拟各种真实的以太坊网络攻击场景，帮助评估网络的安全性和鲁棒性。</p><hr><h3 id="1-发起普通攻击-Standard-Attack"><a href="#1-发起普通攻击-Standard-Attack" class="headerlink" title="1. 发起普通攻击 (Standard Attack)"></a>1. 发起普通攻击 (Standard Attack)</h3><p>此接口用于对<strong>明确指定的静态 IP 列表</strong>发起攻击。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate</p></li><li><p><strong>功能</strong>: 发起针对特定静态目标（IP/ID列表）的攻击模拟。</p></li><li><p><strong>逻辑约束</strong>:</p><ol><li><p>parameters.target_nodes 必须是字符串数组 [“ip1”, “ip2”]。</p></li><li><p>支持所有三种执行模式 (one_shot, repeated, continuous)。</p></li></ol></li><li><p><strong>请求体构建规则</strong>:</p><ul><li><p><strong>Level 1 (执行配置)</strong>: 决定攻击的时间维度。</p><ul><li><p>若是 one_shot: 仅需 duration_seconds。</p></li><li><p>若是 repeated: 需额外提供 interval_seconds 和 repeat_count。</p></li></ul></li><li><p><strong>Level 2 (策略参数)</strong>: 决定攻击的具体手段。</p><ul><li><p>必须包含 strategy 字段（枚举值）。</p></li><li><p>其余字段根据 strategy 变化（如 storage_attack 需要 size_mb，而 node_disconnection 不需要）。</p></li></ul></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 场景：对两个节点进行重复的 P2P 洪水攻击</span><br>{<br>  <span class="hljs-string">"execution_config"</span>: {<br>    <span class="hljs-string">"mode"</span>: <span class="hljs-string">"repeated"</span>,<br>    <span class="hljs-string">"duration_seconds"</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">"interval_seconds"</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">"repeat_count"</span>: <span class="hljs-number">5</span><br>  },<br>  <span class="hljs-string">"parameters"</span>: {<br>    <span class="hljs-string">"strategy"</span>: <span class="hljs-string">"communication_interference"</span>,<br>    <span class="hljs-string">"method"</span>: <span class="hljs-string">"p2p_flood"</span>,<br>    <span class="hljs-string">"intensity"</span>: <span class="hljs-string">"high"</span>,<br>    <span class="hljs-string">"target_nodes"</span>: <span class="hljs-selector-attr">[<span class="hljs-string">"192.168.1.10"</span>, <span class="hljs-string">"192.168.1.11"</span>]</span><br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h3 id="2-发起自适应攻击-Adaptive-Attack"><a href="#2-发起自适应攻击-Adaptive-Attack" class="headerlink" title="2. 发起自适应攻击 (Adaptive Attack)"></a>2. 发起自适应攻击 (Adaptive Attack)</h3><p>此接口用于<strong>动态目标</strong>攻击，系统会在每一轮攻击开始前重新计算受害者（例如：总是攻击网络中连接数最多的节点）。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>功能</strong>: 发起自适应攻击，目标由后端实时计算。</p></li><li><p><strong>关键区别</strong>:</p><ol><li><p><strong>不支持</strong> one_shot 模式（因为一次性攻击不需要”自适应”变化）。必须是 repeated 或 continuous。</p></li><li><p>parameters.target_nodes <strong>必须</strong>是特定格式的字符串指令，以 dynamic: 开头。</p></li></ol></li><li><p><strong>目标指令语法</strong>: dynamic:{指标}:{选择策略}</p><ul><li><p>示例: dynamic:degree:top:5 (度中心性最高的前5个)</p></li><li><p>示例: dynamic:betweenness:highest (介数中心性最高的1个)</p></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 场景：持续攻击网络中度中心性最高的前5个节点</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"execution_config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"continuous"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"duration_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"interval_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"strategy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_disconnection"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"firewall_block"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"target_nodes"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dynamic:degree:top:5"</span> <span class="hljs-comment">// 注意这里是字符串</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-前端分流逻辑-Frontend-Logic"><a href="#3-前端分流逻辑-Frontend-Logic" class="headerlink" title="3. 前端分流逻辑 (Frontend Logic)"></a>3. 前端分流逻辑 (Frontend Logic)</h3><p>这是前端 Vue 组件如何决定调用哪个接口的核心逻辑说明。</p><p><strong>Prompt / 逻辑说明:</strong></p><p>前端在点击”发起攻击”按钮时，必须执行以下判断逻辑：</p><ol><li><p><strong>检查目标类型</strong>:</p><ul><li><p>获取用户在表单中输入的目标配置。</p></li><li><p>如果目标是<strong>字符串指令</strong>且以 dynamic: 开头 -&gt; 标记为 isDynamic。</p></li><li><p>如果目标是<strong>手动输入的 IP 列表</strong> -&gt; 标记为 isStatic。</p></li></ul></li><li><p><strong>检查执行模式</strong>:</p><ul><li>获取用户选择的模式 (one_shot, repeated, continuous)。</li></ul></li><li><p><strong>路由决策树</strong>:</p><ul><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode == one_shot):</p><ul><li>❌ <strong>报错</strong>: 自适应攻击不支持一次性模式。</li></ul></li><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode != one_shot):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段发送字符串。</p></li></ul></li><li><p><strong>ELSE</strong> (即静态目标，无论什么模式):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段必须转换为数组 [] 发送。</p></li></ul></li></ul></li></ol><hr><h3 id="4-停止攻击-Stop-Attack"><a href="#4-停止攻击-Stop-Attack" class="headerlink" title="4. 停止攻击 (Stop Attack)"></a>4. 停止攻击 (Stop Attack)</h3><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: DELETE /api/simulations/{attack_id}</p></li><li><p><strong>功能</strong>: 立即终止一个正在运行 (running) 或挂起 (pending) 的攻击任务。</p></li><li><p><strong>适用场景</strong>:</p><ul><li><p>用户点击”紧急停止”按钮。</p></li><li><p>用于中断 continuous (无限持续) 类型的攻击。</p></li><li><p>用于中断剩余轮次尚未执行的 repeated 攻击。</p></li></ul></li><li><p><strong>后端行为</strong>:</p><ul><li><p>取消对应的 asyncio.Task。</p></li><li><p>执行清理逻辑（如恢复防火墙规则、删除垃圾文件）。</p></li><li><p>将数据库中的状态更新为 stopped。</p></li></ul></li></ul><hr><h3 id="5-状态轮询与监控-Monitoring"><a href="#5-状态轮询与监控-Monitoring" class="headerlink" title="5. 状态轮询与监控 (Monitoring)"></a>5. 状态轮询与监控 (Monitoring)</h3><p><strong>Prompt / 接口说明:</strong></p><p>为了在前端展示”实时状态”和”系统日志”，需要配合使用以下两个接口：</p><ol><li><p><strong>获取活跃列表</strong>: GET /api/simulations/active</p><ul><li><p><strong>用途</strong>: 判断当前是否有攻击在跑 (isRunning 状态)。</p></li><li><p><strong>频率</strong>: 建议每 3-5 秒轮询一次。</p></li><li><p><strong>返回</strong>: 包含 progress (进度百分比) 和 current_round (当前轮次)。</p></li></ul></li><li><p><strong>获取详情/日志</strong>: GET /api/simulations/{attack_id}</p><ul><li><p><strong>用途</strong>: 获取特定攻击的详细日志流。</p></li><li><p><strong>返回</strong>: 包含 logs 数组 ([“Attack started”, “Round 1 finished”])。</p></li><li><p><strong>前端展示</strong>: 将 logs 渲染到控制台面板中。</p></li></ul></li></ol><hr><h3 id="总结：数据结构对照表-Type-Mapping"><a href="#总结：数据结构对照表-Type-Mapping" class="headerlink" title="总结：数据结构对照表 (Type Mapping)"></a>总结：数据结构对照表 (Type Mapping)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>参数字段</td><td>描述</td><td>类型限制</td></tr><tr><td><strong>execution_config</strong></td><td></td><td></td></tr><tr><td>mode</td><td>执行模式</td><td>“one_shot” \</td><td>“repeated” \</td><td>“continuous”</td></tr><tr><td>duration_seconds</td><td>单次持续时长</td><td>Integer (秒)</td></tr><tr><td>interval_seconds</td><td>轮次间隔</td><td>Integer (秒), 仅 repeated/continuous 有效</td></tr><tr><td>repeat_count</td><td>重复次数</td><td>Integer, 仅 repeated 有效</td></tr><tr><td><strong>parameters</strong></td><td></td><td></td></tr><tr><td>strategy</td><td>攻击策略</td><td>“node_disconnection” \</td><td>“storage_attack” …</td></tr><tr><td>target_nodes</td><td>攻击目标</td><td>Array [str] (普通) <strong>OR</strong> String dynamic:… (自适应)</td></tr><tr><td>method</td><td>具体手段</td><td>依赖于 strategy (如 firewall_block, disk_fill)</td></tr><tr><td>…</td><td>其他参数</td><td>依赖于 strategy (如 size_mb, intensity)</td></tr></tbody></table></div><hr><h3 id="1-全局枚举定义-Global-Enums"><a href="#1-全局枚举定义-Global-Enums" class="headerlink" title="1. 全局枚举定义 (Global Enums)"></a>1. 全局枚举定义 (Global Enums)</h3><p>这些枚举值用于填充请求体中的特定字段。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>枚举类型</td><td>字段名</td><td>可选值 (Value)</td><td>说明</td></tr><tr><td><strong>执行模式</strong></td><td>mode</td><td>one_shot</td><td><strong>一次性</strong>：执行一次，持续指定时间后恢复。</td></tr><tr><td></td><td></td><td>repeated</td><td><strong>重复执行</strong>：按间隔重复执行多次。</td></tr><tr><td></td><td></td><td>continuous</td><td><strong>持续执行</strong>：按间隔无限执行，直到手动停止。</td></tr><tr><td><strong>攻击策略</strong></td><td>strategy</td><td>node_disconnection</td><td>节点断连攻击</td></tr><tr><td></td><td></td><td>communication_interference</td><td>通信干扰攻击</td></tr><tr><td></td><td></td><td>storage_attack</td><td>存储耗尽攻击</td></tr><tr><td></td><td></td><td>timestamp_attack</td><td>时间/NTP攻击</td></tr><tr><td></td><td></td><td>simplified_sybil_attack</td><td>简化版女巫攻击</td></tr><tr><td></td><td></td><td>geth_lighthouse_attack</td><td>客户端特定攻击 (Geth/Lighthouse)</td></tr></tbody></table></div><hr><h3 id="2-执行配置-execution-config"><a href="#2-执行配置-execution-config" class="headerlink" title="2. 执行配置 (execution_config)"></a>2. 执行配置 (execution_config)</h3><p>根据 mode 的不同，所需字段不同。<strong>注意：自适应攻击接口 (/simulate/adaptive) 不支持 one_shot。</strong></p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>模式 (Mode)</td><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>约束/说明</td></tr><tr><td><strong>通用</strong></td><td>duration_seconds</td><td>Int</td><td>✅</td><td>30</td><td>攻击生效持续时间 (秒)，&gt;=1</td></tr><tr><td><strong>Repeated</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr><tr><td>(重复)</td><td>repeat_count</td><td>Int</td><td>✅</td><td>-</td><td>重复执行的总轮数，&gt;=1</td></tr><tr><td><strong>Continuous</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr></tbody></table></div><hr><h3 id="3-策略参数详情-parameters"><a href="#3-策略参数详情-parameters" class="headerlink" title="3. 策略参数详情 (parameters)"></a>3. 策略参数详情 (parameters)</h3><p>此部分为多态结构，根据 strategy 字段的值，JSON 结构发生变化。</p><h4 id="3-1-节点断连-node-disconnection"><a href="#3-1-节点断连-node-disconnection" class="headerlink" title="3.1 节点断连 (node_disconnection)"></a>3.1 节点断连 (node_disconnection)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>interface_down (网卡下线), route_flush (清空路由), firewall_block (防火墙), p2p_block (P2P阻断)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令 (见第4节)</td></tr></tbody></table></div><h4 id="3-2-通信干扰-communication-interference"><a href="#3-2-通信干扰-communication-interference" class="headerlink" title="3.2 通信干扰 (communication_interference)"></a>3.2 通信干扰 (communication_interference)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>json_rpc_flood (RPC泛洪), p2p_flood (P2P泛洪), memory_exhaustion (内存耗尽)</td></tr><tr><td>intensity</td><td>String</td><td>❌</td><td>medium</td><td>low, medium, high, extreme</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h4 id="3-3-存储攻击-storage-attack"><a href="#3-3-存储攻击-storage-attack" class="headerlink" title="3.3 存储攻击 (storage_attack)"></a>3.3 存储攻击 (storage_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>disk_fill (填充), database_corruption (脏数据), state_pollution (状态污染), chain_data_spam (链上垃圾)</td></tr><tr><td>size_mb</td><td>Int</td><td>❌</td><td>1000</td><td>填充大小 (MB)，100 - 10000</td></tr><tr><td>file_count</td><td>Int</td><td>❌</td><td>100</td><td>生成文件数量，10 - 1000</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-4-时间攻击-timestamp-attack"><a href="#3-4-时间攻击-timestamp-attack" class="headerlink" title="3.4 时间攻击 (timestamp_attack)"></a>3.4 时间攻击 (timestamp_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>time_shift (平移), ntp_block (NTP阻断), time_drift (漂移)</td></tr><tr><td>time_shift</td><td>String</td><td>❌</td><td>+1 hour</td><td>偏移量 (如 +1 hour, -30 minutes)，仅 time_shift 方法有效</td></tr><tr><td>drift_seconds</td><td>Int</td><td>❌</td><td>3600</td><td>漂移秒数，-86400 到 86400，仅 time_drift 方法有效</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-5-女巫攻击-simplified-sybil-attack"><a href="#3-5-女巫攻击-simplified-sybil-attack" class="headerlink" title="3.5 女巫攻击 (simplified_sybil_attack)"></a>3.5 女巫攻击 (simplified_sybil_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>fake_node_count</td><td>Int</td><td>❌</td><td>5</td><td>虚假节点数量 (1-20)</td></tr><tr><td>node_type</td><td>String</td><td>❌</td><td>light</td><td>light (轻节点), full (全节点), validator (验证者)</td></tr><tr><td>network</td><td>String</td><td>❌</td><td>testnet</td><td>mainnet, testnet, devnet</td></tr><tr><td>connect_to_real</td><td>Bool</td><td>❌</td><td>True</td><td>是否连接真实节点</td></tr><tr><td>min_connections</td><td>Int</td><td>❌</td><td>3</td><td>最小连接数 (0-10)</td></tr><tr><td>target_nodes</td><td>-</td><td>-</td><td>-</td><td><strong>注意：此策略通常不需要指定具体目标节点</strong></td></tr></tbody></table></div><h4 id="3-6-客户端攻击-geth-lighthouse-attack"><a href="#3-6-客户端攻击-geth-lighthouse-attack" class="headerlink" title="3.6 客户端攻击 (geth_lighthouse_attack)"></a>3.6 客户端攻击 (geth_lighthouse_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>process_kill, db_corruption, port_blocking, config_modification</td></tr><tr><td>attack_type</td><td>String</td><td>✅</td><td>-</td><td>geth, lighthouse (指定攻击的客户端类型)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><hr><h3 id="4-目标节点配置-target-nodes"><a href="#4-目标节点配置-target-nodes" class="headerlink" title="4. 目标节点配置 (target_nodes)"></a>4. 目标节点配置 (target_nodes)</h3><p>target_nodes 字段在不同接口下有严格的格式要求。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>接口端点</td><td>格式类型</td><td>数据结构示例</td><td>说明</td></tr><tr><td>/api/simulate</td><td><strong>静态列表</strong></td><td>[“192.168.1.10”, “node_id_123”]</td><td>明确指定要攻击的节点列表。</td></tr><tr><td>/api/simulate/adaptive</td><td><strong>动态指令</strong></td><td>“dynamic:degree:top:5”</td><td>字符串格式，后端自动计算目标。</td></tr></tbody></table></div><p><strong>动态指令语法:</strong> dynamic:{指标}:{选择器}</p><ol><li><p><strong>指标 (Metric)</strong>:</p><ul><li><p>degree (度中心性)</p></li><li><p>betweenness (介数中心性)</p></li><li><p>closeness (接近中心性)</p></li><li><p>eigenvector (特征向量中心性)</p></li></ul></li><li><p><strong>选择器 (Selector)</strong>:</p><ul><li><p>highest (选最高的1个)</p></li><li><p>top:N (选前 N 个，N为数字)</p></li></ul></li></ol><hr><h3 id="5-防护配置-defense-enable"><a href="#5-防护配置-defense-enable" class="headerlink" title="5. 防护配置 (/defense/enable)"></a>5. 防护配置 (/defense/enable)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>示例</td><td>说明</td></tr><tr><td>enabled</td><td>Bool</td><td>❌</td><td>true</td><td>是否启用防护</td></tr><tr><td>rules</td><td>Object</td><td>✅</td><td>{“rate_limit”: 100}</td><td>防护规则字典，具体Key由后端逻辑决定</td></tr></tbody></table></div><hr><h3 id="6-响应结构概览"><a href="#6-响应结构概览" class="headerlink" title="6. 响应结构概览"></a>6. 响应结构概览</h3><p>所有接口通常遵循统一的响应格式：</p><p>codeJSON</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">{<br>  <span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>,  <span class="hljs-string">//</span> 或 <span class="hljs-string">"error"</span><br>  <span class="hljs-string">"message"</span>: <span class="hljs-string">"操作描述"</span>,<br>  <span class="hljs-string">"data"</span>: { <span class="hljs-string">...</span> }       <span class="hljs-string">//</span> 具体业务数据<br>}<br></code></pre></td></tr></table></figure><p><strong>关键数据字段 (data)</strong>:</p><ul><li><p>attack_id: (String) 攻击任务的唯一标识符。</p></li><li><p>status: (Enum) pending, running, completed, failed, stopped, cancelled。</p></li><li><p>logs: (Array[Str]) 攻击日志列表。</p></li></ul><p>{<br>  “nodes”: [<br>    {<br>      “id”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”,<br>      “name”: “Tether USD (USDT)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 5<br>    },<br>    {<br>      “id”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”,<br>      “name”: “USD Coin (USDC)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 3<br>    },<br>    {<br>      “id”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”,<br>      “name”: “Uniswap V3: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 8<br>    },<br>    {<br>      “id”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”,<br>      “name”: “Uniswap V3: SwapRouter02”,<br>      “type”: “SwapRouter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 6<br>    },<br>    {<br>      “id”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”,<br>      “name”: “Uniswap V3: Quoter”,<br>      “type”: “Quoter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”,<br>      “name”: “Uniswap V2: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 7<br>    },<br>    {<br>      “id”: “0x881D40237659C251811CEC9c364ef91dC08D300C”,<br>      “name”: “Curve: 3pool Controller”,<br>      “type”: “CurvePool”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”,<br>      “name”: “Curve: 3pool Gauge”,<br>      “type”: “Gauge”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 2<br>    }<br>  ],<br>  “links”: [<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “type”: “transfer_approve” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap_out” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “type”: “swap_in” },<br>    { “source”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “target”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “type”: “call” },<br>    { “source”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “target”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”, “type”: “quote” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “type”: “approve” },<br>    { “source”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “type”: “deposit” },<br>    { “source”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “target”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”, “type”: “stake” }<br>  ],<br>  “timestamp”: 1765095677.891234,<br>  “data_source”: “real_web3”,<br>  “topology_type”: “contract”<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[ETH前端] --&gt; B[src]<br>    A --&gt; C[package.json]<br>    A --&gt; D[index.html]<br>    A --&gt; E[vite.config.ts]<br>    A --&gt; F[README.md]<br>    A --&gt; G[public]<br>    <br>    B --&gt; H[__tests__]<br>    B --&gt; I[api]<br>    B --&gt; J[assets]<br>    B --&gt; K[components]<br>    B --&gt; L[composables]<br>    B --&gt; M[router]<br>    B --&gt; N[services]<br>    B --&gt; O[types]<br>    B --&gt; P[utils]<br>    B --&gt; Q[views]<br>    B --&gt; R[App.vue]<br>    B --&gt; S[main.ts]<br>    <br>    I --&gt; T[api_docs]<br>    I --&gt; U[attack]<br>    <br>    J --&gt; V[styles]<br>    V --&gt; W[global.css]<br>    V --&gt; X[tailwind.css]<br>    <br>    K --&gt; Y[blockchain]<br>    K --&gt; Z[common]<br>    K --&gt; AA[layout]<br>    K --&gt; AB[tabs]<br>    K --&gt; AC[topology]<br>    <br>    Y --&gt; AD[BlockchainCanvas.vue]<br>    Y --&gt; AE[BlockchainInfoPanel.vue]<br>    Y --&gt; AF[BlockchainModal.vue]<br>    Y --&gt; AG[BlockchainVisualization.vue]<br>    Y --&gt; AH[composables]<br>    Y --&gt; AI[types]<br>    <br>    AH --&gt; AJ[useBlockchainAPI.ts]<br>    AH --&gt; AK[useBlockchainAnimations.ts]<br>    AH --&gt; AL[useBlockchainData.ts]<br>    AH --&gt; AM[useBlockchainEvents.ts]<br>    AH --&gt; AN[useBlockchainRenderer.ts]<br>    AH --&gt; AO[useBlockchainScrolling.ts]<br>    <br>    Z --&gt; AP[ContainerTerminal.vue]<br>    Z --&gt; AQ[DEP-TERM.vue]<br>    Z --&gt; AR[StandaloneTerminal.vue]<br>    Z --&gt; AS[Terminal.vue]<br>    Z --&gt; AT[websocket_terminal8080.vue]<br>    <br>    AA --&gt; AU[DashboardHeader.vue]<br>    AA --&gt; AV[LeftPanel.vue]<br>    AA --&gt; AW[PanelSplitter.vue]<br>    AA --&gt; AX[RightPanel.vue]<br>    <br>    AB --&gt; AY[AttackMonitoringTab.vue]<br>    AB --&gt; AZ[Attack_sys]<br>    AB --&gt; BA[BlockchainBrowserTab.css]<br>    AB --&gt; BB[BlockchainBrowserTab.vue]<br>    AB --&gt; BC[ContainerListTab.vue]<br>    AB --&gt; BD[NetworkTopologyTab.vue]<br>    AB --&gt; BE[sections]<br>    AB --&gt; BF[tabstyle.css]<br>    <br>    AZ --&gt; BG[AttackSystemTab.vue]<br>    BE --&gt; BH[Network-analysis.vue]<br>    BE --&gt; BI[NodeInfoPanel.vue]<br>    BE --&gt; BJ[RealTimeMonitoring.vue]<br>    <br>    AC --&gt; BK[ContractTopology.vue]<br>    AC --&gt; BL[Ethereum_Topology]<br>    AC --&gt; BM[Physical_Topology]<br>    AC --&gt; BN[TopologyVisualization.vue]<br>    AC --&gt; BO[TransactionTopology.vue]<br>    AC --&gt; BP[composables]<br>    AC --&gt; BQ[types]<br>    <br>    BL --&gt; BR[types]<br>    BL --&gt; BS[workers]<br>    BL --&gt; BT[EthereumTopology_new.vue]<br>    BL --&gt; BU[useD3Renderer.ts]<br>    BL --&gt; BV[use_topology_core.ts]<br>    BL --&gt; BW[use_topology_visuals.ts]<br>    <br>    BM --&gt; BX[composables]<br>    BM --&gt; BY[PhysicalTopology.vue]<br>    <br>    BP --&gt; BZ[index.ts]<br>    BP --&gt; CA[topology.css]<br>    BP --&gt; CB[useTopologyAPI.ts]<br>    BP --&gt; CC[useTopologyData.ts]<br>    BP --&gt; CD[useTopologyRendererBase.ts]<br>    <br>    L --&gt; CE[useDashboardData.ts]<br>    L --&gt; CF[useDashboardLayout.ts]<br>    L --&gt; CG[useDashboardTabs.ts]<br>    <br>    M --&gt; CH[index.ts]<br>    <br>    N --&gt; CI[analysis.ts]<br>    N --&gt; CJ[api.ts]<br>    N --&gt; CK[apiService.ts]<br>    N --&gt; CL[attack.ts]<br>    N --&gt; CM[blockchain.ts]<br>    N --&gt; CN[daily-operations.ts]<br>    N --&gt; CO[device-monitoring.ts]<br>    N --&gt; CP[execution.ts]<br>    N --&gt; CQ[foundation.ts]<br>    N --&gt; CR[monitoring.ts]<br>    N --&gt; CS[readme.md]<br>    N --&gt; CT[root-api.ts]<br>    N --&gt; CU[security.ts]<br>    N --&gt; CV[temporal.ts]<br>    N --&gt; CW[topology.ts]<br>    <br>    O --&gt; CX[topology.ts]<br>    <br>    P --&gt; CY[http.ts]<br>    P --&gt; CZ[index.ts]<br>    P --&gt; DA[types.ts]<br>    <br>    Q --&gt; DB[BlockchainTest.vue]<br>    Q --&gt; DC[Dashboard.vue]<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;性能优化 (Web Workers)&lt;/strong&gt;: 目前的数据获取、解析和Diff算法都在&lt;strong&gt;主线程&lt;/strong&gt;运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 &lt;strong&gt;Web Worker&lt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-05-字节工训营画布项目相关设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/17798.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/17798.html</id>
    <published>2025-12-04T18:00:16.000Z</published>
    <updated>2025-12-25T03:23:33.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BDdraw-DEV"><a href="#BDdraw-DEV" class="headerlink" title="BDdraw_DEV"></a>BDdraw_DEV</h1><p>代码仓库：<br><a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>现代协同 2D 画布编辑器 · React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8</p><h4 id="技术栈-·-Tech-Stack"><a href="#技术栈-·-Tech-Stack" class="headerlink" title="技术栈 · Tech Stack"></a>技术栈 · Tech Stack</h4><p class='item-img' data-src='https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white'><img src="https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white" alt="React 18"> <img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5" class='item-img' data-src='https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white'><img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5"> <img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6" class='item-img' data-src='https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white'><img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6"> <img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate" class='item-img' data-src='https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4'><img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate"> <img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design" class='item-img' data-src='https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white'><img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design"> <img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide" class='item-img' data-src='https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white'><img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide"> <img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer" class='item-img' data-src='https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white'><img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer"> <img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8" class='item-img' data-src='https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white'><img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8"> <img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3" class='item-img' data-src='https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white'><img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3"> <img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12" class='item-img' data-src='https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white'><img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12"> <img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid" class='item-img' data-src='https://img.shields.io/badge/nanoid-5.1.6-000000'><img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid"> <img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint" class='item-img' data-src='https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white'><img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint"> <img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky" class='item-img' data-src='https://img.shields.io/badge/Husky-8.0.3-7711A4'><img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky"> <img src="https://img.shields.io/badge/Deploy-GitHub_Pages-222222?logo=githubpages&logoColor=white" alt="GitHub Pages"></p><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p><strong>frontend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:Zhongye1/BDdraw_DEV.git<br><br><span class="hljs-built_in">cd</span> BDdraw_DEV (进入项目)<br>bun install (安装依赖包)<br>bun start (启动服务)<br></code></pre></td></tr></table></figure><p><strong>backend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> BDdraw_DEV/ALD_Backend/<br>bun install <span class="hljs-comment">#安装依赖</span><br>bun index.ts  <span class="hljs-comment">#启动后端服务</span><br></code></pre></td></tr></table></figure><p>推荐使用 bun 包管理器，见个人博客</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/15722.html">关于包管理器 npm,pnpm,yarn 和 bun 以及我为何选择后者</a></p><h4 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h4><p>项目支持通过 Docker 进行容器化部署，使用 Node 22 和 Bun 包管理器。</p><p><strong>开发环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><strong>生产环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -f docker-compose.prod.yml up -d<br></code></pre></td></tr></table></figure><p>部署完成后，可以通过以下地址访问：</p><ul><li>前端应用: <a href="http://localhost:5000/BDdraw_DEV/">http://localhost:5000/BDdraw_DEV/</a></li><li>后端 API 文档: <a href="http://localhost:3000/swagger-ui">http://localhost:3000/swagger-ui</a></li></ul><h4 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h4><p>项目采用了模块化的架构设计，将不同的功能划分为独立的模块，以方便后续维护和扩展</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>60 FPS 渲染（得益于 PixiJS WebGL）</li><li>完整撤销/重做（Command Pattern + 防抖快照）</li><li>多元素选择与群组操作</li><li>画布元素变换控制器</li><li>富文本所见即所得编辑（WanngEditor + PIXI.HTMLText）</li><li>图片插入 + 内置滤镜（模糊、亮度、灰度等）</li><li>插件式元素系统</li><li>插件式元素系统</li><li>完整的 TypeScript 类型支持</li><li>现代开发体验（Vite + ESLint + Prettier + Husky）</li><li>集成 GitHub-Actions 支持， 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</li></ul><hr><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>这时候需要简单做一个技术选型分析，根据任务拆解，选择了如下技术栈</p><p><strong>【框架】</strong>【技术方案：采用 React 18 + TypeScript 5 构建应用，React 提供完整的 UI 生态，TypeScript 提供更清晰可靠的类型安全，相比 JavaScript 更易于维护】</p><p><strong>【构建工具】</strong>【技术方案：使用 Vite 5 作为构建工具，其开发服务器启动和热模块替换（HMR）速度明显快于 Webpack】</p><p><strong>【路由】</strong>【技术方案：采用 React Router DOM 6 实现路由管理，API 稳定且文档完善】</p><p><strong>【样式】</strong>【技术方案：使用 Tailwind CSS 3 + PostCSS 处理样式，开发时编写样式更快，生产环境会自动进行 tree-shaking 优化，相比 CSS Modules 和 styled-components 更高效且原子化更直观，对 AI 工具友好】</p><p><strong>【样式扩展】</strong>【技术方案：少量使用 Less 覆盖 Tailwind 主题变量，保持兼容性】</p><p><strong>【SVG 处理】</strong>【技术方案：使用 SVGR 1.5 处理 SVG，Vite 原生支持，可以将 SVG 作为 React 组件使用，比直接使用 SVG 或 SVG sprite 更灵活】</p><p><strong>【UI 组件库】</strong>【技术方案：采用 shadcn/ui（latest）和 Arco Design 2 实现 UI 组件，易于使用，符合字节项目使用字节组件库的习惯】</p><p><strong>【全局状态】</strong>【技术方案：采用 Zustand 4 管理全局状态，API 简洁、性能良好且无样板代码，相比 Redux Toolkit、Pinia、Jotai 代码量更少且配有 Devtools】</p><p><strong>【图形/画布】</strong>【技术方案：使用 PixiJS 8 + pixi-viewport 实现图形和画布功能，基于 WebGL 渲染，适合处理大量精灵元素，相比其他可选方案性能更高】</p><p><strong>【富文本编辑器】</strong>【技术方案：采用 WangEditor 5 作为富文本编辑器，轻量且文档和社区均为中文，相比 Slate/TipTap 等编辑器，默认输出的 HTML 可直接给 PixiJS HTMLText 进行渲染】</p><p><strong>【图标】</strong>【技术方案：使用 Lucide React 图标库，图标数量多、风格统一且支持 Tree-shaking】</p><p><strong>【工具库】</strong>【技术方案：采用 nanoid 3 为画布元素生成唯一标识符等操作，轻量实用】</p><p><strong>【代码质量】</strong>【技术方案：使用 ESLint + Stylelint + Prettier + Husky + lint-staged + commitlint 保证团队代码风格一致，这是中大型项目的基本配置，有利于多人协作开发】</p><p>此外，还配置了 react 开发者工具 react-dev-inspector，配置了一下，开发环境下 ctrl+q 可以实现点击页面上的组件，在 VSCode 中自动跳转到对应文件，并定位到对应行号，方便调试（先前写 vue 也用过类似的）</p><p>项目 <a href="https://react-dev-inspector.zthxxx.me/docs">https://react-dev-inspector.zthxxx.me/docs</a></p><h3 id="功能要素和方案"><a href="#功能要素和方案" class="headerlink" title="功能要素和方案"></a>功能要素和方案</h3><p>分析以上需求，查阅相关资料后，进行各个核心模块的技术方案选型，确定初步实现方案</p><p><strong>【基础渲染引擎】</strong>【技术方案：PixiJS v8（WebGL）提供高性能 2D 渲染，根据不同元素类型创建对应的 Pixi 对象（图形、文本、图像），通过 pixi-viewport 实现无限画布的视口控制，支持缩放、拖拽等交互】</p><p><strong>【无限画布视口】</strong>【技术方案：pixi-viewport（内置 zoom、drag、decelerate、clampZoom）库创建无限画布，在 StageManagerCore.ts 中初始化 viewport，并添加拖拽、缩放等交互功能，支持鼠标中键拖拽画布、滚轮缩放等常见操作】</p><p><strong>【富文本编辑】</strong>【技术方案：WangEditor 5 作为富文本编辑器，提供完整的文本编辑功能，编辑结果以 HTML 格式存储在元素的 text/string 属性中，元素使用 PixiJS 内置的 HTMLText 进行渲染实现富文本效果】</p><p><strong>【状态管理与数据结构】</strong>【技术方案：Zustand 作为全局状态管理库，通过 structuredClone 函数手动创建状态快照，管理画布元素、选中状态、工具类型等，通过中间件监听状态变化并触发重渲染，在特定的 ts 中定义所有状态和操作方法】</p><p><strong>【图片上传显示与滤镜】</strong>【技术方案：PixiJS 内置 Filter 系统包括 BlurFilter、ColorMatrixFilter（黑白、对比度、饱和度）实现图像处理效果，支持模糊、亮度调整、灰度等多种滤镜效果，在 ElementRenderer.ts 中根据元素的 filter 属性应用相应滤镜，支持 blur（模糊）、brightness（亮度）、grayscale（灰度）等滤镜类型】</p><p><strong>【选中与变换系统】</strong>【技术方案：SelectionManager + TransformOverlay（8 个把手 + 旋转把手）实现变换控件渲染，支持单个元素选中和多个元素群组选中，提供 8 个控制点和 1 个旋转点进行变换操作，根据不同元素类型提供不同的控制方式】</p><p><strong>【旋转与组合嵌套】</strong>【技术方案：每个元素维护自己的 matrix（局部矩阵），组合后父容器统一应用矩阵变换，支持多层级嵌套和复杂变换】</p><p><strong>【Minimap】</strong>【技术方案：单独一个小的 Pixi.Application（共享 texture 缓存）实现缩略图功能，主画布所有容器使用 cacheAsBitmap 后生成低分辨率 texture，实时更新到小画布，视口框用一个半透明矩形表示在主画布中的位置】</p><p><strong>【元素永久缓存】</strong>【技术方案：使用 spriteMap 来存储 PIXI 对象，元素更新时只修改属性并设置 container.dirty = true，而不是销毁重建，来解决拖拽中断、光标丢失、闪烁等问题】</p><p><strong>【辅助对齐线】</strong>【技术方案：拖拽时实时遍历所有元素 bounds，计算对齐情况（水平/垂直/间距相等），差值&lt;6px 就吸附并画蓝线，支持水平、垂直对齐以及等间距对齐等多种对齐方式，当距离小于阈值时自动吸附并对齐】</p><p><strong>【Undo/Redo】</strong>【技术方案：Command Pattern + structuredClone 完整快照（每步 before/after）实现撤销/重做功能，通过管理命令栈（undo，redo 栈），使用 structuredClone 创建状态快照，记录操作前后的完整状态，来支持添加元素、删除元素、修改元素属性等操作的撤销/重做，针对拖拽和调整大小操作的命令生成逻辑可能还要具体再处理一套】</p><p><strong>【数据持久化与离线】</strong>【技术方案：Zustand-persist + localForage（IndexedDB）实现数据持久化和离线使用，使用 Zustand 的持久化中间件保存状态，通过 localForage 将数据存储到 IndexedDB 中，实现数据的自动保存和恢复功能】</p><p><strong>【实时协同】</strong>【技术方案：Y.js + y-websocket（或自己写 CRDT）+ Operation Transform 合并策略实现无冲突的实时协同编辑，通过 y-websocket 插件实现服务端同步（问的 AI），有个思路是把操作打给时间 tag，然后然后按时间合并】</p><hr><h4 id="项目架构树"><a href="#项目架构树" class="headerlink" title="项目架构树"></a>项目架构树</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs sh">BDdraw_DEV/<br>├── ALD_Backend/                    <span class="hljs-comment"># 后端服务目录</span><br>│   ├── src/                        <span class="hljs-comment"># 后端源代码</span><br>│   │   ├── api/                    <span class="hljs-comment"># API接口目录</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关API</span><br>│   │   │   │   ├── types/          <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   │   ├── CORE.ts         <span class="hljs-comment"># 核心房间管理逻辑</span><br>│   │   │   │   ├── Room_CRUD.ts    <span class="hljs-comment"># 房间增删改查操作实现</span><br>│   │   │   │   ├── Room_List.ts    <span class="hljs-comment"># 房间列表管理实现</span><br>│   │   │   │   └── Room_users.ts   <span class="hljs-comment"># 房间用户管理实现</span><br>│   │   │   ├── USER_management/    <span class="hljs-comment"># 用户管理相关API</span><br>│   │   │   │   ├── auth_API.ts     <span class="hljs-comment"># 用户认证API实现</span><br>│   │   │   │   └── auth_API_types.ts  <span class="hljs-comment"># 用户认证类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API索引文件</span><br>│   │   ├── auth.ts                 <span class="hljs-comment"># 认证模块实现</span><br>│   │   ├── collab.ts               <span class="hljs-comment"># 协作功能模块实现</span><br>│   │   └── db.ts                   <span class="hljs-comment"># 数据库连接和操作实现</span><br>│   ├── ARCHITECTURE.md             <span class="hljs-comment"># 后端架构说明文档</span><br>│   ├── README.md                   <span class="hljs-comment"># 后端说明文档</span><br>│   ├── index.ts                    <span class="hljs-comment"># 后端服务入口文件</span><br>│   ├── package.json                <span class="hljs-comment"># 后端依赖配置文件</span><br>│   └── tsconfig.json               <span class="hljs-comment"># 后端TypeScript配置</span><br>├── src/                            <span class="hljs-comment"># 前端源代码目录</span><br>│   ├── api/                        <span class="hljs-comment"># 前端API客户端</span><br>│   │   ├── types/                  <span class="hljs-comment"># API类型定义</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   ├── auth_API_types.ts   <span class="hljs-comment"># 认证相关类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API类型索引文件</span><br>│   │   ├── utils/                  <span class="hljs-comment"># API工具函数</span><br>│   │   │   └── apiClient.ts        <span class="hljs-comment"># API客户端工具</span><br>│   │   ├── apiService.ts           <span class="hljs-comment"># API服务封装实现</span><br>│   │   └── index.ts                <span class="hljs-comment"># API索引文件</span><br>│   ├── components/                 <span class="hljs-comment"># React组件目录</span><br>│   │   ├── Richtext_editor/        <span class="hljs-comment"># 富文本编辑器组件</span><br>│   │   │   ├── BottomTextEditor.tsx    <span class="hljs-comment"># 底部文本编辑器实现</span><br>│   │   │   └── Richtext_editor.tsx     <span class="hljs-comment"># 富文本编辑器主组件</span><br>│   │   ├── canvas_toolbar/         <span class="hljs-comment"># 画布工具栏组件</span><br>│   │   │   ├── ContextMenu.tsx     <span class="hljs-comment"># 上下文菜单实现</span><br>│   │   │   └── TopToolbar.tsx      <span class="hljs-comment"># 顶部工具栏实现</span><br>│   │   ├── collaboration/          <span class="hljs-comment"># 协作功能组件</span><br>│   │   │   ├── CollaboratorCursors.tsx <span class="hljs-comment"># 协作者光标显示组件</span><br>│   │   │   └── RemoteSelectionLayer.tsx <span class="hljs-comment"># 远程选择层组件</span><br>│   │   ├── error-page/             <span class="hljs-comment"># 错误页面组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 错误页面实现</span><br>│   │   ├── header/                 <span class="hljs-comment"># 页面头部组件</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 头部内容组件</span><br>│   │   │   │   ├── ExportCanvasModal.tsx   <span class="hljs-comment"># 导出画布模态框</span><br>│   │   │   │   └── StageManagerContext.tsx <span class="hljs-comment"># 舞台管理上下文</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 头部组件入口</span><br>│   │   ├── image-insert-modal/     <span class="hljs-comment"># 图片插入模态框组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 图片插入模态框实现</span><br>│   │   ├── layout/                 <span class="hljs-comment"># 布局组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 布局组件实现</span><br>│   │   ├── minimap/                <span class="hljs-comment"># 小地图组件</span><br>│   │   │   └── Minimap.tsx         <span class="hljs-comment"># 小地图实现</span><br>│   │   ├── property-panel/         <span class="hljs-comment"># 属性面板组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 属性面板实现</span><br>│   │   ├── settings/               <span class="hljs-comment"># 设置组件</span><br>│   │   │   └── setting.tsx         <span class="hljs-comment"># 设置组件实现</span><br>│   │   ├── ui/                     <span class="hljs-comment"># 基础UI组件</span><br>│   │   │   ├── blackwhitebutton.tsx    <span class="hljs-comment"># 黑白按钮组件</span><br>│   │   │   ├── button.tsx          <span class="hljs-comment"># 按钮组件</span><br>│   │   │   ├── icon-circle.tsx     <span class="hljs-comment"># 圆形图标组件</span><br>│   │   │   ├── icon-clear.tsx      <span class="hljs-comment"># 清除图标组件</span><br>│   │   │   ├── icon-rect.tsx       <span class="hljs-comment"># 矩形图标组件</span><br>│   │   │   ├── icon-select.tsx     <span class="hljs-comment"># 选择图标组件</span><br>│   │   │   └── icon-triangle.tsx   <span class="hljs-comment"># 三角形图标组件</span><br>│   │   ├── AnimatedRoutes.tsx      <span class="hljs-comment"># 动画路由组件</span><br>│   │   ├── ParallaxBackground.tsx  <span class="hljs-comment"># 视差背景组件</span><br>│   │   └── WipeTransition.tsx      <span class="hljs-comment"># 擦除过渡动画组件</span><br>│   ├── hooks/                      <span class="hljs-comment"># 自定义React Hooks</span><br>│   │   ├── use-localstorage-state.ts   <span class="hljs-comment"># localStorage状态管理Hook</span><br>│   │   └── use_React_hotkeys_management.ts <span class="hljs-comment"># 快捷键管理Hook</span><br>│   ├── lib/                        <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   │   ├── AddElementCommand.ts    <span class="hljs-comment"># 添加元素命令实现</span><br>│   │   ├── RemoveElementCommand.ts <span class="hljs-comment"># 删除元素命令实现</span><br>│   │   ├── UndoRedoManager.ts      <span class="hljs-comment"># 撤销重做管理器实现</span><br>│   │   ├── UpdateElementCommand.ts <span class="hljs-comment"># 更新元素命令实现</span><br>│   │   ├── UpdateElementPropertyCommand.ts <span class="hljs-comment"># 更新元素属性命令实现</span><br>│   │   ├── constants.ts            <span class="hljs-comment"># 常量定义文件</span><br>│   │   ├── env.ts                  <span class="hljs-comment"># 环境变量配置</span><br>│   │   ├── minimapUtils.ts         <span class="hljs-comment"># 小地图工具函数</span><br>│   │   └── utils.ts                <span class="hljs-comment"># 通用工具函数</span><br>│   ├── pages/                      <span class="hljs-comment"># 页面组件目录</span><br>│   │   ├── auth/                   <span class="hljs-comment"># 认证相关页面</span><br>│   │   │   ├── Login.tsx           <span class="hljs-comment"># 登录页面实现</span><br>│   │   │   └── Register.tsx        <span class="hljs-comment"># 注册页面实现</span><br>│   │   ├── canvas/                 <span class="hljs-comment"># 画布主页面</span><br>│   │   │   ├── Pixi_STM_modules/   <span class="hljs-comment"># Pixi.js状态管理模块</span><br>│   │   │   │   ├── core/           <span class="hljs-comment"># 核心类和初始化逻辑</span><br>│   │   │   │   │   ├── Core_StageManager.ts    <span class="hljs-comment"># 核心舞台管理器</span><br>│   │   │   │   │   ├── ElementRender.ts        <span class="hljs-comment"># 元素渲染器</span><br>│   │   │   │   │   ├── TF_controler_Renderer.ts <span class="hljs-comment"># 变换控制器渲染器</span><br>│   │   │   │   │   └── types.ts                <span class="hljs-comment"># 核心类型定义</span><br>│   │   │   │   ├── interaction/    <span class="hljs-comment"># 交互处理模块</span><br>│   │   │   │   │   ├── Base_InteractionHandler.ts   <span class="hljs-comment"># 基础交互处理器</span><br>│   │   │   │   │   └── Stage_InteractionHandler.ts  <span class="hljs-comment"># 舞台交互处理器</span><br>│   │   │   │   ├── shared/         <span class="hljs-comment"># 共享类型定义</span><br>│   │   │   │   │   └── types.ts    <span class="hljs-comment"># 共享类型定义文件</span><br>│   │   │   │   ├── utils/          <span class="hljs-comment"># 工具函数目录</span><br>│   │   │   │   │   ├── commandUtils.ts      <span class="hljs-comment"># 命令工具函数</span><br>│   │   │   │   │   ├── cursorUtils.ts       <span class="hljs-comment"># 光标工具函数</span><br>│   │   │   │   │   ├── destroyUtils.ts      <span class="hljs-comment"># 销毁工具函数</span><br>│   │   │   │   │   ├── dragUtils.ts         <span class="hljs-comment"># 拖拽工具函数</span><br>│   │   │   │   │   ├── drawingUtils.ts      <span class="hljs-comment"># 绘图工具函数</span><br>│   │   │   │   │   ├── eraserUtils.ts       <span class="hljs-comment"># 橡皮擦工具函数</span><br>│   │   │   │   │   ├── geometryUtils.ts     <span class="hljs-comment"># 几何工具函数</span><br>│   │   │   │   │   ├── guidelineUtils.ts    <span class="hljs-comment"># 辅助线工具函数</span><br>│   │   │   │   │   ├── interactionUtils.ts  <span class="hljs-comment"># 交互工具函数</span><br>│   │   │   │   │   ├── renderUtils.ts       <span class="hljs-comment"># 渲染工具函数</span><br>│   │   │   │   │   ├── resizeUtils.ts       <span class="hljs-comment"># 调整大小工具函数</span><br>│   │   │   │   │   ├── rotationUtils.ts     <span class="hljs-comment"># 旋转工具函数</span><br>│   │   │   │   │   ├── scaleUtils.ts        <span class="hljs-comment"># 缩放工具函数</span><br>│   │   │   │   │   ├── selectionUtils.ts    <span class="hljs-comment"># 选择工具函数</span><br>│   │   │   │   │   └── stateUtils.ts        <span class="hljs-comment"># 状态工具函数</span><br>│   │   │   │   └── STM_modules.md  <span class="hljs-comment"># 状态管理模块说明文档</span><br>│   │   │   ├── Pixi_stageManager.ts    <span class="hljs-comment"># Pixi舞台管理器入口</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 画布页面入口文件</span><br>│   │   ├── home/                   <span class="hljs-comment"># 主页</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 主页内容组件</span><br>│   │   │   │   └── AKN.tsx         <span class="hljs-comment"># AKN内容组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 主页入口文件</span><br>│   │   ├── intro/                  <span class="hljs-comment"># 介绍页面</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 介绍页面实现</span><br>│   │   └── room/                   <span class="hljs-comment"># 房间管理页面</span><br>│   │       └── RoomManagement.tsx  <span class="hljs-comment"># 房间管理页面实现</span><br>│   ├── router/                     <span class="hljs-comment"># 路由配置目录</span><br>│   │   └── router.tsx              <span class="hljs-comment"># 路由配置实现</span><br>│   ├── stores/                     <span class="hljs-comment"># 状态存储目录(Zustand)</span><br>│   │   ├── canvasStore.ts          <span class="hljs-comment"># 画布状态存储</span><br>│   │   ├── persistenceStore.ts     <span class="hljs-comment"># 持久化状态存储</span><br>│   │   └── themeStore.ts           <span class="hljs-comment"># 主题状态存储</span><br>│   ├── app.tsx                     <span class="hljs-comment"># 应用根组件</span><br>│   ├── main.tsx                    <span class="hljs-comment"># 应用入口文件</span><br>│   └── vite-env.d.ts               <span class="hljs-comment"># Vite环境声明文件</span><br>├── README.md                       <span class="hljs-comment"># 项目说明文档</span><br>├── components.json                 <span class="hljs-comment"># 组件配置文件</span><br>├── index.html                      <span class="hljs-comment"># HTML入口文件</span><br>├── lint-staged.config.js           <span class="hljs-comment"># Lint-staged配置</span><br>├── package.json                    <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js               <span class="hljs-comment"># PostCSS配置</span><br>├── tailwind.config.js              <span class="hljs-comment"># Tailwind CSS配置</span><br>├── transmart.config.ts             <span class="hljs-comment"># Transmart配置</span><br>├── tsconfig.json                   <span class="hljs-comment"># TypeScript配置</span><br>├── tsconfig.node.json              <span class="hljs-comment"># Node.js TypeScript配置</span><br>└── vite.config.ts                  <span class="hljs-comment"># Vite构建配置</span><br></code></pre></td></tr></table></figure><h3 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h3><p>项目采用数据驱动视图（Data-Driven View）模式，使用<strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>的三层架构</p><p>React 只负责 UI 和事件入口<br>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）<br>PixiJS 层只做”渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建<br>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</p><p>项目主要划分为三个层次：渲染层、状态管理层和逻辑层，来实现关注点分离，提高代码的可维护性和可扩展性。</p><h4 id="渲染层"><a href="#渲染层" class="headerlink" title="渲染层"></a><strong>渲染层</strong></h4><p>主要由 PixiJS (WebGL) 负责处理图形渲染，包括创建、更新和删除图形对象。这一层负责将状态管理层的数据转换为可视化的图形元素，并处理用户的交互操作，如拖拽、缩放和旋转等</p><h4 id="状态管理层"><a href="#状态管理层" class="headerlink" title="状态管理层"></a><strong>状态管理层</strong></h4><p>采用 Zustand 管理 JSON 画布数据。<br>先定义一个 CanvasState 接口（JSON 数据结构，包含 id, type, x, y, width, height 等属性）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span> <span class="hljs-comment">// 当前工具类型</span><br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt; <span class="hljs-comment">// 画布元素集合</span><br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[] <span class="hljs-comment">// 选中元素ID列表</span><br>  <span class="hljs-attr">editingId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 正在编辑的元素ID</span><br>  <span class="hljs-attr">clipboard</span>: <span class="hljs-title class_">CanvasElement</span>[] | <span class="hljs-literal">null</span> <span class="hljs-comment">// 剪贴板数据</span><br>  <span class="hljs-attr">pasteOffset</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 粘贴偏移计数</span><br>  <span class="hljs-attr">currentStyle</span>: {<br>    <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-comment">// ... 其他样式属性</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p>使用 Zustand 状态管理库，其中 elements 被定义为 Record<string, CanvasElement="">类型，表示一个以 id 为键，CanvasElement 为值的对象，用于存储画布上的所有元素。更新元素时使用 structuredClone 函数来克隆状态数据。后续持久化存储和撤销重做机制也是基于这一套状态管理来实现。这一层作为数据核心，主要维护画布上所有元素的状态信息，通过集中管理状态，确保了数据的一致性，便于后续的协同编辑和撤销重做功能的开发。</string,></p><h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a><strong>逻辑层</strong></h4><p>核心是 StageManagerCore 类，通过 StageManagerState 接口管理交互状态，包括当前交互模式、起始位置、当前元素 ID、初始元素状态等，处理多种交互模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">idle - 空闲状态<br>panning - 画布平移<br>selecting - 选择元素<br>dragging - 拖拽元素<br>resizing - 调整元素大小<br>drawing - 绘制元素<br>texting - 文本编辑<br>erasing - 擦除元素<br></code></pre></td></tr></table></figure><p>处理多种元素操作逻辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建元素 - 根据不同工具类型创建相应元素<br>选择元素 - 支持单选和多选<br>拖拽元素 - 记录初始状态，计算偏移量<br>调整大小 - 通过控制手柄调整元素尺寸<br>删除元素 - 通过橡皮擦工具删除元素<br></code></pre></td></tr></table></figure><p>通过这种方式来实现面向对象编程并封装业务逻辑，提高代码的可维护性，利用后续拓展</p><hr><h3 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h3><p class='item-img' data-src='./assets/image-20251123121234358.png'><img src="./assets/image-20251123121234358.png" alt="image-20251123121234358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互类型}<br>    B --&gt;|创建元素| C[StageManagerCore.onPointerDown]<br>    B --&gt;|拖拽元素| D[StageManagerCore.onPointerMove]<br>    B --&gt;|调整大小| E[StageManagerCore.onHandleDown]<br>    B --&gt;|选择元素| F[StageManagerCore.onPointerUp]<br><br>    C --&gt; G[Zustand Store.addElement]<br>    D --&gt; H[Zustand Store.updateElement]<br>    E --&gt; I[Zustand Store.updateElement]<br>    F --&gt; J[Zustand Store.setSelected]<br><br>    G --&gt; K[Zustand 状态更新]<br>    H --&gt; K<br>    I --&gt; K<br>    J --&gt; K<br><br>    K --&gt; L{状态变化}<br>    L --&gt;|元素变化| M[ElementRenderer.renderElements]<br>    L --&gt;|选择变化| N[TransformerRenderer.renderTransformer]<br><br>    M --&gt; O[PixiJS 图形渲染]<br>    N --&gt; O<br><br>    O --&gt; P[用户看到更新结果]<br><br>    K --&gt; Q[Zustand 持久化]<br>    Q --&gt; R[本地存储/IndexedDB]<br><br>    K --&gt; S[撤销/重做管理]<br>    S --&gt; T[命令栈管理]<br><br>    style A fill:#e1f5fe<br>    style O fill:#e8f5e8<br>    style K fill:#fff3e0<br>    style Q fill:#fce4ec<br></code></pre></td></tr></table></figure><p>流程如下：</p><h4 id="用户交互输入"><a href="#用户交互输入" class="headerlink" title="用户交互输入"></a>用户交互输入</h4><p>所有用户交互事件由 StageManagerCore 处理<br>用户通过鼠标、键盘等方式与画布进行交互：</p><ul><li>创建新元素（点击工具栏选择图形类型后在画布上绘制）</li><li>拖拽元素（选中元素后拖动）</li><li>调整元素大小（拖拽元素控制点）</li><li>选择元素（点击或框选元素）</li></ul><h4 id="创建元素流程"><a href="#创建元素流程" class="headerlink" title="创建元素流程"></a>创建元素流程</h4><ol><li>用户在画布上按下鼠标开始绘制</li><li><a href="">onPointerDown</a>捕获事件，创建新元素</li><li>调用 Zustand store 的<a href="">addElement</a>方法添加元素</li></ol><blockquote><p>创建元素时的中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="拖拽元素流程"><a href="#拖拽元素流程" class="headerlink" title="拖拽元素流程"></a>拖拽元素流程</h4><ol><li>用户按下并拖动已选中的元素</li><li><a href="">onPointerMove</a>持续捕获鼠标移动事件</li><li>实时调用 Zustand store 的<a href="">updateElement</a>更新元素位置</li></ol><blockquote><p>拖拽元素时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="调整大小流程"><a href="#调整大小流程" class="headerlink" title="调整大小流程"></a>调整大小流程</h4><ol><li>用户拖拽元素的控制点（resize handle）</li><li><a href="">onHandleDown</a>捕获控制点拖拽事件</li><li><a href="">onPointerMove</a>计算缩放比例并更新元素大小</li><li>调用 Zustand store 的<a href="">updateElement</a>更新元素属性</li></ol><blockquote><p>调整元素大小时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="交互结束处理"><a href="#交互结束处理" class="headerlink" title="交互结束处理"></a>交互结束处理</h4><ol><li>用户释放鼠标按键，<a href="">onPointerUp</a>处理交互结束,解锁撤销/重做管理器</li><li>创建相应的命令（<a href="">UpdateElementCommand</a>并添加到命令栈中</li><li>清理临时状态</li></ol><h4 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h4><p>Zustand 作为全局状态管理器，处理所有状态更新：</p><ol><li><strong>状态更新</strong>：自定义一套<a href="">originalSet</a>方法更新状态</li><li><strong>撤销/重做处理</strong>：创建状态快照并生成命令对象</li><li><strong>状态订阅</strong>：通知所有订阅者状态变化</li></ol><h4 id="渲染更新"><a href="#渲染更新" class="headerlink" title="渲染更新"></a>渲染更新</h4><p>Zustand 状态变化触发 StageManagerCore 的订阅回调：</p><ol><li><a href="">ElementRenderer.renderElements</a> 根据元素数据更新 PixiJS 图形对象</li><li><a href="">TransformerRenderer.renderTransformer</a> 更新选中元素的变换控制器</li><li>PixiJS 自动进行渲染</li></ol><h4 id="撤销-重做管理"><a href="#撤销-重做管理" class="headerlink" title="撤销/重做管理"></a>撤销/重做管理</h4><p>通过命令模式实现撤销/重做功能：</p><ol><li>每个操作生成对应的命令对象（<a href="">UpdateElementCommand</a>、<a href="">SnapshotCommand</a>等）</li><li>命令对象保存操作前后的状态快照</li><li>通过<a href="">UndoRedoManager</a>管理命令栈，实现撤销和重做功能</li></ol><h4 id="数据持久化阶段"><a href="#数据持久化阶段" class="headerlink" title="数据持久化阶段"></a>数据持久化阶段</h4><p>Zustand 状态变化同时触发数据持久化：</p><ol><li>状态通过<a href="">persist</a>中间件自动保存到本地存储</li><li>数据存储在 IndexedDB 中，来支持离线使用</li></ol><blockquote><p>这一块还在写</p></blockquote><hr><h3 id="设计的相关考虑"><a href="#设计的相关考虑" class="headerlink" title="设计的相关考虑"></a>设计的相关考虑</h3><p><strong>解耦</strong>：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展</p><p><strong>便于后续的协同编辑</strong>：实现多人协同，要监听 WebSocket 消息，然后更新 Zustand Store。StageManager 可以去监听到 Store 的变化，并作出相应的渲染更新</p><p><strong>对撤销/重做的实现</strong>：因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照</p><p><strong>序列化/反序列化</strong>：保存项目只需 JSON.stringify(store.elements)</p><h4 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h4><p>【待补充】</p><h2 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h2><p>部署地址：<a href="https://zhongye1.github.io/BDdraw_DEV/">https://zhongye1.github.io/BDdraw_DEV/</a></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h4 id="【P0】基础渲染"><a href="#【P0】基础渲染" class="headerlink" title="【P0】基础渲染"></a><del>【P0】基础渲染</del></h4><ul><li><del>支持图形渲染，需要支持至少 3 种不同图形，比如矩形、圆角矩形、圆形、三角形等。需要支持以下图形属性：</del><ul><li><del>背景色（background）</del></li><li><del>边框宽度（border-width）</del></li><li><del>边框颜色（border-color）</del></li></ul></li><li><del>支持图片渲染，需要支持 png、jpeg 格式，支持设置三种简单滤镜</del></li><li><del>支持富文本文字渲染，需要支持以下文本属性：</del><ul><li><del>字体（font-family）</del></li><li><del>字号（font-size）</del></li><li><del>颜色（color）</del></li><li><del>背景色（background）</del></li><li><del>BIUS（加粗、斜体、下划线、删除线）</del></li></ul></li></ul><h4 id="【P0】画布交互"><a href="#【P0】画布交互" class="headerlink" title="【P0】画布交互"></a><del>【P0】画布交互</del></h4><ul><li><del>支持无限画布的缩放、滚动、拖拽</del><ul><li><del>支持无限画布滚动条</del></li><li><del>支持无限画布的 minimap 功能</del></li></ul></li><li><del>支持选区功能：</del><ul><li><del>点击选中单个元素</del></li><li><del>框选选中多个元素</del></li></ul></li><li><del>支持数据持久化，每次操作后自动保存数据，刷新页面数据仍然存在</del></li><li><del>快捷键复制选中元素</del></li><li><del>支持辅助线功能</del></li></ul><h4 id="【P0】调参工具栏"><a href="#【P0】调参工具栏" class="headerlink" title="【P0】调参工具栏"></a><del>【P0】调参工具栏</del></h4><ul><li><del>浮动工具栏</del><ul><li><del>当选中文本元素时出现在上方，支持设置不同文本属性</del>（做了个编辑器）</li><li><del>当选中图形元素时出现在上方，支持设置不同图形属性</del></li><li><del>选中文本元素的部分文字时也能够出现，支持设置局部文本的文本属性</del>（编辑器内编辑可实现）</li></ul></li></ul><h4 id="【P0】元素编辑"><a href="#【P0】元素编辑" class="headerlink" title="【P0】元素编辑"></a><del>【P0】元素编辑</del></h4><ul><li><del>支持双击文本进入编辑，可以输入/删除文本内容</del></li><li><del>支持对选中元素（单个或多个）删除</del></li><li><del>支持对选中元素（单个或多个）拖拽</del></li><li><del>支持对选中元素（单个或多个）缩放</del></li><li><del>支持对选中元素（单个或多个）旋转</del></li><li><del>支持对多个元素进行组合操作，组合可以嵌套</del></li><li><del>支持对多个元素进行打组、解组</del><del>(组操作 bug 复现了，目前在修)</del>（已修复）</li></ul><h4 id="【P0】性能优化"><a href="#【P0】性能优化" class="headerlink" title="【P0】性能优化"></a><del>【P0】性能优化</del></h4><ul><li><del>画布存在 100 个元素，打开页面到渲染完成 &lt; 3s</del></li><li><del>同时操作 100 个元素，FPS 50+</del></li></ul><h4 id="【P1】协同"><a href="#【P1】协同" class="headerlink" title="【P1】协同"></a><del>【P1】协同</del></h4><ul><li><del>支持 undo &amp; redo 操作</del> <del>（大体实现了，可能要修一下 undo，redo 栈，有个不能稳定复现的 bug）</del>（已实现）</li><li><del>支持协同编辑，多人打开同一个画布可以协同编辑</del> (写了个 Node.js 后端)</li><li><del>支持离线编辑，断网后仍然可以对画布编辑，恢复网络后自动提交数据</del>（IndexedDB）</li></ul><blockquote><p>各模块的技术文档补充中<br>此文档最后编辑于 2025.11.27<br>项目开发中，欢迎提 issue 和 pr</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BDdraw-DEV&quot;&gt;&lt;a href=&quot;#BDdraw-DEV&quot; class=&quot;headerlink&quot; title=&quot;BDdraw_DEV&quot;&gt;&lt;/a&gt;BDdraw_DEV&lt;/h1&gt;&lt;p&gt;代码仓库：&lt;br&gt;&lt;a href=&quot;https://github.com/Z</summary>
      
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="excalidraw" scheme="https://zhongye1.github.io/Arknight-notes/tags/excalidraw/"/>
    
    <category term="github" scheme="https://zhongye1.github.io/Arknight-notes/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-Undo/Redo机制具体实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/52695.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/52695.html</id>
    <published>2025-11-23T11:15:00.000Z</published>
    <updated>2025-11-23T16:03:47.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>Undo/Redo 机制是画布应用中实现操作撤销和重做的核心功能模块。它基于命令模式（Command Pattern）实现来，管理操作历史、执行撤销/重做操作和防止操作冲突，通过维护撤销栈和重做栈来管理用户的操作历史。</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>├── lib/<br>│   ├── UndoRedoManager.ts        <span class="hljs-comment"># 撤销重做管理器核心实现</span><br>│   └── UpdateElementCommand.ts   <span class="hljs-comment"># 元素更新命令实现</span><br>└── stores/<br>    └── canvasStore.ts            <span class="hljs-comment"># 状态存储，命令操作的目标</span><br></code></pre></td></tr></table></figure><ul><li><code>Command Pattern</code>：设计模式，用于封装操作命令</li><li><code>Zustand</code>：状态管理库，作为命令操作的目标</li><li><code>TypeScript</code>：提供类型安全和代码可维护性</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-UndoRedoManager-核心方法"><a href="#2-1-UndoRedoManager-核心方法" class="headerlink" title="2.1 UndoRedoManager 核心方法"></a>2.1 UndoRedoManager 核心方法</h4><p>撤销重做管理器提供了一系列核心方法用于管理操作命令。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>参数</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>executeCommand</td><td>command: Command</td><td>void</td><td>执行并记录命令</td></tr><tr><td>undo</td><td>无</td><td>void</td><td>执行撤销操作</td></tr><tr><td>redo</td><td>无</td><td>void</td><td>执行重做操作</td></tr><tr><td>lock</td><td>无</td><td>void</td><td>锁定管理器，防止记录新命令</td></tr><tr><td>unlock</td><td>无</td><td>void</td><td>解锁管理器</td></tr><tr><td>isLocked</td><td>无</td><td>boolean</td><td>检查管理器是否被锁定</td></tr><tr><td>canUndo</td><td>无</td><td>boolean</td><td>检查是否可以撤销</td></tr><tr><td>canRedo</td><td>无</td><td>boolean</td><td>检查是否可以重做</td></tr></tbody></table></div><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口</strong>：<br>定义了命令对象必须实现的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><p><strong>UpdateOperation 接口</strong>：<br>定义了元素更新操作的数据结构。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 元素ID</span><br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><blockquote><p>⚠️ 为防止在执行撤销/重做操作时记录新的命令，系统实现了锁定机制。在执行命令时会先锁定管理器，执行完成后再解锁，确保操作的原子性。</p></blockquote><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>UndoRedoManager 维护以下内部状态用于管理操作历史：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>undoStack</td><td>Command[]</td><td>撤销命令栈，存储可以撤销的命令</td></tr><tr><td>redoStack</td><td>Command[]</td><td>重做命令栈，存储可以重做的命令</td></tr><tr><td>locked</td><td>boolean</td><td>锁定状态，防止在执行命令时记录新命令</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>Undo/Redo 机制通过 Zustand 状态管理库操作外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据，命令操作的目标</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户操作] --&gt; B{StageManager}<br>    B --&gt; C[创建命令对象]<br>    C --&gt; D[UndoRedoManager.executeCommand]<br>    D --&gt; E{管理器锁定?}<br>    E --&gt;|是| F[忽略命令]<br>    E --&gt;|否| G[执行命令]<br>    G --&gt; H[命令入撤销栈]<br>    H --&gt; I[清空重做栈]<br>    I --&gt; J[Zustand 状态更新]<br>    <br>    subgraph 撤销操作<br>      K[UndoRedoManager.undo]<br>      K --&gt; L{撤销栈空?}<br>      L --&gt;|是| M[无法撤销]<br>      L --&gt;|否| N[弹出命令]<br>      N --&gt; O[执行命令.undo]<br>      O --&gt; P[命令入重做栈]<br>      P --&gt; Q[Zustand 状态更新]<br>    end<br>    <br>    subgraph 重做操作<br>      R[UndoRedoManager.redo]<br>      R --&gt; S{重做栈空?}<br>      S --&gt;|是| T[无法重做]<br>      S --&gt;|否| U[弹出命令]<br>      U --&gt; V[执行命令.redo]<br>      V --&gt; W[命令入撤销栈]<br>      W --&gt; X[Zustand 状态更新]<br>    end<br>    <br>    style A fill:#e1f5fe<br>    style J fill:#e8f5e8<br>    style Q fill:#e8f5e8<br>    style X fill:#e8f5e8<br>    style F fill:#ffebee<br></code></pre></td></tr></table></figure><h3 id="4-命令管理机制"><a href="#4-命令管理机制" class="headerlink" title="4. 命令管理机制"></a>4. 命令管理机制</h3><p>Undo/Redo 机制采用命令模式（Command Pattern）来管理操作命令，通过定义统一的接口和不同的实现类来处理各种操作。</p><h4 id="4-1-命令类型"><a href="#4-1-命令类型" class="headerlink" title="4.1 命令类型"></a>4.1 命令类型</h4><p>系统中主要有两种命令类型：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：用于记录整个画布状态的变化，通常用于添加元素、删除元素等较大范围的操作，保存完整的状态快照</p></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：用于记录特定元素的属性变化，主要用于拖拽移动和调整大小操作，只保存相关元素的特定属性变化</p></li></ol><h4 id="4-2-命令接口定义"><a href="#4-2-命令接口定义" class="headerlink" title="4.2 命令接口定义"></a>4.2 命令接口定义</h4><p>所有命令都实现统一的 <a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><h4 id="4-3-快照命令（SnapshotCommand）"><a href="#4-3-快照命令（SnapshotCommand）" class="headerlink" title="4.3 快照命令（SnapshotCommand）"></a>4.3 快照命令（SnapshotCommand）</h4><p>快照命令用于记录整个画布状态的变化，适用于影响范围较大的操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">any</span></span>) {<br>    <span class="hljs-comment">// 使用 structuredClone 进行深拷贝，确保状态隔离</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span> = <span class="hljs-title function_">structuredClone</span>(prevState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span> = <span class="hljs-title function_">structuredClone</span>(nextState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>    <span class="hljs-comment">// 生成唯一的命令ID用于调试</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() % <span class="hljs-number">1000000</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// execute在添加到命令栈之前已经执行了</span><br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之前的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span>);<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之后的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-4-更新元素命令（UpdateElementCommand）"><a href="#4-4-更新元素命令（UpdateElementCommand）" class="headerlink" title="4.4 更新元素命令（UpdateElementCommand）"></a>4.4 更新元素命令（UpdateElementCommand）</h4><p>更新元素命令用于记录特定元素的属性变化，适用于影响范围较小的精细操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operations</span>: <span class="hljs-title class_">UpdateOperation</span>[],</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operationType</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"更新元素"</span></span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-comment">// 生成唯一命令ID</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-string">`UpdateElementCommand-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random()</span></span><br><span class="hljs-subst"><span class="hljs-string">      .toString(<span class="hljs-number">36</span>)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .slice(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)}</span>`</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 应用最终状态</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 撤销：恢复到 initialAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">initialAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 重做：恢复到 finalAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-5-命令生命周期"><a href="#4-5-命令生命周期" class="headerlink" title="4.5 命令生命周期"></a>4.5 命令生命周期</h4><p>命令的生命周期包括创建、执行、撤销和重做四个阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[命令创建] --&gt; B[命令执行]<br>    B --&gt; C{用户操作}<br>    C --&gt;|撤销| D[执行undo方法]<br>    C --&gt;|重做| E[执行redo方法]<br>    D --&gt; F[命令状态切换]<br>    E --&gt; F<br>    F --&gt; G[状态更新完成]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style D fill:#fff3e0<br>    style E fill:#fff3e0<br>    style G fill:#e8f5e8<br></code></pre></td></tr></table></figure><h3 id="5-命令栈管理机制"><a href="#5-命令栈管理机制" class="headerlink" title="5. 命令栈管理机制"></a>5. 命令栈管理机制</h3><p>撤销/重做机制使用两个栈来管理命令历史：</p><ol><li><strong>撤销栈（Undo Stack）</strong>：</li></ol><p>存储用户可以撤销的操作命令，栈顶是最近执行的命令，执行新命令时，命令被推入此栈，执行撤销操作时，命令从此栈弹出并推入重做栈</p><ol><li><strong>重做栈（Redo Stack）</strong>：</li></ol><p>存储用户可以重做的操作命令，在执行撤销操作时，被撤销的命令被推入此栈，执行重做操作时，命令从此栈弹出并推入撤销栈，执行新命令时，此栈被清空</p><h4 id="5-1-命令栈操作流程"><a href="#5-1-命令栈操作流程" class="headerlink" title="5.1 命令栈操作流程"></a>5.1 命令栈操作流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[执行新命令] --&gt; B[命令入撤销栈]<br>    B --&gt; C[清空重做栈]<br>    <br>    D[执行撤销] --&gt; E{撤销栈空?}<br>    E --&gt;|是| F[无操作]<br>    E --&gt;|否| G[弹出命令]<br>    G --&gt; H[执行命令.undo]<br>    H --&gt; I[命令入重做栈]<br>    <br>    J[执行重做] --&gt; K{重做栈空?}<br>    K --&gt;|是| L[无操作]<br>    K --&gt;|否| M[弹出命令]<br>    M --&gt; N[执行命令.redo]<br>    N --&gt; O[命令入撤销栈]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#f3e5f5<br>    style D fill:#e1f5fe<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style J fill:#e1f5fe<br>    style N fill:#e8f5e8<br>    style O fill:#e8f5e8<br></code></pre></td></tr></table></figure><h4 id="5-2-不同类型的命令"><a href="#5-2-不同类型的命令" class="headerlink" title="5.2 不同类型的命令"></a>5.2 不同类型的命令</h4><p>撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：</p><ul><li>用于记录整个画布状态的变化</li><li>通常用于添加元素、删除元素等较大范围的操作</li><li>保存完整的状态快照</li></ul></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：</p><ul><li>用于记录特定元素的属性变化</li><li>主要用于拖拽移动和调整大小操作</li><li>只保存相关元素的特定属性变化</li></ul></li></ol><h4 id="5-3-操作序列和撤销栈状态变化示例"><a href="#5-3-操作序列和撤销栈状态变化示例" class="headerlink" title="5.3 操作序列和撤销栈状态变化示例"></a>5.3 操作序列和撤销栈状态变化示例</h4><h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><p>撤销栈：空<br>重做栈：空</p><h5 id="1-创建元素-A"><a href="#1-创建元素-A" class="headerlink" title="1. 创建元素 A"></a>1. 创建元素 A</h5><p>当创建元素 A 时，系统会生成一个快照命令，记录整个画布状态的变化。<br>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：空</p><h5 id="2-移动-A-到一个位置"><a href="#2-移动-A-到一个位置" class="headerlink" title="2. 移动 A 到一个位置"></a>2. 移动 A 到一个位置</h5><p>当移动元素 A 时，系统会生成一个更新元素命令（UpdateElementCommand），只记录 A 元素位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：空</p><h5 id="3-创建元素-B"><a href="#3-创建元素-B" class="headerlink" title="3. 创建元素 B"></a>3. 创建元素 B</h5><p>当创建元素 B 时，系统会生成另一个快照命令，记录添加 B 元素后的状态。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：空</p><h5 id="4-缩放-B-到一个位置"><a href="#4-缩放-B-到一个位置" class="headerlink" title="4. 缩放 B 到一个位置"></a>4. 缩放 B 到一个位置</h5><p>当缩放元素 B 时，系统会生成一个更新元素命令，记录 B 元素尺寸和位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：空</p><h5 id="5-移动-B-到一个位置"><a href="#5-移动-B-到一个位置" class="headerlink" title="5. 移动 B 到一个位置"></a>5. 移动 B 到一个位置</h5><p>当再次移动元素 B 时，系统会生成另一个更新元素命令，记录 B 元素位置的新变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5)<br>重做栈：空</p><h4 id="5-4-执行撤销操作时的状态变化"><a href="#5-4-执行撤销操作时的状态变化" class="headerlink" title="5.4 执行撤销操作时的状态变化"></a>5.4 执行撤销操作时的状态变化</h4><h5 id="第一次撤销（移动-B-操作）"><a href="#第一次撤销（移动-B-操作）" class="headerlink" title="第一次撤销（移动 B 操作）"></a>第一次撤销（移动 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB</li><li>执行该命令的 undo()方法，将 B 元素恢复到缩放后的位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：[UpdateElementCommand_MoveB] (大小: 1)</p><h5 id="第二次撤销（缩放-B-操作）"><a href="#第二次撤销（缩放-B-操作）" class="headerlink" title="第二次撤销（缩放 B 操作）"></a>第二次撤销（缩放 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB</li><li>执行该命令的 undo()方法，将 B 元素恢复到刚创建时的尺寸和位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)</p><h5 id="第三次撤销（创建-B-操作）"><a href="#第三次撤销（创建-B-操作）" class="headerlink" title="第三次撤销（创建 B 操作）"></a>第三次撤销（创建 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_B</li><li>执行该命令的 undo()方法，将整个画布状态恢复到创建 B 之前的状态（即只包含 A 元素的状态）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)</p><h5 id="第四次撤销（移动-A-操作）"><a href="#第四次撤销（移动-A-操作）" class="headerlink" title="第四次撤销（移动 A 操作）"></a>第四次撤销（移动 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA</li><li>执行该命令的 undo()方法，将 A 元素恢复到初始位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)</p><h5 id="第五次撤销（创建-A-操作）"><a href="#第五次撤销（创建-A-操作）" class="headerlink" title="第五次撤销（创建 A 操作）"></a>第五次撤销（创建 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_A</li><li>执行该命令的 undo()方法，将整个画布状态恢复到初始状态（空画布）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：空<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)</p><h3 id="6-逻辑流程-Logic-Flow"><a href="#6-逻辑流程-Logic-Flow" class="headerlink" title="6. 逻辑流程 (Logic Flow)"></a>6. 逻辑流程 (Logic Flow)</h3><h4 id="6-1-交互时序图-Mermaid"><a href="#6-1-交互时序图-Mermaid" class="headerlink" title="6.1 交互时序图 (Mermaid)"></a>6.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManager<br>    participant URM as UndoRedoManager<br>    participant C as Command<br>    participant ZS as Zustand Store<br>    <br>    U-&gt;&gt;SM: 执行操作（如拖拽元素）<br>    SM-&gt;&gt;SM: 记录操作初始状态<br>    SM-&gt;&gt;ZS: 更新元素状态<br>    SM-&gt;&gt;C: 创建 UpdateElementCommand<br>    SM-&gt;&gt;URM: executeCommand(command)<br>    URM-&gt;&gt;C: command.execute()<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 清空重做栈<br>    <br>    U-&gt;&gt;URM: 执行撤销 (Ctrl+Z)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.undo()<br>    C-&gt;&gt;ZS: 恢复初始状态<br>    C-&gt;&gt;URM: 命令入重做栈<br>    URM-&gt;&gt;URM: 解锁管理器<br>    <br>    U-&gt;&gt;URM: 执行重做 (Ctrl+Y)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.redo()<br>    C-&gt;&gt;ZS: 恢复最终状态<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 解锁管理器<br></code></pre></td></tr></table></figure><h4 id="6-2-核心函数解析"><a href="#6-2-核心函数解析" class="headerlink" title="6.2 核心函数解析"></a>6.2 核心函数解析</h4><p><strong>executeCommand 函数</strong>：当用户完成一个操作（如创建、更新、删除元素）时触发，执行命令并将命令添加到撤销栈，同时清空重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">executeCommand</span>(<span class="hljs-params"><span class="hljs-attr">command</span>: <span class="hljs-title class_">Command</span></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">locked</span>) {<br>    <span class="hljs-comment">// 如果管理器被锁定，忽略命令</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-comment">// 执行命令</span><br>  command.<span class="hljs-title function_">execute</span>()<br><br>  <span class="hljs-comment">// 将命令添加到撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)<br><br>  <span class="hljs-comment">// 清空重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span> = []<br>}<br></code></pre></td></tr></table></figure><p><strong>undo 函数</strong>：当用户执行撤销操作（如按 Ctrl+Z）时触发，从撤销栈弹出命令，执行命令的 undo 方法，并将命令放入重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">undo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 撤销栈为空，无法撤销</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">undo</span>()  <span class="hljs-comment">// 执行撤销</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><p><strong>redo 函数</strong>：当用户执行重做操作（如按 Ctrl+Y）时触发，从重做栈弹出命令，执行命令的 redo 方法，并将命令放入撤销栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">redo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 重做栈为空，无法重做</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">redo</span>()  <span class="hljs-comment">// 执行重做</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><h3 id="7-UI-与样式实现-UI-Implementation"><a href="#7-UI-与样式实现-UI-Implementation" class="headerlink" title="7. UI 与样式实现 (UI Implementation)"></a>7. UI 与样式实现 (UI Implementation)</h3><p>Undo/Redo 机制通过快捷键和控制台界面与用户交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互方式}<br>    B --&gt; C[键盘快捷键]<br>    B --&gt; D[控制台界面]<br>    C --&gt; E[Ctrl+Z 撤销]<br>    C --&gt; F[Ctrl+Y 重做]<br>    D --&gt; G[命令栈控制台]<br>    G --&gt; H[撤销按钮]<br>    G --&gt; I[重做按钮]<br>    G --&gt; J[清空按钮]<br>    <br>    style A fill:#e1f5fe<br>    style C fill:#f3e5f5<br>    style D fill:#f3e5f5<br>    style E fill:#e8f5e8<br>    style F fill:#e8f5e8<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="状态管理" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-逻辑层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/62457.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/62457.html</id>
    <published>2025-11-23T09:45:00.000Z</published>
    <updated>2025-11-23T16:04:12.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>逻辑层是整个画布应用的中枢神经系统，负责协调状态管理层和渲染层之间的交互。它通过 StageManagerCore 类实现，主要处理用户交互、协调状态更新、管理渲染流程、维护交互状态</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── pages/<br>    └── canvas/<br>        ├── Pixi_stageManager.ts               <span class="hljs-comment"># StageManager 入口文件</span><br>        └── Pixi_STM_modules/                  <span class="hljs-comment"># StageManager 模块目录</span><br>            ├── core/<br>            │   ├── StageManagerCore.ts        <span class="hljs-comment"># 核心类</span><br>            │   └── types.ts                   <span class="hljs-comment"># 类型定义文件</span><br>            ├── rendering/<br>            │   ├── ElementRenderer.ts         <span class="hljs-comment"># 元素渲染器</span><br>            │   └── TransformerRenderer.ts     <span class="hljs-comment"># 变换控制器渲染器</span><br>            ├── interaction/<br>            │   └── InteractionHandler.ts      <span class="hljs-comment"># 交互处理器</span><br>            └── utils/<br>                └── cursorUtils.ts             <span class="hljs-comment"># 光标工具函数</span><br></code></pre></td></tr></table></figure><ul><li><code>PixiJS</code>：WebGL 渲染引擎，负责图形渲染</li><li><code>pixi-viewport</code>：视口管理插件，处理画布缩放和平移</li><li><code>Zustand</code>：状态管理库，与状态管理层对接</li><li><code>nanoid</code>：用于生成唯一 ID</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-StageManagerCore-构造函数参数"><a href="#2-1-StageManagerCore-构造函数参数" class="headerlink" title="2.1 StageManagerCore 构造函数参数"></a>2.1 StageManagerCore 构造函数参数</h4><p>StageManagerCore 类通过构造函数接收容器元素参数。</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>container</td><td>HTMLElement</td><td>是</td><td>无</td><td>用于挂载 PixiJS 应用的 DOM 容器</td></tr></tbody></table></div><p>代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 创建 StageManager 实例</span><br><span class="hljs-keyword">const</span> stageManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StageManagerCore</span>(containerElement);<br></code></pre></td></tr></table></figure><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L11-L38">StageManagerState</a> 类型</strong>：<br>定义了 StageManager 的核心状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StageManagerState</span> {<br>  <span class="hljs-attr">mode</span>: <span class="hljs-title class_">InteractionMode</span>; <span class="hljs-comment">// 当前交互模式</span><br>  <span class="hljs-attr">startPos</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> }; <span class="hljs-comment">// 起始坐标</span><br>  <span class="hljs-attr">currentId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前操作元素 ID</span><br>  <span class="hljs-attr">initialElementsMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始元素映射</span><br>  <span class="hljs-attr">initialGroupBounds</span>: {<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  } | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始群组边界</span><br>  <span class="hljs-attr">initialElementState</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始元素状态</span><br>  <span class="hljs-attr">resizeInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 调整大小初始状态</span><br>  <span class="hljs-attr">dragInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 拖拽初始状态</span><br>  <span class="hljs-attr">activeHandle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 激活的手柄</span><br>  <span class="hljs-attr">isSpacePressed</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 空格键是否按下</span><br>  <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 是否已销毁</span><br>}<br></code></pre></td></tr></table></figure><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L3-L8">InteractionMode</a> 类型</strong>：<br>定义了用户与画布交互的各种模式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">InteractionMode</span> =<br>  | <span class="hljs-string">"idle"</span> <span class="hljs-comment">// 空闲状态</span><br>  | <span class="hljs-string">"panning"</span> <span class="hljs-comment">// 画布平移</span><br>  | <span class="hljs-string">"selecting"</span> <span class="hljs-comment">// 选择元素</span><br>  | <span class="hljs-string">"dragging"</span> <span class="hljs-comment">// 拖拽元素</span><br>  | <span class="hljs-string">"resizing"</span> <span class="hljs-comment">// 调整元素大小</span><br>  | <span class="hljs-string">"drawing"</span> <span class="hljs-comment">// 绘制元素</span><br>  | <span class="hljs-string">"texting"</span> <span class="hljs-comment">// 文本编辑</span><br>  | <span class="hljs-string">"erasing"</span>; <span class="hljs-comment">// 擦除元素</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>StageManagerCore 维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>app</td><td>PIXI.Application</td><td>PixiJS 应用实例</td></tr><tr><td>viewport</td><td>Viewport</td><td>pixi-viewport 实例</td></tr><tr><td>elementLayer</td><td>PIXI.Container</td><td>元素图层容器</td></tr><tr><td>uiLayer</td><td>PIXI.Container</td><td>UI 图层容器</td></tr><tr><td>elementRenderer</td><td>ElementRenderer</td><td>元素渲染器实例</td></tr><tr><td>transformerRenderer</td><td>TransformerRenderer</td><td>变换控制器渲染器实例</td></tr><tr><td>interactionHandler</td><td>InteractionHandler</td><td>交互处理器实例</td></tr><tr><td>state</td><td>StageManagerState</td><td>交互状态对象</td></tr><tr><td>selectionRectGraphic</td><td>PIXI.Graphics</td><td>选区框图形对象</td></tr><tr><td>eraserGraphic</td><td>PIXI.Graphics</td><td>橡皮擦指示器图形对象</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>逻辑层通过 Zustand 状态管理库订阅外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据</td></tr><tr><td>selectedIds</td><td>string[]</td><td>当前选中的元素 ID 数组</td></tr><tr><td>tool</td><td>ToolType</td><td>当前工具类型</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store 状态变更] --&gt; B{StageManager 订阅}<br>    B --&gt; C{状态处理}<br>    C --&gt; D[ElementRenderer.renderElements]<br>    C --&gt; E[TransformerRenderer.renderTransformer]<br>    C --&gt; F[更新视口状态]<br>    C --&gt; G[更新光标样式]<br>    D --&gt; H[PixiJS 渲染元素]<br>    E --&gt; I[PixiJS 渲染变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style H fill:#e8f5e8<br>    style I fill:#e8f5e8<br>    style F fill:#fff3e0<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManagerCore<br>    participant IH as InteractionHandler<br>    participant ZS as Zustand Store<br>    participant ER as ElementRenderer<br>    participant TR as TransformerRenderer<br>    <br>    U-&gt;&gt;IH: 触发交互事件 (点击/拖拽等)<br>    IH-&gt;&gt;SM: 调用处理函数 (onPointerDown等)<br>    SM-&gt;&gt;SM: 更新内部状态 (mode, startPos等)<br>    SM-&gt;&gt;ZS: 更新画布数据 (addElement等)<br>    ZS-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;ER: 调用renderElements()<br>    SM-&gt;&gt;TR: 调用renderTransformer()<br>    ER-&gt;&gt;ER: 更新 PIXI 元素<br>    TR-&gt;&gt;TR: 更新变换控制器<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><p><strong>onPointerDown 函数</strong>：当用户在画布上按下鼠标时触发，根据当前工具和点击位置处理不同的交互逻辑（选择、绘制、拖拽等）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理防抖</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerDebounceSnapshot</span>()<br><br>  <span class="hljs-comment">// 获取当前状态</span><br>  <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>()<br>  <span class="hljs-keyword">const</span> tool = state.<span class="hljs-property">tool</span><br>  <span class="hljs-keyword">const</span> worldPos = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>)<br><br>  <span class="hljs-comment">// 根据工具类型处理不同逻辑</span><br>  <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'text'</span>) {<br>    <span class="hljs-comment">// 处理文本工具</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'eraser'</span>) {<br>    <span class="hljs-comment">// 处理橡皮擦工具</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> &amp;&amp; e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>) {<br>    <span class="hljs-comment">// 处理元素点击</span><br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 处理绘制或选择</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p><strong>onPointerMove 函数</strong>：当用户在画布上移动鼠标时触发，根据当前交互模式处理不同的移动逻辑（绘制、拖拽、调整大小等）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerMove = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理防抖</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerDebounceSnapshot</span>()<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> === <span class="hljs-string">'idle'</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>()<br>  <span class="hljs-keyword">const</span> currentPos = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>)<br><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span>) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'selecting'</span>:<br>      <span class="hljs-comment">// 处理选择框绘制</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'erasing'</span>:<br>      <span class="hljs-comment">// 处理橡皮擦操作</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'dragging'</span>:<br>      <span class="hljs-comment">// 处理元素拖拽</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'resizing'</span>:<br>      <span class="hljs-comment">// 处理元素调整大小</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'drawing'</span>:<br>      <span class="hljs-comment">// 处理元素绘制</span><br>      <span class="hljs-keyword">break</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="5-UI-与样式实现-UI-Implementation"><a href="#5-UI-与样式实现-UI-Implementation" class="headerlink" title="5. UI 与样式实现 (UI Implementation)"></a>5. UI 与样式实现 (UI Implementation)</h3><p>逻辑层通过管理不同图层来实现 UI 布局：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Viewport] --&gt; B[elementLayer]<br>    A --&gt; C[uiLayer]<br>    B --&gt; D[图形元素]<br>    C --&gt; E[选区框]<br>    C --&gt; F[橡皮擦指示器]<br>    C --&gt; G[变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#e8f5e8<br>    style D fill:#fce4ec<br>    style E fill:#fff3e0<br>    style F fill:#fff3e0<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure><p>使用 PixiJS 的容器系统管理图层，分为元素层和 UI 层，通过 PIXI.Graphics API 实现图形绘制，通过 CSS 控制光标样式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="PixiJS" scheme="https://zhongye1.github.io/Arknight-notes/tags/PixiJS/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-状态管理层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/61173.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/61173.html</id>
    <published>2025-11-23T09:17:00.000Z</published>
    <updated>2025-11-23T16:04:20.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>状态管理层管理画布元素数据、选中状态、工具状态、剪贴板数据等核心业务数据，是整个画布应用的数据核心，负责维护所有画布元素的状态信息和用户交互相关的全局状态。它采用了 Zustand 作为状态管理库，实现了数据的集中管理和状态变更的响应式更新</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── stores/<br>    └── canvasStore.ts        <span class="hljs-comment"># Zustand 状态管理核心文件</span><br></code></pre></td></tr></table></figure><ul><li><code>Zustand</code>：轻量级状态管理库，用于管理全局状态</li><li><code>nanoid</code>：用于生成唯一 ID</li><li><code>structuredClone</code>：用于深拷贝状态数据</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-useStore-参数"><a href="#2-1-useStore-参数" class="headerlink" title="2.1 useStore 参数"></a>2.1 useStore 参数</h4><p>状态管理模块通过 <a href="/src/stores/canvasStore.ts#L35-L136">useStore</a> Hook 提供状态访问和更新功能。</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>setTool</td><td>Function</td><td>是</td><td>无</td><td>设置当前使用的工具类型</td></tr><tr><td>addElement</td><td>Function</td><td>是</td><td>无</td><td>添加新元素到画布</td></tr><tr><td>updateElement</td><td>Function</td><td>是</td><td>无</td><td>更新指定元素的属性</td></tr><tr><td>removeElements</td><td>Function</td><td>是</td><td>无</td><td>从画布中移除指定元素</td></tr><tr><td>setSelected</td><td>Function</td><td>是</td><td>无</td><td>设置当前选中的元素</td></tr><tr><td>setEditingId</td><td>Function</td><td>是</td><td>无</td><td>设置当前正在编辑的元素</td></tr><tr><td>copyElements</td><td>Function</td><td>是</td><td>无</td><td>复制指定元素到剪贴板</td></tr><tr><td>pasteElements</td><td>Function</td><td>是</td><td>无</td><td>从剪贴板粘贴元素到画布</td></tr></tbody></table></div><p>代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 设置工具类型</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">setTool</span>(<span class="hljs-string">"rect"</span>);<br><br><span class="hljs-comment">// 添加元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>({<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">"element1"</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"rect"</span>,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">150</span>,<br>  <span class="hljs-attr">fill</span>: <span class="hljs-string">"#ff0000"</span>,<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-string">"#000000"</span>,<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">2</span>,<br>});<br><br><span class="hljs-comment">// 更新元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-string">"element1"</span>, { <span class="hljs-attr">fill</span>: <span class="hljs-string">"#00ff00"</span> });<br><br><span class="hljs-comment">// 移除元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-string">"element1"</span>]);<br></code></pre></td></tr></table></figure><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15">CanvasElement</a> 类型</strong>：<br>定义了画布上所有元素的基本属性和可选属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 元素唯一标识符</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span>; <span class="hljs-comment">// 元素类型</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素左上角 x 坐标</span><br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素左上角 y 坐标</span><br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素宽度</span><br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素高度</span><br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 填充颜色</span><br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 描边颜色</span><br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 描边宽度</span><br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 透明度</span><br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][]; <span class="hljs-comment">// 点坐标数组（用于线条类元素）</span><br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 旋转角度（弧度制）</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本内容（HTML 格式）</span><br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 字体大小</span><br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 字体族</span><br>  <span class="hljs-attr">textAlign</span>?: <span class="hljs-string">"left"</span> | <span class="hljs-string">"center"</span> | <span class="hljs-string">"right"</span>; <span class="hljs-comment">// 文本对齐方式</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图片 URL</span><br>  <span class="hljs-attr">filter</span>?: <span class="hljs-string">"none"</span> | <span class="hljs-string">"blur"</span> | <span class="hljs-string">"brightness"</span> | <span class="hljs-string">"grayscale"</span>; <span class="hljs-comment">// 图片滤镜</span><br>  <span class="hljs-attr">radius</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 圆角半径</span><br>}<br></code></pre></td></tr></table></figure><p><strong><a href="/src/stores/canvasStore.ts#L6-L21">ToolType</a> 类型</strong>：<br>定义了用户可选择的工具类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToolType</span> =<br>  | <span class="hljs-string">"select"</span> <span class="hljs-comment">// 选择工具</span><br>  | <span class="hljs-string">"hand"</span> <span class="hljs-comment">// 手型工具</span><br>  | <span class="hljs-string">"rect"</span> <span class="hljs-comment">// 矩形工具</span><br>  | <span class="hljs-string">"circle"</span> <span class="hljs-comment">// 圆形工具</span><br>  | <span class="hljs-string">"triangle"</span> <span class="hljs-comment">// 三角形工具</span><br>  | <span class="hljs-string">"diamond"</span> <span class="hljs-comment">// 菱形工具</span><br>  | <span class="hljs-string">"line"</span> <span class="hljs-comment">// 直线工具</span><br>  | <span class="hljs-string">"arrow"</span> <span class="hljs-comment">// 箭头工具</span><br>  | <span class="hljs-string">"pencil"</span> <span class="hljs-comment">// 铅笔工具</span><br>  | <span class="hljs-string">"text"</span> <span class="hljs-comment">// 文本工具</span><br>  | <span class="hljs-string">"image"</span> <span class="hljs-comment">// 图片工具</span><br>  | <span class="hljs-string">"eraser"</span>; <span class="hljs-comment">// 橡皮擦工具</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><p>状态管理层维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>tool</td><td><a href="/src/stores/canvasStore.ts#L6-L21">ToolType</a></td><td>当前选中的工具类型</td></tr><tr><td>elements</td><td>Record&lt;string, [CanvasElement](/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15)&gt;</td><td>所有画布元素的集合</td></tr><tr><td>selectedIds</td><td>string[]</td><td>当前选中的元素 ID 数组</td></tr><tr><td>editingId</td><td>string \</td><td>null</td><td>当前正在编辑的元素 ID</td></tr><tr><td>clipboard</td><td><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15">CanvasElement</a>[] \</td><td>null</td><td>剪贴板数据</td></tr><tr><td>pasteOffset</td><td>number</td><td>粘贴偏移计数</td></tr><tr><td>currentStyle</td><td>Object</td><td>当前样式设置</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store 状态变更] --&gt; B{订阅者监听}<br>    B --&gt; C[StageManager 订阅]<br>    B --&gt; D[UI 组件订阅]<br>    C --&gt; E[触发渲染层更新]<br>    D --&gt; F[触发 UI 更新]<br>    <br>    style A fill:#e1f5fe<br>    style E fill:#e8f5e8<br>    style F fill:#fff3e0<br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant C as CanvasStore<br>    participant SM as StageManager<br>    participant R as 渲染层<br>    <br>    U-&gt;&gt;C: 调用 Action (如 addElement)<br>    C-&gt;&gt;C: 更新内部状态<br>    C-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;R: 触发重新渲染<br>    R-&gt;&gt;R: 更新 PIXI 对象<br>    R-&gt;&gt;U: 显示更新结果<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数"><a href="#4-2-核心函数" class="headerlink" title="4.2 核心函数"></a>4.2 核心函数</h4><p><strong>addElement 函数</strong>：当用户创建新元素时调用，创建新元素并添加到 elements 集合中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({<br>    <span class="hljs-attr">elements</span>: { ...state.<span class="hljs-property">elements</span>, [el.<span class="hljs-property">id</span>]: el },<br>  }));<br></code></pre></td></tr></table></figure><p><strong>updateElement 函数</strong>：当用户修改元素属性时调用，更新指定元素的属性并保持其他元素不变</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params">id, attrs</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">elements</span>[id]) <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">return</span> {<br>      <span class="hljs-attr">elements</span>: {<br>        ...state.<span class="hljs-property">elements</span>,<br>        [id]: { ...state.<span class="hljs-property">elements</span>[id], ...attrs },<br>      },<br>    };<br>  });<br></code></pre></td></tr></table></figure><p>状态管理层作为纯数据层，不直接涉及 UI 和样式实现，但为上层 UI 提供了必要的状态支持，通过状态结构支持上层组件的布局逻辑和状态中的样式属性支持上层组件的样式实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Zustand" scheme="https://zhongye1.github.io/Arknight-notes/tags/Zustand/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-渲染层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/8350.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/8350.html</id>
    <published>2025-11-23T06:56:37.000Z</published>
    <updated>2025-11-23T16:06:10.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>渲染层是基于 PixiJS 构建的可视化层，负责将存储在 Zustand 状态管理器中的画布元素数据转化为可视化的图形界面，并处理用户的交互操作。它主要包括元素渲染（ElementRenderer）和变换控制器渲染（TransformerRenderer）两大部分，分别负责绘制元素本身和元素的选中状态、控制手柄等辅助 UI。</p><p>其项目结构树如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nix">src<span class="hljs-symbol">/</span><br>└── pages<span class="hljs-symbol">/</span><br>    └── canvas<span class="hljs-symbol">/</span><br>        ├── Pixi_stageManager.ts               <span class="hljs-comment"># 整合StageManager各模块的入口文件</span><br>        ├── index.tsx                          <span class="hljs-comment"># 画布页面组件，整合渲染层到React组件中</span><br>        └── Pixi_STM_modules<span class="hljs-symbol">/</span>                  <span class="hljs-comment"># StageManager模块目录</span><br>            ├── STM_modules.md                 <span class="hljs-comment"># 模块设计文档</span><br>            ├── core<span class="hljs-symbol">/</span><br>            │   ├── StageManagerCore.ts        <span class="hljs-comment"># 核心类，整合渲染、交互和状态管理</span><br>            │   └── types.ts                   <span class="hljs-comment"># 类型定义文件</span><br>            ├── rendering<span class="hljs-symbol">/</span><br>            │   ├── ElementRenderer.ts         <span class="hljs-comment"># 元素渲染器，负责渲染各类画布元素</span><br>            │   └── TransformerRenderer.ts     <span class="hljs-comment"># 变换控制器渲染器，负责渲染选中元素的手柄等</span><br>            ├── interaction<span class="hljs-symbol">/</span><br>            │   └── InteractionHandler.ts      <span class="hljs-comment"># 交互处理器，绑定和处理各种交互事件</span><br>            └── utils<span class="hljs-symbol">/</span><br>                └── cursorUtils.ts             <span class="hljs-comment"># 光标工具函数</span><br></code></pre></td></tr></table></figure><p>该模块主要负责将状态管理层的数据渲染成可视化图形，并处理用户交互反馈</p><ul><li><code>pixi.js</code>：WebGL 渲染引擎</li><li><code>pixi-viewport</code>：视口管理插件</li><li><code>zustand</code>：状态管理库（虽然不是渲染层直接依赖，但与其紧密协作）</li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><p>渲染层接收来自逻辑层的 props 参数，用于驱动元素渲染和交互控制。这些参数主要包括元素数据、状态信息和事件回调函数。</p><h4 id="2-1-ElementRenderer-renderElements-方法参数"><a href="#2-1-ElementRenderer-renderElements-方法参数" class="headerlink" title="2.1 ElementRenderer.renderElements 方法参数"></a>2.1 ElementRenderer.renderElements 方法参数</h4><p>ElementRenderer 负责将画布元素数据渲染为 PIXI 可视化对象，其 <a href="src/pages/canvas/Pixi_STM_modules/rendering/ElementRenderer.ts#L57-L157">renderElements</a> 方法接收以下参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">类型</th><th style="text-align:left">必填</th><th style="text-align:left">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">elements</td><td style="text-align:left">Record<string, CanvasElement=""></string,></td><td style="text-align:left">是</td><td style="text-align:left">无</td><td style="text-align:left">包含所有画布元素的数据对象</td></tr><tr><td style="text-align:left">elementLayer</td><td style="text-align:left">PIXI.Container</td><td style="text-align:left">是</td><td style="text-align:left">无</td><td style="text-align:left">用于承载所有可视元素的容器</td></tr><tr><td style="text-align:left">destroyed</td><td style="text-align:left">boolean</td><td style="text-align:left">是</td><td style="text-align:left">false</td><td style="text-align:left">标识组件是否已被销毁</td></tr></tbody></table></div><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// elements对象结构示例</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-string">"element1"</span>: <span class="hljs-punctuation">{</span><br><span class="hljs-symbol">    id:</span> <span class="hljs-string">"element1"</span>,<br><span class="hljs-symbol">    type:</span> <span class="hljs-string">"rect"</span>,<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">200</span>,<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">150</span>,<br><span class="hljs-symbol">    fill:</span> <span class="hljs-string">"#ff0000"</span><br>  <span class="hljs-punctuation">}</span>,<br>  <span class="hljs-string">"element2"</span>: <span class="hljs-punctuation">{</span><br><span class="hljs-symbol">    id:</span> <span class="hljs-string">"element2"</span>,<br><span class="hljs-symbol">    type:</span> <span class="hljs-string">"text"</span>,<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">50</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">50</span>,<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">300</span>,<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    text:</span> <span class="hljs-string">"&lt;p&gt;示例文本&lt;/p&gt;"</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p><a href="src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a>: PIXI.Container - PIXI.js 中的容器对象，用于承载所有画布元素的可视化对象。ElementRenderer 会将创建的 PIXI 对象添加到这个容器中，以便在画布上显示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在StageManagerCore.ts中创建elementLayer</span><br><span class="hljs-keyword">private</span> elementLayer: PIXI.Container = new PIXI.Container()<br><span class="hljs-comment">// 然后传给ElementRenderer</span><br><span class="hljs-keyword">this</span>.elementRenderer.renderElements(elements, <span class="hljs-keyword">this</span>.elementLayer, <span class="hljs-keyword">this</span>.state.destroyed)<br></code></pre></td></tr></table></figure><p>destroyed: boolean - 标识渲染器是否已被销毁。当组件被销毁时，此参数防止在销毁后继续执行渲染操作，避免内存泄漏。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderElements</span>(<span class="hljs-params"><span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;, <span class="hljs-attr">elementLayer</span>: PIXI.<span class="hljs-title class_">Container</span>, <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span></span>) {<br>  <span class="hljs-keyword">if</span> (destroyed) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已销毁，直接返回不执行渲染</span><br>  <span class="hljs-comment">// ... 其他渲染逻辑</span><br>}<br></code></pre></td></tr></table></figure><h4 id="2-2-TransformerRenderer-renderTransformer-方法参数"><a href="#2-2-TransformerRenderer-renderTransformer-方法参数" class="headerlink" title="2.2 TransformerRenderer.renderTransformer 方法参数"></a>2.2 TransformerRenderer.renderTransformer 方法参数</h4><p>TransformerRenderer 负责渲染选中元素的变换控制器（手柄、边框等），其 <a href="src/pages/canvas/Pixi_STM_modules/rendering/TransformerRenderer.ts#L31-L182">renderTransformer</a> 方法接收以下参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">elements</td><td style="text-align:left">Record<string, CanvasElement=""></string,></td><td style="text-align:left">所有画布元素的数据</td></tr><tr><td style="text-align:left">selectedIds</td><td style="text-align:left">string[]</td><td style="text-align:left">当前选中元素的 ID 数组</td></tr><tr><td style="text-align:left">spriteMap</td><td style="text-align:left">Map<string, PIXI.DisplayObject=""></string,></td><td style="text-align:left">元素 ID 到 PIXI 可视化对象的映射</td></tr><tr><td style="text-align:left">onHandleDown</td><td style="text-align:left">Function</td><td style="text-align:left">手柄按下事件的回调函数</td></tr><tr><td style="text-align:left">viewportScale</td><td style="text-align:left">number</td><td style="text-align:left">当前视口的缩放比例</td></tr></tbody></table></div><p>elements: Record<string, CanvasElement=""> - 与 ElementRenderer 中的 elements 相同，提供所有画布元素的数据。TransformerRenderer 需要访问元素数据来计算选中元素的边界框和位置信息。</string,></p><p>selectedIds: string[] - 包含当前选中元素 ID 的数组。TransformerRenderer 根据这个数组决定是否以及如何绘制变换控制器（选中框和手柄）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// selectedIds数组示例</span><br>;<span class="hljs-selector-attr">[<span class="hljs-string">'element1'</span>, <span class="hljs-string">'element3'</span>]</span> <span class="hljs-comment">// 表示element1和element3被选中</span><br></code></pre></td></tr></table></figure><p>spriteMap: Map&lt;string, PIXI.Graphics | PIXI.HTMLText | PIXI.Sprite&gt; - 提供元素 ID 到 PIXI 可视化对象的映射。TransformerRenderer 需要访问实际的 PIXI 对象来准确计算元素的边界（特别是文本元素）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// spriteMap结构示例</span><br><span class="hljs-built_in">Map</span>(<span class="hljs-number">2</span>) {<br>  <span class="hljs-string">"element1"</span> =&gt; Graphics {},     <span class="hljs-comment">// 矩形元素的PIXI.Graphics对象</span><br>  <span class="hljs-string">"element2"</span> =&gt; HTMLText {}      <span class="hljs-comment">// 文本元素的PIXI.HTMLText对象</span><br>}<br></code></pre></td></tr></table></figure><p>onHandleDown: Function - 手柄按下事件的回调函数。当用户点击变换控制器上的手柄时，会调用这个函数开始变换操作（如缩放、旋转）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在StageManagerCore.ts中定义并传递给TransformerRenderer</span><br><span class="hljs-keyword">private</span> onHandleDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span>, <span class="hljs-attr">handle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>, <span class="hljs-attr">elementId</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理手柄按下事件</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">'resizing'</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">activeHandle</span> = handle <span class="hljs-keyword">as</span> <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// ... 其他逻辑</span><br>}<br></code></pre></td></tr></table></figure><p>viewportScale: number - 当前视口的缩放比例。TransformerRenderer 使用这个值来调整手柄和控制器的大小，确保在不同缩放级别下都有合适的尺寸。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在StageManagerCore.ts中获取并传递视口缩放比例</span><br><span class="hljs-keyword">this</span>.transformerRenderer.renderTransformer(<br>  elements,<br>  selectedIds,<br>  <span class="hljs-keyword">this</span>.elementRenderer.getSpriteMap(),<br>  <span class="hljs-keyword">this</span>.onHandleDown,<br>  <span class="hljs-keyword">this</span>.viewport.scale.x, <span class="hljs-comment">// 传递视口缩放比例</span><br>)<br></code></pre></td></tr></table></figure><h3 id="2-3-核心类型定义"><a href="#2-3-核心类型定义" class="headerlink" title="2.3 核心类型定义"></a>2.3 核心类型定义</h3><p>渲染层涉及到的关键类型定义如下：</p><h4 id="CanvasElement-类型"><a href="#CanvasElement-类型" class="headerlink" title="CanvasElement 类型"></a>CanvasElement 类型</h4><p>定义了画布元素的基本属性和可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>:<br>    | <span class="hljs-string">"rect"</span><br>    | <span class="hljs-string">"circle"</span><br>    | <span class="hljs-string">"triangle"</span><br>    | <span class="hljs-string">"text"</span><br>    | <span class="hljs-string">"image"</span><br>    | <span class="hljs-string">"line"</span><br>    | <span class="hljs-string">"arrow"</span><br>    | <span class="hljs-string">"pencil"</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 根据元素类型可能包含额外属性</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图片元素</span><br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][]; <span class="hljs-comment">// 线条/铅笔元素</span><br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 透明度</span><br>  <span class="hljs-attr">radius</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 圆角矩形</span><br>}<br></code></pre></td></tr></table></figure><h4 id="HandleType-类型"><a href="#HandleType-类型" class="headerlink" title="HandleType 类型"></a>HandleType 类型</h4><p>定义了变换控制器上各种手柄的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">HandleType</span> =<br>  | <span class="hljs-string">"tl"</span> <span class="hljs-comment">// top-left 左上角</span><br>  | <span class="hljs-string">"t"</span> <span class="hljs-comment">// top 顶部中间</span><br>  | <span class="hljs-string">"tr"</span> <span class="hljs-comment">// top-right 右上角</span><br>  | <span class="hljs-string">"r"</span> <span class="hljs-comment">// right 右侧中间</span><br>  | <span class="hljs-string">"br"</span> <span class="hljs-comment">// bottom-right 右下角</span><br>  | <span class="hljs-string">"b"</span> <span class="hljs-comment">// bottom 底部中间</span><br>  | <span class="hljs-string">"bl"</span> <span class="hljs-comment">// bottom-left 左下角</span><br>  | <span class="hljs-string">"l"</span> <span class="hljs-comment">// left 左侧中间</span><br>  | <span class="hljs-string">"p0"</span> <span class="hljs-comment">// 线段起点</span><br>  | <span class="hljs-string">"p1"</span> <span class="hljs-comment">// 线段终点</span><br>  | <span class="hljs-string">"rotate"</span>; <span class="hljs-comment">// 旋转手柄</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><p>渲染层采用内外结合的状态管理模式，既维护自身的局部状态，又与外部的 Zustand 状态管理库协同工作。</p><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>渲染层维护一组局部状态，用于管理 PIXI 对象和渲染优化：</p><div class="table-container"><table><thead><tr><th style="text-align:left">状态名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>spriteMap</code></td><td style="text-align:left">`Map&lt;string, PIXI.Graphics \</td><td style="text-align:left">PIXI.HTMLText \</td><td>PIXI.Sprite&gt;`</td><td>存储元素 ID 到 PIXI 图形对象的映射关系，用于快速查找和更新元素</td></tr><tr><td style="text-align:left"><code>textureCache</code></td><td style="text-align:left"><code>Map&lt;string, PIXI.Texture&gt;</code></td><td style="text-align:left">图片纹理缓存，避免重复加载相同图片</td></tr><tr><td style="text-align:left"><code>loadingSet</code></td><td style="text-align:left"><code>Set&lt;string&gt;</code></td><td style="text-align:left">正在加载中的图片 URL 集合，防止重复加载</td></tr><tr><td style="text-align:left"><code>imageUpdateTimers</code></td><td style="text-align:left"><code>Map&lt;string, NodeJS.Timeout&gt;</code></td><td style="text-align:left">图像元素更新检查定时器映射</td></tr><tr><td style="text-align:left"><code>transformerGraphic</code></td><td style="text-align:left"><code>PIXI.Graphics</code></td><td style="text-align:left">用于绘制变换控制器（选中框、手柄等）的图形对象</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// ElementRenderer 内部状态示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">textureCache</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Texture</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">loadingSet</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">imageUpdateTimers</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><br><span class="hljs-comment">// TransformerRenderer 内部状态示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">transformerGraphic</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Graphics</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Graphics</span>()<br><br></code></pre></td></tr></table></figure><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>渲染层通过订阅 Zustand 状态管理库中的 <a href="src/stores/canvasStore.ts#L35-L136">canvasStore</a> 来获取画布元素数据和选中状态：</p><div class="table-container"><table><thead><tr><th style="text-align:left">状态名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>elements</code></td><td style="text-align:left"><code>Record&lt;string, CanvasElement&gt;</code></td><td style="text-align:left">所有画布元素的数据对象</td></tr><tr><td style="text-align:left"><code>selectedIds</code></td><td style="text-align:left"><code>string[]</code></td><td style="text-align:left">当前选中元素的 ID 数组</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// StageManagerCore.ts 中订阅外部状态的方式</span><br>useStore.<span class="hljs-title function_">subscribe</span>(<br>  <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">elements</span>: state.<span class="hljs-property">elements</span>, <span class="hljs-attr">selectedIds</span>: state.<span class="hljs-property">selectedIds</span> }),<br>  <span class="hljs-function">(<span class="hljs-params">{ elements, selectedIds }</span>) =&gt;</span> {<br>    <span class="hljs-comment">// 当 elements 或 selectedIds 发生变化时触发重新渲染</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();<br>  },<br>  { <span class="hljs-attr">equalityFn</span>: shallow }<br>);<br></code></pre></td></tr></table></figure><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><p>渲染层通过增量更新（Diffing）算法实现高效的状态同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A[Zustand Store 状态变更] --&gt; B{StageManager 订阅}<br>B --&gt; C{Diff 算法对比}<br>C --&gt;|新增元素| D[创建 PIXI 对象]<br>C --&gt;|更新元素| E[更新 PIXI 对象属性]<br>C --&gt;|删除元素| F[销毁 PIXI 对象]<br>D --&gt; G[添加到 spriteMap]<br>E --&gt; G<br>F --&gt; H[从 spriteMap 移除]<br>G --&gt; I[PixiJS 渲染]<br>H --&gt; I<br>    style A fill:#e1f5fe<br>    style I fill:#e8f5e8<br>    style G fill:#fff3e0<br>    style H fill:#ffebee<br><br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>participant U as 用户<br>participant SM as StageManagerCore<br>participant ER as ElementRenderer<br>participant TR as TransformerRenderer<br>participant S as Zustand Store<br><br>    U-&gt;&gt;SM: 触发状态变更 (添加/更新元素)<br>    SM-&gt;&gt;S: 更新elements数据<br>    S-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;ER: 调用renderElements()<br>    ER-&gt;&gt;ER: 根据元素类型创建/更新PIXI对象<br>    ER-&gt;&gt;SM: 更新spriteMap<br>    <br>    U-&gt;&gt;SM: 选择元素<br>    SM-&gt;&gt;S: 更新selectedIds<br>    S-&gt;&gt;SM: 通知选中状态变更<br>    SM-&gt;&gt;TR: 调用renderTransformer()<br>    TR-&gt;&gt;TR: 根据选中元素绘制变换控制器<br></code></pre></td></tr></table></figure><hr><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><ul><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/rendering/ElementRenderer.ts#L57-L157">ElementRenderer.renderElements()</a></strong>:</p><ul><li><p><strong>触发时机</strong>: 当画布元素数据发生变更时，通过状态订阅机制触发。每当 Zustand store 中的 <a href="/src/stores/canvasStore.ts#L44-L44">elements</a> 对象发生变化时，StageManagerCore 会调用此方法进行重新渲染。</p></li><li><p><strong>逻辑闭环</strong>: 遍历所有元素数据，根据元素类型创建或更新对应的 PIXI 对象，并将其添加到容器中。通过 diff 算法比较现有 spriteMap 和新元素数据（遍历 spriteMap 中的所有元素 ID，检查哪些元素在新的 elements 数据中不存在，这些元素需要被删除，遍历新的 elements 数据中的所有元素 ID，检查哪些是新增的元素需要创建，哪些是已存在的元素需要更新），确定需要创建、更新或删除的元素，最终保持 PIXI 对象与数据状态同步。</p></li><li><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 核心渲染逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderElements</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">elementLayer</span>: PIXI.<span class="hljs-title class_">Container</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (destroyed) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 获取当前所有元素ID</span><br>  <span class="hljs-keyword">const</span> elementIds = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(elements);<br><br>  <span class="hljs-comment">// 删除已移除的元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">keys</span>()) {<br>    <span class="hljs-keyword">if</span> (!elementIds.<span class="hljs-title function_">includes</span>(id)) {<br>      <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id)!;<br>      sprite.<span class="hljs-title function_">destroy</span>({ <span class="hljs-attr">children</span>: <span class="hljs-literal">true</span> });<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">delete</span>(id);<br>    }<br>  }<br><br>  <span class="hljs-comment">// 更新或创建元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> elementIds) {<br>    <span class="hljs-keyword">const</span> data = elements[id];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">has</span>(id)) {<br>      <span class="hljs-comment">// 更新现有元素</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateElement</span>(data, <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id)!);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// 创建新元素</span><br>      <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createElement</span>(data);<br>      elementLayer.<span class="hljs-title function_">addChild</span>(sprite);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">set</span>(id, sprite);<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>差异化渲染处理</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 根据不同类型元素进行差异化渲染处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">CanvasElement</span>): <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span> {<br>  <span class="hljs-keyword">switch</span> (data.<span class="hljs-property">type</span>) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'rect'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'circle'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'triangle'</span>:<br>      <span class="hljs-comment">// 几何图形处理逻辑：使用Graphics API绘制形状</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createGraphicsElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>:<br>      <span class="hljs-comment">// 文本元素处理逻辑：使用HTMLText组件渲染富文本</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createTextElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'image'</span>:<br>      <span class="hljs-comment">// 图片元素处理逻辑：加载纹理并创建Sprite</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createImageElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'line'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'arrow'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'pencil'</span>:<br>      <span class="hljs-comment">// 线条/铅笔元素处理逻辑：使用Graphics API绘制线条</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createLineElement</span>(data);<br><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Unsupported element type: <span class="hljs-subst">${data.<span class="hljs-keyword">type</span>}</span>`</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/rendering/TransformerRenderer.ts#L31-L182">TransformerRenderer.renderTransformer()</a></strong>:</p><ul><li><p><strong>触发时机</strong>: 当选中元素发生变更时触发。每当 Zustand store 中的 <a href="/src/stores/canvasStore.ts#L45-L45">selectedIds</a> 数组发生变化时，StageManagerCore 会调用此方法更新变换控制器的显示。</p></li><li><p><strong>逻辑闭环</strong>: 根据选中元素的数量和类型，绘制相应的变换控制器（如缩放手柄、旋转手柄等）。通过清除之前的控制器图形并根据当前选中状态重新绘制，保持变换控制器与选中状态同步。</p></li><li><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 变换控制器渲染逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderTransformer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, PIXI.<span class="hljs-title class_">DisplayObject</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">onHandleDown</span>: (</span><br><span class="hljs-params">    e: PIXI.FederatedPointerEvent,</span><br><span class="hljs-params">    handle: HandleType | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>,</span><br><span class="hljs-params">    elementId: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  ) =&gt; <span class="hljs-built_in">void</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">viewportScale</span>: <span class="hljs-built_in">number</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 清除之前的变换控制器</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">clear</span>();<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-comment">// 单个元素选中逻辑</span><br>    <span class="hljs-keyword">const</span> element = elements[selectedIds[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">const</span> sprite = spriteMap.<span class="hljs-title function_">get</span>(selectedIds[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (sprite) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawSingleElementTransformer</span>(element, sprite, onHandleDown, viewportScale);<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 多个元素选中逻辑</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawMultiElementTransformer</span>(elements, selectedIds, spriteMap, onHandleDown, viewportScale);<br>  }<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="UI-与样式实现-UI-Implementation"><a href="#UI-与样式实现-UI-Implementation" class="headerlink" title="UI 与样式实现 (UI Implementation)"></a>UI 与样式实现 (UI Implementation)</h4><ul><li><p><strong>布局策略</strong>: 使用 PIXI 的容器系统进行布局管理，分为 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a>（元素层）和 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L37-L37">uiLayer</a>（UI 层）两个层级，通过坐标系统定位元素</p><ul><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a></strong>: 用于承载所有画布元素的容器层，包括矩形、圆形、文本、图像等各种元素的 PIXI 对象都添加到这一层。这是渲染层的主要内容，负责显示用户创建的所有图形元素。</p></li><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L37-L37">uiLayer</a></strong>: 用于承载所有 UI 元素的容器层，包括选区框、橡皮擦指示器、变换控制器等辅助 UI 元素。这一层位于元素层之上，确保 UI 元素始终显示在图形元素的前面。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore.ts 中创建两个容器层</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">elementLayer</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Container</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Container</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">uiLayer</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Container</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Container</span>()<br><br><span class="hljs-comment">// 将两个容器层添加到视口中</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">addChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementLayer</span>)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">addChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiLayer</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>样式方案</strong>:</p><ul><li>几何图形使用 PIXI 的绘图 API 进行绘制，支持描边、填充、透明度等样式</li><li>文本元素使用 HTMLText 组件支持富文本渲染</li><li>图片元素使用 PIXI.Sprite 并支持滤镜效果（模糊、亮度、灰度等）</li><li>变换控制器统一使用紫色 (#8b5cf6) 作为主题色</li></ul></li><li><p><strong>条件渲染</strong>:</p><ul><li>根据元素类型选择不同的渲染方式</li><li>根据选中状态决定是否显示变换控制器</li><li>根据选中元素数量显示不同的控制器形态（单选手柄 vs 群组控制器）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A[Viewport] --&gt; B[elementLayer]<br>A --&gt; C[uiLayer]<br>B --&gt; D[图形元素 1]<br>B --&gt; E[图形元素 2]<br>B --&gt; F[文本元素]<br>B --&gt; G[图像元素]<br>C --&gt; H[选区框]<br>C --&gt; I[橡皮擦指示器]<br>C --&gt; J[变换控制器]<br><br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#e8f5e8<br>    style D fill:#fce4ec<br>    style E fill:#fce4ec<br>    style F fill:#fce4ec<br>    style G fill:#fce4ec<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style J fill:#fff3e0<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>前端项目安装和配置指南 Vite + React + TypeScript + Tailwind CSS</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39845.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39845.html</id>
    <published>2025-11-23T04:38:32.000Z</published>
    <updated>2025-11-23T06:46:44.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南"><a href="#Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南" class="headerlink" title="Vite + React + TypeScript + Tailwind CSS 脚手架搭建指南"></a>Vite + React + TypeScript + Tailwind CSS 脚手架搭建指南</h2><p>本文记录从零搭建 <code>Vite + React + Tailwind CSS</code> 项目，省去一个个官网去查阅文档，旨在方便快速丝滑的创建项目</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><strong>Vite 4.2.0</strong> - 新一代构建工具，提供极快的冷启动和热更新。基于原生 ES 模块实现，开发时按需编译，相比传统打包工具具有显著的速度优势。</li><li><strong>React 18.2.0</strong> - 流行的前端 UI 库，采用组件化架构和虚拟 DOM 技术，提供高效的渲染性能和良好的开发体验。</li><li><strong>TypeScript 5.3.3</strong> - JavaScript 的超集，提供静态类型检查，在编译阶段发现潜在错误，增强代码可维护性和开发效率。</li><li><strong>Tailwind CSS 3.3.1</strong> - 实用优先的 CSS 框架，通过组合预定义的原子类来构建界面，无需编写自定义 CSS 即可实现复杂设计。</li><li><strong>ESLint &amp; Prettier</strong> - 代码规范和格式化工具。ESLint 用于检测代码质量问题和潜在错误，Prettier 专注于代码格式统一，共同保障代码质量。</li><li><strong>Husky &amp; lint-staged</strong> - Git 钩子工具，用于提交前代码检查。Husky 简化 Git 钩子配置，lint-staged 仅对暂存文件执行操作，提升提交前检查效率。</li><li><strong>React Router DOM 6</strong> - React 应用的路由管理工具，提供声明式路由配置，支持动态路由、嵌套路由等特性，是构建单页应用的核心组件。</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">BDdraw_DEV/<br>├── .husky/                     <span class="hljs-comment"># Git hooks 配置</span><br>├── .vscode/                    <span class="hljs-comment"># VSCode 配置</span><br>├── docs/                       <span class="hljs-comment"># 文档目录</span><br>├── public/                     <span class="hljs-comment"># 静态资源目录</span><br>├── src/                        <span class="hljs-comment"># 源代码主目录</span><br>│   ├── api/                    <span class="hljs-comment"># API 接口定义</span><br>│   ├── assets/                 <span class="hljs-comment"># 静态资源文件</span><br>│   ├── components/             <span class="hljs-comment"># 公共组件</span><br>│   ├── hooks/                  <span class="hljs-comment"># 自定义 React Hooks</span><br>│   ├── lib/                    <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   ├── pages/                  <span class="hljs-comment"># 页面组件</span><br>│   ├── router/                 <span class="hljs-comment"># 路由配置</span><br>│   │   └── router.tsx          <span class="hljs-comment"># 路由定义</span><br>│   ├── stores/                 <span class="hljs-comment"># 状态管理</span><br>│   ├── styles/                 <span class="hljs-comment"># 样式文件</span><br>│   ├── app.tsx                 <span class="hljs-comment"># 应用入口组件</span><br>│   ├── main.tsx                <span class="hljs-comment"># 主入口文件</span><br>│   └── vite-env.d.ts           <span class="hljs-comment"># Vite 环境声明文件</span><br>├── .editorconfig               <span class="hljs-comment"># 编辑器配置</span><br>├── .eslintrc                  <span class="hljs-comment"># ESLint 配置</span><br>├── .gitignore                 <span class="hljs-comment"># Git 忽略文件配置</span><br>├── .prettierrc.js             <span class="hljs-comment"># Prettier 配置</span><br>├── .stylelintrc.json          <span class="hljs-comment"># Stylelint 配置</span><br>├── commitlint.config.cjs      <span class="hljs-comment"># Commitlint 配置</span><br>├── components.json            <span class="hljs-comment"># 组件配置</span><br>├── index.html                 <span class="hljs-comment"># HTML 入口</span><br>├── lint-staged.config.js      <span class="hljs-comment"># Lint-staged 配置</span><br>├── package.json               <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js          <span class="hljs-comment"># PostCSS 配置</span><br>├── tailwind.config.js         <span class="hljs-comment"># Tailwind CSS 配置</span><br>├── transmart.config.ts        <span class="hljs-comment"># Transmart 配置</span><br>├── tsconfig.json              <span class="hljs-comment"># TypeScript 配置</span><br>├── tsconfig.node.json         <span class="hljs-comment"># Node.js TypeScript 配置</span><br>├── vite.config.ts             <span class="hljs-comment"># Vite 配置</span><br>└── README.md                  <span class="hljs-comment"># 项目说明文档</span><br><br></code></pre></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>使用 Vite 创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm create vite@latest [项目名] -- --template react-ts<br><span class="hljs-built_in">cd</span> [项目名]<br></code></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure><h3 id="集成-Tailwind-CSS-v3"><a href="#集成-Tailwind-CSS-v3" class="headerlink" title="集成 Tailwind CSS v3"></a>集成 Tailwind CSS v3</h3><p>Tailwind CSS 是一个功能类优先的 CSS 框架，它提供了大量的实用类，可以直接在 HTML 中组合使用来构建任何设计。通过配置文件可以自定义主题、颜色、间距等设计系统，并且只生成实际使用的样式，使得最终的 CSS 文件非常精简。其 JIT（Just-In-Time）模式可以按需生成样式，大大提高了编译速度并支持更多功能。</p><p>安装 Tailwind CSS v3 及其依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D tailwindcss postcss autoprefixer<br>npx tailwindcss init -p<br></code></pre></td></tr></table></figure><p>如果出问题可以去翻一下官方文档，v4 改变了一些部署方式</p><p>配置 Tailwind CSS</p><p>编辑 <code>tailwind.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import('tailwindcss').Config</span>} */</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">content</span>: [<span class="hljs-string">"./index.html"</span>, <span class="hljs-string">"./src/**/*.{js,ts,jsx,tsx}"</span>],<br>  <span class="hljs-attr">theme</span>: {<br>    <span class="hljs-attr">extend</span>: {},<br>  },<br>  <span class="hljs-attr">plugins</span>: [],<br>};<br></code></pre></td></tr></table></figure><h3 id="引入-Tailwind-CSS-v3"><a href="#引入-Tailwind-CSS-v3" class="headerlink" title="引入 Tailwind CSS v3"></a>引入 Tailwind CSS v3</h3><p>在 <code>src/index.css</code> 文件中添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@tailwind</span> base;<br><span class="hljs-keyword">@tailwind</span> components;<br><span class="hljs-keyword">@tailwind</span> utilities;<br></code></pre></td></tr></table></figure><p>并在入口文件中导入该 CSS 文件：</p><p>Tailwind CSS 的三个核心层：</p><ul><li><code>@tailwind base</code> - 包含 Normalize.css 和一些基础样式重置</li><li><code>@tailwind components</code> - 包含框架的组件类，可用于添加结构样式</li><li><code>@tailwind utilities</code> - 包含所有实用类，这是 Tailwind 的核心部分</li></ul><p>通过这种分层方式，Tailwind 提供了一种灵活的方式来组织和扩展样式。</p><h3 id="配置-TypeScript"><a href="#配置-TypeScript" class="headerlink" title="配置 TypeScript"></a>配置 TypeScript</h3><p>TypeScript 是 JavaScript 的超集，添加了可选的静态类型。它可以帮助开发者在编码阶段捕获错误，提供更好的代码补全和重构支持。通过配置 <code>tsconfig.json</code>，我们可以控制 TypeScript 编译器的行为，如目标 JavaScript 版本、模块解析策略、严格性级别等。在本项目中，我们启用了严格的类型检查，同时配置了 React JSX 支持。</p><p>项目中的 <code>tsconfig.json</code> 文件已经包含了基本的 TypeScript 配置。根据项目需求，我们可以对其进行定制：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"useDefineForClassFields"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"DOM"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"DOM.Iterable"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"skipLibCheck"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"allowSyntheticDefaultImports"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"forceConsistentCasingInFileNames"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Node"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"resolveJsonModule"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"isolatedModules"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"jsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"react-jsx"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"references"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span> <span class="hljs-attr">"path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./tsconfig.node.json"</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><h3 id="配置-ESLint-和-Prettier"><a href="#配置-ESLint-和-Prettier" class="headerlink" title="配置 ESLint 和 Prettier"></a>配置 ESLint 和 Prettier</h3><p>ESLint 是一个可插拔的 JavaScript 和 TypeScript 代码质量检查工具，它可以识别语法错误和代码风格问题。Prettier 是一个代码格式化工具，专注于代码风格统一。两者结合使用可以确保团队代码质量和风格的一致性。通过配置规则，我们可以自定义检查标准，例如是否使用分号、引号类型、缩进大小等。</p><p>安装相关依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser<br></code></pre></td></tr></table></figure><p>配置 ESLint</p><p>创建 <code>.eslintrc</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"browser"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"es2021"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"extends"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">"eslint:recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:@typescript-eslint/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:react/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:react-hooks/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"prettier"</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parser"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@typescript-eslint/parser"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parserOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"ecmaVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"latest"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"sourceType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"plugins"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"@typescript-eslint"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"react"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"prettier"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"rules"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"prettier/prettier"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"error"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"react/react-in-jsx-scope"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"off"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"settings"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"react"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"detect"</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p>配置 Prettier</p><p>创建 <code>.prettierrc</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"semi"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"singleQuote"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"tabWidth"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"trailingComma"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"es5"</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><h3 id="配置-Git-Hooks"><a href="#配置-Git-Hooks" class="headerlink" title="配置 Git Hooks"></a>配置 Git Hooks</h3><p>Git Hooks 允许我们在 Git 操作的不同阶段执行自定义脚本。通过 Husky 和 lint-staged，我们可以在代码提交前自动运行 ESLint 和 Prettier，确保只有符合规范的代码才能进入代码库。lint-staged 只会针对暂存区的文件运行检查，提高效率。这有助于保持整个项目的代码质量和一致性。</p><p>使用 Husky 和 lint-staged 在代码提交前自动运行代码检查和格式化。</p><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D husky lint-staged<br></code></pre></td></tr></table></figure><p>初始化 Husky</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky install<br></code></pre></td></tr></table></figure><p>配置 lint-staged</p><p>创建 <code>lint-staged.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-string">"*.{ts,tsx}"</span>: [<span class="hljs-string">"eslint --fix"</span>, <span class="hljs-string">"prettier --write"</span>],<br>  <span class="hljs-string">"*.{css,md}"</span>: <span class="hljs-string">"prettier --write"</span>,<br>};<br></code></pre></td></tr></table></figure><p>添加 pre-commit 钩子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky add .husky/pre-commit <span class="hljs-string">"npx lint-staged"</span><br></code></pre></td></tr></table></figure><h3 id="集成-React-Router"><a href="#集成-React-Router" class="headerlink" title="集成 React Router"></a>集成 React Router</h3><p>React Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。</p><p>安装 React Router</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install react-router-dom<br>npm install -D @types/react-router-dom<br></code></pre></td></tr></table></figure><p>创建路由配置</p><p>创建 <code>src/router/router.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { createBrowserRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"../pages/Home"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"../pages/About"</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  {<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span>,<br>  },<br>  {<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">"/about"</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span> /&gt;</span></span>,<br>  },<br>]);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p>在应用中使用路由</p><p>更新 <code>src/App.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">RouterProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">"./router/router"</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterProvider</span> <span class="hljs-attr">router</span>=<span class="hljs-string">{router}</span> /&gt;</span></span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>创建页面组件</p><p>创建 <code>src/pages/Home.tsx</code> 和 <code>src/pages/About.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/pages/Home.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/pages/About.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">About</span>;<br></code></pre></td></tr></table></figure><p>React Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。</p><h3 id="配置-Vite"><a href="#配置-Vite" class="headerlink" title="配置 Vite"></a>配置 Vite</h3><p>项目的 <code>vite.config.ts</code> 文件配置如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;<br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;<br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">resolve</span>: {<br>    <span class="hljs-attr">alias</span>: {<br>      <span class="hljs-string">"@"</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src"</span>),<br>    },<br>  },<br>  <span class="hljs-attr">css</span>: {<br>    <span class="hljs-attr">postcss</span>: <span class="hljs-string">"./postcss.config.js"</span>,<br>  },<br>  <span class="hljs-attr">server</span>: {<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>  },<br>});<br></code></pre></td></tr></table></figure><h3 id="配置-PostCSS"><a href="#配置-PostCSS" class="headerlink" title="配置 PostCSS"></a>配置 PostCSS</h3><p>PostCSS 是一个使用 JavaScript 插件转换 CSS 的工具。在这个项目中，我们使用了两个关键插件：</p><ul><li>Tailwind CSS 插件：处理 Tailwind CSS 相关的样式生成</li><li>Autoprefixer 插件：自动添加厂商前缀以确保样式在不同浏览器中的兼容性</li></ul><p>通过 PostCSS，我们可以自动化处理 CSS，减少手动工作并提高样式兼容性。</p><p><code>postcss.config.js</code> 文件配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">plugins</span>: {<br>    <span class="hljs-attr">tailwindcss</span>: {},<br>    <span class="hljs-attr">autoprefixer</span>: {},<br>  },<br>};<br></code></pre></td></tr></table></figure><h3 id="添加常用组件和工具"><a href="#添加常用组件和工具" class="headerlink" title="添加常用组件和工具"></a>添加常用组件和工具</h3><p>通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。</p><p>创建基础 UI 组件：在 <code>src/components/ui</code> 目录下创建一些基础 UI 组件，例如按钮、输入框等</p><p>创建自定义 Hooks：在 <code>src/hooks</code> 目录下创建常用的自定义 Hooks，例如 <code>useLocalStorage</code>、<code>useToggle</code> 等</p><p>配置路径别名：在 <code>tsconfig.json</code> 中配置路径别名，方便导入模块：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-comment">// ... 其他配置</span><br>    <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"."</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/*"</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p>通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。</p><h3 id="其他重要配置文件说明"><a href="#其他重要配置文件说明" class="headerlink" title="其他重要配置文件说明"></a>其他重要配置文件说明</h3><h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p><code>.gitignore</code> 文件用于指定 Git 应当忽略的文件和目录，防止不必要的文件被提交到代码仓库。在本项目中，该文件包含了以下几类被忽略的内容：</p><ol><li><strong>系统文件</strong>：如 macOS 系统生成的 <code>.DS_Store</code> 文件</li><li><strong>日志文件</strong>：如 npm、yarn 等生成的日志文件</li><li><strong>依赖目录</strong>：如 <code>node_modules/</code> 目录</li><li><strong>构建输出</strong>：如构建工具生成的 <code>dist/</code>、<code>.next/</code> 等目录</li><li><strong>缓存文件</strong>：如各种工具生成的缓存文件</li><li><strong>环境变量文件</strong>：如 <code>.env</code> 及其变体文件，防止敏感信息泄露</li><li><strong>编辑器配置</strong>：如编辑器生成的临时文件</li></ol><p>通过合理配置 <code>.gitignore</code>，可以减小代码仓库体积，保护敏感信息，并避免无关文件干扰开发。</p><h4 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h4><p><code>.editorconfig</code> 文件用于统一不同编辑器和 IDE 的代码格式设置。在团队协作中，不同开发者可能使用不同的编辑器，该文件可以确保所有人使用相同的编码规范：</p><ul><li>使用空格缩进，缩进大小为 2 个空格</li><li>行尾符使用 LF (Unix 风格)</li><li>字符编码使用 UTF-8</li><li>自动删除行尾空白字符</li><li>文件末尾自动添加新行</li></ul><p>这有助于保持代码风格的一致性，避免因编辑器差异导致的格式混乱。</p><h4 id="prettierrc-js"><a href="#prettierrc-js" class="headerlink" title=".prettierrc.js"></a>.prettierrc.js</h4><p>Prettier 配置文件，用于统一代码格式化风格：</p><ul><li>不使用分号结尾</li><li>对象和数组末尾保留逗号</li><li>使用单引号而非双引号</li><li>单行最大宽度为 120 字符</li><li>缩进使用 2 个空格</li><li>行尾符自动适应操作系统</li></ul><p>Prettier 会在保存文件或执行格式化命令时自动应用这些规则，确保整个项目的代码风格统一。</p><h4 id="commitlint-config-cjs"><a href="#commitlint-config-cjs" class="headerlink" title="commitlint.config.cjs"></a>commitlint.config.cjs</h4><p>Commitlint 配置文件，用于校验 Git 提交信息的格式。它继承了 <code>@commitlint/config-conventional</code> 规则，要求提交信息遵循约定式提交规范：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&lt;<span class="hljs-keyword">type</span>&gt;[<span class="hljs-keyword">optional</span> scope]: &lt;description&gt;<br><br>[<span class="hljs-keyword">optional</span> body]<br><br>[<span class="hljs-keyword">optional</span> footer(s)]<br></code></pre></td></tr></table></figure><p>其中 type 必须是以下几种之一：</p><ul><li>feat: 新功能</li><li>fix: 修复 bug</li><li>chore: 构建过程或辅助工具的变动</li><li>docs: 文档更新</li><li>style: 代码格式调整</li><li>refactor: 重构</li><li>perf: 性能优化</li><li>test: 测试用例</li></ul><p>这有助于生成标准化的变更日志，便于团队理解和维护项目历史。</p><h4 id="stylelintrc-json"><a href="#stylelintrc-json" class="headerlink" title=".stylelintrc.json"></a>.stylelintrc.json</h4><p>Stylelint 配置文件，用于检查 CSS/LESS 样式代码的质量和风格。该项目配置了：</p><ul><li>继承标准规则集和 Prettier 推荐规则</li><li>支持 LESS 语法</li><li>启用 Prettier 规则</li><li>自定义类名命名规范（小写字母和连字符）</li><li>允许未知的 at-rule（为了支持 LESS 特性）</li></ul><p>通过 Stylelint 可以确保样式代码的一致性和质量，避免常见的样式错误。</p><h4 id="lint-staged-config-js"><a href="#lint-staged-config-js" class="headerlink" title="lint-staged.config.js"></a>lint-staged.config.js</h4><p>Lint-staged 配置文件，用于对 Git 暂存区的文件执行检查和格式化：</p><ul><li>对 TypeScript 文件执行 ESLint 和 Prettier</li><li>对 JavaScript 文件执行 ESLint 和 Prettier</li><li>对 LESS 和 CSS 文件执行 Stylelint</li><li>对其他文件执行相应检查</li></ul><p>这确保只有符合规范的代码才能被提交到仓库，提升整体代码质量。</p><h3 id="开发环境和生产环境配置"><a href="#开发环境和生产环境配置" class="headerlink" title="开发环境和生产环境配置"></a>开发环境和生产环境配置</h3><p>开发环境启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run dev<br></code></pre></td></tr></table></figure><p>构建生产版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><p>预览生产构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run preview<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南&quot;&gt;&lt;a href=&quot;#Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南&quot; class=&quot;headerlink&quot; title=&quot;Vite + R</summary>
      
    
    
    
    <category term="Github" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-22- 使用 GitHub Actions 自动部署基于vite的项目到 GitHub Pages</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33040.html</id>
    <published>2025-11-22T17:59:24.000Z</published>
    <updated>2025-11-23T09:48:37.352Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记主要讲在新创建前端项目后，如何通过 GitHub-Actions 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</p><p>参考 <a href="https://zhongye1.github.io/BDdraw_DEV/#/">https://zhongye1.github.io/BDdraw_DEV/#/</a><br>其从仓库 <a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a> 实现自动构建和部署</p><h3 id="0-前置条件"><a href="#0-前置条件" class="headerlink" title="0.前置条件"></a>0.前置条件</h3><ul><li>GitHub 账户 + 一个 public 仓库（私有仓库需要 GitHub Pro 才能开 Pages）</li></ul><h3 id="1-创建-GitHub-Actions-工作流"><a href="#1-创建-GitHub-Actions-工作流" class="headerlink" title="1. 创建 GitHub Actions 工作流"></a>1. 创建 GitHub Actions 工作流</h3><p>在仓库根目录创建文件： .github/workflows/deploy.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">main</span>]<br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">read</span><br>  <span class="hljs-attr">pages:</span> <span class="hljs-string">write</span><br>  <span class="hljs-attr">id-token:</span> <span class="hljs-string">write</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">github-pages</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">${{</span> <span class="hljs-string">steps.deployment.outputs.page_url</span> <span class="hljs-string">}}</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Bun</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">oven-sh/setup-bun@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">bun-version:</span> <span class="hljs-string">latest</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">bun</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">bun</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/configure-pages@v5</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">artifact</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/upload-pages-artifact@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">"./dist"</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">deployment</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/deploy-pages@v4</span><br></code></pre></td></tr></table></figure><h3 id="2-配置-vite-config-ts-的-base"><a href="#2-配置-vite-config-ts-的-base" class="headerlink" title="2. 配置 vite.config.ts 的 base"></a>2. 配置 vite.config.ts 的 base</h3><p>打开 vite.config.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span><br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-react'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">base</span>: <span class="hljs-string">'/BDdraw_DEV/'</span>,   <span class="hljs-comment">// 必须和仓库名完全一致！大小写也要一样</span><br>})<br></code></pre></td></tr></table></figure><p>如果想让它在本地开发和 GitHub Pages 都正常，可以写成动态 base：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">base</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">'production'</span> ? <span class="hljs-string">'/BDdraw_DEV/'</span> : <span class="hljs-string">'/'</span>,<br>})<br></code></pre></td></tr></table></figure><h3 id="3-GitHub-仓库设置-Pages-为-Actions-模式"><a href="#3-GitHub-仓库设置-Pages-为-Actions-模式" class="headerlink" title="3. GitHub 仓库设置 Pages 为 Actions 模式"></a>3. GitHub 仓库设置 Pages 为 Actions 模式</h3><ol><li>进入仓库 → Settings → Pages（左侧菜单）</li><li>Build and deployment → Source 选 <strong>GitHub Actions</strong></li><li>保存</li></ol><h3 id="4-提交代码触发第一次部署"><a href="#4-提交代码触发第一次部署" class="headerlink" title="4. 提交代码触发第一次部署"></a>4. 提交代码触发第一次部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add .<br>git commit -m <span class="hljs-string">"chore: 新建 GitHub Actions 部署工作流"</span><br>git push origin main<br></code></pre></td></tr></table></figure><p>然后去仓库 → Actions 标签页，就能看到正在跑的 “Deploy to GitHub Pages” 工作流。</p><p>成功后可以前往对应的 GitHub Pages 地址查看效果</p><p class='item-img' data-src='https://pica.zhimg.com/v2-25ed9b20ac34367edf61581afc6742ea_r.jpg'><img src="https://pica.zhimg.com/v2-25ed9b20ac34367edf61581afc6742ea_r.jpg" alt="alt text"></p><p>只要 push 到 main 分支，GitHub Actions 就会自动触发工作流，实现自动部署。</p><blockquote><p>如果是私有仓库，需要 GitHub Pro 才能开 Pages</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇笔记主要讲在新创建前端项目后，如何通过 GitHub-Actions 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作&lt;/p&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://zhongye1.github.io/BDdraw_DE</summary>
      
    
    
    
    <category term="Github" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-22- 关于前端包管理器npm,pnpm,yarn和bun以及我为何选择后者</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/15722.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/15722.html</id>
    <published>2025-11-22T13:21:15.000Z</published>
    <updated>2025-11-22T13:39:37.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>因为快。</strong></p><p>2025 年，Bun 作为一个「全能型」运行时 + 包管理器，在实际项目中对传统包管理器（npm/yarn/pnpm）确实有相当大的优势，很多人已经开始抛弃 npm/yarn/pnpm，转用 Bun 作为前端项目的包管理器</p><h3 id="初识-Bun-管理器"><a href="#初识-Bun-管理器" class="headerlink" title="初识 Bun 管理器"></a>初识 Bun 管理器</h3><p>Bun 是 JavaScript 和 TypeScript 应用程序的一站式工具包。它作为一个名为<code>bun</code>的单个可执行文件提供。</p><p>其核心是 Bun 运行时，这是一个快速的 JavaScript 运行时，设计为 Node.js 的即插即用替代品。它是用 Zig 编写的，在底层由 JavaScriptCore 驱动，大大减少了启动时间和内存使用。</p><h3 id="对比其他包管理器"><a href="#对比其他包管理器" class="headerlink" title="对比其他包管理器"></a>对比其他包管理器</h3><h4 id="1-npm（Node-Package-Manager）"><a href="#1-npm（Node-Package-Manager）" class="headerlink" title="1. npm（Node Package Manager）"></a>1. npm（Node Package Manager）</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：使用扁平化依赖树（flattened dependency tree，自 v3+ 引入），但仍依赖传统的 node_modules 目录结构。每个包及其子依赖都会下载 tarball（压缩包），然后解压到本地 node_modules 中。如果有版本冲突，会创建嵌套的 node_modules 子目录（hoisting 机制试图扁平化，但不总是完美）。</li><li><strong>锁文件</strong>：package-lock.json，记录精确的依赖树和哈希值，确保可重现安装。</li><li><strong>缓存机制</strong>：全局缓存在 ~/.npm（或 Windows 的 %AppData%\npm-cache），存储 tarball 和元数据。安装时先检查缓存，命中则直接解压。</li><li><strong>下载与并行</strong>：自 v7+ 支持并行下载（自 v5+），使用 HTTP/1.1 或 HTTP/2，但解析依赖树时仍依赖 JavaScript 引擎（Node.js），导致启动开销大。</li><li><strong>monorepo 支持</strong>：基本支持（通过 workspaces），但需手动配置，效率一般。</li></ul><p><strong>技术栈</strong>：纯 Node.js 实现，CLI 基于 npm-cli。</p><h4 id="2-pnpm（Performant-NPM）"><a href="#2-pnpm（Performant-NPM）" class="headerlink" title="2. pnpm（Performant NPM）"></a>2. pnpm（Performant NPM）</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：引入<strong>内容寻址存储（content-addressable store）</strong>，所有包统一存储在全局 .pnpm/store（硬链接 + 符号链接）。项目中只生成一个扁平的 node_modules/.pnpm 目录，通过符号链接（symlinks）指向全局包，避免重复下载。严格的 peer dependency 隔离，防止“幽灵依赖”（phantom dependencies）。</li><li><strong>锁文件</strong>：pnpm-lock.yaml，YAML 格式，记录依赖图和完整哈希链。</li><li><strong>缓存机制</strong>：全局 store + 硬链接，安装时直接链接现有包（无解压开销）。支持范围补丁（patching），允许动态修改依赖。</li><li><strong>下载与并行</strong>：并行下载 + 增量更新，自 v8+ 优化为“聪明缓存”，只下载变化部分。monorepo 原生支持（workspace 协议），通过过滤命令（如 pnpm -r）高效处理多包。</li><li><strong>monorepo 支持</strong>：最佳，原生高效，节省 70-80% 磁盘。</li></ul><p><strong>技术栈</strong>：Node.js 实现，但使用 Rust-like 的高效链接系统（实际是 JS + 文件系统优化）。</p><h4 id="3-Yarn-Berry（Yarn-v2-）"><a href="#3-Yarn-Berry（Yarn-v2-）" class="headerlink" title="3. Yarn Berry（Yarn v2+）"></a>3. Yarn Berry（Yarn v2+）</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：革命性 <strong>Plug’n’Play (PnP)</strong> 模式，默认<strong>完全消除 node_modules</strong>。依赖通过 .pnp.cjs（或 .pnp.js）文件映射（类似虚拟文件系统），运行时动态解析路径，而非物理目录。备选 nodeLinker: node-modules 模式回退到传统结构。</li><li><strong>锁文件</strong>：yarn.lock（v2+ 格式），包含完整依赖树、校验和和 ZIP 存档引用。</li><li><strong>缓存机制</strong>：项目级 .yarn/cache，存储 ZIP 压缩的包（可提交到 Git，实现“零安装”——clone 后直接运行）。支持“零安装”（zero-installs），CI/CD 无需重新下载。</li><li><strong>下载与并行</strong>：并行下载 + 增量缓存，自 v3+ 引入 Constraints（依赖规则检查）。monorepo 通过 Workspaces + Plug’n’Play 实现高效共享。</li><li><strong>monorepo 支持</strong>：优秀，支持 Constraints 和 Patch 协议，适合大型团队。</li></ul><p><strong>技术栈</strong>：Node.js 实现，但 PnP 使用自定义加载器（loader）拦截模块解析。</p><h4 id="4-Bun"><a href="#4-Bun" class="headerlink" title="4. Bun"></a>4. Bun</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：<strong>无 node_modules</strong>，所有包存储在全局单例缓存（~/.bun/install/cache），项目只生成极小的 .bun 文件夹（二进制锁文件）。使用<strong>极致压缩 + 硬链接</strong>，运行时直接从缓存加载（跳过解压）。兼容 npm 注册表，但内置 JSR（JavaScript Registry）支持。</li><li><strong>锁文件</strong>：bun.lockb，二进制格式（超小、超快解析）。</li><li><strong>缓存机制</strong>：全局缓存 + 内容哈希，安装时并行下载并验证哈希。支持“热缓存”（hot cache），CI 复用率近 100%。</li><li><strong>下载与并行</strong>：使用 Zig 语言编写的超快解析器（非 JS），HTTP/3 支持 + 原生并行。monorepo 自动识别，无需额外配置。</li><li><strong>monorepo 支持</strong>：优秀，极速安装，但生态仍在完善（2025 年已稳定）。</li></ul><p><strong>技术栈</strong>：Zig + JavaScriptCore（WebKit 引擎），非 Node.js 依赖，实现全栈（包管理 + bundler + 测试运行器）。</p><p>基于 pnpm 官方基准（2025-11-16 更新）、Bun 团队报告和社区测试，四个包管理器中<strong>Bun 整体最快，pnpm/Yarn Berry 在磁盘效率上领先，npm 最稳但最慢</strong>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Bun 支持 Linux（x64 和 arm64）和 macOS（x64 和 Apple Silicon）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用npm</span><br>npm install -g bun<br></code></pre></td></tr></table></figure><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bun upgrade<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>bun</code>命令行工具实现了测试运行器、脚本运行器和与 Node.js 兼容的包管理器。Bun 的内置工具明显比现有选项快，并且在现有 Node.js 项目中几乎不需要进行任何更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">bun <span class="hljs-built_in">test</span>                      <span class="hljs-comment"># 运行测试</span><br>bun run start                 <span class="hljs-comment"># 运行`package.json`中的`start`脚本</span><br>bun install &lt;pkg&gt;             <span class="hljs-comment"># 安装包</span><br>bunx cowsay <span class="hljs-string">'Hello, world!'</span>   <span class="hljs-comment"># 执行包</span><br>bun run index.tsx             <span class="hljs-comment"># 默认支持TS和JSX</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;因为快。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2025 年，Bun 作为一个「全能型」运行时 + 包管理器，在实际项目中对传统包管理器（npm/yarn/pnpm）确实有相当大的优势，很多人已经开始抛弃 npm/yarn/pnpm，转用 Bun 作为前端项目的包</summary>
      
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-21-canvas项目杂记</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/14933.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/14933.html</id>
    <published>2025-11-21T06:50:48.000Z</published>
    <updated>2025-11-23T09:36:28.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><del>分析</del></h2><p><del>要做的就是一个<strong>类 Canva / Figma 的在线图形绘板</strong>，完整需求优先级和覆盖范围如下：</del></p><div class="table-container"><table><thead><tr><th>优先级</th><th>功能模块</th><th>具体需求</th><th>是否必须</th><th>难度</th></tr></thead><tbody><tr><td>P0</td><td>基础渲染</td><td>矩形、圆形、三角形任意填充色、边框色、边框宽度、圆角、透明度</td><td>Yes</td><td>★☆</td></tr><tr><td>P0</td><td>图片支持</td><td>上传 png/jpg/webp，任意缩放、圆角、模糊、灰度、亮度调节、裁剪掩模</td><td>Yes</td><td>★★</td></tr><tr><td>P0</td><td>富文本</td><td>字体、字号、颜色、加粗、斜体、下划线、删除线、文本背景色、文字对齐、行距、局部样式支持</td><td>Yes</td><td>★★★★</td></tr><tr><td>P0</td><td>基本交互</td><td>单选、多选（框选 + Shift）、拖拽、删除、复制粘贴、缩放把手（8 个方向）、旋转把手</td><td>Yes</td><td>★★</td></tr><tr><td>P0</td><td>无限画布 + 缩放平移</td><td>Ctrl+滚轮缩放、空格拖拽平移、无限滚动</td><td>Yes</td><td>★☆</td></tr><tr><td>P0</td><td>数据持久化</td><td>自动 localStorage 保存、打开页面自动恢复</td><td>Yes</td><td>★☆</td></tr><tr><td>P1</td><td>高级交互</td><td>组合（Group）、解散组合、图层排序、辅助对齐线、吸附、旋转任意角度</td><td>Yes</td><td>★★★</td></tr><tr><td>P1</td><td>工具栏 &amp; 属性面板</td><td>顶部工具栏（切换文本/形状/图片模式）、右侧属性面板实时编辑属性</td><td>Yes</td><td>★★</td></tr><tr><td>P1</td><td>历史记录</td><td>Undo / Redo（支持跨会话）</td><td>Yes</td><td>★★</td></tr><tr><td>P1</td><td>性能要求</td><td>100 个复杂元素（图片+富文本）打开 &lt; 3s，拖拽 60fps 不闪烁</td><td>Yes</td><td>★★★★</td></tr><tr><td>P2</td><td>未来可扩展</td><td>实时协同编辑、离线编辑、模板库、导出 PNG/SVG/PDF、激光笔、箭头、自由画笔等</td><td>No</td><td>★★★★</td></tr></tbody></table></div><h1 id="架构方案"><a href="#架构方案" class="headerlink" title="架构方案"></a><del>架构方案</del></h1><ul><li><del><strong>渲染层</strong>：PixiJS (WebGL) 处理高性能图形渲染 + HTML DOM 处理文本编辑/输入框。</del></li><li><del><strong>状态管理</strong>：Zustand / Pinia (管理庞大的 JSON 画布数据)。</del></li><li><del><strong>逻辑层</strong>：自定义 Class 结构（如  Shape, Tool, History）实现面向对象编程。</del></li></ul><h3 id="二、项目设计要素"><a href="#二、项目设计要素" class="headerlink" title="二、项目设计要素"></a><del>二、项目设计要素</del></h3><div class="table-container"><table><thead><tr><th>设计维度</th><th>推荐技术方案</th><th></th></tr></thead><tbody><tr><td>1. 渲染引擎</td><td>PixiJS v8（WebGL） + HTMLText</td><td>WebGL 抗锯齿完美 + 高分屏不模糊；HTMLText 是目前唯一能轻松实现富文本局部样式的方案</td></tr><tr><td>2. 状态管理</td><td>Zustand（或 Jotai + signals）</td><td>轻量、响应式、支持中间件（持久化、历史栈）</td></tr><tr><td>3. 元素对象缓存</td><td>Map<string, Container=""> 永久缓存（一个元素一个 Container，永不 destroy）</string,></td><td>彻底解决闪烁、拖拽中断、光标丢失的根本方案</td></tr><tr><td>4. 历史栈</td><td>Command Pattern + structuredClone 快照（每操作记录 before/after）</td><td>简单可靠，支持跨页面 Undo</td></tr><tr><td>5. 选中/变换系统</td><td>单独的 SelectionManager + TransformHandles（旋转、缩放把手层也缓存）</td><td>tldraw/Figma 标配</td></tr><tr><td>6. 辅助对齐线</td><td>拖拽时实时遍历所有元素 bounds，差值 &lt; 5px 就吸附并画蓝线</td><td>提升专业感</td></tr><tr><td>7. 组合（Group）</td><td>元素加 groupId 字段；选中时绘制大虚线框；拖拽/缩放/旋转时整体应用矩阵变换</td><td>必须有，属于 P1 核心</td></tr><tr><td>8. 数据持久化</td><td>Zustand middleware persist + localForage（IndexedDB）</td><td>防止 localStorage 炸掉</td></tr><tr><td>9. 图片处理</td><td>Sprite + Graphics mask（圆角）+ BlurFilter + ColorMatrixFilter</td><td>PixiJS 原生支持</td></tr><tr><td>10. 架构分层</td><td>- store（纯数据） - rendering（Pixi 元素缓存 &amp; 更新） - interaction（拖拽、选中逻辑） - ui（React 面板）</td></tr></tbody></table></div><p><del>installed pixi.js@8.14.3</del><br><del>installed zustand@5.0.8</del><br><del>installed nanoid@5.1.6</del></p><p><del><strong>数据驱动视图”（Data-Driven View）</strong>  模式，采用了  <strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>  的三层分离架构</del></p><p><del>这种架构的核心理念是：<strong>PixiJS 实例不保存“业务状态”，它只是 Zustand 数据的“投影”</strong></del></p><p><del class='item-img' data-src='Pasted%20image%2020251121155817.png'><img src="Pasted%20image%2020251121155817.png" alt=""></del></p><p><del>其中，</del></p><ul><li><del>React 只负责 UI 和事件入口</del></li><li><del>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）</del></li><li><del>PixiJS 层只做“渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建</del></li><li><del>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</del></li></ul><h3 id="三层架构详解"><a href="#三层架构详解" class="headerlink" title="三层架构详解"></a><del>三层架构详解</del></h3><h4 id="第一层：数据层-The-Source-of-Truth-canvasStore-ts"><a href="#第一层：数据层-The-Source-of-Truth-canvasStore-ts" class="headerlink" title="第一层：数据层 (The Source of Truth) - canvasStore.ts"></a><del>第一层：数据层 (The Source of Truth) - canvasStore.ts</del></h4><p><del>这是整个应用的大脑。</del></p><ul><li><del><strong>职责</strong>：只存储纯 JSON 数据（Serializable），不包含任何 UI 实例或 Pixi 对象。</del></li><li><del><strong>存储内容</strong>：</del><ul><li><del>elements: 一个 Map 对象（Record<id, Element="">），存储所有矩形、圆形的坐标、颜色等。</id,></del></li><li><del>selectedIds: 当前选中的 ID 列表。</del></li><li><del>tool: 当前使用的工具。</del></li></ul></li><li><del><strong>特点</strong>：</del><ul><li><del><strong>单一数据源</strong>：画布上显示什么，完全由这里的数据决定。</del></li><li><del><strong>无副作用</strong>：这里的 Action 只修改数据，不直接操作 DOM 或 Canvas。</del></li></ul></li></ul><h4 id="第二层：适配层-The-Bridge-StageManager-ts"><a href="#第二层：适配层-The-Bridge-StageManager-ts" class="headerlink" title="第二层：适配层 (The Bridge) - StageManager.ts"></a><del>第二层：适配层 (The Bridge) - StageManager.ts</del></h4><p><del>这是连接 React/Zustand 和 PixiJS 的胶水层，也是架构中最复杂的部分。</del></p><ul><li><del><strong>职责</strong>：将“声明式”的数据（Zustand）转换为“命令式”的 Pixi 调用。</del></li><li><del><strong>核心机制 - 增量更新 (Diffing)</strong>：</del><ul><li><del>它维护了一个  spriteMap (Map<id, PIXI.Graphics="">)。</id,></del></li><li><del><strong>订阅 (Subscribe)</strong>：它监听 Store 的变化。</del></li><li><del><strong>同步 (Sync/Render Loop)</strong>：</del><ul><li><del><strong>Create</strong>: Store 有 ID，Map 里没有 -&gt; new PIXI.Graphics()。</del></li><li><del><strong>Update</strong>: Store 有，Map 里也有 -&gt; 更新  x, y, width, color。</del></li><li><del><strong>Delete</strong>: Store 没有，Map 里有 -&gt; destroy()。</del></li></ul></li></ul></li><li><del><strong>事件转换</strong>：</del><ul><li><del>它监听 Pixi 的  pointerdown/move/up  事件，将屏幕坐标转换为逻辑坐标，然后调用 Store 的 Action。</del></li></ul></li></ul><h4 id="第三层：视图层-The-Container-Canvas-tsx"><a href="#第三层：视图层-The-Container-Canvas-tsx" class="headerlink" title="第三层：视图层 (The Container) - Canvas.tsx"></a><del>第三层：视图层 (The Container) - Canvas.tsx</del></h4><p><del>这是 React 组件层。</del></p><ul><li><del><strong>职责</strong>：</del><ul><li><del>提供  div  容器供 Pixi 挂载。</del></li><li><del>渲染 HTML UI（工具栏、属性面板）。</del></li><li><del>生命周期管理：组件 Mount 时初始化  StageManager，Unmount 时销毁。</del></li></ul></li></ul><p><del>—-</del></p><h3 id="3-关键数据流转-Data-Flow"><a href="#3-关键数据流转-Data-Flow" class="headerlink" title="3. 关键数据流转 (Data Flow)"></a><del>3. 关键数据流转 (Data Flow)</del></h3><p><del>让我们以  <strong>“拖拽矩形移动”</strong>  为例，看数据如何在架构中流转：</del></p><p><del><strong>Input (输入)</strong>:</del></p><ul><li><del>用户在画布上按住矩形并移动鼠标。</del></li><li><del>StageManager  的  onPointerMove  被触发。</del></li></ul><p><del><strong>Logic (逻辑处理)</strong>:</del></p><ul><li><del>StageManager  计算鼠标的偏移量  (dx, dy)。</del></li><li><del>它<strong>不直接修改</strong> Pixi 图形的  graphics.x (这是关键！)。</del></li><li><del>它调用  store.updateElement(id, { x: newX, y: newY })。</del></li></ul><p><del><strong>State Update (状态更新)</strong>:</del></p><ul><li><del>Zustand Store 更新内部的 JSON 数据。</del></li><li><del>Zustand 触发订阅回调 (subscribe)。</del></li></ul><p><del><strong>Render Sync (渲染同步)</strong>:</del></p><ul><li><del>StageManager  的  render  方法被调用。</del></li><li><del>它从  spriteMap  找到对应的 Pixi 实例。</del></li><li><del>执行  graphic.position.set(newX, newY)。</del></li><li><del>PixiJS 在下一个  requestAnimationFrame  自动重绘 Canvas。</del></li></ul><p><del>—-</del></p><h3 id="4-为什么选择这种架构？"><a href="#4-为什么选择这种架构？" class="headerlink" title="4. 为什么选择这种架构？"></a><del>4. 为什么选择这种架构？</del></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><del>优点：</del></h4><p><del><strong>解耦 (Decoupling)</strong>：渲染引擎可以随时替换（比如换成 Konva 或原生 Canvas），只需要重写  StageManager，数据层和 UI 层不需要动。</del></p><p><del><strong>协同编辑 (Collaboration) 友好</strong>：</del></p><ul><li><del>如果要实现多入协同，只需要监听 WebSocket 消息，然后更新 Zustand Store。StageManager  会自动把队友的操作画出来，无需写额外的同步绘图逻辑。</del><br><del><strong>撤销/重做 (Undo/Redo) 容易</strong>：</del></li><li><del>因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照（或 Patch）即可。</del><br><del><strong>序列化/反序列化</strong>：</del></li><li><del>保存项目只需  JSON.stringify(store.elements)。</del></li></ul><h4 id="潜在挑战（及优化方案）："><a href="#潜在挑战（及优化方案）：" class="headerlink" title="潜在挑战（及优化方案）："></a><del>潜在挑战（及优化方案）：</del></h4><p><del><strong>性能瓶颈</strong>：</del></p><ul><li><del>问题：高频触发  Store Update -&gt; Diff  循环可能在元素极多时（&gt;2000 个）产生开销。</del></li><li><del>优化：对于拖拽这种 60FPS 的操作，可以引入“临时层” (Transient State)。即拖拽时直接修改 Pixi 对象，鼠标松开时再同步到 Store。</del><br><del><strong>复杂性</strong>：</del></li><li><del>相比直接用 Canvas API 画图，这种架构代码量更大，需要维护 ID 映射和 Diff 逻辑。</del></li></ul><p><del>feat(canvas): 重构画布实现，应项目要求，删除了基于tldraw的实现转而选择PixiJS 库重构以进行渲染操作，基于Zustand 进行状态管理。新增的文件中canvasStore.ts主要负责维护整个画布项目的全局可序列化状态，是渲染画布系统中唯一数据来源。Pixi_stageManager.ts 负责将声明式数据（Zustand）实时、高性能地映射为命令式渲染实例（PixiJS），并处理所有用户交互的计算与反馈。canvas下的index.ts最轻量的一层，仅负责生命周期管理与组件组装。三层数据驱动架构详情可见文档</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;&lt;del&gt;分析&lt;/del&gt;&lt;/h2&gt;&lt;p&gt;&lt;del&gt;要做的就是一个&lt;strong&gt;类 Canva / Figma 的在线图形绘板&lt;/strong&gt;，完整需求优先</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-19-重拾编程语言设计与计科相关概念</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/29484.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/29484.html</id>
    <published>2025-11-19T03:06:20.000Z</published>
    <updated>2025-11-19T03:22:30.204Z</updated>
    
    <content type="html"><![CDATA[<p>计算机类专业结果这些都得自己学，整理一套编程语言设计与计算机科学核心概念集，日后开坑学习，博客狠狠写，知识学爆</p><h2 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>指针（Pointer）</li><li>引用（Reference）</li><li>堆（Heap）</li><li>栈（Stack）</li><li>内存布局（Memory Layout）</li><li>垃圾回收（Garbage Collection）</li><li>内存泄漏（Memory Leak）</li><li>悬挂指针/引用（Dangling Pointer/Reference）</li><li>内存序（Memory Ordering）</li><li>写时复制（Copy-on-Write）</li><li>内存映射文件（Memory-mapped Files）</li><li>缓存一致性协议（Cache Coherence Protocol）</li><li>虚拟内存机制（Virtual Memory）</li><li>内存屏障（Memory Barrier）</li><li>内存对齐（Memory Alignment）</li><li>内存分配器（Memory Allocator）</li><li>内存池（Memory Pool）</li><li>引用计数（Reference Counting）</li><li>弱引用（Weak Reference）</li><li>循环引用（Circular Reference）</li><li>内存碎片（Memory Fragmentation）：包括内部碎片和外部碎片</li><li>分页与分段（Paging and Segmentation）：虚拟内存管理技术</li><li>垃圾回收算法：如标记-清除、复制、标记-整理等具体算法</li><li>内存管理单元（Memory Management Unit）</li><li>内存保护（Memory Protection）</li><li>内存访问（Memory Access）</li></ul><h3 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h3><ul><li>自动存储期（Automatic Storage Duration）</li><li>静态存储期（Static Storage Duration）</li><li>动态存储期（Dynamic Storage Duration）</li><li>线程存储期（Thread Storage Duration）</li><li>寄存器变量（Register Variable）</li></ul><h2 id="二、程序执行模型"><a href="#二、程序执行模型" class="headerlink" title="二、程序执行模型"></a>二、程序执行模型</h2><h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><ul><li>调用栈（Call Stack）</li><li>栈帧（Stack Frame）</li><li>调用约定（Calling Convention）</li><li>参数传递（Parameter Passing）</li><li>尾调用优化（Tail Call Optimization）</li><li>尾递归（Tail Recursion）</li><li>Trampoline 机制</li><li>Thunk：延迟计算的代码块</li><li>Thunk 函数：用于实现惰性求值的技术</li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li>作用域（Scope）</li><li>词法作用域（Lexical Scope）</li><li>动态作用域（Dynamic Scope）</li><li>作用域链（Scope Chain）</li><li>闭包（Closure）</li><li>执行上下文（Execution Context）</li><li>变量环境（Variable Environment）</li><li>词法环境（Lexical Environment）</li><li>延续（Continuation）</li><li>协程（Coroutine）</li><li>生成器（Generator）</li></ul><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><ul><li>事件循环（Event Loop）</li><li>计算器模型（Evaluator Model）</li><li>消息传递接口（Message Passing）</li><li>Actor 模型</li><li>CSP（Communicating Sequential Processes）</li><li>控制流图（Control Flow Graph）</li><li>数据流分析（Data Flow Analysis）</li></ul><h2 id="三、并发与并行"><a href="#三、并发与并行" class="headerlink" title="三、并发与并行"></a>三、并发与并行</h2><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><ul><li>并发（Concurrency）</li><li>并行（Parallelism）</li><li>绿色线程（Green Threads）</li><li>内核线程（Kernel Threads）</li><li>用户态线程（User-level Threads）</li><li>线程池（Thread Pool）</li><li>工作窃取（Work Stealing）</li><li>屏障（Barrier）：同步原语</li><li>fork-join 模型：并行任务执行模型</li><li>数据竞争（Data Race）：并发访问共享数据的问题</li></ul><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><ul><li>原子操作（Atomic Operations）</li><li>比较并交换（Compare-and-Swap）</li><li>锁（Lock）</li><li>自旋锁（Spinlock）</li><li>互斥锁（Mutex）</li><li>读写锁（Read-Write Lock）</li><li>信号量（Semaphore）</li><li>条件变量（Condition Variable）</li><li>无锁编程（Lock-free Programming）</li><li>内存模型（Memory Model）</li><li>顺序一致性（Sequential Consistency）</li><li>释放获取语义（Release-Acquire Semantics）</li></ul><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><ul><li>Promise/Future</li><li>async/await</li><li>响应式编程（Reactive Programming）</li><li>数据并行（Data Parallelism）</li><li>任务并行（Task Parallelism）</li><li>事务内存（Transactional Memory）</li></ul><h2 id="四、类型系统"><a href="#四、类型系统" class="headerlink" title="四、类型系统"></a>四、类型系统</h2><h3 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h3><ul><li>静态类型（Static Typing）</li><li>动态类型（Dynamic Typing）</li><li>强类型（Strong Typing）</li><li>弱类型（Weak Typing）</li><li>基本数据类型（Primitive Data Types）</li><li>复合数据类型（Composite Data Types）</li><li>引用类型（Reference Types）</li><li>值类型（Value Types）</li><li>类型推导（Type Inference）</li><li>类型检查（Type Checking）</li><li>类型擦除（Type Erasure）</li><li>类型转换（Type Casting）</li><li>类型别名（Type Alias）</li><li>类型注解（Type Annotation）</li><li>泛型（Generics）</li><li>类型参数（Type Parameter）</li><li>类型变量（Type Variable）</li><li>类型约束（Type Constraint）</li><li>类型构造器（Type Constructor）</li><li>类型等价（Type Equality）</li><li>类型子类型（Type Subtyping）</li><li>类型上界（Type Upper Bound）</li><li>类型下界（Type Lower Bound）</li><li>类型推断（Type Inference）</li><li>类型检查（Type Checking）</li><li>子类型（Subtyping）：类型之间的关系</li><li>型变（Covariance/Contravariance）：更详细的变型规则说明</li><li>不透明类型（Opaque Types）：隐藏实现细节的类型</li></ul><h3 id="高级类型概念"><a href="#高级类型概念" class="headerlink" title="高级类型概念"></a>高级类型概念</h3><ul><li>行多态（Row Polymorphism）</li><li>存在类型（Existential Types）</li><li>高阶类型（Higher-Kinded Types）</li><li>依赖类型（Dependent Types）</li><li>渐进类型（Gradual Typing）</li><li>类型类（Type Classes）</li><li>泛型（Generics）</li><li>变型（Variance）：协变、逆变、不变</li><li>类型安全（Type Safety）</li><li>类型擦除（Type Erasure）</li><li>单态化（Monomorphization）</li></ul><h2 id="五、函数与抽象"><a href="#五、函数与抽象" class="headerlink" title="五、函数与抽象"></a>五、函数与抽象</h2><h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><ul><li>高阶函数（Higher-Order Function）</li><li>回调函数（Callback）</li><li>递归（Recursion）</li><li>匿名函数（Anonymous Function）</li><li>Lambda 表达式</li><li>柯里化（Currying）</li><li>部分应用（Partial Application）</li><li>函数组合（Function Composition）</li></ul><h3 id="抽象机制"><a href="#抽象机制" class="headerlink" title="抽象机制"></a>抽象机制</h3><ul><li>控制抽象（Control Abstraction）</li><li>数据抽象（Data Abstraction）</li><li>迭代器（Iterator）</li><li>流处理（Stream Processing）</li><li>声明式编程（Declarative Programming）</li><li>函子（Functor）：映射结构的抽象概念</li><li>单子（Monad）：具有绑定操作的计算容器</li></ul><h2 id="六、面向对象编程"><a href="#六、面向对象编程" class="headerlink" title="六、面向对象编程"></a>六、面向对象编程</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>类（Class）</li><li>对象（Object）</li><li>封装（Encapsulation）</li><li>继承（Inheritance）</li><li>多态（Polymorphism）</li><li>接口（Interface）</li><li>抽象类（Abstract Class）</li><li>混入（Mixin）</li><li>特质（Trait）</li></ul><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><ul><li>虚函数表（Virtual Method Table）</li><li>方法解析顺序（Method Resolution Order）</li><li>对象布局（Object Layout）</li><li>多重继承（Multiple Inheritance）</li><li>虚继承（Virtual Inheritance）</li><li>原型继承（Prototypal Inheritance）</li><li>消息传递（Message Passing）：对象间的通信机制</li><li>委托（Delegation）：替代继承的复用机制</li></ul><h2 id="七、元编程与反射"><a href="#七、元编程与反射" class="headerlink" title="七、元编程与反射"></a>七、元编程与反射</h2><h3 id="元编程技术"><a href="#元编程技术" class="headerlink" title="元编程技术"></a>元编程技术</h3><ul><li>反射（Reflection）</li><li>内省（Introspection）</li><li>宏系统（Macro System）</li><li>卫生宏（Hygienic Macro）</li><li>语法宏（Syntax Macro）</li><li>过程宏（Procedural Macro）</li><li>模板元编程（Template Metaprogramming）</li><li>注解处理（Annotation Processing）</li><li>属性导向编程（Attribute-Oriented Programming）</li></ul><h3 id="运行时元编程"><a href="#运行时元编程" class="headerlink" title="运行时元编程"></a>运行时元编程</h3><ul><li>动态代理（Dynamic Proxy）</li><li>方法缺失处理（Method Missing）</li><li>代码生成（Code Generation）</li><li>AST 操作（Abstract Syntax Tree Manipulation）</li></ul><h2 id="八、编译与解释"><a href="#八、编译与解释" class="headerlink" title="八、编译与解释"></a>八、编译与解释</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li>词法分析（Lexical Analysis）</li><li>语法分析（Syntax Analysis）</li><li>语义分析（Semantic Analysis）</li><li>中间代码生成（Intermediate Code Generation）</li><li>代码优化（Code Optimization）</li><li>目标代码生成（Target Code Generation）</li><li>编译器架构（Compiler Architecture）</li><li>编译器设计（Compiler Design）</li><li>编译器实现（Compiler Implementation）</li><li>链接时优化（Link Time Optimization, LTO）：跨模块优化技术</li><li>Profile-Guided Optimization (PGO)：基于运行时信息的优化</li></ul><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><ul><li>解释器（Interpreter）</li><li>字节码（Bytecode）</li><li>即时编译（Just-In-Time Compilation）</li><li>抽象语法树（Abstract Syntax Tree, AST）</li><li>单态化（Monomorphization）</li><li>类型擦除（Type Erasure）</li><li>中间表示（Intermediate Representation）</li><li>SSA 形式（Static Single Assignment）</li></ul><h2 id="九、系统接口"><a href="#九、系统接口" class="headerlink" title="九、系统接口"></a>九、系统接口</h2><h3 id="操作系统交互"><a href="#操作系统交互" class="headerlink" title="操作系统交互"></a>操作系统交互</h3><ul><li>系统调用（System Call）</li><li>文件描述符（File Descriptor）</li><li>ABI（Application Binary Interface）</li><li>系统 V ABI</li><li>TLS（Thread Local Storage）</li><li>信号处理（Signal Handling）</li></ul><h2 id="十、异常与错误处理"><a href="#十、异常与错误处理" class="headerlink" title="十、异常与错误处理"></a>十、异常与错误处理</h2><h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><ul><li>异常处理（Exception Handling）</li><li>返回值错误（Error Return Values）</li><li>Result 类型</li><li>可选值（Option/Maybe）</li><li>断言（Assertion）</li><li>契约编程（Design by Contract）</li></ul><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><ul><li>RAII（Resource Acquisition Is Initialization）</li><li>所有权系统（Ownership System）</li><li>借用检查（Borrow Checking）</li><li>生命周期（Lifetime）</li><li>析构函数（Destructor）</li><li>finally 块</li></ul><h2 id="十一、模块化与代码组织"><a href="#十一、模块化与代码组织" class="headerlink" title="十一、模块化与代码组织"></a>十一、模块化与代码组织</h2><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><ul><li>模块化（Modularity）</li><li>命名空间（Namespace）</li><li>包管理（Package Management）</li><li>依赖注入（Dependency Injection）</li><li>接口隔离（Interface Segregation）</li></ul><h3 id="链接与加载"><a href="#链接与加载" class="headerlink" title="链接与加载"></a>链接与加载</h3><ul><li>静态链接（Static Linking）</li><li>动态链接（Dynamic Linking）</li><li>符号解析（Symbol Resolution）</li><li>重定位（Relocation）</li><li>名称修饰（Name Mangling）</li></ul><h2 id="十二、性能优化"><a href="#十二、性能优化" class="headerlink" title="十二、性能优化"></a>十二、性能优化</h2><h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><ul><li>内联优化（Inlining）</li><li>常量传播（Constant Propagation）</li><li>死代码消除（Dead Code Elimination）</li><li>循环优化（Loop Optimization）</li><li>向量化（Vectorization）</li><li>分支目标缓冲（Branch Target Buffer）：提高分支预测准确性的硬件机制</li><li>指令级并行（Instruction Level Parallelism）：CPU 级别的并行执行</li></ul><h3 id="运行时优化"><a href="#运行时优化" class="headerlink" title="运行时优化"></a>运行时优化</h3><ul><li>内联缓存（Inline Cache）</li><li>方法缓存（Method Cache）</li><li>逃逸分析（Escape Analysis）</li><li>栈上替换（On-Stack Replacement）</li><li>热点代码检测（Hotspot Detection）</li></ul><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><ul><li>缓存局部性（Cache Locality）</li><li>分支预测（Branch Prediction）</li><li>流水线冒险（Pipeline Hazard）</li><li>预取（Prefetching）</li><li>SIMD（Single Instruction Multiple Data）</li></ul><h2 id="十三、形式化方法与理论"><a href="#十三、形式化方法与理论" class="headerlink" title="十三、形式化方法与理论"></a>十三、形式化方法与理论</h2><h3 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h3><ul><li>霍尔逻辑（Hoare Logic）</li><li>指称语义（Denotational Semantics）</li><li>操作语义（Operational Semantics）</li><li>公理语义（Axiomatic Semantics）</li><li>进展定理（Progress Theorem）</li><li>保持定理（Preservation Theorem）</li></ul><h3 id="计算理论"><a href="#计算理论" class="headerlink" title="计算理论"></a>计算理论</h3><ul><li>λ 演算（Lambda Calculus）</li><li>组合子逻辑（Combinatory Logic）</li><li>图灵完备性（Turing Completeness）</li><li>邱奇-图灵论题（Church-Turing Thesis）</li><li>停机问题（Halting Problem）</li></ul><h2 id="十四、现代语言特性"><a href="#十四、现代语言特性" class="headerlink" title="十四、现代语言特性"></a>十四、现代语言特性</h2><h3 id="语言设计趋势"><a href="#语言设计趋势" class="headerlink" title="语言设计趋势"></a>语言设计趋势</h3><ul><li>空安全（Null Safety）</li><li>模式匹配（Pattern Matching）</li><li>异步/等待（Async/Await）</li><li>记录类型（Record Types）</li><li>代数数据类型（Algebraic Data Types）</li><li>效应系统（Effect System）</li><li>资源安全（Resource Safety）</li><li>所有权与借用（Ownership and Borrowing）：Rust 中的内存安全机制</li><li>异构编程（Heterogeneous Programming）：利用多种计算设备的编程模型</li></ul><h3 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h3><ul><li>表达式问题（Expression Problem）</li><li>访问者模式（Visitor Pattern）</li><li>模式匹配解构</li></ul><h2 id="十五、编程范式"><a href="#十五、编程范式" class="headerlink" title="十五、编程范式"></a>十五、编程范式</h2><h3 id="主要范式"><a href="#主要范式" class="headerlink" title="主要范式"></a>主要范式</h3><ul><li>命令式编程（Imperative Programming）</li><li>声明式编程（Declarative Programming）</li><li>函数式编程（Functional Programming）</li><li>逻辑编程（Logic Programming）</li><li>面向对象编程（Object-Oriented Programming）</li><li>面向方面编程（Aspect-Oriented Programming）</li></ul><h3 id="混合范式"><a href="#混合范式" class="headerlink" title="混合范式"></a>混合范式</h3><ul><li>多范式编程（Multi-paradigm Programming）</li><li>函数响应式编程（Functional Reactive Programming）</li><li>元对象协议（Metaobject Protocol）</li></ul><h2 id="十六、软件开发基础"><a href="#十六、软件开发基础" class="headerlink" title="十六、软件开发基础"></a>十六、软件开发基础</h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>表达式与语句（Expressions vs Statements）</li><li>控制流（Control Flow）</li><li>数据结构（Data Structures）</li><li>算法（Algorithms）</li><li>复杂度分析（Complexity Analysis）</li><li>设计模式（Design Patterns）：常见问题的标准解决方案</li><li>SOLID 原则：面向对象设计的五个基本原则</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机类专业结果这些都得自己学，整理一套编程语言设计与计算机科学核心概念集，日后开坑学习，博客狠狠写，知识学爆&lt;/p&gt;
&lt;h2 id=&quot;一、内存管理&quot;&gt;&lt;a href=&quot;#一、内存管理&quot; class=&quot;headerlink&quot; title=&quot;一、内存管理&quot;&gt;&lt;/a&gt;一、内存管</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="日志" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
