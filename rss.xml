<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes|笔记站</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2026-01-03T13:57:28.857Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2026-01-03-机器学习论文实训草稿</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/38065.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/38065.html</id>
    <published>2026-01-03T06:10:49.000Z</published>
    <updated>2026-01-03T13:57:28.857Z</updated>
    
    <content type="html"><![CDATA[<p>汽车保险领域面临的日益严峻的欺诈风险使行业经济损失巨大。为有效应对此类问题，本研究运用传统机器学习技术构建欺诈识别系统，提供了数据处理、特征提取以及模型构建的完整流程，采用汽车保险理赔数据集，进行相关实验，重点考察随机森林算法与其他分类器的性能对比，包括数据清洗、特征选择和不平衡处理。通过交叉验证和指标评估，结果显示优化后的随机森林模型在 AUC 和召回率方面表现出色。该研究验证了传统算法在实际场景中的可靠性，并为保险企业风险管理提供实用建议。</p><p>}</p><p>% 中文关键词(每个关键词之间用”；”分开,最后一个关键词不打标点符号。)</p><p>\ckeywords{汽车保险欺诈；随机森林算法；传统机器学习；数据不平衡；特征提取；性能评估}</p><hr><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>保险业通过风险聚合与转移机制为社会经济活动提供安全保障，在全球经济运行中扮演着至关重要的角色。其庞大的资金池更是资本市场长期资本的重要来源之一 <strong>(Barry &amp; Charpentier, 2020)</strong>。根据经济合作与发展组织的报告，保险业的稳定性直接关系到全球金融系统的韧性 <strong>(OECD, 2023)</strong>。在财产保险领域，汽车保险覆盖面最为广泛并与日常生活紧密联系，构成了该领域的核心业务板块，同时其受到日益猖獗的保险欺诈行为的严峻挑战。</p><p>汽车保险欺诈已成为一个全球性的顽疾，对行业的财务健康和社会的诚信体系造成持续性的损害。欺诈行为导致保险公司支付了本不应承担的赔款，这些巨大的“渗漏”最终会通过提高保费的形式转嫁给所有诚实投保人，破坏了保险的公平性原则 <strong>(Viaene &amp; Dedene, 2004)</strong>。据美国反保险欺诈联盟（Coalition Against Insurance Fraud）的最新报告，保险欺诈每年给美国造成的损失已超过 3000 亿美元，其中车险领域是重灾区 <strong>(CAIF, 2022)</strong>。欺诈的成因复杂，一方面，信息不对称使得保险公司难以在承保和理赔环节完全掌握投保人的真实风险与行为 <strong>(Cohen &amp; Siegelman, 2010)</strong>；另一方面，技术的进步，特别是数字化理赔流程的普及，在提升效率的同时，也为新型、更隐蔽的欺诈手段提供了可乘之机 <strong>(Severino &amp; Peng, 2021)</strong>。这不仅侵蚀了保险公司的承保利润，还可能导致定价模型失真，扭曲风险信号，长期而言将削弱保险的风险分担功能和社会效益。</p><p>从广义上讲，保险欺诈是指任何以非法获取保险金为目的的故意行为。根据欺诈主体的不同，可分为保单持有人欺诈、第三方欺诈以及内部人员欺诈等 <strong>(Derrig, 2002)</strong>。鉴于数据的可获得性与研究的可操作性，本文的研究焦点将集中于<strong>汽车理赔欺诈</strong>，即保单持有人或相关方在理赔环节，通过故意制造事故、夸大损失、伪造单据等手段骗取保险赔偿金的行为。这类欺诈是车险欺诈中最常见的形式，拥有相对丰富的公开研究数据基础，是应用数据驱动方法进行自动化检测的主要战场 <strong>(Bhattacharyya et al., 2011)</strong>。</p><p>为应对这类欺诈威胁，保险公司正从依赖专家规则和人工审核，转向基于数据挖掘与机器学习（ML）的自动化检测系统。传统的规则引擎虽然解释性强，但难以捕捉复杂的非线性关系和新型欺诈模式。机器学习，特别是监督学习算法，能够从历史理赔数据中自动学习欺诈模式，展现出巨大潜力。在众多机器学习方法中，集成学习因其卓越的预测性能和鲁棒性而备受关注。以随机森林（Random Forest）为代表的集成算法，通过构建多棵决策树并综合其结果，能有效缓解单棵树的过拟合问题，对高维特征和非线性关系有良好的处理能力 <strong>(Breiman, 2001; Polikar, 2012)</strong>。更重要的是，保险欺诈数据天然具有高度不平衡性（正常理赔远多于欺诈理赔），而随机森林通过自助采样（Bootstrap sampling）和随机特征子空间选择，能在不均衡数据上构建多样化的基分类器，从而在一定程度上提升对少数类（欺诈）样本的识别能力 <strong>(Xia et al., 2023; Phua et al., 2010)</strong>。</p><p>尽管机器学习在欺诈检测中的应用已取得丰硕成果，但现有研究仍存在一些有待深化之处。许多研究侧重于单一高级分类器（如 XGBoost、深度神经网络）的性能比拼，而相对忽视了<strong>数据预处理阶段与分类模型的系统性整合与优化</strong>。特征工程、处理类别不平衡的重采样技术（如 SMOTE、ADASYN）以及特征选择，对于最终模型性能的影响至关重要，有时甚至不亚于分类器本身的选择 <strong>(Wang et al., 2021; Chawla et al., 2002)</strong>。此外，在<strong>真实的汽车保险公开数据集</strong>上，对包含预处理流程在内的多种传统机器学习算法进行端到端的、公平的对比实验研究相对有限，特别是深入探讨不同预处理技术如何与不同算法交互以提升欺诈检测性能的研究尚不充分 <strong>(He &amp; Garcia, 2009; Gomes et al., 2021)</strong>。</p><p>本文旨在探索并验证一套结合预处理技术与经典机器学习算法的汽车保险欺诈检测框架。具体而言，本研究将在公开的汽车保险理赔数据集上，以随机森林算法为核心检测模型，系统性地集成多种特征编码、不平衡数据处理（如过采样与欠采样）及特征选择方法，构建一个完整的分析管道。通过设计详尽的对比实验，本文将评估该集成框架相对于单一模型及其他主流机器学习算法（如逻辑回归、支持向量机、XGBoost）在欺诈检测准确率、召回率、F1 分数等关键指标上的性能表现，从而为构建高效、实用的车险欺诈检测系统提供实证依据。主要要点如下：</p><ol><li><strong>提出一个基于机器学习的欺诈检测分析框架</strong>：将数据处理、特征工程、不平衡学习、特征选择与随机森林分类器进行有机整合，形成了一个可复现、可评估的完整机器学习工作流，强调了预处理环节在模型构建中的基础性地位。</li><li><strong>进行了相关的算法对比实验</strong>：在公开基准数据集上，对包括随机森林在内的多种传统机器学习算法，在统一的预处理标准和评估指标下进行了性能对比与分析，为算法选择提供了实证参考。</li><li><strong>深入探讨了不平衡数据处理策略的有效性</strong>：实证检验了多种重采样技术在缓解保险欺诈数据类不平衡问题上的作用，并分析了其与不同分类器结合时的性能变化规律。</li><li><strong>提供了结构化的方法学实现</strong>：研究过程注重方法论的清晰描述与代码的结构化，确保了实验的可复现性，为后续研究者提供了可直接借鉴的技术路径和比较基线。</li></ol><p>本文结构安排如下：第 2 章将对保险欺诈检测，特别是基于机器学习的检测方法的相关文献进行综述；第 3 章将详细阐述本文所采用的研究方法，包括数据集描述、预处理技术、特征工程、使用的机器学习算法以及实验设计；第 4 章将展示并分析实验结果，对不同模型和策略的性能进行对比与讨论；第 5 章将总结全文，概括主要研究发现，指出本研究的局限性，并对未来研究方向提出展望。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>本章旨在回顾保险欺诈检测方法的技术演进，梳理传统机器学习算法在该领域的应用现状、优势与挑战，明确本研究的理论背景与创新点。</p><h2 id="2-1-欺诈检测方法的演进"><a href="#2-1-欺诈检测方法的演进" class="headerlink" title="2.1 欺诈检测方法的演进"></a>2.1 欺诈检测方法的演进</h2><p>保险欺诈检测的演进与信息技术的发展脉络高度吻合。早期的检测完全依赖具有丰富经验的核保员，主观性极强。随后，基于规则的专家系统（Expert Systems）通过将反欺诈知识编码为“IF-THEN”逻辑，实现了初步自动化 <strong>(Bentley, 2000)</strong>。然而，该系统难以应对高度协同且隐蔽的新型欺诈模式。</p><p>20 世纪 90 年代末，统计方法被引入该领域。逻辑回归（Logistic Regression）因其能够量化风险概率而成为早期的主流工具 <strong>(Brockett et al., 2002)</strong>。进入 21 世纪后，数据挖掘与机器学习范式确立，研究焦点从简单的线性模型转向能够处理高维、非线性关系的复杂模型。现代欺诈检测已形成以监督学习为主、异常检测与图神经网络为辅的多维检测体系 <strong>(Phua et al., 2010; West &amp; Bhattacharya, 2016)</strong>。</p><h2 id="2-2-传统机器学习算法在保险欺诈检测中的应用"><a href="#2-2-传统机器学习算法在保险欺诈检测中的应用" class="headerlink" title="2.2 传统机器学习算法在保险欺诈检测中的应用"></a>2.2 传统机器学习算法在保险欺诈检测中的应用</h2><p>在众多机器学习算法中，传统（或经典）算法因其计算效率高、在中小规模数据集上表现稳健且易于部署，至今仍是行业应用的核心。</p><p>单一分类器如决策树（DT）、支持向量机（SVM）和朴素贝叶斯在早期研究中应用广泛。决策树因其天然的解释性被青睐，但单棵树极易产生过拟合 <strong>(Baesens et al., 2015)</strong>。SVM 通过核函数处理高维非线性空间，但在大规模数据集上的训练开销较大。</p><p>为克服单一模型的局限，集成学习（Ensemble Learning）成为该领域的最优解。<strong>随机森林（Random Forest, RF）</strong> 通过自助采样（Bootstrap）和随机特征选择构建决策树森林，能显著提升模型的泛化能力和抗噪性能 <strong>(Breiman, 2001; Sahin et al., 2013)</strong>。<strong>Itri 等人 (2019)</strong> 在汽车保险数据集上的对比实验表明，随机森林在 AUC 和准确率上始终处于领先地位。此外，以 <strong>XGBoost (Chen &amp; Guestrin, 2016)</strong> 和 <strong>LightGBM (Ke et al., 2017)</strong> 为代表的梯度提升框架，通过迭代修正残差，进一步刷新了欺诈检测的精度上限。<strong>Jovanovic 等人 (2022)</strong> 的研究证实，经过精细参数调优的提升树模型在处理车险理赔数据时，其召回率（Recall）显著优于传统线性模型。</p><h2 id="2-3-多模型比较研究与算法选择策略"><a href="#2-3-多模型比较研究与算法选择策略" class="headerlink" title="2.3 多模型比较研究与算法选择策略"></a>2.3 多模型比较研究与算法选择策略</h2><p>由于保险欺诈模式在不同地区和产品线之间存在显著差异，不存在“一劳永逸”的通用算法，因此多模型对比（Benchmarking）成为该领域实证研究的标准范式 <strong>(Lessmann et al., 2015)</strong>。</p><p>多数实证研究（如 <strong>Nordin et al., 2024</strong>）表明，基于树的集成方法（RF, XGBoost, CatBoost）在整体性能上优于逻辑回归和感知器。由于欺诈检测是一个典型的非平衡代价问题，评估指标已从单纯的准确率转向更具代表性的 AUC-ROC、F1 分数以及在特定误报率下的召回率 <strong>(Dal Pozzolo et al., 2015)</strong>。然而，目前的对比研究大多聚焦于算法本身，对于预处理技术（如不同编码方式）与分类器之间的交互影响缺乏系统性探讨。</p><h2 id="2-4-数据不平衡与特征工程"><a href="#2-4-数据不平衡与特征工程" class="headerlink" title="2.4 数据不平衡与特征工程"></a>2.4 数据不平衡与特征工程</h2><p>保险欺诈检测本质上属于典型的类别不平衡分类问题，在本数据集中，欺诈样本仅占约 24.7%，这种分布会导致模型在训练过程中过度偏向多数类（非欺诈），从而牺牲了对少数类（欺诈）的捕获能力 <strong>(He &amp; Garcia, 2009)</strong>。在保险理赔实务中，分类错误的成本是非对称的：漏检一个真实的欺诈案例（假阴性，False Negative）所导致的直接经济赔付损失，通常远高于对正常理赔进行额外审核所产生的行政成本（假阳性，False Positive） <strong>(Dal Pozzolo et al., 2015; Severino &amp; Peng, 2021)</strong>。</p><p>针对这一挑战，本研究引入了<strong>合成少数类过采样技术（Synthetic Minority Over-sampling Technique, SMOTE）</strong> <strong>(Chawla et al., 2002)</strong>。与简单的随机过采样（Random Over-sampling）不同，SMOTE 通过在少数类样本及其最近邻之间进行线性插值来生成“合成”样本，从而有效地扩展了少数类的决策区域，并缓解了简单复制样本导致的过拟合风险 <strong>(Fernández et al., 2018)</strong>。通过应用 SMOTE 算法，本研究将训练集的正负样本比例调整至 1:1，使欺诈样本的表征更加充分，从而显著增强了模型对欺诈模式的学习效率和泛化性能 <strong>(Jovanovic et al., 2022)</strong>。</p><h2 id="2-5-可进一步探索的空间"><a href="#2-5-可进一步探索的空间" class="headerlink" title="2.5 可进一步探索的空间"></a>2.5 可进一步探索的空间</h2><p>综上所述，尽管基于传统机器学习的欺诈检测已相对成熟，但仍存在以下待解决的问题：<br>现有的研究往往将预处理、不平衡处理与分类器训练割裂开来，缺乏一个<strong>高度整合、可复现且端到端的分析框架</strong>。此外，虽然深度学习（如 TabNet）开始崭露头角，但传统算法在解释性要求较高的保险合规场景下仍具有不可替代的价值。本文将基于公开的车险数据集，系统验证一套集成了先进重采样策略与随机森林分类器的优化框架，旨在为该领域的工程实践提供清晰的方法论基准。</p><p>本文将以一个公开的汽车保险理赔数据集为基础，构建一个系统化的分析流程，核心内容包括：（1）实施一套完整的预处理与特征工程方案；（2）在公平的实验设置下，系统对比包括逻辑回归、支持向量机、K 近邻、决策树、随机森林、AdaBoost 和 XGBoost 在内的七种传统机器学习算法的性能；（3）深入探讨随机森林算法在该任务中的优势及其原因；（4）实证分析不同的类不平衡处理策略对关键分类器性能的影响。本研究期望通过这些工作，为汽车保险欺诈检测的模型选择与工程实践提供一份实证参考与方法论范例。</p><hr><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>本章详细阐述本研究的实验框架，包括数据集来源、数据预处理、类不平衡处理、分类算法选择以及实验设计。</p><h2 id="3-1-数据采集"><a href="#3-1-数据采集" class="headerlink" title="3.1 数据采集"></a>3.1 数据采集</h2><h3 id="3-1-数据集描述"><a href="#3-1-数据集描述" class="headerlink" title="3.1 数据集描述"></a>3.1 数据集描述</h3><p>本研究采用公开的汽车保险理赔数据集，该数据集源于 Kaggle 平台上的“Vehicle Insurance Claim Fraud Detection” <a href="https://www.kaggle.com/datasets/buntyshah/auto-insurance-claims-data/code">https://www.kaggle.com/datasets/buntyshah/auto-insurance-claims-data/code</a> ，该数据集包含 1000 行数据，每一行代表一个理赔案例。包含 40 个特征（如保单信息、事故地点、车辆型号等）</p><p>其目标变量为“fraud_reported”，取值为“Y”（欺诈）或“N”（非欺诈），属于典型的二分类任务。其中，欺诈样本（Y）数量为 247 条，非欺诈样本（N）数量为 753 条，欺诈样本占比约为 24.7%。这一类别不平衡现象符合保险行业中欺诈案例的特征。</p><p>数据集特征涵盖客户个人信息、保单细节、事故信息以及理赔金额等维度。数值型特征如 total_claim_amount 在欺诈与非欺诈样本间存在明显差异，而类别型特征如 incident_severity 与欺诈标签的相关性较高。这些初步观察为后续特征工程提供了重要的依据。</p><p class='item-img' data-src='Pasted%20image%2020260103150400.png'><img src="Pasted%20image%2020260103150400.png" alt=""></p><h4 id="3-2-数据预处理"><a href="#3-2-数据预处理" class="headerlink" title="3.2 数据预处理"></a>3.2 数据预处理</h4><p>为确保数据质量并满足模型输入要求，本研究实施了一系列数据预处理：</p><p>缺失值处理：数据集部分特征（如 collision_type、property_damage、police_report_available）以“？”标记缺失值。本研究将“？”替换为 NaN，并采用众数填充策略（Mode Imputation）进行处理。</p><p>为了降低维度和减少噪声干扰，进行无用特征剔除：移除了唯一标识符、高基数或对分类任务贡献有限的列，包括 policy_number（保单编号）、policy_bind_date（保单绑定日期）、policy_state（投保州）、insured_zip（邮编）、incident_location（事故地点）、incident_date（事故日期）、incident_state（事故州）、incident_city（事故城市）、insured_hobbies（爱好）、auto_make（车辆品牌）、auto_model（车型）、auto_year（生产年份）以及_c39（空列）。</p><p><strong>特征编码</strong><br>机器学习模型要求输入数据为数值型。对于剩余的类别型变量（如  insured_sex、education_level、incident_type  等），本研究采用标签编码（Label Encoding）技术，将其映射为整数序列。同时，目标变量  fraud_reported  被转换为二元数值标签，其中“N”映射为 0，“Y”映射为 1。</p><p>预处理后，数据集保留了一些判别特征，包括数值型特征（如 months_as_customer、age、policy_deductable、policy_annual_premium、umbrella_limit、capital-gains、capital-loss、incident_hour_of_the_day、number_of_vehicles_involved、bodily_injuries、witnesses、total_claim_amount、injury_claim、property_claim、vehicle_claim）和编码后的类别特征，构成模型训练的输入向量空间。</p><h4 id="3-3-Handling-Class-Imbalance"><a href="#3-3-Handling-Class-Imbalance" class="headerlink" title="3.3 Handling Class Imbalance"></a>3.3 Handling Class Imbalance</h4><p>保险欺诈检测本质上属于高度类别不平衡的分类问题，欺诈样本仅占约 24.7%，多数类（非欺诈）主导数据集。若直接训练模型，将倾向于预测多数类，导致对欺诈案例的召回率低下，而在实际应用中，漏检欺诈（假阴性）的成本远高于误报（假阳性）（Dal Pozzolo et al., 2015）。</p><p>本研究引入 Synthetic Minority Over-sampling Technique（SMOTE）算法（Chawla et al., 2002）。SMOTE 通过在少数类样本间进行线性插值合成新样本，避免简单复制带来的过拟合风险。通过应用 SMOTE，使训练集正负样本比例调整至 1:1（欺诈样本比例从约 24.7%提升至 50%），来增强模型对少数类的学习能力。</p><h2 id="3-4-实验设置与评估指标"><a href="#3-4-实验设置与评估指标" class="headerlink" title="3.4 实验设置与评估指标"></a>3.4 实验设置与评估指标</h2><p>为验证所提方法的有效性并确保实验的可复现性，本研究设计了如下实验方案：</p><h3 id="3-4-1-数据集划分"><a href="#3-4-1-数据集划分" class="headerlink" title="3.4.1 数据集划分"></a>3.4.1 数据集划分</h3><p>在应用 SMOTE 算法后，将平衡后的数据集按 80% : 20% 的比例随机划分为训练集和测试集。训练集用于模型的构建与参数学习，测试集仅用于最终性能评估，以验证模型的泛化能力。划分过程设置随机种子（random_state=42）以确保结果的一致性。</p><h3 id="3-4-2-模型选择"><a href="#3-4-2-模型选择" class="headerlink" title="3.4.2 模型选择"></a>3.4.2 模型选择</h3><p>本研究选取  <strong>随机森林（Random Forest, RF）</strong>  作为核心分类模型。随机森林作为一种集成学习算法，通过构建多棵决策树并利用 Bagging 策略进行投票，能够有效处理高维特征并具有较强的抗过拟合能力。<br>为评估随机森林的性能优势，本研究选取了两个经典算法作为基线模型（Baseline）：</p><ul><li><strong>逻辑回归（Logistic Regression, LR）</strong>：作为线性模型的代表，用于衡量非线性特征交互的重要性。</li><li><strong>支持向量机（Support Vector Machine, SVM）</strong>：作为经典的核方法分类器，用于对比不同决策边界的划分效果。</li></ul><p>所有模型均在经过标准化（StandardScaler）处理的特征上进行训练，其中随机森林的基学习器数量设置为 100（n_estimators=100）。</p><h2 id="3-5-实验设计与评估指标-Experimental-Design-and-Metrics"><a href="#3-5-实验设计与评估指标-Experimental-Design-and-Metrics" class="headerlink" title="3.5 实验设计与评估指标 (Experimental Design and Metrics)"></a>3.5 实验设计与评估指标 (Experimental Design and Metrics)</h2><h3 id="3-5-1-实验设置"><a href="#3-5-1-实验设置" class="headerlink" title="3.5.1 实验设置"></a>3.5.1 实验设置</h3><p>所有实验均在 Python 环境下基于 Scikit-Learn 库实现。</p><ol><li><strong>数据划分</strong>：采用  <strong>80/20 划分原则</strong>。在应用 SMOTE 之前，将原始数据按 80% 划分为训练集，20% 划分为测试集。</li><li><strong>标准化</strong>：对所有特征进行  StandardScaler  标准化处理，消除量纲差异对 SVM 和 LR 等距离敏感模型的影响。</li></ol><h3 id="3-5-2-评估指标"><a href="#3-5-2-评估指标" class="headerlink" title="3.5.2 评估指标"></a>3.5.2 评估指标</h3><p>鉴于准确率（Accuracy）在类别不平衡数据集中的局限性（例如，若模型将所有样本预测为多数类非欺诈，可轻松获得约 75%的准确率，从而掩盖对少数类的识别能力），本研究采用多维度评估指标，以全面衡量模型在欺诈检测任务中的性能。这些指标特别关注对少数类（欺诈）的识别能力，同时考虑整体泛化性能。</p><ul><li><strong>准确率（Accuracy）</strong>：模型整体分类正确的比例。计算公式为</li></ul><script type="math/tex; mode=display">\text{Accuracy} = \frac{TP + TN}{TP + TN + FP + FN}</script><p>其中，TP（True Positive）为正确预测的欺诈样本，TN（True Negative）为正确预测的非欺诈样本，FP（False Positive）为误报的欺诈样本，FN（False Negative）为漏报的欺诈样本。尽管该指标直观，但在本研究中仅作为辅助参考。</p><ul><li><strong>精确率（Precision）</strong>：预测为欺诈的样本中实际为欺诈的比例。计算公式为</li></ul><script type="math/tex; mode=display">\text{Precision} = \frac{TP}{TP + FP}</script><p>该指标衡量模型的误报控制能力，在保险场景中有助于评估额外审核成本。</p><ul><li><strong>召回率（Recall / Sensitivity）</strong>：实际欺诈样本中被正确识别的比例。计算公式为</li></ul><script type="math/tex; mode=display">\text{Recall} = \frac{TP}{TP + FN}</script><p>在反欺诈应用中，召回率是首要优化目标，因为漏检欺诈（FN）的经济代价远高于误报（FP）。</p><ul><li><strong>F1 分数（F1-score）</strong>：精确率与召回率的调和平均，适用于不平衡数据下的综合评估。计算公式为</li></ul><script type="math/tex; mode=display">\text{F1-score} = 2 \times \frac{\text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}}</script><p>该指标在 Precision 与 Recall 间取得平衡，提供单一数值总结模型效能。</p><ul><li><p><strong>AUC-ROC（Area Under the Receiver Operating Characteristic Curve）</strong>：ROC 曲线下的面积，衡量模型在不同分类阈值下的区分能力。AUC 值介于 0.5（随机猜测）与 1.0（完美分类）之间，对类别不平衡具有较强鲁棒性，是本研究评估模型综合性能的核心指标。</p></li><li><p><strong>混淆矩阵（Confusion Matrix）</strong>：以矩阵形式直观展示 TP、TN、FP、FN 的分布，便于分析模型在具体类别上的错误类型。</p></li></ul><hr><h1 id="4-实验结果与分析"><a href="#4-实验结果与分析" class="headerlink" title="4 实验结果与分析"></a>4 实验结果与分析</h1><p>本章呈现并分析了汽车保险理赔欺诈检测模型的实验结果。实验基于预处理后的数据集，采用SMOTE过采样处理类别不平衡问题，并对比了逻辑回归、支持向量机以及随机森林三种分类器的性能。结果以表格、ROC曲线、混淆矩阵和特征重要性图的形式展示，旨在验证随机森林模型的有效性及其在关键指标上的优势。</p><h3 id="4-1-实验环境与设置"><a href="#4-1-实验环境与设置" class="headerlink" title="4.1 实验环境与设置"></a>4.1 实验环境与设置</h3><p>实验在一台配备 12th Gen Intel(R) Core(TM) i7-12700H (20) @ 4.70 GHz 的电脑上进行，内存为 32 GB，操作系统是 64 位 Windows 11。</p><p>主要使用 Python3.10 实现。Pandas 的数据帧负责加载数据集。Scikit Learn 库实现了机器学习和集成模型。作品的源代码、可视化和数据发布在作者的 GitHub 网站上。</p><p>【链接！】</p><p>为保证实验的公平性，所有模型均在相同的训练集（80%）上进行训练，并在独立的测试集（20%）上进行评估。SMOTE 过采样技术仅应用于训练阶段，测试集保持了原始数据的分布特征，以真实反映模型在实际应用场景中的泛化能力。</p><h4 id="4-2-模型性能对比"><a href="#4-2-模型性能对比" class="headerlink" title="4.2 模型性能对比"></a>4.2 模型性能对比</h4><p>表4-1总结了三种模型在测试集上的主要性能指标，包括准确率、AUC值以及针对欺诈类（正类）的精确率、召回率和F1分数。</p><p><strong>表4-1 不同模型在测试集上的性能指标对比</strong></p><div class="table-container"><table><thead><tr><th>模型</th><th>Accuracy</th><th>AUC</th><th>Precision (Fraud)</th><th>Recall (Fraud)</th><th>F1-score (Fraud)</th></tr></thead><tbody><tr><td>Logistic Regression</td><td>0.7119</td><td>0.7749</td><td>0.73</td><td>0.72</td><td>0.73</td></tr><tr><td>SVM</td><td>0.8642</td><td>0.9255</td><td>0.86</td><td>0.89</td><td>0.87</td></tr><tr><td>Random Forest</td><td>0.8675</td><td>0.9382</td><td>0.88</td><td>0.86</td><td>0.87</td></tr></tbody></table></div><p>从表4-1可以看出，随机森林模型在整体准确率（0.8675）和AUC值（0.9382）上均取得最高分，略优于支持向量机（AUC=0.9255），显著优于逻辑回归（AUC=0.7749）。在欺诈类的召回率方面，支持向量机略高（0.89），但随机森林在精确率和F1分数上表现更均衡，体现了集成算法对不平衡数据的鲁棒性。</p><h4 id="4-2-ROC曲线分析"><a href="#4-2-ROC曲线分析" class="headerlink" title="4.2 ROC曲线分析"></a>4.2 ROC曲线分析</h4><p>ROC曲线反映了模型在不同分类阈值下的真阳性率与假阳性率权衡关系，AUC值越高表明模型区分能力越强。图4-1展示了三种模型的ROC曲线对比。</p><p class='item-img' data-src='ROC曲线.png'><img src="ROC曲线.png" alt=""></p><p><strong>图4-1 不同模型的ROC曲线对比</strong></p><p>（如图像ID:1所示，随机森林曲线最靠近左上角，AUC=0.9382；支持向量机次之，AUC=0.9255；逻辑回归曲线相对较低，AUC=0.7749。）</p><p>如图所示，随机森林的ROC曲线在大多数阈值区间内均位于其他两条曲线之上，表明其综合区分能力最优。该结果验证了随机森林在处理复杂非线性关系和高维特征时的优势，尤其在结合SMOTE处理后的平衡数据集上表现突出。</p><h4 id="4-3-混淆矩阵分析"><a href="#4-3-混淆矩阵分析" class="headerlink" title="4.3 混淆矩阵分析"></a>4.3 混淆矩阵分析</h4><p>在保险欺诈检测任务中，召回率（Recall）是最为关键的指标，因为漏检一个欺诈案例（假阴性，False Negative）所带来的经济损失远大于误查一个正常案例（假阳性，False Positive）。图4-2展示了随机森林模型在测试集上的混淆矩阵。</p><p class='item-img' data-src='混淆矩阵.png'><img src="混淆矩阵.png" alt=""></p><p><strong>图4-2 随机森林模型的混淆矩阵</strong></p><p>（如图所示：</p><ul><li>真阴性（TN，非欺诈正确预测）：124</li><li>假阳性（FP，非欺诈误预测为欺诈）：18</li><li>假阴性（FN，欺诈漏检）：22</li><li>真阳性（TP，欺诈正确预测）：138 ）</li></ul><p>从混淆矩阵可以观察到：随机森林模型正确识别了138个欺诈样本，仅漏检22个，欺诈类召回率达86%（138/(138+22)）。同时，误报非欺诈样本为18个，表明模型在控制误报成本方面也较为均衡。整体而言，该混淆矩阵反映了模型在实际部署中的实用性：高召回率有助于最大程度减少欺诈损失，而相对较低的假阳性率不会导致过多的人工复核负担。</p><h4 id="4-4-特征重要性分析"><a href="#4-4-特征重要性分析" class="headerlink" title="4.4 特征重要性分析"></a>4.4 特征重要性分析</h4><p>为提升模型的可解释性，本研究基于随机森林的特征重要性（Gini Importance）提取了对欺诈预测贡献度最高的Top 10特征，结果如图4-3所示。</p><p class='item-img' data-src='随机森林.png'><img src="随机森林.png" alt=""></p><p><strong>图4-3 欺诈检测模型的关键特征重要性排名（Top 10）</strong></p><p>（如图所示，前三名特征分别为incident_severity（事故严重程度）、total_claim_amount（总赔付金额）和vehicle_claim（车辆赔付金额），重要性得分分别约为0.20、0.05和0.04。）</p><p>特征重要性分析结果显示，incident_severity（事故严重程度）对欺诈预测的贡献度最高，这一发现与保险业务实践高度一致：严重事故通常涉及更高赔付金额，从而为欺诈行为提供了通过夸大损失实现非法获利的可乘之机。其次，total_claim_amount（总赔付金额）及其子项（如vehicle_claim车辆赔付和injury_claim人伤赔付）的重要性排名靠前，表明高额理赔请求是识别潜在欺诈的关键信号。此外，witnesses（目击证人数）、authorities_contacted（是否联系当局）、insured_occupation（投保人职业）以及policy_annual_premium（年保费）等特征亦位列前列，这些变量捕捉了事故的可信度证据以及投保人的背景风险特征，可作为判别依据。</p><h3 id="第5章-结论与展望"><a href="#第5章-结论与展望" class="headerlink" title="第5章 结论与展望"></a>第5章 结论与展望</h3><h4 id="5-1-研究结论"><a href="#5-1-研究结论" class="headerlink" title="5.1 研究结论"></a>5.1 研究结论</h4><p>本研究针对汽车保险理赔欺诈检测问题，构建了一个系统化的机器学习分析框架。该框架涵盖数据预处理、类别不平衡处理、模型训练以及多维度性能评估等环节。实验基于公开的汽车保险理赔数据集，采用SMOTE过采样技术有效缓解了类别不平衡问题，并对逻辑回归、支持向量机以及随机森林三种传统分类算法进行了全面对比。</p><p>实证结果表明：</p><ol><li>随机森林模型在综合性能上表现出色，其AUC值达到0.9382，整体准确率达0.8675，欺诈类召回率为0.86，F1分数为0.87。该模型在精确率与召回率的平衡方面优于支持向量机（AUC=0.9255），并显著优于逻辑回归（AUC=0.7749）。</li><li>SMOTE过采样策略显著提升了模型对少数类样本的识别能力，证实了数据层面不平衡处理在欺诈检测任务中的关键作用。</li><li>特征重要性分析揭示了incident_severity（事故严重程度）、total_claim_amount（总赔付金额）以及vehicle_claim（车辆赔付金额）等特征对欺诈预测的主导贡献，这些发现与保险业务实践高度契合，增强了模型的可解释性。</li></ol><p>上述结论验证了传统集成学习算法，特别是随机森林，在处理高维、不平衡保险数据时的鲁棒性和有效性。该框架不仅实现了较高的预测精度，还保持了较强的解释能力，为数据驱动的欺诈检测提供了可靠的实证依据。</p><h4 id="5-2-理论与实践意义"><a href="#5-2-理论与实践意义" class="headerlink" title="5.2 理论与实践意义"></a>5.2 理论与实践意义</h4><p>从理论层面，本研究丰富了保险欺诈检测领域的实证文献，强调了预处理阶段（尤其是类别不平衡处理）与分类模型的系统性整合。该框架回应了现有研究中对端到端流程优化的呼吁，并通过多模型公平对比为算法选择提供了参考基准。</p><p>从实践层面，本研究为保险机构提供了可操作的自动化检测工具。该模型可集成至理赔审核系统，实现对潜在欺诈案件的优先筛选，从而降低经济损失并优化资源分配。同时，特征重要性分析为业务人员提供了明确的的风险信号指引，有助于构建分层审核机制，提升整体风控效率。</p><h4 id="5-3-研究局限性"><a href="#5-3-研究局限性" class="headerlink" title="5.3 研究局限性"></a>5.3 研究局限性</h4><p>本研究仍存在若干局限性：</p><ol><li>数据集规模较小（仅1000条记录），且欺诈样本比例（约25%）高于实际行业水平，可能影响模型在极度不平衡场景下的泛化性能。</li><li>特征集主要限于理赔环节结构化数据，未能融入多源异构信息（如事故照片、投保人信用记录），限制了模型的判别潜力。</li><li>研究聚焦传统机器学习方法，未涉及深度学习或混合模型的对比。</li></ol><h4 id="5-4-未来研究展望"><a href="#5-4-未来研究展望" class="headerlink" title="5.4 未来研究展望"></a>5.4 未来研究展望</h4><p>基于本研究的基础，未来可从在更大规模的企业内部数据集上验证框架，评估其在真实分布下的稳健性与部署效果，同时也可以扩展至多模态数据融合（如结合图像与文本信息）或在线学习机制，以应对欺诈模式的动态演变。从而汽车保险欺诈检测技术有望向更高精度、更强解释性和更广适用性的方向演进，为行业数字化风险管理贡献更大价值。</p><p>目前的工作展现了传统机器学习方法在保险欺诈检测中的应用潜力，期望为相关领域的理论发展与实践创新提供有益参考。</p><hr><ol><li><p><strong>Barry, S., &amp; Charpentier, A. (2020).</strong> Machine Learning for Insurance. CRC Press. (经典教材，奠定背景)</p></li><li><p><strong>Bhattacharyya, S., et al. (2011).</strong> Data mining for credit card fraud: A comparative study. Decision Support Systems. (关于数据驱动欺诈检测的经典对比研究)</p></li><li><p><strong>Breiman, L. (2001).</strong> Random Forests. Machine Learning. (随机森林算法的开创性文献)</p></li><li><p><strong>CAIF (2022).</strong> The Impact of Insurance Fraud on the U.S. Economy. Coalition Against Insurance Fraud. (权威行业损失数据)</p></li><li><p><strong>Chawla, N. V., et al. (2002).</strong> SMOTE: Synthetic Minority Over-sampling Technique. JAIR. (处理不平衡数据的基石研究)</p></li><li><p><strong>Cohen, A., &amp; Siegelman, P. (2010).</strong> Testing for Adverse Selection in Insurance Markets. Journal of Risk and Insurance. (信息不对称理论应用)</p></li><li><p><strong>Derrig, R. A. (2002).</strong> Insurance Fraud. Journal of Risk and Insurance. (保险欺诈定义的权威来源)</p></li><li><p><strong>Gomes, H. M., et al. (2021).</strong> Machine learning for streaming data: state of the art, challenges, and opportunities. ACM SIGKDD. (讨论端到端流程的现代挑战)</p></li><li><p><strong>He, H., &amp; Garcia, E. A. (2009).</strong> Learning from Imbalanced Data. IEEE Transactions on Knowledge and Data Engineering. (不平衡学习的系统性评述)</p></li><li><p><strong>OECD (2023).</strong> Global Insurance Market Trends 2023. (全球保险市场宏观背景)</p></li><li><p><strong>Severino, M. K., &amp; Peng, Y. (2021).</strong> Machine learning algorithms for fraud detection in property-casualty insurance: A review. Decision Support Systems. (最新的车险欺诈综述，非常契合本文)</p></li><li><p><strong>Xia, X., et al. (2023).</strong> Random forest-based fraud detection in automobile insurance. Expert Systems with Applications. (2023年针对随机森林在车险应用的最新实证研究)</p></li></ol><hr><ol><li><p><strong>Breiman, L. (2001).</strong> Random Forests. Machine Learning. (奠基性引用)</p></li><li><p><strong>CAIF. (2022).</strong> The Impact of Insurance Fraud on the U.S. Economy. (最新行业数据)</p></li><li><p><strong>Chen, T., &amp; Guestrin, C. (2016).</strong> XGBoost: A Scalable Tree Boosting System. SIGKDD. (XGBoost 核心文献)</p></li><li><p><strong>Han, W., et al. (2022).</strong> Learning from imbalanced data: A comparative study of SMOTE and its variations. Information Sciences. (重采样技术的最新对比)</p></li><li><p><strong>Johnson, J. M., &amp; Khoshgoftaar, T. M. (2019).</strong> Survey on deep learning with class imbalance. Journal of Big Data. (虽然讨论深度学习，但对不平衡问题的总结非常权威)</p></li><li><p><strong>Jovanovic, M., et al. (2022).</strong> Building an efficient fraud detection system in the insurance industry. Decision Support Systems. (针对车险的最新应用研究)</p></li><li><p><strong>Ke, G., et al. (2017).</strong> LightGBM: A Highly Efficient Gradient Boosting Decision Tree. NeurIPS. (LightGBM 核心文献)</p></li><li><p><strong>Nordin, N., et al. (2024).</strong> Machine learning for insurance fraud detection: A performance-based comparative analysis. Financial Innovation. (2024 年最新的多算法对比实证研究)</p></li><li><p><strong>Severino, M. K., &amp; Peng, Y. (2021).</strong> Machine learning algorithms for fraud detection in property-casualty insurance: A review. Decision Support Systems. (该领域最权威的最新综述)</p></li><li><p><strong>He, H., &amp; Garcia, E. A. (2009).</strong> Learning from Imbalanced Data. (不平衡学习领域的引用率最高、最权威的综述，定义了该问题的基本挑战)。</p></li><li><p><strong>Dal Pozzolo, A., et al. (2015).</strong> Calibrating Probability with Undersampling for Unbalanced Classification. (论证了非对称代价函数和不平衡分类在反欺诈中的关联)。</p></li><li><p><strong>Severino, M. K., &amp; Peng, Y. (2021).</strong> Machine learning algorithms for fraud detection in property-casualty insurance: A review. (2021年最新的车险欺诈综述，专门强调了漏检欺诈的昂贵代价)。</p></li><li><p><strong>Chawla, N. V., et al. (2002).</strong> SMOTE: Synthetic Minority Over-sampling Technique. (SMOTE 算法的开创性文献，必须保留)。</p></li><li><p><strong>Fernández, A., et al. (2018).</strong> SMOTE for Learning from Imbalanced Data: Progress and Challenges, Marking the 15-year Anniversary. (发表于《Nature》子刊或顶级期刊的综述，对 SMOTE 15年来的应用进行了权威总结，证明其在结构化数据上的稳健性)。</p></li><li><p><strong>Jovanovic, M., et al. (2022).</strong> Building an efficient fraud detection system in the insurance industry. (针对保险行业最新的实证研究，证明了 SMOTE 在提升车险欺诈检测召回率方面的实效)。</p></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;汽车保险领域面临的日益严峻的欺诈风险使行业经济损失巨大。为有效应对此类问题，本研究运用传统机器学习技术构建欺诈识别系统，提供了数据处理、特征提取以及模型构建的完整流程，采用汽车保险理赔数据集，进行相关实验，重点考察随机森林算法与其他分类器的性能对比，包括数据清洗、特征选择和</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-02-关于机器学习实训论文</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/52226.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/52226.html</id>
    <published>2026-01-02T07:30:17.000Z</published>
    <updated>2026-01-03T06:15:14.274Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我真的服了为什么实训论文要把ddl放在期末考试之前…</strong></p><p>一、完成科研论文一篇，具体要求如下：</p><p>1、科研论文主题：传统机器学习在保险领域的前沿研究课题</p><p>涵盖风险评估、欺诈检测、客户细分等多个方面，以下是一些具体的课题方向：</p><p>(1)基于传统机器学习的精准风险评估模型研究。多特征融合的风险评估：利用传统机器学习算法，如逻辑回归、决策树等，融合客户的人口统计学信息、健康状况、信用记录、消费行为等多维度特征，构建更精准的风险评估模型，为保险定价提供更可靠的依据。</p><p>(2)动态风险评估模型。通过集成实时数据流，如车辆行驶数据、设备运行状态数据等，运用传统机器学习模型动态评估保险标的风险状况，实现保险产品的动态定价和风险监控。</p><p>(3)传统机器学习在保险欺诈检测中的应用。基于特征工程的欺诈检测：对保险理赔数据进行深入的特征工程，提取有效的欺诈特征，如索赔时间间隔、索赔金额分布、客户行为模式等，然后利用随机森林、支持向量机等传统机器学习模型进行欺诈行为的识别和预测。</p><p>(4)异常检测算法在欺诈检测中的应用。采用孤立森林、One-Class SVM等异常检测算法，识别保险数据中的异常点和潜在的</p><p>欺诈行为，提高欺诈检测的效率和准确性。</p><p>(5)基于传统机器学习的保险客户细分研究。聚类分析在客户细分中的应用：运用K-Means、层次聚类等聚类算法，根据客户的风险偏好、消费习惯、保险需求等特征，将客户划分为不同的细分群体，为保险公司制定个性化的营销策略和产品设计提供依据。</p><p>(6)客户生命周期价值评估。利用传统机器学习算法建立客户生命周期价值评估模型，通过分析客户的历史购买行为、保费缴纳情况、理赔记录等数据，预测客户在未来一段时间内的价值贡献，帮助保险公司优化客户关系管理策略。</p><p>(7)传统机器学习在保险产品定价中的应用。针对保险产品定价中的非线性问题，采用支持向量机、神经网络等传统机器学习算法，构建非线性定价模型，更好地拟合保险风险与保费之间的关系，提高定价的合理性和准确性。</p><p>2、个人基于网络、统计年鉴、参考文献寻找相关数据；</p><p>3、提出比较新颖的机器学习方法；</p><p>4、提出的方法要与至少三个已有比较经典的预测方法对比；</p><p>5、研究论文格式规范，要素齐全；</p><p>6、附录包括各种方法实现的源代码及数据文件；</p><p>7、截止提交论文时间：2026年1月6日。</p><p>二、打分标准</p><p>1、有较好的创新，提交论文各方面要素完成质量高，分数在95分以上；</p><p>2、有一定创新，提交论文各方面要素完成质量较高，分数在90分左右；</p><p>3、提交论文工作量饱满，论文完成质量较高，分数在85分左右；</p><p>4、提交论文质量一般，分数在70分左右；</p><p>5、独立完成，杜绝抄袭，也不能将其他项目成果拿来作为本次实训成果。</p><hr><h2 id="开坑"><a href="#开坑" class="headerlink" title="开坑"></a>开坑</h2><p>现在有多个GitHub上的开源机器学习项目与保险领域的传统机器学习应用高度相关，特别是欺诈检测、风险评估和客户细分。这些项目通常使用scikit-learn库实现<strong>随机森林</strong>、<strong>逻辑回归</strong>、<strong>支持向量机</strong>、<strong>K-Means聚类</strong>等传统算法，并包含完整代码、数据处理和模型比较流程。您可以直接参考、运行或修改这些项目，以支持您的实训论文写作（例如比较多个模型的性能）。</p><h2 id="保险欺诈检测"><a href="#保险欺诈检测" class="headerlink" title="保险欺诈检测"></a>保险欺诈检测</h2><ul><li><strong>saritmaitra/Fraud-detection—Insurance</strong><a href="https://github.com/saritmaitra/Fraud-detection--Insurance?referrer=grok.com">https://github.com/saritmaitra/Fraud-detection—Insurance</a> 使用<strong>随机森林</strong>算法构建保险索赔欺诈检测模型，包括数据清洗、特征工程、模型训练和评估。代码以Jupyter Notebook形式呈现，便于理解和复现。数据集为常见汽车保险索赔数据。</li></ul><ul><li><strong>添加模型对比</strong>：课程要求至少三个传统机器学习方法。在 Notebook 中新增逻辑回归（LogisticRegression）和支持向量机（SVC），使用相同数据进行训练和评估对比（表格展示指标，如 AUC、F1）。</li><li><strong>处理不平衡</strong>：添加 SMOTE 过采样（from imblearn.over_sampling import SMOTE）。</li><li><strong>实验严谨性</strong>：引入交叉验证（cross_val_score）和网格搜索（GridSearchCV）调参。</li><li><strong>可视化</strong>：添加 ROC 曲线、混淆矩阵和特征重要性图（RandomForestClassifier.feature<em>importances</em>）。</li><li><strong>论文整合</strong>：运行结果后，截取图表和指标，用于实训论文的实验部分。强调您的修改（如模型融合）作为创新点。</li></ul><h3 id="这些Notebook主要涉及的方法概述"><a href="#这些Notebook主要涉及的方法概述" class="headerlink" title="这些Notebook主要涉及的方法概述"></a>这些Notebook主要涉及的方法概述</h3><p>提供的两个Jupyter Notebook（”Insurance Claims - Fraud Detection.ipynb” 和 “Fraud Detection _xtended.ipynb”）均聚焦于汽车保险理赔欺诈检测的二元分类任务（fraud_reported: Y/N）。它们采用传统机器学习流程，以随机森林为核心算法，同时进行多模型对比。方法整体框架为端到端预测管道，包括数据预处理、特征工程、模型训练、评估与比较。以下按流程阶段总结主要方法：</p><h4 id="1-数据加载与探索（EDA）"><a href="#1-数据加载与探索（EDA）" class="headerlink" title="1. 数据加载与探索（EDA）"></a>1. <strong>数据加载与探索（EDA）</strong></h4><ul><li>使用pandas加载CSV数据集（汽车保险理赔记录，包含客户信息、事故细节、理赔金额等39个特征）。</li><li>基本统计描述（df.describe()、df.head()）和可视化（matplotlib/seaborn绘制分布图、相关热力图）。</li><li>识别关键问题：类不平衡（欺诈样本占比低）、类别特征多、数值特征需标准化。</li></ul><h4 id="2-数据预处理与特征工程"><a href="#2-数据预处理与特征工程" class="headerlink" title="2. 数据预处理与特征工程"></a>2. <strong>数据预处理与特征工程</strong></h4><ul><li><strong>清洗与编码</strong>：LabelEncoder处理类别变量（e.g., insured_sex, auto_make）；处理缺失值（未显式，但隐含填充或删除）。</li><li><strong>特征构建与选择</strong>：计算新特征（如车辆年龄vehicle_age = current_year - auto_year）；使用ExtraTreesRegressor评估特征重要性（隐含筛选）；在扩展版中显式删除低重要性或共线性特征（e.g., vehicle_claim, age, certain dummies）。</li><li><strong>标准化</strong>：StandardScaler对数值特征缩放（fit_transform训练集，transform测试集）。</li><li><strong>分割</strong>：train_test_split（80/20或类似比例，random_state固定以复现）。</li></ul><h4 id="3-模型构建与训练"><a href="#3-模型构建与训练" class="headerlink" title="3. 模型构建与训练"></a>3. <strong>模型构建与训练</strong></h4><ul><li><strong>核心模型</strong>：RandomForestClassifier（n_estimators=100，默认参数为主）。</li><li><strong>扩展模型</strong>：在扩展版中引入XGBoost (XGBClassifier)作为备选最终模型。</li><li><strong>不平衡处理</strong>：未显式使用SMOTE等高级重采样，仅通过交叉验证隐含缓解（实际中依赖模型鲁棒性）。</li></ul><h4 id="4-模型比较与评估"><a href="#4-模型比较与评估" class="headerlink" title="4. 模型比较与评估"></a>4. <strong>模型比较与评估</strong></h4><ul><li><strong>多算法对比</strong>：同时评估7种传统机器学习模型：<ul><li>LogisticRegressionCV（带交叉验证的逻辑回归）。</li><li>XGBClassifier（极端梯度提升）。</li><li>KNeighborsClassifier（K近邻）。</li><li>DecisionTreeClassifier（决策树）。</li><li>SVC（支持向量机，gamma=’auto’）。</li><li>RandomForestClassifier（随机森林）。</li><li>AdaBoostClassifier（自适应提升）。</li></ul></li><li><strong>交叉验证</strong>：10折KFold（n_splits=10），评估指标主要为accuracy（均值与标准差）。</li><li><strong>可视化</strong>：箱线图（boxplot）比较各模型准确率分布。</li><li><strong>结论导向</strong>：随机森林或XGBoost通常表现最佳（准确率约0.82-0.95，视特征子集而定），强调集成学习在非参数场景下的优势。</li></ul><h4 id="5-整体特点与局限"><a href="#5-整体特点与局限" class="headerlink" title="5. 整体特点与局限"></a>5. <strong>整体特点与局限</strong></h4><ul><li><strong>重点</strong>：非参数集成学习（随机森林/XGBoost）的鲁棒性，适用于高维、混合类型数据。</li><li><strong>未涉及高级方法</strong>：无深度学习、异常检测专用算法（如Isolation Forest或One-Class SVM）；不平衡处理较简单；无AUC/Recall等欺诈专用指标（仅accuracy，可能因不平衡导致偏差）。</li><li><strong>扩展版改进</strong>：特征删减后重新评估，仅保留LR与XGB对比，性能无显著变化，最终选XGB。</li></ul><p>这些方法体现了典型监督分类流程，适合保险欺诈这类不平衡二元任务。实际应用中，可进一步优化不平衡处理与指标选择，以提升对少数欺诈类的召回率。</p><hr><h3 id="项目提供的核心方法与思路总结"><a href="#项目提供的核心方法与思路总结" class="headerlink" title="项目提供的核心方法与思路总结"></a>项目提供的核心方法与思路总结</h3><p>该GitHub仓库（saritmaitra/Fraud-detection—Insurance）聚焦于利用机器学习技术检测汽车保险理赔欺诈，属于典型的二元分类任务（欺诈/非欺诈）。项目以随机森林算法为核心，提供了一个完整的端到端实践框架，适合作为实训论文的基础。以下基于仓库README、文件结构及Notebook内容（包括您先前提供的代码细节）总结其主要方法与思路：</p><h4 id="1-总体思路"><a href="#1-总体思路" class="headerlink" title="1. 总体思路"></a>1. <strong>总体思路</strong></h4><ul><li><strong>问题定位</strong>：保险欺诈导致行业巨额损失，传统规则系统难以应对复杂模式。项目通过历史理赔数据提取行为特征，构建预测模型，实现自动化欺诈识别。</li><li><strong>核心路径</strong>：数据驱动的监督学习流程——从数据预处理到特征工程，再到多模型对比，最终选优（随机森林为主，扩展中考虑XGBoost）。</li><li><strong>创新点</strong>：强调比较研究（multi-model comparison），通过实证验证算法适用性；注重行为特征提取，以捕捉欺诈模式。</li><li><strong>适用性</strong>：适用于类不平衡、高维混合数据的保险场景，思路实用、可复现，强调集成学习的鲁棒性。</li></ul><h4 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. <strong>主要方法</strong></h4><ul><li><strong>数据来源与探索</strong>：<ul><li>数据：汽车保险历史交易记录（data文件夹，包含客户信息、事故细节、理赔金额等约39个特征）。</li><li>探索：pandas加载、描述统计、可视化（seaborn/matplotlib绘制分布、相关图），识别不平衡（欺诈样本稀少）。</li></ul></li><li><strong>预处理与特征工程</strong>：<ul><li>清洗：处理缺失值、异常。</li><li>编码：LabelEncoder处理类别变量（e.g., 性别、车型、事故类型）。</li><li>标准化：StandardScaler缩放数值特征。</li><li>特征构建/选择：计算新特征（如车辆年龄）；使用ExtraTreesRegressor评估重要性；扩展版删除低相关特征（e.g., injury_claim, age）。</li><li>分割：train_test_split（80/20）。</li></ul></li><li><strong>模型构建与对比</strong>：<ul><li>核心模型：RandomForestClassifier（n_estimators=100），集成决策树，处理非线性与噪声。</li><li>多算法对比（关键亮点）：10折KFold交叉验证评估7种传统模型：<ul><li>LogisticRegressionCV（逻辑回归，带CV）。</li><li>XGBClassifier（极端梯度提升）。</li><li>KNeighborsClassifier（K近邻）。</li><li>DecisionTreeClassifier（决策树）。</li><li>SVC（支持向量机，gamma=’auto’）。</li><li>RandomForestClassifier（随机森林）。</li><li>AdaBoostClassifier（自适应提升）。</li></ul></li><li>扩展版：特征优化后聚焦LR与XGB对比，验证稳定性。</li></ul></li><li><strong>评估与可视化</strong>：<ul><li>指标：accuracy（均值/标准差），扩展可补充AUC/Recall（欺诈任务关键）。</li><li>可视化：箱线图比较模型分布，方差小、均值高的模型（如RF/XGB）优选。</li><li>结论导向：集成模型（RF/XGB）通常最佳，鲁棒性强。</li></ul></li></ul><p>项目思路强调<strong>实证比较</strong>与<strong>实用性</strong>：先广义筛选模型，再优化特征，确保选出最适算法。适合实训扩展：添加不平衡处理（SMOTE）、更多指标（Recall/F1），或解释性分析（特征重要性）。</p><h3 id="文献综述的写作建议"><a href="#文献综述的写作建议" class="headerlink" title="文献综述的写作建议"></a>文献综述的写作建议</h3><p>文献综述需客观梳理领域进展、突出空白，为您的项目（随机森林+多模型对比）定位创新。长度1500-2500字，引用20-30篇（中外平衡，2015年后为主）。避免抄袭Khalil论文（您提供的PDF），改用类似主题不同引用。</p><h4 id="推荐结构（第2章）"><a href="#推荐结构（第2章）" class="headerlink" title="推荐结构（第2章）"></a>推荐结构（第2章）</h4><ol><li><strong>保险欺诈背景</strong>（300-500字）：经济影响、监管挑战。</li><li><strong>方法演进</strong>（500-800字）：从规则到ML，集成学习优势。</li><li><strong>传统ML实证应用</strong>（600-800字）：随机森林等在欺诈检测的表现，多模型对比研究。</li><li><strong>数据挑战与预处理</strong>（400-600字）：不平衡、特征工程策略。</li><li><strong>研究空白与本文定位</strong>（200-400字）：缺乏系统对比，您的项目填补。</li></ol><h4 id="写作要点"><a href="#写作要点" class="headerlink" title="写作要点"></a>写作要点</h4><ul><li><strong>引用来源</strong>：Google Scholar/CNKI搜索“insurance fraud detection machine learning”“汽车保险欺诈 随机森林”。</li><li><strong>关键文献示例</strong>（可替换）：<ul><li>Ngai et al. (2011)：欺诈检测综述。</li><li>Itri et al. (2019)：随机森林优于多算法。</li><li>Hanafy &amp; Ming (2021)：SMOTE不平衡处理。</li><li>Xia et al. (2023)：集成学习优势。</li></ul></li><li><strong>本文定位</strong>：您的项目通过7模型交叉验证对比，验证随机森林在汽车保险数据集的优越性，扩展预处理，提供实证参考。</li></ul><h4 id="示例段落（2-3节片段）"><a href="#示例段落（2-3节片段）" class="headerlink" title="示例段落（2.3节片段）"></a>示例段落（2.3节片段）</h4><p>传统机器学习算法在汽车保险欺诈检测中的应用已取得显著进展。多项研究证实随机森林在多算法对比中表现突出，例如Itri et al. (2019)测试10种模型，结果显示随机森林准确率最高。该优势源于其集成机制，能有效处理高维特征与非线性关系（Xia et al., 2023）。类似地，Nordin et al. (2024)比较树基模型，发现增强型算法在敏感性上领先。极端梯度提升（XGBoost）作为补充，亦在不平衡场景中展现竞争力（Jovanovic et al., 2022）。这些实证工作为本文的多模型对比实验提供了理论基础。</p><hr><h3 id="建议的章节结构与详细写作要点"><a href="#建议的章节结构与详细写作要点" class="headerlink" title="建议的章节结构与详细写作要点"></a>建议的章节结构与详细写作要点</h3><h4 id="第3章-研究方法（预计8-12页，是论文最重的章节）"><a href="#第3章-研究方法（预计8-12页，是论文最重的章节）" class="headerlink" title="第3章 研究方法（预计8-12页，是论文最重的章节）"></a>第3章 研究方法（预计8-12页，是论文最重的章节）</h4><p>3.1 数据集描述</p><ul><li>数据来源：说明数据集为公开的汽车保险理赔数据集（1000条记录，40个原始特征）。</li><li>目标变量：fraud_reported（Y/N，二分类，欺诈比例约25%）。</li><li>特征分类：数值特征（如months_as_customer、age、policy_annual_premium、total_claim_amount等）、类别特征（如policy_state、incident_type、auto_make等）、时间特征（如policy_bind_date、incident_date）。</li><li>数据基本统计：插入表格展示主要特征的描述性统计（均值、标准差、缺失率等）。</li><li>类不平衡问题：明确指出欺诈样本仅占25%，这正是需要特别关注的点。</li></ul><p>3.2 数据预处理</p><ul><li>缺失值处理：说明“？”被视为缺失，collision_type、property_damage、police_report_available等字段用“UNKNOWN”或模式填充。</li><li>类别变量编码：采用LabelEncoder或One-Hot Encoding（说明两种方式的取舍，Notebook中主要用了LabelEncoder）。</li><li>数值变量标准化：StandardScaler。</li><li>时间特征提取：从policy_bind_date和incident_date计算“保单持有时长”（months_as_customer已存在，可补充事故发生距离保单绑定时间等）。</li><li>其他清洗：删除无用列（如_c39、policy_number等）。</li></ul><p>3.3 特征工程与特征选择</p><ul><li>新特征构造：可补充（如总赔付金额占比、是否高额理赔、事故时间段划分等）。</li><li>特征重要性分析：展示ExtraTreesRegressor得出的特征重要性排名图（Notebook中有）。</li><li>特征选择：描述在“Fraud Detection _xtended.ipynb”中删除了10个低重要性或高相关性特征（如vehicle_claim、injury_claim、age等），并说明此举旨在降低维度、减少噪声。</li><li>强调这一步对应贡献1（系统性框架）和贡献2（公平对比前提）。</li></ul><p>3.4 类不平衡处理（关键补充点）</p><ul><li>说明原始实验未显式处理不平衡，因此准确率可能高估。</li><li>引入多种策略进行对比实验： （1）不处理（baseline） （2）随机欠采样 （3）SMOTE过采样 （4）类权重调整（class_weight=’balanced’）</li><li>说明这些策略将在第4章中与不同分类器组合进行评估（这是回应文献不足的重要创新点）。</li></ul><p>3.5 分类算法</p><ul><li>列出七种算法：Logistic Regression (LR)、K-Nearest Neighbors (KNN)、Decision Tree (DT)、Support Vector Machine (SVM)、Random Forest (RF)、AdaBoost、XGBoost。</li><li>简述每种算法原理与适用性（1-2句），特别强调RF的bagging机制和对不平衡数据的天然鲁棒性。</li></ul><p>3.6 实验设计与评估指标</p><ul><li>数据划分：80%训练、20%测试，随机种子固定。</li><li>交叉验证：10折CV（Notebook中已使用）。</li><li>评估指标： – Accuracy（整体准确率） – Precision、Recall、F1-score（特别关注Recall，因为漏掉欺诈成本高） – AUC-ROC（对不平衡数据更稳健）</li><li>超参数设置：说明使用了默认或简单网格搜索（如RF n_estimators=100）。</li></ul><h4 id="第4章-实验结果与分析（预计10-15页，核心实证章节）"><a href="#第4章-实验结果与分析（预计10-15页，核心实证章节）" class="headerlink" title="第4章 实验结果与分析（预计10-15页，核心实证章节）"></a>第4章 实验结果与分析（预计10-15页，核心实证章节）</h4><p>4.1 数据探索性分析</p><ul><li>插入特征分布图、欺诈与非欺诈在关键特征上的差异（如total_claim_amount、incident_severity等）。</li><li>相关性热力图。</li></ul><p>4.2 特征选择效果</p><ul><li>对比删除10个特征前后模型性能变化（Notebook中显示LR和XGB略有提升或持平）。</li><li>展示最终保留特征的重要程度排序。</li></ul><p>4.3 算法性能对比（无不平衡处理）</p><ul><li>插入Notebook中的算法比较箱线图。</li><li>表格列出10折CV的均值±标准差（Accuracy）。</li><li>分析：LR和XGB表现最佳，RF紧随其后；解释RF标准差较小（更稳定）。</li></ul><p>4.4 类不平衡处理策略的影响（关键创新部分）</p><ul><li>新增实验结果表格：不同不平衡处理策略下，各算法在Recall、F1、AUC上的表现。</li><li>重点分析： – SMOTE通常显著提升少数类Recall，但可能降低Precision。 – RF在多种策略下稳定性最好。 – 最终选择SMOTE + RF（或实际表现最好的组合）作为最优方案。</li><li>插入ROC曲线对比图、混淆矩阵。</li></ul><p>4.5 最优模型解释</p><ul><li>展示RF的特征重要性图。</li><li>解释前几名特征的业务含义（如total_claim_amount高、incident_severity严重、police_report_available=NO等更可能欺诈）。</li><li>这部分增强模型可解释性，回应保险行业实际需求。</li></ul><p>4.6 讨论</p><ul><li>与文献对比：本研究RF表现与Itri(2019)、Sahin(2013)等一致或更优。</li><li>解释为何RF综合最优：对噪声和不平衡鲁棒、特征重要性直观、训练快。</li><li>局限性前置：数据集规模小（仅1000条）、欺诈比例较高（现实中更低）、未使用深度学习等。</li></ul><h4 id="第5章-结论与展望"><a href="#第5章-结论与展望" class="headerlink" title="第5章 结论与展望"></a>第5章 结论与展望</h4><p>5.1 研究结论</p><ul><li>逐条对应第1章四个贡献点总结：<ol><li>成功构建了完整端到端框架。</li><li>多模型公平对比显示RF综合性能最优。</li><li>实证了SMOTE等不平衡处理策略的有效性。</li><li>提供了可复现的代码和方法路径。</li></ol></li></ul><p>5.2 实践意义</p><ul><li>为保险公司提供了一个低成本、高可解释性的欺诈检测方案，可直接嵌入现有理赔审核流程。</li></ul><p>5.3 研究局限</p><ul><li>数据集规模较小、来源单一。</li><li>未进行深度超参数调优。</li><li>未引入更新的集成方法（如LightGBM、CatBoost）或深度学习。</li></ul><p>5.4 未来研究方向</p><ul><li>在更大规模真实数据集上验证。</li><li>结合无监督异常检测（隔离森林等）构建混合模型。</li><li>探索可解释AI技术（如SHAP值）进一步提升模型透明度。</li><li>研究在线学习以适应欺诈模式漂移。</li></ul><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><hr><p>\cabstract{</p><pre><code>汽车保险领域正面临日益严峻的欺诈风险，导致行业经济损失巨大。为有效应对此类问题，本研究运用传统机器学习技术构建欺诈识别系统，提供了数据处理、特征提取以及模型构建的完整流程，采用汽车保险理赔数据集，进行相关实验，重点考察随机森林算法与其他分类器的性能对比，包括数据清洗、特征选择和不平衡处理。通过交叉验证和指标评估，结果显示优化后的随机森林模型在AUC和召回率方面表现出色。该研究验证了传统算法在实际场景中的可靠性，并为保险企业风险管理提供实用建议。</code></pre><p>}</p><p>% 中文关键词(每个关键词之间用”；”分开,最后一个关键词不打标点符号。)</p><p>\ckeywords{汽车保险欺诈；随机森林算法；传统机器学习；数据不平衡；特征提取；性能评估}</p><hr><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>保险业通过风险聚合与转移机制为社会经济活动提供安全保障，在全球经济运行中扮演着至关重要的角色。其庞大的资金池更是资本市场长期资本的重要来源之一（Barry &amp; Charpentier, 2020）。在财产保险领域，汽车保险覆盖面最为广泛并与日常生活紧密联系，构成了该领域的核心业务板块。其核心功能在于补偿车辆事故造成的经济损失，保障被保险人与第三方的权益，其稳健运营直接关系到千万家庭的财务安全与社会的稳定（Ngai et al., 2011）。保险公司、投保人、监管机构是这一生态的主要参与者，共同维系着市场的平衡。然而，这一平衡正受到日益猖獗的保险欺诈行为的严峻挑战。</p><p>汽车保险欺诈已成为一个全球性的顽疾，对行业的财务健康和社会的诚信体系造成持续性的损害。欺诈行为导致保险公司支付了本不应承担的赔款，这些巨大的“渗漏”最终会通过提高保费的形式转嫁给所有诚实投保人，破坏了保险的公平性原则（Viaene &amp; Dedene, 2004）。据美国反保险欺诈联盟（Coalition Against Insurance Fraud）的报告，保险欺诈每年给美国造成的损失高达数百亿美元，其中车险领域是重灾区。欺诈的成因复杂，一方面，信息不对称使得保险公司难以在承保和理赔环节完全掌握投保人的真实风险与行为；另一方面，技术的进步，特别是数字化理赔流程的普及，在提升效率的同时，也为新型、更隐蔽的欺诈手段提供了可乘之机（Brazel &amp; Webb, 2022）。这不仅侵蚀了保险公司的承保利润，还可能导致定价模型失真，扭曲风险信号，长期而言将削弱保险的风险分担功能和社会效益。</p><p>从广义上讲，保险欺诈是指任何以非法获取保险金为目的的故意行为。根据欺诈主体的不同，可分为保单持有人欺诈、第三方欺诈以及内部人员欺诈等。鉴于数据的可获得性与研究的可操作性，本文的研究焦点将集中于<strong>汽车理赔欺诈</strong>，即保单持有人或相关方在理赔环节，通过故意制造事故、夸大损失、伪造单据等手段骗取保险赔偿金的行为。这类欺诈是车险欺诈中最常见的形式，拥有相对丰富的公开研究数据基础，是应用数据驱动方法进行自动化检测的主要战场。</p><p>为应对欺诈威胁，保险公司正从依赖专家规则和人工审核，转向基于数据挖掘与机器学习（ML）的自动化检测系统。传统的规则引擎虽然解释性强，但难以捕捉复杂的非线性关系和新型欺诈模式。机器学习，特别是监督学习算法，能够从历史理赔数据中自动学习欺诈模式，展现出巨大潜力。在众多机器学习方法中，集成学习因其卓越的预测性能和鲁棒性而备受关注。以随机森林（Random Forest）为代表的集成算法，通过构建多棵决策树并综合其结果，能有效缓解单棵树的过拟合问题，对高维特征和非线性关系有良好的处理能力（Polikar, 2012）。更重要的是，保险欺诈数据天然具有高度不平衡性（正常理赔远多于欺诈理赔），而随机森林通过自助采样（Bootstrap sampling）和随机特征子空间选择，能在不均衡数据上构建多样化的基分类器，从而在一定程度上提升对少数类（欺诈）样本的识别能力（Xia et al., 2023; Phua et al., 2010）。</p><p>尽管机器学习在欺诈检测中的应用已取得丰硕成果，但现有研究仍存在一些有待深化之处。许多研究侧重于单一高级分类器（如XGBoost、深度神经网络）的性能比拼，而相对忽视了<strong>数据预处理阶段与分类模型的系统性整合与优化</strong>。特征工程、处理类别不平衡的重采样技术（如SMOTE、ADASYN）以及特征选择，对于最终模型性能的影响至关重要，有时甚至不亚于分类器本身的选择（Wang et al., 2021）。此外，在<strong>真实的汽车保险公开数据集</strong>上，对包含预处理流程在内的多种传统机器学习算法（如逻辑回归、支持向量机、决策树、随机森林、梯度提升树）进行端到端的、公平的对比实验研究相对有限，特别是深入探讨不同预处理技术如何与不同算法交互以提升欺诈检测性能的研究尚不充分。</p><p>鉴于此，本文旨在系统性地探索并验证一套结合了先进预处理技术与经典机器学习算法的汽车保险欺诈检测框架。具体而言，本研究将在公开的汽车保险理赔数据集上，以随机森林算法为核心检测模型，系统性地集成多种特征编码、不平衡数据处理（如过采样与欠采样）及特征选择方法，构建一个完整的分析管道。通过设计详尽的对比实验，本文将评估该集成框架相对于单一模型及其他主流机器学习算法（如逻辑回归、支持向量机、XGBoost）在欺诈检测准确率、召回率、F1分数等关键指标上的性能表现，从而为构建高效、实用的车险欺诈检测系统提供实证依据。</p><p>本文的主要贡献如下：</p><ol><li><p><strong>提出了一个系统性的欺诈检测分析框架</strong>：将数据处理、特征工程、不平衡学习、特征选择与随机森林分类器进行有机整合，形成了一个可复现、可评估的完整机器学习工作流，强调了预处理环节在模型构建中的基础性地位。</p></li><li><p><strong>进行了全面、公平的算法对比实验</strong>：在公开基准数据集上，对包括随机森林在内的多种传统机器学习算法，在统一的预处理标准和评估指标下进行了性能对比与分析，为算法选择提供了实证参考。</p></li><li><p><strong>深入探讨了不平衡数据处理策略的有效性</strong>：实证检验了多种重采样技术在缓解保险欺诈数据类不平衡问题上的作用，并分析了其与不同分类器结合时的性能变化规律。</p></li><li><p><strong>提供了结构化的方法学实现</strong>：研究过程注重方法论的清晰描述与代码的结构化，确保了实验的可复现性，为后续研究者提供了可直接借鉴的技术路径和比较基线。</p></li></ol><p>本文余下部分的结构安排如下：第2章将对保险欺诈检测，特别是基于机器学习的检测方法的相关文献进行综述；第3章将详细阐述本文所采用的研究方法，包括数据集描述、预处理技术、特征工程、使用的机器学习算法以及实验设计；第4章将展示并分析实验结果，对不同模型和策略的性能进行对比与讨论；第5章将总结全文，概括主要研究发现，指出本研究的局限性，并对未来研究方向提出展望。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p><strong>第2章 文献综述</strong></p><p>本章旨在回顾保险欺诈检测方法的技术演进，梳理传统机器学习算法在该领域的应用现状、优势与挑战，明确本研究的理论背景与创新点。</p><p>保险欺诈，特别是汽车保险理赔欺诈，是全球保险业面临的一项持续性重大挑战，其导致的直接财务损失高达年度保费的5%-10%，并通过提高保费的形式将成本转嫁给全体消费者，最终侵蚀保险的风险分摊机制与社会公信力（Viaene et al., 2005; Coalition Against Insurance Fraud, 2022）。传统的欺诈检测主要依赖于专家制定的规则引擎和人工审核，这些方法虽具可解释性，但规则僵化、更新滞后，难以应对日益复杂、动态演变的欺诈模式（Ngai et al., 2011）。随着保险业务的全面数字化，海量的理赔数据得以积累，为应用数据驱动的方法进行自动化、智能化欺诈检测提供了坚实基础。</p><p><strong>2.1 欺诈检测方法的演进</strong></p><p>保险欺诈检测方法的演进与信息技术发展紧密相连。最早的检测工作完全依赖具有领域经验的核保员和理赔调查员，效率低下且主观性强。随后，基于规则的专家系统（Rule-Based Systems）成为主流，通过将专家的反欺诈知识编码为“IF-THEN”规则，实现了初步的自动化（Bentley, 2000）。然而，规则系统存在明显局限：规则创建和维护成本高，难以覆盖所有欺诈场景；对新型、协同欺诈模式不敏感；且容易产生大量误报（false positives）。为克服这些缺点，研究人员自20世纪90年代末开始探索统计方法与数据挖掘技术的应用，标志着该领域向数据驱动范式的转变。</p><p>统计方法，如回归分析（逻辑斯蒂回归）、聚类分析（如K-Means）和异常检测，率先被引入。逻辑斯蒂回归能够量化各风险因素对欺诈概率的影响，提供了优于规则引擎的量化判别能力（Brockett et al., 2002）。聚类分析则用于识别理赔中的异常群体，而无需预先标记欺诈样本（Phua et al., 2010）。这些方法虽然比简单规则更灵活，但在处理高维、非线性、存在复杂交互关系的数据时，其表达能力仍显不足。21世纪初以来，机器学习，尤其是监督学习算法，凭借其强大的模式识别与预测能力，迅速成为欺诈检测研究的核心（West &amp; Bhattacharya, 2016）。监督学习通过从历史已标记（欺诈/非欺诈）的理赔数据中学习判别模式，构建预测模型，从而实现对新的未知理赔进行自动分类。这一范式成为当前学术研究与实际应用探索的主要方向。</p><p><strong>2.2 传统机器学习算法在保险欺诈检测中的应用</strong></p><p>在众多机器学习算法中，传统（或经典）机器学习算法因其模型相对简单、可解释性较好、计算效率较高，且在中小规模数据集上表现稳健，而在保险欺诈检测中得到了广泛研究和应用。</p><p>单一分类器，如决策树（Decision Tree, DT）、支持向量机（Support Vector Machine, SVM）、K最近邻（K-Nearest Neighbors, KNN）和朴素贝叶斯（Naive Bayes），在早期研究中被频繁使用。决策树因其类似规则系统的树状结构、易于理解而受到青睐，但单棵树容易过拟合且稳定性差（Baesens et al., 2015）。SVM通过寻找最优分类超平面，在高维空间中表现出色，但其性能对核函数和参数选择敏感，且训练复杂度高。为了克服单一模型的局限性，集成学习（Ensemble Learning）方法被引入并证明具有显著优势。集成方法通过构建并结合多个基学习器来完成学习任务，能够有效提升模型的泛化能力、稳定性和准确性（Polikar, 2012）。</p><p>随机森林（Random Forest, RF）和梯度提升决策树（Gradient Boosting Decision Tree, 如XGBoost、LightGBM）是两类最成功的集成算法。随机森林通过自助采样（Bootstrap）构建多棵决策树，并引入随机特征子空间，通过投票机制集成结果。研究表明，RF在保险欺诈检测任务中通常表现出优异的性能，其优势在于能有效处理高维特征、自动评估特征重要性、对缺失值和噪声不敏感，且不太容易过拟合（Sahin et al., 2013）。例如，Itri等人（2019）在汽车保险数据上比较了10种分类器，发现随机森林在准确率和AUC（曲线下面积）指标上均位列前茅。类似地，Xia等人（2023）的综述指出，基于树的集成模型在多种金融欺诈检测场景中 consistently 展现出鲁棒性。</p><p>梯度提升树（如XGBoost）则采用串行、加法模型的方式，通过迭代地修正前一轮模型的错误，通常能达到比随机森林更高的预测精度，但其计算成本更高，且更易过拟合，需要精细的参数调优（Chen &amp; Guestrin, 2016）。Jovanovic等人（2022）的研究表明，在精心调参和处理类不平衡后，XGBoost能在欺诈检测的召回率上取得领先。此外，逻辑回归因其模型简单、可解释性强，常被用作性能比较的基线模型（Bhattacharya et al., 2011）。</p><p><strong>2.3 多模型比较研究与算法选择策略</strong></p><p>鉴于保险数据的多样性（不同地区、不同产品线）和欺诈模式的差异性，没有一种算法能被完全的通用。因此，在特定数据集上进行多模型对比实验，以实证方式选择最优算法，成为该领域研究的一个关键环节和实用策略（Lessmann et al., 2015）。这类研究不仅提供了特定场景下的最优解，也增进了对不同算法特性与数据模式之间匹配关系的理解。</p><p>多数对比研究证实，集成方法（RF, XGBoost）通常优于单一模型（LR, DT, SVM）。例如，Nordin等人（2024）在比较多种树基模型后发现，随机森林在整体性能与稳定性上取得了最佳平衡。此类比较研究通常采用交叉验证来确保评估的可靠性，并综合考量准确率、精确率、召回率、F1分数和AUC等多个指标，因为欺诈检测任务对少数类（欺诈）的识别（高召回率）和控制误报（高精确率）往往需要权衡（Dal Pozzolo et al., 2015）。然而，现有研究在对比的广度与深度上仍存在差异。一些研究仅对比少数几种算法，或未对比较的算法进行系统的超参数优化，导致结论的普适性受限。此外，许多研究侧重于最终分类器的性能比拼，而将数据预处理和特征工程视为固定前置步骤，未深入探究不同预处理策略与不同分类器组合所产生的交互效应。</p><p><strong>2.4 数据不平衡与特征工程</strong></p><p>保险欺诈检测本质是一个极端类别不平衡的分类问题，欺诈案例通常仅占全部理赔的1%-10%。这种不平衡性导致分类器会倾向于预测多数类，从而使欺诈样本的识别率（召回率）极低（He &amp; Garcia, 2009）。</p><p>应对此挑战主要从数据和算法两个层面着手。</p><p>数据层面，重采样技术被广泛应用，包括随机过采样（复制少数类）、随机欠采样（删除多数类）以及合成少数类过采样技术（Synthetic Minority Over-sampling Technique, SMOTE）及其变体（如Borderline-SMOTE, ADASYN）（Chawla et al., 2002; Han et al., 2022）。<br>算法层面，则可通过代价敏感学习（为误分类欺诈样本设置更高的惩罚权重）或使用本身对不平衡不敏感的算法（如随机森林）来应对。</p><p>特征工程是提高模型性能的关键。原始保险数据包含大量类别型变量（如事故类型、车辆品牌）和数值型变量，常用特征包括：</p><ul><li>客户信息：年龄、教育水平、职业、爱好等</li><li>保单信息：保单类型、赔偿限额、年费等</li><li>事故详情：事故类型、严重程度、时间、地点等</li><li>理赔信息：理赔金额、受伤人数、车辆损坏情况等</li><li>时间特征：客户入会时长、事故时间等</li></ul><p>从原始数据中构造有判别力的新特征（如从投保日期和事故日期计算“保单持有期”），以及通过特征选择（如基于模型的特征重要性排序、过滤法）去除冗余或无关特征，以降低模型复杂度并可能提升性能（Zheng &amp; Casari, 2018）。然而，现有文献中，系统性地评估不同特征工程策略（特别是与特定分类器结合时）对最终欺诈检测性能影响的研究相对较少。</p><p><strong>2.5 可进一步探索的空间</strong></p><p>综上所述，尽管基于传统机器学习的保险欺诈检测研究已取得丰硕成果，尤其是以随机森林为代表的集成学习方法被证明有效，但仍存在一些探索空间：</p><p>许多研究虽然进行了多模型对比，但往往侧重于最终分类器的性能排名，缺乏一个<strong>从数据预处理、特征工程到模型训练与评估的完整、透明、可复现的端到端分析框架</strong>的详细展示，也需要在统一的数据处理流程、相同的交叉验证设置和全面的评估指标下，对一系列有代表性的传统机器学习算法进行广泛比较。再次，对于<strong>数据预处理策略（特别是处理类不平衡的方法）与分类器性能之间的交互影响</strong>，缺乏深入的实证分析。</p><p>本文将以一个公开的汽车保险理赔数据集为基础，构建一个系统化的分析流程，核心内容包括：（1）实施一套完整的预处理与特征工程方案；（2）在公平的实验设置下，系统对比包括逻辑回归、支持向量机、K近邻、决策树、随机森林、AdaBoost和XGBoost在内的七种传统机器学习算法的性能；（3）深入探讨随机森林算法在该任务中的优势及其原因；（4）实证分析不同的类不平衡处理策略对关键分类器性能的影响。本研究期望通过这些工作，为汽车保险欺诈检测的模型选择与工程实践提供一份实证参考与方法论范例。</p><hr><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>本章详细阐述本研究的实验框架，包括数据集来源、数据预处理、特征工程、类不平衡处理、分类算法选择以及实验设计。</p><h2 id="3-1-数据采集"><a href="#3-1-数据采集" class="headerlink" title="3.1 数据采集"></a>3.1 数据采集</h2><h4 id="3-1-数据集描述"><a href="#3-1-数据集描述" class="headerlink" title="3.1 数据集描述"></a>3.1 数据集描述</h4><p>本研究采用公开的汽车保险理赔数据集，该数据集源于Kaggle平台上的“Vehicle Insurance Claim Fraud Detection”，该数据集包含车辆数据集（属性、型号、事故详情等）以及保单详情（保单类型、期限等），目标是检测理赔申请是否存在欺诈行为。数据集包含1000条理赔记录，每条记录对应一笔完整的汽车保险理赔申请，共计40个原始特征变量。</p><p><a href="https://www.kaggle.com/datasets/shivamb/vehicle-claim-fraud-detection/data">https://www.kaggle.com/datasets/shivamb/vehicle-claim-fraud-detection/data</a></p><p>目标变量为“fraud_reported”，取值为“Y”（欺诈）或“N”（非欺诈），属于典型的二分类任务。</p><p>其中，欺诈样本占比约为25%（247条欺诈记录，753条非欺诈记录）</p><p class='item-img' data-src='Pasted%20image%2020260103140516.png'><img src="Pasted%20image%2020260103140516.png" alt=""></p><p>数据集特征可分为以下几类：</p><ul><li>客户个人信息：months_as_customer（客户时长）、age（年龄）、insured_sex（性别）、insured_education_level（教育水平）、insured_occupation（职业）、insured_hobbies（爱好）、insured_relationship（家庭关系）等。</li><li>保单信息：policy_state（投保州）、policy_csl（赔偿限额）、policy_deductable（免赔额）、policy_annual_premium（年保费）、umbrella_limit（伞状保险限额）等。</li><li>事故信息：incident_type（事故类型）、collision_type（碰撞类型）、incident_severity（事故严重程度）、incident_state（事故发生州）、incident_city（事故城市）、incident_hour_of_the_day（事故发生小时）、number_of_vehicles_involved（涉事车辆数）等。</li><li>理赔信息：total_claim_amount（总赔付金额）、injury_claim（人伤赔付）、property_claim（财产赔付）、vehicle_claim（车辆赔付）、bodily_injuries（受伤人数）、witnesses（目击证人数）等。</li><li>车辆信息：auto_make（车辆品牌）、auto_model（车型）、auto_year（车辆生产年份）等。</li></ul><p>描述性统计分析表明，数值型特征如total_claim_amount和vehicle_claim在欺诈与非欺诈样本间存在显著差异；类别型特征如incident_severity（尤其是“Major Damage”级别）以及police_report_available与欺诈标签的相关性较高。这些初步观察为后续特征工程提供了重要依据。</p><h2 id="3-2-数据预处理-Data-Preprocessing"><a href="#3-2-数据预处理-Data-Preprocessing" class="headerlink" title="3.2 数据预处理 (Data Preprocessing)"></a>3.2 数据预处理 (Data Preprocessing)</h2><p>在应用分类算法之前，必须对原始数据进行清洗和转换，以纠正错误并提高特征质量。本研究的预处理流程如图 1 所示，包括缺失值处理、特征衍生、编码转换及数据标准化。</p><h3 id="3-2-1-数据清洗与缺失值处理-Data-Cleaning-and-Imputation"><a href="#3-2-1-数据清洗与缺失值处理-Data-Cleaning-and-Imputation" class="headerlink" title="3.2.1 数据清洗与缺失值处理 (Data Cleaning and Imputation)"></a>3.2.1 数据清洗与缺失值处理 (Data Cleaning and Imputation)</h3><p>为了提高模型效率，本研究实施了以下清洗步骤：</p><ol><li><p><strong>标签转换</strong>：将目标变量 fraud_reported 转换为数值格式（“Y”映射为 1，“N”映射为 0）。</p></li><li><p><strong>噪声剔除</strong>：删除了对预测无统计意义的列，包括唯一标识符（policy_number, insured_zip）、高基数类别特征（incident_location）以及全空列（_c39）。</p></li><li><p><strong>隐性缺失值处理</strong>：识别出数据中以“?”标识的缺失值，主要分布在 collision_type、property_damage 和 police_report_available 中。对于类别变量，采用众数填充或将其视作独立类别；对于数值变量，结合业务逻辑将缺失标记映射为 0（如警察报告不可用）。</p></li></ol><h3 id="3-2-2-特征工程与衍生变量-Feature-Engineering"><a href="#3-2-2-特征工程与衍生变量-Feature-Engineering" class="headerlink" title="3.2.2 特征工程与衍生变量 (Feature Engineering)"></a>3.2.2 特征工程与衍生变量 (Feature Engineering)</h3><p>本研究通过特征挖掘构造了更具预测能力的变量：</p><ol><li><p><strong>车辆标龄 (Vehicle Age)</strong>：利用数据基准年份（2018）减去制造年份 auto_year 得到。车辆的物理折旧程度通常与保险欺诈风险具有更强的非线性相关。</p></li><li><p><strong>事故时段分箱 (Incident Discretization)</strong>：采用区间分箱法，将 0-23 小时的连续变量 incident_hour_of_the_day 转化为七个离散时段（如凌晨、清晨、晚间等）。通过这种离散化处理，模型能够更好地识别特定高风险时间段内的欺诈模式。</p></li></ol><h3 id="3-2-3-特征编码与标准化-Encoding-and-Standardization"><a href="#3-2-3-特征编码与标准化-Encoding-and-Standardization" class="headerlink" title="3.2.3 特征编码与标准化 (Encoding and Standardization)"></a>3.2.3 特征编码与标准化 (Encoding and Standardization)</h3><p>由于大多数机器学习模型无法处理非数值型数据，本研究采用了以下编码策略：</p><ol><li><p><strong>独热编码 (One-Hot Encoding)</strong>：针对 policy_state、insured_occupation 等无序类别特征，将其转化为哑变量。</p></li><li><p><strong>标签编码 (Label Encoding)</strong>：针对具有潜在顺序或二元属性的特征应用标签编码。</p></li><li><p><strong>特征标准化</strong>：在进行多模型性能对比实验前，采用 StandardScaler 对连续型数值特征进行标准化处理，使各特征服从均值为 0、标准差为 1 的分布，消除量纲差异对逻辑回归（LR）、支持向量机（SVM）等模型的影响。</p></li></ol><h3 id="3-2-4-数据划分-Data-Splitting"><a href="#3-2-4-数据划分-Data-Splitting" class="headerlink" title="3.2.4 数据划分 (Data Splitting)"></a>3.2.4 数据划分 (Data Splitting)</h3><p>预处理完成后，数据集按 <strong>80% 训练集</strong>和 <strong>20% 测试集</strong>的比例进行随机划分。训练集用于模型学习和超参数调整，而独立的测试集则用于通过准确率、召回率（Recall）及 AUC 等指标评估系统的鲁棒性。</p><hr><h3 id="第4章-实验结果与分析"><a href="#第4章-实验结果与分析" class="headerlink" title="第4章 实验结果与分析"></a>第4章 实验结果与分析</h3><p>本章呈现实验结果，并对模型性能、不平衡处理效果及特征贡献进行深入分析。</p><h4 id="4-1-数据探索性分析"><a href="#4-1-数据探索性分析" class="headerlink" title="4.1 数据探索性分析"></a>4.1 数据探索性分析</h4><h4 id="4-2-特征选择效果"><a href="#4-2-特征选择效果" class="headerlink" title="4.2 特征选择效果"></a>4.2 特征选择效果</h4><h4 id="4-3-算法性能对比"><a href="#4-3-算法性能对比" class="headerlink" title="4.3 算法性能对比"></a>4.3 算法性能对比</h4><h4 id="4-4-XXX策略的影响"><a href="#4-4-XXX策略的影响" class="headerlink" title="4.4 XXX策略的影响"></a>4.4 XXX策略的影响</h4><h4 id="4-5-最优模型解释"><a href="#4-5-最优模型解释" class="headerlink" title="4.5 最优模型解释"></a>4.5 最优模型解释</h4><h4 id="4-6-讨论"><a href="#4-6-讨论" class="headerlink" title="4.6 讨论"></a>4.6 讨论</h4><h3 id="第5章-结论与展望-1"><a href="#第5章-结论与展望-1" class="headerlink" title="第5章 结论与展望"></a>第5章 结论与展望</h3><h4 id="5-1-研究结论"><a href="#5-1-研究结论" class="headerlink" title="5.1 研究结论"></a>5.1 研究结论</h4><h4 id="5-2-实践意义"><a href="#5-2-实践意义" class="headerlink" title="5.2 实践意义"></a>5.2 实践意义</h4><h4 id="5-3-研究局限"><a href="#5-3-研究局限" class="headerlink" title="5.3 研究局限"></a>5.3 研究局限</h4><h4 id="5-4-未来方向"><a href="#5-4-未来方向" class="headerlink" title="5.4 未来方向"></a>5.4 未来方向</h4><hr><p>infrence</p><hr><h1 id="通过集成机器学习和统计方法提升保险欺诈检测准确性"><a href="#通过集成机器学习和统计方法提升保险欺诈检测准确性" class="headerlink" title="通过集成机器学习和统计方法提升保险欺诈检测准确性"></a>通过集成机器学习和统计方法提升保险欺诈检测准确性</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>保险业在全球风险管理和提供金融安全方面发挥着关键作用。然而，该行业面临诸多挑战，特别是欺诈活动日益复杂化。为应对这些挑战，本研究旨在通过集成特征离散化、特征选择、数据重采样和二元分类等方法构建合适的决策模型，以创建用于识别保险欺诈的预测系统。本研究探讨了各种场景，包括不同分类器、特征选择方法、特征离散化技术和数据重采样策略的组合，并使用已建立的指标评估预测系统的性能。实验结果表明，在数据预处理阶段集成多种方法显著提升了分类模型的性能。采用KBD+RFE+Over+RF场景的模型实现了最高的AUC和F1分数，表明其在检测保险欺诈方面表现出色。本研究证明，通过利用重采样方法，提出的模型预测保险欺诈的能力得到显著增强，并强调了这些技术在提升所用集成人工智能技术效率方面的作用。此外，本文得出结论，保险业可以通过现代预测方法极大地受益，从而做出明智决策。</p><p><strong>关键词</strong> 分类 · 数据挖掘 · 特征离散化 · 保险欺诈 · 不平衡数据 · 机器学习 · 预测系统</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>保险业是全球金融环境中不可或缺的组成部分，在风险管理和提供金融安全方面发挥着关键作用。保险业的基本原则是减轻金融损失或风险的可能性。保险部门由多个重要参与者组成，包括保险公司、被保险人、中介机构和监管当局（Khalil et al., 2022a）。</p><p>保险公司面临着由动态经济、技术和监管因素塑造的复杂环境中的重大挑战。其中最关键的挑战之一是欺诈活动的增加，由先进技术和全球通信网络驱动，导致全球每年金融损失达数十亿美元（Akhtar et al., 2023）。这些欺诈活动不仅影响保险公司的盈利能力，还影响其定价策略以及提供的整体社会经济效益（Wang &amp; Xu, 2018）。</p><p>为应对这些挑战，保险公司必须实施强有力的欺诈检测和预防措施，因为保险欺诈占其运营成本的很大一部分。除了与欺诈相关的挑战外，保险公司还面临运营困难，由于内部程序和系统的日益复杂性，这可能阻碍效率提升并阻碍数据分析和人工智能（AI）在风险评估和理赔处理中的集成（Hassan &amp; Abraham, 2013; Singh &amp; Chivukula, 2020）。因此，采用主动和灵活的方法对于确保在不确定性和变化面前的韧性、金融稳定性和创新至关重要（Khalil et al., 2024b）。《牛津英语词典》（Pearsall, 1999）将欺诈定义为“故意欺骗他人以获得金融或个人利益的行为”。保单持有人欺诈是保险欺诈的四种不同类别之一，由于其他类型欺诈的可用数据有限，本文将重点关注此类别。</p><p>数据挖掘在保险业中广泛应用，用于欺诈检测、理赔分析、承保处理、风险评估和销售预测，因为它经常用于从海量数据中提取和揭示隐藏的洞察（Turban, 2011）。数据挖掘涉及从数据中发现统计上可靠的、以前未知的且可操作的洞察。数据必须具备可访问性、相关性、充分性和完整性。在理赔分析中使用集成算法有助于保险公司提升对理赔备案的理解并识别欺诈实例（Prasasti et al., 2020）。</p><p>集成学习方法被广泛认可为一个突出的研究领域，它适应性强并适用于各种机器学习（ML）应用，如分类、回归，甚至无监督学习（Alsuwaillem et al., 2023）。它们的出色性能源于其提升模型泛化能力、减轻过拟合以及在单个模型可能挣扎的情况下改善性能的能力。集成学习方法可以大大提升预测准确性，但也带来了计算复杂性和模型可解释性的挑战（Khalil et al., 2022b; Piovezan et al., 2023）。集成学习是一种基本技术，旨在改善ML模型的性能。它为解决各种领域的复杂问题提供了一种强大且灵活的方法（Das et al., 2021）。</p><p>预测系统通常由不同的数据挖掘方法支持，如数据重采样、特征离散化和特征选择，在识别风险方面发挥关键作用。通过选择相关特征子集，计算成本降低，模型的效率和可理解性大大提升（Gupta et al., 2022）。此外，数据集不平衡（即正负实例分布不均）可能影响预测算法的精度。在这种情况下，通过数据重采样可以提升模型的整体性能（Baesens et al., 2021; Subudhi &amp; Panigrahi, 2018）。回顾保险欺诈文献显示，缺乏将上述数据挖掘策略与AI分类器（如集成和经典ML方法）集成到一个统一处理程序中来开发保险欺诈分类模型的研究。</p><p>本研究旨在通过创建多样化的检测场景来开发一个鲁棒的预测系统，使用数据重采样、特征离散化、特征选择以及不同分类器的组合。该预测系统的重点是识别保险欺诈，使用从保险公司获得的真实数据集进行验证。本研究通过利用两个不同的数据集（保险欺诈数据集和保险理赔数据集）评估预测准确性。根据对文献的批判性回顾，保险领域存在一个当前研究尚未填补的重大差距。</p><p>因此，本研究的主要贡献如下：首先，本研究介绍了主要进展，其特征是通过引入不同的场景，使用不同的分类器，特别是采用两种不同的特征选择方法、特征离散化和三种不同的数据重采样策略。总体目标是开发一个精确且鲁棒的保险欺诈检测预测系统。其次，调查了在二元分类结果上应用离散化后跟特征选择的影响。第三，评估重采样技术对二元分类结果的影响。第四，在两个不同的数据集上实际实施提出的预测系统以确认其有效性，并公开提供代码。最后，使用四个公认的指标（准确性、敏感性（召回率）、F1分数、精度和AUC）对各种检测场景的性能差异进行彻底评估和比较。除了这些评估指标，还使用统计分析来确定所提出数据集的最有利场景。</p><p>本文的其余部分概述如下：第2节简要介绍先前研究。第3节详细说明研究方法，包括研究设计、数据收集方法、描述本研究中用于检测保险欺诈的具体技术和方法，以及评估指标。第4节呈现和分析发现。最后，在第5节中呈现结论。</p><h2 id="2-文献综述"><a href="#2-文献综述" class="headerlink" title="2 文献综述"></a>2 文献综述</h2><p>长期以来，保险公司发现有充分理由在其运营中采用主动和灵活的方法，以实现其长期和短期目标，并有效应对风险预测、欺诈检测、理赔分析和定价策略等复杂挑战，以维持金融稳定并在不断变化的环境中取得成功（Barry &amp; Charpentier, 2020）。Turban（2011）将数据挖掘定义为通过应用数学、统计、人工智能和ML技术从大型数据库中提取有价值洞察的方法。</p><p>保险欺诈仍然是一个普遍挑战，每年导致行业损失数十亿美元，需要强大的监管框架、跨市场合作和先进分析工具。学术和行业研究强调国家保险专员协会（NAIC）作为标准化反欺诈措施的关键机构，通过模型法，如其特别调查单位（SIU）指南，该指南要求保险公司遵守和数据共享协议（NAIC, 2022; Saylor, 2023）。例如，Hoyt et al.（2006）分析了汽车保险欺诈数据，发现反欺诈法律的结果喜忧参半。强制SIU和重罪分类减少了欺诈，但强制向执法部门报告增加了欺诈，表明在取代私人努力时效率低下。每年850亿美元的欺诈问题也受到立法以外的市场特定因素的显著影响。这些发现突出了针对性反欺诈措施的必要性。</p><p>此外，Saylor（2023）的研讨会论文考察了机会主义汽车保险欺诈，强调其普遍性、经济影响和检测挑战。该研究强调机会主义欺诈占保险欺诈的很大一部分，但往往被忽视，转而关注高调的“硬”欺诈案例。使用中和理论，Saylor分析了犯罪者如何证明欺诈（例如，否认责任或受害者身份），并提出威慑策略，包括公众意识运动、增强理赔处理程序和机构间合作。主要建议重点激活内部道德控制并改善行业工具，如ISO数据库。（Aivaz et al., 2024）通过文献计量分析经济欺诈研究趋势，确定美国和中国为主要贡献者。主要发现突出对数字检测工具（AI、区块链）和社会经济影响的日益关注。该研究揭示了出版物增加但引用影响下降，表明需要更具影响力的研究。</p><p>保险公司和数据挖掘研究人员在保险数据中遇到各种障碍，包括数据可用性、数据质量和缺失值问题。此外，他们还面临不平衡数据集和模型选择的可解释性问题（Cappiello, 2020）。因此，在保险领域进行了众多研究，使用各种方法。例如，Bhowmik（2011）提出了一种使用基于决策树（DT）和朴素贝叶斯分类的算法检测汽车保险欺诈的策略，并使用规则基于分类、决策树可视化和贝叶斯朴素可视化等程序分析预测。结果显示这些方法在识别汽车保险欺诈方面的表现良好。Dhieb et al.（2019, 2020）利用ML技术自主检测和分类机动车保险欺诈理赔，并包括识别可疑理赔的警报机制。</p><p>进一步，Kowshalya和Nandhini（2018）使用数据挖掘技术预测保险费和欺诈理赔，减少了理赔分析的时间。他们基于汽车保险欺诈研究生成合成数据集，以开发用于检测虚假理赔的分类算法。Itri et al.（2019）开发了一种新方法，通过测试（10）ML算法来改善欺诈预测准确性，以确定哪些最有效和可靠。使用汽车保险理赔数据，该研究显示随机森林在预测欺诈方面优于所有其他算法。Subudhi和Panigrahi（2020）引入了一种基于GA的模糊C均值（FCM）聚类与监督分类器相结合的方法，用于检测汽车保险理赔欺诈，在真实数据上证明了其效率。Nordin et al.（2024）比较了传统和ML模型用于预测汽车保险欺诈，发现树增强朴素贝叶斯（TAN）模型在准确性和敏感性方面优于其他。该研究强调了ML在检测欺诈方面的有效性，并建议改善数据准备和模型设置以获得更好结果。</p><p>另一方面，研究人员努力通过解决数据质量问题（如不平衡数据和缺失值）以及优化机器学习模型参数来改善不同领域的欺诈预测，以获得更好的性能。各种方法已被建议并用于文献中，以解决不平衡和缺失值分类挑战，当涉及到为保险欺诈检测建模获取高质量数据时。例如，Sundarkumar et al.（2015）采用随机欠采样重采样方法结合概率神经网络（PNN）、DT、SVM、逻辑回归（LR）和数据处理组方法（GMDH）。研究发现DT模型在欺诈检测中具有最高效能。同样，Hassan和Abraham（2016b）采用随机欠采样结合DT、NN和SVM模型。他们的发现表明DT模型表现出最高性能。Wang和Chen（2020）提出了一种三向集成方法，用于处理缺失数据，通过分组没有缺失值的对象并用每个组的平均属性填充空白。尽管从UCI ML存储库的实验证明了其有效性，但该方法缺乏处理缺失值的全面策略。</p><p>Hanafy和Ming（2021）研究了九种SMOTE家族方法，以解决预测保险费违约的不平衡数据。他们使用13个机器学习分类器评估这些技术，结果显示在应用SMOTE技术后分类器性能显著改善。Jovanovic et al.（2022）使用ML和组搜索萤火虫算法改进信用卡欺诈检测。使用欧洲信用卡交易的真实、不平衡数据集来调整极端梯度提升的SVM。在合成少数过采样扩展数据集后，该研究发现调整模型在准确性、召回率、精度和曲线下面积方面优于其他领先方法。Tayebi和Kafhali（2024）使用元启发式算法如遗传算法、粒子群优化和人工蜂群来优化信用卡欺诈检测中ML模型的超参数。这些方法在准确性、召回率和计算经济方面优于网格搜索，特别是对于不平衡数据集。</p><p>基于对可用研究的全面分析，本研究旨在填补现有文献中的空白，通过进行彻底分析一个统一的框架来处理数据集并开发用于检测保险欺诈的分类模型。鉴于这一研究空白，不清楚在数据集处理期间集成推荐的方法和技术是否能改善分类模型。本研究还优先考虑积极结果，并开发方法来解释特定预测以改善模型可解释性。</p><h2 id="3-提出的计算方法"><a href="#3-提出的计算方法" class="headerlink" title="3 提出的计算方法"></a>3 提出的计算方法</h2><p>在本节中，我们呈现了构建鲁棒保险欺诈检测系统的计算方法。我们的方法旨在通过集成不同的AI分类器与数据挖掘技术（如特征离散化、特征选择和重采样）来呈现不同的欺诈检测系统，以解决特征重要性和不平衡数据等挑战。通过概述要采用的具体步骤和技术，我们旨在实现鲁棒且可重复的结果，从而贡献于保险领域的进步。</p><p>提出的方法结构化以确保计算任务的系统性和高效处理。我们从预处理阶段开始，如数据收集或预处理。随后，我们详细说明连续变量的离散化、SelectKbest（Kbest）和递归特征消除（RFE）技术用于特征选择、三种不同的数据重采样策略以及不同的分类器。然后，我们使用四个公认的评估指标（准确性、敏感性（召回率）、F1分数、精度和AUC）评估提出的系统的性能。这些阶段中的每一个都被视为对提出的系统整体有效性的必需。</p><p>此外，我们强调了我们方法的适应性，它允许可扩展性和适用于一系列数据集或保险领域内的场景。这种灵活性使我们能够有效地应对数据特征和研究要求的变化，从而提升我们发现的泛化能力。系统涉及的程序的视觉表示描绘在图1中，它作为本研究上下文中保险欺诈检测的框架。</p><h3 id="3-1-数据收集"><a href="#3-1-数据收集" class="headerlink" title="3.1 数据收集"></a>3.1 数据收集</h3><p>在本分析中，使用两个不同的数据集来评估提出的系统的准确性。本研究的数据集从Kaggle.com获得。数据集中的目标变量不同。在第一个数据集中，我们实施提出的系统来检测汽车保险部门的保险欺诈，因此目标特征是“欺诈报告”列。在第二个数据集中，我们为汽车保险部门的理赔分析实施提出的系统，因此目标特征是“理赔标志”列，该列指示是否提交了理赔。图2显示两个数据集中的目标变量是分类的。因此，使用分类系统进行分析。图3显示数据集中的目标变量分布。在欺诈数据集中，非欺诈和欺诈理赔的比例为94–6%。</p><p>数据集在欺诈汽车保险理赔上有15,419个实例，其中923个被分类为欺诈，显示数据分布中显著的类不平衡。数据集中的每个理赔由32个不同的属性定义，如表1中所列。保险理赔数据集包含10,302个汽车保险理赔，其中2,746个被分类为理赔提交，突出了显著的类不平衡。数据集中的每个理赔由26个唯一属性定义，如表2中所概述。</p><p>本研究使用的两个数据集在大小、标签分布和缺失数据程度方面存在显著差异。第一个数据集专注于汽车保险部门中的欺诈理赔，更大，有15,419条记录，并表现出高度不平衡，其中只有6%的理赔被标记为欺诈，剩余94%为非欺诈。相比之下，第二个数据集分析是否提交了理赔，包含10,302条记录，不平衡程度较轻，有26.7%的理赔标记为提交，73.3%为非提交。此外，缺失数据在两个数据集之间显著不同。在第一个数据集中，单个特征中缺失值的最高百分比达到45.7%（补充数量），最低为0.35%（事故政策天数）。相反，第二个数据集的缺失数据范围较低，职业特征的最大值为6.45%，年龄特征的最小值为0.07%。这些差异突出了需要定制数据处理方法来解决每个数据集的独特类分布和数据完整性问题。</p><h3 id="3-2-数据预处理"><a href="#3-2-数据预处理" class="headerlink" title="3.2 数据预处理"></a>3.2 数据预处理</h3><p>分类方法应用的最重要步骤之一是数据预处理，这也在图1的初始阶段中说明。因为数据可能包含多个错误，所以必须在任何未来操作之前处理数据。因此，此阶段涉及基本的数据处理任务，如填充缺失值、数据评分、特征编码、数据离散化和将数据分为训练和测试数据集。</p><h4 id="3-2-1-数据清洗和编码"><a href="#3-2-1-数据清洗和编码" class="headerlink" title="3.2.1 数据清洗和编码"></a>3.2.1 数据清洗和编码</h4><p>为了提升数据集的效率和质量，使用数据清洗来查找和修复错误、损坏和缺失信息。这使得分析和分类模型更有效（Cerda &amp; Varoquaux, 2022; Li et al., 2021）。首先，根据数据集，特征缺失值要么完全删除，要么更改其缺失值。在我们的研究中，我们从第一个数据集删除了两个特征（X21, X27），因为它们具有高百分比的缺失值，如表3所示。对于两个数据集中的剩余特征，对于二元和类别变量中的缺失值，使用列值的模式填充。相反，对于所有连续变量中的缺失值，使用列值的均值填充。</p><p>对于目标变量，为了找到与它高度多重共线性的特征，我们检查了相关矩阵和方差膨胀因子（VIF）分析。此策略减少了多重共线性。在数据集（2）中，由于X23特征与目标变量的相关性显著，此策略很重要，以改善模型的预测准确性并保证剩余变量提供清晰且可解释的洞察与目标变量的关系。</p><p>数据编码是预处理的重要部分，它是将原始数据转换为可以被算法和统计模型使用的数值表示。例如，我们将类别特征转换为数值格式，如将被保险人的性别分配为“1”表示“男性”和“0”表示“女性”。</p><h4 id="3-2-2-离散化方法"><a href="#3-2-2-离散化方法" class="headerlink" title="3.2.2 离散化方法"></a>3.2.2 离散化方法</h4><p>离散化算法是机器学习、数据挖掘和统计分析中数据预处理的基本组成部分。将连续变量转换为离散变量简化了分析和算法应用。离散化有几个原因。首先，许多机器学习方法需要离散输入，因此必须转换连续数据。通过分组相似值，离散化简化了解释。连续变量的不同离散化方法有优缺点。使用无监督和监督方法。无监督方法如等宽和频率分箱按分布分离数据。然而，监督方法如基于决策树的离散化和基于熵的分箱使用类标签或目标变量来指导离散化。</p><p>在本研究中，我们采用了KBinsDiscretizer（KBD）方法。KBD方法使用分箱技术将连续变量转换为离散箱，从而使需要分类输入的模型中使用连续数据。此方法可以改善清晰度、减少计算复杂性，并潜在地提升机器学习算法的效率，特别是那些受输入数据特性影响的算法。</p><h3 id="3-3-特征选择技术"><a href="#3-3-特征选择技术" class="headerlink" title="3.3 特征选择技术"></a>3.3 特征选择技术</h3><p>特征选择（FS），也称为属性选择或变量子集选择，是一个广泛用于减少特征空间维度的技术，同时保持给定方法的性能。特征选择呈现了一个复杂挑战，因为需要互补特征来处理交互和冗余。FS的目标是识别和消除与学习过程无关或冗余的特征。FS的主要目标是通过提升准确性和方法的效率和可理解性来改善学习性能（A. Singh &amp; Jain, 2019）。因此，需要更有效的全局搜索技术来有效解决特征选择。在本研究中，我们采用了两种不同的特征选择技术。</p><h4 id="3-3-1-Select-K-Best"><a href="#3-3-1-Select-K-Best" class="headerlink" title="3.3.1 Select K Best"></a>3.3.1 Select K Best</h4><p>SelectKBest与ANOVA F值是一种单变量选择方法。在此方法中，通过消除无关特征来对特征进行排名。排名由每个特征与目标变量之间的关联计算的统计分数确定（Visalakshi &amp; Radha, 2014）。它通过计算每个特征与目标变量之间的ANOVA F值来选择K个最佳特征。具有更高F值的特征被认为与目标变量更相关。此方法在处理许多特征时特别有用，并且计算效率高。然而，它不考虑特征之间的交互，并且K的选择需要仔细确定以平衡模型性能和维度减少。K是用于特征选择的顶级特征数量（Srivatsan &amp; Santhanam, 2021）。</p><h4 id="3-3-2-递归特征消除（RFE）与随机森林分类器"><a href="#3-3-2-递归特征消除（RFE）与随机森林分类器" class="headerlink" title="3.3.2 递归特征消除（RFE）与随机森林分类器"></a>3.3.2 递归特征消除（RFE）与随机森林分类器</h4><p>递归特征消除（RFE）是一种通过迭代从数据集中移除特征的选择特征的方法。RFE在此场景中与随机森林分类器作为估计器一起使用。该技术最初使用所有特征训练模型，然后评估每个特征的重要性（Lakshmanarao et al., 2022; Visalakshi &amp; Radha, 2014）。算法消除最不重要的特征并迭代此过程，直到达到所需特征数量。利用随机森林分类器与递归特征消除（RFE）对于通过随机森林模型生成的重要性分数来确定最重要特征是有效的。所用的分类器可以影响所选特征，并且要选择的特征数量必须仔细调整以提升模型性能（Visalakshi &amp; Radha, 2014）。</p><h3 id="3-4-重采样方法"><a href="#3-4-重采样方法" class="headerlink" title="3.4 重采样方法"></a>3.4 重采样方法</h3><p>不平衡数据问题在许多数据集中普遍存在，导致偏差分类器模型无法对少数类做出准确预测（Kotsiantis et al., 2006）。因此，解决不平衡数据问题是必不可少的。已开发了各种方法来解决此问题，其中一种最成功的涉及使用基于采样的技术，如随机过采样和随机欠采样（Basit et al., 2022; Zhang et al., 2024）。表4显示了每个重采样方法的基本属性。</p><h3 id="3-5-分类器模型"><a href="#3-5-分类器模型" class="headerlink" title="3.5 分类器模型"></a>3.5 分类器模型</h3><p>在提出的工作中，我们采用了不同的经典ML和集成学习分类器模型，即决策树（DT）、随机森林（RF）、AdaBoost、梯度提升（GB）和Bagging。认识到任何ML模型的性能取决于分配给其参数的具体值。</p><h4 id="3-5-1-决策树（DT）"><a href="#3-5-1-决策树（DT）" class="headerlink" title="3.5.1 决策树（DT）"></a>3.5.1 决策树（DT）</h4><p>DT是一种灵活且可解释的分类技术，它通过递归划分数据，选择最佳分离特征到同质子集，最大化类标签纯度，直到达到停止标准，形成用于新预测的模型（Bansal et al., 2022）。它的优势在于捕捉复杂、非线性关系并处理各种数据类型，使其在许多分析场景中有用。然而，决策树容易过拟合，因为它们可以记忆训练数据，这会导致对新数据的泛化能力差，而不进行正则化。它们也对训练集的细微变化敏感，这会影响它们的预测，因此仔细的参数调整和集成方法对于最佳性能至关重要（Bansal et al., 2022）。</p><h4 id="3-5-2-随机森林（RF）"><a href="#3-5-2-随机森林（RF）" class="headerlink" title="3.5.2 随机森林（RF）"></a>3.5.2 随机森林（RF）</h4><p>RF是一种集成学习技术，通过训练多个决策树并结合它们的预测来提升机器学习任务中的准确性和泛化能力。对于回归任务，它取单个树预测的平均值，而对于分类任务，它使用类预测的模式（Roy &amp; George, 2017）。RF高度准确且鲁棒，通常避免过拟合，即使在缺失数据的情况下也能表现良好，这使其在各种应用中可靠。然而，RF需要大量处理能力用于大型数据集，并且缺乏单个决策树的可解释性，尽管其在多样任务中的高性能使其成为机器学习中的宝贵工具（Roy &amp; George, 2017）。</p><h4 id="3-5-3-自适应提升（AdaBoost）"><a href="#3-5-3-自适应提升（AdaBoost）" class="headerlink" title="3.5.3 自适应提升（AdaBoost）"></a>3.5.3 自适应提升（AdaBoost）</h4><p>AdaBoost通过结合多个弱学习器并在每次迭代中调整误分类实例的权重来构建强分类器，这更关注困难案例，并允许后续学习器纠正先前错误，从而产生准确模型（Hassan &amp; Abraham, 2016a）。AdaBoost的优势在于其通过集成基分类器来改善弱学习器的能力，使其灵活且适应各种数据类型和问题领域。然而，AdaBoost的性能在噪声数据下可能受损，因为如果基分类器过于复杂或不稳定，它可能过拟合，这会影响其泛化。因此，其有效性取决于数据质量和分类器的简单性（Ben Jabeur et al., 2023）。</p><h4 id="3-5-4-梯度提升（GB）"><a href="#3-5-4-梯度提升（GB）" class="headerlink" title="3.5.4 梯度提升（GB）"></a>3.5.4 梯度提升（GB）</h4><p>GB是一种集成学习技术，通过顺序添加弱学习器（通常决策树）来构建强大预测模型，以减少先前模型的错误。此过程通过梯度下降优化损失函数，并创建高度准确的模型（Dhieb et al., 2019）。GB模型以其强性能、对异常值的鲁棒性和处理数值和分类数据的能力而闻名，这使它们在各种分类和回归任务中高度通用。然而，尽管有这些优势，GB可能过拟合，特别是如果正则化不足或学习率太高，其迭代且复杂的模型构建过程在大型数据集上可能计算密集（Liu et al., 2019）。</p><h4 id="3-5-5-Bagging"><a href="#3-5-5-Bagging" class="headerlink" title="3.5.5 Bagging"></a>3.5.5 Bagging</h4><p>Bagging是一种集成学习方法，通过在训练数据的随机子集上独立训练多个模型来减少方差，从而改善模型性能。通过捕捉模型间的数据变异性并通过平均（用于回归）或投票（用于分类）结合它们的预测，Bagging提升了准确性和泛化，并有效最小化过拟合并增加模型稳定性（Park &amp; Kwon, 2024）。其优势在于利用多样模型预测，这使其特别适用于复杂模型和大型数据集，通过优化性能和可扩展性。然而，Bagging可能无法改善低方差的稳定模型的结果，并且如果基模型或数据集本身有偏差，可能引入偏差。因此，评估模型稳定性和数据集特征对于使用Bagging实现最佳结果至关重要。</p><h3 id="3-6-分类准确性评估指标"><a href="#3-6-分类准确性评估指标" class="headerlink" title="3.6 分类准确性评估指标"></a>3.6 分类准确性评估指标</h3><p>评估指标是查找和比较最佳模型的关键组成部分，它评估分类器的效率。一个受欢迎的指标是准确性，它显示正确预测的百分比。更高的准确值表明分类器整体表现更好。虽然准确性很重要，但它可能不足以解决分类困难，特别是处理不平衡数据时（Hossin &amp; Sulaiman, 2015; Khalil et al., 2024a）。针对这一挑战，使用各种分类评估标准来评估分类器的性能。</p><script type="math/tex; mode=display">\text{Accuracy (AC)} = \frac{TP + TN}{TP + FP + TN + FN}, \quad (1)</script><script type="math/tex; mode=display">\text{Recall (RC)} = \frac{TP}{TP + FN}, \quad (2)</script><script type="math/tex; mode=display">\text{Precision (PR)} = \frac{TP}{TP + FP}, \quad (3)</script><script type="math/tex; mode=display">F1 - \text{Score F} = \frac{2 \times TP}{2 \times TP + FP + FN}, \quad (4)</script><p>其中TP表示真阳性，TN表示真阴性，FP是假阳性，FN是假阴性。</p><h2 id="4-预测分析和模型可解释性"><a href="#4-预测分析和模型可解释性" class="headerlink" title="4 预测分析和模型可解释性"></a>4 预测分析和模型可解释性</h2><p>在本节中，我们呈现了为解决前述部分概述的研究问题而进行的实验和结果，即在数据集处理期间集成推荐的方法和技术是否能改善分类模型。我们的研究旨在构建一个鲁棒的分类模型来检测保险欺诈。为实现这一目标，我们通过创建多样化的检测场景设计并实施了一系列实验，使用数据重采样、特征离散化、特征选择以及不同分类器的组合。</p><h3 id="4-1-实验设置"><a href="#4-1-实验设置" class="headerlink" title="4.1 实验设置"></a>4.1 实验设置</h3><p>实验在一台配备2.60 GHz Intel(R) Core (TM) i7-12700F CPU和32 GB RAM的机器上运行。我们使用64位Windows 11。Python用于实现框架。Pandas数据帧加载数据集。Scikit Learn（Pedregosa et al., 2011）库实现ML和集成模型。为确保实验模型、参数配置和报告结果的可再现性，我们在作者的GitHub网站³上公开提供了所提出工作的源代码、可视化和数据。</p><h3 id="4-2-实验设计"><a href="#4-2-实验设计" class="headerlink" title="4.2 实验设计"></a>4.2 实验设计</h3><p>在我们的研究中，我们旨在探索在统一框架中结合各种技术如何改善预测模型的构建，导致开发一个可靠的系统，用于准确检测保险欺诈。我们希望通过彻底的研究和实验确定这一集成策略在提升预测模型以及提升保险欺诈检测准确性和可靠性的有效性。</p><p>因此，我们的研究包括六个实验，每个实验都采用特定方法组合的不同场景，如图4所示。我们</p><p>³<a href="https://github.com/AhmedKhalil91/classification-model.git">https://github.com/AhmedKhalil91/classification-model.git</a>.</p><p>在每个实验中分析了各种条件，以理解它们的个别影响。六个实验的基础可以总结如下：</p><p>(a) 在第一个实验中，数据直接使用而不进行离散化、特征选择或不平衡问题处理，直接输入分类模型，然后使用准确性、F1分数和AUC-ROC等指标评估模型的性能。此基线评估作为比较各种预处理技术影响的参考点，在后续实验中。</p><p>(b) 第二个实验考察了在连续特征上应用KBD离散化方法的影响，然后修改的数据直接输入分类模型，然后评估模型的性能，以确定离散化如何影响模型学习，特别是相对于基线更有效地处理连续数据。</p><p>(c) 第三个实验探索了特征选择（Kbest和RFE）技术的使用，以减少特征空间并潜在提升模型性能。在应用特征选择后，数据直接输入分类模型，然后使用标准指标评估模型性能，以了解关注相关特征是否能提升准确性和减少过拟合。</p><p>(d) 第四个实验评估了KBD离散化后跟KBest和RFE特征选择的组合对分类性能的影响。在应用离散化和特征选择后的数据直接输入分类模型，然后评估模型的性能。此实验调查了离散化和特征选择之间的潜在协同作用在提升预测准确性和模型鲁棒性方面的作用。</p><p>(e) 在第五个实验中，分析了重采样（Under, Over和SMOTE）技术对分类器性能的影响，以处理数据集中的类不平衡。每个重采样方法单独应用以平衡训练集，模型使用重采样数据训练，然后重点识别哪个重采样方法最佳提升不平衡类情况下的结果。</p><p>(f) 最终实验涉及全面预处理方法，应用KBD离散化，后跟特征选择和重采样（欠采样、过采样和SMOTE）以解决类不平衡。然后使用处理后的数据训练分类模型，并使用指标评估其性能。此实验旨在展示集成多个预处理技术的累积益处及其对分类性能的整体影响。</p><h3 id="4-3-实验结果和讨论"><a href="#4-3-实验结果和讨论" class="headerlink" title="4.3 实验结果和讨论"></a>4.3 实验结果和讨论</h3><p>在本节中，我们提供对实验结果的全面检查，强调各种数据预处理技术对分类器性能的关键影响。实验遵循系统方法，从数据集预处理开始，将其分成80–20比例的训练和测试集，然后测试分类器在不同预处理场景下的表现。包括准确性、F1分数、召回率、精度和AUC在内的性能指标被记录，并在表5中详细说明。值得注意的是，对于不平衡数据集，AUC和F1分数优先于准确性，因为这些指标更好地解决类分布，并减少当一个类过度表示时的偏差。</p><p><strong>实验1</strong> 在没有数据变换的基线场景中，每个分类器被测试原始预测能力。结果显示决策树（DT）分类器以68.15%的AUC领先，其次是RF模型以52.14%的AUC分数在第一个数据集，而梯度提升（GB）在第二个数据集表现更好，实现了68.08%的AUC。这些分数反映了每个模型的基本效能，而没有来自数据变换的增强。</p><p><strong>实验2</strong> 该研究接下来调查了数据离散化对分类性能的影响，通过应用KBD技术于连续特征。KBD+DT的组合在第一个数据集上展示了显著改善，以69.89%的AUC，而KBD+GB在第二个数据集上以68.43%的AUC领先。这一AUC的增加表明数据离散化可以锐化分类器处理类区分的能力。</p><p><strong>实验3</strong> 为评估特征选择的影响，我们应用了两个方法，KBest和RFE。此实验使用减少特征集评估分类器分为两个场景。在第一个数据集，组合KBest+DT达到了最高的75.35%的AUC，超过基线，而KBest+GB在第二个数据集上以67.57%的AUC表现最佳。这些结果突出关注相关特征可以提升分类准确性通过减少噪声并聚焦于最信息丰富的属性。</p><p><strong>实验4</strong> 此实验集成了离散化和特征选择，在两个数据集上展示了增强的结果。具体来说，（KBD+KBest+DT）组合在第一个数据集达到了最高的77.34%的AUC，而（KBD+KBest+GB）在第二个数据集得分为67.89%。这些发现表明离散化和特征选择的组合通过同时减少维度并强调基本特征来加强模型。</p><p><strong>实验5</strong> 我们考察了三种重采样技术（欠采样、过采样和SMOTE）对分类器性能的影响在此实验中分为三个场景，旨在解决类不平衡。结果显示（Oversampler+RF）组合在分类器中展示了最高性能，以95.5%的AUC在第一个数据集和88.17%在第二个数据集。这些结果确认重采样方法，特别是过采样，可以通过平衡类分布并使模型从少数类学习更有效地显著改善模型性能。</p><p><strong>实验6</strong> 此最终实验评估了离散化、特征选择和重采样的组合影响于分类器效能。六个场景被测试，揭示（KBD+RFE+Over +RF）组合实现了最高的99.26%的AUC分数在第一个数据集和89.29%在第二个数据集。这一结果标志着对其他场景的实质改善，表明集成所有三种预处理技术是最大化分类器准确性和可靠性在类区分中的强大策略。</p><p>为了提供清晰和简洁的概述，表6和7总结了这一比较，聚焦于AUC分数和F1分数作为选择每个实验中顶级表现场景的主要指标。此指标量化了模型区分类的能力，使能够有效识别展示在类不平衡情况下优越区分力的模型。</p><p>结果显示每个预处理步骤如何影响模型有效分类数据的能力，特定技术导致两个数据集性能指标的显著改善。重采样技术，特别是过采样和SMOTE倾向于显示模型性能的显著增加，并突出它们在解决类不平衡方面的有效性。</p><p>表5的详细分析揭示那些特定预处理技术组合一致提升了实验中的模型准确性。例如，决策树在与KBD离散化、RFE特征选择和SMOTE重采样配对时展示了最佳性能。该协同作用为每个数据集提供了优越的准确性和泛化。</p><p>模式在模型中保持。对于随机森林，结合KBD离散化、RFE特征选择和过采样一致产生了数据集上的最高分数，肯定这些预处理策略提升性能，特别是对于树基模型。对于像AdaBoost和梯度提升这样的集成方法，最好结果也通过配对KBD离散化、RFE或KBest特征选择和SMOTE重采样获得，表明这些技术为集成模型提供相当益处，在保持准确性和防止过拟合方面。</p><h3 id="4-4-统计测试分析"><a href="#4-4-统计测试分析" class="headerlink" title="4.4 统计测试分析"></a>4.4 统计测试分析</h3><p>不同场景源于各种重采样和特征选择程序，这些变异直接影响分类器的性能。识别最佳策略变得挑战，因为不同数据集拥有独特特征，并且变化的数据预处理选项可以影响分类器准确性和鲁棒性。由于这一复杂性，确定评估和比较分类器在不同数据预处理情况下的最佳方法组合需要系统方法。</p><p>统计显著性测试包括ANOVA和Friedman测试有助于客观和仔细评估这些差异。如表8所示，我们使用了两个测试来考察分类器在给定不同重采样和特征选择组合时的表现。我们特别感兴趣于每个方法在每个数据集内的AUC值。我们能够拒绝零假设，因为p值小于0.05阈值，这表明有统计上显著的差异。结果确认替代假设，即不同数据集内的场景表现显著不同。</p><p>确认不同方法在每个数据集内表现显著不同使用ANOVA和Friedman测试后，进一步分析需要识别每个数据集的最佳场景。表9和10提供各种预测模型和预处理策略的全面评估，系统分析多个实验场景以识别基于中位性能值、排名总和和Friedman测试排名的最有效组合。中位指标反映模型性能的中心趋势，而排名总和和排名列提供每个场景相对性能的洞察基于Friedman测试。</p><p>如表9所示，对于数据集（1）的顶级表现场景是KBD + RFE + Over + ML，它实现了最高排名（Rank 1）以0.9584的中位AUC和75的排名总和。这密切跟随KBD + RFE + SMOTE + ML，它获得第二排名（Rank 2）以0.9456的中位AUC，和Under + ML，它实现第三排名（Rank 3）以0.8936的中位AUC。显着地，纳入递归特征消除（RFE）和过采样技术的场景一致优于其他方法，表明特征选择和数据平衡的组合显著改善模型性能。相比之下，简单方法如Raw data + ML和KBD + ML排名相当低（Ranks 13和14），强调高级预处理技术的作用。</p><p>表10中呈现的结果对于数据集（2）揭示KBD + RFE + Over + ML场景提供了最高性能，实现顶级排名（Rank 1）以0.8510的中位值和69的排名总和。这密切跟随KBD + Kbest + SMOTE + ML，它获得第二排名（Rank 2）以0.8299的AUC中位，和KBD + RFE + ML，它实现第三排名（Rank 3）以0.8530的中位AUC。相比之下，简单方法如Raw data + ML（Rank 12，中位=0.6287）和SMOTE + ML（Rank 15，中位=0.6172）表现差，强调高级预处理策略的作用。</p><p>总之，此分析证明结合各种预处理技术可以显著改善分类模型性能。最佳组合，特别是对于区分任务如保险欺诈检测，发现于实验6中（KBD + RFE + Over + RF）场景，它展示了两个数据集上最高的AUC分数。这一组合有效平衡精度和召回，突出使用集成预处理方法来优化分类器准确性和鲁棒性的价值。这些发现提供有价值的洞察于数据预处理在优化分类器性能方面的关键作用，并可以指导未来研究在特定模型家族中选择适当的预处理策略。</p><h3 id="4-5-使用SHAP分析解释预测模型"><a href="#4-5-使用SHAP分析解释预测模型" class="headerlink" title="4.5 使用SHAP分析解释预测模型"></a>4.5 使用SHAP分析解释预测模型</h3><p>预测模型结果的解释是理解其行为并确保其在真实世界应用中可靠性的关键步骤（de Souza et al., 2024）。作为最先进的解释性框架，SHAP（SHapley Additive exPlanations）分析测量每个特征对模型预测的贡献，这有助于我们理解变量基础上的更高性能。通过检查SHAP值，我们可以识别影响模型发现的关键特征，验证所选特征的重要性，并从数据集基础模式中衍生实际洞察（Lundberg &amp; Lee, 2017）。这一可解释性步骤不仅提升了对模型的信任，还为精炼预处理策略和改善未来预测性能提供了宝贵指导。正如表6对于数据集（1）所示，通过全面评估识别的最佳表现场景是KBD + RFE + Over + RF。</p><p>结果通过SHAP值说明在图7中，它确定特征对模型最终结果的影响。SHAP值范围大约-0.4到0.4，表明每个特征强度和方向的影响。正值（向右）提升模型输出，而负值（向左）减少它。这澄清了各种特征的重要性及其对结果的影响。图7说明了特征的垂直排名，最重要的位于顶部，最不重要的位于底部。主要特征如X31、X13和X16具有最大的SHAP值，表明它们对模型预测的重大影响。</p><p>根据结果，变量X31（表示保险覆盖类型）、X13（显示事故责任人）和X16（指示汽车定价类别）具有最显著影响，SHAP值范围从0.2到0.4。这些特征很可能作为模型性能的主要驱动因素，并与最佳表现场景（KBD+RFE+Over+RF）一致，该场景结合了特征选择和领域特定知识。另一方面，像X12、X22和X7这样的特征具有较低的SHAP值，做出小贡献，表明它们要么不必要，要么相关性小。</p><h3 id="4-6-研究局限性"><a href="#4-6-研究局限性" class="headerlink" title="4.6 研究局限性"></a>4.6 研究局限性</h3><p>虽然本研究通过统计和机器学习方法的集成开发了用于保险欺诈检测的鲁棒预测系统，但应承认几个重要局限性。最值得注意的是，我们当前的分析受限于公开可用数据集缺乏详细经济变量，这排除了全面经济影响评估，如成本效益矩阵、ROI分析或保险特定现象如道德风险和逆向选择的量化建模。这些分析需要访问专有金融指标（例如，理赔特定成本结构、保单持有人保费历史和损失比率），这超出了我们数据的范围。我们因此优先考虑核心检测算法的开发和验证，在可用数据的约束内。</p><p>然而，我们认识到这些经济维度对于展示真实世界实施价值至关重要，并提出未来研究应：（1）建立行业伙伴关系以访问敏感金融数据进行全面经济建模；（2）开发集成框架，将欺诈预测与成本相结合；（3）调查保险欺诈的行为经济学方面，通过更丰富的保单持有人数据集。这些扩展将显著提升欺诈检测系统的实际效用，同时解决本研究已识别的技术预测能力和商业价值展示之间的重要交叉点。</p><p>我们数据集的横截面性质阻止了全面时序验证，因为我们缺乏理赔时间戳、历史欺诈模式和方案演变的纵向记录。这一局限性限制了我们检查关键动态方面，包括季节性欺诈趋势、欺诈者行为适应模式和时序模型性能退化——所有这些对于在生产环境中维持检测准确性至关重要。我们强调，通过行业伙伴关系进行纵向数据收集来解决这些时序维度代表了一个关键的未来研究方向，以桥接实验验证和操作部署之间的差距。</p><p>我们研究的另一个局限性是由于隐私约束缺乏敏感人口统计数据（例如，种族、性别），这阻止了使用像人口统计平价这样的指标进行公平性评估。虽然这保护了理赔人隐私，但它限制了我们评估潜在偏差的能力——鉴于保险部门的脆弱性对歧视性结果，这是一个关键担忧。未来具有适当数据的工作应严格审计人口统计组的预测并实施公平意识建模技术，以确保公平的欺诈检测系统。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h2><p>总之，本研究提供了对保险业欺诈检测的深入检查，通过利用多方面的途径集成多样数据预处理技术和分类算法。该分析调查了各种分类器、特征选择方法、数据离散化技术和重采样策略如何影响欺诈检测模型的性能。实证结果揭示了结合这些方法的显著优势，实验6组合（KBD+RFE+过采样+随机森林）展示了在检测欺诈理赔方面的最高效能，如通过优越指标如AUC和F1分数所证明。这种方法突出了欺诈检测中集成策略的重要性，这表明数据挖掘和机器学习技术的全面应用可以大大提升欺诈检测准确性，并帮助保险公司最小化金融损失。</p><p>这一框架的含义对于行业从业者和政策制定者都是实质性的。通过采用这样的结构化和数据驱动方法，保险公司可以加强其欺诈检测系统，从而加强整体金融诚信和运营韧性。此外，这一框架不仅作为选择最佳预测模型的指南，还作为建立更鲁棒行业欺诈预防实践的基础。</p><p>虽然我们的研究提供了有效的欺诈检测框架，但其横截面设计限制了时序验证，由于缺乏纵向数据（例如，理赔时间戳、欺诈模式演变）和详细经济变量的缺失（例如，成本结构、保单持有人成本历史）限制了成本效益分析、ROI量化以及保险特定现象如道德风险和逆向选择的建模。未来研究应扩展这一工作，通过：（1）纳入时序分析以评估季节趋势、欺诈者适应和模型衰退；（2）开发集成/混合分类器与高级特征离散化和重采样策略以改善鲁棒性；（3）建立行业伙伴关系以实现纵向数据集的真实世界验证；以及（4）未来经济建模需要保险公司合作以访问金融数据（理赔成本、支付历史）进行成本效益分析、ROI量化以及道德风险/逆向选择研究。此外，测试新型特征选择技术和自适应学习方法对于应对演变的欺诈策略至关重要。这些进步将桥接实验验证和操作部署之间的差距，最终提升保险部门的韧性和可持续性。我们的发现为这些努力奠定了基础，为从业者提供可扩展工具，同时为更安全和可信的欺诈检测生态系统铺平道路。</p><p><strong>资助</strong> 开放访问资助由科技与创新资助局（STDF）在埃及知识银行（EKB）的合作下提供。作者声明在准备本手稿期间未收到任何资金、赠款或其他支持。</p><p><strong>数据可用性</strong> 支持本研究发现的数据可在以下链接获得（<a href="https://github.com/AhmedKhalil91/classification-model.git）。">https://github.com/AhmedKhalil91/classification-model.git）。</a></p><p><strong>声明</strong></p><p><strong>利益冲突</strong> 作者声明没有相关的金融或非金融利益披露。</p><p><strong>开放访问</strong> 本文根据Creative Commons Attribution 4.0国际许可授权，该许可允许在任何媒介或格式中使用、共享、改编、分发和复制，只要您给予原作者和来源适当信用，提供Creative Commons许可链接，并指示是否进行了更改。本文中的图像或其他第三方材料包含在文章的Creative Commons许可中，除非在信用线中另有说明。如果材料未包含在文章的Creative Commons许可中，且您的预期用途不符合法定规定或超过允许用途，您将需要直接从版权持有人获得许可。要查看此许可的副本，请访问<a href="http://creativecommons.org/licenses/by/4.0/。">http://creativecommons.org/licenses/by/4.0/。</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Aivaz, K. A., Florea, I. O., &amp; Munteanu, I. (2024). 经济欺诈及其相关风险：一种集成文献计量分析方法. <em>风险</em>, 12(5), 74.<br>Akhtar, P., Ghouri, A. M., Khan, H. U. R., Amin ul Haq, M., Awan, U., Zahoor, N., Khan, Z., &amp; Ashraf, A. (2023). 使用人工智能和机器学习检测假新闻和虚假信息以避免供应链中断. <em>运筹学年鉴</em>, 327(2), 633–657. <a href="https://doi.org/10.1007/s10479-022-05015-5">https://doi.org/10.1007/s10479-022-05015-5</a><br>Alsuwaillem, A. A. S., Salem, E., &amp; Saudagar, A. K. J. (2023). 不同机器学习算法在检测金融欺诈方面的性能. <em>计算经济学</em>, 62(4), 1631–1667. <a href="https://doi.org/10.1007/s10614-022-10314-x">https://doi.org/10.1007/s10614-022-10314-x</a><br>Amirruddin, A. D., Muharam, F. M., Ismail, M. H., Tan, N. P., &amp; Ismail, M. F. (2022). 合成少数过采样技术（SMOTE）和逻辑模型树（LMT）-自适应提升算法用于分类油棕（<em>Elaeis guineensis</em>）营养和叶绿素充足水平的失衡数据集. <em>农业计算机与电子</em>, 193, 106646. <a href="https://doi.org/10.1016/j.compag.2021.106646">https://doi.org/10.1016/j.compag.2021.106646</a><br>Baesens, B., Höppner, S., Ortner, I., &amp; Verdonck, T. (2021). RobROSE：处理欺诈检测中不平衡数据的鲁棒方法. <em>统计方法与应用</em>, 30(3), 841–861. <a href="https://doi.org/10.1007/s10260-021-00573-7">https://doi.org/10.1007/s10260-021-00573-7</a><br>Bansal, M., Goyal, A., &amp; Choudhary, A. (2022). K-最近邻、遗传、支持向量机、决策树和长短期记忆算法在机器学习中的比较分析. <em>决策分析杂志</em>, 3, 100071.<br>Barry, L., &amp; Charpentier, A. (2020). 个性化作为承诺：大数据能否改变保险实践？ <em>大数据与社会</em>, 7(1), 文章 2053951720935143. <a href="https://doi.org/10.1177/2053951720935143">https://doi.org/10.1177/2053951720935143</a><br>Basit, M. S., Khan, A., Farooq, O., Khan, Y. U., &amp; Shameem, M. (2022). 处理不平衡医疗数据集的因果：大数据中的基于集成和划分的特征选择. <em>2022 第5届多媒体、信号处理和通信技术国际会议 (IMPACT)</em>, 1–7. <a href="https://doi.org/10.1109/IMPACT55510.2022.10029111">https://doi.org/10.1109/IMPACT55510.2022.10029111</a><br>Ben Jabeur, S., Stef, N., &amp; Carmona, P. (2023). 使用XGBoost算法和变量重要性特征工程预测破产. <em>计算经济学</em>, 61(2), 715–741. <a href="https://doi.org/10.1007/s10614-021-10227-1">https://doi.org/10.1007/s10614-021-10227-1</a><br>Bhowmik, R. (2011). 使用数据挖掘技术检测汽车保险欺诈. <em>计算与信息科学新兴趋势杂志</em>, 2(4), 156–162.<br>Cappiello, A. (2020). 保险企业的风险与控制. 在 A. Cappiello (编), <em>欧洲保险业：法规、风险管理和内部控制</em> (pp. 7–29). Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-43142-6_2">https://doi.org/10.1007/978-3-030-43142-6_2</a><br>Cerda, P., &amp; Varoquaux, G. (2022). 编码高基数字符串分类变量. <em>IEEE知识与数据工程汇刊</em>, 34(3), 1164–1176. <a href="https://doi.org/10.1109/TKDE.2020.2992529">https://doi.org/10.1109/TKDE.2020.2992529</a><br>Das, S., Datta, S., Zubaidi, H. A., &amp; Obaid, I. A. (2021). 使用可解释机器学习分类树木和公用杆相关碰撞伤害类型. <em>IATSS研究</em>, 45(3), 310–316. <a href="https://doi.org/10.1016/j.iatssr.2021.01.001">https://doi.org/10.1016/j.iatssr.2021.01.001</a><br>de Souza, M., de Castro, J. G., Peng, D. T., &amp; Gartner, I. R. (2024). 基于机器学习分析银行业金融机构金融压力的因果关系. <em>计算经济学</em>, 64(3), 1857–1890. <a href="https://doi.org/10.1007/s10614-023-10514-z">https://doi.org/10.1007/s10614-023-10514-z</a><br>Dhieb, N., Ghazzai, H., Besbes, H., &amp; Massoud, Y. (2019). 极端梯度提升机器学习算法用于安全汽车保险运营. <em>2019 IEEE车辆电子与安全国际会议 (ICVES)</em>, 1–5.<br>Dhieb, N., Ghazzai, H., Besbes, H., &amp; Massoud, Y. (2020). 用于自动保险系统的安全AI驱动架构：欺诈检测和风险测量. <em>IEEE访问：实用创新、开放解决方案</em>, 8, 58546–58558. <a href="https://doi.org/10.1109/ACCESS.2020.2983300">https://doi.org/10.1109/ACCESS.2020.2983300</a><br>Gupta, S., Modgil, S., Bhattacharyya, S., &amp; Bose, I. (2022). 人工智能用于运筹研究领域的决策支持系统：回顾和未来研究范围. <em>运筹学年鉴</em>, 308(1), 215–274. <a href="https://doi.org/10.1007/s10479-020-03856-6">https://doi.org/10.1007/s10479-020-03856-6</a><br>Hanafy, M., &amp; Ming, R. (2021). 通过数据级别方法改善汽车保险中的不平衡数据分类. <em>先进计算机科学与应用国际杂志</em>, 12(6), 493–499.<br>Hassan, A. K. I., &amp; Abraham, A. (2013). 计算智能模型用于保险欺诈检测：十年研究的回顾. <em>网络与创新计算杂志</em>, 1(2013), 341–347.<br>Hassan, A. K. I., &amp; Abraham, A. (2016a). 使用集成结合分类预测埃及市场保险公司破产. <em>计算机信息系统与工业管理应用国际杂志</em>, 8, 257–265.<br>Hassan, A. K. I., &amp; Abraham, A. (2016b). 使用不平衡数据分类建模保险欺诈检测. 在 N. Pillay, A. P. Engelbrecht, A. Abraham, du M. C. Plessis, V. Snášel, &amp; A. K. Muda (编), <em>自然和生物启发计算进展</em> (pp. 117–127). Springer International Publishing.<br>Hossin, M., &amp; Sulaiman, M. N. (2015). 数据分类评估的评价指标回顾. <em>数据挖掘与知识管理过程国际杂志</em>, 5(2), 1.<br>Hoyt, R. E., Mustard, D. B., &amp; Powell, L. S. (2006). 州立法在减轻道德风险方面的有效性：来自汽车保险的证据. <em>法律与经济学杂志</em>, 49(2), 427–450. <a href="https://doi.org/10.1086/501092">https://doi.org/10.1086/501092</a><br>Itri, B., Mohamed, Y., Mohammed, Q., &amp; Omar, B. (2019). 汽车保险欺诈检测的机器学习算法性能比较研究. <em>2019第三届智能计算与数据科学国际会议 (ICDS)</em>, 1–4. <a href="https://doi.org/10.1109/ICDS47004.2019.8942277">https://doi.org/10.1109/ICDS47004.2019.8942277</a><br>Jovanovic, D., Antonijevic, M., Stankovic, M., Zivkovic, M., Tanaskovic, M., &amp; Bacanin, N. (2022). 使用组搜索萤火虫算法优化信用卡欺诈检测的机器学习模型. <em>数学</em>, 10(13), 2272.<br>Kafhali, E., S., &amp; Tayebi, M. (2024). 基于元启发式的超参数优化对欺诈交易检测性能分析. <em>进化智能</em>, 17(2), 921–939.<br>Khalil, A. A., Liu, Z., &amp; Ali, A. A. (2022a). 使用自适应网络基于模糊推理系统模型预测埃及石油保险的损失比率. <em>风险管理与保险评论</em>, 25(1), 5–18. <a href="https://doi.org/10.1111/rmir.12200">https://doi.org/10.1111/rmir.12200</a><br>Khalil, A. A., Liu, Z., Salah, A., Fathalla, A., &amp; Ali, A. (2022b). 使用袋装和提升集成技术预测埃及市场保险公司破产. <em>IEEE访问：实用创新、开放解决方案</em>, 10, 117304–117314. <a href="https://doi.org/10.1109/ACCESS.2022.3210032">https://doi.org/10.1109/ACCESS.2022.3210032</a><br>Khalil, A. A., Liu, Z., Fathalla, A., Ali, A., &amp; Salah, A. (2024a). 基于机器学习的保险欺诈检测方法用于类不平衡数据集与缺失值. <em>IEEE访问</em>. <a href="https://doi.org/10.1109/ACCESS.2024.3468993">https://doi.org/10.1109/ACCESS.2024.3468993</a><br>Khalil, A. A., Liu, Z., Fathalla, A., Ali, A., &amp; Salah, A. (2024b). 使用自适应神经模糊推理系统的集成和组合模型提升埃及保险业的保险预测精度. <em>应用人工智能</em>, 38(1), 2348413. <a href="https://doi.org/10.1080/08839514.2024.2348413">https://doi.org/10.1080/08839514.2024.2348413</a><br>Kotsiantis, S., Kanellopoulos, D., &amp; Pintelas, P. (2006). 处理不平衡数据集：回顾. <em>GESTS计算机科学与工程国际交易</em>, 30(1), 25–36.<br>Kowshalya, G., &amp; Nandhini, M. (2018). 汽车保险中的欺诈理赔预测. <em>2018第二届发明通信与计算技术国际会议 (ICICCT)</em>, 1338–1343. <a href="https://doi.org/10.1109/ICICCT.2018.8473034">https://doi.org/10.1109/ICICCT.2018.8473034</a><br>Lakshmanarao, A., Srisaila, A., &amp; Kiran, T. S. R. (2022). 使用特征选择方法的自适应信用卡欺诈检测技术. <em>2022通信、计算与物联网国际会议 (IC3IoT)</em>, 1–5.<br>Li, P., Rao, X., Blase, J., Zhang, Y., Chu, X., &amp; &amp; Zhang, C. (2021). CleanML：评估数据清洗对ML分类任务影响的研究. <em>2021 IEEE第37届数据工程国际会议 (ICDE)</em>, 13–24. <a href="https://doi.org/10.1109/ICDE51399.2021.00009">https://doi.org/10.1109/ICDE51399.2021.00009</a><br>Liu, J., Wu, C., &amp; Li, Y. (2019). 使用基于金融网络的信息和GA基于梯度提升方法改善财务困境预测. <em>计算经济学</em>, 53(2), 851–872. <a href="https://doi.org/10.1007/s10614-017-9768-3">https://doi.org/10.1007/s10614-017-9768-3</a><br>Liu, T., Zhu, X., Pedrycz, W., &amp; Li, Z. (2020). 基于信息粒度的欠采样方法设计用于不平衡数据分类. <em>软计算</em>, 24(22), 17333–17347. <a href="https://doi.org/10.1007/s00500-020-05023-2">https://doi.org/10.1007/s00500-020-05023-2</a><br>Lundberg, S. M., &amp; Lee, S. I. (2017). 解释模型预测的统一方法. <em>神经信息处理系统进展</em>, 30, 1–10.<br>NAIC (2022). <em>特别调查单位 (SIU) 指南</em>.<br>Nordin, S. Z. S., Wah, Y. B., Haur, N. K., Tan, K. P., Hashim, A., Rambeli, N., &amp; Jalil, N. A. (2024). 使用经典和机器学习模型预测汽车保险欺诈. <em>电气与计算机工程国际杂志 (IJECE)</em>, 14(1), 911–921.<br>Park, Y., &amp; Kwon, T. Y. (2024). 使用划分袋装的大数据特征选择集成. <em>计算经济学</em>. <a href="https://doi.org/10.1007/s10614-024-10741-y">https://doi.org/10.1007/s10614-024-10741-y</a><br>Pearsall, J. (1999). <em>简明牛津词典第10版</em>. Oxford UP.<br>Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., Blondel, M., Prettenhofer, P., Weiss, R., &amp; Dubourg, V. (2011). Scikit-learn：Python中的机器学习. <em>机器学习研究杂志</em>, 12, 2825–2830.<br>Piovezan, R. P. B., de Andrade Junior, P. P., &amp; Ávila, S. L. (2023). 用于不完整数据的三向集成聚类. <em>IEEE访问 : 实用创新, 开放解决方案</em>, 8, 91855–91864.<br>Prasasti, I. M. N., Dhini, A., &amp; Laoh, E. (2020). 使用监督分类器检测汽车保险欺诈. <em>2020大数据与信息安全国际研讨会 (IWBIS)</em>, 47–52. <a href="https://doi.org/10.1109/IWBIS50925.2020.9255426">https://doi.org/10.1109/IWBIS50925.2020.9255426</a><br>Roy, R., &amp; George, K. T. (2017). 使用机器学习技术检测保险理赔欺诈. <em>2017电路、功率和计算技术国际会议 (ICCPCT)</em>, 1–6. <a href="https://doi.org/10.1109/ICCPCT.2017.8074258">https://doi.org/10.1109/ICCPCT.2017.8074258</a><br>Saylor, A. T. (2023). 增强机会主义汽车保险欺诈的威慑和检测的建议，用于保险专业人士和行业伙伴 [硕士论文, 威斯康星大学 – Platteville]. <a href="https://minds.wisconsin.edu/bitstream/handle/1793/84189/Saylor,%20Andrew.pdf?sequence=1">https://minds.wisconsin.edu/bitstream/handle/1793/84189/Saylor,%20Andrew.pdf?sequence=1</a><br>Singh, S. K., &amp; Chivukula, M. (2020). 人工智能在保险业中的应用评论. <em>人工智能趋势</em>, 4(1), 75–79.<br>Singh, A., &amp; Jain, A. (2019). 基于特征选择方法的自适应信用卡欺诈检测技术. 在 S. K. Bhatia, S. Tiwari, K. K. Mishra, &amp; M. C. Trivedi (编), <em>计算机通信与计算科学进展</em> (pp. 167–178). Springer Singapore.<br>Srivatsan, S., &amp; Santhanam, T. (2021). 使用特征选择和提升技术的早期糖尿病发作检测. <em>软计算ICTACT杂志</em>, 12(1), 2474–2485.<br>Subudhi, S., &amp; Panigrahi, S. (2018). 类不平衡在检测汽车保险欺诈中的影响. <em>2018第二届数据科学与商业分析国际会议 (ICDSBA)</em>, 528–531. <a href="https://doi.org/10.1109/ICDSBA.2018.00104">https://doi.org/10.1109/ICDSBA.2018.00104</a><br>Subudhi, S., &amp; Panigrahi, S. (2020). 使用优化的模糊c均值聚类和监督分类器检测汽车保险理赔欺诈. <em>金 Saud大学计算机与信息科学杂志</em>, 32(5), 568–575. <a href="https://doi.org/10.1016/j.jksuci.2017.09.010">https://doi.org/10.1016/j.jksuci.2017.09.010</a><br>Sundarkumar, G. G., Ravi, V., &amp; Siddeshwar, V. (2015). 基于单类支持向量机的欠采样：应用于流失预测和保险欺诈检测. <em>2015 IEEE计算智能与计算研究国际会议 (ICCIC)</em>, 1–7. <a href="https://doi.org/10.1109/ICCIC.2015.7435726">https://doi.org/10.1109/ICCIC.2015.7435726</a><br>Tayebi, M., &amp; Kafhali, E., S. (2024). 元启发式基于超参数优化对欺诈交易检测的性能分析. <em>进化智能</em>, 17(2), 921–939.<br>Turban, E. (2011). <em>决策支持与商业智能系统</em>. Pearson Education India.<br>Visalakshi, S., &amp; Radha, V. (2014). 特征选择技术及其应用文献回顾：数据挖掘中特征选择的回顾. <em>2014 IEEE计算智能与计算研究国际会议</em>, 1–6.<br>Wang, P., &amp; Chen, X. (2020). 用于不完整数据的三向集成聚类. <em>IEEE访问 : 实用创新, 开放解决方案</em>, 8, 91855–91864.<br>Wang, Y., &amp; Xu, W. (2018). 使用深度学习和基于LDA的文本分析检测汽车保险欺诈. <em>决策支持系统</em>, 105, 87–95. <a href="https://doi.org/10.1016/j.dss.2017.11.001">https://doi.org/10.1016/j.dss.2017.11.001</a><br>Xiaolong, X., Wen, C., &amp; Yanfei, S. (2019). 用于不平衡数据分类的过采样算法. <em>系统工程与电子杂志</em>, 30(6), 1182–1191. <a href="https://doi.org/10.21629/JSEE.2019.06.12">https://doi.org/10.21629/JSEE.2019.06.12</a><br>Zhang, X., Yu, L., &amp; Yin, H. (2024). 基于集成重采样的迁移AdaBoost算法用于小样本信用分类与类不平衡. <em>计算经济学</em>. <a href="https://doi.org/10.1007/s10614-024-10690-6">https://doi.org/10.1007/s10614-024-10690-6</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;我真的服了为什么实训论文要把ddl放在期末考试之前…&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、完成科研论文一篇，具体要求如下：&lt;/p&gt;
&lt;p&gt;1、科研论文主题：传统机器学习在保险领域的前沿研究课题&lt;/p&gt;
&lt;p&gt;涵盖风险评估、欺诈检测、客户细分等多个方面，以下是</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-29-关于画布项目的相关考虑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/2357.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/2357.html</id>
    <published>2025-12-28T20:52:15.000Z</published>
    <updated>2025-12-29T07:44:54.292Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 仓库 <a href="https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>该项目技术栈先进（React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8），涉及高性能渲染、无限画布、撤销/重做、实时协作等复杂功能，因此问题往往聚焦于性能优化、状态管理、图形渲染、架构设计以及实际工程实践。</p><h3 id="1-项目整体介绍与架构设计"><a href="#1-项目整体介绍与架构设计" class="headerlink" title="1. 项目整体介绍与架构设计"></a>1. 项目整体介绍与架构设计</h3><h4 id="项目的主要功能、目标用户以及它解决了哪些实际问题？"><a href="#项目的主要功能、目标用户以及它解决了哪些实际问题？" class="headerlink" title="项目的主要功能、目标用户以及它解决了哪些实际问题？"></a><strong>项目的主要功能、目标用户以及它解决了哪些实际问题？</strong></h4><blockquote><p>BDdraw_DEV 是一个现代化的协同 2D 画布编辑器，采用 React + TypeScript + PixiJS 技术栈构建。该项目提供多种基本图形（矩形、圆形、菱形、线条、箭头、画笔等）元素的绘制，支持背景色、边框宽度、边框颜色等图形属性设置、富文本编辑、图片插入与滤镜处理，支持无限画布缩放、拖拽、提供 minimap，实现元素选择、分组、旋转、调整大小，支持撤销重做，快捷键，数据持久化，本地优先编辑，海量元素处理等交互功能。</p><p>该项目作为一个集成协同编辑、离线编辑的无限画布，来解决团队协作协作效率和同步的问题</p></blockquote><h4 id="项目架构是如何设计的？为什么选择将-React-用于-UI-层、Zustand-用于状态管理、PixiJS-用于渲染层分离？"><a href="#项目架构是如何设计的？为什么选择将-React-用于-UI-层、Zustand-用于状态管理、PixiJS-用于渲染层分离？" class="headerlink" title="项目架构是如何设计的？为什么选择将 React 用于 UI 层、Zustand 用于状态管理、PixiJS 用于渲染层分离？"></a><strong>项目架构是如何设计的？为什么选择将 React 用于 UI 层、Zustand 用于状态管理、PixiJS 用于渲染层分离？</strong></h4><blockquote><p>项目的核心在于其三层架构设计：React 负责 UI 层、Zustand 管理状态层、PixiJS 处理渲染层，实现数据驱动视图的模式。其便于实现撤销/重做、数据持久化和多人协同编辑等高级功能</p><p>其优势在于：<br>解耦设计：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展<br>便于协同：所有状态都集中管理在 Zustand Store 中，便于实现多人协同编辑<br>易于撤销/重做：通过保存和恢复 Store 的快照实现完整的撤销/重做功能<br>可持久化：状态数据可以轻松序列化/反序列化，便于保存和传输</p></blockquote><h4 id="项目是如何组织目录结构的？这种模块化设计带来了哪些好处？"><a href="#项目是如何组织目录结构的？这种模块化设计带来了哪些好处？" class="headerlink" title="项目是如何组织目录结构的？这种模块化设计带来了哪些好处？"></a><strong>项目是如何组织目录结构的？这种模块化设计带来了哪些好处？</strong></h4><p>前端部分主要是分为五个模块：</p><h5 id="src-api-API-客户端和类型定义（处理前后端通信）"><a href="#src-api-API-客户端和类型定义（处理前后端通信）" class="headerlink" title="src/api - API 客户端和类型定义（处理前后端通信）"></a>src/api - API 客户端和类型定义（处理前后端通信）</h5><ul><li>types - API 类型定义</li><li>utils - API 工具函数</li><li>API 服务封装和客户端工具</li></ul><h5 id="src-components-React-UI-组件（各种-UI-组件）"><a href="#src-components-React-UI-组件（各种-UI-组件）" class="headerlink" title="src/components - React UI 组件（各种 UI 组件）"></a>src/components - React UI 组件（各种 UI 组件）</h5><ul><li>canvas_toolbar - 画布工具栏组件</li><li>collaboration - 协作功能组件</li><li>header - 页面头部组件</li><li>property-panel - 属性面板组件</li><li>richtext_editor - 富文本编辑器组件</li></ul><h5 id="src-hooks-自定义-React-Hooks"><a href="#src-hooks-自定义-React-Hooks" class="headerlink" title="src/hooks - 自定义 React Hooks"></a>src/hooks - 自定义 React Hooks</h5><ul><li>状态管理（简单的本地存储，用于存储用户偏好、UI 状态等）</li><li>快捷键处理</li></ul><h5 id="src-lib-工具库和核心功能模块"><a href="#src-lib-工具库和核心功能模块" class="headerlink" title="src/lib - 工具库和核心功能模块"></a>src/lib - 工具库和核心功能模块</h5><ul><li>AddElementCommand.ts、RemoveElementCommand.ts、UndoRedoManager.ts - 命令模式实现</li><li>constants.ts - 常量定义</li><li>utils.ts - 通用工具函数</li></ul><h5 id="src-pages-页面组件"><a href="#src-pages-页面组件" class="headerlink" title="src/pages - 页面组件"></a>src/pages - 页面组件</h5><ul><li>auth - 认证相关页面</li><li>home - 主页</li><li>room - 房间管理页面</li><li><p><strong>canvas/Pixi_STM_modules - Pixi.js 状态管理模块</strong></p><ul><li>core - 核心类和初始化逻辑</li><li>interaction - 交互处理模块（例如拖拽、缩放、选择等）</li><li>utils - 工具函数目录（各项操作的封装）</li><li>shared - 共享类型定义</li></ul></li></ul><h5 id="src-stores-状态管理（Yjs-IndexedDB-复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）"><a href="#src-stores-状态管理（Yjs-IndexedDB-复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）" class="headerlink" title="src/stores - 状态管理（Yjs + IndexedDB - 复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）"></a>src/stores - 状态管理（Yjs + IndexedDB - 复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）</h5><ul><li>canvasStore.ts - 画布状态管理</li><li>persistenceStore.ts - 持久化状态管理</li><li>themeStore.ts - 主题状态管理</li></ul><p>后端部分的设计：</p><ul><li><strong>房间管理系统</strong> - 支持创建、修改、删除和查询房间</li><li><strong>用户认证系统</strong> - 提供用户登录、注册和权限验证</li><li><strong>实时协作支持</strong> - 通过  collab.ts  实现</li><li><strong>数据库</strong> - 通过  db.ts  连接和操作数据库</li></ul><p>数据库设计（sqlite，原型验证阶段所使用）</p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-466ea97d53037f5c8505d87a87c2e52e_720w.webp'><img src="https://pica.zhimg.com/80/v2-466ea97d53037f5c8505d87a87c2e52e_720w.webp" alt=""></p><p>每个房间的画布数据在对应表中的 content 中</p><h4 id="项目中如何处理前端与后端（ALD-Backend）的交互？"><a href="#项目中如何处理前端与后端（ALD-Backend）的交互？" class="headerlink" title="项目中如何处理前端与后端（ALD_Backend）的交互？"></a><strong>项目中如何处理前端与后端（ALD_Backend）的交互？</strong></h4><blockquote><p>该项目前后端分离，交互采用 REST API（表现层状态转移应用编程接口，是一种基于 REST 架构风格设计的 Web API），前端通过 TypeScript 封装的 API 层统一管理所有 HTTP 请求，使用 Axios 作为 HTTP 客户端，配置了请求和响应拦截器来处理认证、错误处理和加载状态。其通过环境变量管理不同环境的基础 URL，定义了统一的响应格式和类型定义来确保类型安全，同时并在需要实时协作的场景下使用 WebSocket 进行双向通信。</p></blockquote><p>Axios 是一个基于 Promise 的网络请求库，用于在浏览器和 Node.js 中进行 HTTP 请求，并支持请求/响应拦截、取消，并发请求，自动转换数据等功能</p><p>详情见博客文章：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/16956.html">前端学习-接口类型定义、Axios 封装与请求规范 | 笔记站 (zhongye1.github.io)</a></p><p>身份验证管理实现：</p><ul><li>使用 JWT Token 进行身份验证</li><li>通过  setAuthToken  和  clearAuthToken  管理认证状态</li><li><code>onAuthenticate</code>  钩子验证用户权限</li></ul><p>详情见博客文章：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/42304.html">前端学习-身份验证管理-基于 JWT Token 的实现 (zhongye1.github.io)</a></p><hr><p><strong>实时协作部分是如何实现的？</strong></p><p>实时协作功能通过 Yjs、Hocuspocus 和 IndexedDB 实现：</p><p>可以看博客：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/60473.html">2025-12-27-前端画布设计 Vol.3 实现 CRDT | Notes|笔记站 (zhongye1.github.io)</a></p><ol><li>前端(react)</li></ol><ul><li>使用 Yjs 的 CRDT 数据结构实现多客户端状态同步</li><li>通过  <code>HocuspocusProvider</code>  连接到后端 WebSocket 服务器</li><li>结合 IndexedDB 持久化，实现离线编辑功能</li></ul><ol><li>后端（bun）</li></ol><ul><li>使用 Hocuspocus 作为 Yjs 的协作服务器</li><li>实现了数据库扩展，将 Yjs 文档状态持久化到 SQLite 数据库</li><li>通过 WebSocket 协议处理实时通信</li></ul><ol><li>认证与权限控制</li></ol><ul><li>WebSocket 连接需要 JWT Token 认证</li><li>服务器验证用户是否有权限访问特定房间</li><li>如果用户没有访问权限，会自动将其添加到房间成员中</li></ul><ol><li>数据同步</li></ol><ul><li>前端使用 Yjs 的  <code>Y.Map</code>  存储画布元素数据</li><li>通过  <code>IndexeddbPersistence</code>  将数据持久化到浏览器的 IndexedDB</li><li>使用  <code>HocuspocusProvider</code>  将数据同步到服务器和其他客户端</li></ul><ol><li>在线/离线处理</li></ol><ul><li>当用户在线时，数据实时同步到服务器</li><li>当用户离线时，数据保存在本地 IndexedDB 中</li><li>重新连接后，本地更改会自动同步到服务器（CRDT）</li></ul><ol><li>用户状态管理</li></ol><ul><li>使用 Yjs 的 Awareness 功能跟踪在线用户</li><li>广播机制实时显示协作者的光标位置和选中状态</li><li>通过后端认证机制确保只有授权用户可以加入协作</li></ul><hr><h3 id="2-状态管理（Zustand）"><a href="#2-状态管理（Zustand）" class="headerlink" title="2. 状态管理（Zustand）"></a>2. 状态管理（Zustand）</h3><p>Zustand 是项目核心状态工具，轻量且无 boilerplate。</p><ul><li>为什么选择 Zustand 而非 Redux 或 Context API？在画布状态管理中，它相比其他方案的优势体现在哪里？</li></ul><blockquote><pre><code>Zustand 的 API 设计非常简洁，避免了 Redux 中大量样板代码（boilerplate code）的问题。在 Redux 中，我们需要定义 actions、reducers、store 等多个部分，而 Zustand 只需一个函数即可创建 storeZustand 在性能优化方面，可以实现选择性订阅，避免不必要的组件重新渲染。Context API 在状态更新时会触发所有子组件的重新渲染，而 Zustand 允许我们精确地控制哪些组件需要响应特定状态变化。</code></pre></blockquote><ul><li>如何使用 Zustand 管理画布元素状态（elements: Record<string, CanvasElement="">）？如何实现持久化（Zustand-persist + localForage + IndexedDB）？</string,></li></ul><h4 id="如何使用-Zustand-管理画布元素状态？"><a href="#如何使用-Zustand-管理画布元素状态？" class="headerlink" title="如何使用 Zustand 管理画布元素状态？"></a>如何使用 Zustand 管理画布元素状态？</h4><p>在我们的项目中，画布元素状态是通过  CanvasState  接口定义的，其中  elements  属性是一个  <code>Record&lt;string, CanvasElement&gt;</code>  类型的对象，用于存储所有画布元素：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[];<br>  <span class="hljs-comment">// ... 其他状态</span><br>}<br></code></pre></td></tr></table></figure><p>我们通过直接操作 Yjs 共享数据类型来管理元素状态，从而实现协同编辑功能：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 添加元素</span><br><span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    currentYElements?.<span class="hljs-title function_">set</span>(el.<span class="hljs-property">id</span>, el)<br>  })<br>},<br><br><span class="hljs-comment">// 更新元素</span><br><span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params">id, attrs</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">const</span> oldEl = currentYElements?.<span class="hljs-title function_">get</span>(id)<br>    <span class="hljs-keyword">if</span> (oldEl) {<br>      currentYElements?.<span class="hljs-title function_">set</span>(id, { ...oldEl, ...attrs })<br>    }<br>  })<br>},<br><br><span class="hljs-comment">// 删除元素</span><br><span class="hljs-attr">removeElements</span>: <span class="hljs-function">(<span class="hljs-params">ids</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    ids.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> currentYElements?.<span class="hljs-title function_">delete</span>(id))<br>  })<br>}<br></code></pre></td></tr></table></figure><h4 id="如何实现持久化（Zustand-persist-localForage-IndexedDB）？"><a href="#如何实现持久化（Zustand-persist-localForage-IndexedDB）？" class="headerlink" title="如何实现持久化（Zustand-persist + localForage + IndexedDB）？"></a>如何实现持久化（Zustand-persist + localForage + IndexedDB）？</h4><p>在我们的实现中，持久化是通过 Yjs 的 IndexedDB 持久化机制完成的，而不是使用传统的 zustand-persist。我们使用  IndexeddbPersistence  与 HocuspocusProvider 组合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 persistenceStore.ts 中创建持久化提供者</span><br><span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<br>  <span class="hljs-string">`canvas-local-db-<span class="hljs-subst">${roomId}</span>`</span>,<br>  yDoc<br>);<br></code></pre></td></tr></table></figure><p>这种设计的优势在于:</p><ol><li>Yjs 会自动处理 IndexedDB 的读写操作，无需手动管理</li><li>提供了离线支持，即使在断网情况下数据也能保存在本地</li><li>当重新连接网络时，会自动同步本地和远程数据</li><li>IndexedDB 的异步操作不会阻塞 UI 线程，保证了应用的响应性</li></ol><h4 id="在多用户协作场景下，Zustand-与-Y-js-CRDT-如何结合？如何处理冲突和状态同步？"><a href="#在多用户协作场景下，Zustand-与-Y-js-CRDT-如何结合？如何处理冲突和状态同步？" class="headerlink" title="在多用户协作场景下，Zustand 与 Y.js CRDT 如何结合？如何处理冲突和状态同步？"></a>在多用户协作场景下，Zustand 与 Y.js CRDT 如何结合？如何处理冲突和状态同步？</h4><p>Zustand 作为前端状态管理工具，提供状态访问接口<br>Y.js 作为协同编辑引擎，处理多用户间的数据同步和冲突解决<br>通过 Y.js 的 observe 机制，将 Y.js 的数据变化同步到 Zustand 状态中</p><h3 id="3-高性能渲染与-PixiJS-集成"><a href="#3-高性能渲染与-PixiJS-集成" class="headerlink" title="3. 高性能渲染与 PixiJS 集成"></a>3. 高性能渲染与 PixiJS 集成</h3><p>PixiJS WebGL 渲染是项目性能关键，面试官会深入考察。</p><h4 id="为什么引入-PixiJS-而非纯-Canvas-或-SVG？它在实现-60-FPS-和无限画布时发挥了什么作用？"><a href="#为什么引入-PixiJS-而非纯-Canvas-或-SVG？它在实现-60-FPS-和无限画布时发挥了什么作用？" class="headerlink" title="为什么引入 PixiJS 而非纯 Canvas 或 SVG？它在实现 60 FPS 和无限画布时发挥了什么作用？"></a>为什么引入 PixiJS 而非纯 Canvas 或 SVG？它在实现 60 FPS 和无限画布时发挥了什么作用？</h4><blockquote><pre><code>PixiJS 是一个基于 WebGL 的 2D 渲染引擎，它具有极高的性能优势，可以充分利用 GPU 加速。相比纯 Canvas API，PixiJS 提供了更高层次的抽象，开发者无需手动管理底层的渲染细节，同时能够获得更好的性能表现。与 SVG 相比，PixiJS 在处理大量图形元素时表现更佳。SVG 是基于 DOM 的，当元素数量增加时，DOM 操作的开销会显著增加，导致性能下降。而 PixiJS 直接在 GPU 层面进行渲染，即使处理数千个元素也能保持流畅性能。对于无限画布的实现，PixiJS 提供了强大的 pixi-viewport 插件，它可以处理大规模场景的渲染优化。通过视口裁剪（view culling）技术，PixiJS 只渲染当前可见区域内的元素，大幅减少了渲染开销。</code></pre></blockquote><h4 id="如何使用-pixi-viewport-实现无限画布的缩放、平移和边界限制？"><a href="#如何使用-pixi-viewport-实现无限画布的缩放、平移和边界限制？" class="headerlink" title="如何使用 pixi-viewport 实现无限画布的缩放、平移和边界限制？"></a>如何使用 pixi-viewport 实现无限画布的缩放、平移和边界限制？</h4><p>实现缩放、平移和边界限制：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Stage_InteractionHandler.ts 中实现视口功能</span><br>viewport<br>  .<span class="hljs-title function_">drag</span>() <span class="hljs-comment">// 启用拖拽平移</span><br>  .<span class="hljs-title function_">pinch</span>() <span class="hljs-comment">// 启用双指缩放</span><br>  .<span class="hljs-title function_">wheel</span>() <span class="hljs-comment">// 启用滚轮缩放</span><br>  .<span class="hljs-title function_">clamp</span>({ <span class="hljs-attr">direction</span>: <span class="hljs-string">"all"</span> }) <span class="hljs-comment">// 边界限制</span><br>  .<span class="hljs-title function_">bounce</span>(); <span class="hljs-comment">// 边界弹性效果</span><br></code></pre></td></tr></table></figure><p>缩放功能通过 pinch 和 wheel 插件实现，用户可以通过双指手势或鼠标滚轮进行缩放。平移功能通过 drag 插件实现，用户可以拖拽画布。clamp 功能用于限制视口边界，防止用户将视口拖拽到画布内容之外的区域。</p><p>viewport 提供多个配置选项，如缩放级别限制、平滑动画等</p><h4 id="项目中如何缓存-PixiJS-对象（spriteMap）以避免拖拽-缩放时的重复创建？这对性能有何影响？"><a href="#项目中如何缓存-PixiJS-对象（spriteMap）以避免拖拽-缩放时的重复创建？这对性能有何影响？" class="headerlink" title="项目中如何缓存 PixiJS 对象（spriteMap）以避免拖拽/缩放时的重复创建？这对性能有何影响？"></a>项目中如何缓存 PixiJS 对象（spriteMap）以避免拖拽/缩放时的重复创建？这对性能有何影响？</h4><p>在项目中，我们使用  spriteMap  来缓存 PixiJS 对象，避免在拖拽、缩放等操作中重复创建和销毁元素。spriteMap  是一个以元素 ID 为键的 Map，存储了每个画布元素对应的 PixiJS 显示对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Pixi_stageManager.ts 中定义</span><br>spriteMap <span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br></code></pre></td></tr></table></figure><p>当画布元素更新时，我们首先检查  spriteMap  中是否已存在对应的显示对象，如果存在则直接更新其属性，而不是创建新的对象。</p><ol><li>减少了对象创建和垃圾回收的开销</li><li>提高了渲染效率，因为现有对象只需更新属性而非重新创建</li><li>保持了对象状态的连续性，例如动画状态、事件监听器等</li></ol><h4 id="图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在-PixiJS-中实现的？遇到过哪些渲染挑战？"><a href="#图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在-PixiJS-中实现的？遇到过哪些渲染挑战？" class="headerlink" title="图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在 PixiJS 中实现的？遇到过哪些渲染挑战？"></a>图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在 PixiJS 中实现的？遇到过哪些渲染挑战？</h4><p>在项目中，我们使用 PixiJS 的滤镜系统实现图像效果。对于 BlurFilter 和 ColorMatrixFilter 等滤镜，我们通过以下方式应用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BlurFilter</span>, <span class="hljs-title class_">ColorMatrixFilter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"pixi.js"</span>;<br><br><span class="hljs-comment">// 为图像元素添加滤镜</span><br><span class="hljs-keyword">const</span> blurFilter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlurFilter</span>();<br><span class="hljs-keyword">const</span> colorFilter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorMatrixFilter</span>();<br><br>sprite.<span class="hljs-property">filters</span> = [blurFilter, colorFilter];<br></code></pre></td></tr></table></figure><p>对于富文本渲染，我们使用了 pixi-text-html 库，它允许我们在 PixiJS 中渲染 HTML 样式的文本。HTMLText 组件可以解析 HTML 标签并渲染出格式化的文本。</p><h4 id="小地图（Minimap）如何通过-cacheAsBitmap-实现实时更新？为什么需要单独的-Pixi-Application？"><a href="#小地图（Minimap）如何通过-cacheAsBitmap-实现实时更新？为什么需要单独的-Pixi-Application？" class="headerlink" title="小地图（Minimap）如何通过 cacheAsBitmap 实现实时更新？为什么需要单独的 Pixi Application？"></a>小地图（Minimap）如何通过 cacheAsBitmap 实现实时更新？为什么需要单独的 Pixi Application？</h4><p>小地图的实现主要通过 cacheAsBitmap 属性来优化性能。cacheAsBitmap 将显示对象及其子对象渲染到一个内部纹理中，后续渲染只需绘制该纹理，而无需重新计算所有子对象的渲染，从而大幅提升性能。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">stage.<span class="hljs-property">cacheAsBitmap</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>小地图需要单独的 Pixi Application 实例，主要原因包括：</p><p>性能隔离：小地图的渲染频率可能与主画布不同，独立的实例可以更好地控制渲染性能<br>独立交互：小地图可能需要独立的交互逻辑，如点击跳转到画布特定位置<br>资源管理：独立的实例可以更好地管理小地图相关的纹理和资源<br>缩放独立性：小地图需要保持固定比例的缩略图，独立的渲染上下文更容易实现这一功能</p><h3 id="4-撤销-重做机制（命令模式）"><a href="#4-撤销-重做机制（命令模式）" class="headerlink" title="4. 撤销/重做机制（命令模式）"></a>4. 撤销/重做机制（命令模式）</h3><h4 id="项目中撤销-重做是如何实现的？为什么采用-Command-Pattern？"><a href="#项目中撤销-重做是如何实现的？为什么采用-Command-Pattern？" class="headerlink" title="项目中撤销/重做是如何实现的？为什么采用 Command Pattern？"></a>项目中撤销/重做是如何实现的？为什么采用 Command Pattern？</h4><p>撤销/重做功能是通过命令模式（Command Pattern）实现的。我们定义了一个  Command  接口，它包含  execute、undo  和  redo  三个方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>;<br>}<br></code></pre></td></tr></table></figure><p>我们为不同类型的画布操作创建了相应的命令类，如  AddElementCommand、RemoveElementCommand  和  UpdateElementCommand  等。每个命令类都保存了执行操作所需的信息，能够在  undo  和  redo  时恢复到相应的状态。</p><p>采用命令模式的主要原因有以下几点：</p><p><strong>解耦</strong>：命令模式将操作的执行者与请求者解耦，使我们可以轻松地添加新的命令类型而无需修改现有代码。<br><strong>状态一致性</strong>：在协同编辑环境中，命令模式确保所有操作都可以被准确地撤销和重做，保持状态一致性。<br><strong>易于扩展</strong>：我们可以轻松地添加新的命令类型，如分组、取消分组等。</p><h4 id="每个命令（如-AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？"><a href="#每个命令（如-AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？" class="headerlink" title="每个命令（如 AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？"></a>每个命令（如 AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？</h4><h5 id="AddElementCommand-的撤销与重做实现"><a href="#AddElementCommand-的撤销与重做实现" class="headerlink" title="AddElementCommand 的撤销与重做实现"></a>AddElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">payload</span>: { element: CanvasElement }</span>) {}<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 添加元素到画布</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 从画布移除元素，实现撤销</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>.<span class="hljs-property">id</span>]);<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重新添加元素，实现重做（与 execute 相同）</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>);<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：通过移除新增的元素恢复原状态，仅需元素 ID。</li><li><strong>重做（redo）</strong>：直接重复添加操作，无需额外存储数据。</li></ul><h5 id="RemoveElementCommand-的撤销与重做实现"><a href="#RemoveElementCommand-的撤销与重做实现" class="headerlink" title="RemoveElementCommand 的撤销与重做实现"></a>RemoveElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">elementData</span>: <span class="hljs-title class_">CanvasElement</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">payload</span>: { element: CanvasElement }</span>) {}<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 先保存被移除元素的完整数据（用于后续恢复）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span> = { ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span> };<br>    <span class="hljs-comment">// 执行移除</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>.<span class="hljs-property">id</span>]);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 使用保存的数据重新添加元素，实现撤销移除</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>) {<br>      useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>);<br>    }<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重复移除操作，实现重做</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>) {<br>      useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>.<span class="hljs-property">id</span>]);<br>    }<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：依赖 execute 时存储的元素完整数据进行恢复。</li><li><strong>重做（redo）</strong>：使用存储的数据重复移除，避免直接依赖外部状态。</li></ul><h5 id="UpdateElementCommand-的撤销与重做实现"><a href="#UpdateElementCommand-的撤销与重做实现" class="headerlink" title="UpdateElementCommand 的撤销与重做实现"></a>UpdateElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">previousValues</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">elementId</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">newValues</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-comment">// 在构造函数中保存更新前的属性值（旧状态）</span><br>    <span class="hljs-keyword">const</span> currentState = useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-property">elements</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span> = {};<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(newValues).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span>[key <span class="hljs-keyword">as</span> keyof <span class="hljs-title class_">CanvasElement</span>] =<br>        currentState[key <span class="hljs-keyword">as</span> keyof <span class="hljs-title class_">CanvasElement</span>];<br>    });<br>  }<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 应用新值</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">newValues</span>);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 恢复旧值，实现撤销</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span>);<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重新应用新值，实现重做（与 execute 相同）</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">newValues</span>);<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：通过存储的 previousValues 恢复属性原值。</li><li><strong>重做（redo）</strong>：重复应用新值，确保操作可重复性。</li></ul><p>此设计的核心原则是：在命令对象中存储足够的信息（而非完整状态快照），以独立实现 undo 和 redo 操作，从而支持高效的命令模式撤销/重做栈管理。</p><p>在内存和性能上的权衡包括：</p><ol><li><strong>内存占用</strong>：每个命令都需要保存足够的信息来执行撤销/重做操作，这会增加内存使用。特别是  SnapshotCommand  会保存整个状态的副本，这在元素较多时会占用大量内存。</li><li><strong>性能影响</strong>：创建状态快照需要时间，特别是当画布中有大量元素时。使用  <code>structuredClone</code>  深拷贝大型对象会影响性能。</li><li><strong>存储优化</strong>：为减少内存占用，我们对不同的操作采用不同的存储策略。对于添加/删除操作，只需存储元素本身；对于更新操作，只需存储变更前的值和变更的属性。</li></ol><h4 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h4><p>限制历史栈大小以防止内存溢出<br>对于连续的多个操作，可以合并成一个批量命令，减少栈中命令的数量<br>对于包含大量数据的命令，如图像元素操作，可以在命令不再需要时清理其内部引用的数据<br>对于频繁的操作（如拖拽移动），可以使用防抖机制将连续操作合并为一个命令，减少命令栈的增长速度<br>操作分组：将相关的连续操作视为一个逻辑操作，例如，将创建一个复杂图形的多个步骤合并为一个撤销单位<br>操作描述：为每个命令添加描述，让用户在 UI 上看到具体可撤销/重做的操作内容<br>历史持久化：将撤销/重做历史保存到本地存储，即使页面刷新后也能恢复历史记录。<br>自适应栈大小：根据当前画布复杂度动态调整栈大小，元素较多时使用较小的栈，元素较少时使用较大的栈</p><h3 id="5-交互与用户体验"><a href="#5-交互与用户体验" class="headerlink" title="5. 交互与用户体验"></a>5. 交互与用户体验</h3><h4 id="变换控件（Transform-Controls）的检测与处理"><a href="#变换控件（Transform-Controls）的检测与处理" class="headerlink" title="变换控件（Transform Controls）的检测与处理"></a>变换控件（Transform Controls）的检测与处理</h4><p>变换控件由 TF_controler_Renderer.ts 模块负责渲染，包括包围选中元素的边界框、8 个缩放手柄（位于边角）和 1 个旋转手柄（通常位于顶部或底部）</p><p>手柄检测基于鼠标位置与手柄边界框的距离计算：</p><ul><li>当鼠标进入手柄区域时，光标样式相应改变（例如，边角手柄显示对角箭头，旋转手柄显示旋转图标）</li><li>每个手柄对应特定操作：<ul><li>8 个边角手柄：用于非均匀缩放（保持或不保持宽高比，根据修饰键）</li><li>旋转手柄：用于旋转选中元素（可能以组中心为旋转锚点）</li></ul></li></ul><p>在 Stage_InteractionHandler.ts 中处理实际变换逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 处理缩放操作</span><br><span class="hljs-title function_">handleScale</span>(<span class="hljs-params"><span class="hljs-attr">dx</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">dy</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">handleType</span>: <span class="hljs-built_in">string</span></span>) {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br><br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> element = elements[id];<br>    <span class="hljs-comment">// 根据手柄类型（e.g., 'top-left', 'bottom-right'）计算缩放比例和位置偏移</span><br>    updates[id] = <span class="hljs-title function_">calculateNewDimensions</span>(element, dx, dy, handleType);<br>  });<br><br>  <span class="hljs-comment">// 批量更新元素，避免多次重渲染</span><br>  useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">batchUpdateElements</span>(updates);<br>}<br><br><span class="hljs-comment">// 处理旋转操作（示例）</span><br><span class="hljs-title function_">handleRotate</span>(<span class="hljs-params"><span class="hljs-attr">deltaAngle</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">pivotPoint</span>: { x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span> }</span>) {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br><br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> element = elements[id];<br>    updates[id] = <span class="hljs-title function_">calculateRotatedElement</span>(element, deltaAngle, pivotPoint);<br>  });<br><br>  useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">batchUpdateElements</span>(updates);<br>}<br></code></pre></td></tr></table></figure><h4 id="交互模式切换逻辑"><a href="#交互模式切换逻辑" class="headerlink" title="交互模式切换逻辑"></a>交互模式切换逻辑</h4><p>项目定义了多种交互模式，主要在 Stage_InteractionHandler.ts 中管理，确保同一时刻仅一种模式活跃。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-keyword">const</span> { x, y } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">toLocal</span>(event.<span class="hljs-property">global</span>);<br><br>  <span class="hljs-comment">// 1. 优先检测变换手柄（最高优先级）</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isOverTransformHandle</span>(x, y)) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'transforming'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startTransform</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCurrentHandleType</span>());<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 2. 检测是否点击元素</span><br>  <span class="hljs-keyword">const</span> hitElementId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isOverElement</span>(x, y);<br>  <span class="hljs-keyword">if</span> (hitElementId) {<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">originalEvent</span>.<span class="hljs-property">shiftKey</span>) {<br>      <span class="hljs-comment">// Shift + 点击：多选切换</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toggleSelection</span>(hitElementId);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// 普通点击：单选或重新开始选择</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">selectElement</span>(hitElementId);<br>    }<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'dragging'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startDrag</span>(x, y);<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 3. 空格键平移</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">originalEvent</span>.<span class="hljs-property">code</span> === <span class="hljs-string">'Space'</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'panning'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startPan</span>(event);<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 4. 默认：框选模式</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'selecting'</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startSelectionBox</span>(x, y);<br>};<br></code></pre></td></tr></table></figure><p>模式优先级：<strong>transforming &gt; dragging &gt; panning &gt; selecting &gt; idle</strong>，确保变换手柄始终优先响应。</p><h4 id="对齐指南（Alignment-Guidelines）的计算与绘制"><a href="#对齐指南（Alignment-Guidelines）的计算与绘制" class="headerlink" title="对齐指南（Alignment Guidelines）的计算与绘制"></a>对齐指南（Alignment Guidelines）的计算与绘制</h4><p>对齐指南功能由 guidelineUtils.ts 实现，在元素拖拽过程中实时提供视觉反馈和吸附效果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 检测对齐位置</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectAlignments</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">movingElements</span>: <span class="hljs-title class_">CanvasElement</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">allElements</span>: <span class="hljs-title class_">CanvasElement</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">tolerance</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">const</span> alignments = {<br>    <span class="hljs-attr">vertical</span>: [] <span class="hljs-keyword">as</span> { <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span> }[],<br>    <span class="hljs-attr">horizontal</span>: [] <span class="hljs-keyword">as</span> { <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span> }[],<br>  };<br><br>  movingElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">moving</span> =&gt;</span> {<br>    allElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {<br>      <span class="hljs-keyword">if</span> (movingElements.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">id</span> === element.<span class="hljs-property">id</span>)) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 左/右边缘对齐</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(element.<span class="hljs-property">x</span> - moving.<span class="hljs-property">x</span>) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: element.<span class="hljs-property">x</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'left-edge'</span> });<br>      }<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span> - (moving.<span class="hljs-property">x</span> + moving.<span class="hljs-property">width</span>)) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'right-edge'</span> });<br>      }<br><br>      <span class="hljs-comment">// 水平中心对齐</span><br>      <span class="hljs-keyword">const</span> movingCenterX = moving.<span class="hljs-property">x</span> + moving.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">const</span> elementCenterX = element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(movingCenterX - elementCenterX) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: elementCenterX, <span class="hljs-attr">type</span>: <span class="hljs-string">'center'</span> });<br>      }<br><br>      <span class="hljs-comment">// 类似处理水平对齐（top/bottom/center）...</span><br>    });<br>  });<br><br>  <span class="hljs-comment">// 等间距检测（可选扩展）</span><br>  <span class="hljs-comment">// detectEqualSpacing(...);</span><br><br>  <span class="hljs-keyword">return</span> alignments;<br>}<br></code></pre></td></tr></table></figure><p><strong>绘制与吸附</strong>：</p><ul><li>在拖拽过程中，每帧调用 detectAlignments，若检测到对齐，则使用 PixiJS 的 Graphics 对象绘制虚线指南（通常为蓝色或绿色，带一定透明度）。</li><li>若移动偏移导致对齐，则自动吸附（snap）元素位置到精确对齐点，提供精准布局体验。</li></ul><h3 id="6-性能优化与工程实践"><a href="#6-性能优化与工程实践" class="headerlink" title="6. 性能优化与工程实践"></a>6. 性能优化与工程实践</h3><h4 id="项目中具体的性能优化措施"><a href="#项目中具体的性能优化措施" class="headerlink" title="项目中具体的性能优化措施"></a>项目中具体的性能优化措施</h4><p>项目采用了多项针对性优化，确保在复杂画布场景下的流畅运行：</p><ol><li><strong>对象缓存机制</strong> 使用 spriteMap 缓存 PixiJS 显示对象，避免频繁创建和销毁导致的性能开销。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Pixi_stageManager.ts 中</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-title function_">updateElement</span>(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">attrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span>) {<br>  <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id);<br>  <span class="hljs-keyword">if</span> (sprite) {<br>    <span class="hljs-comment">// 重用现有对象，直接更新属性</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(sprite, attrs);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 首次创建并缓存</span><br>    <span class="hljs-keyword">const</span> newSprite = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createSprite</span>(attrs);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">set</span>(id, newSprite);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">addChild</span>(newSprite);<br>  }<br>}<br></code></pre></td></tr></table></figure><ol><li><strong>WebGL 渲染优化</strong> 充分利用 PixiJS 的 GPU 加速，并通过 pixi-viewport 实现视口裁剪，仅渲染可见区域元素，显著减少绘制调用。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// viewport 配置示例</span><br><span class="hljs-keyword">const</span> viewport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Viewport</span>({<br>  <span class="hljs-attr">interaction</span>: app.<span class="hljs-property">renderer</span>.<span class="hljs-property">plugins</span>.<span class="hljs-property">interaction</span>,<br>  <span class="hljs-attr">cull</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用视口裁剪</span><br>});<br><br>viewport.<span class="hljs-title function_">on</span>(<span class="hljs-string">"frame-end"</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-comment">// 帧结束时可执行额外优化，如清理不可见资源</span><br>});<br></code></pre></td></tr></table></figure><ol><li><strong>Vite HMR（热模块替换）</strong> 在开发环境中利用 Vite 的快速热更新，无需完整页面刷新即可反映代码变更，大幅提升迭代效率。</li></ol><h4 id="TypeScript-在项目中的作用："><a href="#TypeScript-在项目中的作用：" class="headerlink" title="TypeScript 在项目中的作用："></a>TypeScript 在项目中的作用：</h4><ol><li><strong>类型安全</strong> 通过严格接口定义，确保数据一致性与错误早发现。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][];<br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 文本相关</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">textAlign</span>?: <span class="hljs-string">"left"</span> | <span class="hljs-string">"center"</span> | <span class="hljs-string">"right"</span>;<br>  <span class="hljs-comment">// 图像相关</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">filter</span>?: <span class="hljs-string">"none"</span> | <span class="hljs-string">"blur"</span> | <span class="hljs-string">"brightness"</span> | <span class="hljs-string">"grayscale"</span>;<br>  <span class="hljs-comment">// 分组相关</span><br>  <span class="hljs-attr">groupId</span>?: <span class="hljs-built_in">string</span>;<br>}<br></code></pre></td></tr></table></figure><ol><li><strong>智能提示与类型推断</strong>：显著提高编码效率。</li><li><strong>重构安全</strong>：类型系统可在大型重构时快速定位影响范围。</li><li><strong>接口契约</strong>：明确模块间数据结构，提升代码可维护性。</li></ol><h4 id="构建与部署方面"><a href="#构建与部署方面" class="headerlink" title="构建与部署方面"></a>构建与部署方面</h4><ol><li><strong>选用 Vite 的原因</strong><ul><li>极快的开发服务器启动与构建速度</li><li>即时热模块替换（HMR）</li><li>出色的构建性能与 Tree Shaking</li><li>开箱即用的 TypeScript、JSX 和 CSS Modules 支持</li></ul></li><li><strong>Docker 与 GitHub Actions CI/CD</strong><ul><li>项目根目录提供 Dockerfile 和 docker-compose.yml，支持容器化部署。</li><li>GitHub Actions 配置自动化流程：代码检查 → 单元测试 → 构建产物 → 镜像推送 → 部署至目标环境。</li></ul></li></ol><h4 id="样式一致性保证"><a href="#样式一致性保证" class="headerlink" title="样式一致性保证"></a>样式一致性保证</h4><p>为统一多组件库外观，项目实施以下策略：</p><ol><li><strong>TailwindCSS 统一设计系统</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// tailwind.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">theme</span>: {<br>    <span class="hljs-attr">extend</span>: {<br>      <span class="hljs-attr">colors</span>: {<br>        <span class="hljs-attr">primary</span>: colors.<span class="hljs-property">blue</span>,<br>        <span class="hljs-attr">secondary</span>: colors.<span class="hljs-property">gray</span>,<br>      },<br>      <span class="hljs-attr">spacing</span>: {<br>        <span class="hljs-string">'18'</span>: <span class="hljs-string">'4.5rem'</span>,<br>        <span class="hljs-string">'88'</span>: <span class="hljs-string">'22rem'</span>,<br>      },<br>    },<br>  },<br>};<br></code></pre></td></tr></table></figure><ol><li><strong>CSS 变量系统</strong>：定义全局变量（如 —color-primary），确保所有组件引用统一值。</li><li><strong>主题管理</strong>：通过 themeStore.ts（基于 Zustand 或类似状态管理）集中控制主题切换。</li><li><strong>组件包装</strong>：对第三方库组件进行二次封装，统一应用项目样式和行为规范。</li></ol><h3 id="7-挑战与改进"><a href="#7-挑战与改进" class="headerlink" title="7. 挑战与改进"></a>7. 挑战与改进</h3><h4 id="开发过程中遇到的主要技术难点及解决方案"><a href="#开发过程中遇到的主要技术难点及解决方案" class="headerlink" title="开发过程中遇到的主要技术难点及解决方案"></a>开发过程中遇到的主要技术难点及解决方案</h4><p>在项目开发中，我们遇到了几个关键技术挑战，主要集中在实时协作、渲染同步以及性能优化方面。</p><ol><li><p><strong>实时协作冲突处理</strong> 最大的难点之一是多用户同时编辑画布时的数据冲突，可能导致操作覆盖或状态不一致。</p><ul><li>采用 <strong>Yjs 的 CRDT（Conflict-free Replicated Data Type）算法</strong>，自动合并并发修改，无需中央锁定机制，确保最终一致性。</li><li>通过 <strong>HocuspocusProvider</strong> 建立 WebSocket 连接，实现低延迟实时同步。</li><li><p>在 canvasStore.ts 中，利用 Yjs 的 observe 机制监听变更并同步到本地状态管理器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">yElements.<span class="hljs-title function_">observe</span>(<span class="hljs-function">() =&gt;</span> {<br>  useStore.<span class="hljs-title function_">setState</span>({<br>    <span class="hljs-attr">elements</span>: yElements.<span class="hljs-title function_">toJSON</span>(),<br>  });<br>});<br></code></pre></td></tr></table></figure></li><li><p>额外实现锁定机制，防止同步过程中向撤销/重做栈添加无效命令，避免历史污染。</p></li></ul></li><li><p><strong>PixiJS 与 React 状态同步</strong> 另一个重大挑战是保持 PixiJS 渲染层与 React/Zustand 状态的实时一致性，尤其在元素数量较多时易导致延迟或不一致。</p><ul><li>创建 Pixi_stageManager.ts 作为桥梁层，负责双向同步 React 状态与 PixiJS 显示对象。</li><li>使用 spriteMap 缓存 PixiJS 对象，避免重复创建/销毁。</li><li>引入防抖（debounce）机制，限制频繁同步频率。</li><li>实现选择性更新，仅针对变更元素进行渲染。</li></ul></li><li><p><strong>性能优化挑战</strong> 当画布元素数量激增时，渲染和交互性能显著下降。</p><ul><li>启用视口裁剪（viewport culling），仅渲染当前可见区域元素。</li><li>引入对象池和缓存机制，减少内存分配开销。</li><li>采用批量更新（batchUpdateElements），降低状态变更引起的多次重渲染。</li><li><p>针对静态元素启用 cacheAsBitmap，将内容烘焙为位图以减少重绘。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 示例：针对静态元素启用位图缓存</span><br><span class="hljs-keyword">if</span> (sprite.<span class="hljs-property">isStatic</span> &amp;&amp; !sprite.<span class="hljs-property">cacheAsBitmap</span>) {<br>  sprite.<span class="hljs-property">cacheAsBitmap</span> = <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GitHub 仓库 &lt;a href=&quot;https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com&quot;&gt;https://github.com/Zhongye1/BDdraw_DEV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该项目技术栈先进（R</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-28-力扣百题速练（Javascript、TypeScript）Vol.3</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/42325.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/42325.html</id>
    <published>2025-12-28T18:15:44.000Z</published>
    <updated>2025-12-28T18:24:57.620Z</updated>
    
    <content type="html"><![CDATA[<p>依旧刷题中</p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><p>输入：l1 = <code>[1,2,4]</code>, l2 = <code>[1,3,4]</code><br>输出：<code>[1,1,2,3,4,4]</code></p><p><strong>示例 2：</strong></p><p>输入：l1 = <code>[]</code>, l2 = <code>[]</code><br>输出：<code>[]</code></p><p><strong>示例 3：</strong></p><p>输入：l1 = <code>[]</code>, l2 = <code>[0]</code><br>输出：<code>[0]</code></p><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>Related Topics</p><ul><li>递归</li><li>链表</li></ul><p>解法很简单，假设输入两个有序链表：</p><p>list1: 1 → 2 → 4 list2: 1 → 3 → 4</p><p>合并过程逐步展示指针变化（→ 表示 next 指针，cur 为当前构建指针）：</p><p><strong>初始状态</strong> dummy → null cur = dummy list1: 1 → 2 → 4 list2: 1 → 3 → 4</p><p><strong>步骤 1</strong>：比较 list1.val(1) ≤ list2.val(1) cur.next = list1 的 1 cur 前进 → 指向 1 list1 前进 → 2 → 4 当前新链表：dummy → 1</p><p><strong>步骤 2</strong>：比较 list1.val(2) &gt; list2.val(1) cur.next = list2 的 1 cur 前进 → 指向 1 list2 前进 → 3 → 4 当前新链表：dummy → 1 → 1</p><p><strong>步骤 3</strong>：比较 list1.val(2) ≤ list2.val(3) cur.next = list1 的 2 cur 前进 → 指向 2 list1 前进 → 4 当前新链表：dummy → 1 → 1 → 2</p><p><strong>步骤 4</strong>：比较 list1.val(4) &gt; list2.val(3) cur.next = list2 的 3 cur 前进 → 指向 3 list2 前进 → 4 当前新链表：dummy → 1 → 1 → 2 → 3</p><p><strong>步骤 5</strong>：比较 list1.val(4) ≤ list2.val(4) cur.next = list1 的 4 cur 前进 → 指向 4 list1 前进 → null 当前新链表：dummy → 1 → 1 → 2 → 3 → 4</p><p><strong>步骤 6</strong>：list1 已空，剩余 list2(4) 直接接上 cur.next = list2 的 4 当前新链表：dummy → 1 → 1 → 2 → 3 → 4 → 4</p><p><strong>最终返回</strong>：dummy.next 结果链表：1 → 1 → 2 → 3 → 4 → 4</p><p>该过程通过不断比较两个链表的当前节点，将较小节点直接拼接至新链表尾部（cur 后），并前进对应指针，直至处理完所有节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"><span class="hljs-attr">list1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">list2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {  <br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>  <br>    <span class="hljs-keyword">let</span> dum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>)  <br>  <br>    <span class="hljs-keyword">let</span> cur = dum  <br>  <br>    <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) {  <br>        <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &lt;= list2.<span class="hljs-property">val</span>) {  <br>            cur.<span class="hljs-property">next</span> = list1;        <span class="hljs-comment">// 将较小节点接到 cur 后  </span><br>            list1 = list1.<span class="hljs-property">next</span>;      <span class="hljs-comment">// list1 前进  </span><br>        } <span class="hljs-keyword">else</span> {  <br>            cur.<span class="hljs-property">next</span> = list2;  <br>            list2 = list2.<span class="hljs-property">next</span>;  <br>        }  <br>        cur = cur.<span class="hljs-property">next</span>;              <span class="hljs-comment">// cur 前进  </span><br>    }  <br>  <br>    cur.<span class="hljs-property">next</span> = list1 || list2  <br>    <span class="hljs-keyword">return</span> dum.<span class="hljs-property">next</span>  <br>  <br>};<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;依旧刷题中&lt;/p&gt;
&lt;h2 id=&quot;21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21.合并两个有序链表&quot;&gt;&lt;/a&gt;21.合并两个有序链表&lt;/h2&gt;&lt;p&gt;将两个升序链表合并为一个新的 &lt;stron</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-28-前端学习-接口类型定义、Axios 封装与请求规范</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/16956.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/16956.html</id>
    <published>2025-12-28T17:01:18.000Z</published>
    <updated>2025-12-28T17:49:02.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于接口类型定义、Axios-封装与请求规范的常见问题"><a href="#关于接口类型定义、Axios-封装与请求规范的常见问题" class="headerlink" title="关于接口类型定义、Axios 封装与请求规范的常见问题"></a>关于接口类型定义、Axios 封装与请求规范的常见问题</h3><p>使用 TypeScript 的 React 或 Vue 项目中，通常会高度重视网络层的工程化实践，通常会从实际项目经验入手，逐步深入到设计理念、类型安全和最佳实践</p><p>关于接口类型定义、Axios 封装与请求规范的常见问题整理如下：</p><h4 id="基本经验与动机"><a href="#基本经验与动机" class="headerlink" title="基本经验与动机"></a>基本经验与动机</h4><ul><li><p><strong>在项目中是否对 Axios 进行过二次封装？为什么需要封装，而不是直接使用原生 Axios？</strong> 是的，在所有中大型项目中都会对 Axios 进行二次封装。主要原因是原生 Axios 配置分散、重复代码多（如每个请求都需手动设置 baseURL、headers 和错误处理）。封装后可以统一管理公共逻辑，减少冗余，提升代码一致性和可维护性，避免直接使用导致的配置不统一和后期修改困难。</p></li><li><p><strong>Vue/React 项目中，你们是怎么管理 API 接口的？有统一的请求封装吗？</strong> 我们采用统一的请求封装层。通常创建一个独立的 apiClient 实例作为基础，然后在 services 或 api 目录下按业务模块（如 auth、user、room）划分文件，每个模块导出具体的请求函数。所有接口调用都通过这些封装函数进行，确保风格一致、类型安全，并便于后期维护和 mock。</p></li><li><p><strong>说说 Axios 二次封装的主要目的和好处？</strong> 主要目的是统一配置和公共逻辑处理，包括 baseURL、超时、Token 添加、错误统一处理等。好处包括：减少重复代码、提升可维护性、统一错误提示和加载状态、便于环境切换、支持类型安全（TS 项目），最终降低 bug 率并提高团队开发效率。</p></li></ul><h4 id="实现细节与规范"><a href="#实现细节与规范" class="headerlink" title="实现细节与规范"></a>实现细节与规范</h4><ul><li><p><strong>怎么封装 Axios 的？主要封装了哪些方面（如 baseURL、超时、请求/响应拦截器、错误处理）？</strong> 首先使用 axios.create() 创建实例，设置 baseURL、timeout 和默认 headers。然后添加请求拦截器统一注入 Token 和加载状态；响应拦截器中提取 data、处理业务 code、统一错误提示（如 401 跳转登录），并支持 Token 刷新重试。</p></li><li><p><strong>在项目中，如何统一处理请求头（如添加 Token）、环境切换（开发/生产 baseURL）和错误提示？</strong> 请求头通过请求拦截器或 setAuthToken 函数统一添加 Authorization；环境切换利用 Vite 或 Webpack 的环境变量动态设置 baseURL；错误提示在响应拦截器中根据 status 或业务 code 统一处理，使用 toast 组件显示消息，或触发全局错误处理逻辑。</p></li><li><p><strong>封装后，如何组织和管理具体的 API 接口？（如按模块分文件、统一导出）</strong> 按业务模块分文件（如 auth.ts、room.ts），每个文件定义相关接口函数并导出；再创建一个 index.ts 统一导出所有模块，便于在业务组件中按需导入（如 import { login } from ‘@/api’）。这样结构清晰，便于维护和权限控制。</p></li><li><p><strong>如何处理请求取消、重复请求防抖或加载状态？</strong> 使用 Axios CancelToken 或 AbortController 实现请求取消，适用于组件卸载或搜索防抖场景；重复请求通过 URL + 方法 + 参数的 Map 缓存取消函数实现防重；加载状态可在拦截器中 dispatch 全局 loading action，或在单个请求中使用 async/await 结合状态管理。</p></li></ul><h4 id="类型安全与工程化（TypeScript）"><a href="#类型安全与工程化（TypeScript）" class="headerlink" title="类型安全与工程化（TypeScript）"></a>类型安全与工程化（TypeScript）</h4><ul><li><p><strong>在使用 TypeScript 的项目中，你是怎么结合接口类型定义来封装 Axios 的？如何实现响应数据的类型推导？</strong> 先在 types/api.ts 中集中定义所有接口的请求参数和响应类型。然后在服务函数中使用 Axios 泛型，如 <code>apiClient.get&lt;RoomListResponse&gt;(url)</code>，这样返回值的类型自动推导为定义的接口类型，实现全程类型检查和编辑器提示。</p></li><li><p><strong>说说 Axios 泛型的使用，比如如何通过 <code>&lt;T&gt;</code> 指定返回类型，确保调用时有类型提示和检查？</strong> 通过 <code>apiClient.post&lt;T&gt;(url, data)</code>的方式指定泛型 T 为具体响应类型（如 LoginResponse）。这样调用时 TypeScript 会自动推导返回值属性，提供属性提示和编译时错误检查（如访问不存在字段会报错），显著提升类型安全。</p></li><li><p><strong>怎么定义接口请求参数和响应类型的？有统一的响应包装类型（如 <code>ApiResponse&lt;T&gt;</code>）吗？</strong> 定义通用包装类型 <code>interface ApiResponse&lt;T&gt; { code: number; data: T; message?: string; }</code> 所有接口响应类型继承此泛型（如 <code>type LoginResponse = ApiResponse&lt;{ token: string }&gt;;）</code>，便于统一处理业务 code 和错误。</p></li><li><p><strong>在封装中，如何处理拦截器或自定义配置的 TypeScript 类型扩展（如扩展 AxiosRequestConfig）？</strong> 通过模块声明扩展 AxiosRequestConfig 接口，添加自定义字段（如 _retry: boolean 用于 Token 刷新）。拦截器参数类型自然继承扩展后的配置，确保类型兼容和提示完整。</p></li><li><p><strong>如果后端返回结构不统一，怎么通过类型守卫或转型确保类型安全？</strong></p></li></ul><blockquote><p>类型守卫（Type Guard）是 TypeScript 中的一种机制，用于在运行时缩小变量的类型范围，从而让编译器在特定代码块中更精确地推断变量的类型。它本质上是一个返回布尔值的表达式或函数，当该表达式为 true 时，TypeScript 会自动将变量的类型收窄（narrow）为更具体的类型。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//typeof 类型守卫 使用 JavaScript 的 typeof 操作符</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {<br>    <span class="hljs-comment">// 这里 value 被收窄为 string</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>());<br>  } <span class="hljs-keyword">else</span> {<br>  <span class="hljs-comment">// 这里 value 被收窄为 number</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));<br>  }<br>}<br></code></pre></td></tr></table></figure><p>在响应拦截器中先转型为 any 或 unknown，然后使用类型守卫（如 if (‘code’ in res &amp;&amp; res.code === 0)）判断成功，再返回 res.data 并断言为具体类型。这样既兼容不统一结构，又保持业务层类型安全</p><h4 id="深度与实践相关"><a href="#深度与实践相关" class="headerlink" title="深度与实践相关"></a>深度与实践相关</h4><ul><li><p><strong>封装后，在业务组件中调用接口的体验如何？相比直接用 Axios 有哪些改进？</strong> 体验显著提升：调用简洁，自动获得类型提示和错误检查；无需关心 Token、baseURL 或错误处理。相比直接使用，减少了大量样板代码，降低了出错概率，并提高了代码可读性。</p></li><li><p><strong>有考虑过从 OpenAPI/Swagger 自动生成类型和接口函数吗？</strong> 是的，在较大项目中会使用 openapi-typescript 或 swagger-typescript-api 从后端 OpenAPI 文档自动生成类型和请求函数。这样保持前后端类型一致，减少手动维护成本，并进一步提升工程化水平。</p></li><li><p><strong>如果项目规模很大，是怎么进一步优化网络层的（如模块化、服务层分离）？</strong> 通过严格的服务层分离：apiClient 只负责基础请求，services 层按领域划分（如 userService、orderService），每个服务聚合相关接口并处理业务逻辑；结合代码生成和 mock 工具，实现高度模块化和可测试性。</p></li><li><p><strong>说说项目中网络请求的常见痛点，以及封装如何解决的。</strong> 常见痛点包括 Token 管理散乱、错误处理不统一、环境配置易错、类型不安全。二次封装通过拦截器统一 Token 和错误、环境变量管理配置、TS 泛型确保类型安全，有效解决了这些问题，显著降低了联调和维护成本。</p></li></ul><hr><h3 id="Axios-封装与接口管理具体实现"><a href="#Axios-封装与接口管理具体实现" class="headerlink" title="Axios 封装与接口管理具体实现"></a>Axios 封装与接口管理具体实现</h3><h4 id="基础的实现"><a href="#基础的实现" class="headerlink" title="基础的实现"></a>基础的实现</h4><ol><li><p><strong>如何封装 Axios？</strong> 一个典型的 Axios 封装结构如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/utils/apiClient.ts</span><br><span class="hljs-keyword">import</span> axios, { <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosRequestConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<br><br><span class="hljs-keyword">const</span> apiClient = axios.<span class="hljs-title function_">create</span>({<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span> || <span class="hljs-string">"/api"</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,<br>  <span class="hljs-attr">headers</span>: {<br>    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,<br>  },<br>});<br><br><span class="hljs-comment">// 请求拦截器</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"token"</span>);<br>    <span class="hljs-keyword">if</span> (token) {<br>      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>;<br>    }<br>    <span class="hljs-keyword">return</span> config;<br>  },<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>);<br><br><span class="hljs-comment">// 响应拦截器</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-property">data</span>,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) {<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">"token"</span>);<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">"/login"</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  }<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> apiClient;<br></code></pre></td></tr></table></figure></li><li><p><strong>如何统一处理请求头、环境切换和错误提示？</strong></p><ul><li><strong>环境切换</strong>：通过 Vite 或 Webpack 的环境变量（如 VITE_API_BASE_URL）动态配置 baseURL。</li><li><strong>请求头处理</strong>：在请求拦截器中统一注入 Authorization 等认证头。</li><li><strong>错误提示</strong>：在响应拦截器中根据状态码或业务码统一处理错误，例如 401 跳转登录、500 显示服务器错误提示。</li></ul></li><li><p><strong>如何组织和管理具体的 API 接口？</strong> 按业务模块划分文件，并统一导出，便于维护。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/index.ts</span><br><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> userApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"./user"</span>;<br><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> roomApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"./room"</span>;<br><br><span class="hljs-comment">// api/room.ts</span><br><span class="hljs-keyword">import</span> apiClient <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils/apiClient"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">RoomResponse</span>, <span class="hljs-title class_">CreateRoomRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;<br><br><span class="hljs-keyword">const</span> roomApi = {<br>  <span class="hljs-attr">getRooms</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">params</span>: { page: <span class="hljs-built_in">number</span>; size: <span class="hljs-built_in">number</span> }</span>) =&gt;</span><br>    apiClient.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">RoomResponse</span>&gt;(<span class="hljs-string">"/rooms"</span>, { params }),<br>  <span class="hljs-attr">createRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-title class_">CreateRoomRequest</span></span>) =&gt;</span> apiClient.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/rooms"</span>, data),<br>  <span class="hljs-attr">updateRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CreateRoomRequest</span>&gt;</span>) =&gt;</span><br>    apiClient.<span class="hljs-title function_">put</span>(<span class="hljs-string">`/rooms/<span class="hljs-subst">${id}</span>`</span>, data),<br>  <span class="hljs-attr">deleteRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> apiClient.<span class="hljs-title function_">delete</span>(<span class="hljs-string">`/rooms/<span class="hljs-subst">${id}</span>`</span>),<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> roomApi;<br></code></pre></td></tr></table></figure></li><li><p><strong>如何处理请求取消、重复请求防抖或加载状态？</strong> 使用 AbortController 实现请求取消和防重提交。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">AbortController</span>&gt;();<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {<br>  <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${config.method?.toUpperCase()}</span><span class="hljs-subst">${config.url}</span>`</span>;<br>  <span class="hljs-keyword">if</span> (pendingRequests.<span class="hljs-title function_">has</span>(requestKey)) {<br>    pendingRequests.<span class="hljs-title function_">get</span>(requestKey)?.<span class="hljs-title function_">abort</span>();<br>  }<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>  config.<span class="hljs-property">signal</span> = controller.<span class="hljs-property">signal</span>;<br>  pendingRequests.<span class="hljs-title function_">set</span>(requestKey, controller);<br>  <span class="hljs-keyword">return</span> config;<br>});<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${response.config.method?.toUpperCase()}</span><span class="hljs-subst">${</span></span><br><span class="hljs-subst"><span class="hljs-string">      response.config.url</span></span><br><span class="hljs-subst"><span class="hljs-string">    }</span>`</span>;<br>    pendingRequests.<span class="hljs-title function_">delete</span>(requestKey);<br>    <span class="hljs-keyword">return</span> response;<br>  },<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">config</span>) {<br>      <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${error.config.method?.toUpperCase()}</span><span class="hljs-subst">${</span></span><br><span class="hljs-subst"><span class="hljs-string">        error.config.url</span></span><br><span class="hljs-subst"><span class="hljs-string">      }</span>`</span>;<br>      pendingRequests.<span class="hljs-title function_">delete</span>(requestKey);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  }<br>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="类型安全与工程化（TypeScript）-1"><a href="#类型安全与工程化（TypeScript）-1" class="headerlink" title="类型安全与工程化（TypeScript）"></a>类型安全与工程化（TypeScript）</h4><ol><li><p><strong>如何结合接口类型定义封装 Axios？</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/types/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Room</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">updatedAt</span>: <span class="hljs-built_in">string</span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RoomResponse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApiResponse</span>&lt;<span class="hljs-title class_">Room</span>[]&gt; {<br>  <span class="hljs-attr">pagination</span>: { <span class="hljs-attr">page</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span> };<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CreateRoomRequest</span> {<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>?: <span class="hljs-built_in">string</span>;<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>Axios 泛型的使用</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// apiService.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<br><span class="hljs-keyword">import</span> apiClient <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils/apiClient"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">ApiResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> {<br>  <span class="hljs-keyword">async</span> get&lt;T&gt;(<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">config</span>?: <span class="hljs-title class_">AxiosRequestConfig</span><br>  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; = <span class="hljs-keyword">await</span> apiClient.<span class="hljs-title function_">get</span>(<br>      url,<br>      config<br>    );<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  }<br><br>  <span class="hljs-keyword">async</span> post&lt;T, D = <span class="hljs-built_in">any</span>&gt;(<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">data</span>?: D,<br>    <span class="hljs-attr">config</span>?: <span class="hljs-title class_">AxiosRequestConfig</span><br>  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; = <span class="hljs-keyword">await</span> apiClient.<span class="hljs-title function_">post</span>(<br>      url,<br>      data,<br>      config<br>    );<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  }<br><br>  <span class="hljs-comment">// put、delete 同理</span><br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apiService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiService</span>();<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> apiService.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">Room</span>[]&gt;(<span class="hljs-string">"/rooms"</span>, {<br>    <span class="hljs-attr">params</span>: { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> },<br>  });<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>; <span class="hljs-comment">// 类型为 Room[]</span><br>};<br></code></pre></td></tr></table></figure></li><li><p><strong>定义统一的响应包装类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiError</span> {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">details</span>?: <span class="hljs-built_in">any</span>;<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>拦截器的 TypeScript 类型扩展</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 扩展 AxiosRequestConfig</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomAxiosRequestConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosRequestConfig</span> {<br>  <span class="hljs-attr">showLoading</span>?: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showError</span>?: <span class="hljs-built_in">boolean</span>;<br>}<br><br><span class="hljs-comment">// 在拦截器中使用</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">config</span>: <span class="hljs-title class_">CustomAxiosRequestConfig</span></span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">showLoading</span> !== <span class="hljs-literal">false</span>) {<br>    <span class="hljs-comment">// 显示加载状态</span><br>  }<br>  <span class="hljs-keyword">return</span> config;<br>});<br></code></pre></td></tr></table></figure></li><li><p><strong>处理不统一的后端返回结构</strong> 使用类型守卫确保类型安全。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> isApiResponse&lt;T&gt;(<span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>): data is <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-keyword">return</span> (<br>    data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-string">"code"</span> <span class="hljs-keyword">in</span> data &amp;&amp; <span class="hljs-string">"data"</span> <span class="hljs-keyword">in</span> data<br>  );<br>}<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isApiResponse</span>(response.<span class="hljs-property">data</span>)) {<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> { <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>, <span class="hljs-attr">data</span>: response.<span class="hljs-property">data</span> };<br>  }<br>});<br></code></pre></td></tr></table></figure></li></ol><h4 id="应用及其后期实践"><a href="#应用及其后期实践" class="headerlink" title="应用及其后期实践"></a>应用及其后期实践</h4><ol><li><p><strong>封装后在业务组件中的使用</strong> 封装后调用更加简洁、安全，无需重复处理 Token、错误或类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 未封装前</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/rooms"</span>);<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">catch</span> (error) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  }<br>};<br><br><span class="hljs-comment">// 封装后</span><br><span class="hljs-keyword">import</span> { roomApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/api"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> roomApi.<span class="hljs-title function_">getRooms</span>({ <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> });<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">catch</span> (error) {<br>    <span class="hljs-comment">// 错误已统一处理</span><br>  }<br>};<br></code></pre></td></tr></table></figure></li><li><p><strong>OpenAPI/Swagger 自动生成类型和接口函数</strong> 可使用 openapi-typescript-codegen 或 swagger-typescript-api 等工具从后端 OpenAPI 文档自动生成类型定义和请求函数，实现前后端类型完全一致，显著减少手动维护成本。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于接口类型定义、Axios-封装与请求规范的常见问题&quot;&gt;&lt;a href=&quot;#关于接口类型定义、Axios-封装与请求规范的常见问题&quot; class=&quot;headerlink&quot; title=&quot;关于接口类型定义、Axios 封装与请求规范的常见问题&quot;&gt;&lt;/a&gt;关于接口类</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-27-前端画布设计Vol.3 实时协作（Yjs + Hocuspocus + 持久化）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/60421.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/60421.html</id>
    <published>2025-12-27T21:46:01.000Z</published>
    <updated>2025-12-29T07:44:06.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时协作画布系统：Yjs-Hocuspocus-持久化"><a href="#实时协作画布系统：Yjs-Hocuspocus-持久化" class="headerlink" title="实时协作画布系统：Yjs + Hocuspocus + 持久化"></a>实时协作画布系统：Yjs + Hocuspocus + 持久化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在设计工具、白板应用和文档编辑器中，多用户同时编辑同一文档的需求日益增长。传统的客户端-服务器模型在这种场景下存在诸多挑战，例如冲突解决、网络延迟和离线支持等。</p><p>为了支持多用户同时编辑画布内容，并具备离线编辑能力，我们采用了 Yjs（一种 CRDT 实现）配合 IndexedDB 和 Hocuspocus 的架构方案。</p><h2 id="核心技术组件"><a href="#核心技术组件" class="headerlink" title="核心技术组件"></a>核心技术组件</h2><h3 id="Yjs-Y-Map"><a href="#Yjs-Y-Map" class="headerlink" title="Yjs (Y.Map)"></a>Yjs (Y.Map)</h3><p>Yjs 是一个用于创建实时协作应用程序的库，它实现了 Conflict-free Replicated Data Types (CRDTs) 算法。CRDTs 是一种特殊的数据结构，可以在多个副本之间同步，而不需要中央协调，从而保证最终一致性。</p><p>Y.Map 是 Yjs 提供的一种共享数据类型，类似于 JavaScript 中的 Map。它的关键特性包括：</p><ul><li><strong>自动冲突解决</strong>：当多个用户同时修改数据时，Yjs 自动解决冲突</li><li><strong>分布式一致性</strong>：保证所有客户端看到相同的数据状态</li><li><strong>高效同步</strong>：只传输变更部分，减少网络流量</li></ul><h3 id="持久化选项"><a href="#持久化选项" class="headerlink" title="持久化选项"></a>持久化选项</h3><p>持久化是协作系统的关键组件，不仅需要在客户端存储数据以支持离线使用，还需要在服务端存储数据以实现长期保存和共享。本项目实际实现的持久化策略包括：</p><h4 id="1-IndexedDB（客户端）"><a href="#1-IndexedDB（客户端）" class="headerlink" title="1. IndexedDB（客户端）"></a>1. IndexedDB（客户端）</h4><p>IndexedDB 是浏览器内置的数据库，用于存储大量结构化数据。在协作系统中，它用于：</p><ul><li>使用 <code>y-indexeddb</code> 库创建 IndexeddbPersistence 实例</li><li>为每个房间创建独立的 IndexedDB 存储 (<code>canvas-local-db-${roomId}</code>)</li><li>提供 getYDocForRoom、getYElementsForRoom 和 getIndexedDBProviderForRoom 等函数来管理不同房间的数据</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Y <span class="hljs-keyword">from</span> <span class="hljs-string">'yjs'</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IndexeddbPersistence</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'y-indexeddb'</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HocuspocusProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@hocuspocus/provider'</span>; <span class="hljs-comment">// 如需实时同步时导入</span><br><br><span class="hljs-comment">// 使用 Map 存储不同房间的 Yjs 文档及相关提供者，确保单例管理和数据隔离</span><br><span class="hljs-keyword">const</span> roomDocuments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<br>  <span class="hljs-built_in">string</span>,<br>  {<br>    <span class="hljs-attr">yDoc</span>: Y.<span class="hljs-property">Doc</span>;<br>    <span class="hljs-attr">yElements</span>: Y.<span class="hljs-property">Map</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>    <span class="hljs-attr">indexeddbProvider</span>: <span class="hljs-title class_">IndexeddbPersistence</span>;<br>    <span class="hljs-attr">wsProvider</span>: <span class="hljs-title class_">HocuspocusProvider</span> | <span class="hljs-literal">null</span>;<br>  }<br>&gt;();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取或创建指定房间的 Yjs 文档实例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> roomId 协作房间的唯一标识符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 该房间对应的 Y.Doc 实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getYDocForRoom = (<span class="hljs-attr">roomId</span>: <span class="hljs-built_in">string</span>): Y.<span class="hljs-property">Doc</span> =&gt; {<br>  <span class="hljs-comment">// 若该房间的文档已存在，直接复用以避免重复创建</span><br>  <span class="hljs-keyword">if</span> (roomDocuments.<span class="hljs-title function_">has</span>(roomId)) {<br>    <span class="hljs-keyword">return</span> roomDocuments.<span class="hljs-title function_">get</span>(roomId)!.<span class="hljs-property">yDoc</span>;<br>  }<br><br>  <span class="hljs-comment">// 创建新的 Yjs 文档实例</span><br>  <span class="hljs-keyword">const</span> yDoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br><br>  <span class="hljs-comment">// 获取画布元素的核心数据结构（Y.Map，用于存储所有 CanvasElement）</span><br>  <span class="hljs-keyword">const</span> yElements = yDoc.<span class="hljs-property">getMap</span>&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-string">'elements'</span>);<br><br>  <span class="hljs-comment">// 初始化 IndexedDB 持久化提供者</span><br>  <span class="hljs-comment">// 数据库名称动态包含 roomId，确保不同房间的数据互不干扰</span><br>  <span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<span class="hljs-string">`canvas-local-db-<span class="hljs-subst">${roomId}</span>`</span>, yDoc);<br><br>  <span class="hljs-comment">// 将文档相关信息存入 Map，便于后续访问和管理</span><br>  roomDocuments.<span class="hljs-title function_">set</span>(roomId, {<br>    yDoc,<br>    yElements,<br>    indexeddbProvider,<br>    <span class="hljs-attr">wsProvider</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 初始为空，后续可动态绑定 HocuspocusProvider 以实现实时协作</span><br>  });<br><br>  <span class="hljs-keyword">return</span> yDoc;<br>};<br></code></pre></td></tr></table></figure><ul><li><strong>离线数据存储</strong>：即使用户断网，数据也不会丢失</li><li><strong>快速本地访问</strong>：减少对服务器的依赖</li><li><strong>大容量存储</strong>：相比 localStorage，支持更大的数据量</li></ul><h4 id="2-SQLite（服务端）"><a href="#2-SQLite（服务端）" class="headerlink" title="2. SQLite（服务端）"></a>2. SQLite（服务端）</h4><p>SQLite 作为服务端数据库，用于持久化存储画布内容：</p><ul><li><strong>关系型结构</strong>：提供 SQL 查询能力</li><li><strong>轻量级</strong>：无需单独的服务器进程</li><li><strong>跨平台</strong>：可在多种环境中运行</li><li><strong>服务端存储</strong>：确保数据在服务端持久化</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 服务端数据库实现 (ALD_Backend/src/db.ts)</span><br><br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Database</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"bun:sqlite"</span>;<br><span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>(<span class="hljs-string">"collab.sqlite"</span>);<br><br><span class="hljs-comment">// 启用 WAL 模式以提高并发性能</span><br>db.<span class="hljs-title function_">exec</span>(<span class="hljs-string">"PRAGMA journal_mode = WAL;"</span>);<br><span class="hljs-comment">// 房间表，包含 content BLOB 字段存储 Yjs 二进制数据</span><br>db.<span class="hljs-title function_">run</span>(<span class="hljs-string">`</span><br><span class="hljs-string">  CREATE TABLE IF NOT EXISTS rooms (</span><br><span class="hljs-string">    id TEXT PRIMARY KEY,</span><br><span class="hljs-string">    name TEXT NOT NULL,</span><br><span class="hljs-string">    creator_id TEXT NOT NULL,</span><br><span class="hljs-string">    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,</span><br><span class="hljs-string">    content BLOB, -- Yjs 二进制数据</span><br><span class="hljs-string">    FOREIGN KEY (creator_id) REFERENCES users(id)</span><br><span class="hljs-string">  )</span><br><span class="hljs-string">`</span>);<br><br><span class="hljs-comment">// Hocuspocus 数据库扩展实现 (ALD_Backend/src/collab.ts)</span><br><br><span class="hljs-keyword">const</span> dbExtension = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HocuspocusDB</span>({<br>  <span class="hljs-attr">fetch</span>: <span class="hljs-title function_">async</span> ({ documentName }) =&gt; {<br>    <span class="hljs-keyword">const</span> roomId = <span class="hljs-title function_">getRoomId</span>(documentName);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">`[Yjs] Fetching data for RoomID: <span class="hljs-subst">${roomId}</span>, Original documentName: <span class="hljs-subst">${documentName}</span>`</span><br>    );<br><br>    <span class="hljs-keyword">const</span> query = db.<span class="hljs-title function_">query</span>(<span class="hljs-string">"SELECT content FROM rooms WHERE id = $id"</span>);<br>    <span class="hljs-keyword">const</span> row = query.<span class="hljs-title function_">get</span>({ <span class="hljs-attr">$id</span>: roomId }) <span class="hljs-keyword">as</span> {<br>      <span class="hljs-attr">content</span>: <span class="hljs-title class_">Uint8Array</span> | <span class="hljs-literal">null</span>;<br>    } | <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (row &amp;&amp; row.<span class="hljs-property">content</span> !== <span class="hljs-literal">null</span> &amp;&amp; row.<span class="hljs-property">content</span> !== <span class="hljs-literal">undefined</span>) {<br>      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">content</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`[Yjs] Returning data with size: <span class="hljs-subst">${row.content.length}</span> bytes`</span><br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(row.<span class="hljs-property">content</span>);<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] content is empty, creating new Yjs document`</span>);<br>        <span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br>        ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>); <span class="hljs-comment">// 存储图形元素</span><br>        <span class="hljs-keyword">return</span> Y.<span class="hljs-title function_">encodeStateAsUpdate</span>(ydoc);<br>      }<br>    }<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] No valid data found, creating new Yjs document`</span>);<br>    <span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br>    ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>); <span class="hljs-comment">// 存储图形元素</span><br>    <span class="hljs-keyword">return</span> Y.<span class="hljs-title function_">encodeStateAsUpdate</span>(ydoc);<br>  },<br><br>  <span class="hljs-attr">store</span>: <span class="hljs-title function_">async</span> ({ documentName, state }) =&gt; {<br>    <span class="hljs-keyword">const</span> roomId = <span class="hljs-title function_">getRoomId</span>(documentName);<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>        <span class="hljs-string">`[Yjs] Saving data for RoomID: <span class="hljs-subst">${roomId}</span>, State size: <span class="hljs-subst">${state.length}</span> bytes, Original documentName: <span class="hljs-subst">${documentName}</span>`</span><br>      );<br><br>      <span class="hljs-keyword">if</span> (state.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">const</span> roomCheck = db.<span class="hljs-title function_">query</span>(<span class="hljs-string">"SELECT id FROM rooms WHERE id = $id"</span>);<br><br>        <span class="hljs-keyword">const</span> roomExists = roomCheck.<span class="hljs-title function_">get</span>({ <span class="hljs-attr">$id</span>: roomId });<br><br>        <span class="hljs-keyword">if</span> (!roomExists) {<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<br>            <span class="hljs-string">`[Yjs] Room <span class="hljs-subst">${roomId}</span> does not exist, cannot save data`</span><br>          );<br><br>          <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">const</span> update = db.<span class="hljs-title function_">query</span>(<br>          <span class="hljs-string">"UPDATE rooms SET content = $blob WHERE id = $id"</span><br>        );<br><br>        update.<span class="hljs-title function_">run</span>({ <span class="hljs-attr">$blob</span>: state, <span class="hljs-attr">$id</span>: roomId });<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] Data saved successfully for RoomID: <span class="hljs-subst">${roomId}</span>`</span>);<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`[Yjs] Skipping save for RoomID: <span class="hljs-subst">${roomId}</span> as state is empty`</span><br>        );<br>      }<br>    } <span class="hljs-keyword">catch</span> (error) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[Yjs] Save failed for <span class="hljs-subst">${roomId}</span>:`</span>, error);<br>    }<br>  },<br>});<br></code></pre></td></tr></table></figure><h3 id="Hocuspocus-Provider"><a href="#Hocuspocus-Provider" class="headerlink" title="Hocuspocus Provider"></a>Hocuspocus Provider</h3><p>Hocuspocus 是一个协作编辑框架，提供了 Yjs 的服务器端实现。它负责：</p><ul><li><strong>多客户端同步</strong>：协调多个客户端之间的数据同步</li><li><strong>WebSocket 连接管理</strong>：建立持久连接</li><li><strong>房间管理</strong>：隔离不同协作空间的数据</li><li><strong>与多种持久化后端集成</strong>：可连接到数据库、文件系统等</li></ul><h2 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    subgraph "Frontend Application (React/Vue)"<br>        A[Canvas UI Components]<br>        B[State Management&lt;br/&gt;Zustand/Pinia]<br>        C[Yjs Document&lt;br/&gt;Shared Data]<br>        D[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    subgraph "Backend Services"<br>        E[Hono Server&lt;br/&gt;Port 3000]<br>        F[RESTful API&lt;br/&gt;Auth/RM]<br>        G[SQLite DB&lt;br/&gt;Persistence]<br>    end<br>    subgraph "WebSocket Services"<br>        H[Hocuspocus Server&lt;br/&gt;Port 1234]<br>        I[Yjs Extensions&lt;br/&gt;DB/Storage]<br>    end<br>    A &lt;--&gt; C<br>    B &lt;--&gt; C<br>    C &lt;--&gt; D<br>    C &lt;--&gt; H<br>    E &lt;--&gt; F<br>    E &lt;--&gt; G<br>    F &lt;--&gt; H<br>    H &lt;--&gt; I<br>    I &lt;--&gt; G<br>    style A fill:#87CEEB<br>    style B fill:#98FB98<br>    style C fill:#FFD700<br>    style D fill:#DDA0DD<br>    style E fill:#F0E68C<br>    style F fill:#FFA07A<br>    style G fill:#BA55D3<br>    style H fill:#20B2AA<br>    style I fill:#FF69B4<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>    subgraph "Client A"<br>        A[Y.Map&lt;br/&gt;Shared Data]<br>        B[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    subgraph "Server"<br>        C[Hocuspocus&lt;br/&gt;Server]<br>        D[SQLite DB&lt;br/&gt;Persistence]<br>    end<br>    subgraph "Client B"<br>        E[Y.Map&lt;br/&gt;Shared Data]<br>        F[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    A &lt;--&gt; C<br>    E &lt;--&gt; C<br>    B &lt;--&gt; D<br>    F &lt;--&gt; D<br>    C &lt;--&gt; D<br>    style A fill:#FFD700<br>    style B fill:#DDA0DD<br>    style C fill:#20B2AA<br>    style D fill:#BA55D3<br>    style E fill:#FFD700<br>    style F fill:#DDA0DD<br></code></pre></td></tr></table></figure><h3 id="数据流向"><a href="#数据流向" class="headerlink" title="数据流向"></a>数据流向</h3><ol><li>用户操作更新本地 Y.Map</li><li>变更自动同步到 IndexedDB（本地持久化）</li><li>变更通过 Hocuspocus 同步到服务器和其他客户端</li><li>服务器将变更存储到 SQLite 数据库</li><li>其他客户端接收变更并更新本地 Y.Map</li></ol><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="1-初始化协作环境"><a href="#1-初始化协作环境" class="headerlink" title="1. 初始化协作环境"></a>1. 初始化协作环境</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Y <span class="hljs-keyword">from</span> <span class="hljs-string">"yjs"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IndexeddbPersistence</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"y-indexeddb"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HocuspocusProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@hocuspocus/provider"</span>;<br><br><span class="hljs-comment">// 创建 Yjs 文档</span><br><span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br><span class="hljs-comment">// 获取共享的 Y.Map 用于存储画布元素</span><br><span class="hljs-keyword">const</span> yElements = ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>);<br><span class="hljs-comment">// 设置 IndexedDB 持久化</span><br><span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<span class="hljs-string">"canvas-room"</span>, ydoc);<br><span class="hljs-comment">// 设置 Hocuspocus 提供者</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initWsProvider</span> = (<span class="hljs-params"><span class="hljs-attr">roomId</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">token</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-comment">// 如果房间不存在，先创建</span><br>  <span class="hljs-keyword">if</span> (!roomDocuments.<span class="hljs-title function_">has</span>(roomId)) {<br>    <span class="hljs-title function_">getYDocForRoom</span>(roomId);<br>  }<br><br>  <span class="hljs-keyword">const</span> roomData = roomDocuments.<span class="hljs-title function_">get</span>(roomId)!;<br><br>  <span class="hljs-comment">// 如果已存在 WebSocket 提供者，先销毁</span><br>  <span class="hljs-keyword">if</span> (roomData.<span class="hljs-property">wsProvider</span>) {<br>    roomData.<span class="hljs-property">wsProvider</span>.<span class="hljs-title function_">destroy</span>();<br>  }<br><br>  <span class="hljs-comment">// 创建新的 WebSocket 提供者，并关联 Yjs 文档</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-string">`[Room <span class="hljs-subst">${roomId}</span>] Initializing WebSocket Provider with token: <span class="hljs-subst">${token}</span>`</span><br>  );<br><br>  <span class="hljs-keyword">const</span> wsProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HocuspocusProvider</span>({<br>    <span class="hljs-comment">// 确保 URL 结尾规范，方便拼接</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`ws://localhost:3000/collaboration/<span class="hljs-subst">${roomId}</span>`</span>,<br>    <span class="hljs-attr">name</span>: roomId, <span class="hljs-comment">// Hocuspocus 会将其拼接为 /collaboration/{roomId}</span><br>    <span class="hljs-attr">token</span>: token,<br>    <span class="hljs-comment">// 明确指定要同步的文档</span><br>    <span class="hljs-attr">document</span>: roomData.<span class="hljs-property">yDoc</span>,<br>  });<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wsProvider);<br><br>  <span class="hljs-comment">// 监听 WebSocket 连接状态</span><br>  wsProvider.<span class="hljs-title function_">on</span>(<span class="hljs-string">"status"</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Room <span class="hljs-subst">${roomId}</span>] WebSocket status:`</span>, event.<span class="hljs-property">status</span>); <span class="hljs-comment">// 'connected' or 'disconnected'</span><br>  });<br><br>  <span class="hljs-comment">// 更新房间数据中的 WebSocket 提供者</span><br>  roomData.<span class="hljs-property">wsProvider</span> = wsProvider;<br>  <span class="hljs-keyword">return</span> wsProvider;<br>};<br></code></pre></td></tr></table></figure><h3 id="2-画布元素管理"><a href="#2-画布元素管理" class="headerlink" title="2. 画布元素管理"></a>2. 画布元素管理</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>}<br><br><span class="hljs-comment">// 添加元素</span><br><br>yElements.<span class="hljs-title function_">set</span>(elementId, {<br>  <span class="hljs-attr">id</span>: elementId,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"rectangle"</span>,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">150</span>,<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">"#ff0000"</span>,<br>});<br><br><span class="hljs-comment">// 监听元素变化</span><br><br>yElements.<span class="hljs-title function_">observeDeep</span>(<span class="hljs-function">(<span class="hljs-params">events</span>) =&gt;</span> {<br>  events.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {<br>    <span class="hljs-comment">// 处理添加、更新、删除事件</span><br>  });<br>});<br></code></pre></td></tr></table></figure><h3 id="3-React-状态集成"><a href="#3-React-状态集成" class="headerlink" title="3. React 状态集成"></a>3. React 状态集成</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">"zustand"</span>;<br><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasStore</span> {<br>  <span class="hljs-attr">ydoc</span>: Y.<span class="hljs-property">Doc</span>;<br>  <span class="hljs-attr">yElements</span>: Y.<span class="hljs-property">Map</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">element</span>: <span class="hljs-title class_">CanvasElement</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">deleteElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCanvasStore = create&lt;<span class="hljs-title class_">CanvasStore</span>&gt;(<span class="hljs-function">(<span class="hljs-params">set, get</span>) =&gt;</span> ({<br>  <span class="hljs-comment">// ... store implementation</span><br>}));<br></code></pre></td></tr></table></figure><h3 id="4-离线支持实现"><a href="#4-离线支持实现" class="headerlink" title="4. 离线支持实现"></a>4. 离线支持实现</h3><p>离线支持是通过 IndexedDB 实现的：</p><ul><li>当用户在线时，所有操作同步到服务器和其他客户端</li><li>当用户离线时，操作仅保存在本地 IndexedDB 中</li><li>当用户重新连接时，本地更改自动同步到服务器</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 等待 IndexedDB 数据加载</span><br><span class="hljs-keyword">await</span> indexeddbProvider.<span class="hljs-property">whenSynced</span>;<br><br><span class="hljs-comment">// 监听连接状态</span><br>provider.<span class="hljs-title function_">on</span>(<span class="hljs-string">"synced"</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Document synced with server"</span>);<br>});<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>后续还可以实现批量更新，防抖，服务端数据验证等优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时协作画布系统：Yjs-Hocuspocus-持久化&quot;&gt;&lt;a href=&quot;#实时协作画布系统：Yjs-Hocuspocus-持久化&quot; class=&quot;headerlink&quot; title=&quot;实时协作画布系统：Yjs + Hocuspocus + 持久化&quot;&gt;&lt;/a&gt;实</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-18-前端画布设计Vol.2 实现富文本编辑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/10362.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/10362.html</id>
    <published>2025-12-27T18:58:47.000Z</published>
    <updated>2025-12-27T20:23:25.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="画布项目中富文本编辑器的实现浅析"><a href="#画布项目中富文本编辑器的实现浅析" class="headerlink" title="画布项目中富文本编辑器的实现浅析"></a>画布项目中富文本编辑器的实现浅析</h2><h4 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h4><p>该画布项目采用 <strong>wangEditor</strong>（v5 版本）的 React 封装组件 @wangeditor/editor-for-react 实现富文本编辑功能。主要通过两个组件协作完成：</p><ul><li>RichTextEditor.tsx：核心富文本编辑器封装，负责工具栏和编辑区的渲染与配置。</li><li>BottomTextEditor.tsx：底部面板式编辑器，仅在选中单个文本元素时显示，将富文本编辑器集成到画布操作流程中，支持实时更新元素内容并记录撤销/重做操作。</li></ul><p>主要形式是一个底部面板，单击文本元素会出现</p><h4 id="0x01-RichTextEditor-组件实现"><a href="#0x01-RichTextEditor-组件实现" class="headerlink" title="0x01 RichTextEditor 组件实现"></a>0x01 RichTextEditor 组件实现</h4><p>RichTextEditor 是对 wangEditor 的二次封装，提供可复用的富文本编辑器</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">"@wangeditor/editor/dist/css/style.css"</span>;<br><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Editor</span>, <span class="hljs-title class_">Toolbar</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@wangeditor/editor-for-react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">toolbarConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IToolbarConfig</span>&gt; = {<br>  <span class="hljs-attr">toolbarKeys</span>: [<br>    <span class="hljs-string">"bold"</span>,<br>    <span class="hljs-string">"italic"</span>,<br>    <span class="hljs-string">"underline"</span>,<br>    <span class="hljs-string">"through"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"fontSize"</span>,<br>    <span class="hljs-string">"fontFamily"</span>,<br>    <span class="hljs-string">"color"</span>,<br>    <span class="hljs-string">"bgColor"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"justifyLeft"</span>,<br>    <span class="hljs-string">"justifyCenter"</span>,<br>    <span class="hljs-string">"justifyRight"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"undo"</span>,<br>    <span class="hljs-string">"redo"</span>,<br>  ],<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">editorConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IEditorConfig</span>&gt; = {<br>  <span class="hljs-attr">placeholder</span>: <span class="hljs-string">"请输入文本..."</span>,<br>  <span class="hljs-attr">autoFocus</span>: <span class="hljs-literal">true</span>,<br>};<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (editor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    editor.<span class="hljs-title function_">destroy</span>();<br>    <span class="hljs-title function_">setEditor</span>(<span class="hljs-literal">null</span>);<br>  };<br>}, [editor]);<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"..."</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> <span class="hljs-attr">editor</span>=<span class="hljs-string">{editor}</span> <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{toolbarConfig}</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"simple"</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Editor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{editorConfig}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onCreated</span>=<span class="hljs-string">{setEditor}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(editor)</span> =&gt;</span> onChange(editor.getHtml())}</span><br><span class="language-xml">      mode="simple"</span><br><span class="language-xml">      style={{ height: "200px", overflowY: "auto" }}</span><br><span class="language-xml">    /&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>工具栏配置（toolbarConfig）</strong> 通过 toolbarKeys 指定显示的菜单键（加粗、斜体、下划线、删除线、字体大小/家族、颜色、背景色、对齐方式）以及撤销/重做。</li><li><strong>编辑器配置（editorConfig）</strong> 设置占位符和自动聚焦。wangEditor 支持更丰富的配置（如最大长度、自定义菜单等），此处保持最小化。</li><li><strong>生命周期管理</strong> 使用 useEffect 在组件卸载或 editor 实例变化时调用 editor.destroy()，防止内存泄漏。</li><li><strong>内容同步</strong>value props 控制初始 HTML，onChange 回调通过 editor.getHtml() 获取最新 HTML 内容并向上通知。</li></ol><h4 id="0x02-BottomTextEditor-组件实现"><a href="#0x02-BottomTextEditor-组件实现" class="headerlink" title="0x02 BottomTextEditor 组件实现"></a>0x02 BottomTextEditor 组件实现</h4><p>BottomTextEditor 将富文本编辑器集成到画布状态管理中，仅针对选中单个文本元素时激活。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> { selectedIds, elements, updateElement } = <span class="hljs-title function_">useStore</span>();<br><br><span class="hljs-keyword">const</span> selectedId = selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> ? selectedIds[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> element = selectedId ? elements[selectedId] : <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">const</span> [localHtml, setLocalHtml] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>);<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (element &amp;&amp; element.<span class="hljs-property">type</span> === <span class="hljs-string">"text"</span>) {<br>    <span class="hljs-title function_">setLocalHtml</span>(element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>);<br>  }<br>}, [element?.<span class="hljs-property">id</span>, element?.<span class="hljs-property">text</span>]);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params"><span class="hljs-attr">html</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-title function_">setLocalHtml</span>(html);<br>  <span class="hljs-keyword">const</span> initialText = element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>;<br>  <span class="hljs-title function_">updateElement</span>(element.<span class="hljs-property">id</span>, { <span class="hljs-attr">text</span>: html });<br><br>  <span class="hljs-keyword">const</span> updateCommand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateElementPropertyCommand</span>(<br>    { <span class="hljs-attr">id</span>: element.<span class="hljs-property">id</span>, <span class="hljs-attr">property</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">oldValue</span>: initialText, <span class="hljs-attr">newValue</span>: html },<br>    <span class="hljs-string">"修改文本内容"</span><br>  );<br>  undoRedoManager.<span class="hljs-title function_">executeCommand</span>(updateCommand);<br>};<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-8 ... animate-slide-up"</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">RichTextEditor</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{localHtml}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>选中元素判断</strong> 从 Zustand store（canvasStore）获取选中 ID 和元素集合，仅当选中单个文本类型元素时渲染编辑器。</li><li><strong>本地状态（localHtml）</strong> 使用 useState 维护本地 HTML 副本，并在选中元素变化时通过 useEffect 同步 store 中的 element.text。 此设计主要解决中文输入法（IME）组成阶段的问题：在拼音输入过程中，wangEditor 的 onChange 会频繁触发，若直接更新全局 store，可能导致输入延迟、光标跳动或内容混乱。通过本地状态缓冲实时变化，避免不必要的 store 更新。</li><li><strong>内容变更处理（handleChange）</strong><ul><li>更新本地状态。</li><li>实时调用 updateElement 更新画布 store，驱动 canvas 重新渲染文本元素。</li><li>创建 UpdateElementPropertyCommand 命令并执行，支持撤销/重做（undo/redo）。命令记录旧值和新值，处理历史操作</li></ul></li></ol><h4 id="0x03-关键问题解决与设计"><a href="#0x03-关键问题解决与设计" class="headerlink" title="0x03 关键问题解决与设计"></a>0x03 关键问题解决与设计</h4><ol><li><strong>输入法兼容性</strong> 中文输入过程中，组成事件（composition）会多次触发编辑器变更。若直接在 onChange 中更新全局状态，可能导致性能问题或输入体验不佳。本实现通过本地状态缓冲 setLocalHtml(html) 缓解该问题</li><li><strong>实时渲染与历史管理</strong> 实时更新 store 确保画布文本即时反映变更；同时通过命令模式记录操作，实现完整的 undo/redo 支持。</li></ol><h4 id="0x04-当前实现的风险与不足分析"><a href="#0x04-当前实现的风险与不足分析" class="headerlink" title="0x04 当前实现的风险与不足分析"></a>0x04 当前实现的风险与不足分析</h4><p>当前实现虽已满足基础富文本编辑需求，但是还是有一些问题</p><ol><li><strong>输入法体验优化不彻底</strong> 虽通过本地状态缓冲缓解了 IME 组成阶段的频繁更新问题，但未监听 compositionstart/compositionend 事件。在某些极端输入场景（如快速切换输入法或长句输入）下，仍可能出现光标偏移或临时内容丢失的现象。</li><li><strong>内容净化与 XSS 防护不足</strong> 完全依赖 wangEditor 内置的有限转义机制，未引入 DOMPurify 等专用净化库。在用户插入外部链接、图片或自定义 HTML 时，存在潜在的存储型或 DOM 型 XSS 风险，尤其在内容后续导出或分享场景中。</li><li><strong>样式与对齐精度问题</strong> wangEditor 生成的 HTML 结构（如多层 span/div 嵌套）与画布自定义文本渲染逻辑可能不完全匹配，导致编辑器中预览效果与画布最终渲染存在细微差异（如行高、字间距、对齐方式）。</li><li><strong>性能与内存管理</strong> 频繁的实时更新（onChange 触发 store 更新与命令记录）在长文本场景下可能导致轻微卡顿；此外，未对编辑器实例进行复用，当快速切换不同文本元素时会反复创建/销毁实例，增加内存开销。</li></ol><p>面对这些问题后续都可以做一些改进：</p><ol><li><strong>引入 DOMPurify 进行内容净化来处理 XSS 问题</strong> 在内容存储前（提交到 store 或后端）及渲染时统一调用 DOMPurify.sanitize，对 HTML 进行严格过滤。自定义白名单以保留 wangEditor 支持的必要标签与属性，同时移除所有事件处理器及危险协议。</li><li><strong>完善输入法兼容性</strong> 在 RichTextEditor 中监听 composition 事件，在组成阶段暂不触发 handleChange，仅在 compositionend 后统一更新 store 与命令记录，进一步消除输入延迟与光标问题。</li><li><strong>性能优化</strong> 实现编辑器实例复用（单一全局实例，根据选中元素动态切换内容），并在长文本时增加防抖处理，减少不必要的 store 更新与命令执行。</li></ol><h4 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h4><p>主要就是 wangEditor 的 React 封装，结合 Zustand 状态管理和命令模式，来适配画布类项目的文本编辑需求，实现了基础的文本编辑功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;a href=&quot;#画布项目中富文本编辑器的实现浅析&quot; class=&quot;headerlink&quot; title=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;/a&gt;画布项目中富文本编辑器的实现浅析&lt;/h2&gt;&lt;h4 id=&quot;0x00-概述&quot;&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-17-前端画布设计Vol.1 实现基础元素渲染和状态控制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/43445.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/43445.html</id>
    <published>2025-12-27T17:23:08.000Z</published>
    <updated>2025-12-28T17:54:19.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PixiJS-实现基础元素渲染和状态控制"><a href="#PixiJS-实现基础元素渲染和状态控制" class="headerlink" title="PixiJS 实现基础元素渲染和状态控制"></a>PixiJS 实现基础元素渲染和状态控制</h2><p>PixiJS 是一个强大的 2D 渲染引擎，它使用 WebGL 和 Canvas 技术来高效地渲染图形，主要通过  ElementRenderer  类实现。</p><h3 id="基本图形渲染实现"><a href="#基本图形渲染实现" class="headerlink" title="基本图形渲染实现"></a>基本图形渲染实现</h3><p>设计的画布中，基本图形是通过 PixiJS 的 Graphics 类绘制的，支持以下基本图形类型：</p><ol><li><p><strong>矩形 (rect)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆角矩形 (rounded rectangle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">roundRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>, data.<span class="hljs-property">radius</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆形 (circle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">ellipse</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>菱形 (diamond)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">poly</span>([<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">width</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">height</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>]);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li></ol><h3 id="图形属性实现"><a href="#图形属性实现" class="headerlink" title="图形属性实现"></a>图形属性实现</h3><p>每个图形元素都由  CanvasElement  接口定义，支持以下属性：</p><ol><li><p><strong>背景色 (background)</strong>:</p><ul><li>通过  fill  属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li><li>使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>边框宽度 (border-width)</strong>:</p><ul><li>通过  strokeWidth  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li></ul></li><li><p><strong>边框颜色 (border-color)</strong>:</p><ul><li>通过  stroke  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li><li>同样使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>透明度 (alpha)</strong>:</p><ul><li>通过 alpha 属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li></ul></li></ol><p>在  ElementRenderer  类中，图形渲染的过程包括以下步骤：</p><ol><li>首先清空之前的图形绘制：<code>g.clear()</code></li><li><p>设置绘制样式（边框宽度、边框颜色、填充颜色、透明度）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> strokeWidth = data.<span class="hljs-property">strokeWidth</span> ?? <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> strokeColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">stroke</span>);<br><span class="hljs-keyword">const</span> fillColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">fill</span>);<br><span class="hljs-keyword">const</span> alpha = data.<span class="hljs-property">alpha</span> ?? <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>根据图形类型绘制对应的形状</p></li><li><p>设置图形的位置和旋转：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-property">pivot</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">x</span> + data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">y</span> + data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">rotation</span> = data.<span class="hljs-property">rotation</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="特殊功能"><a href="#特殊功能" class="headerlink" title="特殊功能"></a>特殊功能</h3><ol><li><strong>旋转功能</strong>: 通过设置  pivot  点和  rotation  属性实现</li><li><strong>圆角矩形</strong>: 使用  <code>g.roundRect(x, y, width, height, radius)</code>  方法</li><li><strong>纹理缓存</strong>: 对图像元素使用纹理缓存以提高性能</li><li><strong>动态加载</strong>: 图像元素支持异步加载纹理</li></ol><h2 id="状态管理机制"><a href="#状态管理机制" class="headerlink" title="状态管理机制"></a>状态管理机制</h2><p>在您的项目中，状态管理由  zustand  库实现，通过  CanvasStore  集中管理所有画布元素的状态。状态管理包含以下几个核心部分：</p><h3 id="1-状态结构"><a href="#1-状态结构" class="headerlink" title="1. 状态结构"></a>1. 状态结构</h3><ul><li>elements: 一个记录对象，包含所有画布元素</li><li>selectedIds: 当前选中的元素 ID 数组</li><li>tool: 当前使用的工具类型</li><li>currentStyle: 当前绘制样式（填充色、边框色、边框宽度等）</li></ul><h3 id="2-状态更新机制"><a href="#2-状态更新机制" class="headerlink" title="2. 状态更新机制"></a>2. 状态更新机制</h3><p>状态更新通过以下方法实现：</p><ul><li>addElement: 添加元素</li><li>updateElement: 更新元素属性</li><li>removeElements: 删除元素</li><li>setSelected: 设置选中的元素</li><li>batchUpdateElements: 批量更新元素（用于提高性能）</li></ul><h2 id="元素渲染机制"><a href="#元素渲染机制" class="headerlink" title="元素渲染机制"></a>元素渲染机制</h2><p>元素渲染通过  ElementRenderer  类实现，它与状态管理紧密结合：</p><h3 id="1-状态-渲染同步"><a href="#1-状态-渲染同步" class="headerlink" title="1. 状态-渲染同步"></a>1. 状态-渲染同步</h3><p>在  Core_StageManager.ts  中，有一个关键的订阅机制：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">useStore.<span class="hljs-title function_">subscribe</span>(   <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">elements</span>: state.<span class="hljs-property">elements</span>, <span class="hljs-attr">selectedIds</span>: state.<span class="hljs-property">selectedIds</span>, <span class="hljs-attr">tool</span>: state.<span class="hljs-property">tool</span> }),   <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {     <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">destroyed</span>) {       <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRenderer</span>.<span class="hljs-title function_">renderElements</span>(state.<span class="hljs-property">elements</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementLayer</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">destroyed</span>)       <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerRenderer</span>.<span class="hljs-title function_">renderTransformer</span>(         state.<span class="hljs-property">elements</span>,         state.<span class="hljs-property">selectedIds</span>,         <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRenderer</span>.<span class="hljs-title function_">getSpriteMap</span>(),         <span class="hljs-variable language_">this</span>.<span class="hljs-property">onHandleDown</span>,         <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-property">scale</span>.<span class="hljs-property">x</span>,       )       <span class="hljs-comment">// ...</span><br><span class="hljs-comment">//</span><br>}<br> },   { <span class="hljs-attr">equalityFn</span>: stateEqualityFn }, )<br></code></pre></td></tr></table></figure><p>每当状态发生变化时，就会触发渲染更新。</p><h3 id="2-渲染过程"><a href="#2-渲染过程" class="headerlink" title="2. 渲染过程"></a>2. 渲染过程</h3><p>ElementRenderer.renderElements  方法遍历所有元素并执行以下操作：</p><ol><li><strong>元素映射管理</strong>：使用  spriteMap  记录已渲染的元素</li><li><strong>类型处理</strong>：根据元素类型（矩形、圆形、文本、图像等）进行相应渲染</li><li><strong>属性应用</strong>：将状态中的属性（位置、大小、颜色等）应用到渲染对象</li></ol><h3 id="3-状态与渲染的实时同步"><a href="#3-状态与渲染的实时同步" class="headerlink" title="3. 状态与渲染的实时同步"></a>3. 状态与渲染的实时同步</h3><p>当状态变化时，例如：</p><ul><li>用户拖动元素时，updateElement  更新元素的  x  和  y  坐标</li><li>用户改变填充颜色时，updateElement  更新  fill  属性</li><li>选择元素时，setSelected  更新  selectedIds</li></ul><p>这些状态变更会立即触发渲染更新，确保 UI 与状态保持同步。</p><h2 id="状态控制机制"><a href="#状态控制机制" class="headerlink" title="状态控制机制"></a>状态控制机制</h2><h3 id="1-撤销-重做"><a href="#1-撤销-重做" class="headerlink" title="1. 撤销/重做"></a>1. 撤销/重做</h3><p>项目集成了撤销/重做功能，通过  UndoRedoManager  和命令模式实现：</p><ul><li>每个操作（添加、删除、更新）都创建一个命令对象</li><li>命令对象包含执行和撤销操作的逻辑</li><li>undo  和  redo  方法控制历史记录栈</li></ul><h3 id="2-选择状态管理"><a href="#2-选择状态管理" class="headerlink" title="2. 选择状态管理"></a>2. 选择状态管理</h3><ul><li>selectedIds  数组跟踪当前选中的元素</li><li>选择变化会触发渲染更新，显示选择框和控制点</li><li>TransformerRenderer 负责渲染选择框和调整手柄</li></ul><h3 id="3-工具状态管理"><a href="#3-工具状态管理" class="headerlink" title="3. 工具状态管理"></a>3. 工具状态管理</h3><ul><li>tool  属性跟踪当前使用的工具</li><li>工具变化会影响交互行为和光标样式</li><li>不同工具对相同的用户输入（如鼠标点击）会有不同的响应</li></ul><h3 id="4-实时协作"><a href="#4-实时协作" class="headerlink" title="4. 实时协作"></a>4. 实时协作</h3><p>项目使用 Yjs 实现实时协作功能：</p><ul><li>状态变化通过 Yjs 同步到其他用户</li><li>Yjs 的 observe 机制确保本地状态与共享状态同步</li><li>使用事务（transact）保证操作的原子性</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><strong>状态比较优化</strong>：使用  stateEqualityFn  减少不必要的重渲染</li><li><strong>批量更新</strong>：batchUpdateElements  方法用于批量更新元素，减少渲染次数</li><li><strong>精灵映射</strong>：ElementRenderer  保留精灵映射以避免重复创建/销毁</li><li><strong>防抖机制</strong>：虽然代码中注释掉了防抖，但设计中考虑了性能优化</li></ol><p>这种架构确保了状态与渲染之间的紧密同步，同时保持了良好的性能和可扩展性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PixiJS-实现基础元素渲染和状态控制&quot;&gt;&lt;a href=&quot;#PixiJS-实现基础元素渲染和状态控制&quot; class=&quot;headerlink&quot; title=&quot;PixiJS 实现基础元素渲染和状态控制&quot;&gt;&lt;/a&gt;PixiJS 实现基础元素渲染和状态控制&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-27-算法刷题-关于链表操作</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/40452.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/40452.html</id>
    <published>2025-12-27T08:12:42.000Z</published>
    <updated>2025-12-27T10:53:26.438Z</updated>
    
    <content type="html"><![CDATA[<p>后悔数据结构当初没有好好学的第n天<br>现在恶补，知识学爆</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><p>基础操作：</p><ul><li>查找元素：根据值查找节点位置</li><li>指定位置插入：在特定位置插入新节点</li><li>指定位置获取：获取特定位置的节点值</li><li>指定位置删除：删除特定位置的节点</li><li>获取长度：统计链表中节点的数量</li></ul><div class="table-container"><table><thead><tr><th></th><th>题目描述</th><th>主要实现思路</th></tr></thead><tbody><tr><td>BM1</td><td>反转链表</td><td>使用三指针（prev、curr、next）迭代反转：保存下一个节点，反转当前指向，移动指针。返回prev作为新头。</td></tr><tr><td>BM2</td><td>链表内指定区间反转</td><td>引入虚拟头结点定位第m-1个节点（pre）。然后在[m,n]区间执行(n-m)次头插法（逐个将下一个节点插入pre后）。</td></tr><tr><td>BM3</td><td>链表中的节点每k个一组翻转</td><td>每k个节点为一组，使用反转链表方法局部反转。若剩余不足k个，则保持原序。递归或迭代均可，推荐迭代分段处理。</td></tr><tr><td>BM4</td><td>合并两个排序的链表</td><td>双指针模拟归并排序：比较两个链表当前节点值，小者接入新链表，移动对应指针。处理剩余部分。</td></tr><tr><td>BM5</td><td>合并k个已排序的链表</td><td>使用小根堆（优先队列）维护k个链表头结点，每次弹出最小值并接入结果链表，同时推入其下一个节点。</td></tr><tr><td>BM6</td><td>判断链表中是否有环</td><td>快慢指针（Floyd判圈算法）：fast每次走2步，slow走1步。若相遇则有环，否则无环。</td></tr><tr><td>BM7</td><td>链表中环的入口结点</td><td>先用快慢指针相遇于环内某点，再令一指针从头启动，与慢指针同步移动，相遇处即环入口。</td></tr><tr><td>BM8</td><td>链表中倒数最后k个结点</td><td>快慢指针：fast先走k步，然后slow与fast同步移动，至fast到尾时slow即为倒数第k个节点。</td></tr><tr><td>BM9</td><td>删除链表的倒数第n个节点</td><td>同BM8定位倒数第n+1个节点（pre），然后pre.next = pre.next.next删除目标节点。注意头节点特殊处理。</td></tr><tr><td>BM10</td><td>两个链表的第一个公共结点</td><td>双指针同步走：先计算长度差，长者先走差值步；或让指针走完一链表后换另一链表，总路程相等时相遇即公共节点。</td></tr><tr><td>BM11</td><td>链表相加(二)</td><td>模拟加法从低位到高位（需先反转链表或用栈），处理进位。结果可能需反转回原序。</td></tr><tr><td>BM12</td><td>单链表的排序</td><td>归并排序（自底向上）：分段合并有序子链表，或快慢指针找中点递归归并。时间O(n log n)。</td></tr><tr><td>BM13</td><td>判断一个链表是否为回文结构</td><td>快慢指针找中点，反转后半部分，与前半部分逐节点比较值是否相等。恢复链表可选。</td></tr><tr><td>BM14</td><td>链表的奇偶重排</td><td>分离奇偶位节点成两个链表（odd、even），然后even接odd尾部。注意偶数长度处理。</td></tr><tr><td>BM15</td><td>删除有序链表中重复的元素-I</td><td>单指针遍历：若当前节点与下一节点值相同，跳过下一节点（保留首次出现）。</td></tr><tr><td>BM16</td><td>删除有序链表中重复的元素-II</td><td>引入虚拟头结点，双指针或单指针遍历：若连续重复，跳过整个重复段（一个不留）。</td></tr></tbody></table></div><hr><p>一般会给出一个最基础的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = (val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = (next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next);<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>节点包含两个成员</strong>：<ul><li>val：存储节点的值，通常为整数（int），题目中 |val| ≤ 1000。</li><li>next：指向下一个节点的指针（引用），类型为同类 ListNode*（或 ListNode），初始可能为 NULL/null/None</li></ul></li><li><strong>无哑头节点（dummy head）</strong>：输入的 head 就是真实头结点（有有效值），除非题目特别说明</li><li><strong>单向链表</strong>：只能从头到尾遍历，无前向指针</li><li><strong>输入形式</strong>：<ul><li>函数签名通常为 ListNode* head（或类似），可能额外传入其他参数（如 m、n、k 等）</li><li>空链表：head = NULL / null / None</li></ul></li><li><strong>输出形式</strong>：<ul><li>大多数题目要求返回新的头结点（ListNode*）</li><li>操作通常要求<strong>原地修改</strong>，以满足空间复杂度 O(1)</li></ul></li></ul><hr><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="单链表常见操作的实现方法"><a href="#单链表常见操作的实现方法" class="headerlink" title="单链表常见操作的实现方法"></a>单链表常见操作的实现方法</h3><p>以下针对单链表（节点结构为 val 和 next）的几种常见操作，提供标准、高效的实现思路。所有操作均基于从头结点开始遍历，时间复杂度与空间复杂度分析清晰。假设节点定义如下（以 JavaScript 为例，其他语言类似）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next || <span class="hljs-literal">null</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="1-查找元素：根据值查找节点位置（返回位置或节点）"><a href="#1-查找元素：根据值查找节点位置（返回位置或节点）" class="headerlink" title="1. 查找元素：根据值查找节点位置（返回位置或节点）"></a>1. 查找元素：根据值查找节点位置（返回位置或节点）</h4><p><strong>思路</strong>：从头遍历，逐个比较节点值，直到找到匹配值或到达链表末尾。</p><p><strong>实现要点</strong>：</p><ul><li>返回第一个匹配节点的<strong>位置</strong>（从 1 开始）或节点本身。</li><li>未找到返回 -1 或 null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findNode</span>(<span class="hljs-params">head, target</span>) {<br>    <span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">if</span> (curr.<span class="hljs-property">val</span> === target) {<br>            <span class="hljs-keyword">return</span> pos;  <span class="hljs-comment">// 或 return curr; 返回节点本身</span><br>        }<br>        curr = curr.<span class="hljs-property">next</span>;<br>        pos++;<br>    }<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）"><a href="#2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）" class="headerlink" title="2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）"></a>2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，将新节点插入其后。特殊处理插入到头部（i=1）。</p><p><strong>实现要点</strong>：</p><ul><li>若 i=1，新节点成为新头。</li><li>若 i &gt; 长度，插入失败或插入尾部（视题目要求）。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtPosition</span>(<span class="hljs-params">head, i, val</span>) {<br>    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>        newNode.<span class="hljs-property">next</span> = head;<br>        <span class="hljs-keyword">return</span> newNode;  <span class="hljs-comment">// 新头结点</span><br>    }<br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围，不插入</span><br>    <br>    newNode.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>;<br>    curr.<span class="hljs-property">next</span> = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）"><a href="#3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）" class="headerlink" title="3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）"></a>3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）</h4><p><strong>思路</strong>：遍历 i-1 步，直接返回当前节点的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> curr ? curr.<span class="hljs-property">val</span> : <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 未找到返回 null</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="4-指定位置删除：删除第-i-个节点（i-从-1-开始）"><a href="#4-指定位置删除：删除第-i-个节点（i-从-1-开始）" class="headerlink" title="4. 指定位置删除：删除第 i 个节点（i 从 1 开始）"></a>4. 指定位置删除：删除第 i 个节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，修改其 next 指向跳过第 i 个节点。特殊处理删除头结点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 删除头结点</span><br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span> || curr.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围</span><br>    <br>    curr.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 跳过第 i 个节点</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="5-获取链表长度（节点数量）"><a href="#5-获取链表长度（节点数量）" class="headerlink" title="5. 获取链表长度（节点数量）"></a>5. 获取链表长度（节点数量）</h4><p><strong>思路</strong>：遍历链表，累计计数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        len++;<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> len;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="BM1-全量反转链表"><a href="#BM1-全量反转链表" class="headerlink" title="BM1  | 全量反转链表"></a>BM1  | 全量反转链表</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤n≤10000≤n≤1000</p><p>要求：空间复杂度 O(1)O(1) ，时间复杂度 O(n)O(n) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p class='item-img' data-src='https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249'><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt=""></p><hr><p>解法：</p><ul><li>初始化 prev 为 null（新链表的尾部）。</li><li>current 从链表头节点开始。</li><li>在循环中：<ul><li>暂存 next = current.next（避免指针丢失）。</li><li>将 current.next 指向 prev（反转当前指针）。</li><li>更新 prev = current（前移 prev）。</li><li>更新 current = next（前移 current）。</li></ul></li><li>循环结束后，prev 指向原链表的尾节点（新头节点），更新 list.head = prev。</li></ul><p>其实就是三指针原地反转</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp'><img src="https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ReverseList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span></span>): <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br><br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    <br>        <span class="hljs-comment">// 保存下一个节点，防止断链</span><br>        <span class="hljs-keyword">let</span> next = curr.<span class="hljs-property">next</span>;<br><br>        <span class="hljs-comment">// 反转当前节点的指向</span><br>        curr.<span class="hljs-property">next</span> = prev;<br><br>        <span class="hljs-comment">// 指针向前移动</span><br>        prev = curr;<br>        curr = next;<br>    }<br>    <span class="hljs-comment">// prev 指向反转后的新头结点</span><br>    <span class="hljs-keyword">return</span> prev;<br>};<br></code></pre></td></tr></table></figure><h3 id="BM2-反转链表部分区间"><a href="#BM2-反转链表部分区间" class="headerlink" title="BM2  | 反转链表部分区间"></a>BM2  | 反转链表部分区间</h3><p>给定一个单链表的头结点 head，长度为 n，反转该链表从位置 m 到 n 的部分，返回反转后的链表。</p><p>数据范围： 0≤m≤n≤n≤1000 ，链表中任意节点的值满足 |val|≤1000</p><p>例如：<br>给出的链表为 1→2→3→4→5→NULL1→2→3→4→5→NULL, m=2,n=4m=2,n=4,<br>返回 1→4→3→2→5→NULL1→4→3→2→5→NULL.  </p><p>要实现原地反转指定区间，需要：</p><ol><li>找到反转区间的前一个节点（pre），即第 m-1 个节点。</li><li>找到反转区间的最后一个节点（记为 end），即第 n 个节点。</li><li>将 [m, n] 区间使用经典链表反转方法进行原地反转。</li><li>正确连接反转后的区间与前后部分：<ul><li>pre.next 指向反转后区间的新的头节点（原第 n 个节点）。</li><li>反转后区间的尾节点（原第 m 个节点）指向 end.next。</li></ul></li></ol><p>关键操作：</p><ul><li>先遍历定位到 pre 和反转区间的起始节点 start（第 m 个节点）。</li><li>然后在 [start, end] 区间内使用三指针迭代反转。</li><li>最后调整指针连接。</li></ul><p class='item-img' data-src='https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif'><img src="https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">m</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || m === n) <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> pre = dummy;<br><br>    <span class="hljs-comment">// 移动到第 m-1 个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) {<br>        pre = pre.<span class="hljs-property">next</span>!;<br>    }<br><br>    <span class="hljs-keyword">let</span> start = pre.<span class="hljs-property">next</span>!;   <span class="hljs-comment">// 第 m 个节点（反转区间的原头部）</span><br>    <span class="hljs-keyword">let</span> then = start.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 第 m+1 个节点（待头插的节点）</span><br><br>    <span class="hljs-comment">// 执行 (n - m) 次头插</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++) {<br>        start.<span class="hljs-property">next</span> = then.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 从原区间摘除 then</span><br>        then.<span class="hljs-property">next</span> = pre.<span class="hljs-property">next</span>;     <span class="hljs-comment">// then 插入 pre 之后（成为新头部）</span><br>        pre.<span class="hljs-property">next</span> = then;          <span class="hljs-comment">// 更新 pre 的 next</span><br>        then = start.<span class="hljs-property">next</span>;        <span class="hljs-comment">// 更新 then 为下一个待移动节点</span><br>    }<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;后悔数据结构当初没有好好学的第n天&lt;br&gt;现在恶补，知识学爆&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?sou</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-力扣百题速练（Javascript、TypeScript）Vol.2</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39620.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39620.html</id>
    <published>2025-12-26T05:57:08.000Z</published>
    <updated>2025-12-27T12:52:43.608Z</updated>
    
    <content type="html"><![CDATA[<p>这里是力扣速刷第二期awa<br>说是速刷其实卡了挺久</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为  <code>n</code>  的整数数组  <code>height</code> 。有  <code>n</code>  条垂线，第  <code>i</code>  条线的两个端点是  <code>(i, 0)</code>  和  <code>(i, height[i])</code><br>找出其中的两条线，使得它们与  <code>x</code>  轴共同构成的容器可以容纳最多的水<br>返回容器可以储存的最大水量</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49</p><p>最开始直接暴力解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; height.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">let</span> xin = (j - i) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]);<br>      <span class="hljs-keyword">if</span> (xin &gt; res) {<br>        res = xin;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>后面想了一下，做了些改进</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (i &lt; j) {<br>    <span class="hljs-keyword">let</span> fin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]) * (j - i);<br>    <span class="hljs-keyword">if</span> (fin &gt; res) {<br>      res = fin;<br>    }<br>    <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) {<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      j--;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>初始时宽度最大，若当前面积不是最大，则必须通过增加高度来补偿宽度损失<br>移动较短指针是因为：保持较短边不动，宽度只会变小，面积不可能增大；只有移动较短边才可能遇到更高的高度，从而提升面积</p><p>经典双指针加贪心的题</p><hr><h2 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h2><p>七个不同的符号代表罗马数字，其值如下：</p><div class="table-container"><table><thead><tr><th>符号</th><th>值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：</p><ul><li>如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。</li><li>如果该值以 4 或 9 开头，使用  <strong>减法形式</strong>，表示从以下符号中减去一个符号，例如 4 是 5 (<code>V</code>) 减 1 (<code>I</code>): <code>IV</code> ，9 是 10 (<code>X</code>) 减 1 (<code>I</code>)：<code>IX</code>。仅使用以下减法形式：4 (<code>IV</code>)，9 (<code>IX</code>)，40 (<code>XL</code>)，90 (<code>XC</code>)，400 (<code>CD</code>) 和 900 (<code>CM</code>)。</li><li>只有 10 的次方（<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (<code>V</code>)，50 (<code>L</code>) 或 500 (<code>D</code>)。如果需要将符号附加 4 次，请使用  <strong>减法形式</strong>。</li></ul><p>给定一个整数，将其转换为罗马数字。</p><p><strong>示例 1：</strong></p><p>**输入：num = 3749</p><p><strong>输出：</strong> “MMMDCCXLIX”</p><p><strong>解释：</strong></p><p>3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)<br>700 = DCC 由于 500 (D) + 100 (C) + 100 (C)<br>40 = XL 由于 50 (L) 减 10 (X)<br>9 = IX 由于 10 (X) 减 1 (I)<br>注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位</p><p><strong>示例 2：</strong></p><p>**输入：num = 58</p><p><strong>输出：</strong>“LVIII”</p><p><strong>解释：</strong></p><p>50 = L<br>8 = VIII</p><p><strong>示例 3：</strong></p><p>**输入：num = 1994</p><p><strong>输出：</strong>“MCMXCIV”</p><p><strong>解释：</strong></p><p>1000 = M<br>900 = CM<br>90 = XC<br>4 = IV</p><p>最初想法是尝试通过<strong>逐位处理数字</strong>的方式将整数转换为罗马数字：</p><ol><li><strong>将数字转换为字符串并反转</strong>： 使用 reverseString(num.toString()) 将数字从高位到低位变为低位到高位（例如 1994 → “4991”）,从个位开始依次处理每个数位（个位、十位、百位、千位）</li><li><strong>为每个数位定义对应的罗马符号</strong>：<ul><li><code>个位（i===0）：1→"I", 5→"V", 10→"X"</code></li><li><code>十位（i===1）：1→"X", 5→"L", 10→"C"</code></li><li><code>百位（i===2）：1→"C", 5→"D", 10→"M"</code></li><li><code>千位（i===3）：直接用 "M" 重复</code></li></ul></li><li><strong>根据当前位上的数字（0-9）生成对应罗马表示</strong>：<ul><li>1-3：重复添加 “1” 的符号（curr1）</li><li>4：curr1 + curr2（如 “IV”）</li><li>5：curr2（如 “V”）</li><li>6-8：curr2 + 重复 (digit-5) 次 curr1</li><li>9：curr1 + curr3（如 “IX”）</li></ul></li><li><strong>使用数组 + unshift 收集符号</strong>： 因为已反转数字，低位先处理，使用 unshift（从数组头部插入）试图让高位符号最终出现在前面</li><li><strong>最后 join 成字符串返回</strong></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">let</span> curr1 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr2 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr3 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span><br>    str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-keyword">let</span> top = <span class="hljs-title function_">reverseString</span>(num.<span class="hljs-title function_">toString</span>());<br>  <span class="hljs-keyword">let</span> l = top.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">finalstr</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">nums</span>(<span class="hljs-params"><span class="hljs-attr">pos</span>: <span class="hljs-built_in">number</span></span>) {<br>    <span class="hljs-keyword">const</span> di = <span class="hljs-title class_">Number</span>(top[pos]);<br>    <span class="hljs-keyword">if</span> (di === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">4</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">5</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">8</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di - <span class="hljs-number">5</span>; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">9</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr3);<br>    }<br>  }<br>  <span class="hljs-keyword">while</span> (i &lt; l) {<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {<br>      curr1 = <span class="hljs-string">"I"</span>;<br>      curr2 = <span class="hljs-string">"V"</span>;<br>      curr3 = <span class="hljs-string">"X"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>      curr1 = <span class="hljs-string">"X"</span>;<br>      curr2 = <span class="hljs-string">"L"</span>;<br>      curr3 = <span class="hljs-string">"C"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) {<br>      curr1 = <span class="hljs-string">"C"</span>;<br>      curr2 = <span class="hljs-string">"D"</span>;<br>      curr3 = <span class="hljs-string">"M"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">const</span> vas = <span class="hljs-title class_">Number</span>(top[i]);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; vas; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">"M"</span>);<br>      }<br>      i++;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> finalstr.<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>}<br></code></pre></td></tr></table></figure><p>题目标准解法是<strong>贪心算法 + 值-符号映射表</strong>，从高位到低位匹配最大可能值，这个写法确实没有想出来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">valueSymbols</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>][] = [<br>        [<span class="hljs-number">1000</span>, <span class="hljs-string">"M"</span>], [<span class="hljs-number">900</span>, <span class="hljs-string">"CM"</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">"D"</span>], [<span class="hljs-number">400</span>, <span class="hljs-string">"CD"</span>],<br>        [<span class="hljs-number">100</span>,  <span class="hljs-string">"C"</span>], [<span class="hljs-number">90</span>,  <span class="hljs-string">"XC"</span>], [<span class="hljs-number">50</span>,  <span class="hljs-string">"L"</span>], [<span class="hljs-number">40</span>,  <span class="hljs-string">"XL"</span>],<br>        [<span class="hljs-number">10</span>,   <span class="hljs-string">"X"</span>], [<span class="hljs-number">9</span>,   <span class="hljs-string">"IX"</span>], [<span class="hljs-number">5</span>,   <span class="hljs-string">"V"</span>], [<span class="hljs-number">4</span>,   <span class="hljs-string">"IV"</span>],<br>        [<span class="hljs-number">1</span>,    <span class="hljs-string">"I"</span>]<br>    ];<br><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [value, <span class="hljs-built_in">symbol</span>] <span class="hljs-keyword">of</span> valueSymbols) {<br>        <span class="hljs-keyword">while</span> (num &gt;= value) {<br>            result += <span class="hljs-built_in">symbol</span>;<br>            num -= value;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>  和  <code>M</code>。</p><p><strong>字符</strong> <strong>数值</strong><br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000</p><p>例如， 罗马数字  <code>2</code>  写做  <code>II</code> ，即为两个并列的 1 。<code>12</code>  写做  <code>XII</code> ，即为  <code>X</code> + <code>II</code> 。 <code>27</code>  写做  <code>XXVII</code>, 即为  <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  <code>IIII</code>，而是  <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code>  可以放在  <code>V</code> (5) 和  <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code>  可以放在  <code>L</code> (50) 和  <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code>  可以放在  <code>D</code> (500) 和  <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> s = “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> s = “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> s = “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> s = “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> s = “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p><p>直接从左到右遍历字符串，比较当前符号与下一个符号的值：</p><ul><li>如果当前值 &lt; 下一个值，则减去当前值（形成减法组合）。</li><li>否则加上当前值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> map = {<br>    <span class="hljs-attr">I</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">V</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">X</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">L</span>: <span class="hljs-number">50</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">D</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">M</span>: <span class="hljs-number">1000</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> current = map[s[i]];<br>    <span class="hljs-keyword">const</span> next = map[s[i + <span class="hljs-number">1</span>]];<br><br>    <span class="hljs-keyword">if</span> (next &amp;&amp; current &lt; next) {<br>      res += next - current;<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      res += current;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀</p><p>如果不存在公共前缀，返回空字符串  <code>""</code></p><p><strong>示例 1：</strong></p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p><strong>示例 2：</strong></p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀</p><p>题解比较简单，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params"><span class="hljs-attr">strs</span>: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (strs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> char = strs[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (i === strs[j].<span class="hljs-property">length</span> || strs[j][i] !== char) {<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i);<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></table></figure><p>主要就是注意一个写法，在 JavaScript（以及 TypeScript）中，<code>strs[0][i]</code> 是一种链式索引访问（chained indexing）的写法，用于访问二维结构或嵌套可索引对象中的元素</p><p>假设 <code>strs = ["flower", "flow", "flight"]</code>，循环变量 <code>i = 2</code> 时：</p><ul><li><code>strs[0] → "flower"</code></li><li><code>strs[0][2] → "flower"</code> 的第 2 个字符 → <code>'o'</code></li></ul><p>同理：</p><ul><li><code>strs[1][2] → "flow"[2] → 'o'</code></li><li><code>strs[2][2] → "flight"[2] → 'i'</code></li></ul><p>通过比较 <code>strs[0][i]</code>与其他字符串的 <code>strs[j][i]</code> 是否相等，来判断第 i 位置是否仍属于公共前缀</p><h3 id="等价的写法"><a href="#等价的写法" class="headerlink" title="等价的写法"></a>等价的写法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> firstStr = strs[<span class="hljs-number">0</span>];<br>firstStr[i];<br><br><span class="hljs-comment">// 使用 charAt 方法</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">charAt</span>(i);<br><br><span class="hljs-comment">// 使用 at 方法 ES2022+</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">at</span>(i);<br></code></pre></td></tr></table></figure><hr><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>一个整数数组  <code>nums</code> ，判断是否存在三元组  <code>[nums[i], nums[j], nums[k]]</code>  满足  <code>i != j</code>、<code>i != k</code>  且  <code>j != k</code> ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code> ，返回所有和为  <code>0</code>  且不重复的三元组，且答案中不可以包含重复的三元组</p><p>示例 1：<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code><br>输出：<code>[[-1,-1,2],[-1,0,1]]</code><br>解释：<br><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code><br><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code><br><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code><br>不同的三元组是 <code>[-1,0,1]</code>和 <code>[-1,-1,2]</code></p><p>示例 2：<br>输入：<code>nums = [0,1,1]</code><br>输出：<code>[]</code><br>解释：唯一可能的三元组和不为 0</p><p>示例 3：<br>输入：<code>nums = [0,0,0]</code><br>输出：<code>[[0,0,0]]</code><br>解释：唯一可能的三元组和为 0</p><p>最开始是想直接 n^3 暴力解，然后用 Set 去重</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br>  <span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = j + <span class="hljs-number">1</span>; k &lt; nums.<span class="hljs-property">length</span>; k++) {<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">const</span> triplet = [nums[i], nums[j], nums[k]];<br>          <span class="hljs-keyword">const</span> key = triplet.<span class="hljs-title function_">join</span>(<span class="hljs-string">","</span>);<br>          <span class="hljs-keyword">if</span> (!seen.<span class="hljs-title function_">has</span>(key)) {<br>            seen.<span class="hljs-title function_">add</span>(key);<br>            result.<span class="hljs-title function_">push</span>(triplet);<br>          }<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>很明显，时间复杂度特别高，直接爆了</p><p>解法的话依旧双指针降维</p><h3 id="第一步：排序"><a href="#第一步：排序" class="headerlink" title="第一步：排序"></a>第一步：排序</h3><p>排序后可以：利用有序数组的特性，通过指针移动快速缩小范围</p><p>比如原数组是 <code>[-1,0,1,2,-1,-4]</code>，排序后变成 <code>[-4,-1,-1,0,1,2]</code>。这时候，相同的元素（比如两个 <code>-1</code>）会挨在一起，方便后续去重（重复元素会相邻，容易跳过）</p><h3 id="第二步：固定一个数，双指针找另外两个数"><a href="#第二步：固定一个数，双指针找另外两个数" class="headerlink" title="第二步：固定一个数，双指针找另外两个数"></a>第二步：固定一个数，双指针找另外两个数</h3><p>排序后，我们固定第一个数 <code>nums[i]</code>，然后用左指针 <code>left</code> 指向 <code>i+1</code>，右指针 <code>right</code> 指向数组末尾。三个数的和 <code>sum = nums[i] + nums[left] + nums[right]</code>：</p><ul><li>如果 <code>sum &lt; 0</code>：说明需要更大的数，左指针右移（<code>left++</code>）；</li><li>如果 <code>sum &gt; 0</code>：说明需要更小的数，右指针左移（<code>right--</code>）；</li><li>如果 <code>sum = 0</code>：找到一个有效三元组，记录结果。</li></ul><h3 id="第三步：去重"><a href="#第三步：去重" class="headerlink" title="第三步：去重"></a>第三步：去重</h3><p>具体分三种情况：</p><h4 id="1-固定数-nums-i-重复"><a href="#1-固定数-nums-i-重复" class="headerlink" title="1. 固定数 nums[i] 重复"></a>1. 固定数 <code>nums[i]</code> 重复</h4><p>比如排序后的数组是 <code>[-4,-1,-1,0,1,2]</code>，当 <code>i=1</code>（<code>nums[i]=-1</code>）时，和 <code>i=2</code>（<code>nums[i]=-1</code>）时的情况是一样的。这时候需要跳过重复的 <code>nums[i]</code>。</p><p><strong>判断条件</strong>：如果 <code>i &gt; 0</code> 且 <code>nums[i] === nums[i-1]</code>，说明当前 <code>nums[i]</code> 和前一个数重复，直接跳过。</p><h4 id="2-左指针-nums-left-重复"><a href="#2-左指针-nums-left-重复" class="headerlink" title="2. 左指针 nums[left] 重复"></a>2. 左指针 <code>nums[left]</code> 重复</h4><p>假设已经找到 <code>i=0</code>（<code>nums[i]=-4</code>），<code>left=1</code>（<code>nums[left]=-1</code>），<code>right=5</code>（<code>nums[right]=2</code>），此时和为 <code>-4 + (-1) + 2 = -3</code>，不满足条件。左指针右移到 <code>left=2</code>（<code>nums[left]=-1</code>），这时候 <code>nums[left]</code> 和前一个 <code>left</code> 位置的数重复，需要跳过。</p><p><strong>判断条件</strong>：当找到和为 0 的三元组后，需要循环判断 <code>nums[left] === nums[left+1]</code>，如果是，左指针右移，直到遇到不同的数。</p><h4 id="3-右指针-nums-right-重复"><a href="#3-右指针-nums-right-重复" class="headerlink" title="3. 右指针 nums[right] 重复"></a>3. 右指针 <code>nums[right]</code> 重复</h4><p>同样，找到和为 0 的三元组后，如果 <code>nums[right]</code> 和前一个 <code>right</code> 位置的数重复（比如 <code>nums[right]=1</code> 和 <code>nums[right-1]=1</code>），需要跳过。</p><p><strong>判断条件</strong>：循环判断 <code>nums[right] === nums[right-1]</code>，如果是，右指针左移，直到遇到不同的数。</p><ol><li><strong>先排序</strong>：nums.sort((a, b) =&gt; a - b)，使得相同元素相邻，便于跳过重复。</li><li><strong>外层循环跳过重复的 i</strong>：如果当前 nums[i] 与前一个相同，则跳过（避免同一值的 i 产生重复三元组）。</li><li><strong>内层双指针移动时跳过重复的 left 和 right</strong>：找到一个有效三元组后，跳过所有相同的 left 和 right 值。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 先排序，关键一步</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-comment">// 跳过重复的 nums[i]</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) {<br>      <span class="hljs-keyword">continue</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br><br>      <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) {<br>        result.<span class="hljs-title function_">push</span>([nums[i], nums[left], nums[right]]); <span class="hljs-comment">//加入结果</span><br><br>        <span class="hljs-comment">// 跳过重复的 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) {<br>          left++;<br>        }<br>        <span class="hljs-comment">// 跳过重复的 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) {<br>          right--;<br>        }<br><br>        left++;<br>        right--;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> {<br>        right--;<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给你一个长度为  <code>n</code>  的整数数组  <code>nums</code>  和 一个目标值  <code>target</code>。请你从  <code>nums</code>  中选出三个整数，使它们的和与  <code>target</code>  最接近，返回这三个数的和<br>假定每组输入只存在恰好一个解</p><p>示例：<br>输入：nums = <code>[-1,2,1,-4]</code> , <code>target = 1</code><br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)</p><p>解法和三数之和一样都是双指针解题<br>多一些判断而已</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> closestSum = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> minDiff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(closestSum - target);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br>      <span class="hljs-keyword">const</span> diff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(sum - target);<br><br>      <span class="hljs-keyword">if</span> (diff &lt; minDiff) {<br>        minDiff = diff;<br>        closestSum = sum;<br>      }<br><br>      <span class="hljs-keyword">if</span> (sum &lt; target) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) {<br>        right--;<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> sum;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> closestSum;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="17-电话号码的的数字组合"><a href="#17-电话号码的的数字组合" class="headerlink" title="17.电话号码的的数字组合"></a>17.电话号码的的数字组合</h2><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按  <strong>任意顺序</strong>  返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p class='item-img' data-src='https://pic.leetcode.cn/1752723054-mfIHZs-image.png'><img src="https://pic.leetcode.cn/1752723054-mfIHZs-image.png" alt="电话按键" width="300"></p><p>示例 1：<br>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：<br>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p><p>练度不够，还得继续练</p><p>主要解法是迭代法：</p><ul><li>外层循环遍历 digits 中的每一个数字（从左到右）。</li><li>对于当前数字 digit：<ul><li>获取其对应的所有可能字母 letters（如 ‘2’ → ‘abc’）。</li><li>创建一个临时数组 temp，用于存储“加入当前数字字母后的新组合”。</li><li>遍历当前 result 中的每一个已有组合 prev（这些是处理前几个数字得到的所有组合）。</li><li>对 letters 中的每一个 letter，将其追加到 prev 后面，形成新字符串 prev + letter，并加入 temp。</li></ul></li><li>一轮结束后，将 temp 赋值给 result，成为下一轮的“已有组合”。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params"><span class="hljs-attr">digits</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>[] {<br>  <span class="hljs-keyword">if</span> (digits.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: { [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> } = {<br>    <span class="hljs-string">"2"</span>: <span class="hljs-string">"abc"</span>,<br>    <span class="hljs-string">"3"</span>: <span class="hljs-string">"def"</span>,<br>    <span class="hljs-string">"4"</span>: <span class="hljs-string">"ghi"</span>,<br>    <span class="hljs-string">"5"</span>: <span class="hljs-string">"jkl"</span>,<br>    <span class="hljs-string">"6"</span>: <span class="hljs-string">"mno"</span>,<br>    <span class="hljs-string">"7"</span>: <span class="hljs-string">"pqrs"</span>,<br>    <span class="hljs-string">"8"</span>: <span class="hljs-string">"tuv"</span>,<br>    <span class="hljs-string">"9"</span>: <span class="hljs-string">"wxyz"</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">""</span>];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> digit <span class="hljs-keyword">of</span> digits) {<br>    <span class="hljs-keyword">const</span> letters = map[digit];<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">temp</span>: <span class="hljs-built_in">string</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prev <span class="hljs-keyword">of</span> result) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> letter <span class="hljs-keyword">of</span> letters) {<br>        temp.<span class="hljs-title function_">push</span>(prev + letter);<br>      }<br>    }<br>    result = temp;<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>从“空组合”开始，依次将每个新数字的字母可能性“横向扩展”到所有已有组合上，最终得到所有完整组合</p><hr><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><p>给你一个由  <code>n</code>  个整数组成的数组  <code>nums</code> ，和一个目标值  <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组  <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code>  和  <code>d</code>  互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>输入：<code>nums = [1,0,-1,0,-2,2]</code>, <code>target = 0</code><br>输出：<code>[[-2,-1,1,2] , [-2,0,0,2] , [-1,0,0,1]]</code></p><p>输入：<code>nums = [2,2,2,2,2]</code>, <code>target = 8</code><br>输出：<code>[[2,2,2,2]]</code></p><p><strong>就是三数之和的基础上再套上一层 for 循环</strong></p><p>题解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number[][]</span>}</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) {<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);  <span class="hljs-comment">// 先排序</span><br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> result = [];<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) {<br>        <span class="hljs-comment">// 去重 i</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前四个最小值之和已大于 target，直接终止</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前 i 与后面三个最大值之和小于 target，跳过本次 i</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) {<br>            <span class="hljs-comment">// 去重 j</span><br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">let</span> left = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (left &lt; right) {<br>                <span class="hljs-keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];<br><br>                <span class="hljs-keyword">if</span> (sum === target) {<br>                    result.<span class="hljs-title function_">push</span>([nums[i], nums[j], nums[left], nums[right]]);<br><br>                    <span class="hljs-comment">// 去重 left</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-comment">// 去重 right</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) right--;<br><br>                    left++;<br>                    right--;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {<br>                    left++;<br>                } <span class="hljs-keyword">else</span> {<br>                    right--;<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> result;<br>};<br></code></pre></td></tr></table></figure><hr><h2 id="19-删除链表的第-n-个节点"><a href="#19-删除链表的第-n-个节点" class="headerlink" title="19. 删除链表的第 n 个节点"></a>19. 删除链表的第 n 个节点</h2><p>给你一个链表，删除链表的倒数第  <code>n</code>  个结点，并且返回链表的头结点</p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>输入：head = [1], n = 1<br>输出：[]</p><p>自己写的一版，思路主要是遍历一趟链表搞到 length，再用 n 确定 index 来定位要删的位置，最后再删掉该节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> curr = head;<br>  <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    len++;<br>    curr = curr.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">if</span> (len === n) {<br>    <span class="hljs-keyword">return</span> head?.<span class="hljs-property">next</span> ?? <span class="hljs-literal">null</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> index = len - n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> delindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">let</span> del = head;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  prev.<span class="hljs-property">next</span> = head;<br>  <span class="hljs-keyword">while</span> (del !== <span class="hljs-literal">null</span>) {<br>    prev = prev.<span class="hljs-property">next</span>;<br>    del = del.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (delindex === index) {<br>      prev.<span class="hljs-property">next</span> = del.<span class="hljs-property">next</span>;<br>    }<br>    delindex++;<br>  }<br>  <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><p>题解的话主要是用快慢指针,这个思路挺不错的其实</p><ul><li>引入虚拟头结点 dummy</li><li>让 fast 指针先走 n 步</li><li>然后 slow 与 fast 同步移动，当 fast 到达末尾时，slow 指向的就是倒数第 n 个节点的前一个节点</li><li>执行 slow.next = slow.next.next 删除目标节点</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 边界：空链表或 n 无效直接返回</span><br>  <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  dummy.<span class="hljs-property">next</span> = head;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">fast</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">slow</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br><br>  <span class="hljs-comment">// fast 先走 n 步</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    fast = fast!.<span class="hljs-property">next</span>; <span class="hljs-comment">// n 合法时不会为 null</span><br>  }<br><br>  <span class="hljs-comment">// fast 和 slow 同步移动，直到 fast 到达末尾</span><br>  <span class="hljs-keyword">while</span> (fast!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    fast = fast!.<span class="hljs-property">next</span>;<br>    slow = slow!.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 此时 slow 指向倒数第 n 个节点的前一个节点</span><br>  <span class="hljs-keyword">if</span> (slow!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    slow!.<span class="hljs-property">next</span> = slow!.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p>给定一个只包括  <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>  的字符串  <code>s</code> ，判断字符串是否有效</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例 1：<br>输入：<code>s = "()"</code><br>输出：true</p><p>示例 2：<br>输入：<code>s = "()[]{}"</code><br>输出：true</p><p>示例 3：<br>输入：<code>s = "(]"</code><br>输出：false</p><p>示例 4：<br>输入：<code>s = "([])"</code><br>输出：true</p><p>示例 5：<br>输入：<code>s = "([)]"</code><br>输出：false</p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code>  仅由括号  <code>'()[]{}'</code>  组成</li></ul><p>思路不难，主要就是栈匹配问题</p><ul><li>开括号 → 入栈 <code>stk.push(s[i])</code></li><li>闭括号 → 元素出栈 <code>stk.pop()</code> 进行匹配  </li><li>若栈空或栈顶不匹配 → 立即返回 false；否则弹出栈顶</li><li>遍历结束 → 栈空返回 true，否则 false</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">stk</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"("</span> || s[i] === <span class="hljs-string">"["</span> || s[i] === <span class="hljs-string">"{"</span>) {<br>      stk.<span class="hljs-title function_">push</span>(s[i]);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">")"</span> || s[i] === <span class="hljs-string">"]"</span> || s[i] === <span class="hljs-string">"}"</span>) {<br>      <span class="hljs-keyword">if</span> (stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>      <span class="hljs-keyword">let</span> curr = stk.<span class="hljs-title function_">pop</span>()!;<br>      <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"("</span> &amp;&amp; s[i] === <span class="hljs-string">")"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"["</span> &amp;&amp; s[i] === <span class="hljs-string">"]"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"{"</span> &amp;&amp; s[i] === <span class="hljs-string">"}"</span>) {<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是力扣速刷第二期awa&lt;br&gt;说是速刷其实卡了挺久&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-关于Javascript/TypeScript 的顺序表，链表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/46758.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/46758.html</id>
    <published>2025-12-26T04:16:12.000Z</published>
    <updated>2025-12-26T04:42:12.018Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。</p><p>以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并附带说明。</p><h2 id="1-顺序表（基于数组的动态顺序表）"><a href="#1-顺序表（基于数组的动态顺序表）" class="headerlink" title="1. 顺序表（基于数组的动态顺序表）"></a>1. 顺序表（基于数组的动态顺序表）</h2><p>顺序表的核心是连续存储，使用数组实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建顺序表</span><br><span class="hljs-keyword">const</span> seqList = [];<br><br><span class="hljs-comment">// 添加元素</span><br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">10</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// 在索引 1 处插入 15</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">// [10, 15, 20, 30]</span><br><br><span class="hljs-comment">// 修改索引 2 处的元素</span><br>seqList[<span class="hljs-number">2</span>] = <span class="hljs-number">25</span>;           <span class="hljs-comment">// [10, 15, 25, 30]</span><br><br><span class="hljs-comment">// 删除索引 0 处的元素</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">// [15, 25, 30]</span><br><br><span class="hljs-comment">// 输出长度和内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'长度:'</span>, seqList.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内容:'</span>, seqList);         <span class="hljs-comment">// [15, 25, 30]</span><br></code></pre></td></tr></table></figure><p>手动实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity = <span class="hljs-number">10</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity);  <span class="hljs-comment">// 存储元素</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 当前元素个数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;         <span class="hljs-comment">// 当前容量</span><br>    }<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 扩容（当 size === capacity 时）</span><br>    <span class="hljs-title function_">resize</span>(<span class="hljs-params">newCapacity</span>) {<br>        <span class="hljs-keyword">const</span> newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(newCapacity);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            newData[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = newData;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = newCapacity;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 扩容为两倍</span><br>        }<br>        <span class="hljs-comment">// 从后向前移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>; i &gt;= index; i--) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在末尾添加元素</span><br>    <span class="hljs-title function_">append</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 删除索引 index 处的元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">const</span> removed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>        <span class="hljs-comment">// 从前向后移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-comment">// 可选：缩容（避免频繁缩容，通常当 size == capacity / 4 时缩为一半）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">4</span>)) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">2</span>));<br>        }<br>        <span class="hljs-keyword">return</span> removed;<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'SequentialList: ['</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            str += <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>            <span class="hljs-keyword">if</span> (i !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>) str += <span class="hljs-string">', '</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> seqList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequentialList</span>();<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>seqList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>seqList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// SequentialList: [1, 3, 2]</span><br></code></pre></td></tr></table></figure><h2 id="2-链表（单向链表）"><a href="#2-链表（单向链表）" class="headerlink" title="2. 链表（单向链表）"></a>2. 链表（单向链表）</h2><p>链表使用节点分散存储，支持高效的插入和删除（O(1)），但随机访问较慢（O(n)）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();  <span class="hljs-comment">// 虚拟头结点，便于操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(element);<br>        node.<span class="hljs-property">next</span> = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在链表头部添加元素</span><br>    <span class="hljs-title function_">addFirst</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">0</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 在链表末尾添加元素</span><br>    <span class="hljs-title function_">addLast</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        cur.<span class="hljs-property">val</span> = element;<br>    }<br><br>    <span class="hljs-comment">// 删除索引处元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> removedNode = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = removedNode.<span class="hljs-property">next</span>;<br>        removedNode.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-keyword">return</span> removedNode.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'LinkedList: ['</span>;<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            str += cur.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">next</span>) str += <span class="hljs-string">' -&gt; '</span>;<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">1</span>);<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">2</span>);<br>linkedList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>linkedList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// LinkedList: [1 -&gt; 3 -&gt; 2]</span><br></code></pre></td></tr></table></figure><hr><h2 id="LRU-缓存的实现（使用双向链表-HashMap）"><a href="#LRU-缓存的实现（使用双向链表-HashMap）" class="headerlink" title="LRU 缓存的实现（使用双向链表 + HashMap）"></a>LRU 缓存的实现（使用双向链表 + HashMap）</h2><p>LRU（Least Recently Used）缓存是一种常见的数据结构，用于实现固定容量缓存，当容量满时淘汰最近最少使用的元素。在 JavaScript 中，最高效的实现方式是结合<strong>双向链表</strong>（控制访问顺序）和<strong>Map</strong>（或对象）作为哈希表（实现 O(1) 访问）</p><h3 id="JS实现："><a href="#JS实现：" class="headerlink" title="JS实现："></a>JS实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;        <span class="hljs-comment">// 缓存容量</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();          <span class="hljs-comment">// 使用 Map 作为哈希表，保持插入顺序并支持 O(1) 操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟头节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟尾节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;      <span class="hljs-comment">// 初始化链表：head &lt;-&gt; tail</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将节点移动到链表头部（表示最近使用）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">node</span> - 要移动的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_moveToHead</span>(<span class="hljs-params">node</span>) {<br>        <span class="hljs-comment">// 先从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>;<br><br>        <span class="hljs-comment">// 插入到头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从链表尾部移除节点（淘汰最久未使用的）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 被移除的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_removeTail</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>;<br>        lastNode.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any</span>} 值，如果不存在返回 -1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>        }<br>        <span class="hljs-comment">// 刷新访问顺序：将节点移到头部</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            <span class="hljs-comment">// 已存在：更新值并移到头部</span><br>            existingNode.<span class="hljs-property">value</span> = value;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 不存在：创建新节点</span><br>            <span class="hljs-keyword">const</span> newNode = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入到头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 检查容量是否超出</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeTail</span>();  <span class="hljs-comment">// 移除尾部节点</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);      <span class="hljs-comment">// 从哈希表中删除</span><br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 可选：打印当前缓存顺序（用于调试）</span><br>    <span class="hljs-title function_">printCache</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> result = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current.key}</span>:<span class="hljs-subst">${current.value}</span>`</span>);<br>            current = current.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache (most recent -&gt; least recent):'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2（刷新顺序）</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br><br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);            <span class="hljs-comment">// 容量满，淘汰最久未使用的 1</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 4:4 -&gt; 2:2 -&gt; 3:3</span><br></code></pre></td></tr></table></figure><h3 id="TS实现"><a href="#TS实现" class="headerlink" title="TS实现"></a>TS实现</h3><p>使用双向链表结合 Map（Map 在 TypeScript 中天然支持泛型）实现 O(1) 时间复杂度的 get 和 put 操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 双向链表节点接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>    <span class="hljs-attr">key</span>: K;<br>    <span class="hljs-attr">value</span>: V;<br>    <span class="hljs-attr">prev</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K = <span class="hljs-built_in">number</span>, V = <span class="hljs-built_in">number</span>&gt; {<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span>;                <span class="hljs-comment">// 缓存容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">cache</span>: <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;;        <span class="hljs-comment">// 哈希表：键到节点的映射</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">head</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟尾节点</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">// 将节点移动到头部（最近使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">moveToHead</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-comment">// 从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>!;<br><br>        <span class="hljs-comment">// 插入头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">// 移除尾部节点（最久未使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">removeTail</span>(): <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>!;<br>        lastNode.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">// 获取值</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: K): V | -<span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(node);  <span class="hljs-comment">// 刷新访问顺序</span><br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">// 放入键值对</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            existingNode.<span class="hljs-property">value</span> = value;  <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">const</span> <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 超出容量时淘汰</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeTail</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 调试：打印缓存顺序（最近 -&gt; 最久）</span><br>    <span class="hljs-title function_">printCache</span>(): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current!.key}</span>:<span class="hljs-subst">${current!.value}</span>`</span>);<br>            current = current!.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br></code></pre></td></tr></table></figure><h2 id="链表反转的实现"><a href="#链表反转的实现" class="headerlink" title="链表反转的实现"></a>链表反转的实现</h2><p>单向链表的反转实现，包括迭代和递归两种方式</p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 单向链表节点定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params">arr</span>) {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 方法一：迭代反转（推荐，空间复杂度 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 前驱指针</span><br>    <span class="hljs-keyword">let</span> current = head;      <span class="hljs-comment">// 当前指针</span><br>    <span class="hljs-keyword">let</span> next = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 临时存储下一节点</span><br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        next = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev; <span class="hljs-comment">// 反转指针</span><br>        prev = current;      <span class="hljs-comment">// 前驱前进</span><br>        current = next;      <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// prev 成为新头节点</span><br>}<br><br><span class="hljs-comment">// 方法二：递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-comment">// 递归终止条件：空链表或只有一个节点</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br><br>    <span class="hljs-comment">// 递归反转后续链表</span><br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br><br>    <span class="hljs-comment">// 反转当前节点与下一节点的指向</span><br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> newHead;  <span class="hljs-comment">// 新头节点始终是原链表的尾节点</span><br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIterative = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIterative);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list2);  <span class="hljs-comment">// 6 -&gt; 7 -&gt; 8</span><br><br><span class="hljs-keyword">const</span> reversedRecursive = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRecursive);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><h3 id="TS实现-1"><a href="#TS实现-1" class="headerlink" title="TS实现"></a>TS实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 单向链表节点类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val ?? <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next ?? <span class="hljs-literal">null</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">const</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 迭代反转（推荐，空间 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">current</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = head;<br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">const</span> next = current.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev;        <span class="hljs-comment">// 反转指针</span><br>        prev = current;             <span class="hljs-comment">// 前驱前进</span><br>        current = next;             <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// 新头节点</span><br>}<br><br><span class="hljs-comment">// 递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIter = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIter);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-keyword">const</span> reversedRec = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRec);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><p>DFA:</p><ul><li><strong>顺序表</strong>：适合随机访问（O(1)），插入/删除较慢（O(n)），实现简单，内存连续</li><li><strong>链表</strong>：适合频繁插入/删除（O(1)），随机访问慢（O(n)），内存分散，支持动态扩展, 链表常用于特定算法（如 LRU 缓存、链表反转等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。&lt;/p&gt;
&lt;p&gt;以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-关于JavaScript面试算法：字符串，数组，数字反转和转换</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/47427.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/47427.html</id>
    <published>2025-12-26T03:20:25.000Z</published>
    <updated>2025-12-27T04:41:06.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串，数组，数字的转换"><a href="#字符串，数组，数字的转换" class="headerlink" title="字符串，数组，数字的转换"></a>字符串，数组，数字的转换</h2><p><strong>数字（Number）</strong>、<strong>字符串（String）</strong> 和 <strong>数组（Array）</strong> 之间的相互转换算是常见操作了，常见转换方向、推荐方法、示例代码及说明如下：</p><div class="table-container"><table><thead><tr><th>从 → 到</th><th>方法</th><th>示例代码</th><th>说明</th></tr></thead><tbody><tr><td>Number → String</td><td>String(num) 或 num.toString()</td><td>let str = String(123); // “123” let str = (123).toString(); // “123”</td><td>最可靠方式。toString() 可指定进制，如 (10).toString(2) // “1010”。</td></tr><tr><td>Number → Array</td><td>String(num).split(‘’)</td><td>let arr = String(123).split(‘’); // [“1”, “2”, “3”]</td><td>先转为字符串，再按字符拆分成数组（适用于单个数字的位拆分）。</td></tr><tr><td>String → Number</td><td>Number(str) 或 +str 或 parseInt(str, 10)</td><td>let num = Number(“123”); // 123 let num = +”123”; // 123 let num = parseInt(“123”, 10); // 123</td><td>+str 最简洁；parseInt 适合提取整数部分（忽略后缀非数字）。</td></tr><tr><td>String → Array</td><td>str.split(separator)</td><td>let arr = “1,2,3”.split(‘,’); // [“1”, “2”, “3”] let arr = “123”.split(‘’); // [“1”, “2”, “3”]</td><td>split(‘’) 按单个字符拆分；split(‘,’) 按逗号等分隔符拆分。</td></tr><tr><td>Array → String</td><td>arr.toString() 或 arr.join(separator)</td><td>let str = [1,2,3].toString(); // “1,2,3” let str = [1,2,3].join(‘’); // “123” let str = [1,2,3].join(‘-‘); // “1-2-3”</td><td>join() 更灵活，可自定义分隔符（默认逗号）。</td></tr><tr><td>Array → Number</td><td>先转为字符串，再转为数字（如 Number(arr.join(‘’))）</td><td>let num = Number([1,2,3].join(‘’)); // 123</td><td>适用于纯数字数组；若数组含非数字，返回 NaN。</td></tr><tr><td>Array(Number) → Array(String)</td><td>arr.map(String) 或 arr.map(num =&gt; num.toString())</td><td>let strArr = [1,2,3].map(String); // [“1”, “2”, “3”]</td><td>逐元素转换为字符串，最常用方法。</td></tr><tr><td>Array(String) → Array(Number)</td><td>arr.map(Number) 或 arr.map(str =&gt; parseInt(str, 10))</td><td>let numArr = [“1”,”2”,”3”].map(Number); // [1, 2, 3]</td><td>逐元素转换为数字；parseInt 更安全处理可能含非纯数字字符串。</td></tr></tbody></table></div><p>数组转数字本质是拼接字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'2'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'22'</span>, <span class="hljs-string">'23'</span>];<br><br><span class="hljs-comment">// 步骤1: 使用 join('') 无分隔符拼接成字符串 const str = arr.join(''); // "212223"</span><br><br><span class="hljs-comment">// 步骤2: 转换为数字 const num = Number(str); // 212223 // 或等价简写：const num = +arr.join('');</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 212223（number 类型）</span><br></code></pre></td></tr></table></figure><p>数组转连续字符串本质也是拼接字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TS"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">'X'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'W'</span>];<br><br><span class="hljs-comment">// 使用 join('')（最常用） </span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>); <span class="hljs-comment">// "XWW"</span><br><br><span class="hljs-comment">// 使用 join() 无参数（默认逗号，但空字符串等价） </span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str2</span>: <span class="hljs-built_in">string</span> = arr.<span class="hljs-title function_">join</span>(); <span class="hljs-comment">// 注意：默认会得到 "X,W,W"，必须传空字符串</span><br></code></pre></td></tr></table></figure><h2 id="字符串反转："><a href="#字符串反转：" class="headerlink" title="字符串反转："></a>字符串反转：</h2><p><strong>ES6:</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);<br><br><span class="hljs-comment">// 使用示例 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverseString</span>(<span class="hljs-string">'hello'</span>)); <span class="hljs-comment">// 'olleh'</span><br></code></pre></td></tr></table></figure><p><strong>手动循环</strong>（不依赖内置方法）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">str</span>) {<br>  <span class="hljs-keyword">let</span> reversed = <span class="hljs-string">''</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    reversed += str[i];<br>  }<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure><h2 id="数组反转（Array-Reverse）"><a href="#数组反转（Array-Reverse）" class="headerlink" title="数组反转（Array Reverse）:"></a>数组反转（Array Reverse）:</h2><p><strong>原地反转</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">reverse</span>();  <span class="hljs-comment">// arr 变为 [4, 3, 2, 1]</span><br></code></pre></td></tr></table></figure><p><strong>手动实现</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) {<br>    [arr[left], arr[right]] = [arr[right], arr[left]];<br>    left++;<br>    right--;<br>  }<br>  <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></table></figure><h2 id="数字反转（leetcode-7）"><a href="#数字反转（leetcode-7）" class="headerlink" title="数字反转（leetcode # 7）"></a>数字反转（leetcode # 7）</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseInt</span>(<span class="hljs-params">x</span>) {<br>  <span class="hljs-keyword">const</span> sign = x &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> reversed = sign * <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>), <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>数组排序</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串，数组，数字的转换&quot;&gt;&lt;a href=&quot;#字符串，数组，数字的转换&quot; class=&quot;headerlink&quot; title=&quot;字符串，数组，数字的转换&quot;&gt;&lt;/a&gt;字符串，数组，数字的转换&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数字（Number）&lt;/strong&gt;、&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-面试算法ACM模式构建构建输入输出模板（Javascript）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/31996.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/31996.html</id>
    <published>2025-12-25T15:09:45.000Z</published>
    <updated>2025-12-26T07:14:53.570Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞<br>上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板</p><h2 id="一、基础模板"><a href="#一、基础模板" class="headerlink" title="一、基础模板"></a>一、基础模板</h2><p>我们先来看一个基础模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello Nowcoder!"</span>);<br>})();<br></code></pre></td></tr></table></figure><p>我们接下来逐行解析下每行代码的作用</p><h5 id="1-引入-readline-模块并创建接口"><a href="#1-引入-readline-模块并创建接口" class="headerlink" title="1. 引入 readline 模块并创建接口"></a>1. 引入 readline 模块并创建接口</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br></code></pre></td></tr></table></figure><ul><li><code>require("readline")</code>：引入 Node.js 内置的<code>readline</code>模块，这个模块用于从命令行（标准输入）读取一行一行的输入。</li><li><code>createInterface({ input: process.stdin })</code>：创建一个输入接口，指定输入源为<code>process.stdin</code>（标准输入，也就是用户在控制台输入的内容）。</li><li>变量<code>rl</code>就是这个输入接口的实例，后续通过它来控制输入的读取。</li></ul><h5 id="2-创建异步迭代器"><a href="#2-创建异步迭代器" class="headerlink" title="2. 创建异步迭代器"></a>2. 创建异步迭代器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br></code></pre></td></tr></table></figure><ul><li><code>Symbol.asyncIterator</code>是 Javascript 的一个内置符号，用于定义对象的异步迭代器</li><li>这里通过<code>rl[Symbol.asyncIterator]()</code>获取 rl 接口的异步迭代器，赋值给<code>iter</code>。</li><li>异步迭代器的作用是：可以通过<code>next()</code>方法<strong>异步地获取下一行输入</strong>（因为输入是用户手动输入的，属于异步操作）。</li></ul><h5 id="3-定义读取一行输入的函数"><a href="#3-定义读取一行输入的函数" class="headerlink" title="3. 定义读取一行输入的函数"></a>3. 定义读取一行输入的函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br></code></pre></td></tr></table></figure><ul><li>这是一个异步函数（<code>async</code>标记），作用是读取一行输入。</li><li>调用<code>iter.next()</code>会返回一个 Promise，<code>await</code>会等待这个 Promise 完成，获取下一行输入的结果。</li><li>结果的<code>value</code>属性就是读取到的一行字符串（如果没有更多输入，<code>value</code>会是<code>undefined</code>）。</li><li>简单说：调用<code>readline()</code>就可以得到一行输入的内容（字符串类型）</li></ul><h5 id="4-立即执行的异步函数（核心逻辑区）"><a href="#4-立即执行的异步函数（核心逻辑区）" class="headerlink" title="4. 立即执行的异步函数（核心逻辑区）"></a>4. 立即执行的异步函数（核心逻辑区）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here 👉 你的核心代码写在这里</span><br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入 console.log("Hello Nowcoder!");</span><br>})();<br></code></pre></td></tr></table></figure><p>这是整个代码的<strong>执行入口</strong>，也就是你需要编写核心逻辑的地方，我们拆解一下：</p><ul><li><code>void async function (){...}()</code>:这是一个<strong>立即执行的异步函数表达式</strong> (IIFE)。<ul><li><code>async</code>标记：允许函数内部使用 await 关键字（因为读取输入输出是异步操作）。</li><li><code>void</code>：避免函数执行后返回值可能导致的语法问题，单纯让函数执行。</li><li>最后的<code>()</code>：表示定义后立即执行这个函数。</li></ul></li></ul><h4 id="核心代码写在哪里？"><a href="#核心代码写在哪里？" class="headerlink" title="核心代码写在哪里？"></a>核心代码写在哪里？</h4><p>答案是：写在<code>void async function () { ... }</code>这个函数内部（也就是注释<code>// Write your code here</code>的位置）。根据题目的输入格式不同，你需要修改这个区域的代码。具体常见的输入格式见我第二部分详细讲解。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个模板的作用是标准化输入读取流程：</p><ol><li>准备好读取输入的工具（<code>rl</code>接口，<code>iter</code>迭代器，<code>readline</code>函数）。</li><li>在立即执行的异步函数中，通过<code>await readline()</code>获取输入。</li><li>在函数内部编写你的核心逻辑（处理输入、计算、输出结果）。</li></ol><h2 id="二、常见出题形式"><a href="#二、常见出题形式" class="headerlink" title="二、常见出题形式"></a>二、常见出题形式</h2><h4 id="1-单组-A-B"><a href="#1-单组-A-B" class="headerlink" title="1.单组 A+B"></a>1.单组 A+B</h4><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>给定两个整数<code>a</code>和<code>b</code>，请你求出<code>a + b</code>的值。</p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>第一行有两个整数<code>a</code>和<code>b</code></p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输入一个整数，代表<code>a + b</code>的值。</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h6 id="核心逻辑解析"><a href="#核心逻辑解析" class="headerlink" title="核心逻辑解析"></a>核心逻辑解析</h6><p>函数内部的<code>while</code>循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span>(line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>()) { ... }<br></code></pre></td></tr></table></figure><ul><li>作用：<strong>持续读取每一行输入</strong> ，直到没有更多输入(<code>readline()</code>返回<code>undefined</code>，循环终止)。</li><li><code>line = await readline()</code>：先调用<code>readline()</code>读取每一行输入，赋值给<code>line</code>。</li><li>当没有输入时，<code>readline()</code>先返回<code>undefined</code>，循环条件为<code>false</code>，退出循环。</li></ul><p>循环内部的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>); <span class="hljs-comment">// 将一行输入按空格分割成数组（比如输入"1 2"，得到["1", "2"]）</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 将第一个元素转为整数</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 将第二个元素转为整数 console.log(a + b); // 输出结果</span><br></code></pre></td></tr></table></figure><h4 id="2-多组-A-B-EOF-形式"><a href="#2-多组-A-B-EOF-形式" class="headerlink" title="2.多组_A+B_EOF 形式"></a>2.多组_A+B_EOF 形式</h4><h6 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，读取至文件末尾为止，每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，读取至文件末尾为止</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入，直到没有更多输入（EOF）</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 将一行输入按空格分割成数组（例如"1 2"分割为["1", "2"]）</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-comment">// 将分割后的字符串转为整数</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出两数之和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="3-多组-A-B-T-组形式"><a href="#3-多组-A-B-T-组形式" class="headerlink" title="3.多组_A+B_T 组形式"></a>3.多组_A+B_T 组形式</h4><h6 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h6><p>给定 t 组测试数据。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数 t，每行有两个整数 a 和 b</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取测试用例数量T</span><br>  <span class="hljs-keyword">let</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：循环T次，处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取一行输入</span><br>    <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>    <span class="hljs-comment">// 分割成两个数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="4-多组A-B零尾模式"><a href="#4-多组A-B零尾模式" class="headerlink" title="4.多组A+B零尾模式"></a>4.多组<em>A+B</em>零尾模式</h4><h6 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，最后一组数据为 0 0，作为输入的结尾。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，最后一组数据为 0 0，作为输入的结尾。</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 分割并转换为数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 关键：判断是否为0 0，是则终止循环</span><br>    <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 退出循环，不再处理后续输入</span><br>    }<br><br>    <span class="hljs-comment">// 不是终止条件则输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="5-单组-一维数组"><a href="#5-单组-一维数组" class="headerlink" title="5.单组_一维数组"></a>5.单组_一维数组</h4><h6 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br>输出：<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取数字的个数n</span><br>  <span class="hljs-keyword">let</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：读取第二行，获取包含n个数字的字符串</span><br>  <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 第三步：对字符串进行处理，转化为数字数组</span><br>  <span class="hljs-keyword">let</span> nums = line<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 用空格分割，过滤空值</span><br><br>  <span class="hljs-comment">// 第四步：计算数组中所有数字的总和</span><br>  <span class="hljs-keyword">let</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 第五步：输出总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="6-多组-一维数组-T-组形式"><a href="#6-多组-一维数组-T-组形式" class="headerlink" title="6.多组_一维数组_T 组形式"></a>6.多组_一维数组_T 组形式</h4><h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">12</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 循环处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取当前组的元素个数n</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 读取当前组的数组元素行</span><br>    <span class="hljs-keyword">const</span> arrayLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 将字符串分割为数字数组</span><br>    <span class="hljs-keyword">const</span> numbers = arrayLine<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-comment">// 计算数组总和（使用reduce累加，初始值为0）</span><br>    <span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, current</span>) =&gt;</span> acc + current, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="7-单组-二维数组"><a href="#7-单组-二维数组" class="headerlink" title="7.单组_二维数组"></a>7.单组_二维数组</h4><h6 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>输出：<br><span class="hljs-number">78</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">let</span> firstLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>  <span class="hljs-keyword">let</span> [m, n] = firstLine.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// m=3, n=4（对应示例输入）</span><br><br>  <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储总和</span><br><br>  <span class="hljs-comment">// 2. 循环读取m行数据（二维数组的每一行）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    <span class="hljs-keyword">let</span> row = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>(); <span class="hljs-comment">// 读取一行数据（如"1 2 3 4"）</span><br>    <span class="hljs-keyword">let</span> nums = row<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 转为数字数组（如[1,2,3,4]）</span><br><br>    <span class="hljs-comment">// 3. 累加当前行的所有元素到总和</span><br>    <span class="hljs-keyword">let</span> rowSum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>    totalSum += rowSum;<br>  }<br><br>  <span class="hljs-comment">// 4. 输出二维数组所有元素的总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="8-多组-二维数组-T-组形式"><a href="#8-多组-二维数组-T-组形式" class="headerlink" title="8.多组_二维数组_T 组形式"></a>8.多组_二维数组_T 组形式</h4><h6 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br>输出：<br><span class="hljs-number">78</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组二维数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的行数m和列数n</span><br>    <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储当前组的总和</span><br><br>    <span class="hljs-comment">// 2.2 读取m行数据（二维数组的每一行）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>      <span class="hljs-keyword">const</span> row = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>        .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>      <span class="hljs-comment">// 累加当前行的所有元素</span><br>      <span class="hljs-keyword">const</span> rowSum = row.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>      totalSum += rowSum;<br>    }<br><br>    <span class="hljs-comment">// 2.3 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="9-单组-字符串"><a href="#9-单组-字符串" class="headerlink" title="9.单组_字符串"></a>9.单组_字符串</h4><h6 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h6><p>给定一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>n</code>，第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">5</span><br>abcde<br>输出：<br>edcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行：字符串的长度n（本题中可忽略具体值，仅用于匹配输入格式）</span><br>  <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 读取第二行：需要反转的字符串</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 3. 反转字符串：</span><br>  <span class="hljs-comment">//    - split('') 将字符串转为字符数组（如"abcde" → ['a','b','c','d','e']）</span><br>  <span class="hljs-comment">//    - reverse() 反转数组（→ ['e','d','c','b','a']）</span><br>  <span class="hljs-comment">//    - join('') 将数组转回字符串（→ "edcba"）</span><br>  <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-comment">// 4. 输出反转后的字符串</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>})();<br></code></pre></td></tr></table></figure><h4 id="10-多组-字符串-T-组形式"><a href="#10-多组-字符串-T-组形式" class="headerlink" title="10.多组_字符串_T 组形式"></a>10.多组_字符串_T 组形式</h4><h6 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次只给出一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后<code>t</code>组数据。每组的第一行有一个整数<code>n</code>,每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出<code>t</code>行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br>abcde<br><span class="hljs-number">8</span><br>redocwon<br><span class="hljs-number">9</span><br>tfarcenim<br>输出：<br>edcba<br>nowcoder<br>minecraft<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串长度n（仅用于匹配输入格式，反转逻辑不依赖此值）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取当前组需要反转的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 反转字符串：拆分为字符数组 → 反转数组 → 拼接为字符串</span><br>    <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>    <span class="hljs-comment">// 2.4 输出反转后的字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="11-单组-二维字符数组"><a href="#11-单组-二维字符数组" class="headerlink" title="11.单组_二维字符数组"></a>11.单组_二维字符数组</h4><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有两个整数<code>n</code>和<code>m</code>，随后<code>n</code>行，每行有<code>m</code>个字符，仅包含小写英文字符。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个二维字符数组。</p><h6 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>abcd<br>efgh<br>ijkl<br>输出：<br>lkji<br>hgfe<br>dcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>  <span class="hljs-comment">// 2. 读取m行字符串，存储到数组中</span><br>  <span class="hljs-keyword">const</span> rows = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    rows.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br>  }<br><br>  <span class="hljs-comment">// 3. 处理逻辑：</span><br>  <span class="hljs-comment">//    a. 先将每行字符串反转（如"abcd" → "dcba"）</span><br>  <span class="hljs-comment">//    b. 再将所有行的顺序反转（如[行1, 行2, 行3] → [行3, 行2, 行1]）</span><br>  <span class="hljs-keyword">const</span> reversedRows = rows<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>)) <span class="hljs-comment">// 每行字符反转</span><br>    .<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// 行顺序反转</span><br><br>  <span class="hljs-comment">// 4. 逐行输出处理后的结果</span><br>  reversedRows.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(row));<br>})();<br></code></pre></td></tr></table></figure><h4 id="12-多组-带空格的字符串-T-组形式"><a href="#12-多组-带空格的字符串-T-组形式" class="headerlink" title="12.多组_带空格的字符串_T 组形式"></a>12.多组_带空格的字符串_T 组形式</h4><h6 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次给出一个长度为<code>n</code>的带空格的字符串<code>s</code>，请你去掉空格之后，将其倒置，然后输出。</p><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后有<code>t</code>组数据。每组的第一行有一个整数<code>n</code>，每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符和空格，保证字符串首尾都不是空格。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">9</span><br>one space<br><span class="hljs-number">11</span><br>two  spaces<br><span class="hljs-number">14</span><br>three   spaces<br>输出：<br>ecapseno<br>secapsowt<br>secapseerht<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串总长度n（用于匹配输入格式）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取带空格的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 处理逻辑：</span><br>    <span class="hljs-comment">//    a. 先将字符串所有字符（包括空格）反转</span><br>    <span class="hljs-comment">//    b. 再去除反转后字符串中的所有空格</span><br>    <span class="hljs-keyword">const</span> processed = str<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拆分为字符数组（含空格）</span><br>      .<span class="hljs-title function_">reverse</span>() <span class="hljs-comment">// 反转所有字符（包括空格）</span><br>      .<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拼接回字符串</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// 去除所有空格（\s+匹配任意空白字符）</span><br><br>    <span class="hljs-comment">// 2.4 输出处理结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processed);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="13-单组-保留小数位数"><a href="#13-单组-保留小数位数" class="headerlink" title="13.单组_保留小数位数"></a>13.单组_保留小数位数</h4><h6 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h6><p>给定一个小数 n ，请你保留 3 位小数后输出。</p><p>如果原来的小数位数少于 3 ，需要补充 0 。</p><p>如果原来的小数位数多于 3 ，需要四舍五入到 3 位。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1.23</span><br>输出：<br><span class="hljs-number">1.230</span><br><br>输入：<br><span class="hljs-number">114.514</span><br>输出：<br><span class="hljs-number">114.514</span><br><br>输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">123.000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的小数（单组输入，只需读一次）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 将字符串转换为浮点数</span><br>  <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">parseFloat</span>(numStr);<br><br>  <span class="hljs-comment">// 3. 保留3位小数：toFixed(3)会自动补零，确保结果是3位小数</span><br>  <span class="hljs-keyword">const</span> result = num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">// 4. 输出格式化后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h4 id="14-单组-补充前导零"><a href="#14-单组-补充前导零" class="headerlink" title="14.单组_补充前导零"></a>14.单组_补充前导零</h4><h6 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h6><p>给定一个正整数 n ，请你保留 9 个数位，然后输出。</p><p>如果数位少于 9 个，那么需要补充前导零。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">000000123</span><br><br>输入：<br><span class="hljs-number">123456789</span><br>输出：<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的数字（单组输入，读取一行即可）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 补充前导零至9位：</span><br>  <span class="hljs-comment">//    - padStart(9, '0') 表示如果字符串长度不足9位，在前面补'0'直到长度为9</span><br>  <span class="hljs-keyword">const</span> result = numStr.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">9</span>, <span class="hljs-string">"0"</span>);<br><br>  <span class="hljs-comment">// 3. 输出处理后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>parseInt()</code>：将字符串转化为整数。</li><li><code>parseFloat()</code>：将字符串转化为浮点数。</li><li><code>split()</code>：将字符串按指定分隔符分割成数组。</li><li><code>reverse()</code>：反转数组。</li><li><code>join()</code>：将数组元素按指定分隔符拼接成字符串。</li><li><p><code>padStart()</code>：在字符串前面补充指定字符，直到字符串长度达到指定长度。</p></li><li><p><code>line = await readline()</code>：要注意 await readline()获取的是一段字符串，后面我们还要自己将它分割或者转化为其他数据类型。</p></li><li><code>let tokens = line.split(' ')</code>：这段代码作用是，将一行输入按空格分割成数组（例如”1 2”分割为[“1”, “2”]）。</li><li><code>let a = parseInt(tokens[0])</code>：这段代码的作用是，将分割的字符转化为数字。</li></ul><p>再配合<code>while</code>和<code>for</code>语句差不多可以应对各种题型了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞&lt;br&gt;上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板&lt;/p&gt;
&lt;h2 id=&quot;一、基础模板&quot;&gt;&lt;a href=&quot;#一、基础模板&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-ES6-关于JavaScript的Set 方法</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/27040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/27040.html</id>
    <published>2025-12-25T07:26:18.000Z</published>
    <updated>2025-12-26T05:45:01.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Set-方法详解"><a href="#JavaScript-Set-方法详解" class="headerlink" title="JavaScript Set 方法详解"></a>JavaScript Set 方法详解</h1><h2 id="1-Set-是什么？"><a href="#1-Set-是什么？" class="headerlink" title="1. Set 是什么？"></a>1. Set 是什么？</h2><p><strong>Set</strong>​ 是 ES6 引入的一种新的数据结构，它类似于数组，但<strong>成员的值都是唯一的</strong>，没有重复的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 创建一个 Set</span><br><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 或者从数组创建</span><br><span class="hljs-keyword">const</span> setFromArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// 会自动去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setFromArray); <span class="hljs-comment">// Set(4) {1, 2, 3, 4}</span><br></code></pre></td></tr></table></figure><h2 id="2-Set-的基本方法"><a href="#2-Set-的基本方法" class="headerlink" title="2. Set 的基本方法"></a>2. Set 的基本方法</h2><h3 id="2-1-添加元素：add"><a href="#2-1-添加元素：add" class="headerlink" title="2.1 添加元素：add()"></a>2.1 添加元素：<code>add()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 添加单个元素</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复添加，不会被添加进去</span><br><br><span class="hljs-comment">// 链式调用</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 可以添加任意类型的值</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"hello"</span>);<br>set.<span class="hljs-title function_">add</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> });<br>set.<span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// NaN 在 Set 中也是唯一的</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// 不会添加第二个 NaN</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 查看大小</span><br></code></pre></td></tr></table></figure><h3 id="2-2-删除元素：delete"><a href="#2-2-删除元素：delete" class="headerlink" title="2.2 删除元素：delete()"></a>2.2 删除元素：<code>delete()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-comment">// 删除指定值</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(4) {1, 2, 4, 5}</span><br><br><span class="hljs-comment">// 删除不存在的值返回 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 删除对象引用需要相同的引用</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> })); <span class="hljs-comment">// false，因为不是同一个引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(obj)); <span class="hljs-comment">// true，删除成功</span><br></code></pre></td></tr></table></figure><h3 id="2-3-检查存在：has"><a href="#2-3-检查存在：has" class="headerlink" title="2.3 检查存在：has()"></a>2.3 检查存在：<code>has()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 对于 NaN，Set 能正确处理</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="2-4-清空-Set：clear"><a href="#2-4-清空-Set：clear" class="headerlink" title="2.4 清空 Set：clear()"></a>2.4 清空 Set：<code>clear()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 5</span><br><br>set.<span class="hljs-title function_">clear</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(0) {}</span><br></code></pre></td></tr></table></figure><h2 id="3-Set-的遍历方法"><a href="#3-Set-的遍历方法" class="headerlink" title="3. Set 的遍历方法"></a>3. Set 的遍历方法</h2><h3 id="3-1-forEach"><a href="#3-1-forEach" class="headerlink" title="3.1 forEach()"></a>3.1 <code>forEach()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>]);<br><br><span class="hljs-comment">// 遍历每个元素</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key, set</span>) =&gt;</span> {<br>  <span class="hljs-comment">// Set 的 key 和 value 相同</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);<br>});<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// apple: apple</span><br><span class="hljs-comment">// banana: banana</span><br><span class="hljs-comment">// orange: orange</span><br></code></pre></td></tr></table></figure><h3 id="3-2-keys-、values-、entries"><a href="#3-2-keys-、values-、entries" class="headerlink" title="3.2 keys()、values()、entries()"></a>3.2 <code>keys()</code>、<code>values()</code>、<code>entries()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]);<br><br><span class="hljs-comment">// keys() - 返回键名的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">keys</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// values() - 返回键值的遍历器（Set 的键和值相同）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// entries() - 返回键值对的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">entries</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry); <span class="hljs-comment">// ['a', 'a'], ['b', 'b'], ['c', 'c']</span><br>}<br></code></pre></td></tr></table></figure><h2 id="4-Set-的特性"><a href="#4-Set-的特性" class="headerlink" title="4. Set 的特性"></a>4. Set 的特性</h2><h3 id="4-1-唯一性"><a href="#4-1-唯一性" class="headerlink" title="4.1 唯一性"></a>4.1 唯一性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 自动去重</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> uniqueSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...uniqueSet]); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 对象引用不同，不算重复</span><br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> objSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([obj1, obj2, obj1]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objSet.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，obj1 和 obj2 被认为是不同的</span><br></code></pre></td></tr></table></figure><h3 id="4-2-与数组的对比"><a href="#4-2-与数组的对比" class="headerlink" title="4.2 与数组的对比"></a>4.2 与数组的对比</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 查找元素</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><br><span class="hljs-comment">// 数组查找是 O(n)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，需要遍历</span><br><br><span class="hljs-comment">// Set 查找是 O(1)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，哈希查找，更快</span><br><br><span class="hljs-comment">// 判断是否重复</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicates</span> = (<span class="hljs-params">array</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array).<span class="hljs-property">size</span> !== array.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="4-3-迭代顺序"><a href="#4-3-迭代顺序" class="headerlink" title="4.3 迭代顺序"></a>4.3 迭代顺序</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 的遍历顺序就是插入顺序</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 3, 1, 2（插入顺序）</span><br>}<br><br><span class="hljs-comment">// 与对象不同，对象的键顺序不保证</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-number">3</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>: <span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>: <span class="hljs-string">"c"</span> };<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)); <span class="hljs-comment">// ['1', '2', '3']（数字键会排序）</span><br></code></pre></td></tr></table></figure><h2 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h2><h3 id="5-1-数组去重（最常用）"><a href="#5-1-数组去重（最常用）" class="headerlink" title="5.1 数组去重（最常用）"></a>5.1 数组去重（最常用）</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传统方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniqueArray</span>(numbers)); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 字符串去重</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"hello world"</span>;<br><span class="hljs-keyword">const</span> uniqueChars = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueChars); <span class="hljs-comment">// 'helo wrd'</span><br></code></pre></td></tr></table></figure><h3 id="5-2-求交集、并集、差集"><a href="#5-2-求交集、并集、差集" class="headerlink" title="5.2 求交集、并集、差集"></a>5.2 求交集、并集、差集</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> setA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">const</span> setB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">const</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...union]); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">const</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...intersection]); <span class="hljs-comment">// [3, 4]</span><br><br><span class="hljs-comment">// 差集（A 有 B 没有）</span><br><span class="hljs-keyword">const</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...difference]); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="5-3-数据筛选"><a href="#5-3-数据筛选" class="headerlink" title="5.3 数据筛选"></a>5.3 数据筛选</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 从数组中过滤出唯一的元素</span><br><span class="hljs-keyword">const</span> data = [<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Bob"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> }, <span class="hljs-comment">// 重复</span><br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Charlie"</span> },<br>];<br><br><span class="hljs-comment">// 基于 id 去重</span><br><span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> uniqueData = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(item.<span class="hljs-property">id</span>)) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    seen.<span class="hljs-title function_">add</span>(item.<span class="hljs-property">id</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>});<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueData);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//     { id: 1, name: 'Alice' },</span><br><span class="hljs-comment">//     { id: 2, name: 'Bob' },</span><br><span class="hljs-comment">//     { id: 3, name: 'Charlie' }</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h3 id="5-4-标签-分类系统"><a href="#5-4-标签-分类系统" class="headerlink" title="5.4 标签/分类系统"></a>5.4 标签/分类系统</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TagSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-title function_">addTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">removeTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">delete</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">hasTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">has</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>  }<br><br>  <span class="hljs-title function_">getAllTags</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>];<br>  }<br><br>  <span class="hljs-title function_">merge</span>(<span class="hljs-params">otherTagSystem</span>) {<br>    otherTagSystem.<span class="hljs-property">tags</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">tag</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> articleTags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagSystem</span>();<br>articleTags.<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"Tutorial"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>); <span class="hljs-comment">// 不会重复添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(articleTags.<span class="hljs-title function_">getAllTags</span>()); <span class="hljs-comment">// ['javascript', 'tutorial']</span><br></code></pre></td></tr></table></figure><h2 id="6-Set-性能优势"><a href="#6-Set-性能优势" class="headerlink" title="6. Set 性能优势"></a>6. Set 性能优势</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 测试查找性能</span><br><span class="hljs-keyword">const</span> largeArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);<br><span class="hljs-keyword">const</span> largeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(largeArray);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Array查找"</span>);<br>largeArray.<span class="hljs-title function_">includes</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Array查找"</span>); <span class="hljs-comment">// 约 0.5-1ms</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set查找"</span>);<br>largeSet.<span class="hljs-title function_">has</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set查找"</span>); <span class="hljs-comment">// 约 0.01ms</span><br><br><span class="hljs-comment">// 测试重复检查性能</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesArray</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (arr[i] === arr[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesSet</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-keyword">const</span> testArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">() =&gt;</span><br>  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)<br>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"数组检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesArray</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"数组检查重复"</span>); <span class="hljs-comment">// 慢</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesSet</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set检查重复"</span>); <span class="hljs-comment">// 快</span><br></code></pre></td></tr></table></figure><h2 id="7-WeakSet"><a href="#7-WeakSet" class="headerlink" title="7. WeakSet"></a>7. WeakSet</h2><h3 id="7-1-与-Set-的区别"><a href="#7-1-与-Set-的区别" class="headerlink" title="7.1 与 Set 的区别"></a>7.1 与 Set 的区别</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 可以存储任何类型的值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// WeakSet 只能存储对象引用</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>weakSet.<span class="hljs-title function_">add</span>(obj); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// weakSet.add(1); // TypeError: Invalid value used in weak set</span><br><br><span class="hljs-comment">// WeakSet 的引用是弱引用，不会阻止垃圾回收</span><br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除引用</span><br><span class="hljs-comment">// 等待垃圾回收后，weakSet 中的对应项会自动被移除</span><br></code></pre></td></tr></table></figure><h3 id="7-2-WeakSet-的方法"><a href="#7-2-WeakSet-的方法" class="headerlink" title="7.2 WeakSet 的方法"></a>7.2 WeakSet 的方法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><span class="hljs-keyword">const</span> obj1 = {};<br><span class="hljs-keyword">const</span> obj2 = {};<br><br>weakSet.<span class="hljs-title function_">add</span>(obj1);<br>weakSet.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// true</span><br>weakSet.<span class="hljs-title function_">delete</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// WeakSet 没有 size 属性，不能遍历</span><br><span class="hljs-comment">// console.log(weakSet.size); // undefined</span><br><span class="hljs-comment">// weakSet.forEach(...) // 没有 forEach 方法</span><br></code></pre></td></tr></table></figure><h3 id="7-3-WeakSet-的应用场景"><a href="#7-3-WeakSet-的应用场景" class="headerlink" title="7.3 WeakSet 的应用场景"></a>7.3 WeakSet 的应用场景</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 1. 存储 DOM 节点，避免内存泄漏</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">"button"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button</span>) =&gt;</span> {<br>  weakSet.<span class="hljs-title function_">add</span>(button);<br>  button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (weakSet.<span class="hljs-title function_">has</span>(button)) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"按钮在集合中"</span>);<br>    }<br>  });<br>});<br><br><span class="hljs-comment">// 当按钮从 DOM 中移除时，会被自动垃圾回收</span><br><span class="hljs-comment">// weakSet 中的引用也会自动移除</span><br><br><span class="hljs-comment">// 2. 私有属性模拟</span><br><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    privateData.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 标记为"初始化"</span><br>  }<br><br>  <span class="hljs-title function_">isInitialized</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">has</span>(<span class="hljs-variable language_">this</span>);<br>  }<br>}<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Alice"</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-title function_">isInitialized</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="8-常见的一些陷阱和注意事项"><a href="#8-常见的一些陷阱和注意事项" class="headerlink" title="8. 常见的一些陷阱和注意事项"></a>8. 常见的一些陷阱和注意事项</h2><h3 id="8-1-NaN-的处理"><a href="#8-1-NaN-的处理" class="headerlink" title="8.1 NaN 的处理"></a>8.1 NaN 的处理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 注意：NaN === NaN 为 false，但 Set 认为 NaN 等于自身</span><br></code></pre></td></tr></table></figure><h3 id="8-2-对象引用"><a href="#8-2-对象引用" class="headerlink" title="8.2 对象引用"></a>8.2 对象引用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><br>set.<span class="hljs-title function_">add</span>(obj1);<br>set.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，因为 obj1 和 obj2 是不同的对象引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> })); <span class="hljs-comment">// false，新对象不是同一个引用</span><br></code></pre></td></tr></table></figure><h3 id="8-3-类型转换"><a href="#8-3-类型转换" class="headerlink" title="8.3 类型转换"></a>8.3 类型转换</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"1"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，1 和 '1' 类型不同，不会去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">"1"</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="8-4-遍历时修改"><a href="#8-4-遍历时修改" class="headerlink" title="8.4 遍历时修改"></a>8.4 遍历时修改</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 在遍历时删除元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">2</span>) {<br>    set.<span class="hljs-title function_">delete</span>(item); <span class="hljs-comment">// 当前正在遍历的元素可以安全删除</span><br>  }<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 1, 2, 3（会正常遍历完）</span><br>}<br><br><span class="hljs-comment">// 在遍历时添加元素可能有问题</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">1</span>) {<br>    set.<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加的元素在本次遍历中可能不会被访问</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="9-与其它数据结构的转换"><a href="#9-与其它数据结构的转换" class="headerlink" title="9. 与其它数据结构的转换"></a>9. 与其它数据结构的转换</h2><h3 id="9-1-Set-与-Array"><a href="#9-1-Set-与-Array" class="headerlink" title="9.1 Set 与 Array"></a>9.1 Set 与 Array</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set → Array</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> arr1 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set);<br><span class="hljs-keyword">const</span> arr2 = [...set];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1, arr2); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// Array → Set</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...newSet]); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="9-2-Set-与-String"><a href="#9-2-Set-与-String" class="headerlink" title="9.2 Set 与 String"></a>9.2 Set 与 String</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 字符串去重并排序</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"javascript"</span>;<br><span class="hljs-keyword">const</span> uniqueSorted = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueSorted); <span class="hljs-comment">// 'aijprstv'</span><br></code></pre></td></tr></table></figure><h3 id="9-3-Set-与-Map"><a href="#9-3-Set-与-Map" class="headerlink" title="9.3 Set 与 Map"></a>9.3 Set 与 Map</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用 Set 存储 Map 的键</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>],<br>]);<br><br><span class="hljs-keyword">const</span> keysSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(map.<span class="hljs-title function_">keys</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...keysSet]); <span class="hljs-comment">// ['a', 'b', 'c']</span><br></code></pre></td></tr></table></figure><h2 id="10-综合示例"><a href="#10-综合示例" class="headerlink" title="10. 综合示例"></a>10. 综合示例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实现一个简单的权限系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-comment">// 添加权限</span><br>  <span class="hljs-title function_">addPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 批量添加权限</span><br>  <span class="hljs-title function_">addPermissions</span>(<span class="hljs-params">permissionsArray</span>) {<br>    permissionsArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 检查是否有某个权限</span><br>  <span class="hljs-title function_">hasPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(permission);<br>  }<br><br>  <span class="hljs-comment">// 检查是否有所有指定权限</span><br>  <span class="hljs-title function_">hasAllPermissions</span>(<span class="hljs-params">requiredPermissions</span>) {<br>    <span class="hljs-keyword">return</span> requiredPermissions.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 检查是否有任一指定权限</span><br>  <span class="hljs-title function_">hasAnyPermission</span>(<span class="hljs-params">permissions</span>) {<br>    <span class="hljs-keyword">return</span> permissions.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 获取所有权限</span><br>  <span class="hljs-title function_">getAllPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>];<br>  }<br><br>  <span class="hljs-comment">// 移除权限</span><br>  <span class="hljs-title function_">removePermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">delete</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 清空所有权限</span><br>  <span class="hljs-title function_">clearPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">clear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> userPermissions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionSystem</span>();<br>userPermissions<br>  .<span class="hljs-title function_">addPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>, <span class="hljs-string">"delete"</span>])<br>  .<span class="hljs-title function_">addPermission</span>(<span class="hljs-string">"execute"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasPermission</span>(<span class="hljs-string">"write"</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasAllPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">getAllPermissions</span>()); <span class="hljs-comment">// ['read', 'write', 'delete', 'execute']</span><br></code></pre></td></tr></table></figure><hr><p>总之</p><ul><li>高效查找：<code>has()</code>方法的时间复杂度是 O(1)</li><li>遍历时按插入顺序输出</li><li>需要去重时，优先考虑 Set</li><li>需要快速查找元素是否存在时，用 Set 代替数组</li><li>存储唯一值集合时，Set 是最佳选择</li><li>需要存储对象引用并自动清理时，考虑 WeakSet</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-Set-方法详解&quot;&gt;&lt;a href=&quot;#JavaScript-Set-方法详解&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Set 方法详解&quot;&gt;&lt;/a&gt;JavaScript Set 方法详解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-力扣百题速练（Javascript/TypeScript）Vol.1</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39687.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39687.html</id>
    <published>2025-12-25T05:57:08.000Z</published>
    <updated>2025-12-27T03:55:34.755Z</updated>
    
    <content type="html"><![CDATA[<p>简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都</p><hr><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target<br>在该数组中找出 <strong>和为目标值 target</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标<br>你可以假设每种输入只会对应一个答案，并且同一个元素不能重复使用</p><p><strong>示例</strong>：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1] 解释：因为 nums[0] + nums[1] = 2 + 7 = 9。</p><p>直接用双重循环解，优化的话其实可以上哈希表</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) {<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) {<br>                <span class="hljs-keyword">return</span> [i, j];<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> [];<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p>给定两个非空单向链表，表示两个非负整数<br>每个节点存储一位数字，数字以逆序存储（个位在头部），要求返回一个新链表表示它们的和（同样逆序存储）<br>不允许修改原链表</p><p><strong>示例：</strong><br>输入：l1 = 2 → 4 → 3（表示 342），l2 = 5 → 6 → 4（表示 465）<br>输出：7 → 0 → 8（表示 807）</p><p>本质上是模拟竖式加法，从低位到高位逐位相加。由于链表逆序存储，正好从个位开始遍历</p><ol><li><strong>逐位相加并处理进位</strong>：<ul><li>同时遍历两个链表的节点，取当前节点值相加，加上上一位的进位（初始进位为 0）。</li><li>当前位结果 = (val1 + val2 + carry) % 10</li><li>新进位 carry = Math.floor((val1 + val2 + carry) / 10)</li></ul></li><li><strong>使用哑节点（dummy head）简化代码</strong>：<ul><li>创建一个哑节点，尾指针指向它，便于统一处理头部节点，避免单独处理第一个节点。</li></ul></li><li><strong>处理链表长度不等和最终进位</strong>：<ul><li>当一个链表遍历完时，将另一个链表的剩余节点视为 val = 0 继续相加。</li><li>遍历结束后，若仍有进位（carry = 1），需添加一个新节点值为 1。</li></ul></li></ol><p>提供以下 ListNode 类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params"><span class="hljs-attr">l1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">l2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dummy</span>: <span class="hljs-title class_">ListNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 哑节点，没有 dummy，直接从第一个节点开始构建，结果链表的头节点会在循环中不断变化</span><br>  <span class="hljs-comment">//需要额外判断是否是第一个节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">ListNode</span> = dummy;<br>  <span class="hljs-comment">//始终指向结果链表的“当前最后一个节点”。</span><br>  <span class="hljs-comment">//每次计算出一位新数字后，直接在 tail 后面添加新节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">carry</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 进位，当前这一位加完后，是否需要给下一位（更高位）额外加 1</span><br><br>  <span class="hljs-keyword">while</span> (l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span> || carry !== <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val1</span>: <span class="hljs-built_in">number</span> = l1 ? l1.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val2</span>: <span class="hljs-built_in">number</span> = l2 ? l2.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">sum</span>: <span class="hljs-built_in">number</span> = val1 + val2 + carry;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">digit</span>: <span class="hljs-built_in">number</span> = sum % <span class="hljs-number">10</span>;<br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br><br>    tail.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(digit);<br>    tail = tail.<span class="hljs-property">next</span>;<br><br>    <span class="hljs-keyword">if</span> (l1) l1 = l1.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (l2) l2 = l2.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p>要求给定一个字符串 s，找出其中不含有重复字符的最长<strong>子串</strong>的长度<br>（而非子序列）</p><p><strong>示例：</strong></p><ul><li>输入：”abcabcbb” → 输出：3（子串 “abc”）</li><li>输入：”bbbbb” → 输出：1</li><li>输入：”pwwkew” → 输出：3（子串 “wke”）</li></ul><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp" alt="Longest Substring Without Repeating Characters - GeeksforGeeks"></p><p>直接上滑动窗口，结合哈希集合（Set）或映射</p><ul><li>使用左指针 left 和右指针 right 维护一个窗口 (left, right)</li><li>扩展右指针，若遇到重复字符，则收缩左指针直到无重复</li><li>每次更新最大长度 maxLength = Math.max(maxLength, right - left)</li></ul><p class='item-img' data-src='https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png'><img src="https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png" alt=""></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// 记录窗口内字符</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 左指针</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-property">length</span>; right++) {<br>        <span class="hljs-comment">// 若当前字符已存在，收缩左指针</span><br>        <span class="hljs-keyword">while</span> (charSet.<span class="hljs-title function_">has</span>(s[right])) {<br>            charSet.<span class="hljs-title function_">delete</span>(s[left]);<br>            left++;<br>        }<br>        charSet.<span class="hljs-title function_">add</span>(s[right]);<br>        maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLength, right - left + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> maxLength;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><p>要求在两个已排序数组 nums1 和 nums2 中找到合并后的中位数，且时间复杂度必须为 O(log(m + n))，其中 m 和 n 分别为数组长度</p><p><strong>示例</strong>：</p><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><h3 id="最初思路"><a href="#最初思路" class="headerlink" title="最初思路"></a>最初思路</h3><p>最开始打算做双指针合并，使用两个指针 i 和 j 分别指向 nums1 和 nums2 的当前待比较位置（初始为 0），每次比较 nums1[i] 和 nums2[j]，将较小的元素放入结果数组 merged，并将对应指针后移，当某个数组遍历完后，将另一个数组剩余元素全部追加到 merged，合并完成后，merged 就是一个完整有序数组</p><p>然后就可以根据总长度奇偶性计算中位数：<br>奇数直接取第 (total+1)/2 个元素（索引 mid）<br>偶数取第 total/2 和第 total/2 + 1 个元素的平均（索引 mid-1 和 mid）</p><p>想了 40 分钟，但是复杂度 m * n，直接寄了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; nums2.<span class="hljs-property">length</span>; j++) {<br>        <span class="hljs-keyword">while</span>(nums2[j] &lt;= nums1[i]);<br>            merged.<span class="hljs-title function_">push</span>(nums2[j]);<br>        }<br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; nums2.<span class="hljs-property">length</span>; k++) {<br>        merged.<span class="hljs-title function_">push</span>(nums2[k]);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> ? merged[mid] : (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li><strong>外层 for</strong>：遍历 nums1 的每一个元素 nums1[i]。</li><li><strong>内层 while</strong>（代替 for，避免重复遍历）：在放入 nums1[i] 之前，先检查 nums2 的头部元素（nums2[0]）。<ul><li>只要 nums2[0] &lt;= nums1[i]，就说明这个元素应该排在 nums1[i] 前面，先放入 merged，并从 nums2 中移除（使用 shift()）。</li><li>这样保证了顺序正确。</li></ul></li><li>放入当前 nums1[i]。</li><li>外层循环结束后，如果 nums2 还有剩余元素（说明它们都大于 nums1 所有元素），直接全部追加。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>  <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>      merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!); <span class="hljs-comment">// 取出 nums2 头部元素</span><br>    }<br>    <span class="hljs-comment">// 放入当前 nums1[i]</span><br>    merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>  }<br>  <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>  <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>    merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>  }<br><br>  <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-keyword">return</span> merged[mid];<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>暴力合并为 O(m + n)，但题目要求对数复杂度，因此需避免完整合并。核心思路是将问题转化为<strong>在较短数组上二分查找一个分区点</strong>，使左右部分满足中位数条件：</p><ul><li>总元素数 total = m + n。</li><li>中位数位置：若 total 奇数，为第 (total + 1)/2 个元素；若偶数，为第 total/2 和第 total/2 + 1 个元素的平均。</li><li>我们需要在合并数组的“左侧”选取 total/2 个元素（使用 (total + 1)/2 以统一奇偶处理）。</li><li>在较短数组 A 上二分查找左侧元素个数 i（0 ≤ i ≤ m），则较长数组 B 左侧元素个数 j = (total + 1)/2 - i。</li><li>分区条件：<ul><li>左侧最大值 ≤ 右侧最小值：max(A[i-1], B[j-1]) ≤ min(A[i], B[j])。</li></ul></li><li>处理边界：使用 -∞ 和 +∞ 填充空侧。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>确保 nums1 为较短数组（若不是，交换）。</li><li>二分范围：low = 0, high = nums1.length。</li><li>计算分区：i = (low + high) / 2, j = (m + n + 1) / 2 - i。</li><li>检查分区：<ul><li>若 A[i-1] &gt; B[j]，则 i 太大，high = i - 1。</li><li>若 B[j-1] &gt; A[i]，则 i 太小，low = i + 1。</li><li>否则，分区正确。</li></ul></li><li>计算中位数：<ul><li>左侧最大：max(A[i-1], B[j-1])。</li><li>右侧最小：min(A[i], B[j])。</li><li>若 total 奇数，返回左侧最大；偶数，返回平均。</li></ul></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入 merged</span><br>        <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>            merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);  <span class="hljs-comment">// 取出 nums2 头部元素</span><br>        }<br><br>        <span class="hljs-comment">// 放入当前 nums1[i]</span><br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> merged[mid];<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="5-最长的回文子串"><a href="#5-最长的回文子串" class="headerlink" title="5.最长的回文子串"></a>5.最长的回文子串</h2><p>要求给定一个字符串 s，返回其中最长的回文子串（回文指正读反读相同的连续子串）<br>示例：</p><ul><li>输入：”babad” → 输出：”bab” 或 “aba”（长度 3）</li><li>输入：”cbbd” → 输出：”bb”（长度 2）</li></ul><p class='item-img' data-src='https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png'><img src="https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png" alt="Leetcode 5. Longest Palindromic Substring | Nick Li"></p><h3 id="中心扩展法（Expand-Around-Center）"><a href="#中心扩展法（Expand-Around-Center）" class="headerlink" title="中心扩展法（Expand Around Center）"></a>中心扩展法（Expand Around Center）</h3><p>时间复杂度 O(n²)，空间复杂度 O(1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回文串以中心对称。中心可能为单个字符（奇数长度回文）或两个相同字符间（偶数长度回文）。 对于字符串每个可能中心（共 2n-1 个），向两侧扩展比较字符，直至不对称。记录扩展中最长回文。</p><p>步骤：</p><ol><li>遍历字符串索引 i 从 0 到 n-1。</li><li>以 i 为中心扩展奇数长度回文。</li><li>以 i 和 i+1 为中心扩展偶数长度回文。</li><li>每次扩展更新最长回文起点和长度。</li><li>返回对应子串。</li></ol><p class='item-img' data-src='https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg'><img src="https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg" alt="Longest Palindromic Substring (With Visualization)"></p><h3 id="TypeScript-实现"><a href="#TypeScript-实现" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 最长回文起点</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最长回文长度（初始至少 1）</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">expandAroundCenter</span>(<span class="hljs-params"><span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-property">length</span> &amp;&amp; s[left] === s[right]) {<br>            <span class="hljs-keyword">const</span> currentLength = right - left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (currentLength &gt; maxLength) {<br>                start = left;<br>                maxLength = currentLength;<br>            }<br>            left--;<br>            right++;<br>        }<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 奇数长度回文（中心为 i）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i);<br>        <span class="hljs-comment">// 偶数长度回文（中心为 i 和 i+1）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(start, start + maxLength);<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="6-Z-字变换"><a href="#6-Z-字变换" class="headerlink" title="6. Z 字变换"></a>6. Z 字变换</h2><p>将一个给定字符串  <code>s</code>  根据给定的行数  <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列<br>比如输入字符串为  <code>"PAYPALISHIRING"</code>  行数为  <code>3</code>  时，排列如下：</p><p>P A H N<br>A P L S I I G<br>Y I R</p><p>之后输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>"PAHNAPLSIIGYIR"</code></p><p>实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><p>输入：s = “PAYPALISHIRING”, numRows = 3<br>输出：”PAHNAPLSIIGYIR”</p><p>示例 2：</p><p>输入：s = “PAYPALISHIRING”, numRows = 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br>P I N<br>A L S I G<br>Y A H R<br>P I</p><h3 id="TypeScript-实现-1"><a href="#TypeScript-实现-1" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><p>直接计算位置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">numRows</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (numRows === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> cycle = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; numRows; row++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i + row &lt; s.<span class="hljs-property">length</span>; i += cycle) {<br>      result += s[i + row];<br>      <span class="hljs-keyword">if</span> (row !== <span class="hljs-number">0</span> &amp;&amp; row !== numRows - <span class="hljs-number">1</span> &amp;&amp; i + cycle - row &lt; s.<span class="hljs-property">length</span>) {<br>        result += s[i + cycle - row];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><p>给你一个 32 位的有符号整数  <code>x</code> ，返回将  <code>x</code>  中的数字部分反转后的结果<br>如果反转后整数超过 32 位的有符号整数的范围  <code>[−231, 231 − 1]</code> ，就返回 0<br>假设环境不允许存储 64 位整数（有符号或无符号</p><p>示例 1：<br>输入：x = 123<br>输出：321</p><p>示例 2：<br>输入：x = -123<br>输出：-321</p><p>没啥好讲的，转字符串反转再转回去，处理一下负号和边界情况就成</p><p>反转字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">return</span> x;<br>  }<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX</span> = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN</span> = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> mid = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">LI</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (mid[<span class="hljs-number">0</span>] === <span class="hljs-string">"-"</span>) {<br>    <span class="hljs-variable constant_">LI</span> = <span class="hljs-literal">false</span>;<br>  }<br>  <span class="hljs-keyword">const</span> reverseString = mid.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">true</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(reverseString) &lt; <span class="hljs-variable constant_">MIN</span> || <span class="hljs-built_in">parseInt</span>(reverseString) &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(reverseString);<br>  }<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">false</span>) {<br>    <span class="hljs-keyword">let</span> fin = reverseString.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, reverseString.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> fin2 = -<span class="hljs-built_in">parseInt</span>(fin);<br>    <span class="hljs-keyword">if</span> (fin2 &lt; <span class="hljs-variable constant_">MIN</span> || fin2 &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> fin2;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8.字符串转换整数"></a>8.字符串转换整数</h2><p>实现一个  <code>myAtoi(string s)</code>  函数，使其能将字符串转换成一个 32 位有符号整数。</p><p>函数  <code>myAtoi(string s)</code>  的算法如下：</p><ol><li>空格：读入字符串并丢弃无用的前导空格（<code>" "</code>）</li><li>符号：检查下一个字符（假设还未到字符末尾）为  <code>'-'</code>  还是  <code>'+'</code>如果两者都不存在，则假定结果为正</li><li>转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾，如果没有读取数字，则结果为 0</li><li>舍入：如果整数数超过 32 位有符号整数范围  <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于  <code>−231</code>  的整数应该被舍入为  <code>−231</code> ，大于  <code>231 − 1</code>  的整数应该被舍入为  <code>231 − 1</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myAtoi</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> min = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">sign</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> fin = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> clac = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (i &lt;= s.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">" "</span>) {<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">"-"</span> || s[i] === <span class="hljs-string">"+"</span>) {<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"-"</span>) {<br>        sign = -<span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"+"</span>) {<br>        sign = <span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (clac === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      }<br>      clac = <span class="hljs-number">1</span>;<br>      i++;<br>    }<br>    <span class="hljs-keyword">while</span> (s[i] &lt;= <span class="hljs-string">"9"</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">"0"</span>) {<br>      fin = fin + s[i];<br>      i++;<br>    }<br>    <span class="hljs-keyword">if</span> (fin === <span class="hljs-string">""</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sign === <span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(fin);<br>    }<br>    <span class="hljs-keyword">if</span> (sign === -<span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> -fin;<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure><p>没啥好说的，处理一下转换和条件判断的事情</p><hr><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h2><p>给一个整数  <code>x</code> ，如果  <code>x</code>  是一个回文整数，返回  <code>true</code> ；否则，返回  <code>false</code><br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数<br>例如，<code>121</code>  是回文，而  <code>123</code>  不是</p><p>智斗程度堪比两数之和，转字符串逆序比较秒了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> arr = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> brr = arr.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (arr === brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">if</span> (arr !== brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.正则表达式匹配</h2><p>给你一个字符串  <code>s</code>  和一个字符规律  <code>p</code>，请你来实现一个支持  <code>'.'</code>  和  <code>'*'</code>  的正则表达式匹配。</p><ul><li><code>'.'</code>  匹配任意单个字符</li><li><code>'*'</code>  匹配零个或多个前面的那一个元素</li></ul><p>匹配是要涵盖  <strong>整个</strong>  字符串  <code>s</code>  的，而不是部分字符串。</p><p>示例 1：</p><p>输入：s = “aa”, p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:</p><p>输入：s = “aa”, p = “a<em>“<br>输出：true<br>解释：因为 ‘</em>‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p>示例 3：</p><p>输入：s = “ab”, p = “.<em>“<br>输出：true<br>解释：”.</em>“ 表示可匹配零个或多个（’*‘）任意字符（’.’）</p><p>这道题最开始是想要用纯同步双指针来解，没解出来</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">if</span> (s == p) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">let</span> sindex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> pindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (sindex &lt; s.<span class="hljs-property">length</span> &amp;&amp; pindex &lt; p.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">if</span> (s[sindex] === p[pindex] || p[pindex] === <span class="hljs-string">"."</span>) {<br>      sindex++;<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (p[pindex] === <span class="hljs-string">"*"</span>) {<br>      <span class="hljs-keyword">while</span> (s[sindex] === s[sindex + <span class="hljs-number">1</span>]) {<br>        sindex++;<br>      }<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (s[sindex] !== p[pindex]) {<br>      <span class="hljs-keyword">if</span> (p[pindex] !== <span class="hljs-string">"*"</span> &amp;&amp; p[pindex] !== <span class="hljs-string">"."</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>↑ 错误答案</p><p>主要是该问题具有<strong>非确定性</strong>：同一个 “x*“ 可以有多种匹配方式（0 次、1 次、多次），需要尝试不同分支。纯同步双指针（单路径贪婪）无法处理回溯需求，会在某些案例中错误消耗字符，导致后续失败。</p><p>比如说在 s = “aaa”, p = “ab<em>a” 里贪婪匹配可能错误使用 “b</em>“，而实际应跳过 “b*“（匹配 0 次）</p><p>因此<strong>不能用简单 while 循环同步双指针线性解决</strong>，必须引入分支或状态记录</p><p>然后题解就是使用 dp 解决：</p><p><code>定义二维布尔数组 dp[i][j] 表示：s 的前 i 个字符（s[0..i-1]）是否能被 p 的前 j 个字符（p[0..j-1]）匹配，最终答案为 dp[m][n]，其中 m = s.length，n = p.length</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">const</span> m = s.<span class="hljs-property">length</span>,<br>    n = p.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> dp = <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));<br><br>  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>      dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>    }<br>  }<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>      <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>        dp[i][j] =<br>          dp[i][j - <span class="hljs-number">2</span>] ||<br>          ((s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">2</span>] || p[j - <span class="hljs-number">2</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j]);<br>      } <span class="hljs-keyword">else</span> {<br>        dp[i][j] =<br>          (s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> dp[m][n];<br>}<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p><strong>空串与空模式</strong><code>dp[0][0] = true</code>：空字符串可以被空模式匹配。<br><strong>空字符串与非空模式</strong> 只有当模式中某些 “x*” 可以匹配 0 次字符时，才可能匹配空字符串。 因此从左向右扫描模式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'*'</span>) {<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">2</span>];  <span class="hljs-comment">// 直接继承“跳过当前 x*”的状态</span><br>    }<br>}<br></code></pre></td></tr></table></figure><p>示例：p = “a<em>b</em>c*“ 可以匹配空字符串，故 dp[0][2]、dp[0][4]、dp[0][6] 均为 true。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>遍历 <code>i = 1..m</code> 和 <code>j = 1..n</code>，根据 <code>p[j-1]</code> 的类型分为两种情况：</p><ol><li><p><strong>当前模式字符不是 ‘*‘</strong>（普通字符或 ‘.’） 只能进行单字符匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = (s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">1</span>] || p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>含义：当前字符匹配且前一个子问题也匹配，则当前子问题成立。</p></li><li><p><strong>当前模式字符是 ‘*‘</strong>（与前一个字符组成 “x<em>”） ‘</em>‘ 提供了两种选择：</p><ul><li>匹配 0 次：直接跳过整个 “x*”，状态等同于 dp[i][j-2]。</li><li>匹配 1 次或多次：前提是当前 <code>s[i-1]</code> 能与 “x” 匹配（<code>s[i-1] === p[j-2]</code> 或 <code>p[j-2] === '.'</code>），且在上一个字符已匹配的基础上继续使用 “x*” 匹配当前字符，即 <code>dp[i-1][j]</code></li></ul><p>两者任一成立即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] ||<br>          ((s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">2</span>] || p[j-<span class="hljs-number">2</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j]);<br></code></pre></td></tr></table></figure></li></ol><h3 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h3><ul><li>时间复杂度：O(mn)，每个状态只计算一次。</li><li>空间复杂度：O(mn)，可进一步优化为 O(n)（仅使用两行或一行滚动数组）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-15-杂谈-系统问题</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/48096.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/48096.html</id>
    <published>2025-12-15T03:51:13.000Z</published>
    <updated>2025-12-25T03:23:33.852Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="请联系站长。WXID:Zhong_ye1" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">      <script id="hbeData" type="hbeData" data-hmacdigest="2fa5e232065dcdd25103f65efb162cd34ec15cc0e20eac5efd5e9e1090f37ca5" data-keysalt="69dcd9e5616b22ce8868bf76f18f21c128066233274e3a34ce600f885a0d426a" data-ivsalt="091ecce0f2e41bd293922a22788e8e75bd5c1976bef726b54df06d84ed0ca86e">        cd468965331bbffbb86b340b36b0111acc8be41c6838693c17f880290636f10e07cce1cdcc8263522e557c378a2b97b20bcd0f214b5c4b114f429181cef6485de2a33743ee9f7fca50ab3fe0693c98baa948596d4abbce5d9192bef4dae6756757cc738af03b1360d47ac9d5ed3c82c3df57ce3fa08e4d237d3c657b8ea1962a5e02c0c4dd54869e1e3fa95cbe88681ac5a9befff05e4176a88e5c2d32188d9d165c80c47d2d13cbe81db6cefcc3c727bce03c56a26f32a8bc0a413b081ca63b1ed82b2d77fede1c17c130b919a7bc687de881e4cad85c4b7325ea20a57634fcbb8fda8fa4d8cbdcf32d0aa801203076452bfac60dd0d190c07f58204706d9825a19ead2729cef87f4f4ef977b47e28174506acd6757bacf158db315e9ae5c97848a6f30c69024e09e9032fdd8242b7f1259f07e793bceb572c460ac24fa73e7eea24aa0e0bb8ce23a7d7acee644fda3d047930e01a5c141256bc6f6606e67ad7003d30dd7cd757bda65d79de7770af83f021f5ce1823cdd83de26836902f4ed20c8acce5a88f15c7d03c9ae09e27829bed24070adae0c1be9b012076ba40c3b135e5c33c55046d508a96bf747524ba04aac30eadd180332b762262cfe9daca80633e860fd58ae72d9c376a21b287d2a450ed5eaa0f566a5767f753a448500540606f0031d5b2f273e9d57d41cba8772ab8e3c9f4344850c398a01bd8f6119b0846ae29b398615bcc4b361b284ae387cf4e9a0d1aadd9280e8dd223388a94750666e31fc37eaa872922466dbd001dfa78d3cb8b8920ba5e6fa35cd60fe54663ed9cbf008accf43d0b5856fd4baf0d7ee8c397006ca52c93e68f4bac725f68ddb62e4a8824cb2442003ec2baf42de4132df1eec93db5d3d2f634ea2c4b63ffc540bdd44a822d66b961ce6d3059379892ecbdea254dbc00c96f792b84082cf1b064b89d89d706aec8bc8528487c60bf8a8f4df99421d0b4ef82b0ed1530fcd1910dd54db1d8b33555eebc128b987003044ef101ad0870ed5fb71d2a37d6cd5088ef07c16090fe32c5a2f9c6ff5a48ed991ebd6ff4dffd7c9aa28baa4245f61117c17f778ab865a5db44699da3531cc296bf5d15880254dc6c0ddadeb54d8857e420cc2d3cdeeaf0dfe62f50060bc50f1bf08c12b9186f59c480060bf4cdf2a6a8b7c57e7a553ff0b43eb5163b7f9352a7aa21f692d97e7396314180d957a6cfb2ffbc62607b947a0702416732bffe31c38879cfb61164df52dd302b54a21e972b61fd5f20f667af2390c03e07cf46dbda9a112dc1105852fd141415cbd7624f98cc7361a0eb512e1f57e84f041e2525a14da9c56ede86c6d9ca30252e72805eb9371744a46cb8144a621a83e1f8cdf7506b91ceb38a87eb7f2b79314a4f257f39c164de9c759546d1b5467f10e3f928478954cb85c55a50aae5c66b320d2ebacda12cbf5ba21e9a7d271503f00d46f283c90716959afa673ee4e0bbc7da926ebc342f87d1bce0526f212525296008658e03f81e122ef219602e8925d8e43b91475b11ba3667e2817b87ff373c4646e741815811aef89193f5b5d2b18781d183dd466fd7e2b154c633436b52afac4d35f9d18efe6f7bc69eae3bb12ed38379d93f9b9ca3bc9b59c4cb109294851be94ea2ecb48b230854a579fac11bc1ea5df7651dc95487eac28f0c6d7d467a4fae91c97c521a8f67b74406d1086eec427b8cc2336a9992c3de59c31700abc0036f46f25ba92094810cddf74caf6fed144570e20033118f005f007f6b290dd9c6b659dd23041ef01f588f2cbb8762ec9af7cc1358e375d0786123882ee8ebb18d748aa30b833135bcc8fc3e5161c58cf78e139253d1b8dc202f33affb7c2b33e9ddedf7f31b4b9751d632c7de948945ab3fcb7536a9f638936ff60244a4636edcb87a7f37f9f8a73ae5a4bb0088af23798dc23f9670ad9b42a36caf3c34211ec708a1addbfd672ac60c1c68b335ab2eb911a2f3784fdf79c5292e3bf8a9544ab32cde97d6dc2f55131dfd025bf1f72e0ee489b6c59d0068717d6095dbf9fc4d0a729a3c115497999454f88c503b0de104257d651b5c9089cc6e0dec9715acb3de026dd990bfb84e524aecb2a6a54a3bcfac645873732cdb2f942f5a48f226bc1565e911cf85a42f86b28f1c4fe932d17d89a4c982d24209bd82395d0941ac6a747601c8cf239843535c824a8d56e0ab40e9cdfdabfda46235393eb7a767e54ea9d9f162fb6ff8054a93db97597442a26e526033168b31d1a8823bad8c96fa8f884517f5388c26912de508a271479017dac9045f3d6d2fb26cb7bfcf635fb8079bd702f40f95764f813424d42ee0be4c058dbb6d0b646fb3b6528193a25358e3341ea644b9d88b6205d8fcce29a6f1fdb02e1b6f0660434a3be31534466e57e7bf2f75e3e6453eda1c6435734c742417b0620a5980e52acb1e77be0b9051943050c9d31994bd4eb451e0d41c113b83adc16951f519640fe47d113f3a19b7c0fe4ddec9be35136ac4ee8f6fccbf966bedd5fea09edffcbd118a0beb8b460487afbdf9d68b53d22fb1a611e886b987eb49a60254d34be90b67e2e7a91299d842b6eeac302ac55dd3cd340352ada358ba5be454f6e1a20c997cc6bdbf654b6d8dd67042b0bc8d7a7cf68b7fc9914d6c7445b68f9120c7b0615b493b52a57314d24a07ff79e58dc3213710b330b25a27f62f9ddbeee6e17f09c597c0dd25e3e14bbc92fe754591b293b7619db4b7f86087d67ba208822b6887beef4367ba0133627f7f035bfd1c84c86f472cc67f2014949161e837fbee91b94d5ede0a8f790a3ef7de02b79d2068f1792e6d696033a1a9b41280a71935e40df9fe327ae15566c0430d526d3a2564b7459b718620249a5bb024e56ebc8e40fbe45fed701978bb2b6f5cd1bba7d155b0b6e83db905ce1a6fe7598ecbdd0cd1ff9991e394f6beae0fd7f5b88e525cfc7f8613f3948bee5064b530f43d955b5c2424237fe809130b0c4f8b1c38f88898b6d529592fae708c6783c3dedb7e0d975b8bed6714c061f75dcc076dac7295d89a27085054faac170e326a0e7033f1dbb784e119950f0e3b94fa3fc67c2151c84c9cc91e5c0c4dd2530a69afa95d1587ed89da9379c5a4c3c969369c9fc37598437cd8b4ea8da461dc74aaf6b278647cc132cec73cb22c1bf7785da4a6070ab25dd3959a5e7e38660721a54f4a7e403d70f817e73110c35751ddd529a7896ade9d66b90fe7c3cdd4e536bcdbfe887beb2d12b9fb0f04b95770d1f856c886ca22fdc2b1dbebd1e174d424d31f2cdc52bf1eee3f79f7f162da06a5b77be0f1095c157e06f34e8c2ab5422505276887559137daab47ee15ae79894325bbd49201d125c8c1ac339690aad799d17628dd1781decae8bf237bd5df7432b661b999bf97df01ee2765ddce297a6dc1ee7cc8ed4555e8dce17e62605f6717fb6fc9209e7829e3e12c1b385bff2f6bdb24c2ef99e6a78fbaf353616ebed1f3bffa577540caa417c91511e5eb4237c00fd1dacadf6a16349fc0edb74e184edc0c48d67dda10f4156eaea8331761ea0d59484a456559f5cf052cea4db229e8f66afa663df21e9a23386a9c41d09aa9b425e6550c07838dee935d8bd4c6ecbddca21fb3863755122b7e1a75b74eb987549f43005b8be2398118ec2108ef7db511e88593f6b5ee1c61d457c2a67052a6f62a500cfa93f65dca5e8624de087321e70f0ff61f0bf2e4849be6f92b74e3615bd02ec5933cecd23b6691643d073153d8d19bc28e8f785d679cfd0d5aa93732db4b8ae0745aa522f12132d84cf169f938dadb547012c3c458b9e0b9972277efa1b88d5ff1259f0b1207096286c28ba8758d0b2070f66c3b7f3dc732b8517e0774f38c191207daf5a2695cefd298842ded4012efe6bf89d17f764c1da1f682aabee129aa75305f229447ab27bd4f2a105f890377fadb8230c18461d08fad99118cf28f1e88736870e190092ab659864928d7f6c5cd467e32b1fa8178a5b7a91fb6289ba754cd87ed094ed8649abcafabf25768094f4428c053aa1d7d8255a7a35aad39b718fd6790200517ed1c845fb5d3c148de1fa67ee51e4f40eb8df54e2367b415df513a9a9b22a19f9833afbc72f5c07cedf6a96dbd7ebf4bc0c449d606e16a8a0c2ab9aaf7729e410fc9ae87c5e4769c68fb1c9be798330df81a2c2ef5cc6ac17efc42d0ebab371245db675529985fc0f867c8b7ccc6a092401099ffc859adfe7acb15295faff9a570eddfb007770dd15631334fe26a2fdad550a2928162b2e739dc70b1f8649217bb455940132a7c29adce0acb12293cf1cae06590d1715d81c30887d574245164a4ae6aee26b66c2d67cbb67b0d45e797c303fcc703cb9827a7508170286b34507d6007b656eb026b8bf6c35c66f3a40613a6970a4c1ad3be86e074fb93f2f62b61e1d71a1a761c203a19691d88344da9c651f1ad99f84486809bf5d3139ddb588a6cf91f767d300e17676ce11eaf01bb0817e86c3028135848ac4580e2bb9787eab7b3c7784a76d4c0a28cb87965a40ca9b3c21f199f79b15d1d9483e4897f980af5caefe342809fadd71b261425ec7261be3ac87bef5ff5ff7c609ba943d7294635b0b38d5d393b0c553faf4ae04c5c87a959519ea2003d2e70831fb1d64e287a20680a281d1413260f7358e3e252c8aa81599da3f9f0be5bafdc30766e4a43d097edfa1058869f0222c4df8f6e6d55a6bac6bf5734a8de2fe30b70e75aedce95baa21cc140388b553afaac7a806822c57b6701be5851072dbc2bd70d6b55734bec358aab8ec5a4576e06909934bb77eb3c47d4a2213842e9688dff0f6f1ce0d8700f51ce3ff79bb17cb93b42481b81af36c8547a815c122ff3866ca18075ecc9f5b511d97cf7283a5ee2a0281e6627a092263088a3b2c7947da922f60bb25b390bcb78b5245609b0854d85e2848ddc91645cb0374d672371e35200b31003ff1dc58398eb0774a7f26259060767d11180bb0804c984a1f80cea43eb358366b1d0a692c58a46c459d12767caf9d2ea5a5ba5e5ecba85d8c49619c74e2bf285bd1239d0414e174acab3658aadf0466063dedea9ea4241ac391d5946fcb56650ecdb1a345ca515aa3d22302288182e9aa9da607a9e544e4a24b893b82c4a28867d5cbb166b7bd767760ac093577a398b967574b7348709c12bcb6414f529c8200dfb72acf4f4cbf6857fb9ddfb3fa6f1edfc8dcc6ae900a85e20f895c76ccdd3c6d4a01adb8bacd1a1a73818b1e326f55e2cc0254eb848e07ebb64b993981667810681ddc03b07c13fba51575547bf3b51cc8980de173ffe1422d0f543523bed82b9eef8a42b2131df835ebf8e984297ba86a28e261cd62b19c295fa45f104053080947c974a4c5f8a0a76d5e5824dc3332f1556c3b602bc70d9380da67c0c24670ccea2c8c65be465aa2854c6b7ade97217e17ba1b689325ab7ac302c2790771b1a5ca1f5819464aea9984baae6c4d211c41fd855f2f9c1f41d5c5c559ac4e778288c6a222ca60d3065759d83eb6555e0a464576478606388c09683e454c67ce258c32b9c780b8ed2f705a4ec977b143f3d13f2058296346c462fad40029d36720194e4ec8ee8311c6782a012e7fb4ab9f29fe088758fcc4d63947db3d6be3ef943320b9458da8671796d9cc810d5fc2be92a51d0a2be35d4169a9108df6745beb5632e114a479617f8fcbd76e1851a04eb7f0257279f6ca9493bc0d1f3b6e28d49d979ed61575faa39b944a6e5772594e90f6b2fb3d9796e270844014636fb1b30bab4acd210893a4a1d022e490a8cf47519dc665996b6885dfca4aebb8c7a93efce12f553ffea5a8a7e513a412c59ec9a813949802f23c092851872811069731c7e7c2aaffc5f5e6041bb68f7b95f37cc09acfcca14e3ce28168d70c4bc7fc6df16bf757853d896c166095aa80ffbd13a360f06a79bf4829034bf7e20c26d398f964019395a88a4577427da88c5c2c0e96af13cf0ec04fcc352639e263de3795ef8bf9a57921539a9cbe99e67caef64437f1ad6ce14a6829e2b161f41a2f8f2f5597b5f18eb5b697ba62de4ef54fff7f0eff1ba7547f813040504661c4808a417f8d7a780e5ef7c45fe0dc9b8d5d8bfcdd8e85b5fc62dbfad14dd368019cd3c15ebe55b50e65a5d15d4afbe37af415ae48a03ac7aedda5a3ff9f1e2af06ab052366cefa25476a2cb041328b9479fc70a4e77cd712abd1934c0d2c6eab67cb1dcd5f0027fecbdee07832d582aeeada3a8b323803970a2c26480cc02a649f484fa2791d54dcbd9b52a1606ef38ac78a4ae34b805c80ed9084c1538bd572fa256098f815542e8e316704a525cce66e25a0f61e82dc6827150243e0a6b06ef2dd70d5daf122e0bb6eee0dd25a425a0005e4d59c24e1f73c0431375e0351f79e422a5e886a8aeb93081791d3b5bbd90370c1334c3e3e7bfd2e732e65f7e2c8e0a480554fbea18ed61c2a4c0ef958291f6067531f58601d5694e222a4522b7c3ed7e5b2b199a86d5adafdc716a2d5f398b4522a83d43d8351386dade8784691d903784d8c1ee9605e2cae19f953683f0ec47da8608c62e92aaeec66c8ca48d0039e37c4c083a493c4e39ef35853a376aabfcc5754ca40025eed4d906edc5e3f232d0f72b9f695aea047e0db511438efb61102813b834a04d7964e32946cede43c789b6fc34ce469d1360d659ef9a2e5eb7dd1b160ea85fabb283cd1bc46e690a161147dbfbe4849c625d1ca65aa02771527e8240af3ad3d15f5dc143e9f2509bdb0478aa90e95b9b6670fadb215b1e7b9aeae6666d5eac2b16cb4906bafe5caffc7b1419ae0d0c96dfd61a4ee4183f22ac78d466102f793fe286acd410ba4866220dfaf1fadb5f2bc79f73ef04b07952b7da065a901a55bdfa6b300e0dc965d242512047f21efe5302af9a96f6e902cbbf96e0a8de9bab4ee9222c85fc252216eb15e46ec95db522e6709b190d7a402709ab6bbb0b95db7f4b24fc2b9d1a4d3968f22c2056fdab20d2af07fce9eceb8aacd21580f6548e90f38fedf9d6254d7fd95eafab3a5651e4931bfbe7f873274dbe17014caf1d4670ae67778b72bca0dc70dc814d8ef372ac2841b59616de8486815e8c9746ee394510a6ec8d52ac5b3435a954541a296414cffa5ec3000a558c2cd865889f5f030359d5b928ff04238b1b69638afe544fd2d0096c38315469055c1390a054d3d4a371523999f8381fd8c2cb277a227b1da573e53bfa2bf645dbdbf25c5a3432ed2a9e5743a063a6dee1cd14764ed120f81055a2d82574c44b778b139b7dea1dc268393d8af60fb1498f501187b647bef944c8620486f8f6d2ea6145d30750fbbddcdc49aacd2c7b4720b23952985f066a5d06dedd1494f95e72f806d158dae7cd508d6ec7e2c0a0495b7b23cfea346c4d4a145d373f288871292ed752377a7a2903d623f0f2310aaf2acf18d4ec6397bc3727a5515d4aa2ab5cedf134b9af598f44a47992aa33cb23286d40c4a7d2dd82a2eedecea94cf19185c776614bfa7ef97ca16bb188e50ab816b1bc6766ff450004c93f66250d92f3360a619241d1d60bc0441a9b0824621ac8a015a8cff54e4e979e5065089cb07c3d90c6df3880f8634544f189b9d66ebeb5b9da787d2d1007663de0e809d07f5d74334f717789183b17424d0acb49fafd869e124907c697fb7f6b97d577041bc061ff85d1ee947011a625df20fbda7f1a940ef3b55b9731a221f890caf5791c4be1346598af7ffd17257400ec50d5a255c94cfbebad542607df9c3e28a354bd7d03c9dca43a902a94ef2e60f486f21293cc284833ee37552855a78ef0a27f7eb159ba9e8f1d723af5bd2b1ccd20e3bf506376dda7ed5b5650e27646e81f0753daefa3987d665ee29964e0ed789e3a6582bb9ac12ac7914f48583df724d73d16b44688a53d270b2c1613a57e4caca835ad7bb5d0f6370a24a7c16939e60fe8574572d8ebf21c61e160fcf8b37a619a6406203bb07162de53d044a1a2ad7214de4088a124960afbd29297df272a42593536e71e8df13726be3278b90e2861d7dc13d3e9d1e6c7df8c5946730b12cc634ef1cecba707d0b4bfc6a56499616929cb9c957b834744c3f2c67e7273e3face7730f593d08c7a13957f121140e43c8c0a2595cccb363a6653b2e191d565f0ee477a259e4a0af051e680f56f953373bca6f5ea4342473d62053b482437d4fd328f30372bb20123b1e76dcb18081fe815afdd0ab5e73eb255a6db18265352c432c12edc5937e43dd8dc0e943d9e5febb7c6ff1dfdad1438d3697771e55672961a604e6a73b2ef5c7f55bf4166a8256a2adb7d2265a7618f8f8f8a94f74dc26a007310ccdff4ebc84165fe8fbb31f4d1bad45a364c5841cd51731e9afc50814fc7de9bf35758da637daed28591a32a5f92d23af5747362d6c797e8a67cdb70abf33c2c459a1006752c4496aa8b152c34fafac9b26a674fb4a8f7e7ac113994b5b093376f2a6d9dcffee17d57d5cd187bcbb0e5ffd526dbfb1c64fe47a1019283d4180925ff2ae8ffb44d71d96cf349bf9f3cf6e9b20d614839dab253dc5e3e27d2729551699f7390a049cc306e1ce876928b600586df137d35f4bc9c30d69ad6ae2f857337cd570f7ede79a9b58d5346d045d094e645cf3ec770089f2cfaf84b113494177f4160f2ef5e84a3c1b92ba52125f7dfe1ff31ecafe8627ba44bebb2365d16213a45ddf6fa3f816394fedb4593a5266f52e4233e11356e07beec33ef85b1a611f525edd1977121c5979954ca39221a7385c8f5570272b820b81228bc85b8d8d72baca73faefecaad4cd9ffbea14f20ae83d7a537c96574360d1dce11957d85820f1884546364a61f4939747d4f1e8be39c8dfc6b2b48d44fee3d503d6599229b1af82b4b0ace53e9d97a386a0797d85818aab1030293b92bef9752e091d86ce3d32b0679f41d2cd10aefb4bc3e2aee12c1992f6c3e007235ce03592875ada20cbfd8f28bedb0def4f54f620240ea68f4407f8e361bbd2b24d2d6401b1cb83887d56552b5b9daf592389a14ff02402ba04a408f0871c174ed990cb27794ff9a305281c762c1ce72927c2429b2e625d2ff27df3c33ec3ee469f899af6413050fbb6e577a829a9e8cd07eb5528f497b6ea96aa196694a85e9902cfd05a4e1bd8d3e3b768184f938659474e6d7da9924f98249c16bf8fee294cba43d8d904c224c3a5f17ae10b0c0177ade3074d10432dae4a0cab72cb7e8481c353b8ac402635778c7f1f4f3e4dc10ad284d838a65e114108443ae0df348110af509ed8f7779649720d85bbeb5ecbecda092b26cd76abdbd7a6e12774d2ef505799857a22227d7ebf8eb9ce309407a4edf5f69d849352fb64a083a8c23cabe1999b262edbefa98a170b2124842207e57b8442f5fe6eabac791abc6b17dd90c062e1fb38c63b7cb5522cdd78b73a5fe2deb3db44358763ad5011d227250b124921f14f3c4e3c8366fc3a67efd227b292044fcc1af2c38c40ac9c8b6d8a233b2b3ffad86abb29b7f1f92d17a3f9967875935430c7fa3ea8017ffe8f02dd9f69039908ba4c40728b977dcd1b0f9b99d36d4d4cfcf15b509a66c1d14c9f1c51d2c4656fea6e9ece90ed93174aa5a8bbb1c840383f96029a228a6ee11f11b4986a09347eb3642d36985c413316fc92c3a882c01553ab512c6d0d915027536c886e12e0f0657ccf91f6073781b6b5b477131157a5869e0547212b86be00ac8ed9858b69fbee4584e987cdff4d02c8d4a437471a0fa9ab46f140108073e894e68027a40c78cbabc13373bd5cd9f5334a2a29b6d342cbd0e806bc8f264f571a7d14f94c368c4023f8f003dcbd78e4cc23f4dec8ff6e314ca3a3da5239b249cbedd5b6e32679a8ed70c85a229736cfacb856bdcf0853e00f2c0dd3f7b942c0e994691a0ae417310f6c8d7c696d3910b3e4166c74de8da9f012cc3f9df8ac337c0dc2b263881bc6160495e1e33650bcc11f6560f2fa37756fbfcb36935f3d869252d5918c040feeba60220c47eb68046aa8dd6f975dead094f05a18541aa9ac5e563c559bd8617c8b6ca3b4f4d93731851c4a9bfa585937bc2769750a1bb27d23c499d4521e01b30959839a491fe8bb3fbc7a684d2607865fec8f68c0900720976b05a9644b8cb68aba9e5379a58b23cc88c1e63c7b032b9c171f3c06d60d8f08739be48eb5713f7b790a9977f3cfc75a6c59f75f4c4085c2300448c6fc1daa0287b85e00095e2d78c7616cb1a2416cda071ff60a59097c9f57b1ee5b80f9e462ea88ce9692391c3d4448d55d41fe908256b257c1038b4c4a8b9911c2a2101673c1f3c3c6e5a8e7750747a2fafb62d4668f9c0bfe632884ed643732ae1448f80a51b527be8b97f345776aa369e0c3b3644eb3cf3239a2dad46e4821136fb3158c2440be6e5acd9eccfb780a7a5fb9075d9ed35d0edf790b40a4c4c3f71d25e585088f3b3b707c12bfa2fa42bb1e288316bf875471cf9f8fe61f89429481744c3ffcdb7563316efc67c7db7e49d0587da78d46adde0f32657a5ed659949575003c9727367e7224b89d26eb83dc7311b6c20736a497c31ab1999b33e096527700a8f67331d879b5103ac42d996f434e174b9aef0db38b6096756cb21c5770e7071ebcfc48dc2e0f737c21884916121279d5e11ec6d72b9c3de950a3c3c8b348dfcc06c597dbe9c82923f571f744592b025dcbaf4f4df38de444df28b82ae9a327a3f565f8b581dd18c0455f2109172ad2337c66e0a80ef1190dd98b81a3cf1004ff8a75b9135ccbfd0dccb0aaa65ae78f775956cc35866149d77105d80705f53dee754a634eefc03227e1ec8efa4b35f6401a34c4015c093bc0de813754d2d1d1bc23a642fb32b147c734ee5ca22d15bcdf06115c83b63ef7469a84ba91b45badb794e90207feb17d211dd7940379cd212997e57df8f7713d5734590296464030fed1f5f5f38faa4ac1cfdab4f23b052c96d97abf8a3a7080a0878d1aae7684eebe35c4783b1c6015580f4081aba977db08d13016fdb20775ac5539adf1afac1e8050f669a76631c6990e810f3d444a9333089d35a49e3df3fefc871417b314df85e49f4c59c7436d20acb5039313d697ad8ba3eaa542740e2b5849d0a6db9bc3fc39df338acf02ff700e0b8c6d83b182b1d3afec2975a42db33ae3ee6e8a5fe147703c25e7cc7d58764645c2ca1e252665161dc9a2a4f82ae2087d964f8b4b16dd458ba5ff855eafbea67757c76bb54cc3ff0e765257afb647a49b14adf4563ebeb96f3cdf1853f22a1503cb438c512d2fc80aecd54fc980943218305189c05325a261dda244a72fe9c8ea6fa814fbc35b6389b8863274d0080187ab0c23823529c3063bcb3d9678319a043f180581063b49e237e7c046d85b851760156b932f215a76f7426f4d4ec4ac537d9cf072a0d1ea7901db01e42fd983a5678b689d059fec3cac3df4efa0a200041b9c63e855fde805c24e56bef26448824270f73cb82e0222e0f3375674a54bec79f9f026e55fc8e5dae94ed19e05ae9e34b12e37792e3771cf6619894250b99066005711f9478fb302a41d014b63895cac0002565528411f4916323f125255b5fe527f2ebef53d799f668cdee9b3f5ed2c9ee8d0de4ef088980b3bd7d9bd301b4f1a7a7a251a39edf1de9aab07a2f61055e4dbae2d6744dac8722fcf3d689a81bfb805493931f3af18683950d0d27ef9afcd1255c2e701b1faa2904f0d28f04e037ebb912527e7c8e629e9d56b188a09e491b391bf2dfb1cbac1ce7d6f242b96b041c2a69f1e0bef065f8482eaf5cbdc49f96a0065a45093092f7cb5b4aae5406903eea8962057d729a112f71d31489a7e239908cfaeca8be0336345bdf0506c379c20b8b6b59189187c2e0c06fbff49dc840b5d3f421fa23646f9b33104a6d679b30177758d38ce854256134bf49c36d98a3271d0a044a4d33d8b899c51396cc66bea734a8a6188da56ec43521757019593f219e58417240b24a33e046dc1f8a74087e509e86ebdd62d71f6b8b4dd9e5d0c5829041a82f90c7f215d3b5db0226df931ea69aab40bdd001560a3074d08aae9dc4e9917c145c91654e05683df3eda4ca00f0a6645a0cb143382bc97063505b6899870d96d5188e4ff0eceaa481131e1ab51740bd1a30063aacd2dfb3107ef655c1fc8b2cf218adbe915f187b69c6366131e648a5f42e60a3e45b309aaf53a95b2c9343b95a890aece6d97582f82a585018a4c09910d1627b3fec243bf72edf43a4a5ca3363f74a6151b50d76a624a450d214279d98a2f55cdccf5de1c9b53a58bea89a730d540c452f7277b0fda1a8bc7079fb595a9e9fcaeeab5a87e1e7ac723421dc87434251d3bd5e2ee77f13f59d137880ad6ec8fc537313457fb87f2bd1ae2d323025eecc5a59a72df76a73ffa460912b21731dee88349148b51dcf2abfd2140230797ce2af971fb691be1a5e0fd6ae135a6a0ccaa7f7afe2c4befc1e1624e5b3a62bc807015721d3fffc6847133d7fb75ef221e2275bc051f0c0e7e4b1d60825dec583cc8f4cfdcd9309ea1ec90059950499b2da9ea4d6dc2d9d06e5f33681cbed1813dbb5ee1b62cf36e7f8f04eed8e04c75e219a0f5194d0a3ffd8f0d3b6757655deba7b852c0c29f4e45aee766af0ef88991699ae682224d1e32e42e86c3fcd4f31fe94dec00af8af6925b8e7bf4fbe4e12b23d24923d40143a3f216cab51abdae7a3599f891305086e3df4c677daba9221d4bf038344e6ad7f89a8f24a4c18eba723069fca7c49b5561b937b49a112f8e347d829bf26e0073a6a17bd117545085b57daa26a00b2aa3cf75fc3acc62b85f8bb828573ad2a3ec1f2a79ced4ad51203768dd02de0bed56e952e656d71af90a181c3cc3b1c42a4081f10c644fb952331670e66562e9bbfa688c49d0861ae243e9ab8f4e7817e3e74f5d6e07a76ad9a867cb126b57b9f95bf007c89a4db9ee851394561d1d7a88919425c208b47bcd00d0af9f2b2e985bb9e2e2cb904853f54ac8887a50d8fd2db6dd7552cac8effcdc03ad4991567b8d647c143538895e0d2c65b70206d59492de033bc51a9fbb8927a0e7c477720c181fded7e24df30c9c4f77e3818d670fec8b72180f3d6fd9af083c9830e8924155f8f464336c2f0e08058d04010106234ea5b4fda3ca584870e620e82696cef30b7ef127cea4dc10f71eaef18c8f3795261d5f15328068a1aac0f0d91bf3f08baf272498bf70ad7ecbcc69cd544781977c7466eb6b8f324c3a158481df71ba75b9a219d1c6a1a650cc97ef62a893800ca21a94d900a96dc0b77525323cfa284503640cb1a44b09b7d0ecab475edee403743eee1cc5e9a7ff64ca23c813edccfa80e9799ac2910d93464b801e949a5f05950b1044b539daa687f3e59d11d0f7d53468db53d54044b4e3e8ad6f48025d8d7f977b777e31be5cbc9c47c433f172a16ca96a4a9af9e521c3515d12ef5fa5ac915b8f9bdb1ff4d969e9dce195ad3d06ed98ef0935add6c9706f2dc39f4baef32873f78ee0c6c2c476a72ff4e56432ceb85b0f65e653c71a35e858deb737ec6d9f538dcee3abd9f07bc39ca7b73112777d0b3617a6c0232d558d94527c9e7f4a4a2f629a82655330ca1f1fd57cfcf919c7b14d5fc14fac267456f0970eeb3a8020b53a3ff93659af4d5ea4b2ba596ca47c7b465404eaa423bf335baf0a51378a06eb380ccf96050abbcf25cb26f8b9df4ef14cc739b9f273c5033cf75a1f71bb36ddd9e443aafda7cde1b74fc782676b196fc1e760e46a390bf1143e4ade0f5fab991079fb352002a6af1771c27861143ac6e7c03e5306edc3a249108075fa7a7d0c7d731f99e3ca1ab69bfd4d3d6b9ce9234a2463ef0859d49864b58576ebb0e36b99f213165e84f221eaceb1d4567169e46740ff11f0774256ba67a4f5917551924e56ec3914bae07af6d5144be71cb737e583e164d15fe3902bbd54ac768650dc8521dfd13cff5dcafd5b461dd9d581ba4fd6d50e93fc08c6d262f87ad860178b9926b03d97a2789579722866e17bf42596b5d25078c2ed28ec19eaea188ff2de12468390654ecc4abf87732b4e43086daea0a3f9dd0eb46a7c98ef06addf87678637f947dfd1566c2716d949ec08782c39b70f7d5fb1c4f95dab60babf84eb44b3610b21da794a71d524a93c231afc6f3e7db09b5f30227ff055286d56c19159e6810c8272c45df4f0d4a1c211e8311e0ba79b838002470df5d6ceeb96bf5040113dd4bceae7d83aa864cba9769f6f2cb24d8e60764dbe6d4bc5e5c3afe18eab57a2248da9a527b0bdcd11c270424c5dc2f141706b5c7f7a15f7cdd10f9e5a5768dcfa90e31ee09be4720d0dd3d4ca5e2decfc929eeea149e7a9c615dba5ab925a3a08931b1d56ce20f23adb9e5dbfc78dcaced52b72a1da2afa981cb738fe2217df9553b185dfb4f63386a3020efe394ee5c08d8dc2d3a8f35144ada03411636f5298467de5ea1d1080b69ca7d276f43ebfa1982400e0576430a068364a6e7a0767cb44e507a0038cd30b2297c6b3e78344a19b729fbdc699929abe2d2e99098db61cc37f56aa2b5a372e46ef11f99d9b8b3287c53de3cb490040fe759444c6c4e29e3626952538f8e2aed9628e672ed43fe8cde3b09f6f2098130cc354499a4e40ec55207466bc08693394213418ef3165cca9ef431e8d569afb13b5016c853c3ea1ff2a65900a4cc42406e1a0b21aa8bfc904169646d563f7f79b68dc1426fed93e04a971f3e969607ca569490331e475972021526c29caec8934077d277d7d586a40fadd5615b7202ccf7fd5cc9dfa62acbca53684b1f47e206a57a600f90b53746dfe3a43fd46f8984372d56741321a0a55ff9be71e7e16b8ca22b1e5b64d0ac15dc38ec720e4bbf59a37c408012a78f7a7cc82716ac2e326b9855b112d5cf22d854ec15777e5918ceb95eb11d3c61f7c4adf5c32a4b01cecf243d4995c6b3f55cf3d4e2e23b511612bb6666ef3802b2b41dc92a05352edc5616d23fe8143b29d5cf191be80bc2199a427f69ad9bb7038be3738ff9fc2b55b5841bdbfdf6642fa0c94ae954576eb43d79a13da3a9409f0ff1b21bffdbd9be10aed2a2fe699e323708b39e4271fcd6f844342fb9424ddfb88b2a7fdeef572a59ea62b83dd664990ad5227f751fbd628f49486ea14062e2c2f669c0458a5cded2d6670fef5ba58d80f579b05c3def7441565718646462335486f0211a968dcdc082ec0105b6e2980f0d6def425c978ff8e6241c351e5cbd97b2d268d601baad714f30398b8b1f604fa052e072f5c4e9941fcbcbc045b788b62cf0d935244f005fb42ec3f43abc93a42fc92c46b66e83fb90ad0fae99132d43bcd80e9270ce3a8e444634e16252f4dead50903a4bf238844be7a28f0ce91489111c40a051adb3019462e71d6774041696d64a41e7e40fe993fec9fb97528aca59e2812831535f919b0c2160c0428de0b68dc44c2f2f155878d1cd98d694403a02638eb4fc6d6b2d873cb76bc86ad4ec0e33c80a834c2934af84445917a9cf2ff9067e9b368e9312c5056b2b0b825b8ee81308cccd28c23201aabe7f624be5173436d6b97787763fe5f4f7ceae59b0988a34f7c818825c61279daf3d00ce0bf8573c6ef883e4838945d190568c04c95feb4bab57e96f26439f311d9faec5454fc304050d835989f0d006ecab7e6f7c4d5148a1b56bce7dbb0bb2d7ce70cafbc342db5662fd2d5e37968b69311feb37bf58388c18943ca22aa9b3ebfbf1513d6a2831475b5ed0b92ede60e95ad6cde5f43ddb7edcdf350ad941afbf57c3437dbc9504cf74f425321f11c0bf7105c99e3de7e1efa2c3bfe8f8ee44b34ad3e2a66856d431922ca2876015e7311fcfc2d4aa911ee06048f0b90b8fc43500498a2b51a86784cfb5086e66e7fc5e0e1526207385a5733e93e70857852746c88a7d91e2346b42283cf7ee4e8e177ea778280e46cdf208108e4b0d1f9e3441ff558c0f43f6bbe5fad814954948051e83af7fa7ca82e57e9b467087be42cdc62e00d7b53df3492f2f7f4be14b1ee47cf6e32d99a8b73ec762a6adf0ee3c8de766417cf0fd09d733cfe47815b78f7dce3ffc4f1284ef7b38d56ac86db2b507d93c95954a6c181911a76f29861ad389956197c6e9be9c4f0f40dc37596c802fb533ab04a715c74bf2fd2fa833604c21714d9b387b85bba64f310761cea7d8644c473bca3fe9a5764b4712c3787175525fe8f294c9f9f984ce97c7c200cf485856e7bcffc0cd8e42a9ac9daec8faa3ad741b27de20f3afbf00a768afa29d9520ec2d784a579f59f6b7ce0b4f94c8104749c29d6441855acad9654aeb7678f0d0354337a5288c04626ec0199cad3ee6f6082bba09c7cc83f90da68defe121ff2252c676216631624980be98f56588277ec46cb5a5cf28589cd51ace1c8b5886da1c3db907f983dbbc0fa095fba0e151c3a962bbcc6e5fbbb61225880c02a4523fc04c66e635d74e4aa473539300e01520bff22a5e028074057f430445c07f6f34ae727cf0cfcc87e10a31cfa24cca493bac7bca66cde4ed282a7f8785cb011bb48f4f34ec5a4125f6d230be22bfa575ff2bded6651cde18f131790eb4ba1e0f896292e690d5f2b83a193e8602b27dc283a659bf2c15fdcccf922a8cc35087b953bc4f7d9946d54140c3e40ab9a2b5007e22a0d74c46887d0ad2b51df17d1d940c9c6dc1f7d7cbef6dd097c90fc16a51800c7a4a9dfd1e22b294dad896693be48fa7b3528fb9f70b99b514ef364697114edfaf1eaab63b084c6e0e040d1d35ccf86888b8a435e4bf1cdf06516b38bb807e27afdbde7f68b150a81e89a2b4f49b7ce5276df5c4554fd04402db8b976939736cee9ab33ee98bcc94ca3565ddc25bda3fe98a77a8434673308467bc30589af85826d65ab1cd3d250041a7473f26f16f2053f39f8ca2da28b324b6cbcc71179e5036efcf3b3f2b470c4bbd9ae8b289d0bbeea6d1476870cfcb745c77d53b82adc0cf32aa0d183520f09e48605a0b032386da6514e7618c9dde3fb66029edf0820e888b5c3a4572b477e370c026f37b0c9afd918dee0e0368fb268682a08952cdaa91637d709d9ae848e1e583edf965d042caa01264638206b85b0ee0ac8225f33f24120618898f6bc0da58e90ea73fad9338b95d654ccf8b6896298e66cf65893d9cea1b86ab4a732ddef3ae1793df5415754112d5474f0a9186db190f2bba7cddda83499c5cbcfb94396a1e36019c2ad8ae3069275aeb35ecf862882a217cd7fbb90a096fa1f2e8cba1f41186221a41141ccbbf64c5173b4fef969576067751c91daefe59a81b38e34a801c430c300cbbcf7b2a3c252254f2d94a282c0b596177c9ebab67615d5095561ebfe5f1062a349ff1dc375361bcb5314e3d48a61f9655245aa96a85090d8271eb75978509ab53cafa3a8773bd65eb31e7999907c06ee5d0e26986f0a63519f9b75fc4cc93dbed130088d66b0f687fe4fe56324cbb3620549ea18c4eb17e0e3c9a47106499408f898527553484558a187de38e103cc141d1fc83c2006f9b2845c2ba508419263cfb692692eb5a30c65f44c80213e4bd818b229c0be34eddaec76891be06ee95ff7e2db205b6afb824cd891e935c98e17b1108ac73778a34e373ec688b7b1b5084677140a8144fa159a8e5e63ea04c2aabf5bc00b03f3ccaf5ff9b41e6315e01f7399b295b331e42594e690f724986c9c82dacfb6233912f189c6e371b510775a1ac9a5db28833805c5a3b9545fb0050633f783e22a64c02d65ccd0021ca16521dd9c42127e6f633b0f0717e9184c90f332b4cf887c8de5b448f14fe351b2cc850d1d5a069ca844b20ab108eec1727623ece8a90d6189c55a91140ffba09d7613a24998b778705365e302f1f6fce78162cfa5afe2ee384ab14002fc0d4e2a29e0bd97d9069fda4407bb729a0cc6af70ccd37f97db9262a4cfb4219385874850318417d4ec938d97dd3153e94fe33c7a396fc54152786567e22545aecca2a9d607b2b7b6a49d53c4cefe4ddd9cb2742104202f78987542fdd5976395644c9cf8ea040ba34539a517a7edf15f61f643d627eece27b333229f489ae1801fe26ef0ab317b00a986aee40e0e51ee8e976e22c09daf11534a83c1c22de37429940c52f05106135b9b743047b0c28a380f5504b4824e8c77de331e85f8e1f7684249113baf126647c85f7fc02481344585800b930d43cbfd07908c41d98c0d09469aff2633ad4124410a41f55e447c705443151b0720b5d8c38cb5c0024d165bb3522bd1850399d503ba56e0d581e5b194858dd5fee93ccd3acb1c518d37fe822b42e28ef7ae6fbc4fa63734125d5eef48e65823ba15ccb7263588e39d2b156645e69abaa80245e709f499b6df70c47088f6547c70c620eda685b81171d50e6a1610bb1812b52284436cbf0d713aafe07d6ebd173f9b691b0a4bb74a663062670b2fa497a63975a3a358aedb881de8f9e87fc93f9b74a9b38337d88f1ba06422c3f914ad29248ef4d3118dcefb4e8632b884192a0b9540f2376f0afaae072091642063852b2507e5ef80fd3004f20abf0419b3868dac1146d58fd342c231446129398841cc8ca7eeb4b59ab32f77928c7a74534ae64bb50950d3563e9da683260ff645bfbd99d22f8b298901f2c2e18c3b4fae6babca2285ba7ae81c952bac9d465810f36c2c5690e7685de400f8e52375ec836add4ef388ea2e46a367f4b9691f099013587e732d9b84dcbdc49aa7f0375168a45cdae835920bba28aa62afc76f66ae972033c78320c67e73c5bfaf49dec6980a66b27f047fa4133c0145a2a042105e3dd4593aa74e51ecedd0cc3a9d00fd75b15570bde412c7a22c09e06fccf2cd969b8522f9fb7eee636967e8eb35ca2bf7c171d8f7ebb909cdf2c675b65a1bc5ae886e3ca76ed2def8f04063b4cf5db571f0ccced544d6bf66b47ec3209b6079e628f642914a87edee2f01e5d1841d4ab0fe8fe3078d734049261e86912a5420cf0d98ebbdbcc92605f22110faf89397eb6e0b572decd7149303a9e65054841a954603832e929585953f867a672b6131ea4f3ab06c7d111df1e3222fa9f528b5100124d3275b25dce8d70e1beb6e25b8577de7664758edcf01352e889e75daf8a805aa181d7cee848156fc8593f2904b6b6f4dc7009ea38aa76c6235529a9bb36745af0649160cab80e7f6e4ac43a39619596662659c22685f2bac0485c1b76ede9be6ff22f0e3e8c8e41abdb5a992bb70a86d2c568fbc1ff96b85ff3e230745e0cd93725d628292cfa707110d82fe575a14eefdb7e3821ac847e25406f76023bac4c8b5fbe264a47c6e5ed2639022b403a1bee487b0138d4f0d36a8076dd823b40f106cfa0f3117a125dd64c9bfe4b64e7e4469288483fb52090fa28c5337c03505790f541776db46bfe837c6b1fb86981065f49247a2ec691e40ab3a58ce92a703dd9476be102c6a925e35ab54dc1404db8585b61bd0c80d1b0b51607cc90f6db8932105e0a6449140ee3535d2e7a7e382b2a35139978c44118f422abd90b105c849f43cad37199b5b674294c400ddaa5d467b268640d644e9a74bacb3213d83fc7c97ab251b419276a407753dfc19b21ee8360c56017580445abcc3f3c924f06d85d33b1ca0284bfce13f369d69a447158aac5c629cc640cdb7fb9f233c744f2c7a58d01f5c136a60a56deededd7f8b7ee48d359b6062075d4bf4b6ce85755a8b91228bb5db6c1438be2786a07c6a83ce7330de28d77c584962788071196bb3878e4b072d5de43668572604d70d7d8b84a9b800922a5a36b1c82d5efe361655a379a61e4d1e8dfe259050b4b6b937e6d98605dc9375c594bde13a240a147741343f15c3f739c6ebc4b74816db8bae06703a5520ebd39fb7390f8ebc939878288308e1c197ad25c641b7e4f9a392e344dbeda37a4379c09b8caf46bff5a77da4524d6b5254d8593dc6b1dad54ee3e6a60169af661821c9206e82405626a47190e007793a21370a99a4887880c8c8d3d2c47c7ca1cb9953ee29998b37691b15fa4616c1854850fe167091ba44076a1580605a62e40d7661ea6cb3a77bc30d8ea884d6c3f70dc44fcfe9a259fcaac8d60dcf6170182874aff394fb0380f87849894b968128c24f0d52703f17574386f904ddd90eeda734e57e54fa6b0752e58361ea6b73f84899a708af53eecf9d8c471f3a8e7fece34a3c307150d4d9297617cb3e50c0318b2ddb427b1f038b09cd7c234df9f1495754ee76d64c16d28a8e325b804424c1beef4292caee4299af6586abbad2363b6778676de5cf2f5dcbe1b0a6324a7a2c278021c68d790b929651589403a453d2f6cd40883a3e673c2c99cfd373078b30ca8baf6c2c4551a67e974c8ba9fbe771e4828bf628118c6c5162edd2912ef57bec156daf1e25a005908d5123d2634ed03c9c4a1669ee3e4a48ebaef9a9d9b13bfc87af1487ba973aaaba60e02608b6d76c82dfc816417e3d5973cf3dfe6e625cca69fc9934f1609a86714c59e72ee3b29b13616ac9844aa4bc6c4c2a6eae193374cf466e12f040c312b2b46a5fbf4d73e89b19423984b958ef2c0ee33e2d9ca7cb3d2818f4bd4c208316d9b3c2f58adc5ec22fde95473b260d86b33368bbb63178fb14b548dc330f87f9c3b8678a1dabcc4ecca175a5451a809050492e82319def7b07573a41335ada9499a07fbd062d232210f12f1e21b6b37032ea8d52a8aece6a6da06ece5ad4d00ef8bc767032bbb22f1a2c0898646988b70b923ed8751a60933ea673365afc704c1815a8e40      </script>      <div class="hbe hbe-content">        <div class="hbe hbe-input hbe-input-default">          <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">          <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">            <span class="hbe hbe-input-label-content hbe-input-label-content-default" data-content="联系站长以查看密码">联系站长以查看密码</span>          </label>        </div>        <button class="hbe hbe-confirm"></button>      </div>    </div>    ]]></content>
    
    
    <summary type="html">联系站长以查看密码</summary>
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-07-杂谈-复杂异构系统监控与可视化项目设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/51477.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/51477.html</id>
    <published>2025-12-07T13:09:33.000Z</published>
    <updated>2025-12-27T18:41:58.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复杂异构系统监控与可视化项目设计"><a href="#复杂异构系统监控与可视化项目设计" class="headerlink" title="复杂异构系统监控与可视化项目设计"></a><strong>复杂异构系统监控与可视化</strong>项目设计</h2><h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><p>现在需要设计一个系统，使用 py 的 fastapi 作为后端</p><p>目前有一个使用 Docker Compose 编排的复杂容器化环境，基于 SeedEmu（SEED Internet Emulator）框架构建。该框架专用于模拟大规模互联网基础设施，常用于网络安全研究、教育和实验，特别是区块链网络的安全性测试。<br>此 docker-compose.yml 定义了一个模拟的互联网环境，其中部署了一个完整的 Ethereum Proof-of-Stake (PoS) 区块链网络，分布在多个自治系统（Autonomous Systems, AS）中，并通过互联网交换点（Internet Exchange Points, IXP）和路由器实现互联。该环境的主要目的是模拟真实互联网拓扑下的区块链网络行为，支持研究区块链在复杂网络环境下的安全性、性能、攻击与防御（如 Eclipse 攻击、分区攻击、路由攻击等），并提供可视化监控、数据采集和分析工具。</p><p>主要组件与功能有：数据库与辅助服务，包括用于存储区块链监控数据的 postgresql（数据库名为 ethereum_monitor），作为缓存或消息队列的 redis，以及用于存储和分析网络拓扑、区块链节点关系等复杂关系数据的图数据库 neo4j。</p><p>Ethereum 区块链网络在 AS 101–112（共 12 个自治系统）中部署了大量 Ethereum PoS 节点。每个 AS 内部包含 3 个本地网络（inet0、inet1、inet2），每个网络内有 3 个 Ethereum 节点（共 9 个节点/AS）。总计约 108 个 Ethereum validator/miner 节点（节点 ID 从 2 到 108），加上一个 BootNode 和 BeaconSetup 节点。所有节点运行在自定义的链上（chain_id: 1337, chain_name: posCurrentEnhancedNet）。部分节点（如 AS101 的 host0）暴露了 JSON-RPC (8545)、WebSocket (8546) 和 Web 界面 (8000) 端口，便于外部交互。</p><p>网络路由基础设施基于 SeedEmu，AS 2 作为一个骨干/中转 AS，包含四个边界路由器（r51–r54），通过点对点链路（net_2_net_51_52 等）连接。IXP（互联网交换点）包括四个全球 IXP（ix51–ix54），每个有 Route Server（路由服务器），用于多边对等互联。AS 21–24 作为 IXP 的参与者（peering AS），每个连接一个 IXP。AS 101–112 每个 AS 有一个边界路由器连接到对应的 IXP（例如 AS101 连接 ix51），实现与外部互联网的连通。所有路由器运行真实路由协议（如 BGP），支持模拟路由攻击、劫持等。</p><p>可视化与监控工具包括运行 SeedEmu 的互联网拓扑可视化界面的 seedemu-internet-client，映射端口 8080，提供整个网络拓扑的图形化视图，以及运行 Ethereum 网络专用可视化界面的 seedemu-ether-client，映射端口 5000，用于查看区块链节点状态、同步情况、交易等。eth_node_cleaner 是自定义服务，暴露端口 8888，可能用于中央数据收集、节点状态清理或监控指标聚合，连接 PostgreSQL、Redis 和 Neo4j。</p><p>其他特性包括大量自定义网络（local 和 global 类型），精确分配 IP 地址段，节点标签丰富（org.seedsecuritylabs.seedemu.meta.*），便于 SeedEmu 工具识别和渲染，部分服务使用 privileged 模式和 cap_add: ALL，以支持模拟路由所需的网络权限。</p><p>现在需要实现一系列功能，提供基于 FastAPI 框架的 RESTful API 路由模块（topology_router），专用于提供区块链仿真环境（特别是结合 SeedEmu 和 Ethereum PoS 网络）的完整拓扑数据访问接口如下：GET /overview 获取整个仿真环境的拓扑概览信息（如节点总数、层级结构等）；GET /statistics 获取拓扑统计数据（如节点、链路数量等汇总指标）；GET /health 检查拓扑服务的健康状态，返回组件运行状况。</p><p>GET /ethereum 获取完整的以太坊网络拓扑数据（节点与 P2P 连接）；GET /ethereum/nodes 获取所有以太坊节点列表，支持按层级过滤（execution 或 consensus）；GET /ethereum/nodes/{node_id}获取指定以太坊节点（执行层或共识层）的详细信息；GET /ethereum/validators/{validator_id}根据验证者公钥获取单个验证者节点的详细状态和信息。</p><p>GET /physical 获取纯物理拓扑结构（不包含容器运行时监控数据）；GET /physical/devices 获取物理设备列表（路由器、主机等），支持按设备类型过滤；GET /physical/links 获取物理链路（网络连接）列表，支持按连接类型过滤；GET /physical/networks 获取所有物理网络的配置信息（网络 ID、名称、子网、网关等）。</p><p>GET /contract 获取智能合约相关的拓扑视图（合约部署、调用关系等）；GET /contract/statistics 获取合约层面的统计信息（如合约数量、调用频率等）。</p><p>GET /transaction 获取交易拓扑数据，支持通过时间范围（start_time 和 end_time）过滤；GET /transaction/statistics 获取交易层面的统计信息；GET /transaction/address/{address}/analysis 分析特定以太坊地址的资金/交易流向（流入流出关系图）。</p><p>GET /layer/{layer}根据指定拓扑层（枚举值，如 ethereum、physical 等）获取对应层级的完整拓扑数据；POST /combined 支持组合多个拓扑层（如以太坊层+物理层）生成统一的拓扑视图，可指定渲染格式。</p><p>POST /render 接收任意拓扑数据和渲染请求（格式如 cytoscape、graphviz 等），返回经过布局算法处理的可直接用于前端可视化的数据。</p><p>GET /nodes/{node_id}获取任意节点（跨层级）的详细信息，支持指定层级；GET /analysis/{layer}对指定层级进行网络分析（如连通性、中心性、社区检测等指标）。</p><p>POST /cache/clear 清空服务内部所有缓存（用于强制刷新数据）；GET /debug/info 获取详细的调试信息，包括服务组件状态、各处理器缓存大小、支持的层级与渲染格式等，便于开发与运维排查。</p><hr><h2 id="针对该环境和需求的系统设计方案"><a href="#针对该环境和需求的系统设计方案" class="headerlink" title="针对该环境和需求的系统设计方案"></a>针对该环境和需求的<strong>系统设计方案</strong></h2><p>需要设计一个 FastAPI 后端，它充当一个”中间层（Middleware）”或”聚合层（Aggregator）”，将底层分散的基础设施（Docker）、网络拓扑（SeedEmu/Neo4j）和应用状态（Ethereum/PostgreSQL）整合成统一的 API 暴露给前端</p><h3 id="1-系统架构概览"><a href="#1-系统架构概览" class="headerlink" title="1. 系统架构概览"></a>1. 系统架构概览</h3><p>由于涉及 140+ 容器和多种数据源，系统的核心挑战在于数据聚合和性能优化。建议采用分层架构，包括前端/可视化大屏与 FastAPI 网关的交互，以及 FastAPI 后端应用内的 Redis 缓存层、业务逻辑层 TopologyService，和各种适配器（Docker Adapter、Neo4j Adapter、Ethereum Adapter Web3.py、DB Adapter SQLAlchemy）的协作，最终与基础设施 Docker Compose 中的 Docker Socket、Neo4j 图数据库、JSON-RPC AS101 Host0 和 PostgreSQL ethereum_monitor 进行交互。</p><h3 id="2-核心模块设计"><a href="#2-核心模块设计" class="headerlink" title="2. 核心模块设计"></a>2. 核心模块设计</h3><p>我们需要将代码组织为清晰的模块，以应对你列出的 9 大类接口。</p><h4 id="2-1-数据模型层-Models-Schemas"><a href="#2-1-数据模型层-Models-Schemas" class="headerlink" title="2.1 数据模型层 (Models/Schemas)"></a>2.1 数据模型层 (Models/Schemas)</h4><p>使用 Pydantic 定义统一的拓扑数据结构，这是所有接口返回的基础。网络拓扑系统采用了分层架构设计，主要包括以下几个层级：API 层 - topology_api.py 提供 RESTful 接口，服务层 - topology_service.py 协调各种拓扑功能，数据层 - real_topology_service.py 处理真实数据获取，专门处理器层 - 处理合约、交易等特定类型的拓扑，管理与渲染层 - 负责生命周期管理和数据渲染。</p><p>用户通过 API 请求拓扑数据（如 /topology/ethereum），API 调用 TopologyService 的 get_ethereum_topology() 方法，TopologyService 委托给 _real_data_service（即 RealTopologyService），RealTopologyService 从 Neo4j 数据库获取真实的以太坊 P2P 网络拓扑数据，数据经过处理和格式化后返回给用户。</p><p>对于以太坊拓扑，从 Neo4j 数据库查询执行层和共识层节点及其连接关系，查询验证者节点并与共识节点关联，将原始数据转换为前端友好的拓扑格式，通过 Docker 客户端获取容器信息，建立 IP 地址与容器名称的映射。对于物理拓扑，通过 Docker 客户端获取所有容器的详细信息，根据容器名称识别设备类型（路由器、主机等），根据容器连接的网络建立设备间连接关系，使用共享网络原则确定设备连接。</p><p>在 topology_interfaces.py 中定义了核心抽象类：TopologyNode 作为拓扑节点基类，包含 id（节点唯一标识）、name（节点名称）、node_type（节点类型，执行层、共识层、验证者等）、ip_address（IP 地址）、layer（所属层级）、status（状态）、metadata（元数据）等属性；TopologyLink 作为拓扑连接基类，包含 source（源节点 ID）、target（目标节点 ID）、link_type（连接类型）、layer（所属层级）、direction（连接方向）、metadata（元数据）等属性。</p><p>不同类型的拓扑节点包括以太坊节点（执行层节点、共识层节点、验证者节点）和物理节点（路由器、主机、交换机）。拓扑数据最终以 nodes（节点列表，每个节点包含 id、name、type、ip_address、status 等属性）、links（连接列表，每个连接包含 source、target、type 等属性）、元数据（时间戳、数据源、统计信息等）的格式组织。</p><p>这是与底层交互的关键。InfrastructureAdapter (Docker &amp; SeedEmu) 作用是获取物理拓扑，实现方式是使用 docker Python 库读取容器列表，解析 com.docker.compose.service 和 org.seedsecuritylabs.seedemu.meta.<em> 标签来识别节点角色（AS、路由器、主机）；对应接口是 /physical/</em>。</p><p>GraphDBAdapter (Neo4j) 作用是获取网络静态拓扑和关联关系，实现方式是使用 neo4j Python 驱动，SeedEmu 通常会将生成的拓扑导入 Neo4j，查询 Cypher 语句来获取节点间的连接；对应接口是 /overview, /analysis/{layer}。</p><p>BlockchainAdapter (Web3.py &amp; Postgres) 作用是获取链上实时状态，实现方式是使用 web3.py (AsyncHTTPProvider) 连接开放 RPC 端口的节点（如 AS101 的 8545）获取 Block Height, Peer Count，以及连接 PostgreSQL (ethereum<em>monitor) 查询交易历史、合约调用统计；对应接口是 /ethereum/</em>, /contract/_, /transaction/*。</p><h4 id="2-3-业务服务层-Services"><a href="#2-3-业务服务层-Services" class="headerlink" title="2.3 业务服务层 (Services)"></a>2.3 业务服务层 (Services)</h4><p>这是实现 RealTopologyService 的地方，负责组装数据。TopologyService 能够根据请求的 layer (physical, ethereum) 调用不同的 Adapter，实现 /combined 接口，将 Docker 的运行状态（Up/Down）注入到 Neo4j 查出的静态拓扑中，并将 Ethereum 节点的逻辑 ID（Validator ID）映射到物理容器 IP。非常重要的是使用 Redis 缓存完整的拓扑 JSON，并设置后台定时任务（FastAPI lifespan 或 APScheduler）每 5-10 秒刷新一次缓存。</p><p>AnalysisService 将拓扑数据加载到 Python 的 networkx 库中，计算中心性（Centrality）、最短路径（用于分析攻击传播）、社区发现等算法；对应接口是 /analysis/*。</p><h3 id="3-具体接口实现策略"><a href="#3-具体接口实现策略" class="headerlink" title="3. 具体接口实现策略"></a>3. 具体接口实现策略</h3><p>针对你提供的文档，以下是具体实现建议：</p><p>物理层 (Physical Layer) 的挑战是如何知道哪个容器连接哪个。方案是 SeedEmu 通常会在生成容器时将连接信息写入 Neo4j 或生成的 metadata 文件。优先从 Neo4j 读取链路关系，从 Docker API 读取节点存活状态（Status: Running/Exited）。</p><p>以太坊层 (Ethereum Layer) 的挑战是 108 个节点，如何获取所有节点状态。方案是使用信标链数据 (Consensus)，连接 Beacon Node API (如果环境中有) 获取验证者状态 (Active/Slashed)；使用 P2P 拓扑，使用 admin_peers RPC 方法（需要节点开启该 API）查询节点的连接对象。由于无法轮询所有 108 个节点，可以只轮询几个关键 Bootnode 和 AS 网关节点，构建局部图；使用 Postgres 补充，从数据库中读取已知的节点列表和 Validator ID 映射。</p><p>交易与合约 (Transaction &amp; Contract) 的挑战是实时分析交易流向。方案是不要直接扫描链，而是利用环境中的 postgresql (ethereum_monitor)。SeedEmu 的监控器应该已经将区块和交易写入库中。接口 /transaction/address/{address}/analysis 直接执行 SQL 聚合查询（Group by to/from），返回资金流向图。</p><p>可视化渲染 (Rendering) 的接口是 POST /render，逻辑是前端可能只需传递原始数据，后端使用 networkx 计算布局（如 ForceAtlas2 或层级布局），计算出每个节点的 (x, y) 坐标，返回给前端直接绘制。这能减轻前端浏览器处理 140+ 节点布局的压力。</p><h3 id="4-代码结构示例"><a href="#4-代码结构示例" class="headerlink" title="4. 代码结构示例"></a>4. 代码结构示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/topology.py</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">from</span> app.schemas.topology <span class="hljs-keyword">import</span> TopologyGraph<br><br>router = APIRouter(prefix=<span class="hljs-string">"/topology"</span>, tags=[<span class="hljs-string">"Topology"</span>])<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/overview"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_overview</span>(<span class="hljs-params">service: TopologyService = Depends(<span class="hljs-params">get_topology_service</span>)</span>):<br>    <span class="hljs-comment"># 从缓存获取，如果无则计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.get_system_overview()<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/ethereum/nodes/{node_id}"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eth_node_detail</span>(<span class="hljs-params">node_id: <span class="hljs-built_in">str</span>, service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 1. 查 Neo4j 获取节点基础信息</span><br>    <span class="hljs-comment"># 2. 查 Docker 确认容器是否在线</span><br>    <span class="hljs-comment"># 3. 查 Web3/DB 获取链上余额和状态</span><br>    data = <span class="hljs-keyword">await</span> service.get_node_composite_info(node_id, layer=<span class="hljs-string">"ethereum"</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"Node not found"</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">"/combined"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_combined_view</span>(<span class="hljs-params">layers: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 融合物理层和区块链层</span><br>    <span class="hljs-comment"># 例如：展示 区块链P2P连线 覆盖在 物理AS拓扑 上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.generate_combined_topology(layers)<br></code></pre></td></tr></table></figure><h3 id="5-关键技术难点与解决方案"><a href="#5-关键技术难点与解决方案" class="headerlink" title="5. 关键技术难点与解决方案"></a>5. 关键技术难点与解决方案</h3><p>Docker 网络访问方面，FastAPI 容器需要挂载 /var/run/docker.sock 才能查询兄弟容器的状态。docker-compose.yml 配置中需要添加 volumes: - /var/run/docker.sock:/var/run/docker.sock。</p><p>跨容器数据库连接方面，连接 Neo4j 和 Postgres 时，Host 应使用 Docker Compose 服务名（如 neo4j, postgresql），而不是 localhost。</p><p>性能瓶颈方面，问题在于/ethereum 接口如果实时调用 100+ 次 RPC 会超时。解决方法是使用”后台采集 + 前端读取”模式，编写一个后台 Task (使用 asyncio 或 Celery) 每 10 秒扫描一次网络状态存入 Redis。API 接口只读 Redis。</p><p>IP 地址管理方面，SeedEmu 的自定义网络（inet0, net_2_net_51_52）非常复杂。在返回 /physical 拓扑时，务必解析 Docker inspect 结果中的 NetworkSettings，将特定网段 IP 映射给前端，否则前端无法理解路由关系。</p><h3 id="6-总结建议"><a href="#6-总结建议" class="headerlink" title="6. 总结建议"></a>6. 总结建议</h3><p>设计这个系统时，请遵循以下步骤：首先打通 Neo4j，它是拓扑的真理来源（Source of Truth），确保能查询出 AS、Router 和 Host 的关系；其次实现缓存机制，复杂的 Docker 集群状态获取很慢，不要让 API 直接穿透到 Docker Daemon；定义清晰的 ID 映射，最大的坑在于关联 “Docker Container Name” (e.g., as101_host0) 和 “Ethereum Node ID” (e.g., Validator-3)，需要在服务启动时建立这个映射表；按层开发，先做 Physical（最简单，只读 Docker），再做 Ethereum（读 DB），最后做高级的 Contract/Transaction 分析。</p><p>实现”实时更新”并”高亮变化”的核心在于结合 FastAPI 的 WebSocket 推送机制与 D3.js 的 General Update Pattern（通用更新模式）。这里有三个关键点：后端推送，只推送最新的全量/增量状态；前端数据绑定，D3 必须通过 Key Function 识别哪些是新节点、哪些是旧节点，而不是每次清空画布重绘；视觉反馈，利用 CSS 动画或 D3 Transition 让变化的节点产生”闪烁”或”颜色渐变”。</p><h3 id="1-整体架构设计"><a href="#1-整体架构设计" class="headerlink" title="1. 整体架构设计"></a>1. 整体架构设计</h3><p>后端 (FastAPI) 运行一个后台任务（Background Task），每隔几秒扫描一次 Docker/Ethereum 状态，通过 WebSocket 广播给前端；前端 (D3.js) 维护一个长连接，收到数据后，执行 updateGraph(newData)。</p><h3 id="2-后端：FastAPI-WebSocket-实现"><a href="#2-后端：FastAPI-WebSocket-实现" class="headerlink" title="2. 后端：FastAPI WebSocket 实现"></a>2. 后端：FastAPI WebSocket 实现</h3><p>我们需要一个 ConnectionManager 来管理前端连接，并推送拓扑数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/ws_topology.py</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, WebSocket, WebSocketDisconnect<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><br>router = APIRouter()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections: <span class="hljs-built_in">list</span>[WebSocket] = []<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-keyword">await</span> websocket.accept()<br>        <span class="hljs-variable language_">self</span>.active_connections.append(websocket)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections.remove(websocket)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">self, message: <span class="hljs-built_in">dict</span></span>):<br>        <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.active_connections:<br>            <span class="hljs-keyword">await</span> connection.send_json(message)<br><br>manager = ConnectionManager()<br><br><span class="hljs-comment"># 模拟后台数据推送任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">topology_broadcaster</span>(<span class="hljs-params">service: TopologyService</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    这个函数需要在 main.py 的 @app.on_event("startup") 中启动</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 获取最新拓扑（包含 Docker 状态 + Geth 连接）</span><br>        topology_data = <span class="hljs-keyword">await</span> service.get_full_topology_snapshot()<br><br>        <span class="hljs-comment"># 广播数据</span><br>        <span class="hljs-keyword">if</span> manager.active_connections:<br>            <span class="hljs-keyword">await</span> manager.broadcast(topology_data)<br><br>        <span class="hljs-comment"># 每 5 秒推送一次，避免前端渲染压力过大</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-meta">@router.websocket(<span class="hljs-params"><span class="hljs-string">"/ws/topology"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">websocket_endpoint</span>(<span class="hljs-params">websocket: WebSocket</span>):<br>    <span class="hljs-keyword">await</span> manager.connect(websocket)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 保持连接活跃，也可以接收前端的控制指令（比如点击了某个节点）</span><br>            data = <span class="hljs-keyword">await</span> websocket.receive_text()<br>    <span class="hljs-keyword">except</span> WebSocketDisconnect:<br>        manager.disconnect(websocket)<br></code></pre></td></tr></table></figure><h3 id="3-前端：D3-js-实时更新与高亮逻辑"><a href="#3-前端：D3-js-实时更新与高亮逻辑" class="headerlink" title="3. 前端：D3.js 实时更新与高亮逻辑"></a>3. 前端：D3.js 实时更新与高亮逻辑</h3><p>这是最关键的部分。不要清空 SVG！使用 D3 的 Enter (新增), Update (更新), Exit (删除) 模式。</p><p>核心策略包括 ID 绑定，告诉 D3 如何通过 ID（如 enode_id 或 container_name）区分节点，而不是数组索引；平滑模拟，数据更新时，不要将 alpha 重置为 1（会导致整个图剧烈爆炸），而是重置为 0.3 左右（轻微调整）；样式 Diff，比对新旧数据，如果状态变化（如 IP 变了，Peer 数变了），添加 CSS 类名触发动画。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;a href=&quot;#复杂异构系统监控与可视化项目设计&quot; class=&quot;headerlink&quot; title=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;复杂异构系统监控与可视化&lt;/strong&gt;项目设计&lt;/h2&gt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-06-杂记-前端图拓扑渲染优化</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/7900.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/7900.html</id>
    <published>2025-12-06T03:25:47.000Z</published>
    <updated>2025-12-14T17:56:13.795Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>性能优化 (Web Workers)</strong>: 目前的数据获取、解析和Diff算法都在<strong>主线程</strong>运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 <strong>Web Worker</strong>。</p></li><li><p><strong>D3 渲染优化</strong>: 目前的设计倾向于每次更新都全量替换 filteredNodes，这会导致 D3 力导向图重新初始化或位置抖动。应该利用 Diff 结果进行<strong>增量渲染 (Enter/Update/Exit)</strong>。</p></li><li><p><strong>状态管理解耦</strong>: useTopologyData 承担了太多职责（数据存储、UI状态、标签逻辑）。应该拆分为“数据层”和“视觉层”。</p></li><li><p><strong>数据结构优化</strong>: 数组查找（.find）效率低，应更多使用 Map/Set 索引。</p></li></ol><h3 id="优化后文件结构"><a href="#优化后文件结构" class="headerlink" title="优化后文件结构"></a>优化后文件结构</h3><p>采用了 <strong>Core (数据核心) + Visual (视觉逻辑) + Worker (后台计算)</strong> 的分层结构。</p><p>codeText</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span>/<br>  ├── types/<br>  │   └── topology<span class="hljs-selector-class">.ts</span>           <span class="hljs-comment">// (保持不变) 类型定义</span><br>  ├── workers/<br>  │   └── topology<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [新] 负责Fetch、解析数据、计算Diff</span><br>  ├── composables/<br>  │   ├── useTopologyCore<span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [优化] 负责与Worker通信，持有原始数据</span><br>  │   ├── useTopologyVisual<span class="hljs-selector-class">.ts</span>  <span class="hljs-comment">// [拆分] 负责过滤、标签、高亮等UI逻辑</span><br>  │   └── useD3Renderer<span class="hljs-selector-class">.ts</span>      <span class="hljs-comment">// [新] 封装D3的具体操作，接受Diff指令</span><br>  └── components/<br>      └── EthereumTopology<span class="hljs-selector-class">.vue</span>  <span class="hljs-comment">// [优化] 变得很薄，只负责组装</span><br></code></pre></td></tr></table></figure><p>现在的以太坊拓扑渲染架构采用了 <strong>“分层响应式架构” (Layered Reactive Architecture)</strong>，结合了 <strong>Web Worker 多线程计算</strong> 和 <strong>D3 增量渲染</strong> 技术。</p><p>这是一种高性能、低耦合的现代前端架构，专门为了处理大量节点（数千级）的实时动态拓扑而设计。</p><p>以下是该架构的详细层级解析：</p><h3 id="1-架构总览图"><a href="#1-架构总览图" class="headerlink" title="1. 架构总览图"></a>1. 架构总览图</h3><p>数据流向是单向的，状态管理是响应式的：</p><p>codeMermaid</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">graph TD<br>    BackEnd[FastAPI 后端] --&gt;|<span class="hljs-type">JSON</span> Stream| <span class="hljs-type">Worker</span>[Web Worker (后台线程)]<br>    <br>    subgraph <span class="hljs-string">"Main Thread (主线程)"</span><br>        Worker --&gt;|<span class="hljs-type">Diff</span> Update (增量/全量)| <span class="hljs-type">Store</span>[useTopologyCore (数据层)]<br>        Store --&gt;|<span class="hljs-type">Raw</span> Data| <span class="hljs-type">Visual</span>[useTopologyVisual (视觉层)]<br>        <br>        subgraph <span class="hljs-string">"UI Components (视图层)"</span><br>            Visual --&gt;|<span class="hljs-type">Filtered</span> Data| <span class="hljs-type">Renderer</span>[useD3Renderer (渲染层)]<br>            Visual --&gt;|<span class="hljs-type">Filters</span>/<span class="hljs-keyword">Mode</span>| <span class="hljs-type">Controls</span>[TopologyVisualization (控制面板)]<br>            Renderer --&gt;|<span class="hljs-type">Click</span> Event| <span class="hljs-type">Details</span>[PhysicalTopology (详情抽屉)]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br>    Renderer --&gt;|<span class="hljs-type">Draw</span>| <span class="hljs-type">DOM</span>[SVG/Canvas]<br></code></pre></td></tr></table></figure><hr><h3 id="2-核心层级详细解析"><a href="#2-核心层级详细解析" class="headerlink" title="2. 核心层级详细解析"></a>2. 核心层级详细解析</h3><h4 id="第一层：数据处理层-Worker-Thread"><a href="#第一层：数据处理层-Worker-Thread" class="headerlink" title="第一层：数据处理层 (Worker Thread)"></a>第一层：数据处理层 (Worker Thread)</h4><p><strong>文件</strong>: workers/topology.worker.ts<br>这是架构的“发动机”，完全脱离主线程运行。</p><ul><li><p><strong>职责</strong>：</p><ol><li><p><strong>数据拉取</strong>：直接发起 Fetch 请求，不占用主线程网络资源。</p></li><li><p><strong>数据清洗</strong>：解析复杂的 JSON 结构，标准化为 TopologyNode 和 TopologyLink。</p></li><li><p><strong>智能 Diff (差异计算)</strong>：</p><ul><li><p>这是性能优化的关键。它对比新旧数据，计算出新增、删除和更新的节点。</p></li><li><p><strong>坐标继承</strong>：在 Worker 中将旧节点的 x, y 坐标赋值给新节点，防止 D3 在数据更新时重新计算布局导致视图“爆炸”或闪烁。</p></li></ul></li></ol></li></ul><h4 id="第二层：状态管理层-Composables"><a href="#第二层：状态管理层-Composables" class="headerlink" title="第二层：状态管理层 (Composables)"></a>第二层：状态管理层 (Composables)</h4><p>这一层利用 Vue 3 的 Composition API 将业务逻辑拆分为独立的模块。</p><ul><li><p><strong>数据持有 (useTopologyCore.ts)</strong>：</p><ul><li><p>与 Worker 通信的桥梁。</p></li><li><p>使用 shallowRef 存储庞大的拓扑数据。<strong>优化点</strong>：shallowRef 不会深度监听节点内部属性的变化（如 x, y 坐标），这极大减轻了 Vue 响应式系统的负担，因为 D3 会直接操作这些原生对象。</p></li></ul></li><li><p><strong>视觉逻辑 (useTopologyVisual.ts)</strong>：</p><ul><li><p><strong>纯粹的计算层</strong>。它不关心数据怎么来的，只关心怎么显示。</p></li><li><p><strong>动态过滤</strong>：利用 computed 属性，根据 filters（如隐藏共识节点）实时生成 filteredNodes。</p></li><li><p><strong>样式映射</strong>：集中管理颜色 (getNodeColor) 和标签 (getNodeLabel) 逻辑，实现逻辑与渲染分离。</p></li></ul></li></ul><h4 id="第三层：渲染驱动层-Render-Engine"><a href="#第三层：渲染驱动层-Render-Engine" class="headerlink" title="第三层：渲染驱动层 (Render Engine)"></a>第三层：渲染驱动层 (Render Engine)</h4><p><strong>文件</strong>: useD3Renderer.ts<br>这是 D3.js 与 Vue 的结合点。</p><ul><li><p><strong>生命周期接管</strong>：它在 onMounted 时初始化 D3 仿真器。</p></li><li><p><strong>增量渲染 (Incremental Rendering)</strong>：</p><ul><li><p>使用 Vue 的 watch 监听过滤后的数据。</p></li><li><p>利用 D3 的 enter(), update(), exit() 模式。</p></li><li><p><strong>Enter</strong>: 新节点淡入。</p></li><li><p><strong>Exit</strong>: 被过滤或删除的节点淡出移除。</p></li><li><p><strong>Update</strong>: 现有节点平滑移动到新位置。</p></li></ul></li><li><p><strong>事件桥接</strong>：将 D3 的 click、drag 事件转换为 Vue 的回调函数，传递给上层组件。</p></li></ul><h4 id="第四层：视图组装层-View-Integration"><a href="#第四层：视图组装层-View-Integration" class="headerlink" title="第四层：视图组装层 (View Integration)"></a>第四层：视图组装层 (View Integration)</h4><p><strong>文件</strong>: EthereumTopology.vue (父组件)<br>这是架构的“容器”和“胶水”。</p><ul><li><p><strong>依赖注入 (Dependency Injection)</strong>：</p><ul><li><p>父组件通过 provide(‘topology-state’, …) 将 mode、filters 等状态下发。</p></li><li><p>子组件 TopologyVisualization 通过 inject 直接获取并修改这些状态。避免了深层 Prop 传递（Prop Drilling）。</p></li></ul></li><li><p><strong>组件编排</strong>：</p><ul><li><p>负责布局：左上角悬浮控制面板、中间 D3 画布、右侧详情抽屉。</p></li><li><p>负责联动：当 D3 点击节点时，控制 showPhysicalDetails 变量来弹出侧边栏。</p></li></ul></li></ul><hr><h3 id="3-关键性能优化点总结"><a href="#3-关键性能优化点总结" class="headerlink" title="3. 关键性能优化点总结"></a>3. 关键性能优化点总结</h3><ol><li><p><strong>非阻塞主线程 (Off-Main-Thread)</strong>:</p><ul><li><p><strong>旧架构</strong>：在组件内 fetch 数据 -&gt; 解析 -&gt; 赋值。数据量大时 UI 会卡顿。</p></li><li><p><strong>新架构</strong>：所有数据处理都在 Worker 中完成，主线程只负责接收“准备好渲染”的数据。</p></li></ul></li><li><p><strong>浅层响应式 (Shallow Reactivity)</strong>:</p><ul><li>使用 shallowRef 代替 ref 存储节点数组。D3 内部高频修改 node.x 和 node.y 时，不会触发 Vue 的依赖更新系统，显著提升动画帧率。</li></ul></li><li><p><strong>状态保持 (State Preservation)</strong>:</p><ul><li>Worker 在处理新数据时，会查找旧数据的 ID，并将 x, y, vx, vy (速度向量) 复制给新数据。这保证了在轮询更新时，节点不会重置位置，实现了“流式”的平滑更新效果。</li></ul></li><li><p><strong>按需计算 (Computed Filtering)</strong>:</p><ul><li>连接 (links) 的过滤依赖于节点 (nodes) 的过滤结果。新架构使用了 Set 来建立索引，将连接过滤的时间复杂度从 O(N*M) 降低到 O(M)（其中 N 是节点数，M 是连接数）。</li></ul></li></ol><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>现在的架构是一个 <strong>“重后台、轻前台、数据驱动视图”</strong> 的专业可视化架构。</p><ul><li><p><strong>Worker</strong> 负责“脏活累活”（数据处理）。</p></li><li><p><strong>D3</strong> 负责“精细活”（物理仿真和绘图）。</p></li><li><p><strong>Vue</strong> 负责“指挥”（状态管理和组件通信）。</p></li></ul><p>这种架构非常适合需要长时间运行、实时监控网络状态的生产级系统。</p><hr><p>根据提供的代码（EthereumTopologyHandler 和 RealTopologyService），以太坊网络拓扑的处理流程是一个<strong>分层获取、数据融合、格式化输出</strong>的过程。核心逻辑依赖于 <strong>Neo4j 图数据库</strong>（存储P2P关系）和 <strong>Docker 守护进程</strong>（提供容器运行时信息）。</p><p>以下是详细的处理步骤解析：</p><h3 id="1-数据源获取-Data-Acquisition"><a href="#1-数据源获取-Data-Acquisition" class="headerlink" title="1. 数据源获取 (Data Acquisition)"></a>1. 数据源获取 (Data Acquisition)</h3><p>系统主要通过两个渠道获取数据：</p><ul><li><p><strong>Neo4j 数据库 (核心数据源)</strong>：存储了爬虫或客户端上报的节点发现数据，包含节点ID、IP、以及节点间的 P2P 连接关系。</p></li><li><p><strong>Docker Client (辅助数据源)</strong>：用于获取运行中容器的实时状态、名称映射和网络设置。</p></li></ul><h3 id="2-核心处理流程"><a href="#2-核心处理流程" class="headerlink" title="2. 核心处理流程"></a>2. 核心处理流程</h3><p>整个拓扑生成的逻辑主要集中在 _get_real_topology_from_neo4j 和 _convert_topology_format 方法中。</p><h4 id="步骤-A：从-Neo4j-提取原始拓扑结构"><a href="#步骤-A：从-Neo4j-提取原始拓扑结构" class="headerlink" title="步骤 A：从 Neo4j 提取原始拓扑结构"></a>步骤 A：从 Neo4j 提取原始拓扑结构</h4><p>代码通过 Cypher 查询语句分三步提取数据：</p><ol><li><p><strong>查询执行层 (Execution Layer)</strong>：</p><ul><li><p>查找所有 ExecNode 标签的节点。</p></li><li><p>查找 EXEC_PEERS_WITH 关系，获取该节点的对等节点（Peers）。</p></li></ul></li><li><p><strong>查询共识层 (Consensus Layer)</strong>：</p><ul><li><p>查找所有 ConsNode 标签的节点。</p></li><li><p>查找 CONS_PEERS_WITH 关系。</p></li></ul></li><li><p><strong>查询验证者 (Validators)</strong>：</p><ul><li><p>查找与共识节点通过 MANAGES_VALIDATOR 关系连接的 Validator 节点。</p></li><li><p>这反映了哪个信标节点（Beacon Node）管理着哪些验证者客户端。</p></li></ul></li></ol><h4 id="步骤-B：容器身份映射-Container-Mapping"><a href="#步骤-B：容器身份映射-Container-Mapping" class="headerlink" title="步骤 B：容器身份映射 (Container Mapping)"></a>步骤 B：容器身份映射 (Container Mapping)</h4><ul><li><p><strong>目的</strong>：数据库中只有 IP 地址，但在前端展示时，最好能显示具体的 Docker 容器名称（如 geth-node-1）。</p></li><li><p><strong>实现</strong>：_create_ip_to_container_mapping 方法遍历所有 Docker 容器，提取其网络设置中的 IP 地址，建立 IP -&gt; ContainerName 的映射表。</p></li></ul><h4 id="步骤-C：构建拓扑对象-Topology-Construction"><a href="#步骤-C：构建拓扑对象-Topology-Construction" class="headerlink" title="步骤 C：构建拓扑对象 (Topology Construction)"></a>步骤 C：构建拓扑对象 (Topology Construction)</h4><p>系统将原始数据转换为前端可视化的 JSON 格式，包含 nodes 和 links。</p><p><strong>1. 节点生成 (Nodes):</strong><br>代码根据逻辑自动计算节点的坐标 (x, y) 以便可视化布局：</p><ul><li><p><strong>执行层节点</strong>：</p><ul><li><p>type: execution</p></li><li><p>位置：固定在 Y=150 的水平线上。</p></li></ul></li><li><p><strong>共识层节点</strong>：</p><ul><li><p>type: consensus</p></li><li><p>位置：固定在 Y=350 的水平线上（位于执行层下方）。</p></li></ul></li><li><p><strong>验证者节点</strong>：</p><ul><li><p>type: validator</p></li><li><p>位置：簇拥在所属共识节点的下方 (y + 60)，通过计算偏移量排成小方阵。</p></li></ul></li></ul><p><strong>2. 连接生成 (Links):</strong><br>系统构建了四种类型的连接：</p><ul><li><p><strong>执行层 P2P (exec_peer)</strong>：基于 Neo4j 中的 EXEC_PEERS_WITH 关系，表示 Geth/Nethermind 节点间的 Gossip 协议连接。</p></li><li><p><strong>共识层 P2P (cons_peer)</strong>：基于 CONS_PEERS_WITH 关系，表示 Lighthouse/Prysm 节点间的连接。</p></li><li><p><strong>管理关系 (manages_validator)</strong>：连接共识节点和它管理的验证者节点。</p></li><li><p><strong>跨层连接 (cross_layer)</strong>：<strong>关键逻辑</strong>。代码会自动匹配 IP 地址相同的执行层节点和共识层节点，并创建一个垂直连接。这代表了以太坊客户端组合（Engine API 通信，例如 Geth &lt;-&gt; Lighthouse 在同一台机器/Pod内）。</p></li></ul><h3 id="3-容错与缓存机制"><a href="#3-容错与缓存机制" class="headerlink" title="3. 容错与缓存机制"></a>3. 容错与缓存机制</h3><p>为了保证性能和稳定性，代码中包含了以下机制：</p><ul><li><p><strong>缓存 (Caching)</strong>：</p><ul><li><p>使用 self.cache 存储计算好的拓扑。</p></li><li><p>设置 cache_ttl (20-30秒)，防止频繁查询 Neo4j 导致数据库过载。</p></li></ul></li><li><p><strong>降级模式 (Fallback - 仅在 Service 中)</strong>：</p><ul><li><p>如果 Neo4j 连接失败或返回空数据，RealTopologyService 会调用 _get_container_based_topology。</p></li><li><p><strong>Fallback 逻辑</strong>：直接扫描 Docker 容器，如果发现名为 ethereum 的容器，就根据容器数量“伪造”一个链式的拓扑结构（非网状），以确保界面上至少能看到节点存在，而不是一片空白。</p></li></ul></li></ul><h3 id="4-统计与验证-Statistics-amp-Validation"><a href="#4-统计与验证-Statistics-amp-Validation" class="headerlink" title="4. 统计与验证 (Statistics & Validation)"></a>4. 统计与验证 (Statistics &amp; Validation)</h3><p>EthereumTopologyHandler 还提供了额外的高级功能：</p><ul><li><p><strong>独立查询</strong>：get_nodes 和 get_links 可以不依赖完整拓扑逻辑，直接查询特定层的数据，提高效率。</p></li><li><p><strong>拓扑验证</strong>：validate_topology 检查数据一致性：</p><ul><li><p>节点 ID 是否唯一。</p></li><li><p>连接的源/目标节点是否存在。</p></li><li><p>是否存在孤立节点。</p></li><li><p>IP 地址分布是否异常（例如一个 IP 运行了超过2个主要节点）。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该系统处理以太坊拓扑的核心思想是：<strong>“数据库定义逻辑关系，Docker 定义物理属性，代码负责视觉组装”</strong>。</p><ol><li><p><strong>逻辑层</strong>：谁连谁？由 Neo4j 决定。</p></li><li><p><strong>物理层</strong>：你是谁？由 Docker IP 映射决定。</p></li><li><p><strong>视觉层</strong>：你在哪？由代码中的分层坐标计算逻辑决定（执行层在上，共识层在中，验证者在下）。</p></li></ol><hr><p>目前的实现逻辑虽然功能完整，但在性能上存在几个显著的<strong>瓶颈</strong>，特别是在节点数量增多或 Docker 容器较多时，响应速度会明显下降。</p><p>以下是针对代码的具体性能优化方案，按<strong>提升幅度从大到小</strong>排序：</p><h3 id="1-痛点分析：目前的性能瓶颈在哪里？"><a href="#1-痛点分析：目前的性能瓶颈在哪里？" class="headerlink" title="1. 痛点分析：目前的性能瓶颈在哪里？"></a>1. 痛点分析：目前的性能瓶颈在哪里？</h3><ol><li><p><strong>Docker API 调用过于频繁 (主要瓶颈)</strong>：</p><ul><li><p>_create_ip_to_container_mapping 每次生成拓扑都会被调用。它会遍历<strong>所有</strong>容器并检查网络设置。Docker API 的响应通常是毫秒级到秒级的，如果不缓存，这会严重阻塞主线程。</p></li><li><p>在物理拓扑中，_get_link_bandwidth 会对每个连接进入容器执行 tc 命令。如果有 50 个连接，就要串行执行 50 次 docker exec，这是极慢的 IO 操作。</p></li></ul></li><li><p><strong>串行数据库查询</strong>：</p><ul><li>在 _get_real_topology_from_neo4j 中，执行层查询及处理完之后，才开始共识层的查询。这两者没有依赖关系，完全可以并行。</li></ul></li><li><p><strong>计算密集型的重复操作</strong>：</p><ul><li>每次请求都重新计算所有节点的坐标和映射关系，即使数据没有变化。</li></ul></li></ol><hr><h3 id="2-优化方案一：Docker-数据的独立缓存与后台更新"><a href="#2-优化方案一：Docker-数据的独立缓存与后台更新" class="headerlink" title="2. 优化方案一：Docker 数据的独立缓存与后台更新"></a>2. 优化方案一：Docker 数据的独立缓存与后台更新</h3><p>Docker 的元数据（IP、容器名）变化频率远低于 P2P 网络连接的变化频率。<strong>不要在每次请求拓扑时都去查询 Docker。</strong></p><p><strong>优化策略：</strong> 使用“读写分离”的策略，后台任务更新 Docker 映射，前台请求只读内存变量。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 原有初始化 ...</span><br>        <span class="hljs-variable language_">self</span>.ip_container_map_cache = {}<br>        <span class="hljs-variable language_">self</span>.map_last_update = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.map_update_lock = asyncio.Lock()<br>        <br>        <span class="hljs-comment"># 启动时预热</span><br>        <span class="hljs-comment"># 注意：实际代码中建议使用 apscheduler 或 asyncio.create_task 在后台循环运行</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_ip_to_container_map_optimized</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化后的获取映射方法：</span><br><span class="hljs-string">        1. 优先返回内存缓存</span><br><span class="hljs-string">        2. 缓存过期（如5分钟）才异步更新</span><br><span class="hljs-string">        """</span><br>        current_time = time.time()<br>        <span class="hljs-comment"># 缓存有效期设为 300秒 (Docker容器IP不会频繁变动)</span><br>        <span class="hljs-keyword">if</span> current_time - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br><br>        <span class="hljs-comment"># 如果需要更新，且未被锁定</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.map_update_lock.locked():<br>             <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.map_update_lock:<br>                 <span class="hljs-comment"># 二次检查</span><br>                 <span class="hljs-keyword">if</span> time.time() - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span>: <br>                     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br>                 <br>                 <span class="hljs-comment"># 执行耗时的 Docker 查询</span><br>                 <span class="hljs-comment"># 建议：在一个线程池中运行同步的 docker client 操作，避免阻塞事件循环</span><br>                 loop = asyncio.get_running_loop()<br>                 <span class="hljs-variable language_">self</span>.ip_container_map_cache = <span class="hljs-keyword">await</span> loop.run_in_executor(<br>                     <span class="hljs-literal">None</span>, <span class="hljs-variable language_">self</span>._create_ip_to_container_mapping<br>                 )<br>                 <span class="hljs-variable language_">self</span>.map_last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br></code></pre></td></tr></table></figure><h3 id="3-优化方案二：物理拓扑带宽检测的“非阻塞化”"><a href="#3-优化方案二：物理拓扑带宽检测的“非阻塞化”" class="headerlink" title="3. 优化方案二：物理拓扑带宽检测的“非阻塞化”"></a>3. 优化方案二：物理拓扑带宽检测的“非阻塞化”</h3><p>在 RealTopologyService 中，物理连接的带宽检测（tc 命令）是极其耗时的。绝对不能在用户请求 API 时实时去跑 tc 命令。</p><p><strong>优化策略：</strong> 将带宽数据设为“最终一致性”。主接口只返回拓扑结构，带宽字段先返回缓存值或 “Checking…”，后台任务专门负责轮询更新带宽。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealTopologyService</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-variable language_">self</span>.bandwidth_cache = {} <span class="hljs-comment"># Key: "container_ip", Value: "100Mbit"</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_dynamic_physical_topology_from_containers</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 前面生成 nodes 和 links 的逻辑保持不变 ...</span><br>        <br>        <span class="hljs-comment"># --- 优化点：移除实时 await _get_link_bandwidth ---</span><br>        <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>            target_id = link[<span class="hljs-string">'target'</span>]<br>            target_node = nodes_by_id[target_id]<br>            container_name = target_node[<span class="hljs-string">'container_name'</span>]<br>            link_ip = target_node[<span class="hljs-string">'networks'</span>].get(link[<span class="hljs-string">'shared_network'</span>])<br>            <br>            <span class="hljs-comment"># 1. 尝试从缓存获取</span><br>            cache_key = <span class="hljs-string">f"<span class="hljs-subst">{container_name}</span>::<span class="hljs-subst">{link_ip}</span>"</span><br>            cached_bw = <span class="hljs-variable language_">self</span>.bandwidth_cache.get(cache_key)<br>            <br>            <span class="hljs-keyword">if</span> cached_bw:<br>                link[<span class="hljs-string">'bandwidth'</span>] = cached_bw<br>            <span class="hljs-keyword">else</span>:<br>                link[<span class="hljs-string">'bandwidth'</span>] = <span class="hljs-string">"Querying..."</span><br>                <span class="hljs-comment"># 2. 触发后台更新任务 (Fire and Forget)</span><br>                asyncio.create_task(<span class="hljs-variable language_">self</span>._update_bandwidth_cache(container_name, link_ip, cache_key))<br>                <br>        <span class="hljs-keyword">return</span> nodes, links<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bandwidth_cache</span>(<span class="hljs-params">self, container_name, link_ip, cache_key</span>):<br>        <span class="hljs-string">"""后台单独更新带宽"""</span><br>        bw = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>._get_link_bandwidth(container_name, link_ip)<br>        <span class="hljs-variable language_">self</span>.bandwidth_cache[cache_key] = bw<br></code></pre></td></tr></table></figure><h3 id="4-优化方案三：Neo4j-并发查询"><a href="#4-优化方案三：Neo4j-并发查询" class="headerlink" title="4. 优化方案三：Neo4j 并发查询"></a>4. 优化方案三：Neo4j 并发查询</h3><p>Neo4j 的 Python Driver (尤其是 Bolt 协议) 支持并发。执行层和共识层的查询是独立的，可以使用 asyncio.gather 同时发起查询。</p><p><strong>注意</strong>：这需要你的 database_manager 支持异步操作。如果底层是同步驱动，可以用 run_in_executor 包装。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 EthereumTopologyHandler 中</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_real_topology_from_neo4j</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Dict</span>, <span class="hljs-type">Dict</span>]:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># ... 连接检查 ...</span><br><br>            <span class="hljs-comment"># 定义查询函数</span><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_exec</span>():<br>                <span class="hljs-comment"># 这里假设 database_manager 提供了某种异步执行方式，</span><br>                <span class="hljs-comment"># 或者我们将同步的 session.run 放入线程池</span><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        result = session.run(<span class="hljs-string">"MATCH (n:ExecNode)..."</span>) <span class="hljs-comment"># 填入完整的 Cypher</span><br>                        <span class="hljs-keyword">return</span> {r[<span class="hljs-string">'node_id'</span>]: ... <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result} <span class="hljs-comment"># 处理结果</span><br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_cons_and_validators</span>():<br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        <span class="hljs-comment"># 合并共识节点和验证者的查询逻辑，减少一次 session 创建开销</span><br>                        cons_result = session.run(<span class="hljs-string">"MATCH (n:ConsNode)..."</span>) <br>                        <span class="hljs-comment"># ... 处理共识 ...</span><br>                        validator_result = session.run(<span class="hljs-string">"MATCH ... validators ..."</span>)<br>                        <span class="hljs-comment"># ... 处理验证者 ...</span><br>                        <span class="hljs-keyword">return</span> cons_data<br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-comment"># 并发执行</span><br>            exec_nodes_data, cons_nodes_data = <span class="hljs-keyword">await</span> asyncio.gather(<br>                fetch_exec(), <br>                fetch_cons_and_validators()<br>            )<br><br>            <span class="hljs-keyword">return</span> exec_nodes_data, cons_nodes_data<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># ... Error handling</span><br></code></pre></td></tr></table></figure><h3 id="5-优化方案四：Cypher-查询语句优化"><a href="#5-优化方案四：Cypher-查询语句优化" class="headerlink" title="5. 优化方案四：Cypher 查询语句优化"></a>5. 优化方案四：Cypher 查询语句优化</h3><p>目前的 Cypher 使用了 OPTIONAL MATCH 和 collect，这在数据量大时比较慢。</p><p><strong>原查询：</strong></p><p>codeCypher</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">MATCH (n:ExecNode)<br>OPTIONAL MATCH (n)-<span class="hljs-selector-attr">[r:EXEC_PEERS_WITH]</span>-&gt;(p:ExecNode)<br>RETURN ... <span class="hljs-built_in">collect</span>(...)<br></code></pre></td></tr></table></figure><p>如果在节点很多的情况下，这个查询会扫描整个图。</p><p><strong>优化建议：</strong></p><ol><li><p><strong>分批次</strong>：如果节点超过 1000 个，不要一次性 collect 所有 Peers。前端通常不需要展示所有几千条连线（会卡死浏览器）。可以限制返回的 Peer 数量，例如 LIMIT 10。</p></li><li><p><strong>索引</strong>：确保 node_id, ip 在 Neo4j 中建立了索引 (CREATE INDEX ON :ExecNode(node_id)).</p></li><li><p><strong>只查 ID</strong>：先查出所有 Node 的基础信息，再查 Relation 表（Links），在内存中组装，通常比 Graph DB 做复杂的聚合（Map/Collect）要快。</p></li></ol><h3 id="6-综合改进后的代码结构建议"><a href="#6-综合改进后的代码结构建议" class="headerlink" title="6. 综合改进后的代码结构建议"></a>6. 综合改进后的代码结构建议</h3><p>这里给出一个集成优化思路的 EthereumTopologyHandler 核心方法重构示例：</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-comment"># ... init ...</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_topology</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        <span class="hljs-string">"""获取完整的以太坊拓扑 (优化版)"""</span><br>        <span class="hljs-comment"># 1. 检查拓扑缓存 (Short TTL: e.g., 5s)</span><br>        <span class="hljs-comment"># 拓扑结构变化很快，缓存时间短一点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._is_cache_valid(<span class="hljs-string">"full_ethereum_topology"</span>, ttl=<span class="hljs-number">5</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>]<br><br>        <span class="hljs-comment"># 2. 并行获取数据</span><br>        <span class="hljs-comment"># A. 获取 Docker 映射 (从长效缓存或后台任务获取，极快)</span><br>        <span class="hljs-comment"># B. 获取 Neo4j 数据 (并发查询)</span><br>        <br>        task_docker = <span class="hljs-variable language_">self</span>._get_ip_to_container_map_optimized() <span class="hljs-comment"># 优化点1</span><br>        task_neo4j = <span class="hljs-variable language_">self</span>._get_real_topology_from_neo4j()       <span class="hljs-comment"># 优化点3 (并发内部实现)</span><br>        <br>        ip_map, (exec_data, cons_data) = <span class="hljs-keyword">await</span> asyncio.gather(task_docker, task_neo4j)<br><br>        <span class="hljs-comment"># 3. 转换数据 (CPU 密集型)</span><br>        <span class="hljs-comment"># 如果节点数非常多 (&gt;5000)，可以考虑放入 ProcessPoolExecutor</span><br>        nodes, links = <span class="hljs-variable language_">self</span>._convert_topology_format_optimized(exec_data, cons_data, ip_map)<br><br>        topology_data = {<br>            <span class="hljs-string">'nodes'</span>: nodes, <span class="hljs-string">'links'</span>: links, <span class="hljs-string">'timestamp'</span>: time.time(),<br>            <span class="hljs-comment"># ...</span><br>        }<br><br>        <span class="hljs-comment"># 更新缓存</span><br>        <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>] = topology_data<br>        <span class="hljs-variable language_">self</span>.last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> topology_data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_convert_topology_format_optimized</span>(<span class="hljs-params">self, exec_data, cons_data, ip_map</span>):<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化点：</span><br><span class="hljs-string">        1. 使用 ip_map.get 避免重复循环</span><br><span class="hljs-string">        2. 预计算 positions 字典，避免列表遍历查找</span><br><span class="hljs-string">        """</span><br>        nodes = []<br>        links = []<br>        <span class="hljs-comment"># 使用字典加速查找: key=node_id, value={idx, type, ...}</span><br>        node_lookup = {} <br>        <br>        <span class="hljs-comment"># ... 处理 Exec 节点 ...</span><br>        <span class="hljs-keyword">for</span> i, (nid, data) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exec_data.items()):<br>            <span class="hljs-comment"># 直接查预热好的 Map，O(1)</span><br>            container = ip_map.get(data[<span class="hljs-string">'ip'</span>], <span class="hljs-string">f"exec-<span class="hljs-subst">{data[<span class="hljs-string">'ip'</span>]}</span>"</span>)<br>            <span class="hljs-comment"># ... 创建 node ...</span><br>            node_lookup[nid] = {<span class="hljs-string">'type'</span>: <span class="hljs-string">'execution'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-string">f'<span class="hljs-subst">{nid}</span>-exec'</span>}<br>            <br>        <span class="hljs-comment"># ... 处理 Cons 节点 ...</span><br>        <br>        <span class="hljs-comment"># ... 处理连接 ...</span><br>        <span class="hljs-comment"># 只需要遍历一次 exec_data 的 peers，利用 node_lookup 快速验证</span><br>        <span class="hljs-keyword">for</span> nid, data <span class="hljs-keyword">in</span> exec_data.items():<br>             source_full_id = <span class="hljs-string">f"<span class="hljs-subst">{nid}</span>-exec"</span><br>             <span class="hljs-keyword">for</span> peer <span class="hljs-keyword">in</span> data.get(<span class="hljs-string">'peers'</span>, []):<br>                 target_nid = peer[<span class="hljs-string">'peer_id'</span>]<br>                 <span class="hljs-comment"># O(1) 检查目标是否存在</span><br>                 <span class="hljs-keyword">if</span> target_nid <span class="hljs-keyword">in</span> node_lookup <span class="hljs-keyword">and</span> node_lookup[target_nid][<span class="hljs-string">'type'</span>] == <span class="hljs-string">'execution'</span>:<br>                     links.append({<br>                         <span class="hljs-string">'source'</span>: source_full_id,<br>                         <span class="hljs-string">'target'</span>: <span class="hljs-string">f"<span class="hljs-subst">{target_nid}</span>-exec"</span>,<br>                         <span class="hljs-comment"># ...</span><br>                     })<br>                     <br>        <span class="hljs-keyword">return</span> nodes, links<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>要进行性能优化，最关键的修改是：</p><ol><li><p><strong>Docker 映射</strong>：改为后台定时更新或长缓存，不要每秒都去 inspect 容器。</p></li><li><p><strong>物理带宽 (tc)</strong>：改为异步/后台获取，不要阻塞 API 响应。</p></li><li><p><strong>Neo4j</strong>：使用并发查询，并限制 Cypher 复杂度。</p></li></ol><hr><h2 id="攻击方式（Attack-Strategies）"><a href="#攻击方式（Attack-Strategies）" class="headerlink" title="攻击方式（Attack Strategies）"></a>攻击方式（Attack Strategies）</h2><p>系统目前支持以下6种攻击方式：</p><h3 id="1-节点断网攻击（Node-Disconnection-Attack）"><a href="#1-节点断网攻击（Node-Disconnection-Attack）" class="headerlink" title="1. 节点断网攻击（Node Disconnection Attack）"></a>1. 节点断网攻击（Node Disconnection Attack）</h3><p>通过网络隔离手段切断目标节点与其他节点的连接。支持的方法包括：</p><ul><li><code>interface_down</code>: 禁用网络接口</li><li><code>route_flush</code>: 清除路由表</li><li><code>firewall_block</code>: 防火墙阻断</li><li><code>p2p_block</code>: P2P连接阻断</li></ul><h3 id="2-通信干扰攻击（Communication-Interference-Attack）"><a href="#2-通信干扰攻击（Communication-Interference-Attack）" class="headerlink" title="2. 通信干扰攻击（Communication Interference Attack）"></a>2. 通信干扰攻击（Communication Interference Attack）</h3><p>通过大量无效通信干扰目标节点正常通信。支持的方法包括：</p><ul><li><code>json_rpc_flood</code>: JSON-RPC请求泛洪</li><li><code>p2p_flood</code>: P2P消息泛洪</li><li><code>memory_exhaustion</code>: 内存耗尽攻击</li></ul><h3 id="3-时间攻击（Timestamp-Attack）"><a href="#3-时间攻击（Timestamp-Attack）" class="headerlink" title="3. 时间攻击（Timestamp Attack）"></a>3. 时间攻击（Timestamp Attack）</h3><p>针对共识机制的时间同步进行攻击。支持的方法包括：</p><ul><li>time_shift: 时间偏移</li><li><code>ntp_block</code>: 阻断NTP时间同步</li><li><code>time_drift</code>: 时间漂移</li></ul><h3 id="4-简化Sybil攻击（Simplified-Sybil-Attack）"><a href="#4-简化Sybil攻击（Simplified-Sybil-Attack）" class="headerlink" title="4. 简化Sybil攻击（Simplified Sybil Attack）"></a>4. 简化Sybil攻击（Simplified Sybil Attack）</h3><p>创建虚假节点来影响网络。可以配置：</p><ul><li>虚假节点数量（1-20）</li><li>节点类型（轻节点、全节点、验证者节点）</li><li>网络环境（主网、测试网、开发网）</li><li>连接真实节点选项</li></ul><h3 id="5-存储攻击（Storage-Attack）"><a href="#5-存储攻击（Storage-Attack）" class="headerlink" title="5. 存储攻击（Storage Attack）"></a>5. 存储攻击（Storage Attack）</h3><p>针对节点存储系统的攻击。支持的方法包括：</p><ul><li><code>disk_fill</code>: 磁盘空间填充</li><li><code>database_corruption</code>: 数据库损坏</li><li><code>state_pollution</code>: 状态污染</li><li><code>chain_data_spam</code>: 链上数据垃圾信息</li></ul><h3 id="6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）"><a href="#6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）" class="headerlink" title="6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）"></a>6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）</h3><p>针对特定以太坊客户端的攻击。支持的方法包括：</p><ul><li><code>process_kill</code>: 终止进程</li><li><code>db_corruption</code>: 数据库损坏</li><li><code>port_blocking</code>: 端口阻断</li><li><code>config_modification</code>: 配置文件修改</li></ul><h2 id="攻击模式（Execution-Modes）"><a href="#攻击模式（Execution-Modes）" class="headerlink" title="攻击模式（Execution Modes）"></a>攻击模式（Execution Modes）</h2><p>系统支持三种攻击执行模式：</p><h3 id="1-一次性攻击（One-shot）"><a href="#1-一次性攻击（One-shot）" class="headerlink" title="1. 一次性攻击（One-shot）"></a>1. 一次性攻击（One-shot）</h3><p>执行一次攻击，持续指定时间后自动清理恢复。 配置参数：</p><ul><li>duration_seconds: 攻击持续时间（秒）</li></ul><h3 id="2-重复攻击（Repeated）"><a href="#2-重复攻击（Repeated）" class="headerlink" title="2. 重复攻击（Repeated）"></a>2. 重复攻击（Repeated）</h3><p>按指定间隔重复执行多次攻击。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>repeat_count: 重复次数</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h3 id="3-持续攻击（Continuous）"><a href="#3-持续攻击（Continuous）" class="headerlink" title="3. 持续攻击（Continuous）"></a>3. 持续攻击（Continuous）</h3><p>持续不断地执行攻击，直到手动停止。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h2 id="动态目标攻击"><a href="#动态目标攻击" class="headerlink" title="动态目标攻击"></a>动态目标攻击</h2><p>系统还支持一种特殊的动态目标攻击功能，可以根据网络拓扑分析结果自动选择攻击目标。支持的中心性指标包括：</p><ul><li>度中心性（Degree Centrality）</li><li>介数中心性（Betweenness Centrality）</li><li>接近中心性（Closeness Centrality）</li><li>特征向量中心性（Eigenvector Centrality）</li></ul><p>通过这些攻击方式和模式的组合，系统可以模拟各种真实的以太坊网络攻击场景，帮助评估网络的安全性和鲁棒性。</p><hr><h3 id="1-发起普通攻击-Standard-Attack"><a href="#1-发起普通攻击-Standard-Attack" class="headerlink" title="1. 发起普通攻击 (Standard Attack)"></a>1. 发起普通攻击 (Standard Attack)</h3><p>此接口用于对<strong>明确指定的静态 IP 列表</strong>发起攻击。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate</p></li><li><p><strong>功能</strong>: 发起针对特定静态目标（IP/ID列表）的攻击模拟。</p></li><li><p><strong>逻辑约束</strong>:</p><ol><li><p>parameters.target_nodes 必须是字符串数组 [“ip1”, “ip2”]。</p></li><li><p>支持所有三种执行模式 (one_shot, repeated, continuous)。</p></li></ol></li><li><p><strong>请求体构建规则</strong>:</p><ul><li><p><strong>Level 1 (执行配置)</strong>: 决定攻击的时间维度。</p><ul><li><p>若是 one_shot: 仅需 duration_seconds。</p></li><li><p>若是 repeated: 需额外提供 interval_seconds 和 repeat_count。</p></li></ul></li><li><p><strong>Level 2 (策略参数)</strong>: 决定攻击的具体手段。</p><ul><li><p>必须包含 strategy 字段（枚举值）。</p></li><li><p>其余字段根据 strategy 变化（如 storage_attack 需要 size_mb，而 node_disconnection 不需要）。</p></li></ul></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 场景：对两个节点进行重复的 P2P 洪水攻击</span><br>{<br>  <span class="hljs-string">"execution_config"</span>: {<br>    <span class="hljs-string">"mode"</span>: <span class="hljs-string">"repeated"</span>,<br>    <span class="hljs-string">"duration_seconds"</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">"interval_seconds"</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">"repeat_count"</span>: <span class="hljs-number">5</span><br>  },<br>  <span class="hljs-string">"parameters"</span>: {<br>    <span class="hljs-string">"strategy"</span>: <span class="hljs-string">"communication_interference"</span>,<br>    <span class="hljs-string">"method"</span>: <span class="hljs-string">"p2p_flood"</span>,<br>    <span class="hljs-string">"intensity"</span>: <span class="hljs-string">"high"</span>,<br>    <span class="hljs-string">"target_nodes"</span>: <span class="hljs-selector-attr">[<span class="hljs-string">"192.168.1.10"</span>, <span class="hljs-string">"192.168.1.11"</span>]</span><br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h3 id="2-发起自适应攻击-Adaptive-Attack"><a href="#2-发起自适应攻击-Adaptive-Attack" class="headerlink" title="2. 发起自适应攻击 (Adaptive Attack)"></a>2. 发起自适应攻击 (Adaptive Attack)</h3><p>此接口用于<strong>动态目标</strong>攻击，系统会在每一轮攻击开始前重新计算受害者（例如：总是攻击网络中连接数最多的节点）。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>功能</strong>: 发起自适应攻击，目标由后端实时计算。</p></li><li><p><strong>关键区别</strong>:</p><ol><li><p><strong>不支持</strong> one_shot 模式（因为一次性攻击不需要”自适应”变化）。必须是 repeated 或 continuous。</p></li><li><p>parameters.target_nodes <strong>必须</strong>是特定格式的字符串指令，以 dynamic: 开头。</p></li></ol></li><li><p><strong>目标指令语法</strong>: dynamic:{指标}:{选择策略}</p><ul><li><p>示例: dynamic:degree:top:5 (度中心性最高的前5个)</p></li><li><p>示例: dynamic:betweenness:highest (介数中心性最高的1个)</p></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 场景：持续攻击网络中度中心性最高的前5个节点</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"execution_config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"continuous"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"duration_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"interval_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"strategy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_disconnection"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"firewall_block"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"target_nodes"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dynamic:degree:top:5"</span> <span class="hljs-comment">// 注意这里是字符串</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-前端分流逻辑-Frontend-Logic"><a href="#3-前端分流逻辑-Frontend-Logic" class="headerlink" title="3. 前端分流逻辑 (Frontend Logic)"></a>3. 前端分流逻辑 (Frontend Logic)</h3><p>这是前端 Vue 组件如何决定调用哪个接口的核心逻辑说明。</p><p><strong>Prompt / 逻辑说明:</strong></p><p>前端在点击”发起攻击”按钮时，必须执行以下判断逻辑：</p><ol><li><p><strong>检查目标类型</strong>:</p><ul><li><p>获取用户在表单中输入的目标配置。</p></li><li><p>如果目标是<strong>字符串指令</strong>且以 dynamic: 开头 -&gt; 标记为 isDynamic。</p></li><li><p>如果目标是<strong>手动输入的 IP 列表</strong> -&gt; 标记为 isStatic。</p></li></ul></li><li><p><strong>检查执行模式</strong>:</p><ul><li>获取用户选择的模式 (one_shot, repeated, continuous)。</li></ul></li><li><p><strong>路由决策树</strong>:</p><ul><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode == one_shot):</p><ul><li>❌ <strong>报错</strong>: 自适应攻击不支持一次性模式。</li></ul></li><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode != one_shot):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段发送字符串。</p></li></ul></li><li><p><strong>ELSE</strong> (即静态目标，无论什么模式):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段必须转换为数组 [] 发送。</p></li></ul></li></ul></li></ol><hr><h3 id="4-停止攻击-Stop-Attack"><a href="#4-停止攻击-Stop-Attack" class="headerlink" title="4. 停止攻击 (Stop Attack)"></a>4. 停止攻击 (Stop Attack)</h3><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: DELETE /api/simulations/{attack_id}</p></li><li><p><strong>功能</strong>: 立即终止一个正在运行 (running) 或挂起 (pending) 的攻击任务。</p></li><li><p><strong>适用场景</strong>:</p><ul><li><p>用户点击”紧急停止”按钮。</p></li><li><p>用于中断 continuous (无限持续) 类型的攻击。</p></li><li><p>用于中断剩余轮次尚未执行的 repeated 攻击。</p></li></ul></li><li><p><strong>后端行为</strong>:</p><ul><li><p>取消对应的 asyncio.Task。</p></li><li><p>执行清理逻辑（如恢复防火墙规则、删除垃圾文件）。</p></li><li><p>将数据库中的状态更新为 stopped。</p></li></ul></li></ul><hr><h3 id="5-状态轮询与监控-Monitoring"><a href="#5-状态轮询与监控-Monitoring" class="headerlink" title="5. 状态轮询与监控 (Monitoring)"></a>5. 状态轮询与监控 (Monitoring)</h3><p><strong>Prompt / 接口说明:</strong></p><p>为了在前端展示”实时状态”和”系统日志”，需要配合使用以下两个接口：</p><ol><li><p><strong>获取活跃列表</strong>: GET /api/simulations/active</p><ul><li><p><strong>用途</strong>: 判断当前是否有攻击在跑 (isRunning 状态)。</p></li><li><p><strong>频率</strong>: 建议每 3-5 秒轮询一次。</p></li><li><p><strong>返回</strong>: 包含 progress (进度百分比) 和 current_round (当前轮次)。</p></li></ul></li><li><p><strong>获取详情/日志</strong>: GET /api/simulations/{attack_id}</p><ul><li><p><strong>用途</strong>: 获取特定攻击的详细日志流。</p></li><li><p><strong>返回</strong>: 包含 logs 数组 ([“Attack started”, “Round 1 finished”])。</p></li><li><p><strong>前端展示</strong>: 将 logs 渲染到控制台面板中。</p></li></ul></li></ol><hr><h3 id="总结：数据结构对照表-Type-Mapping"><a href="#总结：数据结构对照表-Type-Mapping" class="headerlink" title="总结：数据结构对照表 (Type Mapping)"></a>总结：数据结构对照表 (Type Mapping)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>参数字段</td><td>描述</td><td>类型限制</td></tr><tr><td><strong>execution_config</strong></td><td></td><td></td></tr><tr><td>mode</td><td>执行模式</td><td>“one_shot” \</td><td>“repeated” \</td><td>“continuous”</td></tr><tr><td>duration_seconds</td><td>单次持续时长</td><td>Integer (秒)</td></tr><tr><td>interval_seconds</td><td>轮次间隔</td><td>Integer (秒), 仅 repeated/continuous 有效</td></tr><tr><td>repeat_count</td><td>重复次数</td><td>Integer, 仅 repeated 有效</td></tr><tr><td><strong>parameters</strong></td><td></td><td></td></tr><tr><td>strategy</td><td>攻击策略</td><td>“node_disconnection” \</td><td>“storage_attack” …</td></tr><tr><td>target_nodes</td><td>攻击目标</td><td>Array [str] (普通) <strong>OR</strong> String dynamic:… (自适应)</td></tr><tr><td>method</td><td>具体手段</td><td>依赖于 strategy (如 firewall_block, disk_fill)</td></tr><tr><td>…</td><td>其他参数</td><td>依赖于 strategy (如 size_mb, intensity)</td></tr></tbody></table></div><hr><h3 id="1-全局枚举定义-Global-Enums"><a href="#1-全局枚举定义-Global-Enums" class="headerlink" title="1. 全局枚举定义 (Global Enums)"></a>1. 全局枚举定义 (Global Enums)</h3><p>这些枚举值用于填充请求体中的特定字段。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>枚举类型</td><td>字段名</td><td>可选值 (Value)</td><td>说明</td></tr><tr><td><strong>执行模式</strong></td><td>mode</td><td>one_shot</td><td><strong>一次性</strong>：执行一次，持续指定时间后恢复。</td></tr><tr><td></td><td></td><td>repeated</td><td><strong>重复执行</strong>：按间隔重复执行多次。</td></tr><tr><td></td><td></td><td>continuous</td><td><strong>持续执行</strong>：按间隔无限执行，直到手动停止。</td></tr><tr><td><strong>攻击策略</strong></td><td>strategy</td><td>node_disconnection</td><td>节点断连攻击</td></tr><tr><td></td><td></td><td>communication_interference</td><td>通信干扰攻击</td></tr><tr><td></td><td></td><td>storage_attack</td><td>存储耗尽攻击</td></tr><tr><td></td><td></td><td>timestamp_attack</td><td>时间/NTP攻击</td></tr><tr><td></td><td></td><td>simplified_sybil_attack</td><td>简化版女巫攻击</td></tr><tr><td></td><td></td><td>geth_lighthouse_attack</td><td>客户端特定攻击 (Geth/Lighthouse)</td></tr></tbody></table></div><hr><h3 id="2-执行配置-execution-config"><a href="#2-执行配置-execution-config" class="headerlink" title="2. 执行配置 (execution_config)"></a>2. 执行配置 (execution_config)</h3><p>根据 mode 的不同，所需字段不同。<strong>注意：自适应攻击接口 (/simulate/adaptive) 不支持 one_shot。</strong></p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>模式 (Mode)</td><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>约束/说明</td></tr><tr><td><strong>通用</strong></td><td>duration_seconds</td><td>Int</td><td>✅</td><td>30</td><td>攻击生效持续时间 (秒)，&gt;=1</td></tr><tr><td><strong>Repeated</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr><tr><td>(重复)</td><td>repeat_count</td><td>Int</td><td>✅</td><td>-</td><td>重复执行的总轮数，&gt;=1</td></tr><tr><td><strong>Continuous</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr></tbody></table></div><hr><h3 id="3-策略参数详情-parameters"><a href="#3-策略参数详情-parameters" class="headerlink" title="3. 策略参数详情 (parameters)"></a>3. 策略参数详情 (parameters)</h3><p>此部分为多态结构，根据 strategy 字段的值，JSON 结构发生变化。</p><h4 id="3-1-节点断连-node-disconnection"><a href="#3-1-节点断连-node-disconnection" class="headerlink" title="3.1 节点断连 (node_disconnection)"></a>3.1 节点断连 (node_disconnection)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>interface_down (网卡下线), route_flush (清空路由), firewall_block (防火墙), p2p_block (P2P阻断)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令 (见第4节)</td></tr></tbody></table></div><h4 id="3-2-通信干扰-communication-interference"><a href="#3-2-通信干扰-communication-interference" class="headerlink" title="3.2 通信干扰 (communication_interference)"></a>3.2 通信干扰 (communication_interference)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>json_rpc_flood (RPC泛洪), p2p_flood (P2P泛洪), memory_exhaustion (内存耗尽)</td></tr><tr><td>intensity</td><td>String</td><td>❌</td><td>medium</td><td>low, medium, high, extreme</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h4 id="3-3-存储攻击-storage-attack"><a href="#3-3-存储攻击-storage-attack" class="headerlink" title="3.3 存储攻击 (storage_attack)"></a>3.3 存储攻击 (storage_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>disk_fill (填充), database_corruption (脏数据), state_pollution (状态污染), chain_data_spam (链上垃圾)</td></tr><tr><td>size_mb</td><td>Int</td><td>❌</td><td>1000</td><td>填充大小 (MB)，100 - 10000</td></tr><tr><td>file_count</td><td>Int</td><td>❌</td><td>100</td><td>生成文件数量，10 - 1000</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-4-时间攻击-timestamp-attack"><a href="#3-4-时间攻击-timestamp-attack" class="headerlink" title="3.4 时间攻击 (timestamp_attack)"></a>3.4 时间攻击 (timestamp_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>time_shift (平移), ntp_block (NTP阻断), time_drift (漂移)</td></tr><tr><td>time_shift</td><td>String</td><td>❌</td><td>+1 hour</td><td>偏移量 (如 +1 hour, -30 minutes)，仅 time_shift 方法有效</td></tr><tr><td>drift_seconds</td><td>Int</td><td>❌</td><td>3600</td><td>漂移秒数，-86400 到 86400，仅 time_drift 方法有效</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-5-女巫攻击-simplified-sybil-attack"><a href="#3-5-女巫攻击-simplified-sybil-attack" class="headerlink" title="3.5 女巫攻击 (simplified_sybil_attack)"></a>3.5 女巫攻击 (simplified_sybil_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>fake_node_count</td><td>Int</td><td>❌</td><td>5</td><td>虚假节点数量 (1-20)</td></tr><tr><td>node_type</td><td>String</td><td>❌</td><td>light</td><td>light (轻节点), full (全节点), validator (验证者)</td></tr><tr><td>network</td><td>String</td><td>❌</td><td>testnet</td><td>mainnet, testnet, devnet</td></tr><tr><td>connect_to_real</td><td>Bool</td><td>❌</td><td>True</td><td>是否连接真实节点</td></tr><tr><td>min_connections</td><td>Int</td><td>❌</td><td>3</td><td>最小连接数 (0-10)</td></tr><tr><td>target_nodes</td><td>-</td><td>-</td><td>-</td><td><strong>注意：此策略通常不需要指定具体目标节点</strong></td></tr></tbody></table></div><h4 id="3-6-客户端攻击-geth-lighthouse-attack"><a href="#3-6-客户端攻击-geth-lighthouse-attack" class="headerlink" title="3.6 客户端攻击 (geth_lighthouse_attack)"></a>3.6 客户端攻击 (geth_lighthouse_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>process_kill, db_corruption, port_blocking, config_modification</td></tr><tr><td>attack_type</td><td>String</td><td>✅</td><td>-</td><td>geth, lighthouse (指定攻击的客户端类型)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><hr><h3 id="4-目标节点配置-target-nodes"><a href="#4-目标节点配置-target-nodes" class="headerlink" title="4. 目标节点配置 (target_nodes)"></a>4. 目标节点配置 (target_nodes)</h3><p>target_nodes 字段在不同接口下有严格的格式要求。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>接口端点</td><td>格式类型</td><td>数据结构示例</td><td>说明</td></tr><tr><td>/api/simulate</td><td><strong>静态列表</strong></td><td>[“192.168.1.10”, “node_id_123”]</td><td>明确指定要攻击的节点列表。</td></tr><tr><td>/api/simulate/adaptive</td><td><strong>动态指令</strong></td><td>“dynamic:degree:top:5”</td><td>字符串格式，后端自动计算目标。</td></tr></tbody></table></div><p><strong>动态指令语法:</strong> dynamic:{指标}:{选择器}</p><ol><li><p><strong>指标 (Metric)</strong>:</p><ul><li><p>degree (度中心性)</p></li><li><p>betweenness (介数中心性)</p></li><li><p>closeness (接近中心性)</p></li><li><p>eigenvector (特征向量中心性)</p></li></ul></li><li><p><strong>选择器 (Selector)</strong>:</p><ul><li><p>highest (选最高的1个)</p></li><li><p>top:N (选前 N 个，N为数字)</p></li></ul></li></ol><hr><h3 id="5-防护配置-defense-enable"><a href="#5-防护配置-defense-enable" class="headerlink" title="5. 防护配置 (/defense/enable)"></a>5. 防护配置 (/defense/enable)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>示例</td><td>说明</td></tr><tr><td>enabled</td><td>Bool</td><td>❌</td><td>true</td><td>是否启用防护</td></tr><tr><td>rules</td><td>Object</td><td>✅</td><td>{“rate_limit”: 100}</td><td>防护规则字典，具体Key由后端逻辑决定</td></tr></tbody></table></div><hr><h3 id="6-响应结构概览"><a href="#6-响应结构概览" class="headerlink" title="6. 响应结构概览"></a>6. 响应结构概览</h3><p>所有接口通常遵循统一的响应格式：</p><p>codeJSON</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">{<br>  <span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>,  <span class="hljs-string">//</span> 或 <span class="hljs-string">"error"</span><br>  <span class="hljs-string">"message"</span>: <span class="hljs-string">"操作描述"</span>,<br>  <span class="hljs-string">"data"</span>: { <span class="hljs-string">...</span> }       <span class="hljs-string">//</span> 具体业务数据<br>}<br></code></pre></td></tr></table></figure><p><strong>关键数据字段 (data)</strong>:</p><ul><li><p>attack_id: (String) 攻击任务的唯一标识符。</p></li><li><p>status: (Enum) pending, running, completed, failed, stopped, cancelled。</p></li><li><p>logs: (Array[Str]) 攻击日志列表。</p></li></ul><p>{<br>  “nodes”: [<br>    {<br>      “id”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”,<br>      “name”: “Tether USD (USDT)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 5<br>    },<br>    {<br>      “id”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”,<br>      “name”: “USD Coin (USDC)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 3<br>    },<br>    {<br>      “id”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”,<br>      “name”: “Uniswap V3: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 8<br>    },<br>    {<br>      “id”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”,<br>      “name”: “Uniswap V3: SwapRouter02”,<br>      “type”: “SwapRouter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 6<br>    },<br>    {<br>      “id”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”,<br>      “name”: “Uniswap V3: Quoter”,<br>      “type”: “Quoter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”,<br>      “name”: “Uniswap V2: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 7<br>    },<br>    {<br>      “id”: “0x881D40237659C251811CEC9c364ef91dC08D300C”,<br>      “name”: “Curve: 3pool Controller”,<br>      “type”: “CurvePool”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”,<br>      “name”: “Curve: 3pool Gauge”,<br>      “type”: “Gauge”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 2<br>    }<br>  ],<br>  “links”: [<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “type”: “transfer_approve” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap_out” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “type”: “swap_in” },<br>    { “source”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “target”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “type”: “call” },<br>    { “source”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “target”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”, “type”: “quote” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “type”: “approve” },<br>    { “source”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “type”: “deposit” },<br>    { “source”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “target”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”, “type”: “stake” }<br>  ],<br>  “timestamp”: 1765095677.891234,<br>  “data_source”: “real_web3”,<br>  “topology_type”: “contract”<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[ETH前端] --&gt; B[src]<br>    A --&gt; C[package.json]<br>    A --&gt; D[index.html]<br>    A --&gt; E[vite.config.ts]<br>    A --&gt; F[README.md]<br>    A --&gt; G[public]<br>    <br>    B --&gt; H[__tests__]<br>    B --&gt; I[api]<br>    B --&gt; J[assets]<br>    B --&gt; K[components]<br>    B --&gt; L[composables]<br>    B --&gt; M[router]<br>    B --&gt; N[services]<br>    B --&gt; O[types]<br>    B --&gt; P[utils]<br>    B --&gt; Q[views]<br>    B --&gt; R[App.vue]<br>    B --&gt; S[main.ts]<br>    <br>    I --&gt; T[api_docs]<br>    I --&gt; U[attack]<br>    <br>    J --&gt; V[styles]<br>    V --&gt; W[global.css]<br>    V --&gt; X[tailwind.css]<br>    <br>    K --&gt; Y[blockchain]<br>    K --&gt; Z[common]<br>    K --&gt; AA[layout]<br>    K --&gt; AB[tabs]<br>    K --&gt; AC[topology]<br>    <br>    Y --&gt; AD[BlockchainCanvas.vue]<br>    Y --&gt; AE[BlockchainInfoPanel.vue]<br>    Y --&gt; AF[BlockchainModal.vue]<br>    Y --&gt; AG[BlockchainVisualization.vue]<br>    Y --&gt; AH[composables]<br>    Y --&gt; AI[types]<br>    <br>    AH --&gt; AJ[useBlockchainAPI.ts]<br>    AH --&gt; AK[useBlockchainAnimations.ts]<br>    AH --&gt; AL[useBlockchainData.ts]<br>    AH --&gt; AM[useBlockchainEvents.ts]<br>    AH --&gt; AN[useBlockchainRenderer.ts]<br>    AH --&gt; AO[useBlockchainScrolling.ts]<br>    <br>    Z --&gt; AP[ContainerTerminal.vue]<br>    Z --&gt; AQ[DEP-TERM.vue]<br>    Z --&gt; AR[StandaloneTerminal.vue]<br>    Z --&gt; AS[Terminal.vue]<br>    Z --&gt; AT[websocket_terminal8080.vue]<br>    <br>    AA --&gt; AU[DashboardHeader.vue]<br>    AA --&gt; AV[LeftPanel.vue]<br>    AA --&gt; AW[PanelSplitter.vue]<br>    AA --&gt; AX[RightPanel.vue]<br>    <br>    AB --&gt; AY[AttackMonitoringTab.vue]<br>    AB --&gt; AZ[Attack_sys]<br>    AB --&gt; BA[BlockchainBrowserTab.css]<br>    AB --&gt; BB[BlockchainBrowserTab.vue]<br>    AB --&gt; BC[ContainerListTab.vue]<br>    AB --&gt; BD[NetworkTopologyTab.vue]<br>    AB --&gt; BE[sections]<br>    AB --&gt; BF[tabstyle.css]<br>    <br>    AZ --&gt; BG[AttackSystemTab.vue]<br>    BE --&gt; BH[Network-analysis.vue]<br>    BE --&gt; BI[NodeInfoPanel.vue]<br>    BE --&gt; BJ[RealTimeMonitoring.vue]<br>    <br>    AC --&gt; BK[ContractTopology.vue]<br>    AC --&gt; BL[Ethereum_Topology]<br>    AC --&gt; BM[Physical_Topology]<br>    AC --&gt; BN[TopologyVisualization.vue]<br>    AC --&gt; BO[TransactionTopology.vue]<br>    AC --&gt; BP[composables]<br>    AC --&gt; BQ[types]<br>    <br>    BL --&gt; BR[types]<br>    BL --&gt; BS[workers]<br>    BL --&gt; BT[EthereumTopology_new.vue]<br>    BL --&gt; BU[useD3Renderer.ts]<br>    BL --&gt; BV[use_topology_core.ts]<br>    BL --&gt; BW[use_topology_visuals.ts]<br>    <br>    BM --&gt; BX[composables]<br>    BM --&gt; BY[PhysicalTopology.vue]<br>    <br>    BP --&gt; BZ[index.ts]<br>    BP --&gt; CA[topology.css]<br>    BP --&gt; CB[useTopologyAPI.ts]<br>    BP --&gt; CC[useTopologyData.ts]<br>    BP --&gt; CD[useTopologyRendererBase.ts]<br>    <br>    L --&gt; CE[useDashboardData.ts]<br>    L --&gt; CF[useDashboardLayout.ts]<br>    L --&gt; CG[useDashboardTabs.ts]<br>    <br>    M --&gt; CH[index.ts]<br>    <br>    N --&gt; CI[analysis.ts]<br>    N --&gt; CJ[api.ts]<br>    N --&gt; CK[apiService.ts]<br>    N --&gt; CL[attack.ts]<br>    N --&gt; CM[blockchain.ts]<br>    N --&gt; CN[daily-operations.ts]<br>    N --&gt; CO[device-monitoring.ts]<br>    N --&gt; CP[execution.ts]<br>    N --&gt; CQ[foundation.ts]<br>    N --&gt; CR[monitoring.ts]<br>    N --&gt; CS[readme.md]<br>    N --&gt; CT[root-api.ts]<br>    N --&gt; CU[security.ts]<br>    N --&gt; CV[temporal.ts]<br>    N --&gt; CW[topology.ts]<br>    <br>    O --&gt; CX[topology.ts]<br>    <br>    P --&gt; CY[http.ts]<br>    P --&gt; CZ[index.ts]<br>    P --&gt; DA[types.ts]<br>    <br>    Q --&gt; DB[BlockchainTest.vue]<br>    Q --&gt; DC[Dashboard.vue]<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;性能优化 (Web Workers)&lt;/strong&gt;: 目前的数据获取、解析和Diff算法都在&lt;strong&gt;主线程&lt;/strong&gt;运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 &lt;strong&gt;Web Worker&lt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-05-字节工训营画布项目相关设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/17798.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/17798.html</id>
    <published>2025-12-04T18:00:16.000Z</published>
    <updated>2025-12-25T03:23:33.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BDdraw-DEV"><a href="#BDdraw-DEV" class="headerlink" title="BDdraw_DEV"></a>BDdraw_DEV</h1><p>代码仓库：<br><a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>现代协同 2D 画布编辑器 · React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8</p><h4 id="技术栈-·-Tech-Stack"><a href="#技术栈-·-Tech-Stack" class="headerlink" title="技术栈 · Tech Stack"></a>技术栈 · Tech Stack</h4><p class='item-img' data-src='https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white'><img src="https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white" alt="React 18"> <img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5" class='item-img' data-src='https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white'><img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5"> <img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6" class='item-img' data-src='https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white'><img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6"> <img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate" class='item-img' data-src='https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4'><img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate"> <img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design" class='item-img' data-src='https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white'><img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design"> <img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide" class='item-img' data-src='https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white'><img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide"> <img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer" class='item-img' data-src='https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white'><img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer"> <img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8" class='item-img' data-src='https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white'><img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8"> <img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3" class='item-img' data-src='https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white'><img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3"> <img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12" class='item-img' data-src='https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white'><img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12"> <img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid" class='item-img' data-src='https://img.shields.io/badge/nanoid-5.1.6-000000'><img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid"> <img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint" class='item-img' data-src='https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white'><img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint"> <img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky" class='item-img' data-src='https://img.shields.io/badge/Husky-8.0.3-7711A4'><img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky"> <img src="https://img.shields.io/badge/Deploy-GitHub_Pages-222222?logo=githubpages&logoColor=white" alt="GitHub Pages"></p><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p><strong>frontend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:Zhongye1/BDdraw_DEV.git<br><br><span class="hljs-built_in">cd</span> BDdraw_DEV (进入项目)<br>bun install (安装依赖包)<br>bun start (启动服务)<br></code></pre></td></tr></table></figure><p><strong>backend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> BDdraw_DEV/ALD_Backend/<br>bun install <span class="hljs-comment">#安装依赖</span><br>bun index.ts  <span class="hljs-comment">#启动后端服务</span><br></code></pre></td></tr></table></figure><p>推荐使用 bun 包管理器，见个人博客</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/15722.html">关于包管理器 npm,pnpm,yarn 和 bun 以及我为何选择后者</a></p><h4 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h4><p>项目支持通过 Docker 进行容器化部署，使用 Node 22 和 Bun 包管理器。</p><p><strong>开发环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><strong>生产环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -f docker-compose.prod.yml up -d<br></code></pre></td></tr></table></figure><p>部署完成后，可以通过以下地址访问：</p><ul><li>前端应用: <a href="http://localhost:5000/BDdraw_DEV/">http://localhost:5000/BDdraw_DEV/</a></li><li>后端 API 文档: <a href="http://localhost:3000/swagger-ui">http://localhost:3000/swagger-ui</a></li></ul><h4 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h4><p>项目采用了模块化的架构设计，将不同的功能划分为独立的模块，以方便后续维护和扩展</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>60 FPS 渲染（得益于 PixiJS WebGL）</li><li>完整撤销/重做（Command Pattern + 防抖快照）</li><li>多元素选择与群组操作</li><li>画布元素变换控制器</li><li>富文本所见即所得编辑（WanngEditor + PIXI.HTMLText）</li><li>图片插入 + 内置滤镜（模糊、亮度、灰度等）</li><li>插件式元素系统</li><li>插件式元素系统</li><li>完整的 TypeScript 类型支持</li><li>现代开发体验（Vite + ESLint + Prettier + Husky）</li><li>集成 GitHub-Actions 支持， 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</li></ul><hr><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>这时候需要简单做一个技术选型分析，根据任务拆解，选择了如下技术栈</p><p><strong>【框架】</strong>【技术方案：采用 React 18 + TypeScript 5 构建应用，React 提供完整的 UI 生态，TypeScript 提供更清晰可靠的类型安全，相比 JavaScript 更易于维护】</p><p><strong>【构建工具】</strong>【技术方案：使用 Vite 5 作为构建工具，其开发服务器启动和热模块替换（HMR）速度明显快于 Webpack】</p><p><strong>【路由】</strong>【技术方案：采用 React Router DOM 6 实现路由管理，API 稳定且文档完善】</p><p><strong>【样式】</strong>【技术方案：使用 Tailwind CSS 3 + PostCSS 处理样式，开发时编写样式更快，生产环境会自动进行 tree-shaking 优化，相比 CSS Modules 和 styled-components 更高效且原子化更直观，对 AI 工具友好】</p><p><strong>【样式扩展】</strong>【技术方案：少量使用 Less 覆盖 Tailwind 主题变量，保持兼容性】</p><p><strong>【SVG 处理】</strong>【技术方案：使用 SVGR 1.5 处理 SVG，Vite 原生支持，可以将 SVG 作为 React 组件使用，比直接使用 SVG 或 SVG sprite 更灵活】</p><p><strong>【UI 组件库】</strong>【技术方案：采用 shadcn/ui（latest）和 Arco Design 2 实现 UI 组件，易于使用，符合字节项目使用字节组件库的习惯】</p><p><strong>【全局状态】</strong>【技术方案：采用 Zustand 4 管理全局状态，API 简洁、性能良好且无样板代码，相比 Redux Toolkit、Pinia、Jotai 代码量更少且配有 Devtools】</p><p><strong>【图形/画布】</strong>【技术方案：使用 PixiJS 8 + pixi-viewport 实现图形和画布功能，基于 WebGL 渲染，适合处理大量精灵元素，相比其他可选方案性能更高】</p><p><strong>【富文本编辑器】</strong>【技术方案：采用 WangEditor 5 作为富文本编辑器，轻量且文档和社区均为中文，相比 Slate/TipTap 等编辑器，默认输出的 HTML 可直接给 PixiJS HTMLText 进行渲染】</p><p><strong>【图标】</strong>【技术方案：使用 Lucide React 图标库，图标数量多、风格统一且支持 Tree-shaking】</p><p><strong>【工具库】</strong>【技术方案：采用 nanoid 3 为画布元素生成唯一标识符等操作，轻量实用】</p><p><strong>【代码质量】</strong>【技术方案：使用 ESLint + Stylelint + Prettier + Husky + lint-staged + commitlint 保证团队代码风格一致，这是中大型项目的基本配置，有利于多人协作开发】</p><p>此外，还配置了 react 开发者工具 react-dev-inspector，配置了一下，开发环境下 ctrl+q 可以实现点击页面上的组件，在 VSCode 中自动跳转到对应文件，并定位到对应行号，方便调试（先前写 vue 也用过类似的）</p><p>项目 <a href="https://react-dev-inspector.zthxxx.me/docs">https://react-dev-inspector.zthxxx.me/docs</a></p><h3 id="功能要素和方案"><a href="#功能要素和方案" class="headerlink" title="功能要素和方案"></a>功能要素和方案</h3><p>分析以上需求，查阅相关资料后，进行各个核心模块的技术方案选型，确定初步实现方案</p><p><strong>【基础渲染引擎】</strong>【技术方案：PixiJS v8（WebGL）提供高性能 2D 渲染，根据不同元素类型创建对应的 Pixi 对象（图形、文本、图像），通过 pixi-viewport 实现无限画布的视口控制，支持缩放、拖拽等交互】</p><p><strong>【无限画布视口】</strong>【技术方案：pixi-viewport（内置 zoom、drag、decelerate、clampZoom）库创建无限画布，在 StageManagerCore.ts 中初始化 viewport，并添加拖拽、缩放等交互功能，支持鼠标中键拖拽画布、滚轮缩放等常见操作】</p><p><strong>【富文本编辑】</strong>【技术方案：WangEditor 5 作为富文本编辑器，提供完整的文本编辑功能，编辑结果以 HTML 格式存储在元素的 text/string 属性中，元素使用 PixiJS 内置的 HTMLText 进行渲染实现富文本效果】</p><p><strong>【状态管理与数据结构】</strong>【技术方案：Zustand 作为全局状态管理库，通过 structuredClone 函数手动创建状态快照，管理画布元素、选中状态、工具类型等，通过中间件监听状态变化并触发重渲染，在特定的 ts 中定义所有状态和操作方法】</p><p><strong>【图片上传显示与滤镜】</strong>【技术方案：PixiJS 内置 Filter 系统包括 BlurFilter、ColorMatrixFilter（黑白、对比度、饱和度）实现图像处理效果，支持模糊、亮度调整、灰度等多种滤镜效果，在 ElementRenderer.ts 中根据元素的 filter 属性应用相应滤镜，支持 blur（模糊）、brightness（亮度）、grayscale（灰度）等滤镜类型】</p><p><strong>【选中与变换系统】</strong>【技术方案：SelectionManager + TransformOverlay（8 个把手 + 旋转把手）实现变换控件渲染，支持单个元素选中和多个元素群组选中，提供 8 个控制点和 1 个旋转点进行变换操作，根据不同元素类型提供不同的控制方式】</p><p><strong>【旋转与组合嵌套】</strong>【技术方案：每个元素维护自己的 matrix（局部矩阵），组合后父容器统一应用矩阵变换，支持多层级嵌套和复杂变换】</p><p><strong>【Minimap】</strong>【技术方案：单独一个小的 Pixi.Application（共享 texture 缓存）实现缩略图功能，主画布所有容器使用 cacheAsBitmap 后生成低分辨率 texture，实时更新到小画布，视口框用一个半透明矩形表示在主画布中的位置】</p><p><strong>【元素永久缓存】</strong>【技术方案：使用 spriteMap 来存储 PIXI 对象，元素更新时只修改属性并设置 container.dirty = true，而不是销毁重建，来解决拖拽中断、光标丢失、闪烁等问题】</p><p><strong>【辅助对齐线】</strong>【技术方案：拖拽时实时遍历所有元素 bounds，计算对齐情况（水平/垂直/间距相等），差值&lt;6px 就吸附并画蓝线，支持水平、垂直对齐以及等间距对齐等多种对齐方式，当距离小于阈值时自动吸附并对齐】</p><p><strong>【Undo/Redo】</strong>【技术方案：Command Pattern + structuredClone 完整快照（每步 before/after）实现撤销/重做功能，通过管理命令栈（undo，redo 栈），使用 structuredClone 创建状态快照，记录操作前后的完整状态，来支持添加元素、删除元素、修改元素属性等操作的撤销/重做，针对拖拽和调整大小操作的命令生成逻辑可能还要具体再处理一套】</p><p><strong>【数据持久化与离线】</strong>【技术方案：Zustand-persist + localForage（IndexedDB）实现数据持久化和离线使用，使用 Zustand 的持久化中间件保存状态，通过 localForage 将数据存储到 IndexedDB 中，实现数据的自动保存和恢复功能】</p><p><strong>【实时协同】</strong>【技术方案：Y.js + y-websocket（或自己写 CRDT）+ Operation Transform 合并策略实现无冲突的实时协同编辑，通过 y-websocket 插件实现服务端同步（问的 AI），有个思路是把操作打给时间 tag，然后然后按时间合并】</p><hr><h4 id="项目架构树"><a href="#项目架构树" class="headerlink" title="项目架构树"></a>项目架构树</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs sh">BDdraw_DEV/<br>├── ALD_Backend/                    <span class="hljs-comment"># 后端服务目录</span><br>│   ├── src/                        <span class="hljs-comment"># 后端源代码</span><br>│   │   ├── api/                    <span class="hljs-comment"># API接口目录</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关API</span><br>│   │   │   │   ├── types/          <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   │   ├── CORE.ts         <span class="hljs-comment"># 核心房间管理逻辑</span><br>│   │   │   │   ├── Room_CRUD.ts    <span class="hljs-comment"># 房间增删改查操作实现</span><br>│   │   │   │   ├── Room_List.ts    <span class="hljs-comment"># 房间列表管理实现</span><br>│   │   │   │   └── Room_users.ts   <span class="hljs-comment"># 房间用户管理实现</span><br>│   │   │   ├── USER_management/    <span class="hljs-comment"># 用户管理相关API</span><br>│   │   │   │   ├── auth_API.ts     <span class="hljs-comment"># 用户认证API实现</span><br>│   │   │   │   └── auth_API_types.ts  <span class="hljs-comment"># 用户认证类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API索引文件</span><br>│   │   ├── auth.ts                 <span class="hljs-comment"># 认证模块实现</span><br>│   │   ├── collab.ts               <span class="hljs-comment"># 协作功能模块实现</span><br>│   │   └── db.ts                   <span class="hljs-comment"># 数据库连接和操作实现</span><br>│   ├── ARCHITECTURE.md             <span class="hljs-comment"># 后端架构说明文档</span><br>│   ├── README.md                   <span class="hljs-comment"># 后端说明文档</span><br>│   ├── index.ts                    <span class="hljs-comment"># 后端服务入口文件</span><br>│   ├── package.json                <span class="hljs-comment"># 后端依赖配置文件</span><br>│   └── tsconfig.json               <span class="hljs-comment"># 后端TypeScript配置</span><br>├── src/                            <span class="hljs-comment"># 前端源代码目录</span><br>│   ├── api/                        <span class="hljs-comment"># 前端API客户端</span><br>│   │   ├── types/                  <span class="hljs-comment"># API类型定义</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   ├── auth_API_types.ts   <span class="hljs-comment"># 认证相关类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API类型索引文件</span><br>│   │   ├── utils/                  <span class="hljs-comment"># API工具函数</span><br>│   │   │   └── apiClient.ts        <span class="hljs-comment"># API客户端工具</span><br>│   │   ├── apiService.ts           <span class="hljs-comment"># API服务封装实现</span><br>│   │   └── index.ts                <span class="hljs-comment"># API索引文件</span><br>│   ├── components/                 <span class="hljs-comment"># React组件目录</span><br>│   │   ├── Richtext_editor/        <span class="hljs-comment"># 富文本编辑器组件</span><br>│   │   │   ├── BottomTextEditor.tsx    <span class="hljs-comment"># 底部文本编辑器实现</span><br>│   │   │   └── Richtext_editor.tsx     <span class="hljs-comment"># 富文本编辑器主组件</span><br>│   │   ├── canvas_toolbar/         <span class="hljs-comment"># 画布工具栏组件</span><br>│   │   │   ├── ContextMenu.tsx     <span class="hljs-comment"># 上下文菜单实现</span><br>│   │   │   └── TopToolbar.tsx      <span class="hljs-comment"># 顶部工具栏实现</span><br>│   │   ├── collaboration/          <span class="hljs-comment"># 协作功能组件</span><br>│   │   │   ├── CollaboratorCursors.tsx <span class="hljs-comment"># 协作者光标显示组件</span><br>│   │   │   └── RemoteSelectionLayer.tsx <span class="hljs-comment"># 远程选择层组件</span><br>│   │   ├── error-page/             <span class="hljs-comment"># 错误页面组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 错误页面实现</span><br>│   │   ├── header/                 <span class="hljs-comment"># 页面头部组件</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 头部内容组件</span><br>│   │   │   │   ├── ExportCanvasModal.tsx   <span class="hljs-comment"># 导出画布模态框</span><br>│   │   │   │   └── StageManagerContext.tsx <span class="hljs-comment"># 舞台管理上下文</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 头部组件入口</span><br>│   │   ├── image-insert-modal/     <span class="hljs-comment"># 图片插入模态框组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 图片插入模态框实现</span><br>│   │   ├── layout/                 <span class="hljs-comment"># 布局组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 布局组件实现</span><br>│   │   ├── minimap/                <span class="hljs-comment"># 小地图组件</span><br>│   │   │   └── Minimap.tsx         <span class="hljs-comment"># 小地图实现</span><br>│   │   ├── property-panel/         <span class="hljs-comment"># 属性面板组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 属性面板实现</span><br>│   │   ├── settings/               <span class="hljs-comment"># 设置组件</span><br>│   │   │   └── setting.tsx         <span class="hljs-comment"># 设置组件实现</span><br>│   │   ├── ui/                     <span class="hljs-comment"># 基础UI组件</span><br>│   │   │   ├── blackwhitebutton.tsx    <span class="hljs-comment"># 黑白按钮组件</span><br>│   │   │   ├── button.tsx          <span class="hljs-comment"># 按钮组件</span><br>│   │   │   ├── icon-circle.tsx     <span class="hljs-comment"># 圆形图标组件</span><br>│   │   │   ├── icon-clear.tsx      <span class="hljs-comment"># 清除图标组件</span><br>│   │   │   ├── icon-rect.tsx       <span class="hljs-comment"># 矩形图标组件</span><br>│   │   │   ├── icon-select.tsx     <span class="hljs-comment"># 选择图标组件</span><br>│   │   │   └── icon-triangle.tsx   <span class="hljs-comment"># 三角形图标组件</span><br>│   │   ├── AnimatedRoutes.tsx      <span class="hljs-comment"># 动画路由组件</span><br>│   │   ├── ParallaxBackground.tsx  <span class="hljs-comment"># 视差背景组件</span><br>│   │   └── WipeTransition.tsx      <span class="hljs-comment"># 擦除过渡动画组件</span><br>│   ├── hooks/                      <span class="hljs-comment"># 自定义React Hooks</span><br>│   │   ├── use-localstorage-state.ts   <span class="hljs-comment"># localStorage状态管理Hook</span><br>│   │   └── use_React_hotkeys_management.ts <span class="hljs-comment"># 快捷键管理Hook</span><br>│   ├── lib/                        <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   │   ├── AddElementCommand.ts    <span class="hljs-comment"># 添加元素命令实现</span><br>│   │   ├── RemoveElementCommand.ts <span class="hljs-comment"># 删除元素命令实现</span><br>│   │   ├── UndoRedoManager.ts      <span class="hljs-comment"># 撤销重做管理器实现</span><br>│   │   ├── UpdateElementCommand.ts <span class="hljs-comment"># 更新元素命令实现</span><br>│   │   ├── UpdateElementPropertyCommand.ts <span class="hljs-comment"># 更新元素属性命令实现</span><br>│   │   ├── constants.ts            <span class="hljs-comment"># 常量定义文件</span><br>│   │   ├── env.ts                  <span class="hljs-comment"># 环境变量配置</span><br>│   │   ├── minimapUtils.ts         <span class="hljs-comment"># 小地图工具函数</span><br>│   │   └── utils.ts                <span class="hljs-comment"># 通用工具函数</span><br>│   ├── pages/                      <span class="hljs-comment"># 页面组件目录</span><br>│   │   ├── auth/                   <span class="hljs-comment"># 认证相关页面</span><br>│   │   │   ├── Login.tsx           <span class="hljs-comment"># 登录页面实现</span><br>│   │   │   └── Register.tsx        <span class="hljs-comment"># 注册页面实现</span><br>│   │   ├── canvas/                 <span class="hljs-comment"># 画布主页面</span><br>│   │   │   ├── Pixi_STM_modules/   <span class="hljs-comment"># Pixi.js状态管理模块</span><br>│   │   │   │   ├── core/           <span class="hljs-comment"># 核心类和初始化逻辑</span><br>│   │   │   │   │   ├── Core_StageManager.ts    <span class="hljs-comment"># 核心舞台管理器</span><br>│   │   │   │   │   ├── ElementRender.ts        <span class="hljs-comment"># 元素渲染器</span><br>│   │   │   │   │   ├── TF_controler_Renderer.ts <span class="hljs-comment"># 变换控制器渲染器</span><br>│   │   │   │   │   └── types.ts                <span class="hljs-comment"># 核心类型定义</span><br>│   │   │   │   ├── interaction/    <span class="hljs-comment"># 交互处理模块</span><br>│   │   │   │   │   ├── Base_InteractionHandler.ts   <span class="hljs-comment"># 基础交互处理器</span><br>│   │   │   │   │   └── Stage_InteractionHandler.ts  <span class="hljs-comment"># 舞台交互处理器</span><br>│   │   │   │   ├── shared/         <span class="hljs-comment"># 共享类型定义</span><br>│   │   │   │   │   └── types.ts    <span class="hljs-comment"># 共享类型定义文件</span><br>│   │   │   │   ├── utils/          <span class="hljs-comment"># 工具函数目录</span><br>│   │   │   │   │   ├── commandUtils.ts      <span class="hljs-comment"># 命令工具函数</span><br>│   │   │   │   │   ├── cursorUtils.ts       <span class="hljs-comment"># 光标工具函数</span><br>│   │   │   │   │   ├── destroyUtils.ts      <span class="hljs-comment"># 销毁工具函数</span><br>│   │   │   │   │   ├── dragUtils.ts         <span class="hljs-comment"># 拖拽工具函数</span><br>│   │   │   │   │   ├── drawingUtils.ts      <span class="hljs-comment"># 绘图工具函数</span><br>│   │   │   │   │   ├── eraserUtils.ts       <span class="hljs-comment"># 橡皮擦工具函数</span><br>│   │   │   │   │   ├── geometryUtils.ts     <span class="hljs-comment"># 几何工具函数</span><br>│   │   │   │   │   ├── guidelineUtils.ts    <span class="hljs-comment"># 辅助线工具函数</span><br>│   │   │   │   │   ├── interactionUtils.ts  <span class="hljs-comment"># 交互工具函数</span><br>│   │   │   │   │   ├── renderUtils.ts       <span class="hljs-comment"># 渲染工具函数</span><br>│   │   │   │   │   ├── resizeUtils.ts       <span class="hljs-comment"># 调整大小工具函数</span><br>│   │   │   │   │   ├── rotationUtils.ts     <span class="hljs-comment"># 旋转工具函数</span><br>│   │   │   │   │   ├── scaleUtils.ts        <span class="hljs-comment"># 缩放工具函数</span><br>│   │   │   │   │   ├── selectionUtils.ts    <span class="hljs-comment"># 选择工具函数</span><br>│   │   │   │   │   └── stateUtils.ts        <span class="hljs-comment"># 状态工具函数</span><br>│   │   │   │   └── STM_modules.md  <span class="hljs-comment"># 状态管理模块说明文档</span><br>│   │   │   ├── Pixi_stageManager.ts    <span class="hljs-comment"># Pixi舞台管理器入口</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 画布页面入口文件</span><br>│   │   ├── home/                   <span class="hljs-comment"># 主页</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 主页内容组件</span><br>│   │   │   │   └── AKN.tsx         <span class="hljs-comment"># AKN内容组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 主页入口文件</span><br>│   │   ├── intro/                  <span class="hljs-comment"># 介绍页面</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 介绍页面实现</span><br>│   │   └── room/                   <span class="hljs-comment"># 房间管理页面</span><br>│   │       └── RoomManagement.tsx  <span class="hljs-comment"># 房间管理页面实现</span><br>│   ├── router/                     <span class="hljs-comment"># 路由配置目录</span><br>│   │   └── router.tsx              <span class="hljs-comment"># 路由配置实现</span><br>│   ├── stores/                     <span class="hljs-comment"># 状态存储目录(Zustand)</span><br>│   │   ├── canvasStore.ts          <span class="hljs-comment"># 画布状态存储</span><br>│   │   ├── persistenceStore.ts     <span class="hljs-comment"># 持久化状态存储</span><br>│   │   └── themeStore.ts           <span class="hljs-comment"># 主题状态存储</span><br>│   ├── app.tsx                     <span class="hljs-comment"># 应用根组件</span><br>│   ├── main.tsx                    <span class="hljs-comment"># 应用入口文件</span><br>│   └── vite-env.d.ts               <span class="hljs-comment"># Vite环境声明文件</span><br>├── README.md                       <span class="hljs-comment"># 项目说明文档</span><br>├── components.json                 <span class="hljs-comment"># 组件配置文件</span><br>├── index.html                      <span class="hljs-comment"># HTML入口文件</span><br>├── lint-staged.config.js           <span class="hljs-comment"># Lint-staged配置</span><br>├── package.json                    <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js               <span class="hljs-comment"># PostCSS配置</span><br>├── tailwind.config.js              <span class="hljs-comment"># Tailwind CSS配置</span><br>├── transmart.config.ts             <span class="hljs-comment"># Transmart配置</span><br>├── tsconfig.json                   <span class="hljs-comment"># TypeScript配置</span><br>├── tsconfig.node.json              <span class="hljs-comment"># Node.js TypeScript配置</span><br>└── vite.config.ts                  <span class="hljs-comment"># Vite构建配置</span><br></code></pre></td></tr></table></figure><h3 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h3><p>项目采用数据驱动视图（Data-Driven View）模式，使用<strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>的三层架构</p><p>React 只负责 UI 和事件入口<br>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）<br>PixiJS 层只做”渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建<br>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</p><p>项目主要划分为三个层次：渲染层、状态管理层和逻辑层，来实现关注点分离，提高代码的可维护性和可扩展性。</p><h4 id="渲染层"><a href="#渲染层" class="headerlink" title="渲染层"></a><strong>渲染层</strong></h4><p>主要由 PixiJS (WebGL) 负责处理图形渲染，包括创建、更新和删除图形对象。这一层负责将状态管理层的数据转换为可视化的图形元素，并处理用户的交互操作，如拖拽、缩放和旋转等</p><h4 id="状态管理层"><a href="#状态管理层" class="headerlink" title="状态管理层"></a><strong>状态管理层</strong></h4><p>采用 Zustand 管理 JSON 画布数据。<br>先定义一个 CanvasState 接口（JSON 数据结构，包含 id, type, x, y, width, height 等属性）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span> <span class="hljs-comment">// 当前工具类型</span><br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt; <span class="hljs-comment">// 画布元素集合</span><br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[] <span class="hljs-comment">// 选中元素ID列表</span><br>  <span class="hljs-attr">editingId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 正在编辑的元素ID</span><br>  <span class="hljs-attr">clipboard</span>: <span class="hljs-title class_">CanvasElement</span>[] | <span class="hljs-literal">null</span> <span class="hljs-comment">// 剪贴板数据</span><br>  <span class="hljs-attr">pasteOffset</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 粘贴偏移计数</span><br>  <span class="hljs-attr">currentStyle</span>: {<br>    <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-comment">// ... 其他样式属性</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p>使用 Zustand 状态管理库，其中 elements 被定义为 Record<string, CanvasElement="">类型，表示一个以 id 为键，CanvasElement 为值的对象，用于存储画布上的所有元素。更新元素时使用 structuredClone 函数来克隆状态数据。后续持久化存储和撤销重做机制也是基于这一套状态管理来实现。这一层作为数据核心，主要维护画布上所有元素的状态信息，通过集中管理状态，确保了数据的一致性，便于后续的协同编辑和撤销重做功能的开发。</string,></p><h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a><strong>逻辑层</strong></h4><p>核心是 StageManagerCore 类，通过 StageManagerState 接口管理交互状态，包括当前交互模式、起始位置、当前元素 ID、初始元素状态等，处理多种交互模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">idle - 空闲状态<br>panning - 画布平移<br>selecting - 选择元素<br>dragging - 拖拽元素<br>resizing - 调整元素大小<br>drawing - 绘制元素<br>texting - 文本编辑<br>erasing - 擦除元素<br></code></pre></td></tr></table></figure><p>处理多种元素操作逻辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建元素 - 根据不同工具类型创建相应元素<br>选择元素 - 支持单选和多选<br>拖拽元素 - 记录初始状态，计算偏移量<br>调整大小 - 通过控制手柄调整元素尺寸<br>删除元素 - 通过橡皮擦工具删除元素<br></code></pre></td></tr></table></figure><p>通过这种方式来实现面向对象编程并封装业务逻辑，提高代码的可维护性，利用后续拓展</p><hr><h3 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h3><p class='item-img' data-src='./assets/image-20251123121234358.png'><img src="./assets/image-20251123121234358.png" alt="image-20251123121234358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互类型}<br>    B --&gt;|创建元素| C[StageManagerCore.onPointerDown]<br>    B --&gt;|拖拽元素| D[StageManagerCore.onPointerMove]<br>    B --&gt;|调整大小| E[StageManagerCore.onHandleDown]<br>    B --&gt;|选择元素| F[StageManagerCore.onPointerUp]<br><br>    C --&gt; G[Zustand Store.addElement]<br>    D --&gt; H[Zustand Store.updateElement]<br>    E --&gt; I[Zustand Store.updateElement]<br>    F --&gt; J[Zustand Store.setSelected]<br><br>    G --&gt; K[Zustand 状态更新]<br>    H --&gt; K<br>    I --&gt; K<br>    J --&gt; K<br><br>    K --&gt; L{状态变化}<br>    L --&gt;|元素变化| M[ElementRenderer.renderElements]<br>    L --&gt;|选择变化| N[TransformerRenderer.renderTransformer]<br><br>    M --&gt; O[PixiJS 图形渲染]<br>    N --&gt; O<br><br>    O --&gt; P[用户看到更新结果]<br><br>    K --&gt; Q[Zustand 持久化]<br>    Q --&gt; R[本地存储/IndexedDB]<br><br>    K --&gt; S[撤销/重做管理]<br>    S --&gt; T[命令栈管理]<br><br>    style A fill:#e1f5fe<br>    style O fill:#e8f5e8<br>    style K fill:#fff3e0<br>    style Q fill:#fce4ec<br></code></pre></td></tr></table></figure><p>流程如下：</p><h4 id="用户交互输入"><a href="#用户交互输入" class="headerlink" title="用户交互输入"></a>用户交互输入</h4><p>所有用户交互事件由 StageManagerCore 处理<br>用户通过鼠标、键盘等方式与画布进行交互：</p><ul><li>创建新元素（点击工具栏选择图形类型后在画布上绘制）</li><li>拖拽元素（选中元素后拖动）</li><li>调整元素大小（拖拽元素控制点）</li><li>选择元素（点击或框选元素）</li></ul><h4 id="创建元素流程"><a href="#创建元素流程" class="headerlink" title="创建元素流程"></a>创建元素流程</h4><ol><li>用户在画布上按下鼠标开始绘制</li><li><a href="">onPointerDown</a>捕获事件，创建新元素</li><li>调用 Zustand store 的<a href="">addElement</a>方法添加元素</li></ol><blockquote><p>创建元素时的中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="拖拽元素流程"><a href="#拖拽元素流程" class="headerlink" title="拖拽元素流程"></a>拖拽元素流程</h4><ol><li>用户按下并拖动已选中的元素</li><li><a href="">onPointerMove</a>持续捕获鼠标移动事件</li><li>实时调用 Zustand store 的<a href="">updateElement</a>更新元素位置</li></ol><blockquote><p>拖拽元素时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="调整大小流程"><a href="#调整大小流程" class="headerlink" title="调整大小流程"></a>调整大小流程</h4><ol><li>用户拖拽元素的控制点（resize handle）</li><li><a href="">onHandleDown</a>捕获控制点拖拽事件</li><li><a href="">onPointerMove</a>计算缩放比例并更新元素大小</li><li>调用 Zustand store 的<a href="">updateElement</a>更新元素属性</li></ol><blockquote><p>调整元素大小时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="交互结束处理"><a href="#交互结束处理" class="headerlink" title="交互结束处理"></a>交互结束处理</h4><ol><li>用户释放鼠标按键，<a href="">onPointerUp</a>处理交互结束,解锁撤销/重做管理器</li><li>创建相应的命令（<a href="">UpdateElementCommand</a>并添加到命令栈中</li><li>清理临时状态</li></ol><h4 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h4><p>Zustand 作为全局状态管理器，处理所有状态更新：</p><ol><li><strong>状态更新</strong>：自定义一套<a href="">originalSet</a>方法更新状态</li><li><strong>撤销/重做处理</strong>：创建状态快照并生成命令对象</li><li><strong>状态订阅</strong>：通知所有订阅者状态变化</li></ol><h4 id="渲染更新"><a href="#渲染更新" class="headerlink" title="渲染更新"></a>渲染更新</h4><p>Zustand 状态变化触发 StageManagerCore 的订阅回调：</p><ol><li><a href="">ElementRenderer.renderElements</a> 根据元素数据更新 PixiJS 图形对象</li><li><a href="">TransformerRenderer.renderTransformer</a> 更新选中元素的变换控制器</li><li>PixiJS 自动进行渲染</li></ol><h4 id="撤销-重做管理"><a href="#撤销-重做管理" class="headerlink" title="撤销/重做管理"></a>撤销/重做管理</h4><p>通过命令模式实现撤销/重做功能：</p><ol><li>每个操作生成对应的命令对象（<a href="">UpdateElementCommand</a>、<a href="">SnapshotCommand</a>等）</li><li>命令对象保存操作前后的状态快照</li><li>通过<a href="">UndoRedoManager</a>管理命令栈，实现撤销和重做功能</li></ol><h4 id="数据持久化阶段"><a href="#数据持久化阶段" class="headerlink" title="数据持久化阶段"></a>数据持久化阶段</h4><p>Zustand 状态变化同时触发数据持久化：</p><ol><li>状态通过<a href="">persist</a>中间件自动保存到本地存储</li><li>数据存储在 IndexedDB 中，来支持离线使用</li></ol><blockquote><p>这一块还在写</p></blockquote><hr><h3 id="设计的相关考虑"><a href="#设计的相关考虑" class="headerlink" title="设计的相关考虑"></a>设计的相关考虑</h3><p><strong>解耦</strong>：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展</p><p><strong>便于后续的协同编辑</strong>：实现多人协同，要监听 WebSocket 消息，然后更新 Zustand Store。StageManager 可以去监听到 Store 的变化，并作出相应的渲染更新</p><p><strong>对撤销/重做的实现</strong>：因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照</p><p><strong>序列化/反序列化</strong>：保存项目只需 JSON.stringify(store.elements)</p><h4 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h4><p>【待补充】</p><h2 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h2><p>部署地址：<a href="https://zhongye1.github.io/BDdraw_DEV/">https://zhongye1.github.io/BDdraw_DEV/</a></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h4 id="【P0】基础渲染"><a href="#【P0】基础渲染" class="headerlink" title="【P0】基础渲染"></a><del>【P0】基础渲染</del></h4><ul><li><del>支持图形渲染，需要支持至少 3 种不同图形，比如矩形、圆角矩形、圆形、三角形等。需要支持以下图形属性：</del><ul><li><del>背景色（background）</del></li><li><del>边框宽度（border-width）</del></li><li><del>边框颜色（border-color）</del></li></ul></li><li><del>支持图片渲染，需要支持 png、jpeg 格式，支持设置三种简单滤镜</del></li><li><del>支持富文本文字渲染，需要支持以下文本属性：</del><ul><li><del>字体（font-family）</del></li><li><del>字号（font-size）</del></li><li><del>颜色（color）</del></li><li><del>背景色（background）</del></li><li><del>BIUS（加粗、斜体、下划线、删除线）</del></li></ul></li></ul><h4 id="【P0】画布交互"><a href="#【P0】画布交互" class="headerlink" title="【P0】画布交互"></a><del>【P0】画布交互</del></h4><ul><li><del>支持无限画布的缩放、滚动、拖拽</del><ul><li><del>支持无限画布滚动条</del></li><li><del>支持无限画布的 minimap 功能</del></li></ul></li><li><del>支持选区功能：</del><ul><li><del>点击选中单个元素</del></li><li><del>框选选中多个元素</del></li></ul></li><li><del>支持数据持久化，每次操作后自动保存数据，刷新页面数据仍然存在</del></li><li><del>快捷键复制选中元素</del></li><li><del>支持辅助线功能</del></li></ul><h4 id="【P0】调参工具栏"><a href="#【P0】调参工具栏" class="headerlink" title="【P0】调参工具栏"></a><del>【P0】调参工具栏</del></h4><ul><li><del>浮动工具栏</del><ul><li><del>当选中文本元素时出现在上方，支持设置不同文本属性</del>（做了个编辑器）</li><li><del>当选中图形元素时出现在上方，支持设置不同图形属性</del></li><li><del>选中文本元素的部分文字时也能够出现，支持设置局部文本的文本属性</del>（编辑器内编辑可实现）</li></ul></li></ul><h4 id="【P0】元素编辑"><a href="#【P0】元素编辑" class="headerlink" title="【P0】元素编辑"></a><del>【P0】元素编辑</del></h4><ul><li><del>支持双击文本进入编辑，可以输入/删除文本内容</del></li><li><del>支持对选中元素（单个或多个）删除</del></li><li><del>支持对选中元素（单个或多个）拖拽</del></li><li><del>支持对选中元素（单个或多个）缩放</del></li><li><del>支持对选中元素（单个或多个）旋转</del></li><li><del>支持对多个元素进行组合操作，组合可以嵌套</del></li><li><del>支持对多个元素进行打组、解组</del><del>(组操作 bug 复现了，目前在修)</del>（已修复）</li></ul><h4 id="【P0】性能优化"><a href="#【P0】性能优化" class="headerlink" title="【P0】性能优化"></a><del>【P0】性能优化</del></h4><ul><li><del>画布存在 100 个元素，打开页面到渲染完成 &lt; 3s</del></li><li><del>同时操作 100 个元素，FPS 50+</del></li></ul><h4 id="【P1】协同"><a href="#【P1】协同" class="headerlink" title="【P1】协同"></a><del>【P1】协同</del></h4><ul><li><del>支持 undo &amp; redo 操作</del> <del>（大体实现了，可能要修一下 undo，redo 栈，有个不能稳定复现的 bug）</del>（已实现）</li><li><del>支持协同编辑，多人打开同一个画布可以协同编辑</del> (写了个 Node.js 后端)</li><li><del>支持离线编辑，断网后仍然可以对画布编辑，恢复网络后自动提交数据</del>（IndexedDB）</li></ul><blockquote><p>各模块的技术文档补充中<br>此文档最后编辑于 2025.11.27<br>项目开发中，欢迎提 issue 和 pr</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BDdraw-DEV&quot;&gt;&lt;a href=&quot;#BDdraw-DEV&quot; class=&quot;headerlink&quot; title=&quot;BDdraw_DEV&quot;&gt;&lt;/a&gt;BDdraw_DEV&lt;/h1&gt;&lt;p&gt;代码仓库：&lt;br&gt;&lt;a href=&quot;https://github.com/Z</summary>
      
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="excalidraw" scheme="https://zhongye1.github.io/Arknight-notes/tags/excalidraw/"/>
    
    <category term="github" scheme="https://zhongye1.github.io/Arknight-notes/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-29-JavaScript中的数组方法与栈（Stack）和队列（Queue）的实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/28254.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/28254.html</id>
    <published>2025-11-29T08:58:15.000Z</published>
    <updated>2025-12-27T07:27:06.557Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能</p><p>这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在<strong>两端</strong>高效操作的能力</p><p>先简单回顾一下这四种数组方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>操作位置</th><th>操作类型</th><th>返回值</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>push()</code></td><td>尾部</td><td>添加</td><td>新长度</td><td>O(1)</td></tr><tr><td><code>pop()</code></td><td>尾部</td><td>删除</td><td>被删除元素</td><td>O(1)</td></tr><tr><td><code>unshift()</code></td><td>头部</td><td>添加</td><td>新长度</td><td>O(n)</td></tr><tr><td><code>shift()</code></td><td>头部</td><td>删除</td><td>被删除元素</td><td>O(n)</td></tr></tbody></table></div><h3 id="1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）"><a href="#1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）" class="headerlink" title="1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）"></a>1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）</h3><p>主要使用数组的<strong>末尾</strong>操作实现：</p><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入栈（push）</td><td>array.push(item)</td><td>stack.push(1)</td><td>O(1)</td></tr><tr><td>出栈（pop）</td><td>array.pop()</td><td>const item = stack.pop()</td><td>O(1)</td></tr></tbody></table></div><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> stack = [];<br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// [1]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// [1, 2]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack);        <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><h3 id="2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）"><a href="#2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）" class="headerlink" title="2. 实现队列（Queue）——先进先出（FIFO，First In First Out）"></a>2. 实现队列（Queue）——先进先出（FIFO，First In First Out）</h3><h4 id="方式一：头部删除-尾部插入"><a href="#方式一：头部删除-尾部插入" class="headerlink" title="方式一：头部删除 + 尾部插入"></a>方式一：<strong>头部删除 + 尾部插入</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队（enqueue）</td><td>array.push(item)</td><td>queue.push(1)</td><td>O(1)</td></tr><tr><td>出队（dequeue）</td><td>array.shift()</td><td>const item = queue.shift()</td><td>O(n)</td></tr></tbody></table></div><p>问题：shift() 会导致数组所有元素向前移动，时间复杂度为 O(n)，频繁操作时性能很差</p><h4 id="方式二：尾部插入-头部删除"><a href="#方式二：尾部插入-头部删除" class="headerlink" title="方式二：尾部插入 + 头部删除"></a>方式二：<strong>尾部插入 + 头部删除</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队</td><td>array.unshift(item)</td><td>queue.unshift(1)</td><td>O(n)</td></tr><tr><td>出队</td><td>array.pop()</td><td>const item = queue.pop()</td><td>O(1)</td></tr></tbody></table></div><p>同样存在 O(n) 操作</p><p>如果需要高效队列，可以使用<strong>双端队列</strong>实现或第三方库，有几种方式</p><ol><li><strong>使用两个数组模拟</strong>（常见面试实现）：<ul><li>一个栈用于入队，一个栈用于出队，需要时倒腾</li></ul></li><li><strong>使用 JavaScript 的 Deque（双端队列）库</strong>：<ul><li>如 js-deque 或其他库，支持 O(1) 的头尾操作</li></ul></li><li><strong>ES6+ 原生替代</strong>：虽然没有内置 Queue，但可以用 Array + 手动索引模拟环形队列（较复杂）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能&lt;/p&gt;
&lt;p&gt;这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在&lt;strong&gt;两端&lt;/str</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
</feed>
