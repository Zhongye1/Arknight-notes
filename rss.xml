<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes|笔记站</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2025-09-28T06:12:05.140Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新建</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/28571.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/28571.html</id>
    <published>2025-09-28T06:11:54.000Z</published>
    <updated>2025-09-28T06:12:05.140Z</updated>
    
    <content type="html"><![CDATA[<p>–</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;–&lt;/p&gt;
</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次配置Obsidian配合Hexo写博客</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/t2zf3s.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/t2zf3s.html</id>
    <published>2025-09-22T08:47:52.000Z</published>
    <updated>2025-09-22T10:44:28.442Z</updated>
    
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>利用chrome F12 测试应用实践详解</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/%3C%%20tp.user.get_url()%20%%3E.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/%3C%%20tp.user.get_url()%20%%3E.html</id>
    <published>2025-06-10T01:54:31.944Z</published>
    <updated>2025-09-22T08:21:07.160Z</updated>
    
    <content type="html"><![CDATA[<p>首先介绍Chrome开发者工具中，调试时使用最多的三个功能页面是：<a href="https://zhida.zhihu.com/search?content_id=119003541&content_type=Article&match_order=1&q=%E5%85%83%E7%B4%A0&zhida_source=entity">元素</a>（ELements）、<a href="https://zhida.zhihu.com/search?content_id=119003541&content_type=Article&match_order=1&q=%E6%8E%A7%E5%88%B6%E5%8F%B0&zhida_source=entity">控制台</a>（Console）、<a href="https://zhida.zhihu.com/search?content_id=119003541&content_type=Article&match_order=1&q=%E6%BA%90%E4%BB%A3%E7%A0%81&zhida_source=entity">源代码</a>（Sources），此外还有<a href="https://zhida.zhihu.com/search?content_id=119003541&content_type=Article&match_order=1&q=%E7%BD%91%E7%BB%9C&zhida_source=entity">网络</a>（Network）等。</p><p class='item-img' data-src='https://pic3.zhimg.com/v2-7b3aa7ae78cff19d9f3f8902027b271e_1440w.jpg'><img src="https://pic3.zhimg.com/v2-7b3aa7ae78cff19d9f3f8902027b271e_1440w.jpg"></p><ul><li>元素（Elements）：用于查看或修改HTML元素的属性、CSS属性、监听事件、断点等。</li><li>控制台（Console）：控制台一般用于执行一次性代码，查看JavaScript对象，查看调试日志信息或异常信息。</li><li>源代码（Sources）：该页面用于查看页面的HTML文件源代码、JavaScript源代码、CSS源代码，此外最重要的是可以调试JavaScript源代码，可以给JS代码添加断点等。</li><li>网络（Network）：网络页面主要用于查看header等与网络连接相关的信息。</li></ul><p><strong>1、元素（Elements）</strong></p><p>查看元素代码：点击如图</p><p class='item-img' data-src='https://picx.zhimg.com/v2-c55350fef2cc9847c9e88a00caffa2a1_1440w.png'><img src="https://picx.zhimg.com/v2-c55350fef2cc9847c9e88a00caffa2a1_1440w.png"></p><p>箭头（或用者用快捷键Ctrl+Shift+C）进入选择元素模式，然后从页面中选择需要查看的元素，然后可以在开发者工具元素（Elements）一栏中定位到该元素源代码的具体位置 。</p><p>查看元素属性：可从被定位的源码中查看部分，如class、src，也可在右边的侧栏中查看全部的属性，如下图位置查看</p><p class='item-img' data-src='https://pic3.zhimg.com/v2-0a485043e71f01c0be4e2212852d22c0_1440w.jpg'><img src="https://pic3.zhimg.com/v2-0a485043e71f01c0be4e2212852d22c0_1440w.jpg"></p><p>修改元素的代码与属性：可直接双击想要修改的部分，然后就进行修改，或者选中要修改部分后点击右键进行修改，如下图</p><p>**</p><p class='item-img' data-src='https://pica.zhimg.com/v2-60169f4ee8921f961300d6ea7002d388_1440w.png'><img src="https://pica.zhimg.com/v2-60169f4ee8921f961300d6ea7002d388_1440w.png"></p><p>**</p><p><strong>注意：这个修改也仅对当前的页面渲染生效，不会修改服务器的源代码，故而这个功能也是作为调试页面效果而使用。</strong></p><p>右边的侧栏个功能的介绍:如下图所示</p><p class='item-img' data-src='https://picx.zhimg.com/v2-dd0bbf6c9cb776b8eff94db3c387c019_1440w.jpg'><img src="https://picx.zhimg.com/v2-dd0bbf6c9cb776b8eff94db3c387c019_1440w.jpg"></p><p><strong>2、控制台（Console）</strong></p><ul><li>查看JS对象的及其属性</li><li>执行JS语句</li><li>查看控制台日志：当网页的JS代码中使用了console.log()函数时，该函数输出的日志信息会在控制台中显示。日志信息一般在开发调试时启用，而当正式上线后，一般会将该函数去掉。</li></ul><p>**3、源代码（Sources）**其主要功能如下介绍</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-cf61d4c59d1620e9a96f74ab84d2d027_1440w.jpg'><img src="https://pic4.zhimg.com/v2-cf61d4c59d1620e9a96f74ab84d2d027_1440w.jpg"></p><p><strong>4、网络（Network）大体功能如下：</strong></p><p class='item-img' data-src='https://pic4.zhimg.com/v2-ff058011fb5c4df1e1a558feb67df545_1440w.jpg'><img src="https://pic4.zhimg.com/v2-ff058011fb5c4df1e1a558feb67df545_1440w.jpg"></p><ul><li>打开浏览器,按f12,点击Network,可以查看相关网络请求信息,记得是打开f12之后再刷新页面才会开始记录的</li></ul><p class='item-img' data-src='https://pic3.zhimg.com/v2-e8b63050aa5aee1271250d45f940024e_1440w.jpg'><img src="https://pic3.zhimg.com/v2-e8b63050aa5aee1271250d45f940024e_1440w.jpg"></p><ul><li>查看Network基本信息,请求了哪些地址及每个URL的网络相关请求信息都可以看的到URL，响应状态码，响应数据类型，响应数据大小，响应时间</li></ul><p class='item-img' data-src='https://pic1.zhimg.com/v2-5a3eb9a4f6553aaf12e2e715000c7f7a_1440w.jpg'><img src="https://pic1.zhimg.com/v2-5a3eb9a4f6553aaf12e2e715000c7f7a_1440w.jpg"></p><ul><li>请求URL可进行筛选和分类，选择不同分类,查看请求URL,方便查找</li></ul><p class='item-img' data-src='https://pic2.zhimg.com/v2-fff49ec5c4761f0e17fa70f47d4093c7_1440w.jpg'><img src="https://pic2.zhimg.com/v2-fff49ec5c4761f0e17fa70f47d4093c7_1440w.jpg"></p><ul><li>也可以直接Filter搜索查询相关URL，可以输入关键字或者正则表达式进行查询</li></ul><p class='item-img' data-src='https://pic1.zhimg.com/v2-9f813a3d5a045e7771de0052958c1e84_1440w.jpg'><img src="https://pic1.zhimg.com/v2-9f813a3d5a045e7771de0052958c1e84_1440w.jpg"></p><ul><li>Waterfall能分割重要的请求耗时,查看具体请求耗时在哪个地方,鼠标指到相关区域可以看到具体耗时</li></ul><p class='item-img' data-src='https://pic1.zhimg.com/v2-443fe9f7eabd239b9762e4701ab44a24_1440w.jpg'><img src="https://pic1.zhimg.com/v2-443fe9f7eabd239b9762e4701ab44a24_1440w.jpg"></p><ul><li>我们具体分析下里面每个各代表什么意思,分别耗时多少,通过这个来分析服务器到底是哪个环节出了问题</li></ul><ol><li>Queueing 是排队的意思</li><li>Stalled 是阻塞 请求访问该URL的主机是有并发和连接数限制的,必须要等之前的执行才能执行之后的,这段时间的耗时</li><li>DNS Lookup 是指域名解析所耗时间</li><li>Initial connection 初始化连接时间,这里一般是TCP 3次连接握手时间</li><li>SSL https特有,是一种协议</li><li>Request sent 发送请求所消耗的时间</li><li>Waiting 等待响应时间,这里一般是最耗时的</li><li>Content Download 下载内容所需要消耗的时间</li></ol><p><strong>请求文件具体说明</strong></p><p class='item-img' data-src='https://pica.zhimg.com/v2-457e994216ffe2626cd07c84a0bdf4d4_1440w.jpg'><img src="https://pica.zhimg.com/v2-457e994216ffe2626cd07c84a0bdf4d4_1440w.jpg"></p><p><strong>一共分为四个模块：</strong></p><ul><li>Header：面板列出资源的请求url、HTTP方法、响应状态码、请求头和响应头及它们各自的值、请求参数等等</li><li>Preview：预览面板，用于资源的预览。</li><li>Response：响应信息面板包含资源还未进行格式处理的内容</li><li>Timing：资源请求的详细信息花费时间</li></ul><p>转载自  <a href="https://zhuanlan.zhihu.com/p/138922503">chrome浏览器中 F12 功能的简单介绍 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先介绍Chrome开发者工具中，调试时使用最多的三个功能页面是：&lt;a href=&quot;https://zhida.zhihu.com/search?content_id=119003541&amp;content_type=Article&amp;match_order=1&amp;q=%E5%85</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33985.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33985.html</id>
    <published>2025-04-17T16:17:37.000Z</published>
    <updated>2025-04-22T07:35:17.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h1><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p><strong>栈</strong>：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。<br class='item-img' data-src='https://pic1.zhimg.com/80/v2-a1d987369534eb6c471da568be4aa5cd_720w.png'><img src="https://pic1.zhimg.com/80/v2-a1d987369534eb6c471da568be4aa5cd_720w.png" alt="img"><br><strong>栈顶</strong>（Top）：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>（Bottom)：固定的，不允许进行插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p><p>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</p><h3 id="栈的常见基本操作"><a href="#栈的常见基本操作" class="headerlink" title="栈的常见基本操作"></a>栈的常见基本操作</h3><p><strong>InitStack(&amp;S)</strong>：初始化一个空栈S</p><p><strong>StackEmpty(S)</strong>：判断一个栈是否为空，若栈为空则返回true，否则返回false</p><p><strong>Push(&amp;S, x)</strong>：进栈（栈的插入操作），若栈S未满，则将x加入使之成为新栈顶</p><p><strong>Pop(&amp;S, &amp;x)</strong>：出栈（栈的删除操作），若栈S非空，则弹出栈顶元素，并用x返回</p><p><strong>GetTop(S, &amp;x)</strong>：读栈顶元素，若栈S非空，则用x返回栈顶元素</p><p><strong>DestroyStack(&amp;S)</strong>：栈销毁，并释放S占用的存储空间（“&amp;”表示引用调用）</p><h1 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h1><h4 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h4><p>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br>若存储栈的长度为MAXSIZE，则栈顶位置top必须小于MAXSIZE。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。<br>栈的顺序存储结构可描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 5  </span><br><span class="hljs-comment">//定义栈中元素的最大个数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>&#123;</span><br>    <span class="hljs-type">int</span> data[MAXSIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure><p>若现在有一个栈，MAXSIZE是5，则栈的普通情况、空栈、满栈的情况分别如下图所示：</p><p class='item-img' data-src='https://picx.zhimg.com/80/v2-b667691c4e541ad1b4d77611d936ef7e_720w.png'><img src="https://picx.zhimg.com/80/v2-b667691c4e541ad1b4d77611d936ef7e_720w.png" alt="img"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack* S)</span>&#123; <br>    <span class="hljs-comment">//SqStack&amp; S 是 C++ 的引用参数，用于直接修改外部栈对象</span><br>    <span class="hljs-comment">//若用 C 语言，需改用指针（SqStack* S）</span><br>    S-&gt;top = <span class="hljs-number">-1</span>;             <span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要用 <code>S-&gt;top = -1</code>？</strong></p><p><strong>顺序栈的本质是一个数组</strong>，栈顶指针 <code>top</code> 表示当前栈顶元素在数组中的位置索引。<br>初始化时 <code>top = -1</code> 有</p><p><strong>空栈条件</strong>：<code>top == -1</code><br>当栈中没有元素时，<code>top</code> 指向数组的“前一个位置”（即无效索引），逻辑上表示“无元素”。</p><p><strong>入栈操作</strong></p><p>先让 <code>top++</code>，移动到下一个可用位置；将新元素存入 <code>data[top]</code>。<br>例如，第一次入栈时，<code>top</code> 从 <code>-1</code> 变为 <code>0</code>，元素存入 <code>data[0]</code>，对应数组的第一个索引。</p><p><strong>判断栈满</strong></p><p><strong>栈满条件</strong>：<code>top == MAX_SIZE - 1</code><br>如果数组大小为 <code>MAX_SIZE</code>，当 <code>top</code> 指向最后一个位置（即 <code>MAX_SIZE - 1</code>）时，表示栈已满。</p><h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack* S)</span>&#123;<br>    <span class="hljs-keyword">if</span>( S-&gt;top == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//栈中没有元素时，`top` 指向数组的“前一个位置”（即无效索引），逻辑上表示“无元素”</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>( S-&gt;top == MAXSIZE - <span class="hljs-number">1</span> )&#123; <span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <br>    &#125;<br>    S-&gt;top++ ;                  <span class="hljs-comment">//栈顶指针加1</span><br>    S-&gt;data[S-&gt;top] = x;         <span class="hljs-comment">//入栈,写入元素到新栈顶位置</span><br>    <span class="hljs-comment">//S-&gt;data[S-&gt;top]代表栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<span class="hljs-comment">//通过指针修改外部变量</span><br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无法出栈\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    S-&gt;top--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<span class="hljs-comment">//通过指针修改外部变量</span><br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无栈顶元素\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈顶元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>出栈和读栈顶元素操作需要返回两个信息：</p><ul><li><strong>是否成功</strong>（通过 <code>bool</code> 返回值）。</li><li><strong>得到的元素值</strong>（通过 <code>int* x</code> 指针参数）。</li></ul><h3 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 5  <span class="hljs-comment">// 示例栈容量设为5</span></span><br><br><span class="hljs-comment">//栈结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span> &#123;</span><br>    <span class="hljs-type">int</span> data[MAXSIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125; SqStack;<br><br><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    S-&gt;top = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;top == <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">// 判断栈满</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackFull</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;top == MAXSIZE - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackFull(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已满，无法入栈 %d\n&quot;</span>, x);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    S-&gt;top++;<br>    S-&gt;data[S-&gt;top] = x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;入栈元素: %d\n&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 出栈（通过指针返回栈顶元素）</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无法出栈\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    S-&gt;top--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">// 获取栈顶元素（通过指针返回）</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无栈顶元素\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈顶元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 打印栈内容（辅助函数）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintStack</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈内容 (从底到顶): &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= S-&gt;top; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, S-&gt;data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    SqStack S;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 用于接收出栈/栈顶元素的值</span><br><br>    InitStack(&amp;S);<br>    PrintStack(&amp;S);  <span class="hljs-comment">// 栈空</span><br><br>    <span class="hljs-comment">// 入栈测试</span><br>    Push(&amp;S, <span class="hljs-number">10</span>);<br>    Push(&amp;S, <span class="hljs-number">20</span>);<br>    Push(&amp;S, <span class="hljs-number">30</span>);<br>    Push(&amp;S, <span class="hljs-number">40</span>);<br>    Push(&amp;S, <span class="hljs-number">50</span>);   <span class="hljs-comment">// 栈满</span><br>    Push(&amp;S, <span class="hljs-number">60</span>);   <span class="hljs-comment">// 触发栈满报错</span><br>    PrintStack(&amp;S);  <span class="hljs-comment">// 10 20 30 40 50</span><br><br>    <span class="hljs-comment">// 获取栈顶</span><br>    GetTop(&amp;S, &amp;val);  <span class="hljs-comment">// 50</span><br><br>    <span class="hljs-comment">// 出栈测试</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 50出栈</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 40出栈</span><br>    PrintStack(&amp;S);    <span class="hljs-comment">// 10 20 30</span><br><br>    <span class="hljs-comment">// 继续出栈直到栈空</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 30</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 20</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 10</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 触发栈空报错</span><br>    PrintStack(&amp;S);    <span class="hljs-comment">// 栈空</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h1><p>采用<strong>链式存储</strong>的栈称为<strong>链栈</strong>，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头节点，<strong>Lhead</strong>指向栈顶元素</p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-2f84fc59716af6dc2a4bf3ca23f496d7_720w.webp'><img src="https://pic4.zhimg.com/80/v2-2f84fc59716af6dc2a4bf3ca23f496d7_720w.webp" alt="img"></p><p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top&#x3D;NULL的时候。</p><h4 id="链栈的结构定义："><a href="#链栈的结构定义：" class="headerlink" title="链栈的结构定义："></a>链栈的结构定义：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义链式栈的节点结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> data;                       <span class="hljs-comment">// 存储栈元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> * <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一节点的指针</span><br>&#125; LinkedStackNode, * LinkedStack;   <span class="hljs-comment">// 类型别名：LinkedStackNode表示节点，LinkedStack表示节点指针</span><br>LinkedStack top; <span class="hljs-comment">// 声明一个栈顶指针（本质是LinkedStackNode*类型）</span><br></code></pre></td></tr></table></figure><h4 id="初始化空栈"><a href="#初始化空栈" class="headerlink" title="初始化空栈"></a>初始化空栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br>LinkedStack <span class="hljs-title function_">Init_LinkedStack</span><span class="hljs-params">()</span>                                       <br>&#123;<br>LinkedStack top=(LinkedStackNode * )<span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>( LinkedStackNode));<br><span class="hljs-keyword">if</span>(top!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//申请空间成功</span><br>top-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置栈顶指针为空</span><br><span class="hljs-keyword">return</span> top;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判断栈空-1"><a href="#判断栈空-1" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判栈空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LinkedStack_Empty</span><span class="hljs-params">(LinkedStack top)</span>                            <br>&#123;<br><span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//检查栈顶指针的值 </span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//栈S为空，函数返回1</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Push_LinkedStack</span><span class="hljs-params">(LinkedStack top,elemtype x)</span>                     <br><span class="hljs-comment">//插入数据元素x为新的栈顶元素</span><br>&#123;<br>LinkedStackNode * node;<br>node=(LinkedStackNode * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkedStackNode));<br><span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//申请结点空间失败,插入失败，函数返回0</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>node-&gt;data=x;<span class="hljs-comment">//设置新结点的数据域</span><br>node-&gt;next=top-&gt;next;<span class="hljs-comment">//设置新结点的指针城</span><br>top-&gt;next=node;<span class="hljs-comment">//设置头结点指针城指向新的栈顶元素</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//插入成功，函数返回1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Pop_LinkedStack</span><span class="hljs-params">(LinkedStack top, elemtype *x)</span>                    <br>&#123;LinkedStackNode * node;<br><span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>node=top-&gt;next;<span class="hljs-comment">//将原栈顶数据元素弹出并赋给node</span><br>*x=node-&gt;data;<span class="hljs-comment">//将原栈顶数据元素的数据赋值给x</span><br>top-&gt;next=node-&gt;next;<span class="hljs-comment">//top指向链栈中的下一个数据元素</span><br><span class="hljs-built_in">free</span> (node);<span class="hljs-comment">//释放原栈顶数据元素所占的空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                <br>&#123; <br><span class="hljs-keyword">if</span>(top-&gt;next)<br>      &#123;<br>            <span class="hljs-keyword">return</span> top-&gt;next-&gt;data;<br><br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求栈长"><a href="#求栈长" class="headerlink" title="求栈长"></a>求栈长</h4><p>设置计数器，随top指针后移，计数器加1，直到遍历完所有元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求栈长</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                                       <br>&#123;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(top-&gt;next!=<span class="hljs-literal">NULL</span>) <br>&#123;<br>++count;<br>top=top-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码实现-1"><a href="#完整代码实现-1" class="headerlink" title="完整代码实现"></a>完整代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 定义链式栈的节点结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> data;                       <span class="hljs-comment">// 存储栈元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> * <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一节点的指针</span><br>&#125; LinkedStackNode, * LinkedStack;   <span class="hljs-comment">// 类型别名：LinkedStackNode表示节点，LinkedStack表示节点指针</span><br>LinkedStack top; <span class="hljs-comment">// 声明一个栈顶指针（本质是LinkedStackNode*类型）</span><br><br><span class="hljs-comment">//初始化</span><br>LinkedStack <span class="hljs-title function_">Init_LinkedStack</span><span class="hljs-params">()</span>                                       <br>&#123;<br>LinkedStack top=(LinkedStackNode * )<span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>( LinkedStackNode));<br><span class="hljs-keyword">if</span>(top!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//申请空间成功</span><br>top-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置栈顶指针为空</span><br><span class="hljs-keyword">return</span> top;<br>&#125;<br><br><span class="hljs-comment">//判栈空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LinkedStack_Empty</span><span class="hljs-params">(LinkedStack top)</span>                            <br>&#123;<br><span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//检查栈顶指针的值 </span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//栈S为空，函数返回1</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//入栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push_LinkedStack</span><span class="hljs-params">(LinkedStack top,elemtype x)</span>                     <br><span class="hljs-comment">//插入数据元素x为新的栈顶元素</span><br>&#123;<br>LinkedStackNode * node;<br>node=(LinkedStackNode * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkedStackNode));<br><span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//申请结点空间失败,插入失败，函数返回0</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>node-&gt;data=x;<span class="hljs-comment">//设置新结点的数据域</span><br>node-&gt;next=top-&gt;next;<span class="hljs-comment">//设置新结点的指针城</span><br>top-&gt;next=node;<span class="hljs-comment">//设置头结点指针城指向新的栈顶元素</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//插入成功，函数返回1</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//求栈长</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                                       <br>&#123;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(top-&gt;next!=<span class="hljs-literal">NULL</span>) <br>&#123;<br>++count;<br>top=top-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//出栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop_LinkedStack</span><span class="hljs-params">(LinkedStack top, elemtype *x)</span>                    <br>&#123;LinkedStackNode * node;<br><span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>node=top-&gt;next;<span class="hljs-comment">//将原栈顶数据元素弹出并赋给node</span><br>*x=node-&gt;data;<span class="hljs-comment">//将原栈顶数据元素的数据赋值给x</span><br>top-&gt;next=node-&gt;next;<span class="hljs-comment">//top指向链栈中的下一个数据元素</span><br><span class="hljs-built_in">free</span> (node);<span class="hljs-comment">//释放原栈顶数据元素所占的空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;  <br><br><span class="hljs-comment">//取栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                <br>&#123; <br><span class="hljs-keyword">if</span>(top-&gt;next)<br>      &#123;<br>            <span class="hljs-keyword">return</span> top-&gt;next-&gt;data;<br><br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//主函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i,t,x,a[<span class="hljs-number">20</span>];<br>LinkedStack top=Init_LinkedStack();<span class="hljs-comment">//初始化栈</span><br>x=LinkedStack_Empty(top);<span class="hljs-comment">//判栈空结果赋值给X</span><br><span class="hljs-keyword">if</span>(x=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈为空\n&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请依次输入5个数,开始入栈：\n&quot;</span>);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>Push_LinkedStack(top,a[i]);<br>x=GetTop_LinkedStack(top);<br><span class="hljs-keyword">if</span>(x!=<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈顶元素为%d\n&quot;</span>,x);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;入栈结束\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈长为%d\n&quot;</span>,Length_LinkedStack(top));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始出栈:\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>&#123;<br>Pop_LinkedStack(top,&amp;t);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,t);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈后栈长为%d\n&quot;</span>,Length_LinkedStack(top));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈的基本概念&quot;&gt;&lt;a href=&quot;#栈的基本概念&quot; class=&quot;headerlink&quot; title=&quot;栈的基本概念&quot;&gt;&lt;/a&gt;栈的基本概念&lt;/h1&gt;&lt;h3 id=&quot;栈的定义&quot;&gt;&lt;a href=&quot;#栈的定义&quot; class=&quot;headerlink&quot; title=&quot;栈</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表（链表）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/42928.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/42928.html</id>
    <published>2025-04-05T16:24:40.000Z</published>
    <updated>2025-04-17T16:55:19.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表（链式存储结构）"><a href="#链表（链式存储结构）" class="headerlink" title="链表（链式存储结构）"></a>链表（链式存储结构）</h2><p>链表又称单链表、链式存储结构，用于存储逻辑关系为“一对一”的数据。</p><p>和顺序表不同，使用链表存储数据，不强制要求数据在内存中集中存储，各个元素可以分散存储在内存中。例如，使用链表存储 {1,2,3}，各个元素在内存中的存储状态可能是：</p><p class='item-img' data-src='https://pic2.zhimg.com/v2-5d42c22a139067e60fadd7957ef2c383_b.jpg'><img src="https://pic2.zhimg.com/v2-5d42c22a139067e60fadd7957ef2c383_b.jpg" alt="动图封面"></p><p>可以看到，数据不仅没有集中存放，在内存中的存储次序也是混乱的。那么，链表是如何存储数据间逻辑关系的呢？</p><p>链表存储数据间逻辑关系的实现方案是：为每一个元素配置一个指针，每个元素的指针都指向自己的直接后继元素，如下图所示：</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-fdb02aabf90a9eb2d64c5e8a06feb053_b.jpg'><img src="https://pic4.zhimg.com/v2-fdb02aabf90a9eb2d64c5e8a06feb053_b.jpg" alt="动图封面"></p><p>显然，我们只需要记住元素 1 的存储位置，通过它的指针就可以找到元素 2，通过元素 2 的指针就可以找到元素 3，以此类推，各个元素的先后次序一目了然。</p><p>像图 2 这样，数据元素随机存储在内存中，通过指针维系数据之间“一对一”的逻辑关系，这样的存储结构就是链表。</p><h3 id="结点（节点）"><a href="#结点（节点）" class="headerlink" title="结点（节点）"></a>结点（节点）</h3><blockquote><p>很多教材中，也将“结点”写成“节点”，它们是一个意思。</p></blockquote><p>在链表中，每个数据元素都配有一个指针，这意味着，链表上的每个“元素”都长下图这个样子：</p><p class='item-img' data-src='https://pic3.zhimg.com/v2-375eac6ce04146b28224cf447e00b012_b.jpg'><img src="https://pic3.zhimg.com/v2-375eac6ce04146b28224cf447e00b012_b.jpg" alt="动图封面"></p><p>数据域用来存储元素的值，指针域用来存放指针。数据结构中，通常将图 3 这样的整体称为结点。</p><p>也就是说，链表中实际存放的是一个一个的结点，数据元素存放在各个结点的数据域中。举个简单的例子，图 2 中 {1,2,3} 的存储状态用链表表示，如下图所示：</p><p class='item-img' data-src='https://pic1.zhimg.com/v2-6c920d117fb3d0a2bdcccfd3b002e20c_b.jpg'><img src="https://pic1.zhimg.com/v2-6c920d117fb3d0a2bdcccfd3b002e20c_b.jpg" alt="动图封面"></p><p>在 C 语言中，可以用结构体表示链表中的结点，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span>&#123;<br>    <span class="hljs-type">char</span> elem; <span class="hljs-comment">//代表数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span> * next; <span class="hljs-comment">//代表指针域，指向直接后继元素</span><br>&#125;Link;<br></code></pre></td></tr></table></figure><blockquote><p>我们习惯将结点中的指针命名为 next，因此指针域又常称为“Next 域”。</p></blockquote><h3 id="头结点、头指针和首元结点"><a href="#头结点、头指针和首元结点" class="headerlink" title="头结点、头指针和首元结点"></a>头结点、头指针和首元结点</h3><p>图 4 所示的链表并不完整，一个完整的链表应该由以下几部分构成：</p><ol><li>头指针：一个和结点类型相同的指针，它的特点是：永远指向链表中的第一个结点。上文提到过，我们需要记录链表中第一个元素的存储位置，就是用头指针实现。</li><li>结点：链表中的节点又细分为头结点、首元结点和其它结点：</li></ol><ul><li>头结点：某些场景中，为了方便解决问题，会故意在链表的开头放置一个空结点，这样的结点就称为头结点。也就是说，头结点是位于链表开头、数据域为空（不利用）的结点。</li><li>首元结点：指的是链表开头第一个存有数据的结点。</li><li>其他节点：链表中其他的节点。</li></ul><p>也就是说，一个完整的链表是由头指针和诸多个结点构成的。每个链表都必须有头指针，但头结点不是必须的。</p><p>例如，创建一个包含头结点的链表存储 {1,2,3}，如下图所示：</p><p class='item-img' data-src='https://pic1.zhimg.com/v2-f2b1f40c7ed8cb36d1c7f3215f7b5530_b.jpg'><img src="https://pic1.zhimg.com/v2-f2b1f40c7ed8cb36d1c7f3215f7b5530_b.jpg" alt="动图封面"></p><p>再次强调，头指针永远指向链表中的第一个结点。换句话说，如果链表中包含头结点，那么头指针指向的是头结点，反之头指针指向首元结点。</p><h3 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h3><p>创建一个链表，实现步骤如下：</p><ol><li>定义一个头指针；</li><li>创建一个头结点或者首元结点，让头指针指向它；</li><li>每创建一个结点，都令其直接前驱结点的指针指向它。</li></ol><p>例如，创建一个存储 {1,2,3,4} 且无头节点的链表，C 语言实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建首元结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">1</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向首元结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，创建一个存储 {1,2,3,4} 且含头节点的链表，则 C 语言实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建头结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">0</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向头结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表的使用"><a href="#链表的使用" class="headerlink" title="链表的使用"></a>链表的使用</h3><p>对于创建好的链表，我们可以依次获取链表中存储的数据，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">//链表中节点的结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span> &#123;<br>    <span class="hljs-type">int</span>  elem;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span>* next;<br>&#125;Link;<br><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建头结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">0</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向头结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Link* p)</span> </span>&#123;<br>    Link* temp = p;<span class="hljs-comment">//temp指针用来遍历链表</span><br>    <span class="hljs-comment">//只要temp指向结点的next值不是NULL，就执行输出语句。</span><br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        Link* f = temp;<span class="hljs-comment">//准备释放链表中的结点</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, temp-&gt;elem);<br>        temp = temp-&gt;next;<br>        <span class="hljs-built_in">free</span>(f);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化链表为：\n&quot;</span>);<br>    <span class="hljs-comment">//创建链表&#123;1,2,3,4&#125;</span><br>    p = <span class="hljs-built_in">initLink</span>();<br>    <span class="hljs-comment">//输出链表中的数据</span><br>    <span class="hljs-built_in">display</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序中创建的是带头结点的链表，头结点的数据域存储的是元素 0，因此最终的输出结果为：</p><blockquote><p>0 1 2 3 4</p></blockquote><p>如果不想输出头结点的值，可以将 p-&gt;next 作为实参传递给 display() 函数。</p><p>如果程序中创建的是不带头结点的链表，最终的输出结果应该是：</p><blockquote><p>1 2 3 4</p></blockquote><h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><p>学会创建链表之后，本节继续讲解链表的一些基本操作，包括向链表中添加数据、删除链表中的数据、查找和更改链表中的数据。</p><p>首先，创建一个带头结点的链表，链表中存储着 {1,2,3,4}：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链表中节点的结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span> &#123;<br>    <span class="hljs-type">int</span>  elem;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span>* next;<br>&#125;Link;<br><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建头结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">0</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向头结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表插入元素"><a href="#链表插入元素" class="headerlink" title="链表插入元素"></a>链表插入元素</h3><p>同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：</p><ul><li>插入到链表的头部，作为首元节点；</li><li>插入到链表中间的某个位置；</li><li>插入到链表的最末端，作为链表中最后一个结点；</li></ul><p>对于有头结点的链表，3 种插入元素的实现思想是相同的，具体步骤是：</p><ol><li>将新结点的 next 指针指向插入位置后的结点；</li><li>将插入位置前结点的 next 指针指向插入结点；</li></ol><p>例如，在链表 {1,2,3,4}的基础上分别实现在头部、中间、尾部插入新元素 5，其实现过程如下图所示：</p><p class='item-img' data-src='https://pica.zhimg.com/v2-2b74576c4133d98967e430da2a156c6e_b.jpg'><img src="https://pica.zhimg.com/v2-2b74576c4133d98967e430da2a156c6e_b.jpg" alt="动图封面"></p><p>从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem, <span class="hljs-type">int</span> add)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Link* c = <span class="hljs-literal">NULL</span>;<br>    Link* temp = p;<span class="hljs-comment">//创建临时结点temp</span><br>    <span class="hljs-comment">//首先找到要插入位置的上一个结点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add; i++) &#123;<br>        temp = temp-&gt;next;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置无效\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//创建插入结点c</span><br>    c = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    c-&gt;elem = elem;<br>    <span class="hljs-comment">//① 将新结点的 next 指针指向插入位置后的结点</span><br>    c-&gt;next = temp-&gt;next;<br>    <span class="hljs-comment">//② 将插入位置前结点的 next 指针指向插入结点；</span><br>    temp-&gt;next = c;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 1。</p><p>对于没有头结点的链表，在头部插入结点比较特殊，需要单独实现。</p><p class='item-img' data-src='https://pica.zhimg.com/v2-bc993f6cb9d4f6bfd732b0a341cfdf84_b.jpg'><img src="https://pica.zhimg.com/v2-bc993f6cb9d4f6bfd732b0a341cfdf84_b.jpg" alt="动图封面"></p><p>和 2)、3) 种情况相比，由于链表没有头结点，在头部插入新结点，此结点之前没有任何结点，实现的步骤如下：</p><ol><li>将新结点的指针指向首元结点；</li><li>将头指针指向新结点。</li></ol><p>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Link* <span class="hljs-title">insertElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem, <span class="hljs-type">int</span> add)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (add == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//创建插入结点c</span><br>        Link* c = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        c-&gt;elem = elem;<br>        c-&gt;next = p;<br>        p = c;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        Link* c = <span class="hljs-literal">NULL</span>;<br>        Link* temp = p;<span class="hljs-comment">//创建临时结点temp</span><br>        <span class="hljs-comment">//首先找到要插入位置的上一个结点</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add<span class="hljs-number">-1</span>; i++) &#123;<br>            temp = temp-&gt;next;<br>            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置无效\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//创建插入结点c</span><br>        c = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        c-&gt;elem = elem;<br>        <span class="hljs-comment">//向链表中插入结点</span><br>        c-&gt;next = temp-&gt;next;<br>        temp-&gt;next = c;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意当 add&#x3D;&#x3D;1 成立时，形参指针 p 的值会发生变化，因此需要它的新值作为函数的返回值返回。</p></blockquote><h3 id="链表删除元素"><a href="#链表删除元素" class="headerlink" title="链表删除元素"></a>链表删除元素</h3><p>从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除。</p><p>对于有头结点的链表来说，无论删除头部（首元结点）、中部、尾部的结点，实现方式都一样，执行以下三步操作：</p><ol><li>找到目标元素所在结点的直接前驱结点；</li><li>将目标结点从链表中摘下来;</li><li>手动释放结点占用的内存空间；</li></ol><p>从链表上摘除目标节点，只需找到该节点的直接前驱节点 temp，执行如下操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">temp-&gt;next=temp-&gt;next-&gt;next;<br></code></pre></td></tr></table></figure><p>例如，从存有 {1,2,3,4}的链表中删除存储元素 3 的结点，则此代码的执行效果如图 3 所示：</p><p class='item-img' data-src='https://pica.zhimg.com/v2-6d8f7d30515db53226312254da2db706_b.jpg'><img src="https://pica.zhimg.com/v2-6d8f7d30515db53226312254da2db706_b.jpg" alt="动图封面"></p><p>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p为原链表，elem 为要删除的目标元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    Link* del = <span class="hljs-literal">NULL</span>, *temp = p;<br>    <span class="hljs-type">int</span> find = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//1、找到目标元素的直接前驱结点</span><br>    <span class="hljs-keyword">while</span> (temp-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;next-&gt;elem == elem) &#123;<br>            find = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (find == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//删除失败</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//标记要删除的结点</span><br>        del = temp-&gt;next;<br>        <span class="hljs-comment">//2、将目标结点从链表上摘除</span><br>        temp-&gt;next = temp-&gt;next-&gt;next;<br>        <span class="hljs-comment">//3、释放目标结点</span><br>        <span class="hljs-built_in">free</span>(del);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不带头结点的链表，需要单独考虑删除首元结点的情况，删除其它结点的方式和上图完全相同，如下图所示：</p><p class='item-img' data-src='https://pica.zhimg.com/v2-a82095c25e668736e2d38dcccf45a5bc_b.jpg'><img src="https://pica.zhimg.com/v2-a82095c25e668736e2d38dcccf45a5bc_b.jpg" alt="动图封面"></p><p>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p为原链表，elem 为要删除的目标元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delElem</span><span class="hljs-params">(Link** p, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    Link* del = <span class="hljs-literal">NULL</span>, *temp = *p;<br>    <span class="hljs-comment">//删除首元结点需要单独考虑</span><br>    <span class="hljs-keyword">if</span> (temp-&gt;elem == elem) &#123;<br>        (*p) = (*p)-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> find = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//1、找到目标元素的直接前驱结点</span><br>        <span class="hljs-keyword">while</span> (temp-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (temp-&gt;next-&gt;elem == elem) &#123;<br>                find = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            temp = temp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (find == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//删除失败</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//标记要删除的结点</span><br>            del = temp-&gt;next;<br>            <span class="hljs-comment">//2、将目标结点从链表上摘除</span><br>            temp-&gt;next = temp-&gt;next-&gt;next;<br>            <span class="hljs-comment">//3、释放目标结点</span><br>            <span class="hljs-built_in">free</span>(del);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数返回 1 时，表示删除成功；返回 -1，表示删除失败。注意，该函数的形参 p 为二级指针，调用时需要传递链表头指针的地址。</p><h3 id="链表查找元素"><a href="#链表查找元素" class="headerlink" title="链表查找元素"></a>链表查找元素</h3><p>在链表中查找指定数据元素，最常用的方法是：从首元结点开始依次遍历所有节点，直至找到存储目标元素的结点。如果遍历至最后一个结点仍未找到，表明链表中没有存储该元素。</p><p>因此，链表中查找特定数据元素的 C 语言实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p为原链表，elem表示被查找元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//带头结点，p 指向首元结点</span><br>    p = p-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;elem == elem) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        p = p-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//返回-1，表示未找到</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意第 5 行代码，对于有结点的链表，需要先将 p 指针指向首元结点；反之，对于不带头结点的链表，注释掉第 5 行代码即可。</p><h3 id="链表更新元素"><a href="#链表更新元素" class="headerlink" title="链表更新元素"></a>链表更新元素</h3><p>更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。</p><p>直接给出链表中更新数据元素的 C 语言实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p 为有头结点的链表，oldElem 为旧元素，newElem 为新元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">amendElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> oldElem, <span class="hljs-type">int</span> newElem)</span> </span>&#123;<br>    p = p-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;elem == oldElem) &#123;<br>            p-&gt;elem = newElem;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数返回 1，表示更改成功；返回数字 -1，表示更改失败。如果是没有头结点的链表，直接删除第 3 行代码即可。</p><hr><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>目前我们所学到的链表，无论是动态链表还是静态链表，表中各个节点都只包含一个指针（游标），且都统一指向直接后继节点，这类链表又统称为单向链表或单链表。</p><p>虽然单链表能 100% 存储逻辑关系为 “一对一” 的数据，但在解决某些实际问题时，单链表的执行效率并不高。例如，若实际问题中需要频繁地查找某个结点的前驱结点，使用单链表存储数据显然没有优势，因为单链表的强项是从前往后查找目标元素，不擅长从后往前查找元素。</p><p>解决此类问题，可以建立双向链表（简称双链表）。</p><h3 id="双向链表是什么"><a href="#双向链表是什么" class="headerlink" title="双向链表是什么"></a>双向链表是什么</h3><p>从名字上理解双向链表，即链表是 “双向” 的，如下图所示：</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-62da5191aa8b27e80c1ffc4b1d61d367_b.jpg'><img src="https://pic4.zhimg.com/v2-62da5191aa8b27e80c1ffc4b1d61d367_b.jpg" alt="动图封面"></p><p>“双向”指的是各节点之间的逻辑关系是双向的，头指针通常只设置一个。</p><p>从上图中可以看到，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：</p><ol><li>指针域：用于指向当前节点的直接前驱节点；</li><li>数据域：用于存储数据元素。</li><li>指针域：用于指向当前节点的直接后继节点；</li></ol><p class='item-img' data-src='https://pic4.zhimg.com/v2-6b063e7219eb5143755d567c16dc06b1_b.jpg'><img src="https://pic4.zhimg.com/v2-6b063e7219eb5143755d567c16dc06b1_b.jpg" alt="动图封面"></p><p>因此，双链表的节点结构用 C 语言实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> * prior; <span class="hljs-comment">//指向直接前趋</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> * next; <span class="hljs-comment">//指向直接后继</span><br>&#125;Line;<br></code></pre></td></tr></table></figure><h3 id="双向链表的创建"><a href="#双向链表的创建" class="headerlink" title="双向链表的创建"></a>双向链表的创建</h3><p>同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。</p><p>需要注意的是，与单链表不同，双链表创建过程中，每创建一个新节点都要与其前驱节点建立两次联系，分别是：</p><ul><li>将新节点的 prior 指针指向直接前驱节点；</li><li>将直接前驱节点的 next 指针指向新节点；</li></ul><p>这里给出创建双向链表的 C 语言实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以尝试着在 main 函数中输出创建的双链表，C 语言代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* prior; <span class="hljs-comment">//指向直接前趋</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* next; <span class="hljs-comment">//指向直接后继</span><br>&#125;Line;<br><br><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//输出链表中的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-comment">//如果该节点无后继节点，说明此节点是链表的最后一个节点</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, temp-&gt;data);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &lt;-&gt; &quot;</span>, temp-&gt;data);<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//释放链表中结点占用的空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free_line</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = head;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个头指针</span><br>    Line* head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//调用链表创建函数</span><br>    head = <span class="hljs-built_in">initLine</span>(head);<br>    <span class="hljs-comment">//输出创建好的链表</span><br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-comment">//显示双链表的优点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表中第 4 个节点的直接前驱是：%d&quot;</span>, head-&gt;next-&gt;next-&gt;next-&gt;prior-&gt;data);<br>    <span class="hljs-built_in">free_line</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果：</p><blockquote><p>1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 链表中第 4 个节点的直接前驱是：3</p></blockquote><h2 id="双向链表基本操作"><a href="#双向链表基本操作" class="headerlink" title="双向链表基本操作"></a>双向链表基本操作</h2><p>前面学习了如何创建一个双向链表，本节学习有关双向链表的一些基本操作，即如何在双向链表中添加、删除、查找或更改数据元素。</p><p>本节知识基于已熟练掌握双向链表创建过程的基础上，我们继续上节所创建的双向链表来学习本节内容，创建好的双向链表如下图所示：</p><p class='item-img' data-src='https://pic2.zhimg.com/v2-c5f7cce2077c56369e912c09fbe8b1ef_b.jpg'><img src="https://pic2.zhimg.com/v2-c5f7cce2077c56369e912c09fbe8b1ef_b.jpg" alt="动图封面"></p><p>图 双向链表示意图</p><h3 id="双向链表添加节点"><a href="#双向链表添加节点" class="headerlink" title="双向链表添加节点"></a>双向链表添加节点</h3><p>根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：</p><ol><li>添加至表头</li></ol><p>将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。</p><p>换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：</p><ol><li>temp-&gt;next&#x3D;head; head-&gt;prior&#x3D;temp;</li><li>将 head 移至 temp，重新指向新的表头；</li></ol><p>例如，将新元素 7 添加至双链表的表头，则实现过程如图 2 所示：</p><p class='item-img' data-src='https://pic2.zhimg.com/v2-b9156e5d719713d2e4e61c308869a13b_b.jpg'><img src="https://pic2.zhimg.com/v2-b9156e5d719713d2e4e61c308869a13b_b.jpg" alt="动图封面"></p><p>图 添加元素至双向链表的表头</p><ol start="2"><li>添加至表的中间位置</li></ol><p>同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，如下图所示：</p><ol><li>新节点先与其直接后继节点建立双层逻辑关系；</li><li>新节点的直接前驱节点与之建立双层逻辑关系；</li></ol><p class='item-img' data-src='https://pic2.zhimg.com/v2-f5407b137acf9de84e56c5e30cfc16e7_b.jpg'><img src="https://pic2.zhimg.com/v2-f5407b137acf9de84e56c5e30cfc16e7_b.jpg" alt="动图封面"></p><p>图 双向链表中间位置添加数据元素</p><ol start="3"><li>添加至表尾</li></ol><p>与添加到表头是一个道理，实现过程如下（如图 4 所示）：</p><ol><li>找到双链表中最后一个节点；</li><li>让新节点与最后一个节点进行双层逻辑关系；</li></ol><p class='item-img' data-src='https://pic1.zhimg.com/v2-829fe83055126221b40116352bf5cdc6_b.jpg'><img src="https://pic1.zhimg.com/v2-829fe83055126221b40116352bf5cdc6_b.jpg" alt="动图封面"></p><p>图 双向链表尾部添加数据元素</p><p>因此，我们可以试着编写双向链表添加数据的 C 语言代码，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Line* <span class="hljs-title">insertLine</span><span class="hljs-params">(Line* head, <span class="hljs-type">int</span> data, <span class="hljs-type">int</span> add)</span> </span>&#123;<br>    <span class="hljs-comment">//新建数据域为data的结点</span><br>    Line* temp = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>    temp-&gt;data = data;<br>    temp-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//插入到链表头，要特殊考虑</span><br>    <span class="hljs-keyword">if</span> (add == <span class="hljs-number">1</span>) &#123;<br>        temp-&gt;next = head;<br>        head-&gt;prior = temp;<br>        head = temp;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        Line* body = head;<br>        <span class="hljs-comment">//找到要插入位置的前一个结点</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add - <span class="hljs-number">1</span>; i++) &#123;<br>            body = body-&gt;next;<br>            <span class="hljs-comment">//只要 body 不存在，表明插入位置输入错误</span><br>            <span class="hljs-keyword">if</span> (!body) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置有误！\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断条件为真，说明插入位置为链表尾，实现第 2 种情况</span><br>        <span class="hljs-keyword">if</span> (body &amp;&amp; (body-&gt;next == <span class="hljs-literal">NULL</span>)) &#123;<br>            body-&gt;next = temp;<br>            temp-&gt;prior = body;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//第 2 种情况的具体实现</span><br>            body-&gt;next-&gt;prior = temp;<br>            temp-&gt;next = body-&gt;next;<br>            body-&gt;next = temp;<br>            temp-&gt;prior = body;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表删除节点"><a href="#双向链表删除节点" class="headerlink" title="双向链表删除节点"></a>双向链表删除节点</h3><p>和添加结点的思想类似，在双向链表中删除目标结点也分为 3 种情况。</p><ol><li>删除表头结点</li></ol><p>删除表头结点的过程如下图所示：</p><p class='item-img' data-src='https://picx.zhimg.com/v2-66cf8b9a6cc816e4a69143a68b662e25_b.jpg'><img src="https://picx.zhimg.com/v2-66cf8b9a6cc816e4a69143a68b662e25_b.jpg" alt="动图封面"></p><p>删除表头结点的实现过程是：</p><ol><li>新建一个指针指向表头结点；</li><li>断开表头结点和其直接后续结点之间的关联，更改 head 头指针的指向，同时将其直接后续结点的 prior 指针指向 NULL；</li><li>释放表头结点占用的内存空间。</li><li>删除表中结点</li></ol><p>删除表中结点的过程如下图所示：</p><p class='item-img' data-src='https://pic2.zhimg.com/v2-08e8d26851903ee8889321bbd20279d9_b.jpg'><img src="https://pic2.zhimg.com/v2-08e8d26851903ee8889321bbd20279d9_b.jpg" alt="动图封面"></p><p>删除表中结点的实现过程是：</p><ol><li>找到目标结点，新建一个指针指向改结点；</li><li>将目标结点从链表上摘除；</li><li>释放该结点占用的内存空间。</li><li>删除表尾结点</li></ol><p>删除表尾结点的过程如下图所示：</p><p class='item-img' data-src='https://picx.zhimg.com/v2-8c26da9694cfa9d5cdbe2043e553795b_b.jpg'><img src="https://picx.zhimg.com/v2-8c26da9694cfa9d5cdbe2043e553795b_b.jpg" alt="动图封面"></p><p>删除表尾结点的实现过程是：</p><ol><li>找到表尾结点，新建一个指针指向该结点；</li><li>断点表尾结点和其直接前驱结点的关联，并将其直接前驱结点的 next 指针指向 NULL；</li><li>释放表尾结点占用的内存空间。</li></ol><p>双向链表删除节点的 C 语言实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除结点的函数，data为要删除结点的数据域的值</span><br><span class="hljs-function">Line* <span class="hljs-title">delLine</span><span class="hljs-params">(Line* head, <span class="hljs-type">int</span> data)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;data == data) &#123;<br>            <span class="hljs-comment">//删除表头结点</span><br>            <span class="hljs-keyword">if</span> (temp-&gt;prior == <span class="hljs-literal">NULL</span>) &#123;<br>                head = head-&gt;next;<br>                <span class="hljs-keyword">if</span> (head) &#123;<br>                    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>                    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-built_in">free</span>(temp);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            <span class="hljs-comment">//删除表中结点</span><br>            <span class="hljs-keyword">if</span> (temp-&gt;prior &amp;&amp; temp-&gt;next) &#123;<br>                temp-&gt;next-&gt;prior = temp-&gt;prior;<br>                temp-&gt;prior-&gt;next = temp-&gt;next;<br>                <span class="hljs-built_in">free</span>(temp);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            <span class="hljs-comment">//删除表尾结点</span><br>            <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>                temp-&gt;prior-&gt;next = <span class="hljs-literal">NULL</span>;<br>                temp-&gt;prior = <span class="hljs-literal">NULL</span>;<br>                <span class="hljs-built_in">free</span>(temp);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表中没有目标元素，删除失败\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表查找节点"><a href="#双向链表查找节点" class="headerlink" title="双向链表查找节点"></a>双向链表查找节点</h3><p>通常情况下，双向链表和单链表一样都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，也是从表头依次遍历表中元素。</p><p>C 语言实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//head为原双链表，elem表示被查找元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(line * head,<span class="hljs-type">int</span> elem)</span></span>&#123;<br><span class="hljs-comment">//新建一个指针t，初始化为头指针 head</span><br>    line * t=head;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (t-&gt;data==elem) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        i++;<br>        t=t-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//程序执行至此处，表示查找失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表更改节点"><a href="#双向链表更改节点" class="headerlink" title="双向链表更改节点"></a>双向链表更改节点</h3><p>更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><p>实现此操作的 C 语言实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//更新函数，其中，add 表示要修改的元素，newElem 为新数据的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">amendElem</span><span class="hljs-params">(Line* p, <span class="hljs-type">int</span> oldElem, <span class="hljs-type">int</span> newElem)</span> </span>&#123;<br>    Line* temp = p;<br>    <span class="hljs-type">int</span> find = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//找到要修改的目标结点</span><br>    <span class="hljs-keyword">while</span> (temp)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;data == oldElem) &#123;<br>            find = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//成功找到，则进行更改操作</span><br>    <span class="hljs-keyword">if</span> (find == <span class="hljs-number">1</span>) &#123;<br>        temp-&gt;data = newElem;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//查找失败，输出提示信息</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表中未找到目标元素，更改失败\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>无论静态链表还是动态链表，有时在解决具体问题时，需要我们对其结构进行稍微地调整。比如，可以把链表的两头连接，使其成为了一个环状链表，通常称为循环链表。</p><p>和它名字的表意一样，只需要将表中最后一个结点的指针指向头结点，链表就能成环儿，如下图所示。</p><p class='item-img' data-src='https://picx.zhimg.com/v2-584465255c37aeaae235df42d7f2ab39_1440w.jpg'><img src="https://picx.zhimg.com/v2-584465255c37aeaae235df42d7f2ab39_1440w.jpg" alt="img"></p><p>需要注意的是，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。</p><p>这里给大家一个循环链表的实例，用循环链表实现约瑟夫环</p><p><a href="https://link.zhihu.com/?target=https://xiexuewu.github.io/view/7.html">循环链表实现约瑟夫环 - 玩转C语言和数据结构xiexuewu.github.io&#x2F;view&#x2F;7.html</a></p><h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p>我们知道，单链表通过首尾连接可以构成单向循环链表，如下图所示：</p><p class='item-img' data-src='https://pic3.zhimg.com/v2-2996fac84cba2bbc4ce278d68ec1f40c_b.jpg'><img src="https://pic3.zhimg.com/v2-2996fac84cba2bbc4ce278d68ec1f40c_b.jpg" alt="动图封面"></p><p>同样，双向链表也可以进行首尾连接，构成双向循环链表。如下图所示：</p><p class='item-img' data-src='https://pic3.zhimg.com/v2-6661ba94cff67952b5108a7af5ca4564_b.jpg'><img src="https://pic3.zhimg.com/v2-6661ba94cff67952b5108a7af5ca4564_b.jpg" alt="动图封面"></p><p>解决某些问题，可能既需要正向遍历数据，又需要逆向遍历数据，这时就可以考虑使用双向循环链表。</p><h3 id="双向循环链表的创建"><a href="#双向循环链表的创建" class="headerlink" title="双向循环链表的创建"></a>双向循环链表的创建</h3><p>创建双向循环链表，只需在创建完成双向链表的基础上，将其首尾节点进行双向连接即可。</p><p>C 语言实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建双向循环链表</span><br><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接</span><br>    list-&gt;next=head;<br>    head-&gt;prior=list;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过向 main 函数中调用 initLine 函数，就可以成功创建一个存储有 {1,2,3} 数据的双向循环链表，其完整的 C 语言实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* prior; <span class="hljs-comment">//指向直接前趋</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* next; <span class="hljs-comment">//指向直接后继</span><br>&#125;Line;<br><span class="hljs-comment">//创建双向循环链表</span><br><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接</span><br>    list-&gt;next = head;<br>    head-&gt;prior = list;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//输出链表中的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-comment">//由于是循环链表，所以当遍历指针temp指向的下一个节点是head时，证明此时已经循环至链表的最后一个节点</span><br>    <span class="hljs-keyword">while</span> (temp-&gt;next != head) &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, temp-&gt;data);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, temp-&gt;data);<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//输出循环链表中最后一个节点的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, temp-&gt;data);<br>&#125;<br><span class="hljs-comment">//释放链表中结点占用的空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free_line</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//切断循环</span><br>    head-&gt;prior-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//从第一个结点开始，依次 free</span><br>    temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = head;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个头指针</span><br>    Line* head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//调用链表创建函数</span><br>    head = <span class="hljs-built_in">initLine</span>(head);<br>    <span class="hljs-comment">//输出创建好的链表</span><br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-comment">//手动释放链表占用的内存</span><br>    <span class="hljs-built_in">free_line</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出结果如下：</p><blockquote><p>1-&gt;2-&gt;3</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表（链式存储结构）&quot;&gt;&lt;a href=&quot;#链表（链式存储结构）&quot; class=&quot;headerlink&quot; title=&quot;链表（链式存储结构）&quot;&gt;&lt;/a&gt;链表（链式存储结构）&lt;/h2&gt;&lt;p&gt;链表又称单链表、链式存储结构，用于存储逻辑关系为“一对一”的数据。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表（顺序表）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/23014.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/23014.html</id>
    <published>2025-04-05T14:09:59.000Z</published>
    <updated>2025-04-17T16:53:48.651Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>说起这个问题，我们一定不陌生。打开QQ或微信，我们可以看到好友列表，打开PTA，我们能看到题目列表，打开音乐软件，我们可以看见歌曲列表，线性表在我们的生活中无处不在。线性表是怎么呈现的呢？线性表把我们在生活中需要的信息，按照顺序进行排列，使得这些信息直观、有条理，如果是按照某种顺序排列的列表，我们可以做到信息的快速检索。</p class='item-img' data-src='https://pic4.zhimg.com/80/v2-7c32c9f0fe93841585644ed3fe78d057_1440w.webp'><img src="https://pic4.zhimg.com/80/v2-7c32c9f0fe93841585644ed3fe78d057_1440w.webp" alt="img" style="zoom:50%;" /><h2 id="1-线性表（线性存储结构）"><a href="#1-线性表（线性存储结构）" class="headerlink" title="1) 线性表（线性存储结构）"></a>1) 线性表（线性存储结构）</h2><p>线性表又称线性存储结构，是最简单的一种存储结构，专门用来存储逻辑关系为“一对一”的数据。</p><p>在一个数据集中，如果每个数据的左侧都有且仅有一个数据和它有关系，数据的右侧也有且仅有一个数据和它有关系，那么这些数据之间就是“一对一“的逻辑关系。</p><p>所谓线性表，是<strong>零个或多个数据元素的有限序列</strong>，线性表的元素具有相同的特征，数据元素之间的关系是一对一的关系。</p><p class='item-img' data-src='https://pica.zhimg.com/v2-1d4fbbfe837a10f526f03db2b9bcb51e_b.jpg'><img src="https://pica.zhimg.com/v2-1d4fbbfe837a10f526f03db2b9bcb51e_b.jpg" alt="动图封面"></p><p>如上图所示，在 {1,2,3,4,5} 数据集中，每个数据的左侧都有且仅有一个数据和它紧挨着（除 1 外），右侧也有且仅有一个数据和它紧挨着（除 5 外），这些数据之间就是“一对一“的关系。</p><p>使用线性表存储具有“一对一“逻辑关系的数据，不仅可以将所有数据存储到内存中，还可以将“一对一”的逻辑关系也存储到内存中。</p><p>线性表存储数据的方案可以这样来理解，先用一根线将所有数据按照先后次序“串”起来，如下图所示：</p><p class='item-img' data-src='https://pic1.zhimg.com/v2-fa84cb14e76e339984f024a79e3faf50_b.jpg'><img src="https://pic1.zhimg.com/v2-fa84cb14e76e339984f024a79e3faf50_b.jpg" alt="动图封面"></p><p>数据和“一对一”的逻辑关系</p><p>左侧是“串”起来的数据，右侧是空闲的物理空间。将这“一串儿”数据存放到物理空间中，有以下两种方法：</p><p class='item-img' data-src='https://pic1.zhimg.com/v2-c83d6f36a89109312c6532bc67426d06_b.webp'><img src="https://pic1.zhimg.com/v2-c83d6f36a89109312c6532bc67426d06_b.webp" alt="动图"></p><p>两种存储方式都可以将数据之间的关系存储起来，从线的一头开始捋，可以依次找到每个数据，且数据的前后位置没有发生改变。</p><p>像上图这样，用一根线将具有“一对一”逻辑关系的数据存储起来，这样的存储方式就称为线性表或者线性存储结构。</p><h3 id="顺序存储结构和链式存储结构"><a href="#顺序存储结构和链式存储结构" class="headerlink" title="顺序存储结构和链式存储结构"></a>顺序存储结构和链式存储结构</h3><p>从图 3 不难看出，线性表存储数据的实现方案有两种，分别是：</p><ol><li>像图 3a) 那样，不破坏数据的前后次序，将它们连续存储在内存空间中，这样的存储方案称为顺序存储结构（简称<a href="https://link.zhihu.com/?target=https://xiexuewu.github.io/view/158.html">顺序表</a>）；</li><li>像图 3b) 那样，将所有数据分散存储在内存中，数据之间的逻辑关系全靠“一根线”维系，这样的存储方案称为链式存储结构（简称<a href="https://link.zhihu.com/?target=https://xiexuewu.github.io/view/160.html">链表</a>）。</li></ol><p>也就是说，使用线性表存储数据，有两种真正可以落地的存储方案，分别是顺序表和链表。</p><h3 id="前驱和后继"><a href="#前驱和后继" class="headerlink" title="前驱和后继"></a>前驱和后继</h3><p>在具有“一对一“逻辑关系的数据集中，每个个体习惯称为数据元素（简称元素）。例如，图 1 显示的这组数据集中，一共有 5 个元素，分别是 1、2、3、4 和 5。</p><p>此外，很多教程中喜欢用前驱和后继来描述元素之间的前后次序：</p><ul><li>某一元素的左侧相邻元素称为该元素的“直接前驱”，此元素左侧的所有元素统称为该元素的“前驱元素”；</li><li>某一元素的右侧相邻元素称为该元素的“直接后继”，此元素右侧的所有元素统称为该元素的“后继元素”；</li></ul><p>以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。</p><p class='item-img' data-src='https://pic2.zhimg.com/v2-06d19e0cf407ab715278064926dbdfa9_b.jpg'><img src="https://pic2.zhimg.com/v2-06d19e0cf407ab715278064926dbdfa9_b.jpg" alt="动图封面"></p><h2 id="2-顺序表（顺序存储结构）"><a href="#2-顺序表（顺序存储结构）" class="headerlink" title="2) 顺序表（顺序存储结构）"></a>2) 顺序表（顺序存储结构）</h2><p>顺序表又称顺序存储结构，是线性表的一种，专门存储逻辑关系为“一对一”的数据。</p><p>顺序表存储数据的具体实现方案是：将数据全部存储到一整块内存空间中，数据元素之间按照次序挨个存放。</p><p>举个简单的例子，将 {1,2,3,4,5} 这些数据使用顺序表存储，数据最终的存储状态如下图所示：</p><p class='item-img' data-src='https://pic2.zhimg.com/v2-0b61ec650d70af3469531945a0a0bc11_b.jpg'><img src="https://pic2.zhimg.com/v2-0b61ec650d70af3469531945a0a0bc11_b.jpg" alt="动图封面"></p><h3 id="线性表的抽象数据结构"><a href="#线性表的抽象数据结构" class="headerlink" title="线性表的抽象数据结构"></a>线性表的抽象数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">ADT List<br>&#123;<br>    Data:<br>        D = &#123;ai | <span class="hljs-number">1</span> ≤ i ≤ n, n ≥ <span class="hljs-number">0</span>, ai 为 ElemType 类型&#125;<br>    Relation：<br>        R = &#123; &lt;ai,ai<span class="hljs-number">+1</span>&gt; | ai,ai<span class="hljs-number">+1</span> ∈ D, i = <span class="hljs-number">1</span>, i ∈ (<span class="hljs-number">0</span>,n)&#125;<br>    Operation:<br>        <span class="hljs-built_in">InitList</span>(&amp;L);    <span class="hljs-comment">//初始化，建立一个空的线性表L</span><br>        <span class="hljs-built_in">MakeList</span>(&amp;L);    <span class="hljs-comment">//建立线性表，向表中存入数据</span><br>        <span class="hljs-built_in">ListEmpty</span>(*L);    <span class="hljs-comment">//空表判断，是则返回true,否则返回false</span><br>        <span class="hljs-built_in">DestroyList</span>(&amp;L);    <span class="hljs-comment">//清除操作，清空线性表的元素</span><br>        <span class="hljs-built_in">GetElem</span>(L,i,&amp;e);    <span class="hljs-comment">//获取线性表的元素，将线性表L的第i个元素的值返回给e</span><br>        <span class="hljs-built_in">LocateElem</span>(L,e);    <span class="hljs-comment">//按值查找元素，在线性表L中查找与e元素相等的元素，查找成功返回对应的序号，查找失败则返回0</span><br>        <span class="hljs-built_in">ListInsert</span>(&amp;L,i,e);    <span class="hljs-comment">//插入操作，在线性表L的第i个位置插入元素e</span><br>        <span class="hljs-built_in">ListDelete</span>(&amp;L,i,&amp;e);    <span class="hljs-comment">//删除操作，删除线性表L中的第i个位置的元素，并将其用e返回</span><br>        <span class="hljs-built_in">ListLength</span>(L);    <span class="hljs-comment">//计算表长，返回线性表L的元素个数</span><br>        <span class="hljs-built_in">DispList</span>(L);    <span class="hljs-comment">//输出线性表，当线性表不为空表时，按顺序输出表中的每一个元素</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序表的建立"><a href="#顺序表的建立" class="headerlink" title="顺序表的建立"></a>顺序表的建立</h3><p>使用顺序表存储数据，除了存储数据本身的值以外，通常还会记录以下两样数据：</p><ul><li>顺序表的最大存储容量：顺序表最多可以存储的数据个数；</li><li>顺序表的长度：当前顺序表中存储的数据个数。</li></ul><p>C 语言中，可以定义一个结构体来表示顺序表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> * head; <span class="hljs-comment">//定义一个名为head的长度不确定的数组，也叫“动态数组”</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">//记录当前顺序表的长度</span><br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">//记录顺序表的存储容量</span><br>&#125;Table;<br></code></pre></td></tr></table></figure><p>尝试建立一个顺序表，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Size 5 <span class="hljs-comment">//对Size进行宏定义，表示顺序表的最大容量</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initTable</span><span class="hljs-params">(Table * t)</span> </span>&#123;<br>    <span class="hljs-comment">//构造一个空的顺序表，动态申请存储空间</span><br>    t-&gt;head = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(Size * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//申请内存空间</span><br>    <span class="hljs-comment">//如果申请失败，作出提示并直接退出程序</span><br>    <span class="hljs-keyword">if</span> (!t-&gt;head)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化失败&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//空表的长度初始化为0</span><br>    t-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//空表的初始存储空间为Size</span><br>    t-&gt;size = Size;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，整个建立顺序表的过程都封装在一个函数中，建好的顺序表可以存储 5 个逻辑关系为“一对一”的整数。</p><p>在顺序表的实现中，<code>t-&gt;head</code> 是一个<strong>指向动态数组基地址的指针</strong>，其核心作用是为顺序表提供存储数据的连续内存空间。以下是具体解析：</p><hr><h3 id="1-t-head-的定义与作用"><a href="#1-t-head-的定义与作用" class="headerlink" title="1. t-&gt;head 的定义与作用"></a><strong>1. <code>t-&gt;head</code> 的定义与作用</strong></h3><p>• <strong>定义</strong>：<br>  <code>t-&gt;head</code> 是顺序表结构体中的一个成员变量，通常声明为动态数组的起始地址指针。例如在 C 语言中，顺序表的结构体定义如下：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> *head;  <span class="hljs-comment">// 动态数组基地址</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 当前元素个数</span><br>    <span class="hljs-type">int</span> size;   <span class="hljs-comment">// 总存储容量</span><br>&#125; Table;<br></code></pre></td></tr></table></figure></p><h3 id="顺序表的使用"><a href="#顺序表的使用" class="headerlink" title="顺序表的使用"></a>顺序表的使用</h3><p>通过调用 initTable() 函数，就可以成功地创建一个顺序表，还可以往顺序表中存储一些元素。</p><p>例如，将 {1,2,3,4,5} 存储到顺序表中，实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Size 5 <span class="hljs-comment">//对Size进行宏定义，表示顺序表的最大容量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span>* head;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> size;<br>&#125;Table;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initTable</span><span class="hljs-params">(Table * t)</span> </span>&#123;<br>    <span class="hljs-comment">//构造一个空的顺序表，动态申请存储空间</span><br>    t-&gt;head = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(Size * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-comment">//如果申请失败，作出提示并直接退出程序</span><br>    <span class="hljs-keyword">if</span> (!t-&gt;head) <span class="hljs-comment">//无头（申请失败）</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化失败&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//空表的长度初始化为0</span><br>    t-&gt;length = <span class="hljs-number">0</span>; <span class="hljs-comment">//t-&gt;length：当前元素个数</span><br>    <span class="hljs-comment">//空表的初始存储空间为Size</span><br>    t-&gt;size = Size; <span class="hljs-comment">//t-&gt;size：总存储容量</span><br>&#125;<br><span class="hljs-comment">//输出顺序表中元素的函数</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayTable</span><span class="hljs-params">(Table t)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; t.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, t.head[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Table t = &#123; <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">initTable</span>(&amp;t);<br>    <span class="hljs-comment">//向顺序表中添加&#123;1,2,3,4,5&#125;</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= Size; i++) &#123;<br>        t.head[i - <span class="hljs-number">1</span>] = i;<br>        t.length++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;顺序表中存储的元素分别是：\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(t);<br>    <span class="hljs-built_in">free</span>(t.head);<span class="hljs-comment">//释放申请的堆内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><blockquote><p>顺序表中存储的元素分别是： 1 2 3 4 5</p></blockquote><h2 id="3-顺序表的基本操作"><a href="#3-顺序表的基本操作" class="headerlink" title="3) 顺序表的基本操作"></a>3) 顺序表的基本操作</h2><p>我们学习了顺序表及初始化的过程，本节学习有关顺序表的一些基本操作，以及如何使用 C 语言实现它们。</p><h3 id="顺序表插入元素"><a href="#顺序表插入元素" class="headerlink" title="顺序表插入元素"></a>顺序表插入元素</h3><p>向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：</p><ol><li>插入到顺序表的表头；</li><li>在表的中间位置插入元素；</li><li>尾随顺序表中已有元素，作为顺序表中的最后一个元素；</li></ol><p>虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：</p><ul><li>将要插入位置元素以及后续的元素整体向后移动一个位置；</li><li>将元素放到腾出来的位置上；</li></ul><p>例如，在 {1,2,3,4,5} 的第 3 个位置上插入元素 6，实现过程如下：</p><ul><li>遍历至顺序表存储第 3 个数据元素的位置</li></ul><p class='item-img' data-src='https://pic3.zhimg.com/v2-9ce044ee30b5c641efb5cfe4753b1ff2_b.jpg'><img src="https://pic3.zhimg.com/v2-9ce044ee30b5c641efb5cfe4753b1ff2_b.jpg" alt="动图封面"></p><ul><li>将元素 3、4 和 5 整体向后移动一个位置</li></ul><p class='item-img' data-src='https://pic1.zhimg.com/v2-926c02eec07c5de69d2a9c29149f76bc_b.jpg'><img src="https://pic1.zhimg.com/v2-926c02eec07c5de69d2a9c29149f76bc_b.jpg" alt="动图封面"></p><ul><li>将新元素 6 放入腾出的位置</li></ul><p class='item-img' data-src='https://pic3.zhimg.com/v2-d5868803c7ed313babcec6d6c5a29cf0_b.jpg'><img src="https://pic3.zhimg.com/v2-d5868803c7ed313babcec6d6c5a29cf0_b.jpg" alt="动图封面"></p><p>因此，顺序表插入数据元素的 C 语言实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertTable</span><span class="hljs-params">(Table* t, <span class="hljs-type">int</span> elem, <span class="hljs-type">int</span> add)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <br>    <br>    <span class="hljs-comment">//如果插入元素位置(add)比整张表的长度+1(t-&gt;length + 1)还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出</span><br>    <span class="hljs-keyword">if</span> (add &gt; t-&gt;length + <span class="hljs-number">1</span> || add &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置有问题\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，有就是(t-&gt;length &lt; t-&gt;size)，如果没有就是(t-&gt;length == t-&gt;size)，需要申请</span><br>    <span class="hljs-keyword">if</span> (t-&gt;length == t-&gt;size) &#123;<br>        t-&gt;head = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(t-&gt;head, (t-&gt;size + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-comment">//重新分配内存，动态数组额外申请更多物理空间</span><br>        <span class="hljs-keyword">if</span> (!t-&gt;head) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;存储分配失败\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t-&gt;size += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">//插入操作，需要将自插入位置之后的所有元素(从t-&gt;length - 1倒数到add - 1)全部后移一位</span><br>    <span class="hljs-keyword">for</span> (i = t-&gt;length - <span class="hljs-number">1</span>; i &gt;= add - <span class="hljs-number">1</span>; i--) &#123;<br>        t-&gt;head[i + <span class="hljs-number">1</span>] = t-&gt;head[i];<br>    &#125;<br>    <br>    <span class="hljs-comment">//后移完成后，直接插入元素</span><br>    t-&gt;head[add - <span class="hljs-number">1</span>] = elem;<br>    t-&gt;length++;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，动态数组额外申请更多物理空间使用的是 realloc 函数。此外在实现元素整体后移的过程中，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。</p><h3 id="顺序表删除元素"><a href="#顺序表删除元素" class="headerlink" title="顺序表删除元素"></a>顺序表删除元素</h3><p>从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。</p><p>后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。</p><p>例如，从 {1,2,3,4,5} 中删除元素 3 的过程如图 4 所示：</p><p class='item-img' data-src='https://pic3.zhimg.com/v2-dfb4a1ff7c8dc898a0b7fef73f637262_b.jpg'><img src="https://pic3.zhimg.com/v2-dfb4a1ff7c8dc898a0b7fef73f637262_b.jpg" alt="动图封面"></p><p>因此，顺序表删除元素的 C 语言实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delTable</span><span class="hljs-params">(Table* t, <span class="hljs-type">int</span> add)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span> (add &gt; t-&gt;length || add &lt; <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">//删除元素位置大于表长或小于0</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被删除元素的位置有误\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//删除操作</span><br>    <span class="hljs-keyword">for</span> (i = add; i &lt; t-&gt;length; i++) &#123;<br>        t-&gt;head[i - <span class="hljs-number">1</span>] = t-&gt;head[i];<br>    &#125;<br>    t-&gt;length--;<span class="hljs-comment">//表长减短</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序表查找元素"><a href="#顺序表查找元素" class="headerlink" title="顺序表查找元素"></a>顺序表查找元素</h3><p>顺序表中查找目标元素，可以使用多种查找算法实现，比如说<a href="https://link.zhihu.com/?target=https://xiexuewu.github.io/view/55.html">二分查找</a>算法、插值查找算法等。</p><p>这里，我们选择<a href="https://link.zhihu.com/?target=https://xiexuewu.github.io/view/54.html">顺序查找</a>算法，具体实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//查找函数，其中，elem表示要查找的数据元素的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">selectTable</span><span class="hljs-params">(table t,<span class="hljs-type">int</span> elem)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;t.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (t.head[i]==elem) &#123;<br>            <span class="hljs-keyword">return</span> i<span class="hljs-number">+1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果查找失败，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序表更改元素"><a href="#顺序表更改元素" class="headerlink" title="顺序表更改元素"></a>顺序表更改元素</h3><p>顺序表更改元素的实现过程是：</p><ol><li>找到目标元素；</li><li>直接修改该元素的值；</li></ol><p>顺序表更改元素的 C 语言实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">amendTable</span><span class="hljs-params">(Table* t, <span class="hljs-type">int</span> elem, <span class="hljs-type">int</span> newElem)</span> </span>&#123;<br>    <span class="hljs-type">int</span> add = <span class="hljs-built_in">selectTable</span>(*t, elem);<br>    <span class="hljs-keyword">if</span> (add == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;顺序表中没有找到目标元素\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    t-&gt;head[add - <span class="hljs-number">1</span>] = newElem;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于-t-head-t-length-和-t-size"><a href="#关于-t-head-t-length-和-t-size" class="headerlink" title="关于 t-&gt;head,t-&gt;length 和 t-&gt;size"></a>关于 <code>t-&gt;head</code>,<code>t-&gt;length </code>和 <code>t-&gt;size</code></h3><p>• <strong>物理存储管理</strong>：<br>  <code>t-&gt;head</code> 指向通过 <code>malloc</code> 或 <code>realloc</code> 动态申请的内存块的首地址。顺序表中的所有元素按逻辑顺序连续存储在这段内存中。</p><p>• <strong>操作接口</strong>：<br>  通过 <code>t-&gt;head</code> 可直接访问顺序表的元素，例如：<br>  • <strong>插入</strong>：<code>t-&gt;head[add-1] = elem</code> 将元素写入指定位置。<br>  • <strong>遍历</strong>：通过 <code>t-&gt;head[i]</code> 访问第 <code>i</code> 个元素。</p><p>顺序表初始化时，<code>t-&gt;head</code> 被赋予动态分配的内存地址。例如：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initTable</span><span class="hljs-params">(Table *t)</span> </span>&#123;<br>    t-&gt;head = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(Size * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">// 申请初始内存</span><br>    t-&gt;length = <span class="hljs-number">0</span>;<br>    t-&gt;size = Size;<br>&#125;<br></code></pre></td></tr></table></figure><p>若内存分配失败，<code>t-&gt;head</code> 会指向 <code>NULL</code>，此时需进行错误处理。</p><p>所有对顺序表元素的增删查改均通过 <code>t-&gt;head</code> 实现：<br>• <strong>插入元素</strong>：将后续元素右移后，直接通过 <code>t-&gt;head[add-1]</code> 写入新值。<br>• <strong>删除元素</strong>：左移覆盖目标元素后，通过 <code>t-&gt;head</code> 重新定位后续元素。</p><p><code>t-&gt;head</code> 是顺序表实现中<strong>动态内存管理的核心</strong>，它指向存储数据的连续内存块，并通过指针操作支持元素的增删查改。</p><p>在顺序表的实现中，<code>t-&gt;length</code>和<code>t-&gt;size</code>是两个关键字段，它们的含义及设计逻辑如下：</p><hr><p><strong>1. <code>t-&gt;length</code>：当前元素个数</strong></p><p>• <strong>定义</strong>：表示顺序表中<strong>实际存储的有效元素数量</strong>，即当前表内数据的逻辑长度。<br>• <strong>作用</strong>：<br>  • 控制插入&#x2F;删除操作的合法性（例如插入位置不能超过<code>length+1</code>，删除位置不能超过<code>length</code>）。<br>  • 遍历时确定元素范围（从下标<code>0</code>到<code>length-1</code>）。<br>• <strong>示例</strong>：若顺序表存储<code>&#123;1,2,3&#125;</code>，则<code>length=3</code>。</p><hr><p><strong>2. <code>t-&gt;size</code>：总存储容量</strong></p><p>• <strong>定义</strong>：表示顺序表<strong>已申请的内存空间能容纳的最大元素数量</strong>，即物理存储容量。<br>• <strong>作用</strong>：<br>  • 判断是否需要扩容（当<code>length == size</code>时，表已满需扩展内存）。<br>  • 动态调整内存时记录当前分配的空间上限。<br>• <strong>示例</strong>：若初始分配容量为<code>size=5</code>，插入5个元素后<code>length=5</code>，此时需扩容才能继续插入。</p><hr><p><strong>3. 两者的区别与联系</strong></p><table><thead><tr><th><strong>字段</strong></th><th><strong>意义</strong></th><th><strong>操作触发条件</strong></th><th><strong>命名逻辑</strong></th></tr></thead><tbody><tr><td><code>length</code></td><td>实际元素个数（动态变化）</td><td>插入时位置需满足<code>1 ≤ add ≤ length+1</code></td><td>直观体现“逻辑长度”，类似数组的<code>size()</code></td></tr><tr><td><code>size</code></td><td>最大容量（静态&#x2F;动态）</td><td>扩容条件为<code>length == size</code></td><td>体现“物理容量上限”，类似容器的<code>capacity()</code></td></tr></tbody></table><ol><li><p><strong>逻辑与物理分离</strong>：<br>• <code>length</code>关注数据逻辑层面的使用情况，<code>size</code>关注物理内存的管理，两者分离便于维护动态内存。</p></li><li><p><strong>操作安全性</strong>：<br>• 通过<code>length</code>限制插入&#x2F;删除位置，避免越界访问；通过<code>size</code>判断内存是否耗尽，防止溢出。</p></li><li><p><strong>动态扩容机制</strong>：<br>• 当<code>length</code>达到<code>size</code>时，触发<code>realloc</code>扩展内存（例如每次扩容固定步长或按倍数增长），保证数据连续性。</p><p>插入函数中：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (add &gt; t-&gt;length + <span class="hljs-number">1</span> || add &lt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置有问题\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (t-&gt;length == t-&gt;size) &#123;<br>    t-&gt;head = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(t-&gt;head, (t-&gt;size + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-comment">// 扩容逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>• <strong><code>add &gt; t-&gt;length + 1</code></strong>：确保插入位置不超过逻辑长度的下一个合法位置（如<code>length=3</code>时，允许插入到第4位，但不可到第5位）。<br>• <strong><code>t-&gt;length == t-&gt;size</code></strong>：触发扩容的条件，保证物理空间始终足够容纳逻辑元素。</p><p><code>t-&gt;length</code>和<code>t-&gt;size</code>是顺序表实现中<strong>动态内存管理</strong>与<strong>逻辑操作控制</strong>的核心字段。通过两者的协同，既能高效利用内存，又能确保数据操作的合法性。</p><h2 id="其他操作的实现"><a href="#其他操作的实现" class="headerlink" title="其他操作的实现"></a>其他操作的实现</h2><h3 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseTable</span><span class="hljs-params">(Table* t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 空表或单元素表无需处理</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t-&gt;length / <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-type">int</span> temp = t-&gt;head[i];<br>        t-&gt;head[i] = t-&gt;head[t-&gt;length - <span class="hljs-number">1</span> - i];<br>        t-&gt;head[t-&gt;length - <span class="hljs-number">1</span> - i] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出表长"><a href="#输出表长" class="headerlink" title="输出表长"></a><strong>输出表长</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(Table* t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L-&gt;length; <span class="hljs-comment">// 直接返回顺序表的当前长度</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除全表"><a href="#删除全表" class="headerlink" title="删除全表"></a>删除全表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqListDestory</span><span class="hljs-params">(Table* t)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(t);  <span class="hljs-comment">// 确保传入的指针非空</span><br>    <span class="hljs-built_in">free</span>(t-&gt;head);  <span class="hljs-comment">// 释放动态数组内存</span><br>    t-&gt;head = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 指针置空</span><br>    t-&gt;size = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 容量归零</span><br>    t-&gt;length = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 元素个数归零</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h2><p>以下是一个完整的顺序表操作示例代码，包含<strong>初始化、插入、删除、查找、修改、逆序、销毁</strong>等操作，并在<code>main</code>函数中展示了具体调用逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_SIZE 5  <span class="hljs-comment">// 初始容量</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span>* head;    <span class="hljs-comment">// 动态数组基地址</span><br>    <span class="hljs-type">int</span> length;   <span class="hljs-comment">// 当前元素个数</span><br>    <span class="hljs-type">int</span> size;     <span class="hljs-comment">// 总存储容量</span><br>&#125; Table;<br><br><span class="hljs-comment">// 初始化顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initTable</span><span class="hljs-params">(Table* t)</span> </span>&#123;<br>    t-&gt;head = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(INIT_SIZE * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (!t-&gt;head) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配失败\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    t-&gt;length = <span class="hljs-number">0</span>;<br>    t-&gt;size = INIT_SIZE;<br>&#125;<br><br><span class="hljs-comment">// 插入元素（位置从1开始）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertTable</span><span class="hljs-params">(Table* t, <span class="hljs-type">int</span> elem, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">1</span> || pos &gt; t-&gt;length + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;非法插入位置: %d\n&quot;</span>, pos);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 容量检查与扩容</span><br>    <span class="hljs-keyword">if</span> (t-&gt;length == t-&gt;size) &#123;<br>        <span class="hljs-type">int</span> new_size = t-&gt;size * <span class="hljs-number">2</span>;  <span class="hljs-comment">// 容量翻倍</span><br>        <span class="hljs-type">int</span>* new_head = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(t-&gt;head, new_size * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (!new_head) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;扩容失败\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t-&gt;head = new_head;<br>        t-&gt;size = new_size;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已扩容至 %d\n&quot;</span>, new_size);<br>    &#125;<br><br>    <span class="hljs-comment">// 元素后移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t-&gt;length; i &gt;= pos; i--) &#123;<br>        t-&gt;head[i] = t-&gt;head[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    t-&gt;head[pos - <span class="hljs-number">1</span>] = elem;<br>    t-&gt;length++;<br>&#125;<br><br><span class="hljs-comment">// 删除元素（位置从1开始）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delTable</span><span class="hljs-params">(Table* t, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">1</span> || pos &gt; t-&gt;length) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;非法删除位置: %d\n&quot;</span>, pos);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 元素前移覆盖</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; t-&gt;length; i++) &#123;<br>        t-&gt;head[i - <span class="hljs-number">1</span>] = t-&gt;head[i];<br>    &#125;<br>    t-&gt;length--;<br>&#125;<br><br><span class="hljs-comment">// 查找元素（返回位置，从1开始）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">selectTable</span><span class="hljs-params">(Table* t, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t-&gt;length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (t-&gt;head[i] == elem) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<span class="hljs-comment">// 返回元素位置</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未找到</span><br>&#125;<br><br><span class="hljs-comment">// 修改元素值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">amendTable</span><span class="hljs-params">(Table* t, <span class="hljs-type">int</span> old_elem, <span class="hljs-type">int</span> new_elem)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">selectTable</span>(t, old_elem); <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素 %d 不存在\n&quot;</span>, old_elem);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    t-&gt;head[pos - <span class="hljs-number">1</span>] = new_elem;<br>&#125;<br><br><span class="hljs-comment">// 逆序顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseTable</span><span class="hljs-params">(Table* t)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t-&gt;length / <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-type">int</span> temp = t-&gt;head[i];<br>        t-&gt;head[i] = t-&gt;head[t-&gt;length - <span class="hljs-number">1</span> - i];<br>        t-&gt;head[t-&gt;length - <span class="hljs-number">1</span> - i] = temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 销毁顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroyTable</span><span class="hljs-params">(Table* t)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(t-&gt;head);<br>    t-&gt;head = <span class="hljs-literal">NULL</span>;<br>    t-&gt;length = <span class="hljs-number">0</span>;<br>    t-&gt;size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 打印顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayTable</span><span class="hljs-params">(Table* t)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[当前表长: %d, 总容量: %d]\n&quot;</span>, t-&gt;length, t-&gt;size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t-&gt;length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, t-&gt;head[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Table my_table; <span class="hljs-comment">//声明一个名为 my_table 的变量，其类型为 Table 结构体</span><br>    <br>    <span class="hljs-comment">// 1. 初始化</span><br>    <span class="hljs-built_in">initTable</span>(&amp;my_table);<br>    <span class="hljs-comment">//&amp;my_table的作用是将结构体的地址传递给函数，使函数能通过指针直接修改原始变量</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 初始化顺序表 ===\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(&amp;my_table);<br><br>    <span class="hljs-comment">// 2. 插入初始元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">insertTable</span>(&amp;my_table, i, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 插入5个元素 ===\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(&amp;my_table);<br><br>    <span class="hljs-comment">// 3. 测试扩容插入</span><br>    <span class="hljs-built_in">insertTable</span>(&amp;my_table, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 在第3位插入6</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 插入第6个元素触发扩容 ===\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(&amp;my_table);<br><br>    <span class="hljs-comment">// 4. 删除元素</span><br>    <span class="hljs-built_in">delTable</span>(&amp;my_table, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 删除第2个元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 删除第2个元素 ===\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(&amp;my_table);<br><br>    <span class="hljs-comment">// 5. 查找元素</span><br>    <span class="hljs-type">int</span> target = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">selectTable</span>(&amp;my_table, target);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 查找元素 %d ===\n&quot;</span>, target);<br>    <span class="hljs-keyword">if</span> (pos != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素 %d 位于第 %d 位\n&quot;</span>, target, pos);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素不存在\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 修改元素</span><br>    <span class="hljs-built_in">amendTable</span>(&amp;my_table, <span class="hljs-number">6</span>, <span class="hljs-number">66</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 修改元素 6 → 66 ===\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(&amp;my_table);<br><br>    <span class="hljs-comment">// 7. 逆序操作</span><br>    <span class="hljs-built_in">reverseTable</span>(&amp;my_table);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 逆序顺序表 ===\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(&amp;my_table);<br><br>    <span class="hljs-comment">// 8. 销毁顺序表</span><br>    <span class="hljs-built_in">destroyTable</span>(&amp;my_table);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 销毁后的状态 ===\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;指针状态: %s\n&quot;</span>, (my_table.head == <span class="hljs-literal">NULL</span>) ? <span class="hljs-string">&quot;已释放&quot;</span> : <span class="hljs-string">&quot;未释放&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键调用逻辑说明："><a href="#关键调用逻辑说明：" class="headerlink" title="关键调用逻辑说明："></a>关键调用逻辑说明：</h3><ol><li><strong>初始化顺序表</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">initTable</span>(&amp;my_table);<br></code></pre></td></tr></table></figure><p>• 创建空表，初始容量为5<br>• 时间复杂度：O(1)</p><ol start="2"><li><strong>批量插入元素</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">insertTable</span>(&amp;my_table, i, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>• 插入5个元素填满初始容量<br>• 时间复杂度：O(n)</p><ol start="3"><li><strong>触发扩容插入</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insertTable</span>(&amp;my_table, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>• 当插入第6个元素时触发动态扩容（容量翻倍为10）<br>• 时间复杂度：O(n)</p><ol start="4"><li><strong>删除元素</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">delTable</span>(&amp;my_table, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>• 删除第2个元素（值为2），后续元素前移<br>• 时间复杂度：O(n)</p><ol start="5"><li><strong>元素查找</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">selectTable</span>(&amp;my_table, target);<br></code></pre></td></tr></table></figure><p>• 使用顺序查找，返回元素位置<br>• 时间复杂度：O(n)</p><ol start="6"><li><strong>逆序操作</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverseTable</span>(&amp;my_table);<br></code></pre></td></tr></table></figure><p>• 通过对称交换实现逆序<br>• 时间复杂度：O(n)</p><ol start="7"><li><strong>销毁顺序表</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">destroyTable</span>(&amp;my_table);<br></code></pre></td></tr></table></figure><p>• 释放动态内存并将指针置空<br>• 防止内存泄漏的关键操作</p><h3 id="执行结果示例："><a href="#执行结果示例：" class="headerlink" title="执行结果示例："></a>执行结果示例：</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">=== 初始化顺序表 ===</span><br><span class="hljs-meta">[当前表长: 0, 总容量: 5]</span><br><br><br><span class="hljs-section">=== 插入5个元素 ===</span><br><span class="hljs-meta">[当前表长: 5, 总容量: 5]</span><br>1 2 3 4 5 <br><br>已扩容至 10<br><span class="hljs-section">=== 插入第6个元素触发扩容 ===</span><br><span class="hljs-meta">[当前表长: 6, 总容量: 10]</span><br>1 2 6 3 4 5 <br><br><span class="hljs-section">=== 删除第2个元素 ===</span><br><span class="hljs-meta">[当前表长: 5, 总容量: 10]</span><br>1 6 3 4 5 <br><br><span class="hljs-section">=== 查找元素 6 ===</span><br>元素 6 位于第 2 位<br><span class="hljs-section">=== 修改元素 6 → 66 ===</span><br><span class="hljs-meta">[当前表长: 5, 总容量: 10]</span><br>1 66 3 4 5 <br><br><span class="hljs-section">=== 逆序顺序表 ===</span><br><span class="hljs-meta">[当前表长: 5, 总容量: 10]</span><br>5 4 3 66 1 <br><br><span class="hljs-section">=== 销毁后的状态 ===</span><br>指针状态: 已释放<br></code></pre></td></tr></table></figure><h3 id="复杂度对比："><a href="#复杂度对比：" class="headerlink" title="复杂度对比："></a>复杂度对比：</h3><table><thead><tr><th>操作</th><th>最好情况</th><th>最坏情况</th><th>平均情况</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>逆序</td><td>-</td><td>O(n)</td><td>O(n)</td></tr><tr><td>初始化</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>​首先是插入操作，插入操作时间复杂度最小的情况是，当元素要插入到最后一个位置时，你就不需要移动任何元素即可实现，只需要将需要插入的元素插在表的末端即可，时间复杂度O(1)，最费时的操作就是插入的元素要放在表头，那我们就需要把表中的所有元素都移动了,时间复杂度为O(n)。</p><p>​删除操作也如此，当我们要删除最后一个元素，也不需要移动顺序表，而删除第一个元素时需要移动整个表。我们知道，在实际的操作中，删除表中的任何一个位置需要被插入删除的可能性是相同的，因此从平均角度来分析，移动表的平均次数为 (n - 1) &#x2F; 2，时间复杂度为O(n)。<br>​因此我们可以看出，顺序表在插入、删除操作时是比较费时间的，然而其他的基本操作例如初始化、建表或者销毁，时间复杂度都是O(1)，因此我们在使用顺序表的时候，要尽量让表保持不变，而是多多使用顺序表的存储和随机提取等优点。</p><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p>顺序表主要有如下一些优点：</p><ol><li>顺序表进行随机提取元素的效率较高，能够快速存储、提取元素；</li><li>建表时无需对表中元素的逻辑关系进行描述，各元素在存储地址上是连续的；</li><li>对于CPU，顺序表的高速缓存效率更高，且CPU流水线也不会总是被打断。</li></ol><p>顺序表主要有如下一些缺点：</p><ol><li>申请顺序表时，顺序表存储元素的上限是固定的，这就导致了存在溢出的可能性；</li><li>插入、删除元素时，时间复杂度较大，需要大范围移动表中的元素；</li><li>由于我们在很多情况下无法预知需要存储多少元素，因此容易导致内存碎片的现象，即申请了空间却没有充分利用。</li></ol><p><strong>关于链表再新开一个页面</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h1&gt;&lt;p&gt;说起这个问题，我们一定不陌生。打开QQ或微信，我们可以看到好友列表，打开PTA，我们能看到题目列表，打开音乐软件，我们可以</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-算法复杂度</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/25842.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/25842.html</id>
    <published>2025-04-05T08:09:55.000Z</published>
    <updated>2025-04-06T06:09:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>算法复杂度旨在计算在输入数据量 N的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数据大小 N」而增大的速度。</p><p>算法复杂度主要可从 <strong>时间</strong> 、<strong>空间</strong> 两个角度评价：</p><ul><li><strong>时间：</strong> 假设各操作的运行时间为固定常数，统计算法运行的「计算操作的数量」 ，以代表算法运行所需时间；</li><li><strong>空间：</strong> 统计在最差情况下，算法运行所需使用的「最大空间」；</li></ul><p>「输入数据大小N」指算法处理的输入数据量；根据不同算法，具有不同定义，例如：</p><ul><li><strong>排序算法：</strong> N代表需要排序的元素数量；</li><li><strong>搜索算法：</strong> N代表搜索范围的元素总数，例如数组大小、矩阵大小、二叉树节点数、图节点和边数等；</li></ul><p>接下来，我们将分别从概念定义、符号表示、常见种类、时空权衡、示例解析、示例题目等角度入手，学习「时间复杂度」和「空间复杂度」。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><strong>代码执行次数的简化估算值就是时间复杂度。</strong></p><p>一些例子</p><ol><li><p>线性复杂度<em>O</em>(<em>N</em>)：单层循环，如遍历数组求和。</p></li><li><p>对数复杂度<em>O</em>(log<em>N</em>)：二分查找。</p></li><li><p>线性对数复杂度<em>O</em>(<em>N</em>log<em>N</em>)：快速排序或归并排序的分治策略。</p></li><li><p>平方复杂度<em>O</em>(<em>N</em>^2)：双重循环，如冒泡排序。</p></li><li><p>指数复杂度<em>O</em>(2^<em>N</em>)：递归斐波那契。</p></li><li><p>阶乘复杂度<em>O</em>(<em>N</em>!)：全排列生成。</p><p>其中有：<em>O</em>(1)&lt;<em>O</em>(log<em>N</em>)&lt;<em>O</em>(<em>N</em>)&lt;<em>O</em>(<em>N</em>log<em>N</em>)&lt;<em>O</em>(<em>N</em>^2)&lt;<em>O</em>(2^<em>N</em>)&lt;<em>O</em>(<em>N</em>!)</p></li></ol><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f219793a6bc.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f219793a6bc.png"></p><h3 id="基本复杂度计算"><a href="#基本复杂度计算" class="headerlink" title="基本复杂度计算"></a><strong>基本复杂度计算</strong></h3><p>层层（循环、递归）相加：比如有2层循环，第一层循环共执行n次基本语句，每个基本语句执行1次，也就是n个“1”次相加，为n；第二层循环执行log2n次第一次循环，每个第一次循环执行n次，总的也就是log2n个“n”次相加为nlog2n，故时间复杂度为O(nlogn)。</p><h3 id="复杂度计算的核心规则"><a href="#复杂度计算的核心规则" class="headerlink" title="复杂度计算的核心规则"></a>复杂度计算的核心规则</h3><ol><li><strong>单层循环</strong>：直接取循环次数，如 <code>O(n)</code>.  </li><li><strong>嵌套循环</strong>：各层循环次数相乘，如 <code>O(n²)</code> 或 <code>O(n log n)</code>.  </li><li><strong>递归算法</strong>：<br>• 递归次数 × 每次递归的操作次数，如斐波那契数列的 <code>O(2ⁿ)</code>.<br>• 分治策略（如归并排序）通过主定理计算，结果为 <code>O(n log n)</code>.  </li><li><strong>忽略低阶项</strong>：如 <code>T(n) = 3n² + 2n + 1</code> 简化为 <code>O(n²)</code>.</li></ol><h3 id="1-O-1-—-常数复杂度"><a href="#1-O-1-—-常数复杂度" class="headerlink" title="1. O(1) — 常数复杂度"></a><strong>1. O(1) — 常数复杂度</strong></h3><p><strong>特点</strong>：运行次数与 N 大小呈常数关系，即不随输入数据大小 N 的变化而变化。</p><p><strong>示例</strong>：访问数组元素或交换变量。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 访问数组元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> arr[index]; <span class="hljs-comment">// 无论数组大小，直接访问固定位置</span><br>&#125;<br><br><span class="hljs-comment">// 交换变量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;<br>    <span class="hljs-type">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp; <span class="hljs-comment">// 仅需三次赋值操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f219792807e.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f219792807e.png"></p><hr><h3 id="2-O-log-n-—-对数复杂度"><a href="#2-O-log-n-—-对数复杂度" class="headerlink" title="2. O(log n) — 对数复杂度"></a><strong>2. O(log n) — 对数复杂度</strong></h3><p><strong>特点</strong>：每次操作将问题规模缩减为固定比例（如折半）。<br><strong>示例</strong>：二分查找。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 每次搜索范围减半</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图所示，为二分查找的时间复杂度示意图，每次二分将搜索区间缩小一半。</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197929e82.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197929e82.png"></p><hr><h3 id="3-O-n-—-线性复杂度"><a href="#3-O-n-—-线性复杂度" class="headerlink" title="3. O(n) — 线性复杂度"></a><strong>3. O(n) — 线性复杂度</strong></h3><p><strong>特点</strong>：执行时间与输入规模成线性正比。<br><strong>示例</strong>：遍历数组求和。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sumArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        sum += arr[i]; <span class="hljs-comment">// 遍历所有元素，执行次数为n</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197926290.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197926290.png"></p><hr><h3 id="4-O-n-log-n-—-对数线性复杂度"><a href="#4-O-n-log-n-—-对数线性复杂度" class="headerlink" title="4. O(n log n) — 对数线性复杂度"></a><strong>4. O(n log n) — 对数线性复杂度</strong></h3><p><strong>特点</strong>：两层循环相互独立，第一层和第二层时间复杂度分别为 O(log⁡N) 和 O(N)，则总体时间复杂度为 O(Nlog⁡N)</p><p>结合线性与对数操作，常见于分治算法。<br><strong>示例</strong>：快速排序。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = partition(arr, low, high); <span class="hljs-comment">// 分区操作O(n)</span><br>        quickSort(arr, low, pivot - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 递归左半部分</span><br>        quickSort(arr, pivot + <span class="hljs-number">1</span>, high); <span class="hljs-comment">// 递归右半部分</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 每次递归将问题规模分半，递归深度为log n，每层总操作次数为n</span><br></code></pre></td></tr></table></figure><p>线性对数阶常出现于排序算法，例如「快速排序」、「归并排序」、「堆排序」等，其时间复杂度原理如下图所示。</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f219792ceba.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f219792ceba.png"></p><hr><h3 id="5-O-nᵏ-—-多项式复杂度（k-2为例）"><a href="#5-O-nᵏ-—-多项式复杂度（k-2为例）" class="headerlink" title="5. O(nᵏ) — 多项式复杂度（k&#x3D;2为例）"></a><strong>5. O(nᵏ) — 多项式复杂度（k&#x3D;2为例）</strong></h3><p><strong>特点</strong>：嵌套循环导致时间复杂度为输入规模的k次方。<br><strong>示例</strong>：冒泡排序。 第一层和第二层时间复杂度分别为 O(N) 和 O(N)，则总体时间复杂度为 O(N^2) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size<span class="hljs-number">-1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size-i<span class="hljs-number">-1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>                swap(&amp;arr[j], &amp;arr[j+<span class="hljs-number">1</span>]); <span class="hljs-comment">// 双重循环，操作次数为n²</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197949027.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197949027.png"></p><hr><h3 id="6-O-kⁿ-—-指数复杂度"><a href="#6-O-kⁿ-—-指数复杂度" class="headerlink" title="6. O(kⁿ) — 指数复杂度"></a><strong>6. O(kⁿ) — 指数复杂度</strong></h3><p><strong>特点</strong>：问题规模每增加1，计算量翻倍。<br><strong>示例</strong>：斐波那契数列的递归实现。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fibonacci(n<span class="hljs-number">-1</span>) + fibonacci(n<span class="hljs-number">-2</span>); <span class="hljs-comment">// 每次递归分裂为两次调用，复杂度为O(2ⁿ)</span><br>&#125;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f21979ba451.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f21979ba451.png"></p><hr><h3 id="7-O-n-—-阶乘复杂度"><a href="#7-O-n-—-阶乘复杂度" class="headerlink" title="7. O(n!) — 阶乘复杂度"></a><strong>7. O(n!) — 阶乘复杂度</strong></h3><p><strong>特点</strong>：问题规模每增加1，计算量增长为阶乘级。<br><strong>示例</strong>：生成全排列，给定 N<em>N</em> 个互不重复的元素，求其所有可能的排列方案（递归回溯）。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        count += algorithm(N - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f21979bc3d1.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f21979bc3d1.png"></p><h1 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h1><p>时间复杂度不同，随着输入数据量的增加，代码运行的时间也会增加。</p><p>例如O(1)无论输入数据如何增多，代码运行时间都不变。而O(n)的运行时间和输入数据量成正比。如果时间复杂度过高，例如O(2^n)，那么在小数据情况下，代码还可以运行，一旦数据量增大，则代码的运行时间将会几何级增加。</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197c5a42b.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197c5a42b.png"></p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197b9fefb.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197b9fefb.png"></p><p>代码执行时间总结如下：</p><table><thead><tr><th>名称</th><th>时间复杂度</th></tr></thead><tbody><tr><td>常数时间</td><td>O(1)</td></tr><tr><td>对数时间</td><td>O(log n)</td></tr><tr><td>线性时间</td><td>O(n)</td></tr><tr><td>线性对数时间</td><td>O(nlog n)</td></tr><tr><td>二次时间</td><td>O(n^2)</td></tr><tr><td>三次时间</td><td>O(n^3)</td></tr><tr><td>指数时间</td><td>O(2^n)</td></tr></tbody></table><h1 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h1><p class='item-img' data-src='https://pica.zhimg.com/80/v2-582c21adb0ae8039ad5cf5010c3b46b2_1440w.webp'><img src="https://pica.zhimg.com/80/v2-582c21adb0ae8039ad5cf5010c3b46b2_1440w.webp" alt="img"></p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-4671f059ba17906a6438c07a6a2815f7_1440w.webp'><img src="https://pic4.zhimg.com/80/v2-4671f059ba17906a6438c07a6a2815f7_1440w.webp" alt="img"></p><p class='item-img' data-src='https://pic2.zhimg.com/80/v2-6dd67dfea6b61a260c60b8b6cfc826f3_1440w.webp'><img src="https://pic2.zhimg.com/80/v2-6dd67dfea6b61a260c60b8b6cfc826f3_1440w.webp" alt="img"></p><hr><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><blockquote><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少字节的空间，因为这个也没太大意义，所以<strong>空间复杂度算的是变量的个数</strong>。空间复杂度计算规则基本跟时间复杂度类似，也使用大O渐进表示法。</p></blockquote><h3 id="常数-O-1"><a href="#常数-O-1" class="headerlink" title="常数 O(1)"></a>常数 O(1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算冒泡排序函数的空间复杂度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> N)</span><br>&#123;<br>assert(a);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-type">int</span> exchange = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N - <span class="hljs-number">1</span> - i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[j]&gt;a[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> tmp = a[j];<br>a[j] = a[j + <span class="hljs-number">1</span>];<br>a[j + <span class="hljs-number">1</span>] = tmp;<br>exchange = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (exchange == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>冒泡排序函数中使用了常数个额外空间（即常数个变量），所以用大O的渐进表示法表示冒泡排序函数的空间复杂度为<strong>O(1)</strong> 。</p><h3 id="线性-O-N"><a href="#线性-O-N" class="headerlink" title="线性 O*(*N)"></a>线性 O*(*N)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算阶乘递归函数的空间复杂度</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Factorial</span><span class="hljs-params">(<span class="hljs-type">size_t</span> N)</span><br>&#123;<br><span class="hljs-keyword">return</span> N &lt; <span class="hljs-number">2</span> ? N : Factorial(N - <span class="hljs-number">1</span>)*N;<br>&#125;<br></code></pre></td></tr></table></figure><p>阶乘递归函数会依次调用Factorial(N),Factorial(N-1),…,Factorial(2),Factorial(1)，开辟了N个空间，所以空间复杂度为<strong>O(N)</strong> 。</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197a7f3a0.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197a7f3a0.png"></p><h3 id="平方-O-N²"><a href="#平方-O-N²" class="headerlink" title="平方 O(N²)"></a>平方 O(N²)</h3><p>元素数量与 N呈平方关系的任意类型集合（常见于矩阵），皆使用平方大小的空间。</p><ol><li><strong>递归调用栈的深度</strong><br>每次递归调用参数递减 1，直到 N ≤ 0。递归深度为 N 次（例如 N&#x3D;5 时调用链为 algorithm(5) → algorithm(4) → … → algorithm(0)）</li><li><strong>每次递归的临时空间占用</strong><br>每次递归调用时，会在栈上动态创建一个大小为 N 的整型数组 <code>int nums[N]</code>。随着递归深度增加，数组长度的变化为 N, N-1, N-2, …, 1</li><li><strong>空间累计计算</strong><br>总空间占用为各次递归调用中数组大小的累加：<br><em>S</em>(<em>N</em>)&#x3D;<em>N</em>+(<em>N</em>−1)+(<em>N</em>−2)+⋯+1&#x3D;2<em>N</em>(<em>N</em>+1)​<br>根据大 O 表示法，简化为 ​<strong>​O(N²)​</strong>​</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> nums[N];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">algorithm</span>(N - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197a7bf34.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197a7bf34.png"></p><h3 id="指数-O-2ᴺ"><a href="#指数-O-2ᴺ" class="headerlink" title="指数 O(2ᴺ)"></a>指数 O(2ᴺ)</h3><p>指数阶常见于二叉树、多叉树的空间分析，例如：</p><ol><li><p>满二叉树</p><p>高度为 <strong>N</strong> 的满二叉树，节点总数为 <strong>2ᴺ</strong>，空间复杂度为 <strong>O(2ᴺ)</strong>。</p></li><li><p>满 m 叉树</p><p>高度为 <strong>N</strong> 的满 m 叉树，节点总数为 <strong>mᴺ</strong>。</p><p>当 m 为常数时，<strong>O(mᴺ) &#x3D; O(2ᴺ)</strong>（指数级增长性质相同）。</p></li></ol><p>指数阶常见于二叉树、多叉树。例如，高度为 N的「满二叉树」的节点数量为 2^N，占用 O(2^N)大小的空间；同理，高度为 N的「满 m叉树」的节点数量为 m^N，占用 O(m^N)大小的空间。</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197a8e599.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197a8e599.png"></p><h3 id="对数-O-log-N"><a href="#对数-O-log-N" class="headerlink" title="对数 O(log N)"></a><strong>对数 O(log N)</strong></h3><p>对数阶常出现于分治算法的栈帧空间累计、数据类型转换等，例如：</p><ul><li><strong>快速排序</strong>，平均空间复杂度为 Θ(log N)，最差空间复杂度为 O(N)。<br>通过应用尾递归优化，可以将快速排序的最差空间复杂度限定至 O(N)。</li><li><strong>数字转化为字符串</strong>，设某正整数为 N，则字符串的空间复杂度为 O(log N)。<br>正整数 N 的位数为 log₁₀ N，即转化的字符串长度为 log₁₀ N，因此空间复杂度为 O(log N)。</li></ul><p><strong>注：递归算法的空间复杂度通常是递归的深度（即递归多少层）。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h1&gt;&lt;p&gt;算法复杂度旨在计算在输入数据量 N的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-绪论</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/45088.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/45088.html</id>
    <published>2025-04-05T03:31:22.000Z</published>
    <updated>2025-04-05T09:31:57.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a><strong>1.1 数据结构的基本概念</strong></h2><p>　　数据、数据元素、数据对象、数据结构、存储结构、数据类型和抽象数据类型。</p><blockquote><p><strong>数据</strong>(data)是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。<br><strong>数据元素</strong>(data element)是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。<br><strong>数据对象</strong>(data object)是性质相同的数据元素的集合，是数据的一个子集。<br><strong>数据结构</strong>(data structure)是相互之间存在一种或多种特定关系的数据元素的集合。<br><strong>存储结构</strong>（<strong>物理结构</strong>）是数据结构在计算机中的表示（又称映像）。<br><strong>数据类型</strong>(data type)是一个值的集合和定义在这个值集上的一组操作的总称。<br><strong>抽象数据类型</strong>(Abstract Data Type)是指一个数学模型以及定义在该模型上的一组操作。</p></blockquote><h3 id="抽象数据类型的定义"><a href="#抽象数据类型的定义" class="headerlink" title="抽象数据类型的定义"></a><strong>抽象数据类型的定义</strong></h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">ADT 抽象数据类型名</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    数据对象：数据对象的定义</span><br><span class="hljs-template-variable">    数据关系：数据关系的定义</span><br><span class="hljs-template-variable">    基本操作：基本操作的定义</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">ADT 抽象数据类型名</span><br></code></pre></td></tr></table></figure><p>例子如下</p><p><strong>抽象数据类型复数和有理数的定义</strong>（有理数是其分子、分母均为自然数且分母不为零的分数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">复数定义：<br>ADT Complex  <span class="hljs-comment">//复数定义 a±bi</span><br>&#123;<br>    数据对象：D = &#123;a, b | a,b为实数&#125;<br>    数据关系：R = &#123;&lt;a, b&gt;&#125;<br>    基本操作：<br>        InitComplex(&amp;C, re, im)<br>            操作结果：构造一个复数C，其实部和虚部分别为re和im<br>        DestroyCmoplex(&amp;C)<br>            操作结果：销毁复数C<br>        Get(C, k, &amp;e)<br>            初始条件：复数C已存在<br>            操作结果：用e返回复数C的第k元的值<br>        Put(&amp;C, k, e)<br>            初始条件：复数C已存在<br>            操作结果：改变复数C的第k元的值为e<br>        IsAscending(C)<br>            初始条件：复数C已存在<br>            操作结果：如果复数C的两个元素按升序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        IsDescending(C)<br>            初始条件：复数C已存在<br>            操作结果：如果复数C的两个元素按降序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        Max(C, &amp;e)<br>            初始条件：复数C已存在<br>            操作结果：用e返回复数C的两个元素中值较大的一个<br>        Min(C, &amp;e)<br>            初始条件：复数C已存在<br>            操作结果：用e返回复数C的两个元素中值较小的一个<br>&#125;ADT Complex<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">有理数定义：<br>ADT RationalNumber  <span class="hljs-comment">//有理数定义</span><br>&#123;<br>    数据对象：D=&#123;s, m | s,m为自然数，且m不为<span class="hljs-number">0</span>&#125;<br>    数据关系：R=&#123;&lt;s, m&gt;&#125;<br>    基本操作：<br>        InitRationalNumber(&amp;R, s, m)<br>            操作结果：构造一个有理数R，其分子和分母分别为s和m<br>        DestroyRationalNumber(&amp;R)<br>            操作结果：销毁有理数R<br>        Get(R, k, &amp;e)<br>            初始条件：有理数R已存在<br>            操作结果：用e返回有理数R的第k元的值<br>        Put(&amp;R, k, e)<br>            初始条件：有理数R已存在<br>            操作结果：改变有理数R的第k元的值为e<br>        IsAscending(R)<br>            初始条件：有理数R已存在<br>            操作结果：若有理数R的两个元素按升序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        IsDescending(R)<br>            初始条件：有理数R已存在<br>            操作结果：若有理数R的两个元素按降序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        Max(R, &amp;e)<br>            初始条件：有理数R已存在<br>            操作结果：用e返回有理数R的两个元素中值较大的一个<br>        Min(R, &amp;e)<br>            初始条件：有理数R已存在<br>            操作结果：用e返回有理数R的两个元素中值较小的一个<br>&#125;ADT RationalNumber<br></code></pre></td></tr></table></figure><p>　　</p><p>根据数据元素之间关系的 不同特性，通常有下列几种类基本结构：</p><p>(1) <strong>集合</strong> 结构中的 如生 数据元素之间除了“同属千一个集合”的关系外，别无其他关系</p><p>(2) <strong>线性结构</strong> 结构中的数据元素之间存在一个对 一个的关系；</p><p>(3) <strong>树形结构</strong> 结构中的数据元素之间存在一 个对多个的关系； </p><p>(4) <strong>图状结构或网状结构</strong> 结构中的数据 元素之间存在多个对多个的关系。</p><h3 id="1-1-2-数据结构三要素"><a href="#1-1-2-数据结构三要素" class="headerlink" title="1.1.2 数据结构三要素"></a><strong>1.1.2 数据结构三要素</strong></h3><p>　　　　<strong>① 逻辑结构</strong></p><p>　　　　　　逻辑结构指数据元素之间存在的逻辑关系，是固有的客观联系；</p><p>　　　　　　逻辑结构分为<strong>线性结构</strong>与<strong>非线性结构</strong>，比如：线性表、树、图等；</p><p>　　　　<strong>② 存储结构</strong></p><p>　　　　　　存储结构又称为物理结构，指数据结构在计算机中的表示（映像），是计算机内部的存储方法；</p><p>　　　　　　存储结构主要有<strong>顺序存储、链式存储、索引存储</strong>和<strong>散列存储</strong>；</p><p>　　　　　　一种逻辑结构通过映像便可以得到它的存储结构；</p><p>　　　　　　诸如顺序表、哈希表、链表这样的表述，它们既体现了逻辑结构（均为线性），又体现了存储结构（顺序、散列、链式）；</p><p>　　　　　　而这样的表述我们往往就直接称之为<strong>数据结构</strong>；</p><p>　　　　　　诸如有序表，它只体现了逻辑结构（线性），而存储结构是未知的（可以是顺序、链式……）；</p><p>　　　　　　不存在只体现存储结构而不体现逻辑结构的表述；</p><p>　　　　　　所以，我们认为：<strong>逻辑结构独立于存储结构。</strong></p><p>　　　　<strong>③ 数据的运算（算法）</strong></p><p>　　　　　　算法包括运算的<strong>定义</strong>（取决于逻辑结构，体现算法功能）与<strong>实现</strong>（取决于存储结构，体现于操作步骤）。</p><h3 id="1-2-算法的基本概念"><a href="#1-2-算法的基本概念" class="headerlink" title="1.2 算法的基本概念"></a><strong>1.2 算法的基本概念</strong></h3><p>　　算法的 5 个重要特性：<strong>有穷性、确定性、有效性（可行性）、输入</strong>，<strong>输出</strong>；</p><p>　　一个好的算法的目标：<strong>正确性、可读性、鲁棒性、效率与低存储量需求</strong>。</p><p><strong>1.3 算法分析</strong></p><p>　　<strong>时间复杂度</strong>指算法所有语句被重复执行次数总和的数量级。</p><p>　　常见时间复杂度比较：</p><p>　　　　<strong>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</strong></p><p>　　　　(log 表示以 2 为底的对数)</p><p>　　<strong>空间复杂度</strong>指算法耗费存储空间的数量级。</p><p><strong>1.4 时间复杂度的计算</strong></p><h3 id="计算时间复杂度"><a href="#计算时间复杂度" class="headerlink" title="计算时间复杂度"></a><strong>计算时间复杂度</strong></h3><p>问题规模——&gt; 输入量的多少</p><p>语句频度——&gt; 一条语句的重复执行次数</p><p>执行时间&lt;—— 所有语句频度之和</p><blockquote><p>1.基本操作，即只有常数项，认为其时间复杂度为O(1)<br>2.顺序结构，时间复杂度按加法进行计算<br>3.循环结构，时间复杂度按乘法进行计算<br>4.分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略<br>5.在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度</p></blockquote><p>　　</p><p><strong>循环条件包含主体变量</strong></p><p>将执行次数代入循环条件进行求解：</p><p><strong>示例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= n) <br>    i = i * <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li>每次循环后 <em>i</em> &#x3D;2<em>t</em>（<em>t</em> 为执行次数）</li><li>终止条件：2<em>t</em> ≤ <em>n</em></li><li>解得 <em>t <em>≤ log2</em>n</em></li><li>时间复杂度：<em>T</em>(<em>n</em>) &#x3D; <em>O</em>(log<em>n</em>)</li></ul><p><strong>示例2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">while</span> ((i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">1</span>) &lt; n) <br>    i = i + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>令 <em>t</em>&#x3D;<em>i</em>−3，则 <em>i</em>&#x3D;<em>t</em>+3</li><li>代入条件：(<em>t</em>+3+1)2&lt;<em>n</em>⟹(<em>t</em>+4)2&lt;<em>n</em></li><li>解得 <em>t</em>&lt;<em>n</em>−4</li><li>时间复杂度：<em>T</em>(<em>n</em>)&#x3D;<em>O</em>(<em>n</em>)</li></ul><hr><p><strong>循环条件与主体变量无关</strong></p><p>通过数学归纳法或递归展开直接计数：</p><p><strong>示例（递归函数）：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归方程：<em>T</em>(<em>n</em>)&#x3D;1+<em>T</em>(<em>n</em>−1)</li><li>展开递推：<em>T</em>(<em>n</em>)&#x3D;1+<em>T</em>(<em>n</em>−1)&#x3D;1+1+<em>T</em>(<em>n</em>−2) ⋮&#x3D;<em>k</em>+<em>T</em>(<em>n</em>−<em>k</em>)(当 <em>k</em>&#x3D;<em>n</em>−1)&#x3D;(<em>n</em>−1)+<em>T</em>(1)&#x3D;<em>O</em>(<em>n</em>)</li><li>时间复杂度：<em>T</em>(<em>n</em>)&#x3D;<em>O</em>(<em>n</em>)</li></ul><h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><p>如下图所示，常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。</p><p class='item-img' data-src='https://pic.leetcode-cn.com/1599638810-SZDwfK-Picture1.png'><img src="https://pic.leetcode-cn.com/1599638810-SZDwfK-Picture1.png" alt="Picture1.png"></p><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。</p><p>如下图所示，构建此数组需要在初始化时给定长度，并对数组每个索引元素赋值，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化一个长度为 5 的数组 array</span><br><span class="hljs-type">int</span> array[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 元素赋值</span><br>array[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br>array[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<br>array[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>array[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>array[<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>或者可以使用直接赋值的初始化方式，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> array[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://pic.leetcode-cn.com/1599587176-JAxwpf-Picture2.png'><img src="https://pic.leetcode-cn.com/1599587176-JAxwpf-Picture2.png" alt="Picture2.png"></p><p>「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化可变数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; array;<br><br><span class="hljs-comment">// 向尾部添加元素</span><br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 <code>val</code>」，「后继节点引用 <code>next</code>」 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;        <span class="hljs-comment">// 节点值</span><br>    ListNode *next; <span class="hljs-comment">// 后继节点引用</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实例化节点</span><br>ListNode *n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 节点 head</span><br>ListNode *n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br>ListNode *n3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1-&gt;next = n2;<br>n2-&gt;next = n3;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://pic.leetcode-cn.com/1599578767-zgLjYw-Picture3.png'><img src="https://pic.leetcode-cn.com/1599578767-zgLjYw-Picture3.png" alt="Picture3.png"></p><hr><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; stk;<br></code></pre></td></tr></table></figure><p>如下图所示，通过常用操作「入栈 <code>push()</code>」,「出栈 <code>pop()</code>」，展示了栈的先入后出特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 元素 1 入栈</span><br>stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 元素 2 入栈</span><br>stk.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出栈 -&gt; 元素 2</span><br>stk.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出栈 -&gt; 元素 1</span><br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://pic.leetcode-cn.com/1599578767-ZifMEX-Picture4.png'><img src="https://pic.leetcode-cn.com/1599578767-ZifMEX-Picture4.png" alt="Picture4.png"></p><hr><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; que;<br></code></pre></td></tr></table></figure><p>如下图所示，通过常用操作「入队 <code>push()</code>」,「出队 <code>pop()</code>」，展示了队列的先入先出特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">que.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 元素 1 入队</span><br>que.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 元素 2 入队</span><br>que.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出队 -&gt; 元素 1</span><br>que.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出队 -&gt; 元素 2</span><br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://pic.leetcode-cn.com/1599588416-Majmwh-Picture5.png'><img src="https://pic.leetcode-cn.com/1599588416-Majmwh-Picture5.png" alt="Picture5.png"></p><hr><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 <code>root</code>」。以二叉树为例，每个节点包含三个成员变量：「值 <code>val</code>」、「左子节点 <code>left</code>」、「右子节点 <code>right</code>」 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;         <span class="hljs-comment">// 节点值</span><br>    TreeNode *left;  <span class="hljs-comment">// 左子节点</span><br>    TreeNode *right; <span class="hljs-comment">// 右子节点</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如下图所示，建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化节点</span><br>TreeNode *n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 根节点 root</span><br>TreeNode *n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">4</span>);<br>TreeNode *n3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">5</span>);<br>TreeNode *n4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">1</span>);<br>TreeNode *n5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1-&gt;left = n2;<br>n1-&gt;right = n3;<br>n2-&gt;left = n4;<br>n2-&gt;right = n5;<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://pic.leetcode-cn.com/1599579136-bBARpC-Picture6.png'><img src="https://pic.leetcode-cn.com/1599579136-bBARpC-Picture6.png" alt="Picture6.png"></p><hr><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是一种非线性数据结构，由「节点（顶点）<code>vertex</code>」和「边 <code>edge</code>」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。本文 <strong>以无向图为例</strong> 开展介绍。</p><p>如下图所示，此无向图的 <strong>顶点</strong> 和 <strong>边</strong> 集合分别为：</p><ul><li>顶点集合： <code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></li><li>边集合： <code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;</code></li></ul><p class='item-img' data-src='https://pic.leetcode-cn.com/1599579136-Fxseew-Picture7.png'><img src="https://pic.leetcode-cn.com/1599579136-Fxseew-Picture7.png" alt="Picture7.png"></p><p>表示图的方法通常有两种：</p><p><strong>邻接矩阵</strong>：</p><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml">int vertices[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="language-xml">int edges[5][5] = </span><span class="hljs-template-variable">&#123;&#123;0, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,</span><br><span class="hljs-template-variable">                   &#123;<span class="hljs-number">1</span>, 0, 0, <span class="hljs-number">1</span>, 0&#125;,</span><br><span class="hljs-template-variable">                   &#123;<span class="hljs-number">1</span>, 0, 0, 0, <span class="hljs-number">1</span>&#125;,</span><br><span class="hljs-template-variable">                   &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, 0, 0, <span class="hljs-number">1</span>&#125;,</span><br><span class="hljs-template-variable">                   &#123;<span class="hljs-number">1</span>, 0, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, 0&#125;&#125;</span><span class="language-xml">;</span><br></code></pre></td></tr></table></figure><hr><p><strong>邻接表：</strong></p><ul><li><strong>顶点存储</strong>: 数组 <code>vertices</code> 存储顶点值</li><li><strong>边存储</strong>: 二维容器 <code>edges</code> 存储边关系<ul><li>第一维 <code>i</code> 表示顶点索引（对应 <code>vertices[i]</code>）</li><li>第二维 <code>edges[i]</code> 存储该顶点连接的<strong>目标顶点值集合</strong></li><li><strong><code>edges[i]</code> 中的数字直接表示目标顶点</strong>值**（非索引）</li><li>例如 <code>edges[0] = [1,2,3,4]</code> 表示顶点1连接到值2&#x2F;3&#x2F;4&#x2F;5（注意实际值比索引大1）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> vertices[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; edge_1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_3 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_4 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_5 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>edges.<span class="hljs-built_in">push_back</span>(edge_1);<br>edges.<span class="hljs-built_in">push_back</span>(edge_2);<br>edges.<span class="hljs-built_in">push_back</span>(edge_3);<br>edges.<span class="hljs-built_in">push_back</span>(edge_4);<br>edges.<span class="hljs-built_in">push_back</span>(edge_5);<br></code></pre></td></tr></table></figure><blockquote><p><strong>邻接矩阵 VS 邻接表 ：</strong></p><p>邻接矩阵的大小只与节点数量有关，即 N2<em>N</em>2 ，其中 N<em>N</em> 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。<br>因此，<strong>邻接表</strong> 适合存储稀疏图（顶点较多、边较少）； <strong>邻接矩阵</strong> 适合存储稠密图（顶点较少、边较多）。</p></blockquote><hr><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，以实现高效的元素查找。</p><blockquote><p>设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。<br>现需求从「姓名」查找「学号」。</p></blockquote><p>则可通过建立姓名为 <code>key</code> ，学号为 <code>value</code> 的散列表实现此需求，代码如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 初始化散列表</span><br>unordered_map&lt;string, int&gt; dic;<br><br><span class="hljs-comment">// 添加 key -&gt; value 键值对</span><br>dic[<span class="hljs-string">&quot;小力&quot;</span>] = <span class="hljs-number">10001</span>;<br>dic[<span class="hljs-string">&quot;小特&quot;</span>] = <span class="hljs-number">10002</span>;<br>dic[<span class="hljs-string">&quot;小扣&quot;</span>] = <span class="hljs-number">10003</span>;<br><br><span class="hljs-comment">// 从姓名查找学号</span><br>dic.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;小力&quot;</span>)-&gt;<span class="hljs-built_in">second</span>; <span class="hljs-comment">// -&gt; 10001</span><br>dic.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;小特&quot;</span>)-&gt;<span class="hljs-built_in">second</span>; <span class="hljs-comment">// -&gt; 10002</span><br>dic.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;小扣&quot;</span>)-&gt;<span class="hljs-built_in">second</span>; <span class="hljs-comment">// -&gt; 10003</span><br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://pic.leetcode-cn.com/1599811794-ruXMOV-Picture8.png'><img src="https://pic.leetcode-cn.com/1599811794-ruXMOV-Picture8.png" alt="Picture8.png"></p><p><strong>Hash 函数设计示例 ：</strong></p><blockquote><p>假设需求：从「学号」查找「姓名」。</p></blockquote><p>将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2 。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">string</span> names[] = &#123; <span class="hljs-string">&quot;小力&quot;</span>, <span class="hljs-string">&quot;小特&quot;</span>, <span class="hljs-string">&quot;小扣&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>此时，我们构造一个简单的 Hash 函数（ %% 为取余符号 ），公式和封装函数如下所示：</p><p>hash(key)&#x3D;(key−1)%10000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> <span class="hljs-built_in">hash</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">id</span>) &#123;<br>    <span class="hljs-built_in">int</span> index = (<span class="hljs-built_in">id</span> - <span class="hljs-number">1</span>) % <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></td></tr></table></figure><p>则我们构建了以学号为 <code>key</code> 、姓名对应的数组索引为 <code>value</code> 的散列表。利用此 Hash 函数，则可在 O(1)<em>O</em>(1) 时间复杂度下通过学号查找到对应姓名，即：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">names[<span class="hljs-built_in">hash</span>(<span class="hljs-number">10001</span>)] <span class="hljs-comment">// 小力</span><br>names[<span class="hljs-built_in">hash</span>(<span class="hljs-number">10002</span>)] <span class="hljs-comment">// 小特</span><br>names[<span class="hljs-built_in">hash</span>(<span class="hljs-number">10003</span>)] <span class="hljs-comment">// 小扣</span><br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://pic.leetcode-cn.com/1599811794-NfbpfW-Picture8-1.png'><img src="https://pic.leetcode-cn.com/1599811794-NfbpfW-Picture8-1.png" alt="Picture8-1.png"></p><p>以上设计只适用于此示例，实际的 Hash 函数需保证低碰撞率、 高鲁棒性等，以适用于各类数据和场景。</p><hr><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</p><blockquote><p><strong>完全二叉树定义：</strong> 设二叉树深度为 k<em>k</em> ，若二叉树除第 k<em>k</em> 层外的其它各层（第 11 至 k−1<em>k</em>−1 层）的节点达到最大个数，且处于第 k<em>k</em> 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。</p></blockquote><p>如下图所示，为包含 <code>1, 4, 2, 6, 8</code> 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。</p><p class='item-img' data-src='https://pic.leetcode-cn.com/1599584901-xoiGEQ-Picture9.png'><img src="https://pic.leetcode-cn.com/1599584901-xoiGEQ-Picture9.png" alt="Picture9.png"></p><p>通过使用「优先队列」的「压入 <code>push()</code>」和「弹出 <code>pop()</code>」操作，即可完成堆排序，实现代码如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 初始化小顶堆</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; heap;<br><br><span class="hljs-comment">// 元素入堆</span><br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">4</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">2</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">6</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">8</span>);<br><br><span class="hljs-comment">// 元素出堆（从小到大）</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 1</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 2</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 4</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 6</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 8</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-1-数据结构的基本概念&quot;&gt;&lt;a href=&quot;#1-1-数据结构的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 数据结构的基本概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.1 数据结构的基本概念&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　数据、数据元素</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于数据结构的一些想法</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/12835.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/12835.html</id>
    <published>2025-04-04T11:13:49.000Z</published>
    <updated>2025-04-05T05:59:36.900Z</updated>
    
    <content type="html"><![CDATA[<hr><p>鉴于我校 [已编辑] 的教学安排，在刚学完c语言程序设计后，大一下就开始了基于c++的数据结构的学习，由于算法基础过于薄弱，数据结构拼尽全力期末复习只考了70而且掌握不足，写不出东西来，现在重拾旧事把数据结构重新学一遍</p><p>个人认为学不明白踩过的坑有几点：</p><ul><li><p>第一，在大学的课程里并没有讲明白一个问题，就是数据结构算法应该怎么样和实际场景结合。比如，老师讲到树形结构的时候会说，树形效率很高， 它的插入和查找时间复杂度都是O(LogN)，是一种非常重要的数据结构，在计算机中应用非常广泛，讲到这里就讲完了,留下我们一头雾水。</p></li><li><p>第二，在实际其实没有机会从零开始手写一个数据结构和算法，在主流的编程语言中都已经封装好了。</p></li><li><p>第三，你广州大学的数据结构排课极少，这么难学的课竟然课时还没思政课多。不知道计算机学院那边是什么情况，蹭课时那边一个时间复杂度讲了三节课，心死了，还是得靠自己学</p><p>很多时候我们能说出队列是什么原理，栈是什么原理，树的旋转是怎么回事， 但如果让我们自己实现一个队列或者栈还是有点难度的， 尤其是在需要考虑一些性能问题的时候。遂决定把这些重新拾起来。</p></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;鉴于我校 [已编辑] 的教学安排，在刚学完c语言程序设计后，大一下就开始了基于c++的数据结构的学习，由于算法基础过于薄弱，数据结构拼尽全力期末复习只考了70而且掌握不足，写不出东西来，现在重拾旧事把数据结构重新学一遍&lt;/p&gt;
&lt;p&gt;个人认为学不明白踩过的坑有几点</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo集成gitalk时的Error Validation Failed问题</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/18261.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/18261.html</id>
    <published>2025-04-03T06:26:34.000Z</published>
    <updated>2025-04-04T11:14:28.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo集成gitalk时Error-Validation-Failed问题"><a href="#hexo集成gitalk时Error-Validation-Failed问题" class="headerlink" title="hexo集成gitalk时Error: Validation Failed问题"></a>hexo集成gitalk时Error: Validation Failed问题</h2><p>Hexo集成Gitalk后，某些文章下方的评论显示<code>Error: Validation Failed</code></p><p>Gitalk会限制Label name的长度，有些文章生成的URL长度会超过限制，所以导致这个问题</p><p class='item-img' data-src='https://user-images.githubusercontent.com/16487416/38803021-8740f06c-41a0-11e8-955c-eb3ee9cc07d9.png'><img src="https://user-images.githubusercontent.com/16487416/38803021-8740f06c-41a0-11e8-955c-eb3ee9cc07d9.png" alt="img"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>可以集成一个对文章生成唯一id的插件</p><h3 id="hexo-abbrlink"><a href="#hexo-abbrlink" class="headerlink" title="hexo-abbrlink"></a>hexo-abbrlink</h3><p>在博客根目录下安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-abbrlink</span><br></code></pre></td></tr></table></figure><p>并修改配置文件<code>_config.yml</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">permalink:</span> [<span class="hljs-title class_">EveryWordsYouWant</span>]/<span class="hljs-symbol">:abbrlink/</span><br></code></pre></td></tr></table></figure><p>再 <em>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</em> 即可</p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-0b7a582d36baa6ffd77cccb429f6f244_720w.webp'><img src="https://pica.zhimg.com/80/v2-0b7a582d36baa6ffd77cccb429f6f244_720w.webp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo集成gitalk时Error-Validation-Failed问题&quot;&gt;&lt;a href=&quot;#hexo集成gitalk时Error-Validation-Failed问题&quot; class=&quot;headerlink&quot; title=&quot;hexo集成gitalk时Err</summary>
      
    
    
    
    <category term="Hexo" scheme="https://zhongye1.github.io/Arknight-notes/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://zhongye1.github.io/Arknight-notes/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Neo4j图数据科学库（GDS）进行中心度分析</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/19918.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/19918.html</id>
    <published>2025-04-02T15:37:24.000Z</published>
    <updated>2025-04-03T06:22:53.778Z</updated>
    
    <content type="html"><![CDATA[<p><strong>安装并加载GDS库</strong>  </p><p>​    确保已安装并启用GDS插件。若未安装，需从Neo4j官网下载对应版本。<br>​    </p><h3 id="创建图投影"><a href="#创建图投影" class="headerlink" title="创建图投影"></a>创建图投影</h3><p>在 GDS 中创建内存中的图投影：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">CALL</span> gds.graph.<span class="hljs-keyword">project</span>(<br>  <span class="hljs-string">&#x27;nodeGraph&#x27;</span>,      <span class="hljs-comment">// 图名称</span><br>  <span class="hljs-string">&#x27;Node&#x27;</span>,           <span class="hljs-comment">// 节点标签</span><br>  <span class="hljs-string">&#x27;NEIGHBOR&#x27;</span>,       <span class="hljs-comment">// 关系类型</span><br>  &#123;<br>    nodeProperties: [<span class="hljs-string">&#x27;degree&#x27;</span>],  <span class="hljs-comment">// 需要加载的节点属性</span><br>    relationshipProperties: &#123;&#125;  <span class="hljs-comment">// 关系属性（可选）</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure><hr><p><strong>运行度中心性算法并写入属性</strong> </p><p>使用<code>gds.degree.write</code>方法计算每个节点的度（可指定入度、出度或总度数），并将结果存储为节点属性<code>degree</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">CALL</span> gds.degree.<span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;nodeGraph&#x27;</span>, &#123;<br>    writeProperty: <span class="hljs-string">&#x27;degree&#x27;</span>,   <span class="hljs-comment">// 写入的属性名</span><br>    orientation: <span class="hljs-string">&#x27;UNDIRECTED&#x27;</span>  <span class="hljs-comment">// 方向：UNDIRECTED（总度数）、NATURAL（出度）、REVERSE（入度）</span><br>&#125;)<br>YIELD nodePropertiesWritten<br><br></code></pre></td></tr></table></figure><hr><h3 id="计算中心性指标"><a href="#计算中心性指标" class="headerlink" title="计算中心性指标"></a>计算中心性指标</h3><h4 id="1-PageRank"><a href="#1-PageRank" class="headerlink" title="1. PageRank"></a>1. <strong>PageRank</strong></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">CALL gds.pageRank.<span class="hljs-title function_ invoke__">write</span>(<span class="hljs-string">&#x27;nodeGraph&#x27;</span>, &#123;<br>  <span class="hljs-attr">maxIterations</span>: <span class="hljs-number">20</span>,<br>  <span class="hljs-attr">dampingFactor</span>: <span class="hljs-number">0.85</span>,<br>  <span class="hljs-attr">writeProperty</span>: <span class="hljs-string">&#x27;pagerank&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2-度中心性-Degree-Centrality"><a href="#2-度中心性-Degree-Centrality" class="headerlink" title="2. 度中心性 (Degree Centrality)"></a>2. <strong>度中心性 (Degree Centrality)</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">CALL</span> gds.degree.<span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;nodeGraph&#x27;</span>, &#123;<br>  writeProperty: <span class="hljs-string">&#x27;degree_centrality&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="3-亲密中心性-Closeness-Centrality"><a href="#3-亲密中心性-Closeness-Centrality" class="headerlink" title="3. 亲密中心性 (Closeness Centrality)"></a>3. <strong>亲密中心性 (Closeness Centrality)</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">CALL</span> gds.closeness.<span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;nodeGraph&#x27;</span>, &#123;<br>  writeProperty: <span class="hljs-string">&#x27;closeness_centrality&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="4-介数中心性-Betweenness-Centrality"><a href="#4-介数中心性-Betweenness-Centrality" class="headerlink" title="4. 介数中心性 (Betweenness Centrality)"></a>4. <strong>介数中心性 (Betweenness Centrality)</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">CALL</span> gds.betweenness.<span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;nodeGraph&#x27;</span>, &#123;<br>  writeProperty: <span class="hljs-string">&#x27;betweenness_centrality&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><hr><h3 id="查询结果"><a href="#查询结果" class="headerlink" title="查询结果"></a>查询结果</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MATCH (n:Node)<br><span class="hljs-keyword">RETURN</span> <br>  n.address <span class="hljs-keyword">AS</span> Address,<br>  n.pagerank <span class="hljs-keyword">AS</span> PageRank,<br>  n.degree_centrality <span class="hljs-keyword">AS</span> DegreeCentrality,<br>  n.closeness_centrality <span class="hljs-keyword">AS</span> ClosenessCentrality,<br>  n.betweenness_centrality <span class="hljs-keyword">AS</span> BetweennessCentrality<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> PageRank <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">╒═════════════╤═══════════════════╤════════════════╤═══════════════════╤═════════════════════╕<br>│<span class="hljs-variable">Address</span>      │<span class="hljs-variable">PageRank</span>           │<span class="hljs-built_in">DegreeCentrality</span>│<span class="hljs-built_in">ClosenessCentrality</span>│<span class="hljs-built_in">BetweennessCentrality</span>│<br>╞═════════════╪═══════════════════╪════════════════╪═══════════════════╪═════════════════════╡<br>│<span class="hljs-string">&quot;10.104.0.73&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.105.0.71&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.105.0.72&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.101.0.73&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.103.0.71&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.101.0.71&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.107.0.73&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.108.0.73&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.107.0.71&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.103.0.73&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.106.0.71&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.101.0.72&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.104.0.71&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.109.0.72&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.109.0.73&quot;</span>│<span class="hljs-number">0.17143947585331437</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">1.0</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.103.0.72&quot;</span>│<span class="hljs-number">0.16639351504031516</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.102.0.73&quot;</span>│<span class="hljs-number">0.16639351504031516</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.102.0.71&quot;</span>│<span class="hljs-number">0.16639351504031516</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.107.0.72&quot;</span>│<span class="hljs-number">0.16638840173142871</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.106.0.73&quot;</span>│<span class="hljs-number">0.16638840173142871</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.100.0.72&quot;</span>│<span class="hljs-number">0.16638840173142871</span>│<span class="hljs-number">28.0</span>            │<span class="hljs-number">1.0</span>                │<span class="hljs-number">6.833333333333333</span>    │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.104.0.73&quot;</span>│<span class="hljs-number">0.16620703459522992</span>│<span class="hljs-number">27.0</span>            │<span class="hljs-number">1.0</span>                │<span class="hljs-number">4.166666666666666</span>    │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.102.0.72&quot;</span>│<span class="hljs-number">0.16620703459522992</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.109.0.71&quot;</span>│<span class="hljs-number">0.16532947619296923</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.100.0.72&quot;</span>│<span class="hljs-number">0.16532947619296923</span>│<span class="hljs-number">23.0</span>            │<span class="hljs-number">1.0</span>                │<span class="hljs-number">2.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.105.0.73&quot;</span>│<span class="hljs-number">0.16532947619296923</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.108.0.71&quot;</span>│<span class="hljs-number">0.16532947619296923</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.104.0.72&quot;</span>│<span class="hljs-number">0.16532947619296923</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.8</span>                │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.100.0.74&quot;</span>│<span class="hljs-number">0.16028351537997002</span>│<span class="hljs-number">27.0</span>            │<span class="hljs-number">0.75</span>               │<span class="hljs-number">2.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.106.0.72&quot;</span>│<span class="hljs-number">0.16009703493488484</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.6666666666666666</span> │<span class="hljs-number">0.0</span>                  │<br>├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤<br>│<span class="hljs-string">&quot;10.108.0.72&quot;</span>│<span class="hljs-number">0.16009703493488484</span>│<span class="hljs-number">0.0</span>             │<span class="hljs-number">0.6666666666666666</span> │<span class="hljs-number">0.0</span>                  │<br>└─────────────┴───────────────────┴────────────────┴───────────────────┴─────────────────────┘<br></code></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    
    <summary type="html">计算PageRank、度中心性、亲密中心性、介数中心性和各节点的度数</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Neo4j" scheme="https://zhongye1.github.io/Arknight-notes/tags/Neo4j/"/>
    
  </entry>
  
  <entry>
    <title>SITE-193</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/4183.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/4183.html</id>
    <published>2025-03-31T08:44:24.000Z</published>
    <updated>2025-06-10T02:02:37.883Z</updated>
    
    <content type="html"><![CDATA[<p class='item-img' data-src='https://pic1.zhimg.com/v2-842db2fbcdb441bd2562cf457f8192b4_r.jpg'><img src="https://pic1.zhimg.com/v2-842db2fbcdb441bd2562cf457f8192b4_r.jpg" alt="img"></p><span id="more"></span><h2 id="Zhongye"><a href="#Zhongye" class="headerlink" title="Zhongye"></a>Zhongye</h2><p> <em>&#x2F;From an Open Source Organization in Guangzhou-University</em>*</p><p><em><a href="https://github.com/Guangzhou-University-SITE-193">https://github.com/Guangzhou-University-SITE-193</a></em></p><h2 id="💻-Skills"><a href="#💻-Skills" class="headerlink" title="💻 Skills"></a>💻 Skills</h2><p>🥪 <strong>Front End</strong> &#x2F; 🥗 <strong>Backend</strong> &#x2F; 🍊 <strong>Network Security</strong> &#x2F; 🍑 <strong>Machine Learning</strong></p><h2 id="📋-Tech-Stack"><a href="#📋-Tech-Stack" class="headerlink" title="📋 Tech Stack"></a>📋 Tech Stack</h2 class='item-img' data-src='https://skillicons.dev/icons?i=py,c,java,html,css,js,vscode,git,powershell,docker,arch,windows&theme=light'><img align="center" src="https://skillicons.dev/icons?i=py,c,java,html,css,js,vscode,git,powershell,docker,arch,windows&theme=light" /><h3 id="关注站长博客！"><a href="#关注站长博客！" class="headerlink" title="关注站长博客！"></a>关注站长博客！</h3><p>本站： <a href="https://zhongye1.github.io/Arknight-notes/">https://zhongye1.github.io/Arknight-notes/</a></p><p>本站RSS订阅：  <a href="https://zhongye1.github.io/Arknight-notes/rss.xml">https://zhongye1.github.io/Arknight-notes/rss.xml</a></p><p>主站： <a href="https://zhongye1.github.io/">https://zhongye1.github.io</a></p><p>主站RSS订阅：  <a href="https://zhongye1.github.io/atom.xml">https://zhongye1.github.io/atom.xml</a></p><p>193工作站：      <a href="https://github.com/Guangzhou-University-SITE-193">https://github.com/Guangzhou-University-SITE-193</a></p><p>GitHub：   <a href="https://github.com/Zhongye1">https://github.com/Zhongye1</a></p><p>QQ：2760913192</p><h3 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h3><p>用于做归档页面整理和知识储备，建设中</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-842db2fbcdb441bd2562cf457f8192b4_r.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="日志" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>2024一些笔记（概率论）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/20561.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/20561.html</id>
    <published>2025-03-09T14:51:00.000Z</published>
    <updated>2025-04-03T06:22:53.776Z</updated>
    
    <content type="html"><![CDATA[<p>2024的一些笔记（概率论）（共18张）</p><hr><p class='item-img' data-src='https://pica.zhimg.com/80/v2-04d0311fa8c90603ec9b304c1c5f7636_720w.webp'><img src="https://pica.zhimg.com/80/v2-04d0311fa8c90603ec9b304c1c5f7636_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic3.zhimg.com/80/v2-861ad585ca6cda1a5e4c42840b262cb4_720w.webp'><img src="https://pic3.zhimg.com/80/v2-861ad585ca6cda1a5e4c42840b262cb4_720w.webp" alt="img"></p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-0f6fca5c26fc8711bb543e61aa8522fa_720w.webp'><img src="https://pica.zhimg.com/80/v2-0f6fca5c26fc8711bb543e61aa8522fa_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic2.zhimg.com/80/v2-e4e0ed6e607a63b2c6c31791940bf46d_720w.webp'><img src="https://pic2.zhimg.com/80/v2-e4e0ed6e607a63b2c6c31791940bf46d_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic3.zhimg.com/80/v2-1f1588fd58cd94201e4d9ddd313f0434_720w.webp'><img src="https://pic3.zhimg.com/80/v2-1f1588fd58cd94201e4d9ddd313f0434_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic2.zhimg.com/80/v2-fb9eab8d8a0adcf4585a88a641ffc025_720w.webp'><img src="https://pic2.zhimg.com/80/v2-fb9eab8d8a0adcf4585a88a641ffc025_720w.webp" alt="img"></p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-25339614d611ab591671535ed41fb2fc_720w.webp'><img src="https://pica.zhimg.com/80/v2-25339614d611ab591671535ed41fb2fc_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic3.zhimg.com/80/v2-fa021e9b5f501d077ae6125f236b4a46_720w.webp'><img src="https://pic3.zhimg.com/80/v2-fa021e9b5f501d077ae6125f236b4a46_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-32bb1caff36b8b966294cf1171fed8ee_720w.webp'><img src="https://pic1.zhimg.com/80/v2-32bb1caff36b8b966294cf1171fed8ee_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-8a7b0c0991dc2f527a83d10b197851b8_720w.webp'><img src="https://pic1.zhimg.com/80/v2-8a7b0c0991dc2f527a83d10b197851b8_720w.webp" alt="img"></p><p class='item-img' data-src='https://picx.zhimg.com/80/v2-c9f94c7e04aad4d8ad1d22583c0d593b_720w.webp'><img src="https://picx.zhimg.com/80/v2-c9f94c7e04aad4d8ad1d22583c0d593b_720w.webp" alt="img"></p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-8459499e17ee5f58790bcef4663469fc_720w.webp'><img src="https://pica.zhimg.com/80/v2-8459499e17ee5f58790bcef4663469fc_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-7984fb0d9806e3bd9077e4a4bca05f58_720w.webp'><img src="https://pic1.zhimg.com/80/v2-7984fb0d9806e3bd9077e4a4bca05f58_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic3.zhimg.com/80/v2-64700ff148e27b071eb152eaf84a9160_720w.webp'><img src="https://pic3.zhimg.com/80/v2-64700ff148e27b071eb152eaf84a9160_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-d8677ce9ccb42b4672c03aaf9d527be8_720w.webp'><img src="https://pic1.zhimg.com/80/v2-d8677ce9ccb42b4672c03aaf9d527be8_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-863fd9f5b3f09b17de45172a4b7466da_720w.webp'><img src="https://pic1.zhimg.com/80/v2-863fd9f5b3f09b17de45172a4b7466da_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic2.zhimg.com/80/v2-ec9691e917fe807ab7db12fcdb6c21b5_720w.webp'><img src="https://pic2.zhimg.com/80/v2-ec9691e917fe807ab7db12fcdb6c21b5_720w.webp" alt="img"></p><p class='item-img' data-src='https://picx.zhimg.com/80/v2-4aca80833c2cf44b48d5767ea940c197_720w.webp'><img src="https://picx.zhimg.com/80/v2-4aca80833c2cf44b48d5767ea940c197_720w.webp" alt="img"></p><p>bp)</p>]]></content>
    
    
    <summary type="html">抽空整理的一些</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="概率论" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>2024一些笔记（常微分）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/40883.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/40883.html</id>
    <published>2025-03-09T14:51:00.000Z</published>
    <updated>2025-04-03T06:22:53.786Z</updated>
    
    <content type="html"><![CDATA[<p>2024的一些笔记（常微分）（共20张）</p><p class='item-img' data-src='https://picx.zhimg.com/80/v2-46b61367748a0b9ca84ad8e77800887f_720w.webp'><img src="https://picx.zhimg.com/80/v2-46b61367748a0b9ca84ad8e77800887f_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-bff8d14c462a0bc3c12ab228b3738c28_720w.webp'><img src="https://pic1.zhimg.com/80/v2-bff8d14c462a0bc3c12ab228b3738c28_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic2.zhimg.com/80/v2-72f2d63ff8c1e8897791c961ceb9fce5_720w.webp'><img src="https://pic2.zhimg.com/80/v2-72f2d63ff8c1e8897791c961ceb9fce5_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-55bbe4dbab38a31b64c54120d720fbfd_720w.webp'><img src="https://pic4.zhimg.com/80/v2-55bbe4dbab38a31b64c54120d720fbfd_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-28eb6637c83c134d95626532f0811970_720w.webp'><img src="https://pic1.zhimg.com/80/v2-28eb6637c83c134d95626532f0811970_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-d7f8da6dbf19f664c75bcf0af2e421aa_720w.webp'><img src="https://pic1.zhimg.com/80/v2-d7f8da6dbf19f664c75bcf0af2e421aa_720w.webp" alt="img"></p><p class='item-img' data-src='https://picx.zhimg.com/80/v2-09e62700abf7a00e674ccf9e2871eaa9_720w.webp'><img src="https://picx.zhimg.com/80/v2-09e62700abf7a00e674ccf9e2871eaa9_720w.webp" alt="img"></p><p class='item-img' data-src='https://picx.zhimg.com/80/v2-0711f3581b0d3da93f373e6ae671528d_720w.webp'><img src="https://picx.zhimg.com/80/v2-0711f3581b0d3da93f373e6ae671528d_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic3.zhimg.com/80/v2-1d8db7dd9bfe18f1a88a6554ac54a2d6_720w.webp'><img src="https://pic3.zhimg.com/80/v2-1d8db7dd9bfe18f1a88a6554ac54a2d6_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-1f9b72a957cc336f2723f5e5b1200c3f_720w.webp'><img src="https://pic4.zhimg.com/80/v2-1f9b72a957cc336f2723f5e5b1200c3f_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-dae1d6757d38da31d0268806b0d8671b_720w.webp'><img src="https://pic4.zhimg.com/80/v2-dae1d6757d38da31d0268806b0d8671b_720w.webp" alt="img"></p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-d7a44ef4db3aecd61ac7703db973e3e6_720w.webp'><img src="https://pica.zhimg.com/80/v2-d7a44ef4db3aecd61ac7703db973e3e6_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic2.zhimg.com/80/v2-8f264542c42648239218b08f2d2a3147_720w.webp'><img src="https://pic2.zhimg.com/80/v2-8f264542c42648239218b08f2d2a3147_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-62154c0fa582d94c3f19afa13a39914d_720w.webp'><img src="https://pic4.zhimg.com/80/v2-62154c0fa582d94c3f19afa13a39914d_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic3.zhimg.com/80/v2-2186401cfa936f05461fd316b74d521e_720w.webp'><img src="https://pic3.zhimg.com/80/v2-2186401cfa936f05461fd316b74d521e_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-68efd565744e3aa4f07bebded81d5f1b_720w.webp'><img src="https://pic4.zhimg.com/80/v2-68efd565744e3aa4f07bebded81d5f1b_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-e0d6d5588780012eaa9be2efb9820826_720w.webp'><img src="https://pic1.zhimg.com/80/v2-e0d6d5588780012eaa9be2efb9820826_720w.webp" alt="img"></p><p class='item-img' data-src='https://picx.zhimg.com/80/v2-6e20a5989b7616decf7100d284f7c1cf_720w.webp'><img src="https://picx.zhimg.com/80/v2-6e20a5989b7616decf7100d284f7c1cf_720w.webp" alt="img"></p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-eda6b00705f475fe29811605e5504a3e_720w.webp'><img src="https://pica.zhimg.com/80/v2-eda6b00705f475fe29811605e5504a3e_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic3.zhimg.com/80/v2-e1ccc9db6bf01835178384d0b01493b2_720w.webp'><img src="https://pic3.zhimg.com/80/v2-e1ccc9db6bf01835178384d0b01493b2_720w.webp" alt="img"><br>ebp)</p>]]></content>
    
    
    <summary type="html">另外抽空整理的一些</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="常微分" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%B8%B8%E5%BE%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>爬虫实战-爬取广州大学课程表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33971.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33971.html</id>
    <published>2025-03-01T06:55:48.000Z</published>
    <updated>2025-04-03T06:22:53.773Z</updated>
    
    <content type="html"><![CDATA[<p><em>大二上在学python，所以想要用python实现一下课表爬取。</em></p><p><em>（虽然python开课爬虫不怎么讲的都</em></p><p><em>本文仅供学习使用。</em> </p><h1 id="广州大学课程信息查询脚本"><a href="#广州大学课程信息查询脚本" class="headerlink" title="广州大学课程信息查询脚本"></a>广州大学课程信息查询脚本</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本脚本用于自动化登录广州大学教务系统，获取当前学期课程信息，主要功能包括：</p><ul><li>通过浏览器自动化（Selenium）模拟用户登录，绕过滑块验证。</li><li>使用获取的Cookie通过<code>requests</code>库发送API请求，获取课程数据。</li><li>结构化处理课程信息，并导出为JSON和CSV格式文件。</li></ul><hr><h2 id="2-环境依赖"><a href="#2-环境依赖" class="headerlink" title="2. 环境依赖"></a>2. 环境依赖</h2><h3 id="2-1-运行环境"><a href="#2-1-运行环境" class="headerlink" title="2.1 运行环境"></a>2.1 运行环境</h3><ul><li><p><strong>Python 3.7+</strong></p></li><li><p>依赖库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install selenium requests pandas<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><ul><li>手动输入学号密码（脚本运行时会提示），查询时段的配置请求参数</li><li>后期待完善（</li></ul><hr><h2 id="3-功能模块"><a href="#3-功能模块" class="headerlink" title="3. 功能模块"></a>3. 功能模块</h2><h3 id="3-1-登录模块"><a href="#3-1-登录模块" class="headerlink" title="3.1 登录模块"></a>3.1 登录模块</h3><h4 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h4><ul><li>通过Selenium启动浏览器，访问教务系统登录页面。</li><li>自动填充学号、密码，并绕过滑块验证。</li><li>判断登录状态，成功后保存Cookie供后续请求使用。</li></ul><h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><ul><li>学号（<code>login_username</code>）</li><li>密码（<code>login_password</code>）</li></ul><h4 id="关键逻辑"><a href="#关键逻辑" class="headerlink" title="关键逻辑"></a>关键逻辑</h4><ul><li><strong>浏览器配置</strong>：禁用自动化检测标志（<code>excludeSwitches: [&#39;enable-automation&#39;]</code>），防止被识别为爬虫。</li><li><strong>滑块验证绕过</strong>：通过执行JavaScript代码<code>navigator.webdriver = false</code>。</li><li><strong>登录状态检查</strong>：通过页面元素或关键词（如<code>登录成功</code>）判断是否登录成功。</li></ul><hr><h3 id="3-2-课程数据获取模块"><a href="#3-2-课程数据获取模块" class="headerlink" title="3.2 课程数据获取模块"></a>3.2 课程数据获取模块</h3><h4 id="功能描述-1"><a href="#功能描述-1" class="headerlink" title="功能描述"></a>功能描述</h4><ul><li><p>使用<code>requests</code>库发送POST请求，携带登录后的Cookie和参数，获取课程数据。</p></li><li><p>数据接口：<code>http://jwxt.gzhu.edu.cn/jwglxt/kbcx/xskbcx_cxXsgrkb.html</code>（F12大法</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/03/01/67c2b8ec8a7cc.png'><img src="https://free-img.400040.xyz/4/2025/03/01/67c2b8ec8a7cc.png"></p><p class='item-img' data-src='https://free-img.400040.xyz/4/2025/03/01/67c2b96c96a63.png'><img src="https://free-img.400040.xyz/4/2025/03/01/67c2b96c96a63.png"></p></li></ul><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">data = &#123;<br>    <span class="hljs-string">&quot;xnm&quot;</span>: <span class="hljs-string">&quot;2024&quot;</span>,     <span class="hljs-comment"># 学年（2024表示2023-2024学年）</span><br>    <span class="hljs-string">&quot;kzlx&quot;</span>: <span class="hljs-string">&quot;ck&quot;</span>,      <span class="hljs-comment"># 查询类型（ck=查看）</span><br>    <span class="hljs-string">&quot;xsdm&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-comment"># 学生代码（留空）</span><br>    <span class="hljs-string">&quot;xqm&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>         <span class="hljs-comment"># 学期码（3表示秋季学期）</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="请求头（Headers）"><a href="#请求头（Headers）" class="headerlink" title="请求头（Headers）"></a>请求头（Headers）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 ...&quot;</span>,  <span class="hljs-comment"># 模拟浏览器请求</span><br>    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;http://jwxt.gzhu.edu.cn/...&quot;</span>,  <span class="hljs-comment"># 来源页面</span><br>    <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span>       <span class="hljs-comment"># 标识AJAX请求</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-3-数据处理与导出模块"><a href="#3-3-数据处理与导出模块" class="headerlink" title="3.3 数据处理与导出模块"></a>3.3 数据处理与导出模块</h3><h4 id="功能描述-2"><a href="#功能描述-2" class="headerlink" title="功能描述"></a>功能描述</h4><ol><li><p><strong>JSON数据处理</strong></p><ul><li>从原始响应中提取关键字段（如课程名称<code>kcmc</code>、教室<code>cdmc</code>、节次<code>jc</code>）。</li><li>映射星期代码（<code>xqjmcMap</code>）为中文（如<code>1 → 周一</code>）。</li><li>保存结构化的JSON文件（<code>extracted_courses.json</code>）。</li></ul></li><li><p><strong>CSV导出</strong></p><ul><li><p>使用<code>pandas</code>将JSON数据转换为表格形式。</p></li><li><p>添加中文表头（如“课程名称”、“教室”）。</p></li><li><p>导出为CSV文件（<code>courses.csv</code>），兼容Excel打开。</p class='item-img' data-src='https://free-img.400040.xyz/4/2025/03/01/67c2b36edf98c.png'><img src="https://free-img.400040.xyz/4/2025/03/01/67c2b36edf98c.png" style="zoom:50%;" /></li></ul></li></ol><h4 id="字段映射表"><a href="#字段映射表" class="headerlink" title="字段映射表"></a>字段映射表</h4><table><thead><tr><th align="center">原始字段</th><th align="center">中文表头</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>kcmc</code></td><td align="center">课程名称</td><td align="center">课程全称</td></tr><tr><td align="center"><code>cdmc</code></td><td align="center">教室</td><td align="center">上课地点</td></tr><tr><td align="center"><code>jc</code></td><td align="center">节数</td><td align="center">课程节次（如1-2节）</td></tr><tr><td align="center"><code>xqjmc</code></td><td align="center">日期</td><td align="center">星期几（周一至日）</td></tr><tr><td align="center"><code>kcxszc</code></td><td align="center">课时安排</td><td align="center">周次范围（如1-16周）</td></tr></tbody></table><hr><h2 id="4-代码详解"><a href="#4-代码详解" class="headerlink" title="4. 代码详解"></a>4. 代码详解</h2><h3 id="4-1-登录流程"><a href="#4-1-登录流程" class="headerlink" title="4.1 登录流程"></a>4.1 登录流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 防止打开浏览器后闪退</span><br>options = webdriver.ChromeOptions()<br>options.add_experimental_option(<span class="hljs-string">&#x27;detach&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># options.add_argument(&#x27;--headless&#x27;)  # 无头模式</span><br><br><span class="hljs-comment"># 开发者模式，防止被各大网站识别出来使用了Selenium</span><br>options.add_experimental_option(<span class="hljs-string">&#x27;excludeSwitches&#x27;</span>, [<span class="hljs-string">&#x27;enable-automation&#x27;</span>])<br><br><span class="hljs-comment"># 启动浏览器</span><br>browser = webdriver.Chrome(options=options)<br>browser.get(login_url)<br><br><span class="hljs-comment"># 绕过滑块验证</span><br>browser.execute_script(<span class="hljs-string">&#x27;Object.defineProperties(navigator,&#123;webdriver:&#123;get:()=&gt;false&#125;&#125;)&#x27;</span>)<br><br><span class="hljs-comment"># 查找用户名和密码输入框所在元素</span><br>username_input = browser.find_element(By.ID, <span class="hljs-string">&#x27;un&#x27;</span>)<br>username_input.click()<br>username_input.send_keys(login_username)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 等待响应</span><br>time.sleep(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 输入信息模拟登录</span><br>password_input = browser.find_element(By.XPATH, <span class="hljs-string">&quot;//input[@name=&#x27;pd&#x27;]&quot;</span>)<br>password_input.click()<br>password_input.send_keys(login_password)<br><br>login_button = browser.find_element(By.ID, <span class="hljs-string">&#x27;index_login_btn&#x27;</span>)<br>login_button.click()<br><br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 检查登录是否成功</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;登录成功&#x27;</span> <span class="hljs-keyword">in</span> browser.page_source <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;index_login_btn&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> browser.page_source:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录失败&quot;</span>)<br><br>cookies = browser.get_cookies()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Cookies:&quot;</span>, cookies)<br><br>cookie_dict = &#123;cookie[<span class="hljs-string">&#x27;name&#x27;</span>]: cookie[<span class="hljs-string">&#x27;value&#x27;</span>] <span class="hljs-keyword">for</span> cookie <span class="hljs-keyword">in</span> cookies&#125;<br><br><span class="hljs-comment"># 关闭浏览器</span><br>browser.quit()<br></code></pre></td></tr></table></figure><h3 id="4-2-数据请求"><a href="#4-2-数据请求" class="headerlink" title="4.2 数据请求"></a>4.2 数据请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 请求头</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;*/*&quot;</span>,<br>    <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate&quot;</span>,<br>    <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;zh-CN,zh;q=0.9&quot;</span>,<br>    <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;keep-alive&quot;</span>,<br>    <span class="hljs-string">&quot;Content-Length&quot;</span>: <span class="hljs-string">&quot;28&quot;</span>,<br>    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;</span>,<br>    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;jwxt.gzhu.edu.cn&quot;</span>,<br>    <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;http://jwxt.gzhu.edu.cn&quot;</span>,<br>    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;http://jwxt.gzhu.edu.cn/jwglxt/kbcx/xskbcx_cxXskbcxIndex.html?gnmkdm=███████&amp;layout=default&quot;</span>,<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/███████ (Windows NT ███████; Win64; x64) AppleWebKit/███████ (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36&quot;</span>,<br>    <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 表单数据(学年和学期)</span><br>data = &#123;<br>    <span class="hljs-string">&quot;xnm&quot;</span>: <span class="hljs-string">&quot;2024&quot;</span>,<br>    <span class="hljs-string">&quot;kzlx&quot;</span>: <span class="hljs-string">&quot;ck&quot;</span>,<br>    <span class="hljs-string">&quot;xsdm&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;xqm&quot;</span>: <span class="hljs-string">&quot;3&quot;</span><br>&#125;<br><br>session = requests.Session()<br><br><span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> cookie_dict.items():<br>    session.cookies.<span class="hljs-built_in">set</span>(name, value)<br><br><span class="hljs-comment"># POST请求</span><br>response = session.post(target_url, headers=headers, data=data)<br><br><span class="hljs-comment"># 检查请求是否成功</span><br><span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>    <span class="hljs-keyword">try</span>:<br>        response_data = response.json()<br>        formatted_data = json.dumps(response_data, indent=<span class="hljs-number">4</span>, ensure_ascii=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;course_schedule.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            file.write(formatted_data)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;返回的数据已经保存至course_schedule.json&quot;</span>)<br><br>    <span class="hljs-keyword">except</span> ValueError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无法解析JSON数据&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败，状态码: <span class="hljs-subst">&#123;response.status_code&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3-JSON数据处理"><a href="#4-3-JSON数据处理" class="headerlink" title="4.3 JSON数据处理"></a>4.3 JSON数据处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提取字段并重构数据</span><br>courses = []<br><span class="hljs-keyword">for</span> course <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;kbList&#x27;</span>]:<br>    course_info = &#123;<br>        <span class="hljs-string">&quot;课程名称&quot;</span>: course.get(<span class="hljs-string">&#x27;kcmc&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),<br>        <span class="hljs-string">&quot;教室&quot;</span>: course.get(<span class="hljs-string">&#x27;cdmc&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),<br>        <span class="hljs-comment"># ... 其他字段映射</span><br>    &#125;<br>    courses.append(course_info)<br></code></pre></td></tr></table></figure><h3 id="4-4-CSV导出逻辑"><a href="#4-4-CSV导出逻辑" class="headerlink" title="4.4 CSV导出逻辑"></a>4.4 CSV导出逻辑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用pandas转换并导出</span><br>df = pd.DataFrame(courses)<br>df.to_csv(<span class="hljs-string">&#x27;courses.csv&#x27;</span>, index=<span class="hljs-literal">False</span>, encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>)  <span class="hljs-comment"># 兼容Excel中文编码</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ol><li><p><strong>滑块验证更新</strong>：若教务系统更新滑块验证逻辑，需调整JavaScript绕过代码。</p></li><li><p><strong>接口稳定性</strong>：课程查询接口（<code>xskbcx_cxXsgrkb.html</code>）若变更URL，需同步更新。</p></li></ol><hr><h2 id="6-输出示例"><a href="#6-输出示例" class="headerlink" title="6. 输出示例"></a>6. 输出示例</h2><h3 id="6-1-JSON文件（extracted-courses-json）"><a href="#6-1-JSON文件（extracted-courses-json）" class="headerlink" title="6.1 JSON文件（extracted_courses.json）"></a>6.1 JSON文件（extracted_courses.json）</h3><p>和谐了部分隐私信息（</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;bklxdjmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;无&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cd_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1015170&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cdlbmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;多媒体&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cdmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████517&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cxbj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cxbjmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;无&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;二○二四年十一月十五日&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dateDigit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024年11月15日&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dateDigitSeparator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024-11-15&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;day&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;15&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3-4节&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jcor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3-4&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jcs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3-4&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jgh_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;104119&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jgpxzd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jxb_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1850E3A697E512CAE06███████ACA210&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jxbmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(2024-2025-1)-216███████-01&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jxbsftkbj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;jxbzc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kcbj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;主修&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kch_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kclb&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;专业课程平台&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kcmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;常微分方程1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kcxszc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;理论:48&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kcxz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;专选&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kczxs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;48&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;khfsmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;考试&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;kkzt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;lh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████楼&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;listnav&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;localeKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zh_CN&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;month&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;11&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;oldjc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;oldzc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;65280&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;pageTotal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;pageable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;pkbj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;px&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;qqqh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;无&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;queryModel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;currentPage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;currentResult&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;entityOrField&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;limit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">15</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;offset&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;pageNo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;pageSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">15</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;showCount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;sorts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;totalCount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;totalPage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;totalResult&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rangeable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rk&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rsdzjs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;sfjf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;skfsmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;无&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;sxbj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;totalResult&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;userModel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;monitor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;roleCount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;roleKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;roleValues&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xkbz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;无&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xnm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xqdm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xqh1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1,2,&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xqh_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xqj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xqjmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;星期一&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xqm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xqmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xsdm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;01&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;xslxbj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;year&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zcd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;9-███████周&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zcmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zfjmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;主讲&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zhxs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zxs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;48&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zxxx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;无&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zyfxmc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zyhxkcbj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;否&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zzrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;███████&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h3 id="6-2-CSV文件（courses-csv）"><a href="#6-2-CSV文件（courses-csv）" class="headerlink" title="6.2 CSV文件（courses.csv）"></a>6.2 CSV文件（courses.csv）</h3><table><thead><tr><th align="center">课程名称</th><th align="center">教室</th><th align="center">节数</th><th align="center">日期</th><th align="center">课时安排</th></tr></thead><tbody><tr><td align="center">常微分方程1</td><td align="center">███████</td><td align="center">3-4</td><td align="center">周一</td><td align="center">1-16周</td></tr></tbody></table class='item-img' data-src='https://free-img.400040.xyz/4/2025/03/01/67c2b36edf98c.png'><img src="https://free-img.400040.xyz/4/2025/03/01/67c2b36edf98c.png" style="zoom:50%;" /><h2 id="7-todo"><a href="#7-todo" class="headerlink" title="7. todo"></a>7. todo</h2><ol><li><strong>可视化界面</strong>：集成<code>tkinter</code>或Web框架（如Flask）提供GUI操作。</li><li><strong>全校课表爬虫</strong></li></ol><p>�**</p>]]></content>
    
    
    <summary type="html">爬虫实战-爬取广州大学课程表</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于WSL Docker清理</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33014.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33014.html</id>
    <published>2025-03-01T05:54:15.000Z</published>
    <updated>2025-04-03T06:22:53.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows下释放Docker所占用的WSL磁盘空间"><a href="#Windows下释放Docker所占用的WSL磁盘空间" class="headerlink" title="Windows下释放Docker所占用的WSL磁盘空间"></a>Windows下释放Docker所占用的WSL磁盘空间</h2><p>使用下面的命令清理镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker system prune<br></code></pre></td></tr></table></figure><p>在Linux下面可以释放磁盘空间，但是在Windows下却并不能够真正的释放硬盘。</p><p>搜寻了一下，发现有一个文件超级大：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\&#123;用户名&#125;\AppData\Local\Docker\wsl\data\ext4.vhdx<br></code></pre></td></tr></table></figure><p>这是WSL的虚拟机文件。这个文件看起来是只增长，不回收硬盘空间的，所以，需要手动回收硬盘空间。</p><h3 id="1-停止wsl2"><a href="#1-停止wsl2" class="headerlink" title="1. 停止wsl2"></a>1. 停止wsl2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><h3 id="2-运行diskpart释放空间"><a href="#2-运行diskpart释放空间" class="headerlink" title="2. 运行diskpart释放空间"></a>2. 运行<a href="https://zhida.zhihu.com/search?content_id=241674682&content_type=Article&match_order=1&q=diskpart&zhida_source=entity">diskpart</a>释放空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 代码来自 https://github.com/microsoft/WSL/issues/4699#issuecomment-627133168</span><br><br>diskpart<br><span class="hljs-keyword">select</span> vdisk file=<span class="hljs-string">&quot;C:\Users\&lt;你的用户名&gt;\AppData\Local\Docker\wsl\data\ext4.vhdx&quot;</span><br>attach vdisk <span class="hljs-built_in">readonly</span><br>compact vdisk<br>detach vdisk<br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://link.zhihu.com/?target=https://gist.github.com/banyudu/af131c7bb681e8a80b5cbe2047e62d4c">WSL2 Docker释放磁盘空间</a></li><li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/f7cb8d952427">wsl2 下清理 docker 占用空间</a></li><li><a href="https://link.zhihu.com/?target=https://github.com/microsoft/WSL/issues/4699%23issuecomment-627133168">WSL 2 should automatically release disk space back to the host OS</a></li></ul><ol start="168"><li></li></ol>]]></content>
    
    
    <summary type="html">Windows下释放Docker所占用的WSL磁盘空间</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>创建一个网络包解码器分析DEVP2P协议</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/20624.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/20624.html</id>
    <published>2024-11-04T08:45:19.000Z</published>
    <updated>2025-04-03T06:22:53.788Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="如果是项目组成员，请联系站长。WXID:Zhong_ye1" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">      <script id="hbeData" type="hbeData" data-hmacdigest="d3093aea8077539022f106c3b8848260ddf4d6f497c961e14034679be477605a" data-keysalt="f86ec4d59212f14f8063d6e7d57381e9ca51b9fcfb80ecc5a171755378dccb18" data-ivsalt="eb1dd8e96888d9d31e22bfeb30bebe20181270850bf7a1381a48d660d0781d4b">        08cb5f74ea5885440b370a35f36d4e62d5cc89f60242732dbd4f81054e659819b60756d7d16c88f6f5fc855c7738c75408c30704583b12f530290a8964ebd6297e52615e0793db3a61df1ab25fc72f3caed51ce32121d1a7f875d1c56c58a3be615ba4386cc0ec12266dbc904be351f0576d23a139a02cbdc50e210ae907c80fbc961ace5d260fa5165e638207dea716b652bd0220667d85481f2f71c1516c0c1cfe3bef38b1437e9ff6aa41e94b606d6648d592d7efaf9d16a81c720986e446522ce4e771735ccac72b788c331ed85c4202108c87873fa7587aca5b78d659b8f5903fc38bc1fa990aa6a13960acabe2cadcd2ab854ee2f0a9ecd977f4e24ee2df90b2724dd3e2eed58c00490d48ae5a39600d11258bffabf971c4267d5bab1a31ca26ccff6758315dda055f3e4e3b6f2934ba8d848d7df78ff2ffc7031e004552c5c548410a62b45b11db865f39c4404dea16e5e68bb54688b2712e34804a77bf2bd8e47c5a59ac96622a01b1304850d10ac117a0792bfc3691af8e3022250a053705194cdce822df5ab75827875bf1a5742919cacbc2076b316991c60526f2c1bac088cf944698b9d8d3f8870a35ecc5bb3a1a9daaa4b8118b30e1c41b54c519fe924cf53614ae9de35753ed22be1fcb7cf40f4ae1df1ee72ccfcee3a2cc9cfa371b6ad8d2a2448cc6e4b8ee93d3ffc7bf28504da2ed286c3dff93cefc9629644a06f609b8221bf33839c56bc8ea65e1941e4615a7196afc7e3f49edc13caa238dfb46db7e991f19efed5c2eddfcd4332279b08853d7830f2a0aac36213f15f3878ac00516613366e7545cc1a4e9937d5e294d3ead922e689da7ace8ca101c61dd0d565e7a588a6a6be8c1e67267fb1e2696383b3a13ea11e3a64e4b373fc387d911ac37ca1327070a2e371bf864a1f8a3ee74a190b01f1628f275c28f68dc466d03b47857c357fdea73eca8e2c6ca5b241365544d3b2bee8aba82833a8d330c73980ef1df528876ceaf07770fbc7de4dbf5bf5200db7381af4931fa1b45ce946b913dfffffc065d66e5824cef7d0b1bc0da432de940faf106bea02541d3aa4fa08ad0890a049975b08fedc030e2793c48e0f87114e82f431acb67267832127d16112120fa3db344b211b8b0763630d2ff2d55f79712063dd5ca6d0fe71c36952969acdbd22dc04659c39777fe675aaa9dc9a5bd926577cfb1104cf512d3427dfa1068bf201b4415a76b7fcd8920b3aa34d42fc72da4e20de0e3942ce69c3e8f8b01d04ad570c2b78fbcde8d62e387be8eac688a124c565b535863e4b87c3ba715a77279f82880ba5eca1e788a9265072a2e0431f500c4fa035a32a05032b273172cc9a954fc2de3e636506f4d57b440809f8e5b4b75fb329d1e7abfd8235484643e778a8b3e6c29fc2f820fc07121c499913357cd7c730d59595d1aa84b0fba4cdcb6f41a6d28069a6d475b136dde00becddccdb2d8bdabaac1be10d087560ede6d5b0d7d37a997336900453300708c4a33c6c48e0eb792d38204df889459421d7f2b6a3fefff306628172b0f4f49a106d35cce13485b41e2fe508c9f3ed1df4b33c0343e2df93b452dcebf8aa16c9f9a050c6e6ec937a24c3cc44d912ab51a94ee94ae3fb2e855f85b150fe160e4df03e174412590ac8be64e8e54238e4253a16837f3ef71b89efb7fa011176cbe2ae6ef8cf724e8d4e73b42cbc72d83a63525d7c584d769ebc5deaf66b22e7d7c34fe776369d553d10e6c324b2d207a25398162302af85ef9a35533e4773e2b50bbda6b775ee17adda062dd58f413217461cf1256097facce5da701478dbefc9a953e798eed53c6a5725c1a2129b47d7322e5507216a7ac74f9ed72724fbf4ba2dd7b5274ca9fad669756e27c3d38fb8d416154e21883e83b40498893932b18b58c8a83f421be04300774453ad23befed70ae29c75149b118df4099c4cf65c3aae522f45e305e30a5d7d80c8ed1816e84f16cc27a7eecfe4e12ceff63395af257f2c448eff2d393c835b6c6ca77eacc04bf7999c09ad51fa3e50af6f7a898c6cb6bfee6b183d19314a880b0a05a4ff4d732353a53ea0ca55407d010132e4f9f9de9cf0f7032ec5892ee50a220178ba788bdf64cb816ad178c42090ad06021a9b21ec93d849ebe6055b65ba427b1102a1faa7d20d8203873b25c5b1529b5cec3303ce3f300d24f619c117116d4cf679460fa47a41246d2a88267d9d859e5adfab275f7a56b5809de2242ff7f004285998e7eb6eaee3d1ca0038f64e7910858a3449cbddb46f9740b07625203fd9e70a83cfd4ef46412e0299a34bb8a9eb8e47b00857543a5299277d74001ab26b4709211bdb1238130a009f81f6b3c93bd9580410a4568cd12a9d6e50ad81bbcc2eb76e7fbb7fa014a5975c923a2ef416095417d19868ba908f1c5f1a7512c4a646fca1577b34a114aa4d7a197ed3e43aca427ab98e9c693ffb677d7076543b852f866fe8297769b715e20c48593eaa91ff4e113043f1bad93eee5a6a16e093ccff4aef212f38844c5ef31daf7d4bd0517e1a857b7eadcc5cb510067471c6c6668592743cf9e5b2cadb866a9ea10108417098793721a3e396cf743cedccd341aaa6ecab4bdc51a7126a86c44a61a5c6caeb691d1b96e001145a11cb3106d541f0ac8b43e858224ed9bbab8f6572b1df33add8ecab90eaf45ecbd6b07b92e77794b2ae0a03c6e92351950753ab50efce0eb2c87e15320404710130460e682d21ceb162368b40180f2ed6a9052035591110c67dccf8f40148a5e6e6e0994082900350366797f370b582cc6754471e8f7c3ccc0dfd8a088e64f861819352c5ce33d637734bed2dafc7ad536e0fba1f861e10ab2162d8e1fb6e2448d2ebd16e22467ab4e6a0439e0dc78c926834cbeb8de4698c1724681d1c25bf6a2b189c91ee55dd8b9da3e1f4ddcc965209c9c20b41fa4a79bd05a5139a66991c4ba5a04529f3a5ffe5425504de06a3482dc72c1a3b6d83d52836af09747ee843d4920c795bec12e93d8f7b2fdc563215e7f2a8239be09ced6fc9b2f912ba0a553e79dbe39f3538f1bbb23e1aa7e552396207b4279e9bef6d4c6bec7381e4d435064d20606067bce9c18c9c5da43f2ab266c6c92b9f52cbb46cb6a59fe248bae1071a1570d7fed43be617157d112bcebad655fcc4360ef5f281198969d3ba74fc99ec1ec9e5802e0a9a7e038de4b0ad7a20eb947cedeeaf22844e013b8fdab202d6a4a3e9e97d6b19a34997c2b1458094d4ac303ab432c55183fcf18d8f0acdd564e3443fe38575e9901107dd2c848f56e752fe1d726777f363c2c8ded2930f48f304e01c7d99f16842db3663e9d6a5faef5b6f6ae022b2fe4e245a9308ebf6906aaec14420635a5f511de3dc3e90dd19b68b56a3d9747f7c75a37e38417d46d0cdcba445f10cb400ad0b562bc5e759fc4d1575cd63904b6ce32f8a61a05b1c257be5744eba222a5dbdf87933fdc4f60eb02169da5c2dcebfab8a422ffeb030eb4eb6224314e3ccc511c5dbbe6d9ee2de28acac3c7b0154d2640f82b7385023b7e578e25ab8801ddf70c2f4dc70ca3a95aabb18444b82b655cb9d53da283117df11dd73817e8f0c503dd4ca2985cae686630f8042d796195034f91b2cc1daa26a7e522f8fd71c1e8d89f18b4f43d9197666beb5e43433a4607cf570b62a0879dbe2f2d176388883c21cb7841e5de5a44da5d7fbc9ab49228e3b36778843687adbf749e360084a5f40c20a9345077715525b199e85e404668fd9bbca3e348c4fb5ca2975789d1250a472d8fef8e73f320b9f4722d1ac529a0be10405f9574e337061a164bb22f351983518d2154ad3a2890050c865fc9f0835e8864edbc74ae7b5838625dfbd3ecd228d6da3d1a60b27289f40ed3950b41f2c29aeab71abd45b6381f8fcbaeed4d6ed5d94ab33778374f140b5a875eefd8d88a466c5b504976549141258785a27ed929b4014543c2f6722271294e9c6b50fae644cda9f84ec4e66e81ccbf72d51f36b3e8c048a3a502e9c7ae60e6fc5f8b11b5507c339edba1bcd2b04762dcabf9f8ef58c6bba96f3f6ba82944bb86c642ebe8c5a2fdc6e8db84f668d759cab4ce58fcf935da23578623ce01458bc1a75bbcc3f943ec2b61169859c5d488dd3fdcfbe4fb6442bce2e068d09f6b1c52a4d81b2e77f0ef24647ed9084402278ce30e88a5d3cffb86097b39235205274ba60a0516327693b7a6b479bbf5167cd562717b068a41d6ea0e115d41260bdcee0d99eb048d2e48e9d36975cc03f7680c9c32e83e94e13228773866bdccd79d0b2ee43018fc141df52cbe334e8e5cc2222597dcfec0ade2cbb1b7eb4a88b0624b590803990a4dd0592842d33b02e6483f185147cfdafc221f0782293d9ca0d7abbd6512b99d9088c99b818fae29b0718838fe6ed3416c45e1492d8ae635f9b240d2bfef2c6647948fc1f31965a6c866710e4ee376c3d342b339e4cc6f00242f16392583e304fc491518e3b12ef449877fcf2d6d2cc450c52c85a554e58f6df773db3b4acc24ac5ffa793cd75e76b18cdb650eef097d71b6689b2c998df7fe3d342510f20601558132672235989cfdb788aa1049335e9a5c179c1577c246f7643b59ce317c9d5858a92676ddda850580cfe37b5b7149739b988f56b13adda06550d7fc5df879d3f969e03922af345b977e36d8b49b1d1f60bb504972ec6b2c9811d2b25cc85b80a02b3d90debb1963841e1975260321e00675c6bbac4b3430bdd83bb647e2bb5fa1102c6fb72d254d516d2c73535e92d90d25d811a859156090099c37863d8e27035534b8f842c1dc2237100a3bd2200697d4ddd5561884664f63bcc447c582539974808bc2b55b5e5d7b53c14d15d9028f320e210c59a54139b5ea9bdfda539f305a188f3ce2714e6ab299edce8d3af1f609a67d57464cb463cfc3c0bb718b7b199904f8306a234dff1a93658e722d582562153e731fc740eedd023c5e50a005bfe74c2a3ecb820a27b8b14c23cd78c8ca0d3058fb5bca956f139966de515e4dbc8790a9ca102541051d02bb6922bc54c88068f58314c1df1ff3e9fe452dc60e61a4d75b1db9ab764e1e21ac9691d4a9ffa112697e75e9ad89512a368e8ec72c14b22f7162ca1a90e9930536bf79745bb53b206163ba9fb6807e7cfca0750de7c59a46d9cf45f1ffc6a4a5ea86b836f5e359b219f152ffdb1329881d802ff1a6251a20203f104dbaf3de0ea6aa985e03c37a5731c906c2f7e3ab7991580cf38c09aa567ea075d6bb251688c760141dd5a0a017d69d422acbe46665700a737d9ac10089f76b299813720456075f4b756aec4fc3dd0c1d30dcc03619bed67a4195c4d76698b0c620585cf7fc0ca6b77058773cefd5265896667eabf59e22033380f4653b0887bf63db405052c933a50496a85da83d94192fcff5c92e0e3d3b1de26021ead806f034de10bb031db109455d0513c73c1d6858d0ab8a8a4352fc75f8e96fb4732c1718a13b4a97f9fd3fdc9557e62439d4a8e03d50ebda6c67e07f1475541b94ce47bf6ad4fbe799b82ef0ea17656af7b6f392f2f50f1c2ecafec96fc03dceae0c399278532dad0f273103fd1520eeb97f673c154440ecff0151417ebbb023af77071fdf8950d3c10cc644bad05bdaf4a09f50df6a5212699109a71b324127d06918a1081ea64c7865bf81a10a00f001916c6471f7f5d5c746c27df1282b808d990225811d62916e63abbcd20ccdac7628d159d4c14c127731e531c04cc31433ed2bb17618db4c56c7647fcceb4bc35e764d76cfb52ac4fde2142e0755e35a96ff7c3c1a3568052a29862a4614de0e01079fe4ea6378bae1ab3d60dadcf682bd91f52c1de97c4a8f0c51a36c0c741feb99687d2f4862d54c244d64ada2ca95a92fc96835824bfda136c54a1b6b16070d39ef6a57b9773b29c7ed52ac9f03d7024b8aea6a699a480d68e0809f3370a32e4bb63bd51750fd42a3a35dde7015513a6a7027b89e9a6c9f4eeb168aee7948ea1807a4de9397942310e11cf64558e1416eb35a56d7fb9fd1b5fbffc3651eb0d01a3412dc90bcf5409ae25726e87b0d512af2fa0691427384759034b2376adf55300eacb33d36087e78b2e71b5aae4d8907c2e3f266e379824a72982b932c4f98d9468bf70d0f8b22064a413c4e21ed15c35de257ae0e082b58628515cccbea0942f3bf482fa46ea2beb71d4fe478150108d0d332d70eab783078324d86129c078871b610b096e03baf2a2bbebd1fdcf6e12a5fc7da87a9e8ebae164446a7c02c10b899f98336460a781a35c2380fe5c13b670bd96883e2ae15a7dbe10b4102828eeb36dac5876f8b04bad3c483129cba89ea1fa35b26cc13194d1c22f10898daeb1fbbed75d101841643e26a1a2efc68e051035bf96b140da0665615787d558162242c0e627bbccc59326af26bd1ea2d2220e4ec5de334ccdeaabb41dd3e3e2d4024076a4b2e588f1e59bae2c3bd1e00e502aaa2dea76824cb548972a0b2c5eacc91e3d91109dcf282cee066c6c516da2af1df32ad2e36b94103996065dacd6e6e5f2e1a6099ed4945bc3cd9173fd848a0a7825bdf7827ece7caf3c9cc643148f1b45ce8f4d773f1d90f90427264941c125e81e2cb4cc8ce75fde6eeef9353db7ea8d1026785caf68ea9f527c343c6ebe4351aa83b11acb7bf54a42b1c4706e15fbef1417e921c54b49cf321749979d440c9e19a949ffd1bd0b63fe54e1012b429d3eedc4ea28797e2f3b8b4f15248c7cfc224833f87fe5b8b966b3dd59f689842a250e238dd2a338ffae4b3010e515094a213d22e8160219625808f3e4363638d129890d0123039e8fff4661558e5253c3497e563a4306767ed164eee166ca39c4110d6818ee88ef7750f4d934bfd2327f78686778bb3372573e0446c86b4150066d85168536617a65ab020f32b62256bf15125fda4b6c8226ad693191e1936992c7c9131f2aab3e432f54e4bb048e5e7cd2096c724a1f0b01e66ee964811981ed88b46ad6a7b9922f04dd656c098b61b17054d85ee5224add980a35fa0904d9947e4503099090e5254988bcc457b244828d9e1abb054422fc806b6357fd01833ecac30fd7cfd721eaa2a9916b6c7fbdead27ef760b87e711abd6eed9b448ac22f9aa8df91e3561ffc282fe73aba5a5dd2e72b4bef83212dc4bbbdd1093098298cd3af3626da57755bb1bdf815382cd4affc9cdb7df8b2a781119402ad1856bcf0d4378e2f0fdabd4e9413cca3d8ec029d7a53e4957b741873fe5a684e1c8172d429f618e8974b0774dcd979cf8d6abe706c786418c5b8ebe3ef92d0ad2ccf7993daefe8b15e7473b8ae7feba582f089d757bc9071352841ea5cd4c35cc702481ee2ae5305486f8e5afc852c2d7746080d24933c0d360ec2eee9f075bbcf6017a83ea3017e093f063c28bf5a6b0e42d4c9a5d246635e6ef80bfb50b0b454555ffed7cc732086af48eec659ca740de3346c661082d08d240085c79514194d29175a3f1014a51139fce35df0e2a8113ca80fe54e0e4da5b8711eaa1936d30be7302566e836a4739d9e894d66b9dbe9f12af004da4d9af174f3fa874a53b1fa4eea1a87c59b145e75a49dc20cef292127e16144ebae251cb38ba19e5f4a7d724ed5cac8d43a1effcd19fa289ad73ab8a78330a22c42fd36a0bcadf0c4d822be41db1064e1c71527df57cbad41da00b6e8b6b971c11d4dfbcaafbff5a6673691b4108659938a91a1b7ebe5b093b5b2c7b9419247b5269ada12d51cf0737da18e416534bced1e4fa7e6e1aa1fd1ca86c7069ee293adf7307f9fa3fdca12a117fc77eb323eb16f03da25b615643feb14898e2602a01a973e112f24c332f04f110626d19de37634593eb93ca03c2e27b821d75ef7b5e27de4b11a283df3505299d8ec5a1c928693b5784661b165e74fe1b960d895e0e602dfaaf2805b23fcb59c6b8809bc81298169b7f7ac6a0f286e3583805e866dfebdd50b103945c17e3ecec1a05047157ca87793ce81b0bc8a05ee65823ab48bf8beb2a4abe43c3d725ba1ca37c4c81d2e0efa117180f1af3b9150c07d15c54525a7d5a6f5148477434a280ca61d6219565307fb1da57569abb737164be93a59608e516d5d7698379efffadc2c9597e63f4a248ccf6ffa4411d0fde792f59fc8ff8bc84b675248904418b44e48f445006857b57a480988f0206d45c6163b565f4978801ed59c6e453278193e0d3ada4cd9fa2be1b6cb9e362c9e4d8a96a8d728aa689882de56ef58339e0e21194ebfb2a001bd7f22846288148e42c088ad6fb9a8bb1c59da769b0c29288c40bdc0c03762831b1f771b499cd416f50d7eb2f2b80ab9b899688d5fa40f7ba4716f5459501d45acb4aca2a7eea694d40610dca3ff012222b1aae90df9cc54c37d80f56a9d8f643f634c075ff80d0167eae4645925c5d1cf833818c96046e9d3343438729ef4acb6b7a2a8174b8e3992c45698407413629859587e5f0caeb775c1bfc14d5c151246cd708fd4f5254b59610f8cf08af8a973bc3252a1e95ddb733063d7a8667c3287b86e3314d54030371fd3c4023de82909c97f1a4de4f89ab8d9b5aff3cbaa8e38b5557ed7b63f487ef83ffab43ef540bf14fc7ad41559d5c8d8bb607c368ea1c37884e0f36a26840291e6659aed42f61dfb64b5b1639d8ecf01237f8d968194139e3090d75c8f78aab1fe0d23b2485e1c14969cba9a77431e965c07f4ca8cd33bee5ce63b74929964c4bc5a9b8e4ff6ef3f222df1e63cc88cb15b45970edcf821f4444a857fbbba6e8bbd0f62416b406219695dd6f7461f654f5355c54b13e72e160d36e296acc71fc1e034a6ad48399104f9132dfb7da339b469d457e7c76766de831896a1331c7b83fd8616747b63cc57289bfaea0f3058f3971177f077df3115411f9241234c6101dc213b14c3f352fefb1c7f219b074ed794617d1cfa715a03d5fbd38b05bd3d1309f2b663f918aacc49b83102c20a34e99922fa4d6b54379054d1332dede431d8a26a4f6bd9ddc38dbeb3ac193984c68c93b15afeb5e171998b22f986de6ca51f1af4df841dc77891f7591325721155d9689279bee791867a4a84366a0b6bf4e7f449ab42da1df98c3bd440851079eff289416adac864daca4aeebe0e58f0481cc2467af9e7c91af28ca6d5c95100a2235e1d87500032197b03032d28d6cceb0a8619b3c27fbb9c9504f598c6508a1fe5c9436c4c2e1c9d7eca207cf95dbe279fefbd2f6be57c57eca5fe2c130362d0cd3df139c92e3f4bf1c5efa326767f56be5d11632b3a8b979f51f8460963a46bf220a6e89bfaeec03a6c847ed9af92cdd777b877567cc9cc2680f086203f9169c94fa84dffdcd5cf7c79d62c6d8e55ad19d3a311a2c1da8aed3c57aa2ee381090393531a5ddcdae6360666b01f4f929225634ee0b9a721bb9f77f437c4ab44e2b07bcd84cd181807a7791846adc3f963832ba00161bf8d87c9b6d251882a017c6e41716dd7359555658c7fb196afbb00e1eb45db7ad4223b74742e0b0260a8092c6e57167e8a1520f93620139c7a21cae4a383d7de87ea933663cceb7e8cd7feacc34f27cb0ef1778e6b10830c06c739059cd006268a3be904f7320b13a47dbca92043d79c045e9204c5d3eccd61f867349de2d31c71e7540e1fa585f50054a3f3b5b9293d3b5d0f43932abc03e20f82ec28b253f807cf923f4a7ad407799798bcf8e2591717c66ff2939946eb6c16693cad8fe7e425d9f38bb3c3d02c860fc894543a06fde088fe7c0472849396adf9905aabd2c8b7feb22ad476766bbf4e8ef1a228de7d017f59d9b92336228db891676e61f712f0c327f78716b1bc9a6fb526481d37e0433076dabf7e3262ab5150bdc0d3c30a26b3e155ae00f298d7b284ec5825e6fdd420f32ce19045a49ebeb1d4a88c9e65e99c781d3be010137fc5914304630363f266b9651de49d34961ec8bc9a934b7ec501fa56519171dfbbf2b41d44612b66ab43f72838b89d522e288a07b31e7d577c6360649271efb2d733b5523406ee0cf9581b5da7c1ebdfc3fb7b227da9e78270541ba8616e0e14b6e2aa0954408a6b1cc7a6f11a91aa5d0d9c1249d4969c3f8daaac709460f35f25a78cfecd5a51dbd136bc0206f213e86964b4245a7b339780b8dfb4a83224e2d8fd14fb30e2daca50b9c04b2287d4d5be4e93deb4400970e284a5e23c215f84a100a57c053aab2f7360338b18597b14aca78d15963defbf6cb2d624aa7603a54c47a17880f796fa295b74b76e5466b998f7c0286f9b65acf45124e4b40e89cbae5c0081b9d5223fa21fcb575c42c9beeb4f584560a77dfe686a31be954a099538fa63466d6de538562e56c28534591cf84540c1f1531864b1a8866f741a6f7c5b2fe9d1efff6273568190942fb143b996c4a685bd579efd99c5f45ae6745862d7318a7bdefb8368754c43417e323d448b05b893ec41783765d4a5b94757bb5cd8c45d4b56a09a188f3d26cefb81890d02e7318e349b66042b3fab82bc8c216fefef4298d23989d724034d2d745a482174bac8d85dd106aba02a2f4af05fdfa95026c625b49f21744bdfe035270e91e61d72061afd4c3894c1f948d795d4ab791965d91968eb070ecce284c4be2ff17989571a09efde0ac308df2f1181ff6380acf2c0093b5308f7abdd64de40445e7ad1ba43f25df638d88b966a790a37575661680494db6410f3f082c87cf766d7bba7fd1858d326cbe5eba218dfb600a04ab3e918d9d2794acccc0095e4bbbda29d83d14c23f76975fe52a405f69497042f70356b34ee33c2d50a2b0f16aba251a823746089823e3f614d2d940539f8838c2a3f31030f4336cac027c50044916ae1e03ff6176021e9b10c4ca4d4f5c6af61f5778a6fe2a4908bda4b39e32d99382c5eb27ed2691cc4ad00e932ca1e1c5fe13f4598e9019906ac12c3fd86a07f3aadb998a73b5b2947d745c8b72eb9b805cecc31f7cee74b24408d72d04313078569de6f3ac5a5beca8972ae1fd653b70dddd46efda2fb753b8e920fd76b40bdb8fa251f90ab313b9c6fd1cefe5d5f9f9074f115814f471698a080962095e14d50d00121ca8c958806422beae1f13dc3f0ac0f8d9aaf3b880266d7a26c476da0b4d7cee6bad0a1a77a2edf0c2457780dc77a85e20a5347fc8f7bcc6cdae1cbdafb831a61cde7ab1779286733602917326e198dd099bc8b20f8b95276a5298265f6b20d193c94c8db5ba5bbeee3dab7789cfd2fec6408acf0f5fe61bc26aa7dca487e569ec356b279d7751cd961648465412923e0b2b4405e11d77c7545d042fbe08426bad633d804a5c27bb9e96226bc24ca4bc6ea6f2a593049385095927f2964960d159a8924706ccb99d4ba50dcafde4e96037301e326d473b2ef3549dfab1b22f4b4f4848b6d578f2150fc8cb0c9f737bd1014b4459b682396e0eda98b4232221b6a7d925f068298b883e780364516f68f8c517f9de517a9c4ad5d3bf3728ddd88ece7bc023d954038e9c6967ca6b7394398d49bb5df357b24df5b2fe6ed99d2432d2aeb27024e4784a39627563fe4f0a54de15f46e9d61048f99a628aa239370a64b93281a03d0b73857fcd093fa7cb90fd4b6d3e2bc75591dc46ea1d4b5b6f6116a90c8cf94b4d83278f406c9d6f51d865c5254131d1827f064ed20fa1a1523c59a03bf8a6cd3a473366bd46d4a7bffaed2dfb4520f0062288dbf25d9b295d63c07357ecf917d9ac6846a2e20299e747ac81859d0666320ac3a5c31ef1370b6152dd66754f389f3b5dac53618310a76089e3b1dea238d671b2ac93dd99bcf926bf8ea0c15e091bbb2747e6918997099b9a265bd092ae697b1bef9f9a504a08a26983f1d866f4f6535a8837a484ec59b0ece9b3915a96d67504006f8c34b1bd2e4b195710b668a085efc3f0b9e9e2a5377b7e89f3f35507392934b00d12c3262b89a9075b162d382e45ce002b9db8123f7362caa02c9526077c623bb93bd3234a33142ea5a1a076f5b50bbeabf841219c5909fa0257e851c0ab50db975b847f9c9f1212e983a03d54a9faf7295899eabc403121bc5901a6f8f076e656be998d667d41969f84de1797b649fd3b802845fa8f0e7f3c37ceb9f969365dacddf04993b942e0b51ebf85ded307aab7e6360bb53436d7382b5091ebd3cbc043fb38aadd3a187c3021e8ba1078f82d5634d82fc59f214a14da687af80a17cfd6f615ea420d6b14adf8f7701ec115666406f7bd5c2eb15e0a9e7389334a59a6ac9e8f290f21b9bb90e5fce3a9258ccda8dffdc1aa5968b3c0e6758566b74f86e45936790c8842eda0275e35da16f2fd225bfb7c8ed347ac54fa91f2f6ab7d9f5c8ca1b306248d7c45915d3ded3b469541d2074f4da410a45795201c7d1f44b5d3d732e10621c849d8b539565191f6aee798c0d83e498751145f1b2567a0abdf1cbd150d4d4548bb6820cd326ba3e87545a0f94e3101d77779f3d5a49f4038ae855251e2e61c48488730d44f54a7eb607960227a39abace7aaefeaed1484acd1a3622b42d486eea44fb1555c7c59cecf4c06bf87e4866a5721b27819dde8225391c6ef867bd0830f797c9719ec23fbcdfe9a3a976eb3421e96cdd1271e4969619dad1474f4364d902863f3ae150bc5b84dc76198a4b91ccac38626e36e8205e989445d8742f83eebb49f8e906954b563a9c768116421b3809f06715bfb6cb1dea19938323ff74c361eca9d7504ff0720bb65e13bd3095e72fb76f0316d25d0a9c12be34531cfe0969d92e4760b29f39afa850d61c7f827e92efcb1e36ca110d450dfe2111e3273be7302bccb8b8b14b2d43b03a112d89c419ded7b9a669579218852c477f827859e5237ee19bb24e627e6ab3eb2f7e9f504972e3866516adaa3263209d43a71809ca710c7b498e69ce7f0a1a68094bb5ecf7dd1bb323539b7867a58b006832a03e10cfb0cfa882ae750afcca6d73651aa0deee65a4ca4843fb96d3fb9872994f625897ff297e997a8eb723c4388c3656ad0b85847b401e5cb8e50676993c482f2189d53d276af17f334401d8f5b300b6fb01cf6f7e9f5601f317bf4d5cbb9d58bdcf98311400724bbd39d367f1218830d0860f6648b09fd6017aeb7f3a7d8f07037975ea66ab18cdcc150ed16f6d79124c7d6b8780bafc5a4bd55b4abc4767dcbc05c053836d90784b2088e3cfa9e115d2f460fd661b84d8aa6975326013c8ae85803c1cc5b7d14002c9d418e7ed77b45393489f399cc3a69d54a6957a86ed19e2deb3f291c9fedb116a34c42aafa814c692d958328d43d7a343be67a39fefd080efd1a8bbfcdf8fb6090fc936d5e456b0cd3200bce8d784917193f0e24d33a3a3e03551c0830af65f60e809bd57956785c1830e28a2e7d79a41e9ac0a95c649265caf6290b81588f17aae1b8ea820da8885fb68c71de64b406b2cf60e1e49454cf8f67973d866327785c836d30ae6beccd04fb18d94e630122fca029188bc2c894c66dd3679cacbd43489d0529e67bc2b3af61886179e8810f66f3cc37d0167643a3010415e3b42fc20d25c83e5ab1edd1ccd8ba1a1d8294082b652f7a264b7f340bf63e51eb0c673b2513987243b5339f44b4756c1e412018d09b4de795adc945a2aa0428acecac5ea2d317198528ff9c41a6f680fc52c642b2ea4e1c1f9dcd7e08d938346fe48ca950c12130d8fc1ad38260fc44f63bb7632e542fdaf714543fc4df75c20981e6ce739c89cac36825cb7c0d3089fb04d74eca9238bd6f35e74452ce003af7c9b2f8cd9f88c4dc9b36cdf890d5680e2891b7c32952b13de7f8a0d651a3ce0f220d68924d623450d9c194cfb9589534ed70e6cdb78b6fc0175a10d0f973e0617d3e817b9915e3dd05e72b921b8ebc36cfc9568a9c11244710e392b430a89d7ad26098da86f3372bffe27f1518725b213da381f096bd0359567cb36d05dde6fd87092d9f68e485ab689fe1669e33ca017c2bcd5bad5ee3ebd680e165cbb653792970f97365a3a4cf4ad4d67468c3d81c8adbfbf8ae78ef0ec666d7cc57a02fb4843d1d2e028760fbc5e37d2de2ff17320919af77092df7a9067bf65278c89edc7df71f55cc9dc825094a2c07646d5dc9c0a6e8e9c4d36d9ebd8564d9a9ad9f27ddf11088ee47f0c654f15dc6e5b87566ddf508a18c467566d4024ea86e022a6654cac050eeb4591ea2dd813f2ecf193e25ec65f8c9b7d140718a7076d3af2ff20acbbeae80d005ba883ab8e57bb7ed394db7eead873d899966bc814a55147c41d7e44902fe0e3562671ae3f568a5325d21aae969a76ac234c9e2b307d335dced2c149f96dc0482984d10782521a599c93a9bf269a7bbc7d3304268a3ab1e11f586d11c92fc1150cac744961f40c8138d886a1e2ac04ba965ab154deeca587b2e69f7ed36c30db9eb6f54fc5c205756e4a1befa835ec2a1442bede1d69dfdd4e05e36813208a49a52a41a733961e995bdb63c3880e9e01b73666b5d7b30123fba7c36ed6bfc49eabcecb997285f1f0f7d7261c82baf0f49a45a20bbe1e999f61ec6f2b8cb8be92354e5b6514f99796f7f31277b0539a0cbdab055d633d5c446ad3a94501c8aa53d39445ec927e0b913cbaf527358254482cafead45bc4ccc55d47373446126480f1a9d75ce6d9d197c141fc7caa62ef9f9ab0ecd1c84e4cf45a9d29bb15fc6ccd879915e9b366b6249d8c151558c98cb069a79b7bc02629bcc2f5351b027ad3c8590ee061d00934334c4b367a3491b02129d4e18b8d712c49b6d01a6bedd12b6bdebaf6ee597d0ef54369f81972a365ed73870d986d4531b53ff1fafde888c94d07c78f8188d9fd9d8ec180c96579fd72ee137cee2ce77958fc0c78ecd532f5df3fda08bc2389390b4e9e50d04da564b3e2f6d9f74b5a34f3b0add1a78382efa76fe36304d17e475be281b249f1a537af4bc71db137f8a81f363ac451a3568135ce89815139b6528e78381f6cee67b9982b15aa03bd33e5513b3e686de3c1e2833e887e320a258fb131006a04eb9652477cc64c7bd96bf3a61bb8ac59a7b9d35c197107f30678d01880a5b557703165412dab78f8170c78f1764d800da92f46053dc89d69778db1399ec1773caf62573c4052f3b98d4f942b018b85d7f30272f454e4c5845e09a1e20a93b04431bb8282603f656add5b00846fc92505af8651629ff66b19d45e9fa65557d5db6889ec9d0d1bccee85c0b85a9ec8fc3d901717030eab62e92ecbdff2600e172a53396298a6fd89ebec2878905ac84af3dbedda7c0dacb1d8947ced0c1c788023ded0b090480b342e4c2b355e11a6bde6d3aead3aad83e385da9eaf44613006288255b951b109fe7d78243592e0adafd0cd2c06c82b1dc17b0c5a34f9de5b38cdb723ebc8acce4f1c9594f031246f0e61d8c0edf976dc7544d4cadf5efdb6dac892768a5427876096616d2225498d2b3134fcab1734362cbda712ebfbea05db6375acca2d327812a9b29cc644b04a50b1774beb28e86ca51a5fe33db9585f5eb7ddc18b672e090119dc404436620142f6409d3d81366aa1499028c7bacd1a03411e952b9ce546d9fe27a724712e34a0bf07bda7db4d2d24e76534d9df36c170ac832fe80f21b61864bbd10184dfb1b33f2ff41f2abd97af3d3975473f8b73cba8889c271884220cf4868fed28e4fe8fcfa293d7f3144137a484140b18b84f1d1a7057defb5f6773fb44528576aa03594da1c1cee74a6df0c773aec5ee4c8f9fc21f53da533ea96afcf2c8dc6987e33ffb99476d67e3c616eb7f29f2c931664bf345132b4d7e98b2acca01ef083023e0101e89fa32aa9aea9f972b2fb6edf646fc389f815f0b9f58afc474489f092b34f020ea37e899604045a0f51660ce767fa17b8da474d6612b290425b52472ca3c7e28e1991847188edb00e39e9ecc1ee8ee32cbf51b6bd8d79444d59a1e296e58d08d58b155800eebb01d2144ac25cc34df1dafaf0dc81e1b5c94a282bf862284042c49afdee203c4b990102259edf0672127f0d5099ec8eede2baf49e0bfb8b7667fe90fa163e935190bf46edc16ec6d6c12b6d30ef8ad57e543ca4921abe871f48c87f0f6b7d67eb3e5f4ef0047742315f9308a2ac3ff65909cef6f0519ddaf1cad00b4e37e05a306dbc3227b0a0e800ee9dade962165c67e65ea2f63ee58315169e49d9964fd3b49f0cd77ef96c0ff1a38177bdac638e5f827be87bf4c787c4b3336d4ce6681ba65a4644c0a96c9aedd26459fd7813b2883cadc2cf6e4076ec215768ed5d41c29ef6a57c2a5f54c368f61b65bdc0fc51e5852f5b81d32251e38b06831393049db81d5ca6aff8e93e48376b0b6d9d8358a7938067eac77ecd0e5d2284123298bb335200771d68cb02134c95d0179407809b4c45ebe31b81305ca21fac667e56308aa159b49f17278f09b1c640cd54027c6407197127014d4d8f0bbb63563a9ba21d25485bc64dcafa9efd005da986d6bba24a9cba323720fb3863a9525a71d73b5c895c8359ac8c26476ae0d6134c5c99da1eafc2ded233bec76810b8c33e1eca35ddd5be3c04dcc8a0533ca8aade4c929f2a97ae48a0ff86e79ff1f94608d39dc805aa726ec096365a9bde57ac193a3491029861a3a938d97c29e44818de2b29667ba209e78fd229f82bffc7b772b2a51da968725bff9cc3283e67e4f8623163ecc7c96b9ccfd166ab14f249f9f55fc735731e586a3569033854385982d4cb7862006cdaeeea4a82916252d012038f90b00523dbd2858fd7fb7014b17f86dd3cde4785c2d10fe21070c2fc442cc8a7facc5ff99b774f6bfb3d69f29a09425289de43a5d89066631cb6ffb0c371c39fa20641af1880147dd19acc60c0f67a06b57d7913425f533c5ae6212dd716d6e616ae2a0fa86ba15b7e6c4441836e177f64474f33680ed27d2f61c359445ae82906a5b29fe22e7121ffd5ab2e5b050c3455490246f3c84f599270037db4da5f7fc1e52660a6eca6c7365eef3361df5d28879530604d3db7f00ad6ef051d77758f7e7ffbf0587c6badfb513fa510f677d99c9eb502c3d2abb36a64bd454eb6904507d62c87dcb5cb5c79dc9987a96ad2eea00225151ebdcec0217581fb5c31ac4aba37401f35a1af29beab79f01066632408c2818ee1f6a947bb9e4ce9b6044e0fec419bf070ed15665e45c8ab35d9ed09f49933119efa8f71fa4061769414c3c4eee837034e5ef1581aeba5e8aa772a938c9fd71f75bbb6bbefd5e4a6d9d47660dce70e2f97ddbda2359c3ff9320afa7eecb3cf32c98ca1c44a940bb503c94961a3bbae09d6630499a5cbee684ff143a3cd5d34ae8be91d66839a71d66c8bb3895ad8a74860b7d492d622629f73dd9e838cba0ce333775e9f3460184e742e565940f1d7588125f2b8e8b1faf0d4855e924a34f4a7681ecc361ccf0ffd828726aac58994d36bd794a0f8ba8ef0c1b43a0a44ba889071d0aaeec7d968e298d3cf9b6e33f025bcc76e24e63f3dbee78d6e61bc5afca3ae052198feab9169b528059c7a676051ee1a8a666dcdc9f318d216f23009962944fb65c39e74f2410df81b79d16c4d3b734ef709540db7355c5a7a62c0341789a6f587c7f16f35eb6913fa98ce8615912b96ae4e3c9cbdabfc4ded0495228f7c1c591f9934dfc6a6192eb1396215e4af2dffd9e804414256defb8be44339225fc573fc6143086f3374fcc48978ee0ad696f91adb2a34425bd9474a18994924a06e1c35971b4496dca9b180216db97510795ee75d82aefbc7350268267d284584e3c571c3ab2bfdc50bbc189c77d5d18a70860293a0138902c73939e3a7703f881f70436abbf02164b0c3a32bb2020b02f95fdc21c2b5b3801cbb6f2c5b702529c29c3d7e9606196f003c2e40f189d0d23ddcd90e72bfa34c581bccfd8996b7ada8d2e3aa2be0c93ca8aac8b4b8b62146690d3970821827fd08c7cfba2f7d0d5f962065e61586a9e3d67588623d60ba6ad7178d5607a35be0f24dbc71d71cfcfb1cc8c2830a9fa366379dd0ca6b398409ea6bfa9c017f509c13451d092e030dd8252e2d23b9a366ae7b03a3b242d9ce97d40b10c95d87c50d4806fe5138a79e070642f2674923aeef819c1faeed6ca60e922a0222b1595f93eef8465a18dc43208833d7d2cc421111e2761a7fca0d906cd06887d0623a81bd2a2fed2502d7c17bf4aba020d0402445387958562d4410753a783f6f9d39170c03b0ef540130e8830704ab733677ae269fcb8d0a4caa4fd63b1b58ebf4c6047b3769e2b7005112c04c0e9c1946564225b57cd257174edac6ca6e02561d193bc876e9985b92762d010df3cc0031cef0bfbcf4a2c4521217ff04b6e1882131864fd305121fc5df94009ae443e47cc6de1948306a8308bcc84c62acf28eb9cd9f33d8840582c748171cc1343df417023872a3e3b9385b02521cf4a0ce3967ea497a987ce60dc6eaeec72b5348a3be18208fc3375c29d6b76ca924fb38a808d473330373ae3ed203d8e93169d8903d8139247cc3423a91bd3275b6c03580e2c89c61ae044c0001a836b4a22a2511938ee39807803a804ef1fa5f80a8eafc36c39a81150fd1778e965fe3af301ce6a87358160c574b8a428ece36fdd176fc591f113b13fb80aca3b6863d98c90232db7abf37104c45e0dd4f4d0115f6f1b7c1c35204cb904c044b579d912f4b66bd249dbb20cd294b811c61aa645a20d2bc7527c280a18b439fecabd391d49ffaefd7743628da242c0eb0607742092b6d8f6ac979993e6aa608146996ef8b843514d8235e58d17d014eabb32480827b7182dbb1addfccfb4e6acdecdf5c88a900092db4491636866f4a5eee84c1976c81e0722daf9bfb3fb6376849b98fcf364f5461a503de62b28528686b0a2d137b5bc82ff527f9f3e9f27a5da41dbb37789946ede62798329da452e2ffc22a2971f238292bc2194628145bd4f177c7c1faa446a43ccc1b7a36b79a8e2bc60d9257e3bbe49ebb1d10e0756e7fb1967a6fcfb9dd6da9543155f1d7abb1cc25cb7674749686228db634b6c63aee593d114fdb49c98f82a42519b9ab4aeaa47df41bad6d23a9e5579a061cc728b38337391a5982bacb3453859352ad359c510d18028ce4432d9668ce3971231eee51827b5303b6dd7d972646b3927738354eab28a149e22e6ebf2d0c2cabd1cbd732cde1ba803994cab126309f1222c38f85620daae58fab2499b1d6452d7b8a1ec3c77145d9f008b89ca76261287d7ed9cb82515978bd9fdedc03a99269fe1b99aafe6aff122adcdbde4b34039843079572b4026ee43d26cd685c096767c74e25067bc805007a4ca360f440c466b7894760df0e29ba87396aedf59a9ee8a317ab2cb4341151cc59d36e6fcffbd8cb05c7cab516d685bbf12e17ae53a0e8809f7e6792dbd4179706dc4d34c38e02ce66a16a552251a4e475535b99bc968407359bddd20fb32db977b5e71dddfc9e6e4fd7565d25846423768873aca4d9491d0deff41d96b3e90037efedbebe2d0858593634441e795b797e14460495062ec4f520a87b94ba41a1e980a9ba3fa4a9044e61d06273767abdfa9676edadd454d66b3f928963484c211105b51c3ce7919dd75b610600f080071dc0cadbbce1c99637178f9dfdf5c44cec20be97ce87d48e37eb421db0504217c57621d1f31f8eb4d0e08b3003f96b32677080d3a2f89683210d7d906f820c6eb50af080908703e73c0832a16a144094b910707ef84eab484f3a5c568ed7e5d96f1fb4602c0a503c5866c17e2772c2e409fca258e974001152ead3ffafa6314550424b2002cc6014b22b860b65f4b39bd92d9ce6ae1cd1cce17d2b7a3eb789ee0501232567150ade857034cbd42a40f9773486ad61eb8da44234d001c1475c2b06f55f0e2137b5a84df6c1894217582671e0df3de0762ed1d348f5a76e35881c169a0ef92b96196209fcd354d5df63aa4c4d0cbe56d48ea7373ce340ab7bb66aeed102b5ace355b23aa901dfa31e4bbe963348f4c18edf483c690f3f73ce7f22d73b2e5f3094917558368bfe1f2cfe0a2be57c6dc60c7a72d44a23373a35cd5048e61ace6f8dda42b1f01d4d75b63b42bc3d07339add2a6bc5305c2bacfeccc22145af64bc844dd9c477dd427a366d4bdfd1ae9008716f1f7b4940e4c8ba61b4cf53d0d0eaea44288eeea873adf54e207b11e6e1ec3e6f35870949895cdefce6456427561993ab74193528777f0f85a9e906d888128e3cd50adbd828ce5b3e35c6e0f0e7d47fc1503d0a032a7e653c88049372b521cd859e1594369dcdd362b46d9b97f8a344c3920a025fdac0a6dc76143c062566952c82cd13754b9c7b8b29dccf3db99873ee974030f4d1003de2dab19284e815dcce3cc7695e18b896385d099a5eff67402384d5be2c087463439052a9cd5452e057d1916b13eee98d1f947353099f0b60a889fec0630c1245efc0d4c6d3c8356b084eb02c25287a54feea5bea6f537859589ec46198651e86f4b7e2c934fd1743035115e12a62a52384165945ba11a28b4c884299da3de3756f0b3f1291bf50cbaa8bf88f7be26efc3f55037290317e281168f5701a4358f672c8cf8005575aa1d8529a3d6b1aa067dfa78ff3c50e6c824bf3b96418d39279bd030c536908d137e78579a12f887de42c487ca7804c7ae0784a602d96932acf39221075f4c9bf2049b75573f890e170b3d5e065c7c0b4cb63e46c4bdcab7f6d8943c0557b9982c70ab06a259e933b124fc3daebb04d05ff3e9cb61d75c9eba5dd9bf40bde69f297ce9d209e2351c087c339ebe232956b6d5e0ce6429113e52e9dbac6906894648551f22e345519fcca3c9134928bcfefb5c89d972a5f3418839394b2d8e637f47207746105ccce81f0230fe57b75365058c1551df46a15891cb18cc51cd93dab518f686bd1f34148e15a225607de50eca1a700f1854e766179c7f6a5b156d8bab6b9d0ff165cdc9d1356cfb6af3a30111853357e9ad8ab73b21da35301ff60b2ec88b1432e70b53a496ad079d380a382a6725115a498e02a819367efa96f3fdd4d3e72d08fc9c5162f5e7b51bdd25443cba5948d105315b357f27ab155578c9327e4f9a44c464c08dca4f9acfcfacfbcbb38cb62c3979bd1c4adf7c8f5182d2db56cce63a0753a326a6bdae3333aaeeb071fd20d1b349ce97f5707ad73a1458a6ac4f7a499043c310f8453a531ff99d9e6c64732baea22800614c14c5a2ae2cf351420e59dbe5388309556be1c6ad244d01af5e6cf69c0ccf67c2f6b9f1bf0c6695c86bdbd4de80237a7604c47653473a2302287e4b0e0e4e5e84c445fe16ccc5e4d917acc20303c8c022fbf3d54d2b06ca095b3867bbace2daacf4b9dd6c972d979ec0b13dcf9c456be4a700fb6489dd59642c3d2112c01082db33500c12335e8f3422898332ab850c0ea421a6e1a29771915327e34b7889ccb0c212011f9688f6d1de4612d34c1108668febc58ad0d754a558874b1f5ca7b0a2f7f7dc8bece8ca0cce9ca1049ffaaa0191b687ab467f7461598caf6d6d317e37c6e4976097adc4c0719167286f4d0b6ed65f40e1b6911640c5dffd7f08bc4b5e684a722b3dc25b2eca1ee68c79e0bfe0d79f1ddaf05f8603bb0092c82e5a6035c8997201786f52e0b521c38727f2194a9977d638ec73d440558ccda1f46c8ea225a52def10e012f57b31037af55e04d12bebcd61205f1b10aca7357e493e8c1efec9cabf9773f273fd52ab6cffbb4df3d5bc3b4d3f6904a6595de1ac8beb005d1e3d54092c16680e8d497df808c9701e6a2b02e682621d74d95e1c997f67633dc70b2327ddd7e037b8081781dae8d936826b7d7741980b4beb7f90e79d80b8fac388381478a9db45dfa8b426fc8f46c4bf979cfd2836ec39a5abd29beac3dfd3722f429cc5ca8dce8216693891f95eb8e2df5ac0ee5bbfa12670466a2869e94a4658d261464e8f392f130c71e3288ed0cbd87a52358b99d0810aa7497950efd3c53bd05bc0cadadcce9cd0ed87e3fd71383afb40ecde3ef8dbeb35cf512ca8e150dcaeec9e5e6d8140d3fdf40dc968c94f30ac150d3606acb8e417b0ada7cd1efb1bad44aca316ee005527aaa0597dd371f856edfb11b9b6d20d140cb550b9d72bac6785e03ce2bdedff6ae6fd185789826a6d0113b6cb9ac85ecfdcb99ea7655845730080b667eed96c3131264ef2de03c5a8f8122e83d64929422383001be8c15c9ad82d3ba74d678ae7883691e9eba37f543902d35e8c53306e63193c309a7f96d347f1ce36df690087a6cda4ca2bb628a0712116043de6d3dfe1088932a9805cbae921341303c6067a5b29aa61ac48988d984152d49c477a70467d5810af9e4a3fa31b090c594882160d729c01cc1092504bc50c22f70ce0e102292e323d4465eeb51be90b7ab27e577510d011c1b361c798f1d18bb3b17c30d1ce18136c5ab7f72165fa44707c8a2472f01257cff9fc98ac3a8aa372aaabb13a05b84e1fd0083ec560496f22988c618826ec6040022a9a54d8357c4576beaf5506c0dc08ea46a44d63146f5ddb279cfab3eb22b4371813cbd7fd32cac367c865c7819190f071f9dda0769aaa3dafd30ab159ba9460cee504a154e4ca0e94c2b33db35635ca7a84fe4a504b61a2ca490fbed6db8ffaf00e51e033d9f0bfe6fe484ff134a5873f32ad9c9ff73ce77b3cd0ea2d15389f2c2d6ec1ddb44dc6fabc91ed2597d80e94a76fb1a192fcf1cf965e3a8a20191ac9733ad1d93e62c3347708a6769921746f0e3f08f17e7d875df153c1ba1fc72b4d80ffaad006cb2faab91efeb1f5de48a71e7504299b30e4c10de3964dd5a2bad7cef498ea4ee352bed32ca2913f45ec461dbe8b9edb6aed7e59ccbcd78aa80ed1617618e5a8aa734bf025b5307e8066d4605812d437df4b59ef08a2fe6905a0d54dd2f35d157a8b23a703245d013b2e7e52616600584705d061802aad00255477330c20f2afc53923463f2c2d879873241f44306affa0f1b4ce0152e8fea1fac62237f292bba6abdfa04a0625848993d8f0d5b2785052a4ffbacbef39e85474c09520bc03f87dad5d0eb808af7fa7ca6c39a59abab38a85dc50d3a61a2408db68cabe4233f7d1e8eeec79ffdf566057f6f80443f281c0887803f5e58099bde6f6fe63d7a2b2dbcd24afef40f838d48a9303fd04379be8449f81684545372df41e023a71b91e7d8fb9ad7ba7670c6a891b42d5dcf4931e967024a1c8e0a9a5f9c9d138ca4c20cfd07dfb04c4e7441f153918d45688a9701b40f313206eb171407b303d233082f4362c425da7b91e745aaae0837a66cea775eca50a2f6ffe4525a0e00447780872a1ff47e94caa138ff24db3f1a98a7784a8f01ee4e39ef9ce4e38437534f29bc6bd99eff4940dc8e04a6cceff420325c175685323912e623aa6aa3f3a90c26c1c28b5f5fa1aabc985a7643f0cd7c6df6ddfdd43d039a9332e88724af4b2896febb390170593b71a75c4293512232098d8a62512aeaa77dc2bca44d5d4fb4dbb56c3e43f37ca54c313e2c6398b0bd0a2d429cb5ee7e30d1d84bc286f2bd1cf2dfdff8c0573fccb97ce9d32e578e0c3bddfef8dee8639ae705c7783a454037d4210b7841af6e57025f58f1615b1531c8adfccbca55a8a08fdb0d727153760f3c7838e62a8394a5b82fa06afad155fe95b9ac0aeafd1d5538b9540aa3bfb07451628381bcbb58b38732c2f0620fe88ca88057a8845502c6d3446dca564aecaed2059c4e9fa7be91111cfd143cf9abf7f3edfebc89ccbc0fbae80f12ad5d95d37f37da018faa3fafa1ed058c034efa2c8dbc137176959c6b56e396b6100042feba0c303777c4a160006c674d9263852a572938d76b3fcb545fc006abf2659dc9c4ccf1a3feee458592463c1cad817d30b2a07e3c0b7ffb1d51e63c4c22a685493c677e046088f511522edf9a4b36a2447aef9751bcfd8ec77c3a1dd035b238adfa8aed64378fbcf3a63448ada4473de5372cb7c69d61161a81b03f2c40cd3681b221442bd93069559e3844fd6d709cc2bfbdfd9b3ebd09326d61cb53e25148ba496518a75d0dc628823a09c6cd56c3f73f075e0e1837243e1381bc6a14e7978e55725fedd767e96b555181bb333cd1eda79e9c7adceeb2203705d7824a6cc460f5a5bd55ae034fc0414c154ebfc260dec270538d64483b598bac87f079dd90b34f0a111295deb7a06336a7eccd0eae9118ff8afaa4986e33f8c30bf67880b9ca529c0d918ff4f657dcc94c2e787858548fa3e0dff5899be12c61ac382ce494087479e7cde9c95ee51b7dd4b68e92593d99f3b6bf0b0e47c94b6519e49847d88c150615fb1ec8c7248e5d5d61168f267b80e7cae34e6482fb7581510b0892208d9c629d045af8a1901b2b8cdd79329ee9b9d9102263ab5a2708c718ca8623b3d2b3c498636eacae2c556ae581ca083782dc4806bb6e122a06225be28d40b397e3c62e409f7b1a28d9101652f7ac4fb0d05923d35f9fcbf69b33a30e8ce2fc7370f5e5a785c24d57460857959a32dc10552d71a03ef8666541cab8da6101ff89804ccb8436ef866ca0c79425fb68952f0fa5727884b246b69b2bc54f58b23b8f2c43e6f83d227d6fabfbfca003c6240704cc4f389a644ab257368df843acdbeda5a16a2b849c415c45a0c0bc6c42fcb161b601c625ef1f613efa4d345013ac5a46804f1f6f9e8cca577b6f8e258116dbc6187e4e0c08dbc452cdfc600e2baa60eda114f7f3043e2d4ad4def3123584eb851c53f94df709893b1e899c3076a2b3eddaca8ec520505c10558d4d08cebc708e421075116dbc8f2f7615756d571ad581307546f413f11b1bbe052308502c0f92a420dd04cce0dd43f0b6510e780760ea5ba74e66e866ce3fbb480431526b933c4d1ab333db6638fbffc27eca62e100a79f455c3ed2989127e7d9ecb98d1f8d7f05fb60375df781556d56b17c3fbc78623b9814cc1b3c30cd50232cf672182b3e9a296c5d6f8c1fe276aaa051b53a5e6192bb26de749c72c74a8034214af236107fbd5b5261e6ea4fb5e29595074858ebaa6100066b27598b740e99030ffe77e459d3bd17e4b359ff380720e5580e0ead6bc10f19d597ead76b263904ee55121b9dd4ea24c75adcb0bbbb154c826bd42e99a1a1d908e6441aedb02c0032296e7b80242c359444d1a28822eaf789c0feb3f19c9fc5eb736426847f57b691d20570211202ddadb406e22cfa155e7502bd71d97c71fbe08d6ea8a8ea64ae11f97e7aff6733720fb96bce31ba58685b7ec8533329caa27e1f072ec751bcc4d6efe76ac2ceff01a89efde22402dc25a86ecac1f0518490edba1c9f8ae964a46341f9dada5c85f35b653b8c3f20d1a091ebe51addab8fc32f32093ec14dac234bf8c7545548a1b2718807e14ef10791ded8b8f08dd09f08a1bb0b47c0deae522b268175525aa5e9cf7862bbf05e02eb6c326d07719d91de57fd6eee005115422b1726221de2c505d12219cdf758641ed541398c8219b9f611363992031ff9711ecb3647b1f7a1b188a7ef82c748140b49e9b5caf911c702060bfc7bfd6810c11fd74db2704fb69991075e7e35c2889252c55cd53391903054628fc2bb9f57d7129bd27bf1ef88ae48eda7e9dacea12f33127514ae3a0406a0a18fdbcb3390f8f60a10bfc5b3e71fa30ec8e37e3a648c8125a030e02b962e5714074dc07fc5e745a4a5547ada315aba1d3dc468afc56670c1439f3416986b9e91a83dede27e99dc03d113293203d4c122973558441ee227194349502d2827ff868c320cb626f1d23884d5ef1c703f271235c2b3852ff8d57eb0c5c11c33a5da75b99d239c4010d0ffa75ce44662133745bcd7f442f54e79f16798544ad09e71d27add0241207923e3725fb4eca9581f12a1c1701a0b163b1776719fefd6e82326a7f26807aa12c1cfd208caa7385b139d5711c81a397ce0c367b7d90effbfbbc19d34c046fbd5ee6bcc51d9422407ec0a5039bffa1be8a6e73221fada4f931f59cefad0c826dc1b331c9d0ea2d4dda62f4722c5cc2bcb292b71fa72694582588a2b53744b8b9064cee5e80412d53694c41f68c5bb75db4e6b96923be24d52524cf3abb354d3003eea2c062731cc401288011f7943665af743aaa2e3ec46332c7d4912943cec519a0b94cf2307fc0532abab28c0b183d1794d55137d365050bcdd8343f4edb1576b920261658d65562de3dbeceb8d73349edb994f9f8c29393a3aa9c033cf8b0b4002bd67720f256477f04454626ebc94df2bfee3c320b1ee0f1119ffec460f4244d1f5f0ffb8aca6721a9f32bec12d01ebade9a126c11f2f13a72d132abc2319bb2419dc44229aa3efc5d393a2d2c171e8547e2d6becfb29db506d7f7df042cb59d298c4c0a27efc82cfc5e3dbded9818cc2e317701550e26bc3a859af411c54997190e0ce9d35b09d08098ae8f38c170ef2868b0b8e722356b1764e8073f863c0b2464ddcc24597f9e3ca112848e998bdbf795117c691690ca33aaf3af179e077bfc9b82e120c3f191c41979bb06fc0adb9d7365bae43c0aeb3bbcc30dad709913ef312f0a9def61c44a3f1cfaaf2936c140fb9b063b43d977843e81a819bb603f31824d6fb9b5389f75b11389efb76b6d04739a9578a8a23d09ec18a6572b2a7339c2b62d67df70704f3feb36e8472a4c0dd1dcd3a10c7abe17cd49ee44a12dd478e868b32ff219ac01c97e69b42f419601083bd34ffd68f1721b99e155c96bdec891ce96ae50db7828a17b6a03988101461bae6ea28d9bc97d77bfeb3a390ce90bed75061f6a9cce33a5f35137bcfcb32941dd9c5962cebbe52c571e4fbfc301ef38419a72e43cb718023bad2b0cadffd75d1bd6151eeb1988e55cf473a39249daf3d89724ded522f3124ef10060d5185d9b0d095dc870c145b9218bf75d96b44e8f085a8c87981583cfb625c72a72f35af4e6a2f60a5523fb3a2afc872c5e7b100fe8bcbc15157507e79140b9c8fe7eda214c2e6d70e7eff8e5ada7fec0ba6ee4d88c9ea71c5997fe5c699657b31cf51d71100182e819a07767f88a9e293c65f8ac8f3a490bbb705ab11171744a98beaf2c7e7714460baac638fbb4e2b40e906c8b69bf93a07e2688f4d8d79c5e7018be98982e4ab35f96c58a510766ec46583f6e1bda1edab47b6bcf9967bdc82d2a32f03df79ee6cc65ee6cd8ced58edae15c2e38dae911518edbd1328c5b00b9bd4d3b9ed838ec45415c44b988b7c62b6abc6a1eba32b80febd6b779dd77dfb2a2522dff83f10ccb4c7b1fe308f9b51509fedd69b6712dd0bb260af9072e7a14b70d8c281cd9e7eefad3f7d02eea00f0f87241f745c6573b8a05d7e9cbba061bc70d7b7a02147bfd437284c8ee47e2f2b457e6a3c0943a697d407e5ee7b12611382094e46a796eb4483d49d4042f119554f41f31e49eab70a988dad91074488ec572de4f18078224f9423d6aebf0e5773dc123fc3c0915b8cf17b22ace74592401045078a9e9b73d050a2315cfe4e55ebf1ef39dd093f908c17e39d52053ccbe0698e9a00998d300219411418d8e316fa4fae728439e5bfee2432c09a5938de8e02bb1ea4b03ed24e94262724e5eedd142daac300e3411df3a3fb287ea43e420f62084ade9a2673b632d038306c08244bdc76e57acc41852cec7b9947d19260471b2e27307ce2b1525016b709c397913d0d7ed350d334dd9bc85a9195c73b9831da598376bc4aa68f617f8aa9404fa74e4656f0154f594723c91131ea636d8c2bcb8879111764b09bfb8b382957abe0ade36d1619e73b6c27a2df9b23a8d9f0831b542ef3037b0cc1cd722e6a71d337736c43b385a9dc70c23b238ecc9f621d15682efacac0d21548e71b1bff6ed8dfde2add154b71ad9320b909becc0542041aed8a9ae5a945d7f31295a78af6e5a446a0b8890c84d7978553e6d12a1d4f44056a710fcd0d62e8acf84c331c5ab4cd5642b207c18302d893730a978ab1c141f5bd1bc646076068bcb4727c018322ac3a59aaa12a5005dfbb52d4ba59351cc80a36bcf30aa87c84be1637256c13ee995b5fe6626754294b3df0006e9aeb68402f49baa9e56626db48c0afecfef1339ac36afb0745fa5511c2036ac75bd5e1c8d51cd6d01393263d27ebc792588a6dd57388a3a2f7251141c465b0b2ec5aea39273213962a5bb8fab1086a58cb84a0f01a245244f104fe934f26634d3bdfdee1ed9040e31b1c9a7f5ff22936ba23a603d77ee65e40a0a61710e1abc8b44b7ac68b58f151f66ba0edd56ba1a6d4e399f01fc35f54442ab090c4a0ac78f58fb8be293827f16d6ae6acf9d9282b924c08875cd7866dcfb731cfecbbe0f68be7f6ede5e68967b6bf5ea927a085735afb3ad94eb1370c95a40a83a0ea2996e003b81eb247fade3661a082f00f4915bc005ff07d0e2a1af3b616dbac5e33af55e80e10e218fa9666770e4d7ae3a5ad165808f7675e2d09dacc72c1f6a422ab7efce0fbccc76beb85a39d1f864b88b7fb001a8faebbae2ba77b840cdfb8bb1053919694a7e69bb825c338f8a96641ae223a95574ce76061ef032bfa4a12465cd29d9ccb44d64fbf117c58f4f2c159ccf3d82c88bc0132eb529b15b305261682d3c8d31d7aace5e641db70970ed199847c1a3698ba46ff47f33311cf97cba4ef50185b4e37e1fe49758ec8cb65d106844961b4bae9727ca664ea818f853d2ededa9872ddde2e779a3f6f8dcd4aad42981bf89cd3f145648012eaca8b6aee1c6d08f1629d2b546a9f5c48ac5566ad77faeb236fa16398b6b3b543dec9f1daab98d61fe05611c3e6a1434735365066b5bb0fb37dcb7f86aa1bd96614cc3d9f45a706facb2bfcb0037c93cb4408578c5a04d57b3be9b569a22eaa8319c1a0137d472e0ca6233c3418ae5ff0a6f353fde0721495379d6ad00f686754500f8c5549fc234b03b996b11d83e88a87d5fcec996a39c8865573a78c3f73a6536667426701be6deb39228ea2a14d6756429367d9dcb5a4c313eba6d92684c88e830ab4e72fbbd83c1d97bd952612231c2482f830ba4de9a1cadfba7cc5a8483089e2bbde74391eeae595dd80109bcb56c4b18b59b7ff3eb95fd20679457cb405dd02c7deccbd5566959c4ea9d2598506976fd58261812dafb1f03079c68c18b32a5a4de8c73d0dc70404482596aea63f1cd60d4fbd4970d5206aabb0f0968cbe259cad4273b989e75c934b203a7212e1bfc1ed9d341368919cdfbef5561def1d7fc3229a4f57a0f825ab91251b58171a5fc18d6f8f6dc2c2f56f160bd4bac905ce7c473635be821e36f680a0d78281aa64fc2fd8d84fe19586ed8420a80266d49bd10e35ced14dddf49fa7021cb31102eade796145c60356471af0eff991804dee5b471e5011531476017a69e6b9d04630495d510e6530d2a83c9ab0fe97fcc861cbd62d4aeae2be496d9bd39e27311f04db20b2c5005a0df65f11af62a7e8288b99fc8c13236401795ba0ce8d8f2bb4d9119796bb664a84604eac7e39f6a06f0f01f8e87a077c76d871af7f46bf78d1cdc78c3564c42042f1126a9a33322fa7c7d37c25187550ade584a3234e5cfe94c6c812aad538b55949a616d9bbc59a30b48d31a11cd1f2af8b7e9791864202c58b0685dfcc7092f50e9071cd0a5959b55f4cc6b231463a0a989a9133e8dde898d8f8672be497430623b006e7496387d183b71fc37e6ef094f756a75c8e7250bf4d3939c2ae2e077135595dd640a8f61fb6fdcab589a6873923c373be60c37417b93c0daca8e7f48937544c83f3a2f91204aec15bd4d0c2d31e45bed8ecd43231a516926bdd13564714adc405c6f42c8bb203bd2fd1cd8a42c6a8079e4c0dbf12c26d6a460d039d1521ccb3b50ea5a99eccadd12bf0894fc0790e57cfe69d7c4081d8fa5fde8a12e5a70eba6c151ad2a67ab67546f16dd9b1ecf32e600bd662cb2d87936d830bc9638ca8782e9c2af00ef36cadb115a963de32ba91de4e4eb10c206c8cd7b1da39a58f542b02d63d86eea095e8e1215daabe3d8fe8e19b97252242003a58f28eac8bb1f6029fc497f497eda8393c88757077b3a4863cfa97561c0e34ac21394f88d1556e6deabb69dd2f100b0070f5ce5900761eb650fff2536e1cfc646bf735f905e59905ef5126a0a4af79efe5635876af0e05cfa3d825cb5a61a0921748b8bca64e82a9a53ef6e2b8011b9517c9a36a12e396e8e9fb387d544e960e93ae650a569cb67cad9230fff77b8677bf709360dfb6131d0c4e7f4a59cffc31c7445d04a3bc5fcb6a3ddbd81179270e5ffe1599dbc7df93466b2d67e603f1929fac42c675a54b5c5776b97e66f39b8965ff7bbc57e23714434afe4887d2b7e58319d21151aea5af2ccfda07fb5aaeddccd6179c9381ecba843c0f3858d9e17f6e4ecc2b83295e90fdd2bb19e22cb6a3ae3d8cfa11f933267c300d85edd189e01bfd43a050adba187ff61f6567d66ecd33aee50bb26596a18a003dd4e026dd860fae45cdec767da0f397dd8777f8c3180151f955cc5559fd610f7ce7f9e9cfae5ebe1a4e2fdc7d0a727613ca65e95d995062dde61b279f91f5f220fdaaed2375ed58f585feda1889f47815de637c88ce675255836067fae1d1af025b15faa6c992ecc868bd5288bb881fbfd25ba552300e9cc73d9d0e18786b080a79363cffacc0a09a89b7adc3f856260be40505c67c11857d2b870c62c745f7949161e56c24b0302c4a532352b0e042d80bb0679a427291cca3a89bb49ce68c1571699b53e617b26aaea2a27f860245760d374ca9c01b636aee520ca2a417412a3289aca4b5ebb5652a53f83bef3cd77083c5ca9731d2d2e950ec8873d9e41f0c02b0b2595ef828ed312fb48a48cea0eb635b89f4a10ea72e7961aac5acc65325877ac81cd1355367a53c235a85a024f7cc09aa20db1236665a371fc3878ec60920d07c12e20c8fa7337d1db631b34df0ce3b8462213a1ea41fd27b5c21ac85c0de207ce28d57ccc09211ff0178bc02c4f8c149bf1a3a4ba4a936f653d1f0e19a5837cbc0b9b64c75966547d6a794ad5edc961e6ec6f0adbb986ca5e45ca83b5a5e1107f267e3eb7666970886d76ef367720140e820ceae21afe5e93cc8aa36da3bdc8ae87bfbaae068a4ef2a17eace47369d1faa2fb937d7ff432b43c0f1ece05a446cb57efe65d3c684a28f37df055ecabdce98b50a22d6fac36bb4a924e43e7e40b564f402bfd0863ae7de4130f859d7333f3d752bf0976ab453eb52501a335e354f8037875b1f6de2989ed86945166fd3118c05b78523b0933cbaa1041be9e72daad786e2c72d422c76ebcec90e5a01183f043749b64c2168c316651b5ca21aee43a3d50a661433fbaf997c9618ba86a99273f24e3d5f211c56a70f6032b2929804242e3f4a7c1772f713ddc430c3dac3d2ad16754a0445b4b781a704f172533b74934bb52c82b07910c0166b0ecf877d6745e2068ec25fda7e04a38fba011171ab4851620488135cf0523e77908d0ccd4ed8e01f3cdbf23d596c9f5f16413b26f3085ebd2ec5c6a7e85bc572e22b292ed09ab0528de5b10aaea9acf124c29d16f352a5f6d1addf771996b0df7703ff0280dab175093569e48426b42eebd5262026282ecd693f98a7881ec82abe671ac4d096b9b9cbf9ccfebd18fb00df0f1a136500d385d274e0691f359f1bcd5e6060f44650f6185e4db76fa96a668d7d7412704b94690e1637dfb84429c64664e93df1d01d82d9755eae1d09a4b24e37163c167234aebfe091cd4fd396c4ee2c2b74b1539b6397ec06e194eeba24a1241b6482dd9db60e06a281ab59d8e64343eca9e92dba36a42678a517485b8827482e626511f1ac2f9f0a62c4e8550e15d56bd7bea46f8fbc72f021c0e363761bd6440beec5c8e76979e4efa4580ff03ef895fdb82ee22c95522f299916cfd9f5ef94be9f5be8b3e1e7c2fc6f9cb2cc74c2b857b11cb57af11ce52d82127e0b19ef96736dd7f095324650f4406f2d3fe776c93a31d89d4feb4a82d2f851c9caffc1fe7c970dddf4217eff34ed4437db740e92bb115f8a0ef9af4aaf41abdb01c12fd5c009dd42b56933e2c34c72dde38c97a5a5d9236d8a58793ada5297033113cbfe70fb6b361b637db5c7e8a2411bc341fa9f144f8f12cbb68294ffccccf77e4ab0d4b983aa6b86b9eecba9fce5b1480e3044688073695f66ec1a628e7e59b3f70a68db280ef993e70b8b3b2c41f1c96cda54a9484cebe6804c358f9148711b1fbf5d3af6dd81d32ee9fbc2bd6b68a037ad99c28946faa691632bb19edb28db5f28b6f48acde39b6621dc593a8fa3a902917cd951778bbf7206a5ca14bb04d527c9b719016d7c7047ca1c9c0b6a036c062e2750ca56a1010fadecd8475fbf09db5242bbed23f9bf34e5da4079ada4cf314204242e8ec3596adb1ee80919bb668070ebc29fa7fed2bd27f5ae9be53a12f85ab226af916d93f6ea6bc2efa7c48ea9c51538a877ce8d05fb134524ea47e99344f398a2aa6db1f25f962f1bd0f0da4f7afed83b2789bbd7647afac07c1b020c59cbc40abde822f8179068912348532816b8ece3a7ba4a52210148fd5f5768d57ca5102768efbe0e4bff499a837434fc851df6bfe5f821d4e59293a1591d4ff5c1d5a3c0c007c3998ef5e1968c3922df2ce2ca0e78cbfcc3fa8e83d47dd9277dafae420232b5e32860dba155794596f86b6e87899c7415b9370e9aeafd1f864694b0e4a04f8b35930900716e13be51daf5c969e23dfcf5af34d092d55af1e685f4072253efb6899a34fe1a8f5a3a749ea951f9ae534a6c3a621289be4a33cbaab6ca97031a27e89f87d468c076fe9559939bce004eb240ddac2c1680a4e21895c838b439ddc54b94a5ff8266cb0381764d8a62c3a2676b0500cf5c4c51a90343e092c63ed85c233e8e22307c38e990df05957a921549576b576f69c5afd3fd0865dd0bea6708fb0c0870141369b407ab4edd1023926cc744dc56132a4c8db024b5b4bd1269b731124836b1f63c539820f7f119f2f5d21df8fb80c6c191d8ef31b296f1e17161b1c8418b2c804f080b51a72ec0d89fdebcef96fb7344ed601f2228ca683de680a6099221d21227a9753d3e0033b9d3a6ed2aa653d82530fa9e6b464fa625239bcbd735babb4c80f767de1c77a3092d3d8ca719874f26db86ecec30f948ab2089726da1ae9088c35289590cc04b9aa4b4b11ab83101e3fbbcf27a7f99bfb0ebf48ea2dafd2a22f71787572062b361631e2cf693cd76f9acfbb1a9e8954701d40136b5964dabe609a2f479eeda23d30cf83a1e738bf58347d1425ae0d80d33821ee7928070ec5da8900264f7c5f354b91d0791c97ff163b76e827393ab8ef03648f16052ea4fcf7ba20a59fb71c23f609a8a9756c909efad730dabd90c08cf63f38cb09005cdbee7ba6d9a3caf8e1220514b29e1d4f55bed9aa6597d0b526114060a49e86670ff2ea48f8644ce01b92c6abd7bca7504b393d325b1ac678db2d5dac60cc0e2ca01048a2843b78c5a3a15ed18f6e6095414d94b305e2b41ca947595a80a63407ec4a2a367602a44f8f5244e1ec597fa84a5764ff826470ba9ab04f3b9644f2c0ef0481ed47a7baf689bd5ac90a6920c532ca0aa22ca135c7ac73c946179b7eb1c2ec5acf1d3273f5505d6a9c7200bd03fff806187b883203fe1007674a202abeb5f48c3b53c7f3b377f7ff221b5246c398cf1992a65babad9d9ec9ea2d64266fd44ff6a50fcfcc43d893c79588868ac7ada63469aa068228b9062579f45b0b90bc44c7aa82e8380f8b207ca6e94f3391f1cfc0394ce2dd5eda60b002d830afc53b625a535f5169f985e4d4b92b4e9d496aecd1e168f7dd46326e09bff90a2fd5c39978a0305c4f6fb3742aafbe141196eada6768c7a6287f1424575a3d6b4fcd48668463d6b5c92d5b1e903f556a1bb2fe9337fb34dff515ed385a6630229aba1f268ef23c786f4c92ff95a85a6e0f46b75ee94d3c0d052b257d32111409a46809863919fef8d61a12c7bc2309798ce3090ea0e16e37a1eef56cc698be84febfd2a89a5e1c11c35614fa8ff9132ea22fad94f878f7bbb6ccf7909b9b9e0643849004fc3214f2a1fb3981be2c108f2db671a29de4f285433598d4d964b7d910e162544335f530980c61d65d383d42208339d785f7ef6be567e9f70fe280de54bd9f3e4341bf4c3fcafa624f0052351a91eaf02e46a0c0bf28eb0f1c1038c4217f48d12c3fde527c46bddf8e3ce4a82dfef2872adb988a2624d8a2f5dbeabc7367ef8c8f10c6139a30d7cdac84a35c2dea702d9acdcba7a32c9999720c7dcd66221052da6263b932b182f23c687cfe3eb100e4cc58b0c20fef4563a41592cff3393456a539ea05ccbc19905392d7f0a4e3fd5b338591d948cb010ed9c5b16c92b827f444d0c61345ee4300294974e9cb37cd617be1aba7295687af0acbfb66ec772c6b07db9356e1959ae28339448156df9a919cba672d92195bf8c63323b53e761d6fe0e3ccc146934ecae7b4c74ad32f0d8f162938f6372b0fb6902e9ffb93dd8bb06bd25260ba59f5458a5508e11db52d9810079981957994f857318eccdac9fb23fa97587a903a9803240e279f267a0ab268511ed8ac9469f0e5f05d1a4974ce400bcadbb6f74a47ef2a79f3db446abcf5eac5097c3150ef18569ef25fc900c8b47c44d51ef0caf9af6d68d6fa04ede192dc691d70a227e83d06910b7df6a73ca2be00e12f81575df9c2cbb0507f36f9aa4073feb4db420a35f45c05701338983d9ac43de11fae9eb2d3af2d8efe5d8f35603c91349ea0448989e8318a9ac1b0f7dac7e8296b2cf398b1bf53f2bca09d24b2db9e14446a20b86de27b2edee2dc504a56deba40066098315a2a16b286975290c899ef75d2a4fdad7c3afcf5f0425bfb8086235353dbdea9526bcdc0f0dd57d7e3f70370e4cf49db33e9d1e5ba34f4d1fa65e80c67d43601559da8333ebadefaf719d78f8a149deab5e599285f29bbb536fff46af417c8344e08e6fc6c2201deeacc67e0b1ea8e1b452d5da37fe08c719dd43b22026257fae1cb98e3dd6018762fa13d8be463457538f0a099cb9ed725b6275ae47ffe9fa5a1308ca1c1d6f6148698ed0c25abfb8399b53032a788c04c42783c31d06b6b59a845d328a69f19046747c9f3b9430e052f6198d83a029defc9435a37466df728e727fbfed868da0bcb4a1e0094d76700b31020448a45e344084e00eaa7b27e5e4d4b7749d267f2cba9093cf5a3f1a7d90a6dc63ed33c89afd7d817bdf21796148842fd7a42471abb65dd28df4a070ef1309c0f4d00ea514e97a0c9362625ac209a20c7ea2474ff217138a86dc8d68ae99769054ef6b5f68aa9fbcccfa152c71d5ce41cfc9f9d7698a6f6450a4473a5a14b711687c52e34e6e54d62c37f09ac252b06a7b12ebc01e779b62f2b9c7d301867e469c0cca6108e3d0fd6ded5269c83f4cf11d285369b6c8fe65bdf5711cb273d41a4b4248c880ce7cc86a3e42f684312d4edb9b079129b08858b811e7a8b2696e5477fd2c9290f5fa292b4b0e2f42896b7bdd89d107c0007330ceff4367a9354a727a2f7ba5668c12595b5c17cb491083bea3ef8300ebf7732dc8fbad57cbdd1f27fa0ee2d5771e64cb3b47f0833094b26d31bfe1385742b73c06ea227f0ee39ddb5c2b04a1f55c63cee15290c0bbb6498406def7f6bf50e160ff9986a7348a230f5f1b1173cd8283847f2941c0795c0033a063f48e629e03145eab63d3e267ab93a56132986a75ad70866d6774095af9307771c7faf9bdba73e0897382dc8d9040db124cf2973c260e88ab59d167fa82cc22f91cca5925592b67fa3c8806456f3b6e119087f156593a6fdf66bf5382378cd7fa3f4802ea44d2c6dec735b1750c63d9848517f8e64ce74ce527fca9e993cd28f3ef5a0e37b929b68977cf49234fea0fb2d5fb5cbd0e0aab069080bb50e423b60912086b950fbac5b9d33d8791889b80bb1e189e39d01b6770fabfc91b5e776bef88eaa629d2ee023cde0ef0a5fea4853f4fdba379c6fb3766145a66fcf5ea1e0dd4a84a4bf8aff7cfdedfc7b3a1fbdf50b5c4ec0e36c970ef7df29dcf7e24db67cb942add943e6b40249ae8c64946ea475b74ef3bb2322d6d580efc97a540899147a32ac3b043f8a747a2a9db5095c09faf1f5ab056786e9a2aee8258b8c6691026b642a1dbb21fe17d53799e4b329c86b107aae09f259d611a0724ed36231295ae0f0532be8e1f8d647581479bb00f65f9022290fb84329c6ae815bc1b1f2e8fc2680870cea19b7107f346decc1b23a8b4321ba31ee104c0813873be0c880c2330f22ab5f8e8294355056dca4be24f76a9ff8c38e0d7cef26439cfc1c545c3df623399ce6542c0f439ac764c563830a9ba60f284ee0d5c5937cba652b541037c362a74e60c081731b05c95dbff0f9dbcd641a17ee2de9cbafc99ba9f66d83c1ea5b7ebc27a9f6bf182840d13d32b695313957b3677f27a255606a83be051ef49c8bf71773da3bc5243acfbe100b7d5a372288596bb5070039925448e24ad819f0a3ba6c2cfb6a44f40ff744f137c9d39138a90e315c46543365590b49be1f1f1cd67d583ce42e22d6712c5e7da4c1e9e05f652088095b74d1fea6d893521f6b49889c1eb382ca127051a7cb53a73e80baaca39e6422cd0bca3a9ac131392da7c3820a5d9ce859d633a39e32e9fd23208b99835551fe1a08f885ce8c4eacd21b7a70ca0b1bb99005b52ce8c5a882bac2e1d10ae2c775c729acd747fda1f2046cf58b85eb637a618f2c43cdd12c17fcb3780d508f0f7bf69e32262d42418e9594bd037ee1ee52d46f990542fb5325a91d3824f584fc70ee56b3e27979991e1ba23aa11c3cda8caaa017e95eae26ac355a2bcf7622948dcc7affac16c6a6d2850da7a2807efbf28b5ed722aeec24d3600c75d3996df6a9e131b3b065d97df0fc3ffaf51e455d370134e16c29e97cf087400f8a870cbcc2391b77e0db4c8a73194fd1c0056628245e1f3468bee67aa29a897f68313b96d1456b5840ee61f5ead1a5b16a856c74ae5340496f2677af7f6992e939113f88245dc0d211f9b0459ed5216a207dd852fd7884b97bda43f6d3d4da105b0be3529a92fda1f2b0bfe09d89e9c6f2b36c338413d40378d483eaa0f5b5c5f207b1beeb7dc606a247f632b3e47220c720d81cc783990d49b772edffed38ba25211c72a3e1eb9aaa44c7725059ed7a3a27d853181333f3f49e35802906858329f0c2883ba1200ff3c758f2547d4312f8baa875c8de600f5b798081c237caae50c2f56eef1f2f9394cb0fca55f8c9c9bfb27e7e3176f9e6ce9f9df9ada5209d92a4a5f3d8084cf46e2a94ea3302291e9afa09eeafe1896536f13bb0ede9002bac5577488a6cddc22f9c1b3fa2ee103ad8a41ca4404d8459a7e596ffab775866658234d61e87ef55892834e541ee2ae897bd46ba453d1aff7e2a1ec2eb84e2c306fb8061ce3d24b39cc1300e553786b6452ffd164c412ede34f6d0b95b239a6b591d5d8e7e56ddc32375038ad334c8f92e4b006e0bed1ae1a39a6a7ca4847188e3086158251f55d6cf3cca70b2a84a0ad82fac6a3687246cc488faab8c6a0bdbe471de3f953140ff5717308a29a9117af6546ef888a1f1ff02a376732733bee55a61728a814efdcb2a118e7594754da5851e16d889b193b8c895e958145a2a38627c2b8980642a21cb8688b684ab8ce845c894c350956baac2bac620608326556b3691550b4bf01b2b87529dc52eabf462d8da3ba56789f3a86b9cf14ad9fab0cb81b7def913292f07da1656bec5dfd8673e4b5c0abb894991acb3b6b38a3bdf99716ccd704157d35f11fd7071a7f7f1e85bb8dacc7d218e055ebbb3ce4ca6a8de56dea3d0deb54d554a2104c5e91b60731f8bc956e3c39a22795d4db10d4599b03f303bff94f038e0d0757ef91b6f3875bf1355bfbbfd20118d297dc3b61765472d6ad731b8c5b1a957d3e296598c6fb79b95d5a34da9294cd465f9cc9b63582dffe0a7cb53bf7d286a0aa9b4984d6f85c456a050b7116643fa0782730379849e4b4a4c97e5d8e1c5522abc9df3dbc9e71ebb3462eaf70a9c2dbb288212fe405f95a63afac30c7d7156bdc06d4295db4be1da49697b1632b498e08c41c9a1462fbf5d1fb60283c22f2133e65ab717a2cbfffaa4a4d5741bb919d808fcfcf17d22ebecd5503ea12f54ee21be6d6a005d9a09bb01fc91bd06d986e13c17cc1983342003317b8e7c19de28a6339d9de3c6fcda3df997be565274bc8090fe31f3ac53cd5a47a3d8d8deb5c149c31d6e9c2eabe854909f5cce286162b43e477f836369688e67b5ec3b6510db118066f33ec1cb72bd770534227db8db9cf7ec2ba9e5feb8ec8c5683f7c74f0eba842eb69eac3ca17ccadca1e7b12d9fd9f935af6c2914a7e3ac81c3617fc63b89d0e9549abc82ec852ba3b79a2a18a06723d5c9d5db8d5c5d6634b667a969e892f98e51ce824176d448c7b7e52ae3776870deeed201a2f7a9c17f002c5b1bc400200af1c15bad38c7fafa4edef99f8f4fe2308729dd5dbf8ce8b72242913a79e2bb22f5a290c613801d12f2fdc028fd5453fa1e054d2d0e6dc6497eb0ed949c2c682924b56209331d29440145cf19edb062cd833438257f766bad7ef2baea4a5327d155d9efa0cd6831d4f77e4c7b17820854294aa35012b273af7dfe5bfb8569763d70380ef118d921808b93a9f7392e5f92bbbd7936fe1774956c3250e484f8a10327d0ef8462c65bdf175bff23b36497ed76d0259daf8b08ecf861a05edeec3f24c8220d3f4342c37d84a0e6919c89d9de3f321bfec1fff9c78a64a126646807477e9c6d3525a921c77933deb3e137dce4f651c52fc7efade7c277ba225b0665e78d220e27b1fb058054d39ee5f0b29a2a18c5789a40dba2901a1eaa5f980f8c84c1c89f3f11ecc3b8b8b972f1e1301d8c9180781071cb4086c833a933d2f5e7d4fc95e0e16dd9d65a53a5303f8e7000e7127b6f0a2b8a112761d1a7061c97f33fb9e3f70aa15347780242fe284121c225575c5939fd5f35c55e227a02eae2a129c94c5d5b75c14cebdf6bc61a1c5adf88dec1f8f8d72de9df80b0493f4290819691980cbea7722fb75f70dd4ebb575ceb2075201f1dfadcf3a6a80c8ac289fdf63e9299e5746e0798f068c4260ce774e0810cc114e72bc4626e57ea6401ebc3e744e8e45125304d035758e093f19c8363f1334bdbbce3380aa2b1a1e6960ffbc9f6517490876a372a57321395b2b63b96fe74183a86f07cd325b5b939d5dde1b7667cfbd49ea7f96f913e23076608d0ac5e2af50311b9998eb7ce4389732966b55b17f172d0ade510bac818b5ba49a999e63a0314e3cf885994886c770d3ce00d36e29edc7046a2370db5b53e1f30b25a4b7ff0499d1f5593dae0b26d64d58e7d5942eab14ebe89f9433d6c8517eeb372425849a70b646278d090ac8b3176bd6867a357912a8173e61c605b0cf1cd96ff77a2d21e184e516ba0869497ee0eb67d68b766b5cea7a37ef9204e2cdba42de4f53ba6ff0335c1517b41492d782691f1cc2db4d5ae5d42f5019cc98eea999f4565dbc51e82c5b0179a3a2752bdf30dbb85b313d3bf4f78d1fd14cd819355f0bc67c4ce64625b999c1b1a0c839d2ab7ed111c5e942f1b044d2a9e5f823aeae771eadb4bf59becc011f4c0d3235d544ca85169a06ff69e5a5a1a014ea137a961984761f69788bb1db8ecc7d4fd6fb69520ced09310d64a8a1aa5555e423752b826b19eca0f30426e412f842b6cc87e9f6d784deebfbdd1c24196e266ad2f9caa225ab0e2960d64b3867c17ca119992ff332cb07be638c653844fed07b54a01809ee169971a4ece0102329754170aecece8a5f66ec8e6e6706079f4c105b31da9de5136ff2a50d9e26ea070096c0525a309dbb021a6b4afa1b7827106173989380a7531c79096e82809ad110ad67e4c1ff8d2a3f898bc0760ef8bcaa69af1816e741de624c031065941a8e2893ba55dfd0b73c5f363935b4f6b57d8457b6a9c9ef26ab9216a7cccfbf7395eaf376ff26aa5cee7d4cd8363a1f8e5a04335bc2afddbe325bd285a9a738843ea2cbd06e01802b51ac7a980fa8dc74e791cc181154971a2db556bd66072724fa218fe029ffd1085746163001fc3eabcd51304293ee6962cedae12f58c6f1c160e3162fac2246587789d2e7b55d6aa36cd6fcb42e3190d395981b59cdc16d498c3805dfc3dd20c4ad22b96e2b69c61fac741fbc2937951b45a9db190cd149751eb8e9865de82db5072521bd694eee3aceaa68a73bb9efcb8b37ad4957128fbf6a5932b40386f26df96e2c443c4c12985a4ed26457f7748e81a32152be5dad5f2216bb44aafeeaee5901289de80cb433311a5e915e6a3bf2b238ce4d5b1b846f64deede32051fe8513e7bde308a0b831c11fbaef7e8488b55644fd5dd48a0235321d12d87d20f9da249f00ebffc06c7bb0a7bdd4a763c43d5f24b75ae153b1679e82fd19226983a3d46a322e2f899b280d3616e0d7e76cd5d0f5507cc636e670a626f505cd6359547cdd9cad5e6425205b1094f984249bf7e07ec67b0b685e15d3f9535cd879432ec395a897f5525a07cf8f22b29a4426d9c853d2c112adbdbef016e8495575efde99e506485123e87f50cb04e785660ec589c97baa261672a93e83a12c344903941a52ec5eb39e0088a58e0f2e8a71cd5e3394a44fc6f7cc34adc7261bd99d41998b404cb58cf9a171f880839f3c7b13754410d30aac2cc58f0a0e1d7ae8f84855a3469c135b01834d8d3eb4ac28c90f3b43e03827b9fbe0dcef3e2e781be65ec406ca0de3ce0ef384d126df0e7135182fada4b8839592cee3d278dea5ef08b649509509664f4e7a408365f47fed021f0d8cf4f07200467368136d937c1189d581f5101c28c0f25f96def465c9c794cb93b4fb0882a20d8683af906a690896a6765f9ca513d9f1e71095101f626a0dacded9ac611d87a375ae9546d3fab12b546cafdd6550a590eb761600475582b612f9f888332beb30a1d1c46213855e2dd1c8b7cffd3459b39e204b10e4a9cfee08839e348ff7f3d8bfea35e08ce77474938a86c040de06043d2ebd2ec1a394a2b44b30738226294e88b8c1ae955224169e2517147307040222718cfb5ef579552bc6881105b3fbb16ee52161dd27931bdbedcb00d4fa9ea33f90eb68524ea98e8b92d45d42bdf095f3458e9089dc19c9ab1b1d4671f6b1d2eda83252d18551b9d1c3ce076ad6b043466d9cfac050e5e52ae96a0deee439fbf6d3c25160796fea9f2220ad542e25c1dabc53b3fac4001ae90ad94a79ce2bd5e03025959075380fafff763442cde31e8ac4915eee539c567ef55ead2d9f39a309d9a125d4c8b0cd147e46ae1f01cdad3bcf9f60de8bd54d632a9faa757050e0f76bafb3480ad3f75705afe5f17d6e932801a45827aeda5bbe9cde5827492a3b6a57a00801f3475976cc1c1673947aae914726233e52c32d39eaa0226c601cbdbaba1fe72c7d9bffffc72760f0911d85253fc786dc3f7c267b6dbcf070655b52d099f6c570bb94f4a81da4ab1415b7cd06f1d49c596e0261760a7fe59f3f4d8ced8ea471c8156b592307bd66d0fc385aa7bca700b13f7dc232cf52955e15dca9b7f690df37b      </script>      <div class="hbe hbe-content">        <div class="hbe hbe-input hbe-input-default">          <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">          <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">            <span class="hbe hbe-input-label-content hbe-input-label-content-default" data-content="联系站长以查看密码">联系站长以查看密码</span>          </label>        </div>        <button class="hbe hbe-confirm"></button>      </div>    </div>    ]]></content>
    
    
    <summary type="html">创建一个网络包解码器分析DEVP2P协议</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>（旧）创建一个网络包解码器分析DEVP2P协议</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/30370.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/30370.html</id>
    <published>2024-10-14T14:53:46.000Z</published>
    <updated>2025-04-03T06:22:53.771Z</updated>
    
    <content type="html"><![CDATA[<hr><p><br><center>本项目最新版本</center></p><p> link 本项目最新版本, <a href="https://zhongye1.github.io/posts/1104.html">https://zhongye1.github.io/posts/1104.html</a>, <a href="https://pic1.zhimg.com/80/v2-593dd0a3b84d023b3827b97e81e0242a_720w.webp">https://pic1.zhimg.com/80/v2-593dd0a3b84d023b3827b97e81e0242a_720w.webp</a> </p><center>附注：此页面使用wsl构建不可行</center><h1 id="安装配置WSL2（ubuntu20-04）"><a href="#安装配置WSL2（ubuntu20-04）" class="headerlink" title="安装配置WSL2（ubuntu20.04）"></a>安装配置WSL2（ubuntu20.04）</h1><p>Windows Subsystem for Linux（简称WSL），Windows下的Linux子系统，是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</p><h2 id="1-安装Windows-Terminal"><a href="#1-安装Windows-Terminal" class="headerlink" title="1.安装Windows Terminal"></a>1.安装Windows Terminal</h2><p><a href="https://zhuanlan.zhihu.com/p/351281543">Window Terminal 安装以及使用(2021最新) - 知乎</a></p><p>一个目前在用的windows命令行工具</p><p>可以直接从 <a href="https://link.zhihu.com/?target=https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701?rtc=1&activetab=pivot:overviewtab">Microsoft Store</a> 下载安装，而且<a href="https://link.zhihu.com/?target=https://github.com/microsoft/terminal/releases">Github仓库</a>上发布有内部版本。 </p><h2 id="2-安装wsl"><a href="#2-安装wsl" class="headerlink" title="2.安装wsl"></a>2.安装wsl</h2><p><a href="https://blog.csdn.net/m0_51233386/article/details/127961763">Windows 10 安装配置WSL2（ubuntu20.04）教程 超详细_win10安装wsl2-CSDN博客</a></p><p>对于windows10版本可以直接命令符安装</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">wsl --install<br></code></pre></td></tr></table></figure><h3 id="设置-WSL-开发环境见微软官方文档"><a href="#设置-WSL-开发环境见微软官方文档" class="headerlink" title="设置 WSL 开发环境见微软官方文档"></a>设置 WSL 开发环境见微软官方文档</h3><h3 id="设置-WSL-开发环境-Microsoft-Learn"><a href="#设置-WSL-开发环境-Microsoft-Learn" class="headerlink" title="设置 WSL 开发环境 | Microsoft Learn"></a><a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment">设置 WSL 开发环境 | Microsoft Learn</a></h3><p>完成后打开Windows Terminal找到：</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2f7bd8d86.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2f7bd8d86.png" alt="pic"></p><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2f838b7b1.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2f838b7b1.png" alt="pic"></p><h2 id="3-Docker-安装"><a href="#3-Docker-安装" class="headerlink" title="3.Docker 安装"></a>3.Docker 安装</h2><blockquote><p>Docker -&gt; 虚拟化容器技术。<br>Docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。</p></blockquote><ol><li><p><a href="https://www.docker.com/" title="官网地址">官网地址</a></p></li><li><p><a href="https://hub.docker.com/" title="公共仓库">公共仓库</a></p></li><li><p><a href="https://docs.docker.com/get-docker/" title="安装文档">安装文档</a></p></li><li><p><strong>下载Docker Desktop安装程序：</strong></p><ul><li>访问Docker官网下载页面：<a href="https://link.segmentfault.com/?enc=499FLQDYFvyYdd7cCtVu9A==.MBdFIbVFnRUdUPcpdVZcA7hHAMCkjMVQbZW0Gwmi75DZZOEZnLuU9NNsfxJVDdlM">https://www.docker.com/get-started/</a></li><li>选择对应版本点击下载安装程序。</li><li>没猜错的话应该被墙了可以找我要安装包</li></ul></li></ol><p class='item-img' data-src='https://segmentfault.com/img/remote/1460000044606076'><img src="https://segmentfault.com/img/remote/1460000044606076"></p><ol start="4"><li><p><strong>运行安装程序：</strong></p><ul><li>双击下载的Docker Desktop安装文件。</li><li>在安装向导中，你可以根据个人喜好勾选是否希望建立Docker Desktop的快捷方式或者是否希望Docker Desktop随Windows启动等选项。</li></ul></li><li><p><strong>完成安装并重启：</strong></p><ul><li>完成安装向导后，重启计算机确保设置正确应用。</li></ul></li><li><p><strong>启动Docker Desktop：</strong></p><ul><li>在重启后，运行Docker Desktop。当它启动时，Docker图标会出现在系统托盘中。</li><li>系统托盘中的Docker图标表明Docker正在运行，并可能需要一点时间来启动服务。</li><li><strong>电脑要开VM虚拟化</strong></li><li><a href="https://blog.csdn.net/alwaysbefine/article/details/131277295">Windows 10 |VMware开启虚拟化的最全面说明_vmware虚拟化引擎-CSDN博客</a></li><li>开VM时BIOS不懂的不要瞎搞</li></ul></li><li><p><strong>配置Docker设置：</strong></p><ul><li>你可以右键点击系统托盘中的Docker图标，选择“Settings”来调整Docker的配置，如更改镜像存储位置、<strong>设置代理服务器</strong>等。</li></ul></li></ol><p>国内网络环境拉不下镜像的话就配置别的源<br class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2f87b1c1e.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2f87b1c1e.png" alt="pic"></p><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2f8cd2d48.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2f8cd2d48.png" alt="pic"></p><p>我用的这几个镜像站<br>配置环境要慎重</p><p>我的配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;builder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;gc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;defaultKeepStorage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;20GB&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;experimental&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://huecker.io&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://dockerhub.timeweb.cloud&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://noohub.ru&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="8"><li><p><strong>通过命令行界面测试Docker安装：</strong></p><ul><li>打开命令提示符、Powershell或任何你喜欢的终端。</li><li>输入命令 <code>docker --version</code> 来检查Docker版本，确保它已正确安装。</li><li>运行 <code>docker run hello-world</code> 来下载一个测试镜像，并在容器中运行，这可以验证Docker Daemon是否已正确启动并且可以创建容器。<br class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2faa11c5f.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2faa11c5f.png" alt="pic"></li></ul></li></ol><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>准备材料</p><ul><li><strong>Lua-devp2p-wireshark-dissector</strong>: <a href="https://github.com/jmkemp20/lua-devp2p-wireshark-dissector">GitHub链接</a></li><li><strong>PYDEVP2P</strong>: <a href="https://github.com/jmkemp20/pydevp2p">GitHub链接</a></li><li><strong>Lunatic-Python</strong>: <a href="https://github.com/jmkemp20/lunatic-python">GitHub链接</a></li><li><strong>Go-Ethereum</strong>: <a href="https://github.com/jmkemp20/go-ethereum">GitHub链接</a></li><li><strong>GETH-Docker</strong>: <a href="https://github.com/jmkemp20/geth-docker">GitHub链接</a></li></ul><h4 id="1-安装Wireshark和特定版本的LUA"><a href="#1-安装Wireshark和特定版本的LUA" class="headerlink" title="1 安装Wireshark和特定版本的LUA"></a>1 安装Wireshark和特定版本的LUA</h4><p>linux的python版本要为3.10</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update &amp;&amp; sudo apt-<span class="hljs-built_in">get</span><span class="hljs-built_in"> upgrade</span><br><span class="hljs-built_in"></span>sudo apt-<span class="hljs-built_in">get</span> install lua5.2 liblua5.2-dev wireshark python3.10<br></code></pre></td></tr></table></figure><h4 id="2-更改权限并复制Lunatic-Python-LUA-⇔-Python桥接二进制文件"><a href="#2-更改权限并复制Lunatic-Python-LUA-⇔-Python桥接二进制文件" class="headerlink" title="2 更改权限并复制Lunatic Python LUA ⇔ Python桥接二进制文件"></a>2 更改权限并复制Lunatic Python LUA ⇔ Python桥接二进制文件</h4><p>python.so为文章最开始编译得来的</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo chmod +<span class="hljs-keyword">x</span> <span class="hljs-keyword">python</span>.<span class="hljs-keyword">so</span><br><span class="hljs-keyword">cp</span> <span class="hljs-keyword">python</span>.<span class="hljs-keyword">so</span> /usr/local/lib/<span class="hljs-keyword">lua</span>/<span class="hljs-number">5.2</span>/<br></code></pre></td></tr></table></figure><h2 id="关于python-so是从哪来的："><a href="#关于python-so是从哪来的：" class="headerlink" title="关于python.so是从哪来的："></a><strong>关于python.so是从哪来的：</strong></h2><p><strong>python在linux编译后的文件为.so</strong><br><strong>这个由编译Lunatic-Python: <a href="https://github.com/jmkemp20/lunatic-python">GitHub链接</a>得来</strong><br>不会编译的可以找我要我编译好的（</p><p><strong>如何编译见项目文档</strong>：</p><p>Lunatic Python 是一个双向桥接项目，它允许Python和Lua两种语言互相通信。这意味着你可以在Lua中调用Python代码，也可以在Python中调用Lua代码，甚至可以嵌套调用（如Lua中的Python再调用Lua）。这个项目的主要用途之一是为 <code>LUA-devp2p-dissector</code> 提供必要的工具，使其能够调用 <code>pydevp2p</code> 中的函数。</p><h3 id="项目起源"><a href="#项目起源" class="headerlink" title="项目起源"></a>项目起源</h3><ul><li>这个项目是一个fork版本，原始项目来自 <code>labix-lunatic-python</code>。</li><li>另一个相关的版本由 <code>bastibe</code> 维护。</li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/lunatic-python.git &amp;&amp; <span class="hljs-built_in">cd</span> lunatic-python<br></code></pre></td></tr></table></figure><h4 id="确保安装了LUA-5-3"><a href="#确保安装了LUA-5-3" class="headerlink" title="确保安装了LUA 5.3"></a>确保安装了LUA 5.3</h4><p>通过运行 <code>lua5.3</code> 来检查是否已经安装了正确的LUA版本<br class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fb14402b.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fb14402b.png" alt="pic"></p><h4 id="查找你的Python版本"><a href="#查找你的Python版本" class="headerlink" title="查找你的Python版本"></a>查找你的Python版本</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">ldconfig -<span class="hljs-keyword">p</span> | <span class="hljs-keyword">grep</span> <span class="hljs-keyword">python</span><br></code></pre></td></tr></table></figure><p>这条命令会列出系统中所有可用的Python库路径。你需要找到与你的Python版本相对应的路径。</p><h4 id="准备编译（构建）"><a href="#准备编译（构建）" class="headerlink" title="准备编译（构建）"></a>准备编译（构建）</h4><p>根据上一步输出的Python版本信息来配置CMake：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cmake -B.<span class="hljs-regexp">/build -H. -DPYTHON_INCLUDE_DIR=/u</span>sr<span class="hljs-regexp">/include/</span>python3.<span class="hljs-number">10</span> \<br>  -DPYTHON_LIBRARY=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libpython3.<span class="hljs-number">10</span>.so<br></code></pre></td></tr></table></figure><p>使用的是Python 3.10</p><h4 id="编译（构建）"><a href="#编译（构建）" class="headerlink" title="编译（构建）"></a>编译（构建）</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">cmake <span class="hljs-params">--build</span> <span class="hljs-string">./build</span><br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="定位二进制文件"><a href="#定位二进制文件" class="headerlink" title="定位二进制文件"></a>定位二进制文件</h4><p>构建完成后，你会在 <code>build/bin/</code> 目录下找到两个重要的文件：</p><ul><li><code>python.so</code> 用于在Lua中调用Python</li><li><code>lua.so</code> 用于在Python中调用Lua</li><li>找不到直接搜</li></ul><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fb4591cd.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fb4591cd.png" alt="pic"></p><p>然后把编译好的文件移到论文提到的目录下（见上文<br>![pic](.&#x2F;C:&#x2F;Users&#x2F;Think&#x2F;Desktop&#x2F;大学项目其三&#x2F;环境安装&#x2F;Pasted image 20241014220542.png)</p><h4 id="3-克隆LUA解码器和PYDEVP2P项目"><a href="#3-克隆LUA解码器和PYDEVP2P项目" class="headerlink" title="3 克隆LUA解码器和PYDEVP2P项目"></a>3 克隆LUA解码器和PYDEVP2P项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/lua-devp2p-wireshark-dissector.git<br>git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/pydevp2p.git<br></code></pre></td></tr></table></figure><h4 id="4-从源代码安装PYDEVP2P-PIP包"><a href="#4-从源代码安装PYDEVP2P-PIP包" class="headerlink" title="4 从源代码安装PYDEVP2P PIP包"></a>4 从源代码安装PYDEVP2P PIP包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> pydevp2p<br>pip install -e .<br><span class="hljs-built_in">sudo</span> pip install -e .<br></code></pre></td></tr></table></figure><h4 id="5-创建Wireshark插件目录（本地用户和root）"><a href="#5-创建Wireshark插件目录（本地用户和root）" class="headerlink" title="5 创建Wireshark插件目录（本地用户和root）"></a>5 创建Wireshark插件目录（本地用户和root）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.local/lib/wireshark/plugins<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /usr/local/lib/wireshark/plugins<br></code></pre></td></tr></table></figure><h4 id="Step-6-符号链接或复制-lua解码器文件到Wireshark插件目录"><a href="#Step-6-符号链接或复制-lua解码器文件到Wireshark插件目录" class="headerlink" title="Step 6) 符号链接或复制.lua解码器文件到Wireshark插件目录"></a>Step 6) 符号链接或复制.lua解码器文件到Wireshark插件目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s &lt;location of cloned dissector&gt;/rlpx.lua ~/.local/lib/wireshark/plugins/rlpx.lua<br><span class="hljs-built_in">ln</span> -s &lt;location of cloned dissector&gt;/discovery.lua ~/.local/lib/wireshark/plugins/discovery.lua<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s &lt;location of cloned dissector&gt;/rlpx.lua /usr/local/lib/wireshark/plugins/rlpx.lua<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s &lt;location of cloned dissector&gt;/discovery.lua /usr/local/lib/wireshark/plugins/discovery.lua<br></code></pre></td></tr></table></figure><p><strong>可以直接复制这些.lua文件而不是创建符号链接</strong>。<br>终端里找不到文件用文件资源管理器搜</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fb720710.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fb720710.png" alt="pic"></p><p>好的，你提供的步骤是安装自定义的 Go Ethereum 客户端。以下是详细的步骤来从头开始安装和运行自定义的 Go Ethereum 客户端：</p><h3 id="Live-GETH-Docker-Startup"><a href="#Live-GETH-Docker-Startup" class="headerlink" title="Live GETH Docker Startup"></a>Live GETH Docker Startup</h3><h4 id="Step-1-确保Docker和Docker-Compose已安装并正在运行"><a href="#Step-1-确保Docker和Docker-Compose已安装并正在运行" class="headerlink" title="Step 1) 确保Docker和Docker Compose已安装并正在运行"></a>Step 1) 确保Docker和Docker Compose已安装并正在运行</h4><p>检查Docker版本：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fbc87f5d.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fbc87f5d.png" alt="pic"></p><p>检查Docker Compose版本：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker-compose <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fbf0229a.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fbf0229a.png" alt="pic"></p><h4 id="Step-2-克隆GETH-Docker存储库"><a href="#Step-2-克隆GETH-Docker存储库" class="headerlink" title="Step 2) 克隆GETH-Docker存储库"></a>Step 2) 克隆GETH-Docker存储库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/geth-docker.git<br><span class="hljs-built_in">cd</span> geth-docker<br></code></pre></td></tr></table></figure><h4 id="Step-3-构建自定义docker镜像"><a href="#Step-3-构建自定义docker镜像" class="headerlink" title="Step 3) 构建自定义docker镜像"></a>Step 3) 构建自定义docker镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./build-dockers.sh<br></code></pre></td></tr></table></figure><h4 id="Step-4-启动路由器容器"><a href="#Step-4-启动路由器容器" class="headerlink" title="Step 4) 启动路由器容器"></a>Step 4) 启动路由器容器</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d bridge-router</span><br></code></pre></td></tr></table></figure><h4 id="Step-5-打开Wireshark并连接到网络接口"><a href="#Step-5-打开Wireshark并连接到网络接口" class="headerlink" title="Step 5) 打开Wireshark并连接到网络接口"></a>Step 5) 打开Wireshark并连接到网络接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> wireshark<br></code></pre></td></tr></table></figure><h4 id="Step-6-依次启动每个GETH节点-客户端容器"><a href="#Step-6-依次启动每个GETH节点-客户端容器" class="headerlink" title="Step 6) 依次启动每个GETH节点&#x2F;客户端容器"></a>Step 6) 依次启动每个GETH节点&#x2F;客户端容器</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">docker-compose <span class="hljs-keyword">up</span> -d geth-ubuntu-bootnode<br>docker-compose <span class="hljs-keyword">up</span> -d geth-client-<span class="hljs-number">1</span><br>docker-compose <span class="hljs-keyword">up</span> -d geth-client-<span class="hljs-number">2</span><br>docker-compose <span class="hljs-keyword">up</span> -d geth-client-<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/09/22/66f03893a6823.png'><img src="https://free-img.400040.xyz/4/2024/09/22/66f03893a6823.png" alt="pic"></p><hr><h1 id="接下来新开一个命令行窗口来做"><a href="#接下来新开一个命令行窗口来做" class="headerlink" title="接下来新开一个命令行窗口来做"></a><strong>接下来新开一个命令行窗口来做</strong></h1><p><strong>论文原文操作：</strong></p><h3 id="7-5-Installing-the-Custom-GO-Ethereum-Client-from-Scratch"><a href="#7-5-Installing-the-Custom-GO-Ethereum-Client-from-Scratch" class="headerlink" title="7.5 Installing the Custom GO Ethereum Client from Scratch"></a>7.5 Installing the Custom GO Ethereum Client from Scratch</h3><h4 id="Step-1-克隆自定义GO-Ethereum源代码"><a href="#Step-1-克隆自定义GO-Ethereum源代码" class="headerlink" title="Step 1) 克隆自定义GO Ethereum源代码"></a>Step 1) 克隆自定义GO Ethereum源代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/go-ethereum.git<br></code></pre></td></tr></table></figure><h4 id="Step-2-编译GETH或其他所有GO-Ethereum工具"><a href="#Step-2-编译GETH或其他所有GO-Ethereum工具" class="headerlink" title="Step 2) 编译GETH或其他所有GO Ethereum工具"></a>Step 2) 编译GETH或其他所有GO Ethereum工具</h4><p>编译GETH是个大坑，出问题的话可以看文档后面有讲</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> <span class="hljs-keyword">go</span>-ethereum<br><span class="hljs-keyword">make</span> geth<br></code></pre></td></tr></table></figure><h4 id="Step-3-运行GETH"><a href="#Step-3-运行GETH" class="headerlink" title="Step 3) 运行GETH"></a>Step 3) 运行GETH</h4><p>文档是</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">geth</span><br></code></pre></td></tr></table></figure><p>就行，看终端geth编译完后的输出来定，我这边的是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/build/</span>bin/geth<br></code></pre></td></tr></table></figure><p>不出问题的话终端没报错这里就成功了（一般不太可能，出问题见下</p><p>我的操作：</p><h1 id="编译geth"><a href="#编译geth" class="headerlink" title="编译geth"></a>编译geth</h1><h3 id="1-克隆自定义的-Go-Ethereum-源代码"><a href="#1-克隆自定义的-Go-Ethereum-源代码" class="headerlink" title="1. 克隆自定义的 Go Ethereum 源代码"></a>1. 克隆自定义的 Go Ethereum 源代码</h3><p>克隆自定义的 Go Ethereum 源代码仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/go-ethereum.git<br></code></pre></td></tr></table></figure><h3 id="2-安装-Geth-或所有-Go-Ethereum-工具"><a href="#2-安装-Geth-或所有-Go-Ethereum-工具" class="headerlink" title="2. 安装 Geth 或所有 Go Ethereum 工具"></a>2. 安装 Geth 或所有 Go Ethereum 工具</h3><p>进入克隆的 <code>go-ethereum</code> 目录，并编译 <code>geth</code> 或所有工具。</p><h4 id="安装-Go-1-20（版本好像会影响编译，翻了下issue，我当时用的1-20"><a href="#安装-Go-1-20（版本好像会影响编译，翻了下issue，我当时用的1-20" class="headerlink" title="安装 Go 1.20（版本好像会影响编译，翻了下issue，我当时用的1.20"></a>安装 Go 1.20（版本好像会影响编译，翻了下issue，我当时用的1.20</h4><p>确保你已经安装了 Go 1.20 或更高版本。如果没有，请按照以下步骤安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载 Go 1.20</span><br>wget https://mirrors.aliyun.com/golang/go1.20.6.linux-amd64.tar.gz<br><br><span class="hljs-comment"># 解压并安装</span><br><span class="hljs-built_in">sudo</span> tar -C /usr/local -xzf go1.20.6.linux-amd64.tar.gz<br><br><span class="hljs-comment"># 设置环境变量</span><br>nano ~/.bashrc<br><span class="hljs-comment"># 或者</span><br>nano ~/.zshrc<br><br><span class="hljs-comment"># 添加以下内容</span><br><span class="hljs-built_in">export</span> GOROOT=/usr/local/go<br><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-variable">$HOME</span>/go<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$PATH</span><br><br><span class="hljs-comment"># 使配置生效</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><span class="hljs-comment"># 或者</span><br><span class="hljs-built_in">source</span> ~/.zshrc<br><br><span class="hljs-comment"># 验证 Go 版本</span><br>go version<br></code></pre></td></tr></table></figure><h4 id="编译-geth-或所有工具"><a href="#编译-geth-或所有工具" class="headerlink" title="编译 geth 或所有工具"></a>编译 <code>geth</code> 或所有工具</h4><p>进入 <code>go-ethereum</code> 目录并编译 <code>geth</code> 或所有工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> go-ethereum<br><br><span class="hljs-comment"># 清理 Go 模块缓存</span><br>go clean -modcache<br><br><span class="hljs-comment"># 更新 Go 模块</span><br>go mod tidy<br><br><span class="hljs-comment"># 编译 geth</span><br>make geth<br><br><span class="hljs-comment"># 如果你想编译所有工具</span><br>make all<br></code></pre></td></tr></table></figure><p><strong>如果没猜错的话国内网络环境go下载依赖会卡住</strong><br class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2eff34334.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2eff34334.png" alt="pic"><br>卡在这里</p><p>我看的教程</p><h4 id="解决-go-get-golang-org-x-包失败"><a href="#解决-go-get-golang-org-x-包失败" class="headerlink" title="解决 go get golang.org&#x2F;x 包失败"></a><a href="https://www.cnblogs.com/shockerli/p/go-get-golang-org-x-solution.html" title="发布于 2019-02-24 17:24">解决 go get golang.org&#x2F;x 包失败</a></h4><blockquote><p><strong>GOPROXY</strong><br>我们知道从 <code>Go 1.11</code> 版本开始，官方支持了 <code>go module</code> 包依赖管理工具。<br>其实还新增了 <code>GOPROXY</code> 环境变量。如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。这无疑对我等无法科学上网的开发良民来说是最大的福音。<br>更可喜的是，<a href="https://github.com/goproxyio/goproxy">goproxy.io</a> 这个开源项目帮我们实现好了我们想要的。该项目允许开发者一键构建自己的 <code>GOPROXY</code> 代理服务。同时，也提供了公用的代理服务 <code>https://goproxy.io</code>，我们只需设置该环境变量即可正常下载被墙的源码包了：</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> GOPROXY=https://goproxy.io<br></code></pre></td></tr></table></figure><p>也可以通过置空这个环境变量来关闭，<code>export GOPROXY=</code>。</p><p>对于 Windows 用户，可以在 <code>PowerShell</code> 中设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-variable">$env</span>:GOPROXY = <span class="hljs-string">&quot;https://goproxy.io&quot;</span><br></code></pre></td></tr></table></figure><p>我这边这样做能正常下载</p><h3 id="3-运行-Geth"><a href="#3-运行-Geth" class="headerlink" title="3. 运行 Geth"></a>3. 运行 Geth</h3><p>编译完成后，你可以运行 <code>geth</code>。确保 <code>geth</code> 可执行文件在你的 <code>PATH</code> 中，或者直接在 <code>go-ethereum/build/bin</code> 目录下运行它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果 geth 在 PATH 中</span><br>geth<br><br><span class="hljs-comment"># 如果 geth 不在 PATH 中</span><br>./build/bin/geth<br></code></pre></td></tr></table></figure><p>成功安装并运行自定义的 Go Ethereum 客户端</p><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fcb1430b.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fcb1430b.png" alt="pic"></p><hr><h2 id="最后的截图"><a href="#最后的截图" class="headerlink" title="最后的截图"></a>最后的截图</h2><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fcce60fb.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fcce60fb.png" alt="pic"></p><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/10/14/670d2fcea959a.png'><img src="https://free-img.400040.xyz/4/2024/10/14/670d2fcea959a.png" alt="pic"></p><p>g)</p>]]></content>
    
    
    <summary type="html">此文件为历史版本，仅参考用</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>日志2024.9.25（待解决）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/13872.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/13872.html</id>
    <published>2024-09-25T16:49:26.000Z</published>
    <updated>2025-04-03T06:22:53.770Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="在解析rlpx时出现lua错误"><a href="#在解析rlpx时出现lua错误" class="headerlink" title="在解析rlpx时出现lua错误"></a>在解析rlpx时出现lua错误</h2><p>在帧列表中，有一个帧（编号 1561）出现了 Lua 错误。具体来说，错误信息是：“Lua Error: &#x2F;root&#x2F;local&#x2F;lib&#x2F;wireshark&#x2F;plugins&#x2F;rlpx.lua:97: attempt to index local ‘dec_msg’ (a nil value)”。在解码器脚本 <code>rlpx.lua</code> 的第 97 行尝试访问一个名为 <code>dec_msg</code> 的局部变量，但它是一个空值（nil），导致解码器无法成功解析数据包</p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-21289281388f179624bb09ba37c1cb60_720w.webp'><img src="https://pic1.zhimg.com/80/v2-21289281388f179624bb09ba37c1cb60_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-c9e81041466be372649c07a423f7f737_720w.webp'><img src="https://pic4.zhimg.com/80/v2-c9e81041466be372649c07a423f7f737_720w.webp" alt="img"></p><p>rlpx.lua代码如下，lua版本为Lua 5.4.7 ：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> python = <span class="hljs-built_in">require</span> <span class="hljs-string">&#x27;python&#x27;</span><br><br><span class="hljs-comment">-- Temporary for development</span><br><span class="hljs-comment">-- local sys = python.import &#x27;sys&#x27;</span><br><span class="hljs-comment">-- sys.path.append(&#x27;/home/jkemp/cs700/pydevp2p/&#x27;)</span><br><span class="hljs-comment">-- End of Temporary for development</span><br><br><span class="hljs-keyword">local</span> rlpxBridge = python.import <span class="hljs-string">&#x27;pydevp2p.bridge&#x27;</span><br><br><span class="hljs-comment">-- create a new dissector</span><br><span class="hljs-keyword">local</span> NAME = <span class="hljs-string">&quot;rlpx&quot;</span><br><span class="hljs-keyword">local</span> PORT = <span class="hljs-number">30305</span><br><span class="hljs-keyword">local</span> rlpx = Proto(NAME, <span class="hljs-string">&quot;Ethereum RLPx Protocol&quot;</span>)<br><br><span class="hljs-keyword">local</span> fields = rlpx.fields<br>fields.auth_size = ProtoField.uint16(NAME .. <span class="hljs-string">&quot;.auth_size&quot;</span>, <span class="hljs-string">&quot;Auth Size&quot;</span>)<br>fields.ack_size = ProtoField.uint16(NAME .. <span class="hljs-string">&quot;.ack_size&quot;</span>, <span class="hljs-string">&quot;Ack Size&quot;</span>)<br>fields.body = ProtoField.bytes(NAME .. <span class="hljs-string">&quot;.body&quot;</span>, <span class="hljs-string">&quot;Data&quot;</span>)<br>fields.frame_header = ProtoField.bytes(NAME .. <span class="hljs-string">&quot;.frame_header&quot;</span>, <span class="hljs-string">&quot;Frame Header&quot;</span>)<br>fields.frame_body = ProtoField.bytes(NAME .. <span class="hljs-string">&quot;.frame_body&quot;</span>, <span class="hljs-string">&quot;Frame Body&quot;</span>)<br><br><span class="hljs-keyword">local</span> known_ports = &#123; <span class="hljs-number">30303</span>, <span class="hljs-number">30304</span>, <span class="hljs-number">30305</span>, <span class="hljs-number">30306</span>, <span class="hljs-number">30307</span>, <span class="hljs-number">30308</span> &#125;<br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">table_has_value</span><span class="hljs-params">(tab, val)</span></span><br>    <span class="hljs-keyword">for</span> _, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(tab) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> value == val <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">array_iterator</span><span class="hljs-params">(array, len)</span></span><br>    <span class="hljs-comment">-- This lets us iterate over a c object (like a python array)</span><br>    <span class="hljs-keyword">local</span> index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">local</span> count = <span class="hljs-built_in">len</span><br><br>    <span class="hljs-comment">-- The closure function is returned</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        index = index + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> index &lt;= count<br>        <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- return the current element of the iterator</span><br>            <span class="hljs-keyword">return</span> array[index]<br>        <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- main dissect packet function</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rlpx.dissector</span><span class="hljs-params">(tvb, pinfo, tree)</span></span><br>    <span class="hljs-keyword">local</span> subtree = tree:add(rlpx, tvb())<br>    <span class="hljs-keyword">local</span> offset = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">-- show protocol name in protocol column</span><br>    pinfo.cols.protocol = rlpx.name<br><br>    <span class="hljs-keyword">local</span> srcaddr = <span class="hljs-built_in">tostring</span>(pinfo.src)<br>    <span class="hljs-keyword">local</span> dstaddr = <span class="hljs-built_in">tostring</span>(pinfo.dst)<br><br>    <span class="hljs-keyword">local</span> payload = <span class="hljs-built_in">tostring</span>(tvb:bytes())<br><br>    <span class="hljs-comment">-- dissect field one by one, and add to protocol tree</span><br>    <span class="hljs-keyword">local</span> auth_size = tvb(offset, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> (tvb:<span class="hljs-built_in">len</span>() - auth_size:int() == <span class="hljs-number">2</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> (table_has_value(known_ports, pinfo.src_port)) <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- This is most likely a handshake AUTH-ACK packet</span><br>            offset = offset + <span class="hljs-number">2</span><br>            subtree:add(fields.ack_size, auth_size)<br>            pinfo.cols.info:set(pinfo.src_port .. <span class="hljs-string">&quot; → &quot;</span> .. pinfo.dst_port .. <span class="hljs-string">&quot; [HANDSHAKE] AUTH ACK&quot;</span>)<br>            <span class="hljs-comment">-- print(payload, dstNode)</span><br>            <span class="hljs-keyword">local</span> dec_msg = rlpxBridge.handleRLPxHandshakeMsg(srcaddr, dstaddr, payload, pinfo.visited, pinfo.number)<br>            <span class="hljs-keyword">local</span> payloadtree = subtree:add(fields.body, tvb(offset))<br>            payloadtree:set_text(<span class="hljs-string">&quot;Handshake AUTH ACK&quot;</span>)<br>            <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> array_iterator(dec_msg, dec_msg[<span class="hljs-number">0</span>]) <span class="hljs-keyword">do</span><br>                payloadtree:add(element)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">elseif</span> (table_has_value(known_ports, pinfo.dst_port)) <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- This is most likely a handshake AUTH packet</span><br>            offset = offset + <span class="hljs-number">2</span><br>            subtree:add(fields.auth_size, auth_size)<br>            pinfo.cols.info:set(pinfo.src_port .. <span class="hljs-string">&quot; → &quot;</span> .. pinfo.dst_port .. <span class="hljs-string">&quot; [HANDSHAKE] AUTH INIT&quot;</span>)<br>            <span class="hljs-comment">-- print(payload, dstNode)</span><br>            <span class="hljs-keyword">local</span> dec_msg = rlpxBridge.handleRLPxHandshakeMsg(srcaddr, dstaddr, payload, pinfo.visited, pinfo.number)<br>            <span class="hljs-keyword">local</span> payloadtree = subtree:add(fields.body, tvb(offset))<br>            <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> array_iterator(dec_msg, dec_msg[<span class="hljs-number">0</span>]) <span class="hljs-keyword">do</span><br>                payloadtree:add(element)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span><br>            subtree:add(fields.body, tvb(offset))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">local</span> dec_msg = rlpxBridge.handleRLPxMsg(srcaddr, dstaddr, payload, pinfo.visited, pinfo.number)<br>        <span class="hljs-keyword">local</span> frame_header = dec_msg[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">local</span> frame_body = dec_msg[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">local</span> frame_type = dec_msg[<span class="hljs-number">2</span>]<br>        <span class="hljs-comment">-- Set the column information to the Frame Type</span><br>        <span class="hljs-keyword">if</span> frame_type ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>            pinfo.cols.info:set(pinfo.src_port .. <span class="hljs-string">&quot; → &quot;</span> .. pinfo.dst_port .. <span class="hljs-string">&quot; &quot;</span> .. frame_type)<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-comment">-- Show the frame header information (if available) in Wireshark</span><br>        <span class="hljs-keyword">if</span> frame_header ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> frame_header_tree = subtree:add(fields.frame_header, tvb(<span class="hljs-number">0</span>, frame_header.headerSize))<br>            frame_header_tree:add(<span class="hljs-string">&quot;Decrypted Header Data:&quot;</span>, frame_header.header)<br>            frame_header_tree:add(<span class="hljs-string">&quot;Header MAC:&quot;</span>, frame_header.headerMac)<br>            frame_header_tree:add(<span class="hljs-string">&quot;Frame Body MAC:&quot;</span>, frame_header.frameMac)<br>            frame_header_tree:add(<span class="hljs-string">&quot;Frame Size:&quot;</span>, frame_header.frameSize)<br>            frame_header_tree:add(<span class="hljs-string">&quot;Read Size:&quot;</span>, frame_header.readSize)<br>            frame_header_tree:add(<span class="hljs-string">&quot;Header Data:&quot;</span>, frame_header.headerData)<br>            pinfo.cols.info:append(<span class="hljs-string">&quot; Len=&quot;</span> .. frame_header.readSize)<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-comment">-- Show the frame body information (if available) in Wireshark</span><br>        <span class="hljs-keyword">if</span> frame_header ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">and</span> frame_type ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">and</span> frame_body ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">and</span> frame_body[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> frame_body_tree = subtree:add(fields.frame_body, tvb(frame_header.headerSize))<br>            <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> array_iterator(frame_body, frame_body[<span class="hljs-number">0</span>]) <span class="hljs-keyword">do</span><br>                frame_body_tree:add(element)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- register this dissector</span><br>DissectorTable.get(<span class="hljs-string">&quot;tcp.port&quot;</span>):add(PORT, rlpx)<br>DissectorTable.get(<span class="hljs-string">&quot;tcp.port&quot;</span>):add(<span class="hljs-string">&quot;30303&quot;</span>, rlpx)<br>DissectorTable.get(<span class="hljs-string">&quot;tcp.port&quot;</span>):add(<span class="hljs-string">&quot;30304&quot;</span>, rlpx)<br>DissectorTable.get(<span class="hljs-string">&quot;tcp.port&quot;</span>):add(<span class="hljs-string">&quot;30305&quot;</span>, rlpx)<br>DissectorTable.get(<span class="hljs-string">&quot;tcp.port&quot;</span>):add(<span class="hljs-string">&quot;30306&quot;</span>, rlpx)<br>DissectorTable.get(<span class="hljs-string">&quot;tcp.port&quot;</span>):add(<span class="hljs-string">&quot;30307&quot;</span>, rlpx)<br>DissectorTable.get(<span class="hljs-string">&quot;tcp.port&quot;</span>):add(<span class="hljs-string">&quot;30308&quot;</span>, rlpx)<br><br></code></pre></td></tr></table></figure><p>不知道怎么改，不懂lua</p><p>可能是lua版本问题，改天看下文档</p><p class='item-img' data-src='https://pic4.zhimg.com/80/v2-c9e81041466be372649c07a423f7f737_720w.webp'><img src="https://pic4.zhimg.com/80/v2-c9e81041466be372649c07a423f7f737_720w.webp" alt="img"></p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-e8cfe5272808d7d34394ac62edb904f0_720w.webp'><img src="https://pica.zhimg.com/80/v2-e8cfe5272808d7d34394ac62edb904f0_720w.webp" alt="img"></p><p class='item-img' data-src='https://pic1.zhimg.com/80/v2-21289281388f179624bb09ba37c1cb60_720w.webp'><img src="https://pic1.zhimg.com/80/v2-21289281388f179624bb09ba37c1cb60_720w.webp" alt="img"><br>.webp)</p>]]></content>
    
    
    <summary type="html">项目复现日志(lua错误)</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>创建一个针对Ethereum网络的协议解包器</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/57783.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/57783.html</id>
    <published>2024-09-25T16:13:00.000Z</published>
    <updated>2025-04-03T06:22:53.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Enabling-security-analysis-and-education-of-the-Ethereum-platform"><a href="#Enabling-security-analysis-and-education-of-the-Ethereum-platform" class="headerlink" title="Enabling security analysis and education of the Ethereum platform"></a><strong>Enabling security analysis and education of the Ethereum platform</strong></h2><p>本篇论文旨在探讨如何通过创建一个Wireshark网络包解码器来分析和教育以太坊平台的安全性。使用了定制化的私人以太坊Docker网络来促进Go Ethereum执行客户端之间的通信，并使Wireshark解码器能够捕获实时网络数据。最后，作者还使用了解码器来比较DiscoveryV4和DiscoveryV5的区别，并跟踪RLPx协议中的交易在网络上的传输过程。本文的研究方法包括创建Wireshark解码器、使用定制化的私人以太坊Docker网络以及对比不同版本的DiscoveryV4和DiscoveryV5协议。最终结果表明，该解码器可以有效地帮助人们理解和分析以太坊平台的安全性和网络流量。 </p><h3 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h3><p>该论文提出了一种新的网络包解码器（dissector），用于分析以太坊DEVP2P协议套件中的数据包。该解码器能够解析UDP基的DiscoveryV4、DiscoveryV5以及RLPx协议，并支持其子协议ETH和SNAP的消息能力。这个解码器使用Wireshark作为平台来实现，通过拦截网络流量并提供实时视图，可以识别协议、解码数据、跟踪流和对话、计算统计信息等。</p><h3 id="方法改进"><a href="#方法改进" class="headerlink" title="方法改进"></a>方法改进</h3><p>传统的网络包解码器通常用于调试、协议分析、安全性和可扩展性分析以及教育目的。目前有两种已知的以太坊DEVP2P协议解码器：一个是基于Wireshark插件引擎使用LUA编程语言构建的；另一个是使用C编程语言编译Wireshark源代码而构建的。然而，这两种解码器都存在一些限制，只支持加密发现V4，而不支持在EIP-868中于2019年10月发布的新型数据包类型。此外，它们也不支持DiscoveryV5和RLPx及其任何子协议，如ETH和SNAP。</p><p>这两个项目都已经被放弃，原因是复杂度高，需要社区完成这项工作。由于RLPx的数据包解码过程比较复杂，因为TCP连接是使用ECIES（椭圆曲线集成加密方案）加密的，因此需要私钥才能解密通信。私钥因素包括我们的私钥、节点的公钥以及一个随机生成的临时密钥。</p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>该解码器解决了现有的解码器无法处理新型数据包类型的问题，同时也填补了DiscoveryV5和RLPx及其子协议的安全性和性能分析方面的空白。此外，该解码器还可以帮助证明其价值，为社区和教育者提供更深入的分析，包括安全性和性能差异的比较，以及交易和块传播等方面的研究。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="论文实验"><a href="#论文实验" class="headerlink" title="论文实验"></a>论文实验</h3><p>本文介绍了作者使用Wireshark创建一个针对Ethereum网络的协议解包器，并对不同协议进行了分析和展示。在实验中，作者构建了一个私有开发网络，并通过MetaMask连接了该网络上的账户，演示了如何在两个节点之间进行交易。以下是每个实验的详细介绍：</p><ol><li><p>实验目的：创建Wireshark解包器并分析不同协议</p><p>在这个实验中，作者的主要目的是创建一个Wireshark解包器来解析Ethereum网络中的不同协议。这包括DiscoveryV4、DiscoveryV5和RLPx协议以及它们的子协议ETH和SNAP。作者还创建了一个名为PYDEVP2P的Python库作为后台支持，提供大部分解码、解密和数据布局工具，以帮助Wireshark显示数据包信息。</p></li><li><p>实验步骤：构建私有开发网络并进行交易</p><p>在这个实验中，作者构建了一个私有开发网络，其中包括一个Bootnode和三个节点。每个节点都运行在一个Docker容器中，并且使用GETH客户端。作者使用MetaMask连接到该网络，并从不同的账户向另一个账户发送了200个ETH。整个过程被记录下来并在后续章节中进行分析。</p></li><li><p>实验结果：性能和安全性的分析</p><p>在这个实验中，作者分析了DiscoveryV4和DiscoveryV5协议的性能和安全性，并比较了它们与RLPx协议的不同之处。此外，作者还对实际交易进行了详细的分析，以了解在网络层面上发生了什么。</p></li></ol><p>总的来说，本文旨在展示如何使用Wireshark创建一个用于Ethereum网络的协议解包器，并展示了如何在私有开发网络上进行交易。作者还对不同协议的性能和安全性进行了分析，以便更好地理解Ethereum网络的工作原理。</p><p class='item-img' data-src='https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1286829898522558464/1286829898522558464_cut_Table_1.png'><img src="https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1286829898522558464/1286829898522558464_cut_Table_1.png" alt="table_1"></p><p class='item-img' data-src='https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1286829898522558464/1286829898522558464_cut_Table_2.png'><img src="https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1286829898522558464/1286829898522558464_cut_Table_2.png" alt="table_2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该论文主要介绍了以太坊网络及其相关协议，并通过两个现有分解器的比较，探讨了如何使用分解器来解析网络数据包以及理解底层协议。该论文的优点包括：</p><ul><li>全面深入地介绍了以太坊网络及协议，包括公共和私人网络、节点类型、网络协议等。</li><li>提供了两种现有的分解器的比较，帮助读者了解它们之间的差异和优缺点。</li><li>论文作者在介绍过程中提供了大量的代码示例和详细的解释，使读者更容易理解和应用所学知识。</li></ul><h3 id="方法创新点"><a href="#方法创新点" class="headerlink" title="方法创新点"></a>方法创新点</h3><p>该论文的方法创新点在于，通过对已有分解器的比较，提出了一些改进和完善的想法，例如可以将ENRRequest和ENRResponse添加到C dissector中，以便更好地支持新版本的DiscoveryV4协议。此外，该论文还提出了一个基于用户界面的演示应用程序，可以帮助用户更直观地观察和理解以太坊网络中的数据传输过程。</p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><p>随着以太坊网络的发展和技术的进步，未来的展望包括：</p><ul><li>进一步完善已有的分解器，使其能够更好地支持新的协议和功能。</li><li>开发更加高效和智能的分解器，能够自动识别和解析更多的数据包类型和协议。</li><li>利用机器学习和人工智能技术，实现对以太坊网络数据的自动化分析和预测，为用户提供更好的服务和支持。</li></ul><hr><h1 id="附1：实现方式"><a href="#附1：实现方式" class="headerlink" title="附1：实现方式"></a>附1：实现方式</h1><h3 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h3><p>该项目通过构建一个自定义的 Docker 网络环境来模拟以太坊节点之间的通信，并使用 Wireshark 和自定义的 Lua 解析器插件来捕获和分析这些通信。具体来说，它包括以下组件：</p><ul><li><strong>Go-Ethereum (Geth) 定制源代码</strong>：用于暴露私有会话密钥。</li><li><strong>Docker 环境</strong>：包含多个 Geth 节点和一个路由器容器，用于模拟小型私有以太坊网络。</li><li><strong>Lua 解析器插件</strong>：用于在 Wireshark 中解剖 DEVP2P 协议的数据包。</li><li><strong>PYDEVP2P 库</strong>：用于 Python 和 Lua 之间的交互。</li></ul><h3 id="操作与实现步骤"><a href="#操作与实现步骤" class="headerlink" title="操作与实现步骤"></a>操作与实现步骤</h3><h4 id="1-环境设置"><a href="#1-环境设置" class="headerlink" title="1. 环境设置"></a>1. 环境设置</h4><p>确保安装了必要的软件和库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update &amp;&amp; <span class="hljs-built_in">sudo</span> apt-get upgrade<br><span class="hljs-built_in">sudo</span> apt-get install lua5.2 liblua5.2-dev wireshark python3.10<br></code></pre></td></tr></table></figure><h4 id="2-设置-Lunatic-Python-桥接"><a href="#2-设置-Lunatic-Python-桥接" class="headerlink" title="2. 设置 Lunatic-Python 桥接"></a>2. 设置 Lunatic-Python 桥接</h4><p>Lunatic-Python 是一个双向桥接库，允许 Lua 和 Python 之间的交互。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆 Lunatic-Python 仓库</span><br>git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/lunatic-python.git<br><span class="hljs-built_in">cd</span> lunatic-python<br><br><span class="hljs-comment"># 确保 Lua 5.3 已安装</span><br>lua5.3<br><br><span class="hljs-comment"># 查找 Python 版本</span><br>ldconfig -p | grep python<br><br><span class="hljs-comment"># 准备构建</span><br>cmake -B./build -H. -DPYTHON_INCLUDE_DIR=/usr/include/python3.10 \<br>  -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.10.so<br><br><span class="hljs-comment"># 构建</span><br>cmake --build ./build<br><br><span class="hljs-comment"># 复制生成的库文件到 Lua 目录</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x build/bin/python.so<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> build/bin/python.so /usr/local/lib/lua/5.2/<br></code></pre></td></tr></table></figure><h4 id="3-克隆并安装-LUA-Dissector-和-PYDEVP2P"><a href="#3-克隆并安装-LUA-Dissector-和-PYDEVP2P" class="headerlink" title="3. 克隆并安装 LUA Dissector 和 PYDEVP2P"></a>3. 克隆并安装 LUA Dissector 和 PYDEVP2P</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆 LUA Dissector 和 PYDEVP2P</span><br>git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/lua-devp2p-wireshark-dissector.git<br>git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/pydevp2p.git<br><br><span class="hljs-comment"># 安装 PYDEVP2P PIP 包</span><br><span class="hljs-built_in">cd</span> pydevp2p<br>pip install -e .<br><span class="hljs-built_in">sudo</span> pip install -e .<br><br><span class="hljs-comment"># 创建 Wireshark 插件目录（如果不存在）</span><br><span class="hljs-built_in">mkdir</span> -p ~/.local/lib/wireshark/plugins<br><br><span class="hljs-comment"># 符号链接或复制 .lua 解析器文件（也可以直接复制到该目录</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s &lt;location_of_cloned_dissector&gt;/rlpx.lua ~/.local/lib/wireshark/plugins/rlpx.lua<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s &lt;location_of_cloned_dissector&gt;/discovery.lua ~/.local/lib/wireshark/plugins/discovery.lua<br><br><span class="hljs-comment"># 对于 root 用户（如果使用 sudo 运行 Wireshark）（也可以直接复制到该目录</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /usr/local/lib/wireshark/plugins<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s &lt;location_of_cloned_dissector克隆的地址&gt;/rlpx.lua /usr/local/lib/wireshark/plugins/rlpx.lua<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s &lt;location_of_cloned_dissector克隆的地址&gt;/discovery.lua /usr/local/lib/wireshark/plugins/discovery.lua<br></code></pre></td></tr></table></figure><ul><li><p><strong>使用本地 <code>.pcapng</code> 文件测试</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wireshark-r final.pcapng<br></code></pre></td></tr></table></figure><p>这将运行 Wireshark 并加载捕获的 <code>.pcapng</code> 文件。您可以查看解剖后的 DEVP2P 数据包。</p></li><li><p><strong>实时捕获网络流量</strong>：</p><ul><li>启动 Wireshark 并选择适当的接口捕获数据包。</li><li>观察和分析捕获的数据包，特别是 RLPx 握手和 DiscoveryV5 数据包。</li><li></li></ul></li></ul><h4 id="4-构建-Docker-环境"><a href="#4-构建-Docker-环境" class="headerlink" title="4. 构建 Docker 环境"></a>4. 构建 Docker 环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆 GETH-Docker 仓库</span><br>git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/geth-docker.git<br><span class="hljs-built_in">cd</span> geth-docker<br><br><span class="hljs-comment"># 构建自定义 Docker 镜像</span><br>./build-dockers.sh<br><br><span class="hljs-comment"># 启动路由器容器</span><br>docker-compose up -d bridge-router<br><br><span class="hljs-comment"># 打开 Wireshark 并附加到 10.1.0.1 或任何 10.1.X.X 网络</span><br><span class="hljs-built_in">sudo</span> wireshark<br><br><span class="hljs-comment"># 启动每个 GETH 节点/客户端容器</span><br>docker-compose up -d geth-ubuntu-bootnode<br>docker-compose up -d geth-client-1<br>docker-compose up -d geth-client-2<br>docker-compose up -d geth-client-3<br></code></pre></td></tr></table></figure><h4 id="5-安装编译和运行自定义的-Go-Ethereum-客户端："><a href="#5-安装编译和运行自定义的-Go-Ethereum-客户端：" class="headerlink" title="5.安装编译和运行自定义的 Go Ethereum 客户端："></a>5.安装编译和运行自定义的 Go Ethereum 客户端：</h4><h5 id="1-克隆自定义的-Go-Ethereum-源代码"><a href="#1-克隆自定义的-Go-Ethereum-源代码" class="headerlink" title="1. 克隆自定义的 Go Ethereum 源代码"></a>1. 克隆自定义的 Go Ethereum 源代码</h5><p>首先，你需要克隆自定义的 Go Ethereum 源代码仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jmkemp20/go-ethereum.git<br></code></pre></td></tr></table></figure><h5 id="2-安装-Geth-或所有-Go-Ethereum-工具"><a href="#2-安装-Geth-或所有-Go-Ethereum-工具" class="headerlink" title="2. 安装 Geth 或所有 Go Ethereum 工具"></a>2. 安装 Geth 或所有 Go Ethereum 工具</h5><p>进入克隆的 <code>go-ethereum</code> 目录，并编译 <code>geth</code> 或所有工具。</p><h5 id="安装-Go-1-20"><a href="#安装-Go-1-20" class="headerlink" title="安装 Go 1.20"></a>安装 Go 1.20</h5><p>确保你已经安装了 Go 1.20 或更高版本。如果没有，请按照以下步骤安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载 Go 1.20</span><br>wget https://mirrors.aliyun.com/golang/go1.20.6.linux-amd64.tar.gz<br><br><span class="hljs-comment"># 解压并安装</span><br><span class="hljs-built_in">sudo</span> tar -C /usr/local -xzf go1.20.6.linux-amd64.tar.gz<br><br><span class="hljs-comment"># 设置环境变量</span><br>nano ~/.bashrc<br><span class="hljs-comment"># 或者</span><br>nano ~/.zshrc<br><br><span class="hljs-comment"># 添加以下内容</span><br><span class="hljs-built_in">export</span> GOROOT=/usr/local/go<br><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-variable">$HOME</span>/go<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$PATH</span><br><br><span class="hljs-comment"># 使配置生效</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><span class="hljs-comment"># 或者</span><br><span class="hljs-built_in">source</span> ~/.zshrc<br><br><span class="hljs-comment"># 验证 Go 版本</span><br>go version<br></code></pre></td></tr></table></figure><h5 id="编译-geth-或所有工具"><a href="#编译-geth-或所有工具" class="headerlink" title="编译 geth 或所有工具"></a>编译 <code>geth</code> 或所有工具</h5><p>进入 <code>go-ethereum</code> 目录并编译 <code>geth</code> 或所有工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> go-ethereum<br><br><span class="hljs-comment"># 清理 Go 模块缓存</span><br>go clean -modcache<br><br><span class="hljs-comment"># 更新 Go 模块</span><br>go mod tidy<br><br><span class="hljs-comment"># 编译 geth</span><br>make geth<br><br><span class="hljs-comment"># 如果你想编译所有工具</span><br>make all<br></code></pre></td></tr></table></figure><h5 id="3-运行-Geth"><a href="#3-运行-Geth" class="headerlink" title="3. 运行 Geth"></a>3. 运行 Geth</h5><p>编译完成后，你可以运行 <code>geth</code>。确保 <code>geth</code> 可执行文件在你的 <code>PATH</code> 中，或者直接在 <code>go-ethereum/build/bin</code> 目录下运行它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果 geth 在 PATH 中</span><br>geth<br><br><span class="hljs-comment"># 如果 geth 不在 PATH 中</span><br>./build/bin/geth<br></code></pre></td></tr></table></figure><p>成功安装并运行自定义的 Go Ethereum 客户端</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li><strong>Dockerfile</strong>：用于构建 Docker 镜像的配置文件。</li><li><strong>docker-compose.yml</strong>：用于启动和管理 Docker 容器。</li><li><strong>lua-devp2p-wireshark-dissector</strong>：Lua 解析器插件，用于在 Wireshark 中解剖 DEVP2P 数据包。</li><li><strong>pydevp2p</strong>：Python 库，用于处理以太坊 DEVP2P 协议中的 ECIES 和其他加密操作。</li><li><strong>lunatic-python</strong>：Lua 和 Python 之间的桥接库。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，设置并运行一个自定义的 Docker 环境来模拟以太坊节点之间的通信，并使用 Wireshark 和自定义的 Lua 解析器插件来捕获和分析这些通信。有助于进行安全分析和教育，深入理解以太坊网络的工作原理。</p><h1 id="附2：原文翻译（结论篇）"><a href="#附2：原文翻译（结论篇）" class="headerlink" title="附2：原文翻译（结论篇）"></a>附2：原文翻译（结论篇）</h1><h3 id="6-1-引言和回顾"><a href="#6-1-引言和回顾" class="headerlink" title="6.1 引言和回顾"></a>6.1 引言和回顾</h3><p>本论文提出了一种为以太坊的 DEVP2P 点对点协议套件创建 Wireshark 剖析器的新方法，包括带有 ETH 和 SNAP 子协议的 DiscoveryV4、DiscoveryV5 和 RLPx。正如我们所讨论的，以太坊网络促进了以太坊网络节点之间的相互通信，为去中心化的应用程序和账户提供了便利。因此，为了满足创建支持 RLP 解码和 ECIES 解密的 Wireshark 剖析器插件的要求，涵盖了许多贡献。首先，讨论了利用自定义的 Go Ethereum 源创建一个私有的 Ethereum docker 网络。接下来，介绍了 LUA Wireshark 插件的实际实现;首先是支持 DEVP2P 发现协议的 “discovery.lua” 插件，然后是 “rlpx.lua”，它允许剖析 RLPx，包括 ETH 和 SNAP 子协议。然后，我们深入研究了 PYDEVP2P，这是一个基于 python 的最小第三方依赖库，为 RLP 解码、ECIES 解密和解剖辅助函数提供了工具。最后，利用剖析器和PYDEVP2P分析了椭圆曲线数字签名算法 （ECDSA） 椭圆曲线 Diffie-Hellman 背后的技术细节。</p><p>Wireshark 是一种广泛使用的网络分析工具，允许用户检查和解码网络数据包。但是，Wireshark 本身不支持以太坊的 DEVP2P 协议，这限制了研究人员和开发人员监控和理解以太坊节点行为的能力。最重要的是，Wireshark 支持使用解剖插件，这些插件是 Wireshark 解剖功能的插件。正如我们所讨论的，当前由 BCSEC Org 和 ConsenSys 提供的两个剖析器插件并不完全支持 DiscoveryV4 的最新消息结构，并且对 DiscoveryV5 和 RLPx 的支持为零。为了解决这一差距，本论文在 LUA 中开发了一个自定义 Wireshark 剖析器插件，该插件可以以用户友好的格式解析和显示 DEVP2P 数据包。该插件利用 PYDEVP2P，这是一个基于 python 的库，用于协助解码 RLP（递归长度前缀）和解密 DEVP2P 协议使用的 ECIES（椭圆曲线集成加密方案）。</p><p>此外，本论文还创建了一个具有自定义 Go Ethereum 映像的私有 docker 网络，该网络可生成真实的 DEVP2P 流量，用于开发、测试和分析目的。使用这个剖析器插件和环境，本论文演示了 Wireshark 剖析器如何分析 DEVP2P 数据包流的各个方面，例如跟踪交易在整个网络中的传播、分析 DiscoveryV4 椭圆曲线数字签名算法 （ECDSA） 和 DiscoveryV5 对椭圆曲线 Diffie-Hellman （ECDH） 的使用。本论文为研究以太坊的点对点通信层和增强去中心化应用程序的透明度和安全性提供了实用工具，为区块链研究领域、以太坊社区成员和教育工作者做出了贡献。</p><h4 id="6-2-解剖和分析结果"><a href="#6-2-解剖和分析结果" class="headerlink" title="6.2 解剖和分析结果"></a>6.2 解剖和分析结果</h4><p>本论文介绍了 Wireshark 剖析器插件的设计和实现，用于剖析 DEVP2P 的 DiscoveryV4、DiscoveryV5 和 RLPx 协议。剖析器插件可以解码和显示以太坊节点之间交换的各种消息，这些消息要么是实时网络，要么是事后捕获数据包。此外，剖析器插件还支持使用从握手过程中派生的会话密钥来解码 DiscoveryV5 和 RLPx 消息。</p><p>创建剖析器的过程和剖析器的众多功能在第 4 章中展示。具体来说，DEVP2P 剖析器支持在 DiscoveryV4 中找到的所有消息，如第 4.3.1 章所述，包括 Ping、Pong、FindNode、Neighbors、ENRRequest 和 ENRResponse。由于新的“enr-seq”字段，以前的剖析器（包括 BSECORG 的 LUA 剖析器插件和 ConsenSys 的 C 剖析器）无法完全剖析 Ping 和 Pong 消息的较新消息架构。这些以前的剖析器也不支持 EIP-868 中描述的最新 ENRRequest 和 ENRResponse 数据包，这些数据包已于 2019 年 10 月添加到协议中。</p><p>接下来，新的剖析器支持第 4.3.2 章中讨论的 DiscoveryV5 的最新实现，包括 Ping、Pong、FindNode、Nodes、TalkReq 和 TalkResp。以前的剖析器不支持此功能，因为协议的性质会混淆数据包标头信息和 ECDH 握手以交换会话密钥以进行加密通信。但是，这种新的 DEVP2P 剖析器提供了维护在网络上的已知节点之间创建的会话的所有功能，从而无缝解密和破译捕获的网络数据。</p><p>DEVP2P 剖析器插件可以分析和破译 RLPx 促进的以太坊节点之间经过身份验证和加密的通信。这包括使用 AuthInit 和 AuthAck RLPx 消息在节点之间创建会话密钥的握手过程，然后是内置的 RLPx 功能“P2P”Hello 消息，如第 4.4 章所示。剖析器支持其他 RLPx P2P 消息、Ping、Pong 和 Disconnect。由于 RLPx 用作多种功能的 TCP 传输，因此剖析器可以解码、解密和剖析 RLPx 下的两个主要子协议或功能 ETH 和 SNAP。这些协议支持区块传播、链同步和交易，然后是状态管理和 SNAP 同步。剖析器支持 2 条 RLPx 握手消息、4 条 RLPx P2P 消息、13 条 ETH 功能消息和 6 条 SNAP 功能消息。</p><p>关于区块链状态和交易的 Connected Peer 节点。剖析器还可以显示消息格式的详细信息，例如 RLP 编码和解码、数据包标头和尾部以及消息类型和内容。该工具允许轻松访问 DEVP2P 的内部工作原理，并为研究人员、一般区块链社区和类似领域的教育工作者提供帮助。</p><h4 id="6-3-限制与未来工作"><a href="#6-3-限制与未来工作" class="headerlink" title="6.3 限制与未来工作"></a>6.3 限制与未来工作</h4><p>剖析器是对以太坊网络分析的新颖贡献，因为它是第一个在统一且用户友好的界面中剖析所有三种 DEVP2P 协议的工具。剖析器可以帮助研究人员和开发人员了解 Ethereum 网络的行为和性能，并识别和缓解潜在的安全威胁。剖析器还可以通过使椭圆曲线密码学在实际应用中更易于访问来帮助教育工作者，同时帮助开发和测试以太坊网络的新协议或功能，同时提供可靠的</p><p>为未来改进和扩展对现有协议的支持奠定了基础。</p><p>但是，剖析器也有一些局限性和缺点，必须在未来的工作中解决：</p><p>剖析器需要自定义 Go Ethereum 源代码，其中包括每个节点在 RLPx 握手期间生成的随机私钥，用于会话密钥共享和后续数据包的加密。剖析器不支持使用官方 GETH 或 Ethereum 客户端进行 RLPx 剖读。</p><p>剖析需要 Python 配合 PYDEVP2P 使用， 在幕后处理剖析、解码和解密的主要逻辑。这增加了剖析器设置和执行的复杂性和开销，需要安装 Python PIP 包的 PYDEVP2P 以及 LUA 和 Lunatic-Python 桥。</p><p>剖析器存在不完整的消息错误，当某些消息大于特定大小时，会导致它们被截断或跳过。此错误会影响捕获握手数据包或格式错误的数据包时剖分结果的准确性和完整性。</p><p>剖析器不会在 Wireshark 显示屏上以清晰的人类可读格式显示 DiscoveryV5 消息的未屏蔽“authdata”，其中包含节点 ID、签名和临时公钥等基本信息。</p><p>随着以太坊及其底层网络的复杂性不断增长并随着时间的推移而发展，未来工作可能会有一些可能的改进或扩展：</p><p>在权益证明环境中使用剖析器，查看权益证明共识算法网络中的执行客户端中使用了哪些 DEVP2P 协议和消息。看看哪些 DEVP2P RLPx 功能消息被新协议改编或未使用，以进行权益证明，这将是一件有趣的事情。</p><p>剖析 LIBP2P 并将其与 DEVP2P 进行比较。LIBP2P 是以太坊共识客户端使用的另一个点对点网络堆栈。在功能、性能和安全性方面对 LIBP2P 和 DEVP2P 进行比较和对比会很有用。</p><p>添加 LES、PIP、WIP 和其他 RLPx 子协议的剖析。剖析器目前仅支持 ETH 和 SNAP 子协议。这些其他子协议用于不同的目的，例如轻以太坊子协议 （LES） 支持、奇偶校验轻协议 （PIP） 支持和以太坊见证协议 （WIT）。剖析器也应该扩展以支持这些子协议。</p><p>调查网络发现泄漏，这是 DiscoveryV4 中发现的问题。网络发现泄漏是一个问题，即为特定链&#x2F;网络 ID 设置的 Ethereum 节点会错误地通信并发现其他 Ethereum 网络上的节点。</p><p>实施 DiscoveryV4 和 DiscoveryV5 拒绝服务 （DoS） 攻击。DiscoveryV4 协议容易受到拒绝服务 （DoS） 攻击，这些攻击可能会用虚假的 ping 或 pong 消息淹没节点。这些消息会消耗节点的带宽和处理资源，并可能阻止它们响应合法消息。剖析器可以通过捕获网络上的此类恶意数据包来帮助检测和监控此类攻击。</p><p>实施 RLPx 已知明文攻击。RLPx 协议使用 AES-CTR 加密，每条消息使用固定的 IV（初始化向量）。这使得它容易受到已知的明文攻击，如果攻击者知道一些明文-密文对，该攻击可以恢复加密密钥。剖析器可以通过随机化每条消息的 IV 或使用不同的加密方案来帮助避免这种攻击。</p><p>执行 Wireshark 统计分析。Wireshark 提供各种统计网络流量分析工具，例如图形、图表、表格、过滤器等。剖析器可以利用这些工具对 DEVP2P 协议进行更高级和全面的分析，例如吞吐量、延迟、数据包丢失、消息分发、节点行为等。</p><h4 id="6-4-最后的思考"><a href="#6-4-最后的思考" class="headerlink" title="6.4 最后的思考"></a>6.4 最后的思考</h4><p>解剖器的设计、实现及其结果的分析证明了它对社区、教育工作者、开发者和研究者的有用性。LUA Wireshark 解析插件和 PYDEVP2P 库为教育工作者、研究人员及开发者提供了理解以太坊网络内部运作所需的所有工具。该解析器还允许可视化流行的密码学概念，利用椭圆曲线密码学（ECC），同时帮助理解递归长度前缀（RLP）编码的工作方式。在创建此解析器的过程中克服了许多障碍，无论是更新文档还是实现以太坊特有的ECIES技术细节。本文档中穿插的大多数技术细节直接来自以太坊DEVP2P GitHub规范页面以及最常用的执行客户端源代码Go Ethereum。因此，这些方法对于更广泛的以太坊社区成员、分析师尤其是教育者来说并不容易获得。</p><p>本文讨论的贡献使得进入以太坊节点网络通信变得更加容易，并且克服了由大型区块链技术解决方案公司ConsenSys指出的一些障碍。这包括可以使用单个命令启动一个完整的私有以太坊网络的Go Ethereum Docker网络，随后是只需几个简单步骤即可安装的LUA Wireshark插件和PYDEVP2P库。正如所讨论的那样，PYDEVP2P库还提供了易于理解的椭圆曲线加密实现，让教育工作者和学生能够在一个实际环境中亲身体验并理解这些底层概念。</p><p>本文档的主要目标是提供所有必要的工具来支持未来的改进，为教育者提供一种轻松访问的工具来展示ECIES密码技术，同时也为了安全分析师能够进一步增强点对点区块链网络的健壮性。</p><p>。</p>]]></content>
    
    
    <summary type="html">一种新的网络包解码器（dissector），用于分析以太坊DEVP2P协议套件中的数据包。</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
