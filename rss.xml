<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes|笔记站</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2025-12-26T04:42:12.018Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025-12-26-关于Javascript/TypeScript 的顺序表，链表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/46758.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/46758.html</id>
    <published>2025-12-26T04:16:12.000Z</published>
    <updated>2025-12-26T04:42:12.018Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。</p><p>以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并附带说明。</p><h2 id="1-顺序表（基于数组的动态顺序表）"><a href="#1-顺序表（基于数组的动态顺序表）" class="headerlink" title="1. 顺序表（基于数组的动态顺序表）"></a>1. 顺序表（基于数组的动态顺序表）</h2><p>顺序表的核心是连续存储，使用数组实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建顺序表</span><br><span class="hljs-keyword">const</span> seqList = [];<br><br><span class="hljs-comment">// 添加元素</span><br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">10</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// 在索引 1 处插入 15</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">// [10, 15, 20, 30]</span><br><br><span class="hljs-comment">// 修改索引 2 处的元素</span><br>seqList[<span class="hljs-number">2</span>] = <span class="hljs-number">25</span>;           <span class="hljs-comment">// [10, 15, 25, 30]</span><br><br><span class="hljs-comment">// 删除索引 0 处的元素</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">// [15, 25, 30]</span><br><br><span class="hljs-comment">// 输出长度和内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'长度:'</span>, seqList.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内容:'</span>, seqList);         <span class="hljs-comment">// [15, 25, 30]</span><br></code></pre></td></tr></table></figure><p>手动实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity = <span class="hljs-number">10</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity);  <span class="hljs-comment">// 存储元素</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 当前元素个数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;         <span class="hljs-comment">// 当前容量</span><br>    }<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 扩容（当 size === capacity 时）</span><br>    <span class="hljs-title function_">resize</span>(<span class="hljs-params">newCapacity</span>) {<br>        <span class="hljs-keyword">const</span> newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(newCapacity);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            newData[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = newData;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = newCapacity;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 扩容为两倍</span><br>        }<br>        <span class="hljs-comment">// 从后向前移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>; i &gt;= index; i--) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在末尾添加元素</span><br>    <span class="hljs-title function_">append</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 删除索引 index 处的元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">const</span> removed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>        <span class="hljs-comment">// 从前向后移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-comment">// 可选：缩容（避免频繁缩容，通常当 size == capacity / 4 时缩为一半）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">4</span>)) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">2</span>));<br>        }<br>        <span class="hljs-keyword">return</span> removed;<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'SequentialList: ['</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            str += <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>            <span class="hljs-keyword">if</span> (i !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>) str += <span class="hljs-string">', '</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> seqList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequentialList</span>();<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>seqList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>seqList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// SequentialList: [1, 3, 2]</span><br></code></pre></td></tr></table></figure><h2 id="2-链表（单向链表）"><a href="#2-链表（单向链表）" class="headerlink" title="2. 链表（单向链表）"></a>2. 链表（单向链表）</h2><p>链表使用节点分散存储，支持高效的插入和删除（O(1)），但随机访问较慢（O(n)）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();  <span class="hljs-comment">// 虚拟头结点，便于操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(element);<br>        node.<span class="hljs-property">next</span> = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在链表头部添加元素</span><br>    <span class="hljs-title function_">addFirst</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">0</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 在链表末尾添加元素</span><br>    <span class="hljs-title function_">addLast</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        cur.<span class="hljs-property">val</span> = element;<br>    }<br><br>    <span class="hljs-comment">// 删除索引处元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> removedNode = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = removedNode.<span class="hljs-property">next</span>;<br>        removedNode.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-keyword">return</span> removedNode.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'LinkedList: ['</span>;<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            str += cur.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">next</span>) str += <span class="hljs-string">' -&gt; '</span>;<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">1</span>);<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">2</span>);<br>linkedList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>linkedList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// LinkedList: [1 -&gt; 3 -&gt; 2]</span><br></code></pre></td></tr></table></figure><hr><h2 id="LRU-缓存的实现（使用双向链表-HashMap）"><a href="#LRU-缓存的实现（使用双向链表-HashMap）" class="headerlink" title="LRU 缓存的实现（使用双向链表 + HashMap）"></a>LRU 缓存的实现（使用双向链表 + HashMap）</h2><p>LRU（Least Recently Used）缓存是一种常见的数据结构，用于实现固定容量缓存，当容量满时淘汰最近最少使用的元素。在 JavaScript 中，最高效的实现方式是结合<strong>双向链表</strong>（控制访问顺序）和<strong>Map</strong>（或对象）作为哈希表（实现 O(1) 访问）</p><h3 id="JS实现："><a href="#JS实现：" class="headerlink" title="JS实现："></a>JS实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;        <span class="hljs-comment">// 缓存容量</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();          <span class="hljs-comment">// 使用 Map 作为哈希表，保持插入顺序并支持 O(1) 操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟头节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟尾节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;      <span class="hljs-comment">// 初始化链表：head &lt;-&gt; tail</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将节点移动到链表头部（表示最近使用）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">node</span> - 要移动的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_moveToHead</span>(<span class="hljs-params">node</span>) {<br>        <span class="hljs-comment">// 先从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>;<br><br>        <span class="hljs-comment">// 插入到头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从链表尾部移除节点（淘汰最久未使用的）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 被移除的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_removeTail</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>;<br>        lastNode.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any</span>} 值，如果不存在返回 -1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>        }<br>        <span class="hljs-comment">// 刷新访问顺序：将节点移到头部</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            <span class="hljs-comment">// 已存在：更新值并移到头部</span><br>            existingNode.<span class="hljs-property">value</span> = value;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 不存在：创建新节点</span><br>            <span class="hljs-keyword">const</span> newNode = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入到头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 检查容量是否超出</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeTail</span>();  <span class="hljs-comment">// 移除尾部节点</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);      <span class="hljs-comment">// 从哈希表中删除</span><br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 可选：打印当前缓存顺序（用于调试）</span><br>    <span class="hljs-title function_">printCache</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> result = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current.key}</span>:<span class="hljs-subst">${current.value}</span>`</span>);<br>            current = current.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache (most recent -&gt; least recent):'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2（刷新顺序）</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br><br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);            <span class="hljs-comment">// 容量满，淘汰最久未使用的 1</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 4:4 -&gt; 2:2 -&gt; 3:3</span><br></code></pre></td></tr></table></figure><h3 id="TS实现"><a href="#TS实现" class="headerlink" title="TS实现"></a>TS实现</h3><p>使用双向链表结合 Map（Map 在 TypeScript 中天然支持泛型）实现 O(1) 时间复杂度的 get 和 put 操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 双向链表节点接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>    <span class="hljs-attr">key</span>: K;<br>    <span class="hljs-attr">value</span>: V;<br>    <span class="hljs-attr">prev</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K = <span class="hljs-built_in">number</span>, V = <span class="hljs-built_in">number</span>&gt; {<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span>;                <span class="hljs-comment">// 缓存容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">cache</span>: <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;;        <span class="hljs-comment">// 哈希表：键到节点的映射</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">head</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟尾节点</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">// 将节点移动到头部（最近使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">moveToHead</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-comment">// 从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>!;<br><br>        <span class="hljs-comment">// 插入头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">// 移除尾部节点（最久未使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">removeTail</span>(): <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>!;<br>        lastNode.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">// 获取值</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: K): V | -<span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(node);  <span class="hljs-comment">// 刷新访问顺序</span><br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">// 放入键值对</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            existingNode.<span class="hljs-property">value</span> = value;  <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">const</span> <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 超出容量时淘汰</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeTail</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 调试：打印缓存顺序（最近 -&gt; 最久）</span><br>    <span class="hljs-title function_">printCache</span>(): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current!.key}</span>:<span class="hljs-subst">${current!.value}</span>`</span>);<br>            current = current!.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br></code></pre></td></tr></table></figure><h2 id="链表反转的实现"><a href="#链表反转的实现" class="headerlink" title="链表反转的实现"></a>链表反转的实现</h2><p>单向链表的反转实现，包括迭代和递归两种方式</p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 单向链表节点定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params">arr</span>) {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 方法一：迭代反转（推荐，空间复杂度 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 前驱指针</span><br>    <span class="hljs-keyword">let</span> current = head;      <span class="hljs-comment">// 当前指针</span><br>    <span class="hljs-keyword">let</span> next = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 临时存储下一节点</span><br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        next = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev; <span class="hljs-comment">// 反转指针</span><br>        prev = current;      <span class="hljs-comment">// 前驱前进</span><br>        current = next;      <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// prev 成为新头节点</span><br>}<br><br><span class="hljs-comment">// 方法二：递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-comment">// 递归终止条件：空链表或只有一个节点</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br><br>    <span class="hljs-comment">// 递归反转后续链表</span><br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br><br>    <span class="hljs-comment">// 反转当前节点与下一节点的指向</span><br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> newHead;  <span class="hljs-comment">// 新头节点始终是原链表的尾节点</span><br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIterative = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIterative);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list2);  <span class="hljs-comment">// 6 -&gt; 7 -&gt; 8</span><br><br><span class="hljs-keyword">const</span> reversedRecursive = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRecursive);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><h3 id="TS实现-1"><a href="#TS实现-1" class="headerlink" title="TS实现"></a>TS实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 单向链表节点类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val ?? <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next ?? <span class="hljs-literal">null</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">const</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 迭代反转（推荐，空间 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">current</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = head;<br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">const</span> next = current.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev;        <span class="hljs-comment">// 反转指针</span><br>        prev = current;             <span class="hljs-comment">// 前驱前进</span><br>        current = next;             <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// 新头节点</span><br>}<br><br><span class="hljs-comment">// 递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIter = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIter);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-keyword">const</span> reversedRec = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRec);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><p>DFA:</p><ul><li><strong>顺序表</strong>：适合随机访问（O(1)），插入/删除较慢（O(n)），实现简单，内存连续</li><li><strong>链表</strong>：适合频繁插入/删除（O(1)），随机访问慢（O(n)），内存分散，支持动态扩展, 链表常用于特定算法（如 LRU 缓存、链表反转等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。&lt;/p&gt;
&lt;p&gt;以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-JavaScript算法刷题相关：反转篇</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/47427.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/47427.html</id>
    <published>2025-12-26T03:20:25.000Z</published>
    <updated>2025-12-26T09:06:45.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串，数组，数字的转换"><a href="#字符串，数组，数字的转换" class="headerlink" title="字符串，数组，数字的转换"></a>字符串，数组，数字的转换</h2><p><strong>数字（Number）</strong>、<strong>字符串（String）</strong> 和 <strong>数组（Array）</strong> 之间的相互转换算是常见操作了，常见转换方向、推荐方法、示例代码及说明如下：</p><div class="table-container"><table><thead><tr><th>从 → 到</th><th>方法</th><th>示例代码</th><th>说明</th></tr></thead><tbody><tr><td>Number → String</td><td>String(num) 或 num.toString()</td><td>let str = String(123); // “123” let str = (123).toString(); // “123”</td><td>最可靠方式。toString() 可指定进制，如 (10).toString(2) // “1010”。</td></tr><tr><td>Number → Array</td><td>String(num).split(‘’)</td><td>let arr = String(123).split(‘’); // [“1”, “2”, “3”]</td><td>先转为字符串，再按字符拆分成数组（适用于单个数字的位拆分）。</td></tr><tr><td>String → Number</td><td>Number(str) 或 +str 或 parseInt(str, 10)</td><td>let num = Number(“123”); // 123 let num = +”123”; // 123 let num = parseInt(“123”, 10); // 123</td><td>+str 最简洁；parseInt 适合提取整数部分（忽略后缀非数字）。</td></tr><tr><td>String → Array</td><td>str.split(separator)</td><td>let arr = “1,2,3”.split(‘,’); // [“1”, “2”, “3”] let arr = “123”.split(‘’); // [“1”, “2”, “3”]</td><td>split(‘’) 按单个字符拆分；split(‘,’) 按逗号等分隔符拆分。</td></tr><tr><td>Array → String</td><td>arr.toString() 或 arr.join(separator)</td><td>let str = [1,2,3].toString(); // “1,2,3” let str = [1,2,3].join(‘’); // “123” let str = [1,2,3].join(‘-‘); // “1-2-3”</td><td>join() 更灵活，可自定义分隔符（默认逗号）。</td></tr><tr><td>Array → Number</td><td>先转为字符串，再转为数字（如 Number(arr.join(‘’))）</td><td>let num = Number([1,2,3].join(‘’)); // 123</td><td>适用于纯数字数组；若数组含非数字，返回 NaN。</td></tr><tr><td>Array(Number) → Array(String)</td><td>arr.map(String) 或 arr.map(num =&gt; num.toString())</td><td>let strArr = [1,2,3].map(String); // [“1”, “2”, “3”]</td><td>逐元素转换为字符串，最常用方法。</td></tr><tr><td>Array(String) → Array(Number)</td><td>arr.map(Number) 或 arr.map(str =&gt; parseInt(str, 10))</td><td>let numArr = [“1”,”2”,”3”].map(Number); // [1, 2, 3]</td><td>逐元素转换为数字；parseInt 更安全处理可能含非纯数字字符串。</td></tr></tbody></table></div><p>数组转数字本质是拼接字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'2'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'22'</span>, <span class="hljs-string">'23'</span>];<br><br><span class="hljs-comment">// 步骤1: 使用 join('') 无分隔符拼接成字符串 const str = arr.join(''); // "212223"</span><br><br><span class="hljs-comment">// 步骤2: 转换为数字 const num = Number(str); // 212223 // 或等价简写：const num = +arr.join('');</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 212223（number 类型）</span><br></code></pre></td></tr></table></figure><h2 id="字符串反转："><a href="#字符串反转：" class="headerlink" title="字符串反转："></a>字符串反转：</h2><p><strong>ES6:</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> [...str].<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);<br><br><span class="hljs-comment">// 使用示例 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverseString</span>(<span class="hljs-string">'hello'</span>)); <span class="hljs-comment">// 'olleh'</span><br></code></pre></td></tr></table></figure><p><strong>手动循环</strong>（不依赖内置方法）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">str</span>) {<br>  <span class="hljs-keyword">let</span> reversed = <span class="hljs-string">''</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    reversed += str[i];<br>  }<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure><h2 id="数组反转（Array-Reverse）"><a href="#数组反转（Array-Reverse）" class="headerlink" title="数组反转（Array Reverse）:"></a>数组反转（Array Reverse）:</h2><p><strong>原地反转</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">reverse</span>();  <span class="hljs-comment">// arr 变为 [4, 3, 2, 1]</span><br></code></pre></td></tr></table></figure><p><strong>手动实现</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) {<br>    [arr[left], arr[right]] = [arr[right], arr[left]];<br>    left++;<br>    right--;<br>  }<br>  <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></table></figure><h2 id="数字反转（leetcode-7）"><a href="#数字反转（leetcode-7）" class="headerlink" title="数字反转（leetcode # 7）"></a>数字反转（leetcode # 7）</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseInt</span>(<span class="hljs-params">x</span>) {<br>  <span class="hljs-keyword">const</span> sign = x &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> reversed = sign * <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>), <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串，数组，数字的转换&quot;&gt;&lt;a href=&quot;#字符串，数组，数字的转换&quot; class=&quot;headerlink&quot; title=&quot;字符串，数组，数字的转换&quot;&gt;&lt;/a&gt;字符串，数组，数字的转换&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数字（Number）&lt;/strong&gt;、&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-面试算法ACM模式构建构建输入输出模板（Javascript）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/31996.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/31996.html</id>
    <published>2025-12-25T15:09:45.000Z</published>
    <updated>2025-12-26T07:14:53.570Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞<br>上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板</p><h2 id="一、基础模板"><a href="#一、基础模板" class="headerlink" title="一、基础模板"></a>一、基础模板</h2><p>我们先来看一个基础模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello Nowcoder!"</span>);<br>})();<br></code></pre></td></tr></table></figure><p>我们接下来逐行解析下每行代码的作用</p><h5 id="1-引入-readline-模块并创建接口"><a href="#1-引入-readline-模块并创建接口" class="headerlink" title="1. 引入 readline 模块并创建接口"></a>1. 引入 readline 模块并创建接口</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br></code></pre></td></tr></table></figure><ul><li><code>require("readline")</code>：引入 Node.js 内置的<code>readline</code>模块，这个模块用于从命令行（标准输入）读取一行一行的输入。</li><li><code>createInterface({ input: process.stdin })</code>：创建一个输入接口，指定输入源为<code>process.stdin</code>（标准输入，也就是用户在控制台输入的内容）。</li><li>变量<code>rl</code>就是这个输入接口的实例，后续通过它来控制输入的读取。</li></ul><h5 id="2-创建异步迭代器"><a href="#2-创建异步迭代器" class="headerlink" title="2. 创建异步迭代器"></a>2. 创建异步迭代器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br></code></pre></td></tr></table></figure><ul><li><code>Symbol.asyncIterator</code>是 Javascript 的一个内置符号，用于定义对象的异步迭代器</li><li>这里通过<code>rl[Symbol.asyncIterator]()</code>获取 rl 接口的异步迭代器，赋值给<code>iter</code>。</li><li>异步迭代器的作用是：可以通过<code>next()</code>方法<strong>异步地获取下一行输入</strong>（因为输入是用户手动输入的，属于异步操作）。</li></ul><h5 id="3-定义读取一行输入的函数"><a href="#3-定义读取一行输入的函数" class="headerlink" title="3. 定义读取一行输入的函数"></a>3. 定义读取一行输入的函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br></code></pre></td></tr></table></figure><ul><li>这是一个异步函数（<code>async</code>标记），作用是读取一行输入。</li><li>调用<code>iter.next()</code>会返回一个 Promise，<code>await</code>会等待这个 Promise 完成，获取下一行输入的结果。</li><li>结果的<code>value</code>属性就是读取到的一行字符串（如果没有更多输入，<code>value</code>会是<code>undefined</code>）。</li><li>简单说：调用<code>readline()</code>就可以得到一行输入的内容（字符串类型）</li></ul><h5 id="4-立即执行的异步函数（核心逻辑区）"><a href="#4-立即执行的异步函数（核心逻辑区）" class="headerlink" title="4. 立即执行的异步函数（核心逻辑区）"></a>4. 立即执行的异步函数（核心逻辑区）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here 👉 你的核心代码写在这里</span><br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入 console.log("Hello Nowcoder!");</span><br>})();<br></code></pre></td></tr></table></figure><p>这是整个代码的<strong>执行入口</strong>，也就是你需要编写核心逻辑的地方，我们拆解一下：</p><ul><li><code>void async function (){...}()</code>:这是一个<strong>立即执行的异步函数表达式</strong> (IIFE)。<ul><li><code>async</code>标记：允许函数内部使用 await 关键字（因为读取输入输出是异步操作）。</li><li><code>void</code>：避免函数执行后返回值可能导致的语法问题，单纯让函数执行。</li><li>最后的<code>()</code>：表示定义后立即执行这个函数。</li></ul></li></ul><h4 id="核心代码写在哪里？"><a href="#核心代码写在哪里？" class="headerlink" title="核心代码写在哪里？"></a>核心代码写在哪里？</h4><p>答案是：写在<code>void async function () { ... }</code>这个函数内部（也就是注释<code>// Write your code here</code>的位置）。根据题目的输入格式不同，你需要修改这个区域的代码。具体常见的输入格式见我第二部分详细讲解。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个模板的作用是标准化输入读取流程：</p><ol><li>准备好读取输入的工具（<code>rl</code>接口，<code>iter</code>迭代器，<code>readline</code>函数）。</li><li>在立即执行的异步函数中，通过<code>await readline()</code>获取输入。</li><li>在函数内部编写你的核心逻辑（处理输入、计算、输出结果）。</li></ol><h2 id="二、常见出题形式"><a href="#二、常见出题形式" class="headerlink" title="二、常见出题形式"></a>二、常见出题形式</h2><h4 id="1-单组-A-B"><a href="#1-单组-A-B" class="headerlink" title="1.单组 A+B"></a>1.单组 A+B</h4><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>给定两个整数<code>a</code>和<code>b</code>，请你求出<code>a + b</code>的值。</p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>第一行有两个整数<code>a</code>和<code>b</code></p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输入一个整数，代表<code>a + b</code>的值。</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h6 id="核心逻辑解析"><a href="#核心逻辑解析" class="headerlink" title="核心逻辑解析"></a>核心逻辑解析</h6><p>函数内部的<code>while</code>循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span>(line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>()) { ... }<br></code></pre></td></tr></table></figure><ul><li>作用：<strong>持续读取每一行输入</strong> ，直到没有更多输入(<code>readline()</code>返回<code>undefined</code>，循环终止)。</li><li><code>line = await readline()</code>：先调用<code>readline()</code>读取每一行输入，赋值给<code>line</code>。</li><li>当没有输入时，<code>readline()</code>先返回<code>undefined</code>，循环条件为<code>false</code>，退出循环。</li></ul><p>循环内部的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>); <span class="hljs-comment">// 将一行输入按空格分割成数组（比如输入"1 2"，得到["1", "2"]）</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 将第一个元素转为整数</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 将第二个元素转为整数 console.log(a + b); // 输出结果</span><br></code></pre></td></tr></table></figure><h4 id="2-多组-A-B-EOF-形式"><a href="#2-多组-A-B-EOF-形式" class="headerlink" title="2.多组_A+B_EOF 形式"></a>2.多组_A+B_EOF 形式</h4><h6 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，读取至文件末尾为止，每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，读取至文件末尾为止</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入，直到没有更多输入（EOF）</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 将一行输入按空格分割成数组（例如"1 2"分割为["1", "2"]）</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-comment">// 将分割后的字符串转为整数</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出两数之和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="3-多组-A-B-T-组形式"><a href="#3-多组-A-B-T-组形式" class="headerlink" title="3.多组_A+B_T 组形式"></a>3.多组_A+B_T 组形式</h4><h6 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h6><p>给定 t 组测试数据。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数 t，每行有两个整数 a 和 b</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取测试用例数量T</span><br>  <span class="hljs-keyword">let</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：循环T次，处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取一行输入</span><br>    <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>    <span class="hljs-comment">// 分割成两个数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="4-多组A-B零尾模式"><a href="#4-多组A-B零尾模式" class="headerlink" title="4.多组A+B零尾模式"></a>4.多组<em>A+B</em>零尾模式</h4><h6 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，最后一组数据为 0 0，作为输入的结尾。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，最后一组数据为 0 0，作为输入的结尾。</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 分割并转换为数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 关键：判断是否为0 0，是则终止循环</span><br>    <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 退出循环，不再处理后续输入</span><br>    }<br><br>    <span class="hljs-comment">// 不是终止条件则输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="5-单组-一维数组"><a href="#5-单组-一维数组" class="headerlink" title="5.单组_一维数组"></a>5.单组_一维数组</h4><h6 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br>输出：<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取数字的个数n</span><br>  <span class="hljs-keyword">let</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：读取第二行，获取包含n个数字的字符串</span><br>  <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 第三步：对字符串进行处理，转化为数字数组</span><br>  <span class="hljs-keyword">let</span> nums = line<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 用空格分割，过滤空值</span><br><br>  <span class="hljs-comment">// 第四步：计算数组中所有数字的总和</span><br>  <span class="hljs-keyword">let</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 第五步：输出总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="6-多组-一维数组-T-组形式"><a href="#6-多组-一维数组-T-组形式" class="headerlink" title="6.多组_一维数组_T 组形式"></a>6.多组_一维数组_T 组形式</h4><h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">12</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 循环处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取当前组的元素个数n</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 读取当前组的数组元素行</span><br>    <span class="hljs-keyword">const</span> arrayLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 将字符串分割为数字数组</span><br>    <span class="hljs-keyword">const</span> numbers = arrayLine<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-comment">// 计算数组总和（使用reduce累加，初始值为0）</span><br>    <span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, current</span>) =&gt;</span> acc + current, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="7-单组-二维数组"><a href="#7-单组-二维数组" class="headerlink" title="7.单组_二维数组"></a>7.单组_二维数组</h4><h6 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>输出：<br><span class="hljs-number">78</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">let</span> firstLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>  <span class="hljs-keyword">let</span> [m, n] = firstLine.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// m=3, n=4（对应示例输入）</span><br><br>  <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储总和</span><br><br>  <span class="hljs-comment">// 2. 循环读取m行数据（二维数组的每一行）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    <span class="hljs-keyword">let</span> row = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>(); <span class="hljs-comment">// 读取一行数据（如"1 2 3 4"）</span><br>    <span class="hljs-keyword">let</span> nums = row<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 转为数字数组（如[1,2,3,4]）</span><br><br>    <span class="hljs-comment">// 3. 累加当前行的所有元素到总和</span><br>    <span class="hljs-keyword">let</span> rowSum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>    totalSum += rowSum;<br>  }<br><br>  <span class="hljs-comment">// 4. 输出二维数组所有元素的总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="8-多组-二维数组-T-组形式"><a href="#8-多组-二维数组-T-组形式" class="headerlink" title="8.多组_二维数组_T 组形式"></a>8.多组_二维数组_T 组形式</h4><h6 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br>输出：<br><span class="hljs-number">78</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组二维数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的行数m和列数n</span><br>    <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储当前组的总和</span><br><br>    <span class="hljs-comment">// 2.2 读取m行数据（二维数组的每一行）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>      <span class="hljs-keyword">const</span> row = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>        .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>      <span class="hljs-comment">// 累加当前行的所有元素</span><br>      <span class="hljs-keyword">const</span> rowSum = row.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>      totalSum += rowSum;<br>    }<br><br>    <span class="hljs-comment">// 2.3 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="9-单组-字符串"><a href="#9-单组-字符串" class="headerlink" title="9.单组_字符串"></a>9.单组_字符串</h4><h6 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h6><p>给定一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>n</code>，第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">5</span><br>abcde<br>输出：<br>edcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行：字符串的长度n（本题中可忽略具体值，仅用于匹配输入格式）</span><br>  <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 读取第二行：需要反转的字符串</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 3. 反转字符串：</span><br>  <span class="hljs-comment">//    - split('') 将字符串转为字符数组（如"abcde" → ['a','b','c','d','e']）</span><br>  <span class="hljs-comment">//    - reverse() 反转数组（→ ['e','d','c','b','a']）</span><br>  <span class="hljs-comment">//    - join('') 将数组转回字符串（→ "edcba"）</span><br>  <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-comment">// 4. 输出反转后的字符串</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>})();<br></code></pre></td></tr></table></figure><h4 id="10-多组-字符串-T-组形式"><a href="#10-多组-字符串-T-组形式" class="headerlink" title="10.多组_字符串_T 组形式"></a>10.多组_字符串_T 组形式</h4><h6 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次只给出一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后<code>t</code>组数据。每组的第一行有一个整数<code>n</code>,每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出<code>t</code>行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br>abcde<br><span class="hljs-number">8</span><br>redocwon<br><span class="hljs-number">9</span><br>tfarcenim<br>输出：<br>edcba<br>nowcoder<br>minecraft<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串长度n（仅用于匹配输入格式，反转逻辑不依赖此值）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取当前组需要反转的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 反转字符串：拆分为字符数组 → 反转数组 → 拼接为字符串</span><br>    <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>    <span class="hljs-comment">// 2.4 输出反转后的字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="11-单组-二维字符数组"><a href="#11-单组-二维字符数组" class="headerlink" title="11.单组_二维字符数组"></a>11.单组_二维字符数组</h4><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有两个整数<code>n</code>和<code>m</code>，随后<code>n</code>行，每行有<code>m</code>个字符，仅包含小写英文字符。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个二维字符数组。</p><h6 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>abcd<br>efgh<br>ijkl<br>输出：<br>lkji<br>hgfe<br>dcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>  <span class="hljs-comment">// 2. 读取m行字符串，存储到数组中</span><br>  <span class="hljs-keyword">const</span> rows = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    rows.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br>  }<br><br>  <span class="hljs-comment">// 3. 处理逻辑：</span><br>  <span class="hljs-comment">//    a. 先将每行字符串反转（如"abcd" → "dcba"）</span><br>  <span class="hljs-comment">//    b. 再将所有行的顺序反转（如[行1, 行2, 行3] → [行3, 行2, 行1]）</span><br>  <span class="hljs-keyword">const</span> reversedRows = rows<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>)) <span class="hljs-comment">// 每行字符反转</span><br>    .<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// 行顺序反转</span><br><br>  <span class="hljs-comment">// 4. 逐行输出处理后的结果</span><br>  reversedRows.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(row));<br>})();<br></code></pre></td></tr></table></figure><h4 id="12-多组-带空格的字符串-T-组形式"><a href="#12-多组-带空格的字符串-T-组形式" class="headerlink" title="12.多组_带空格的字符串_T 组形式"></a>12.多组_带空格的字符串_T 组形式</h4><h6 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次给出一个长度为<code>n</code>的带空格的字符串<code>s</code>，请你去掉空格之后，将其倒置，然后输出。</p><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后有<code>t</code>组数据。每组的第一行有一个整数<code>n</code>，每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符和空格，保证字符串首尾都不是空格。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">9</span><br>one space<br><span class="hljs-number">11</span><br>two  spaces<br><span class="hljs-number">14</span><br>three   spaces<br>输出：<br>ecapseno<br>secapsowt<br>secapseerht<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串总长度n（用于匹配输入格式）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取带空格的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 处理逻辑：</span><br>    <span class="hljs-comment">//    a. 先将字符串所有字符（包括空格）反转</span><br>    <span class="hljs-comment">//    b. 再去除反转后字符串中的所有空格</span><br>    <span class="hljs-keyword">const</span> processed = str<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拆分为字符数组（含空格）</span><br>      .<span class="hljs-title function_">reverse</span>() <span class="hljs-comment">// 反转所有字符（包括空格）</span><br>      .<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拼接回字符串</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// 去除所有空格（\s+匹配任意空白字符）</span><br><br>    <span class="hljs-comment">// 2.4 输出处理结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processed);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="13-单组-保留小数位数"><a href="#13-单组-保留小数位数" class="headerlink" title="13.单组_保留小数位数"></a>13.单组_保留小数位数</h4><h6 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h6><p>给定一个小数 n ，请你保留 3 位小数后输出。</p><p>如果原来的小数位数少于 3 ，需要补充 0 。</p><p>如果原来的小数位数多于 3 ，需要四舍五入到 3 位。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1.23</span><br>输出：<br><span class="hljs-number">1.230</span><br><br>输入：<br><span class="hljs-number">114.514</span><br>输出：<br><span class="hljs-number">114.514</span><br><br>输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">123.000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的小数（单组输入，只需读一次）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 将字符串转换为浮点数</span><br>  <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">parseFloat</span>(numStr);<br><br>  <span class="hljs-comment">// 3. 保留3位小数：toFixed(3)会自动补零，确保结果是3位小数</span><br>  <span class="hljs-keyword">const</span> result = num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">// 4. 输出格式化后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h4 id="14-单组-补充前导零"><a href="#14-单组-补充前导零" class="headerlink" title="14.单组_补充前导零"></a>14.单组_补充前导零</h4><h6 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h6><p>给定一个正整数 n ，请你保留 9 个数位，然后输出。</p><p>如果数位少于 9 个，那么需要补充前导零。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">000000123</span><br><br>输入：<br><span class="hljs-number">123456789</span><br>输出：<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的数字（单组输入，读取一行即可）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 补充前导零至9位：</span><br>  <span class="hljs-comment">//    - padStart(9, '0') 表示如果字符串长度不足9位，在前面补'0'直到长度为9</span><br>  <span class="hljs-keyword">const</span> result = numStr.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">9</span>, <span class="hljs-string">"0"</span>);<br><br>  <span class="hljs-comment">// 3. 输出处理后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>parseInt()</code>：将字符串转化为整数。</li><li><code>parseFloat()</code>：将字符串转化为浮点数。</li><li><code>split()</code>：将字符串按指定分隔符分割成数组。</li><li><code>reverse()</code>：反转数组。</li><li><code>join()</code>：将数组元素按指定分隔符拼接成字符串。</li><li><p><code>padStart()</code>：在字符串前面补充指定字符，直到字符串长度达到指定长度。</p></li><li><p><code>line = await readline()</code>：要注意 await readline()获取的是一段字符串，后面我们还要自己将它分割或者转化为其他数据类型。</p></li><li><code>let tokens = line.split(' ')</code>：这段代码作用是，将一行输入按空格分割成数组（例如”1 2”分割为[“1”, “2”]）。</li><li><code>let a = parseInt(tokens[0])</code>：这段代码的作用是，将分割的字符转化为数字。</li></ul><p>再配合<code>while</code>和<code>for</code>语句差不多可以应对各种题型了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞&lt;br&gt;上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板&lt;/p&gt;
&lt;h2 id=&quot;一、基础模板&quot;&gt;&lt;a href=&quot;#一、基础模板&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-关于动态规划(背包问题为例)</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/24254.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/24254.html</id>
    <published>2025-12-25T10:24:04.000Z</published>
    <updated>2025-12-25T15:08:14.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划介绍"><a href="#动态规划介绍" class="headerlink" title="动态规划介绍"></a>动态规划介绍</h3><p>动态规划（Dynamic Programming，简称 DP）是一种算法设计范式，用于解决具有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的优化问题。它通过将原问题分解为若干子问题，先解决子问题并保存结果（通常使用表格或数组），从而避免重复计算，最终构建出原问题的解。</p><p>动态规划的核心思想源于数学中的贝尔曼最优性原理：最优策略的子策略总是最优的。与分治法不同，动态规划适用于子问题重叠的情况，能将指数级时间复杂度优化至多项式级。</p><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20220914114911/DynamicProgramming1.jpg'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220914114911/DynamicProgramming1.jpg" alt=""></p><p class='item-img' data-src='https://deen3evddmddt.cloudfront.net/uploads/content-images/dynamic-programming.webp'><img src="https://deen3evddmddt.cloudfront.net/uploads/content-images/dynamic-programming.webp" alt=""></p><h4 id="动态规划的适用条件"><a href="#动态规划的适用条件" class="headerlink" title="动态规划的适用条件"></a>动态规划的适用条件</h4><ul><li><strong>最优子结构</strong>：原问题的最优解可由子问题的最优解组合得出。</li><li><strong>重叠子问题</strong>：子问题在递归求解中会被多次计算。</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li><strong>自底向上（表格填充）</strong>：使用循环从小型子问题开始填充 DP 表格，直至原问题（常见于背包问题）。</li><li><strong>自顶向下（记忆化递归）</strong>：递归求解并使用备忘录存储已计算子问题结果。</li></ul><h3 id="以-0-1-背包问题为例"><a href="#以-0-1-背包问题为例" class="headerlink" title="以 0/1 背包问题为例"></a>以 0/1 背包问题为例</h3><p>0/1 背包问题（0/1 Knapsack Problem）是动态规划的经典应用：给定 n 个物品，每个物品有重量 w_i 和价值 v_i，以及一个容量为 W 的背包。每个物品只能选择取或不取（0/1），求背包中物品的最大总价值。</p><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20240805101207/Recursion-Tree-for-01-KnapSack.png'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240805101207/Recursion-Tree-for-01-KnapSack.png" alt=""></p><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20250312122610325590/Recursion-tree-for-01-Knapsack-3-1.webp'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20250312122610325590/Recursion-tree-for-01-Knapsack-3-1.webp" alt=""></p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li><strong>子问题</strong>：考虑前 i 个物品和容量为 j 的背包的最大价值。</li><li><strong>状态定义</strong>：<code>dp[i][j]</code> 表示前 i 个物品在容量 j 下的最大价值。</li><li><strong>状态转移方程</strong>：<ul><li>不取第 i 个物品：<code>dp[i][j] = dp[i-1][j]</code></li><li>取第 i 个物品（若 j ≥ w_i）：<code>dp[i][j] = dp[i-1][j - w_i] + v_i</code></li><li><code>dp[i][j] = max</code>(以上两种情况)</li></ul></li><li><strong>边界</strong>：<code>dp[0][j] = 0</code>（无物品），<code>dp[i][0] = 0</code>（容量为 0）</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设物品：重量<code>[1, 3, 4]</code>，价值<code>[15, 20, 30]</code>，背包容量 W = 4。<br>DP 表格填充过程如下所示：</p><h4 id="初始状态（i-0，无物品）"><a href="#初始状态（i-0，无物品）" class="headerlink" title="初始状态（i=0，无物品）"></a>初始状态（i=0，无物品）</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">容量 w:   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br>物品 <span class="hljs-selector-tag">i</span><br><span class="hljs-number">0</span>        <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span><br></code></pre></td></tr></table></figure><h4 id="考虑第-1-个物品（重量-1，价值-15）"><a href="#考虑第-1-个物品（重量-1，价值-15）" class="headerlink" title="考虑第 1 个物品（重量 1，价值 15）"></a>考虑第 1 个物品（重量 1，价值 15）</h4><ul><li>对于 w &lt; 1：无法放入，只能取上一行值（0）。</li><li>对于 w ≥ 1：max(不放入: 0, 放入: 0 + 15) = 15。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">容量 w:   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br>物品 <span class="hljs-selector-tag">i</span><br><span class="hljs-number">0</span>        <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span><br><span class="hljs-number">1</span>        <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span><br></code></pre></td></tr></table></figure><h4 id="考虑第-2-个物品（重量-3，价值-20）"><a href="#考虑第-2-个物品（重量-3，价值-20）" class="headerlink" title="考虑第 2 个物品（重量 3，价值 20）"></a>考虑第 2 个物品（重量 3，价值 20）</h4><ul><li>对于每个 w：<ul><li>如果 w &lt; 3：无法放入，取上一行值。</li><li>如果 w ≥ 3：max(不放入: <code>dp[1][w]</code>, 放入: <code>dp[1][w-3] + 20</code>)。</li></ul></li></ul><p>计算示例：</p><ul><li>w=3：max(15, 15 + 20) = 35</li><li>w=4：max(15, 15 + 20) = 35</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">容量 w:   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br>物品 <span class="hljs-selector-tag">i</span><br><span class="hljs-number">0</span>        <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span><br><span class="hljs-number">1</span>        <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span><br><span class="hljs-number">2</span>        <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[35]</span> <span class="hljs-selector-attr">[35]</span><br></code></pre></td></tr></table></figure><h4 id="考虑第-3-个物品（重量-4，价值-30）"><a href="#考虑第-3-个物品（重量-4，价值-30）" class="headerlink" title="考虑第 3 个物品（重量 4，价值 30）"></a>考虑第 3 个物品（重量 4，价值 30）</h4><ul><li>对于每个 w：<ul><li>如果 w &lt; 4：无法放入，取上一行值。</li><li>如果 w ≥ 4：max(不放入: <code>dp[2][w]</code>, 放入: <code>dp[2][w-4] + 30</code>)。</li></ul></li></ul><p>计算示例：</p><ul><li>w=4：max(35, 0 + 30) = 35（不放入更好）</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">容量 w:   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br>物品 <span class="hljs-selector-tag">i</span><br><span class="hljs-number">0</span>        <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span>  <span class="hljs-selector-attr">[0]</span><br><span class="hljs-number">1</span>        <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span><br><span class="hljs-number">2</span>        <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[35]</span> <span class="hljs-selector-attr">[35]</span><br><span class="hljs-number">3</span>        <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[15]</span> <span class="hljs-selector-attr">[35]</span> <span class="hljs-selector-attr">[35]</span><br></code></pre></td></tr></table></figure><p>最终结果：<code>dp[3][4] = 35</code>（选择第 1 和第 2 个物品：重量 1+3=4，价值 15+20=35）。</p><h4 id="一维-DP-优化过程简要文本模拟"><a href="#一维-DP-优化过程简要文本模拟" class="headerlink" title="一维 DP 优化过程简要文本模拟"></a>一维 DP 优化过程简要文本模拟</h4><p>一维数组从后向前更新（避免覆盖）：</p><p>初始 dp: [0, 0, 0, 0, 0]（容量 0 到 4）</p><p>第 1 个物品后： [0, 15, 15, 15, 15]</p><p>第 2 个物品后： [0, 15, 15, 35, 35]</p><p>第 3 个物品后： [0, 15, 15, 35, 35]</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n × capacity)</li><li>空间复杂度：二维 O(n × capacity)，一维 O(capacity)</li></ul><h4 id="伪代码（自底向上）"><a href="#伪代码（自底向上）" class="headerlink" title="伪代码（自底向上）"></a>伪代码（自底向上）</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dp = 二维数组 (n+<span class="hljs-number">1</span>) <span class="hljs-attribute">x</span> (W+<span class="hljs-number">1</span>)，初始化为 <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n:<br>    <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to W:<br>        <span class="hljs-keyword">if</span> w<span class="hljs-selector-attr">[i-1]</span> &gt; j:<br>            dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = dp<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[j]</span><br>        <span class="hljs-keyword">else</span>:<br>            dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = <span class="hljs-built_in">max</span>(dp<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[j]</span>, dp<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[j - w[i-1]</span>] + v<span class="hljs-selector-attr">[i-1]</span>)<br><br>返回 dp<span class="hljs-selector-attr">[n]</span><span class="hljs-selector-attr">[W]</span><br></code></pre></td></tr></table></figure><p>时间复杂度 O(nW)，空间复杂度 O(nW)（可优化至 O(W) 使用一维数组）</p><p>动态规划通过系统地记录子问题解，避免了暴力递归的冗余计算，在组合优化、序列问题等领域广泛应用。理解背包问题有助于掌握 DP 的状态设计与转移核心。</p><h3 id="0-1-背包问题的-TypeScript-实现详解"><a href="#0-1-背包问题的-TypeScript-实现详解" class="headerlink" title="0/1 背包问题的 TypeScript 实现详解"></a>0/1 背包问题的 TypeScript 实现详解</h3><p>0/1 背包问题（0/1 Knapsack Problem）是动态规划的经典示例。给定 n 个物品，每个物品具有重量 <code>weights[i]</code> 和价值 <code>values[i]</code>，以及一个背包容量 <code>capacity</code>。每个物品只能选择放入或不放入（不可重复），目标是求背包内物品的最大总价值。</p><h4 id="动态规划状态定义与转移"><a href="#动态规划状态定义与转移" class="headerlink" title="动态规划状态定义与转移"></a>动态规划状态定义与转移</h4><ul><li><strong>状态</strong>：<code>dp[i][w]</code> 表示考虑前 i 个物品（索引 0 到 i-1），背包容量为 w 时的最大价值。</li><li><strong>转移方程</strong>：<ul><li>如果不放入第 i 个物品：<code>dp[i][w] = dp[i-1][w]</code></li><li>如果放入第 i 个物品（前提 <code>w ≥ weights[i-1]</code>）：<code>dp[i][w] = dp[i-1][w - weights[i-1]] + values[i-1]</code></li><li><code>dp[i][w] = Math.max(不放入, 放入)</code></li></ul></li><li><strong>初始条件</strong>：<code>dp[0][w] = 0</code>（无物品），<code>dp[i][0] = 0</code>（容量为 0）。</li><li><strong>结果</strong>：<code>dp[n][capacity]</code></li></ul><h4 id="TypeScript-实现"><a href="#TypeScript-实现" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h4><p>以下提供两种实现：标准二维 DP 和空间优化的一维 DP（推荐，后者空间复杂度 O(capacity)）</p><h5 id="1-二维-DP-实现"><a href="#1-二维-DP-实现" class="headerlink" title="1. 二维 DP 实现"></a>1. 二维 DP 实现</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">knapsack01</span>(<span class="hljs-params"><span class="hljs-attr">weights</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">values</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> n = weights.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 创建 (n+1) x (capacity+1) 的二维数组，初始化为 0</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">dp</span>: <span class="hljs-built_in">number</span>[][] = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: n + <span class="hljs-number">1</span> }, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(capacity + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> w = <span class="hljs-number">1</span>; w &lt;= capacity; w++) {<br>            <span class="hljs-keyword">if</span> (weights[i - <span class="hljs-number">1</span>] &gt; w) {<br>                <span class="hljs-comment">// 重量超出，无法放入</span><br>                dp[i][w] = dp[i - <span class="hljs-number">1</span>][w];<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-comment">// 取最大值</span><br>                dp[i][w] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<br>                    dp[i - <span class="hljs-number">1</span>][w],                              <span class="hljs-comment">// 不放入</span><br>                    dp[i - <span class="hljs-number">1</span>][w - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]  <span class="hljs-comment">// 放入</span><br>                );<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> dp[n][capacity];<br>}<br></code></pre></td></tr></table></figure><h5 id="2-一维-DP-实现（空间优化，使用滚动数组）"><a href="#2-一维-DP-实现（空间优化，使用滚动数组）" class="headerlink" title="2. 一维 DP 实现（空间优化，使用滚动数组）"></a>2. 一维 DP 实现（空间优化，使用滚动数组）</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">knapsack01Optimized</span>(<span class="hljs-params"><span class="hljs-attr">weights</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">values</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> n = weights.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 一维数组，dp[w] 表示容量 w 时的最大价值</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">dp</span>: <span class="hljs-built_in">number</span>[] = <span class="hljs-title class_">Array</span>(capacity + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-comment">// 从后向前遍历（防止覆盖前状态）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> w = capacity; w &gt;= weights[i]; w--) {<br>            dp[w] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[w], dp[w - weights[i]] + values[i]);<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> dp[capacity];<br>}<br></code></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> weights = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> values = [<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">const</span> capacity = <span class="hljs-number">4</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">knapsack01Optimized</span>(weights, values, capacity));  <span class="hljs-comment">// 输出 35（放入重量 1 和 3 的物品）</span><br></code></pre></td></tr></table></figure><ul><li>物品数量 n = 3</li><li>重量 weights = [1, 3, 4]</li><li>价值 values = [15, 20, 30]</li><li>背包容量 capacity = 4</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;动态规划介绍&quot;&gt;&lt;a href=&quot;#动态规划介绍&quot; class=&quot;headerlink&quot; title=&quot;动态规划介绍&quot;&gt;&lt;/a&gt;动态规划介绍&lt;/h3&gt;&lt;p&gt;动态规划（Dynamic Programming，简称 DP）是一种算法设计范式，用于解决具有&lt;strong</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-JavaScript中的数组方法与栈（Stack）和队列（Queue）的实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/28254.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/28254.html</id>
    <published>2025-12-25T08:58:15.000Z</published>
    <updated>2025-12-25T10:13:22.452Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能</p><p>这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在<strong>两端</strong>高效操作的能力</p><p>先简单回顾一下这四种数组方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>操作位置</th><th>操作类型</th><th>返回值</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>push()</code></td><td>尾部</td><td>添加</td><td>新长度</td><td>O(1)</td></tr><tr><td><code>pop()</code></td><td>尾部</td><td>删除</td><td>被删除元素</td><td>O(1)</td></tr><tr><td><code>unshift()</code></td><td>头部</td><td>添加</td><td>新长度</td><td>O(n)</td></tr><tr><td><code>shift()</code></td><td>头部</td><td>删除</td><td>被删除元素</td><td>O(n)</td></tr></tbody></table></div><h3 id="1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）"><a href="#1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）" class="headerlink" title="1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）"></a>1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）</h3><p>主要使用数组的<strong>末尾</strong>操作实现：</p><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入栈（push）</td><td>array.push(item)</td><td>stack.push(1)</td><td>O(1)</td></tr><tr><td>出栈（pop）</td><td>array.pop()</td><td>const item = stack.pop()</td><td>O(1)</td></tr></tbody></table></div><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> stack = [];<br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// [1]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// [1, 2]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack);        <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><h3 id="2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）"><a href="#2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）" class="headerlink" title="2. 实现队列（Queue）——先进先出（FIFO，First In First Out）"></a>2. 实现队列（Queue）——先进先出（FIFO，First In First Out）</h3><h4 id="方式一：头部删除-尾部插入"><a href="#方式一：头部删除-尾部插入" class="headerlink" title="方式一：头部删除 + 尾部插入"></a>方式一：<strong>头部删除 + 尾部插入</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队（enqueue）</td><td>array.push(item)</td><td>queue.push(1)</td><td>O(1)</td></tr><tr><td>出队（dequeue）</td><td>array.shift()</td><td>const item = queue.shift()</td><td>O(n)</td></tr></tbody></table></div><p>问题：shift() 会导致数组所有元素向前移动，时间复杂度为 O(n)，频繁操作时性能很差</p><h4 id="方式二：尾部插入-头部删除"><a href="#方式二：尾部插入-头部删除" class="headerlink" title="方式二：尾部插入 + 头部删除"></a>方式二：<strong>尾部插入 + 头部删除</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队</td><td>array.unshift(item)</td><td>queue.unshift(1)</td><td>O(n)</td></tr><tr><td>出队</td><td>array.pop()</td><td>const item = queue.pop()</td><td>O(1)</td></tr></tbody></table></div><p>同样存在 O(n) 操作</p><p>如果需要高效队列，可以使用<strong>双端队列</strong>实现或第三方库，有几种方式</p><ol><li><strong>使用两个数组模拟</strong>（常见面试实现）：<ul><li>一个栈用于入队，一个栈用于出队，需要时倒腾</li></ul></li><li><strong>使用 JavaScript 的 Deque（双端队列）库</strong>：<ul><li>如 js-deque 或其他库，支持 O(1) 的头尾操作</li></ul></li><li><strong>ES6+ 原生替代</strong>：虽然没有内置 Queue，但可以用 Array + 手动索引模拟环形队列（较复杂）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能&lt;/p&gt;
&lt;p&gt;这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在&lt;strong&gt;两端&lt;/str</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-ES6-关于JavaScript的Set 方法</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/27040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/27040.html</id>
    <published>2025-12-25T07:26:18.000Z</published>
    <updated>2025-12-26T05:45:01.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Set-方法详解"><a href="#JavaScript-Set-方法详解" class="headerlink" title="JavaScript Set 方法详解"></a>JavaScript Set 方法详解</h1><h2 id="1-Set-是什么？"><a href="#1-Set-是什么？" class="headerlink" title="1. Set 是什么？"></a>1. Set 是什么？</h2><p><strong>Set</strong>​ 是 ES6 引入的一种新的数据结构，它类似于数组，但<strong>成员的值都是唯一的</strong>，没有重复的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 创建一个 Set</span><br><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 或者从数组创建</span><br><span class="hljs-keyword">const</span> setFromArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// 会自动去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setFromArray); <span class="hljs-comment">// Set(4) {1, 2, 3, 4}</span><br></code></pre></td></tr></table></figure><h2 id="2-Set-的基本方法"><a href="#2-Set-的基本方法" class="headerlink" title="2. Set 的基本方法"></a>2. Set 的基本方法</h2><h3 id="2-1-添加元素：add"><a href="#2-1-添加元素：add" class="headerlink" title="2.1 添加元素：add()"></a>2.1 添加元素：<code>add()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 添加单个元素</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复添加，不会被添加进去</span><br><br><span class="hljs-comment">// 链式调用</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 可以添加任意类型的值</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"hello"</span>);<br>set.<span class="hljs-title function_">add</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> });<br>set.<span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// NaN 在 Set 中也是唯一的</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// 不会添加第二个 NaN</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 查看大小</span><br></code></pre></td></tr></table></figure><h3 id="2-2-删除元素：delete"><a href="#2-2-删除元素：delete" class="headerlink" title="2.2 删除元素：delete()"></a>2.2 删除元素：<code>delete()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-comment">// 删除指定值</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(4) {1, 2, 4, 5}</span><br><br><span class="hljs-comment">// 删除不存在的值返回 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 删除对象引用需要相同的引用</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> })); <span class="hljs-comment">// false，因为不是同一个引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(obj)); <span class="hljs-comment">// true，删除成功</span><br></code></pre></td></tr></table></figure><h3 id="2-3-检查存在：has"><a href="#2-3-检查存在：has" class="headerlink" title="2.3 检查存在：has()"></a>2.3 检查存在：<code>has()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 对于 NaN，Set 能正确处理</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="2-4-清空-Set：clear"><a href="#2-4-清空-Set：clear" class="headerlink" title="2.4 清空 Set：clear()"></a>2.4 清空 Set：<code>clear()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 5</span><br><br>set.<span class="hljs-title function_">clear</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(0) {}</span><br></code></pre></td></tr></table></figure><h2 id="3-Set-的遍历方法"><a href="#3-Set-的遍历方法" class="headerlink" title="3. Set 的遍历方法"></a>3. Set 的遍历方法</h2><h3 id="3-1-forEach"><a href="#3-1-forEach" class="headerlink" title="3.1 forEach()"></a>3.1 <code>forEach()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>]);<br><br><span class="hljs-comment">// 遍历每个元素</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key, set</span>) =&gt;</span> {<br>  <span class="hljs-comment">// Set 的 key 和 value 相同</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);<br>});<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// apple: apple</span><br><span class="hljs-comment">// banana: banana</span><br><span class="hljs-comment">// orange: orange</span><br></code></pre></td></tr></table></figure><h3 id="3-2-keys-、values-、entries"><a href="#3-2-keys-、values-、entries" class="headerlink" title="3.2 keys()、values()、entries()"></a>3.2 <code>keys()</code>、<code>values()</code>、<code>entries()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]);<br><br><span class="hljs-comment">// keys() - 返回键名的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">keys</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// values() - 返回键值的遍历器（Set 的键和值相同）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// entries() - 返回键值对的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">entries</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry); <span class="hljs-comment">// ['a', 'a'], ['b', 'b'], ['c', 'c']</span><br>}<br></code></pre></td></tr></table></figure><h2 id="4-Set-的特性"><a href="#4-Set-的特性" class="headerlink" title="4. Set 的特性"></a>4. Set 的特性</h2><h3 id="4-1-唯一性"><a href="#4-1-唯一性" class="headerlink" title="4.1 唯一性"></a>4.1 唯一性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 自动去重</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> uniqueSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...uniqueSet]); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 对象引用不同，不算重复</span><br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> objSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([obj1, obj2, obj1]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objSet.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，obj1 和 obj2 被认为是不同的</span><br></code></pre></td></tr></table></figure><h3 id="4-2-与数组的对比"><a href="#4-2-与数组的对比" class="headerlink" title="4.2 与数组的对比"></a>4.2 与数组的对比</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 查找元素</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><br><span class="hljs-comment">// 数组查找是 O(n)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，需要遍历</span><br><br><span class="hljs-comment">// Set 查找是 O(1)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，哈希查找，更快</span><br><br><span class="hljs-comment">// 判断是否重复</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicates</span> = (<span class="hljs-params">array</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array).<span class="hljs-property">size</span> !== array.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="4-3-迭代顺序"><a href="#4-3-迭代顺序" class="headerlink" title="4.3 迭代顺序"></a>4.3 迭代顺序</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 的遍历顺序就是插入顺序</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 3, 1, 2（插入顺序）</span><br>}<br><br><span class="hljs-comment">// 与对象不同，对象的键顺序不保证</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-number">3</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>: <span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>: <span class="hljs-string">"c"</span> };<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)); <span class="hljs-comment">// ['1', '2', '3']（数字键会排序）</span><br></code></pre></td></tr></table></figure><h2 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h2><h3 id="5-1-数组去重（最常用）"><a href="#5-1-数组去重（最常用）" class="headerlink" title="5.1 数组去重（最常用）"></a>5.1 数组去重（最常用）</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传统方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniqueArray</span>(numbers)); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 字符串去重</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"hello world"</span>;<br><span class="hljs-keyword">const</span> uniqueChars = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueChars); <span class="hljs-comment">// 'helo wrd'</span><br></code></pre></td></tr></table></figure><h3 id="5-2-求交集、并集、差集"><a href="#5-2-求交集、并集、差集" class="headerlink" title="5.2 求交集、并集、差集"></a>5.2 求交集、并集、差集</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> setA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">const</span> setB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">const</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...union]); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">const</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...intersection]); <span class="hljs-comment">// [3, 4]</span><br><br><span class="hljs-comment">// 差集（A 有 B 没有）</span><br><span class="hljs-keyword">const</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...difference]); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="5-3-数据筛选"><a href="#5-3-数据筛选" class="headerlink" title="5.3 数据筛选"></a>5.3 数据筛选</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 从数组中过滤出唯一的元素</span><br><span class="hljs-keyword">const</span> data = [<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Bob"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> }, <span class="hljs-comment">// 重复</span><br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Charlie"</span> },<br>];<br><br><span class="hljs-comment">// 基于 id 去重</span><br><span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> uniqueData = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(item.<span class="hljs-property">id</span>)) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    seen.<span class="hljs-title function_">add</span>(item.<span class="hljs-property">id</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>});<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueData);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//     { id: 1, name: 'Alice' },</span><br><span class="hljs-comment">//     { id: 2, name: 'Bob' },</span><br><span class="hljs-comment">//     { id: 3, name: 'Charlie' }</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h3 id="5-4-标签-分类系统"><a href="#5-4-标签-分类系统" class="headerlink" title="5.4 标签/分类系统"></a>5.4 标签/分类系统</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TagSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-title function_">addTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">removeTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">delete</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">hasTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">has</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>  }<br><br>  <span class="hljs-title function_">getAllTags</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>];<br>  }<br><br>  <span class="hljs-title function_">merge</span>(<span class="hljs-params">otherTagSystem</span>) {<br>    otherTagSystem.<span class="hljs-property">tags</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">tag</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> articleTags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagSystem</span>();<br>articleTags.<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"Tutorial"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>); <span class="hljs-comment">// 不会重复添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(articleTags.<span class="hljs-title function_">getAllTags</span>()); <span class="hljs-comment">// ['javascript', 'tutorial']</span><br></code></pre></td></tr></table></figure><h2 id="6-Set-性能优势"><a href="#6-Set-性能优势" class="headerlink" title="6. Set 性能优势"></a>6. Set 性能优势</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 测试查找性能</span><br><span class="hljs-keyword">const</span> largeArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);<br><span class="hljs-keyword">const</span> largeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(largeArray);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Array查找"</span>);<br>largeArray.<span class="hljs-title function_">includes</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Array查找"</span>); <span class="hljs-comment">// 约 0.5-1ms</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set查找"</span>);<br>largeSet.<span class="hljs-title function_">has</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set查找"</span>); <span class="hljs-comment">// 约 0.01ms</span><br><br><span class="hljs-comment">// 测试重复检查性能</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesArray</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (arr[i] === arr[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesSet</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-keyword">const</span> testArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">() =&gt;</span><br>  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)<br>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"数组检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesArray</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"数组检查重复"</span>); <span class="hljs-comment">// 慢</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesSet</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set检查重复"</span>); <span class="hljs-comment">// 快</span><br></code></pre></td></tr></table></figure><h2 id="7-WeakSet"><a href="#7-WeakSet" class="headerlink" title="7. WeakSet"></a>7. WeakSet</h2><h3 id="7-1-与-Set-的区别"><a href="#7-1-与-Set-的区别" class="headerlink" title="7.1 与 Set 的区别"></a>7.1 与 Set 的区别</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 可以存储任何类型的值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// WeakSet 只能存储对象引用</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>weakSet.<span class="hljs-title function_">add</span>(obj); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// weakSet.add(1); // TypeError: Invalid value used in weak set</span><br><br><span class="hljs-comment">// WeakSet 的引用是弱引用，不会阻止垃圾回收</span><br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除引用</span><br><span class="hljs-comment">// 等待垃圾回收后，weakSet 中的对应项会自动被移除</span><br></code></pre></td></tr></table></figure><h3 id="7-2-WeakSet-的方法"><a href="#7-2-WeakSet-的方法" class="headerlink" title="7.2 WeakSet 的方法"></a>7.2 WeakSet 的方法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><span class="hljs-keyword">const</span> obj1 = {};<br><span class="hljs-keyword">const</span> obj2 = {};<br><br>weakSet.<span class="hljs-title function_">add</span>(obj1);<br>weakSet.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// true</span><br>weakSet.<span class="hljs-title function_">delete</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// WeakSet 没有 size 属性，不能遍历</span><br><span class="hljs-comment">// console.log(weakSet.size); // undefined</span><br><span class="hljs-comment">// weakSet.forEach(...) // 没有 forEach 方法</span><br></code></pre></td></tr></table></figure><h3 id="7-3-WeakSet-的应用场景"><a href="#7-3-WeakSet-的应用场景" class="headerlink" title="7.3 WeakSet 的应用场景"></a>7.3 WeakSet 的应用场景</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 1. 存储 DOM 节点，避免内存泄漏</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">"button"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button</span>) =&gt;</span> {<br>  weakSet.<span class="hljs-title function_">add</span>(button);<br>  button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (weakSet.<span class="hljs-title function_">has</span>(button)) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"按钮在集合中"</span>);<br>    }<br>  });<br>});<br><br><span class="hljs-comment">// 当按钮从 DOM 中移除时，会被自动垃圾回收</span><br><span class="hljs-comment">// weakSet 中的引用也会自动移除</span><br><br><span class="hljs-comment">// 2. 私有属性模拟</span><br><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    privateData.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 标记为"初始化"</span><br>  }<br><br>  <span class="hljs-title function_">isInitialized</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">has</span>(<span class="hljs-variable language_">this</span>);<br>  }<br>}<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Alice"</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-title function_">isInitialized</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="8-常见的一些陷阱和注意事项"><a href="#8-常见的一些陷阱和注意事项" class="headerlink" title="8. 常见的一些陷阱和注意事项"></a>8. 常见的一些陷阱和注意事项</h2><h3 id="8-1-NaN-的处理"><a href="#8-1-NaN-的处理" class="headerlink" title="8.1 NaN 的处理"></a>8.1 NaN 的处理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 注意：NaN === NaN 为 false，但 Set 认为 NaN 等于自身</span><br></code></pre></td></tr></table></figure><h3 id="8-2-对象引用"><a href="#8-2-对象引用" class="headerlink" title="8.2 对象引用"></a>8.2 对象引用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><br>set.<span class="hljs-title function_">add</span>(obj1);<br>set.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，因为 obj1 和 obj2 是不同的对象引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> })); <span class="hljs-comment">// false，新对象不是同一个引用</span><br></code></pre></td></tr></table></figure><h3 id="8-3-类型转换"><a href="#8-3-类型转换" class="headerlink" title="8.3 类型转换"></a>8.3 类型转换</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"1"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，1 和 '1' 类型不同，不会去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">"1"</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="8-4-遍历时修改"><a href="#8-4-遍历时修改" class="headerlink" title="8.4 遍历时修改"></a>8.4 遍历时修改</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 在遍历时删除元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">2</span>) {<br>    set.<span class="hljs-title function_">delete</span>(item); <span class="hljs-comment">// 当前正在遍历的元素可以安全删除</span><br>  }<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 1, 2, 3（会正常遍历完）</span><br>}<br><br><span class="hljs-comment">// 在遍历时添加元素可能有问题</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">1</span>) {<br>    set.<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加的元素在本次遍历中可能不会被访问</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="9-与其它数据结构的转换"><a href="#9-与其它数据结构的转换" class="headerlink" title="9. 与其它数据结构的转换"></a>9. 与其它数据结构的转换</h2><h3 id="9-1-Set-与-Array"><a href="#9-1-Set-与-Array" class="headerlink" title="9.1 Set 与 Array"></a>9.1 Set 与 Array</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set → Array</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> arr1 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set);<br><span class="hljs-keyword">const</span> arr2 = [...set];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1, arr2); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// Array → Set</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...newSet]); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="9-2-Set-与-String"><a href="#9-2-Set-与-String" class="headerlink" title="9.2 Set 与 String"></a>9.2 Set 与 String</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 字符串去重并排序</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"javascript"</span>;<br><span class="hljs-keyword">const</span> uniqueSorted = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueSorted); <span class="hljs-comment">// 'aijprstv'</span><br></code></pre></td></tr></table></figure><h3 id="9-3-Set-与-Map"><a href="#9-3-Set-与-Map" class="headerlink" title="9.3 Set 与 Map"></a>9.3 Set 与 Map</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用 Set 存储 Map 的键</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>],<br>]);<br><br><span class="hljs-keyword">const</span> keysSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(map.<span class="hljs-title function_">keys</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...keysSet]); <span class="hljs-comment">// ['a', 'b', 'c']</span><br></code></pre></td></tr></table></figure><h2 id="10-综合示例"><a href="#10-综合示例" class="headerlink" title="10. 综合示例"></a>10. 综合示例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实现一个简单的权限系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-comment">// 添加权限</span><br>  <span class="hljs-title function_">addPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 批量添加权限</span><br>  <span class="hljs-title function_">addPermissions</span>(<span class="hljs-params">permissionsArray</span>) {<br>    permissionsArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 检查是否有某个权限</span><br>  <span class="hljs-title function_">hasPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(permission);<br>  }<br><br>  <span class="hljs-comment">// 检查是否有所有指定权限</span><br>  <span class="hljs-title function_">hasAllPermissions</span>(<span class="hljs-params">requiredPermissions</span>) {<br>    <span class="hljs-keyword">return</span> requiredPermissions.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 检查是否有任一指定权限</span><br>  <span class="hljs-title function_">hasAnyPermission</span>(<span class="hljs-params">permissions</span>) {<br>    <span class="hljs-keyword">return</span> permissions.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 获取所有权限</span><br>  <span class="hljs-title function_">getAllPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>];<br>  }<br><br>  <span class="hljs-comment">// 移除权限</span><br>  <span class="hljs-title function_">removePermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">delete</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 清空所有权限</span><br>  <span class="hljs-title function_">clearPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">clear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> userPermissions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionSystem</span>();<br>userPermissions<br>  .<span class="hljs-title function_">addPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>, <span class="hljs-string">"delete"</span>])<br>  .<span class="hljs-title function_">addPermission</span>(<span class="hljs-string">"execute"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasPermission</span>(<span class="hljs-string">"write"</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasAllPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">getAllPermissions</span>()); <span class="hljs-comment">// ['read', 'write', 'delete', 'execute']</span><br></code></pre></td></tr></table></figure><hr><p>总之</p><ul><li>高效查找：<code>has()</code>方法的时间复杂度是 O(1)</li><li>遍历时按插入顺序输出</li><li>需要去重时，优先考虑 Set</li><li>需要快速查找元素是否存在时，用 Set 代替数组</li><li>存储唯一值集合时，Set 是最佳选择</li><li>需要存储对象引用并自动清理时，考虑 WeakSet</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-Set-方法详解&quot;&gt;&lt;a href=&quot;#JavaScript-Set-方法详解&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Set 方法详解&quot;&gt;&lt;/a&gt;JavaScript Set 方法详解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-力扣百题速练（Javascript/TypeScript）Vol.1</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39687.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39687.html</id>
    <published>2025-12-25T05:57:08.000Z</published>
    <updated>2025-12-26T11:02:49.984Z</updated>
    
    <content type="html"><![CDATA[<p>简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都</p><hr><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target<br>在该数组中找出 <strong>和为目标值 target</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标<br>你可以假设每种输入只会对应一个答案，并且同一个元素不能重复使用</p><p><strong>示例</strong>：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1] 解释：因为 nums[0] + nums[1] = 2 + 7 = 9。</p><p>直接用双重循环解，优化的话其实可以上哈希表</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) {<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) {<br>                <span class="hljs-keyword">return</span> [i, j];<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> [];<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p>给定两个非空单向链表，表示两个非负整数<br>每个节点存储一位数字，数字以逆序存储（个位在头部），要求返回一个新链表表示它们的和（同样逆序存储）<br>不允许修改原链表</p><p><strong>示例：</strong><br>输入：l1 = 2 → 4 → 3（表示 342），l2 = 5 → 6 → 4（表示 465）<br>输出：7 → 0 → 8（表示 807）</p><p>本质上是模拟竖式加法，从低位到高位逐位相加。由于链表逆序存储，正好从个位开始遍历</p><ol><li><strong>逐位相加并处理进位</strong>：<ul><li>同时遍历两个链表的节点，取当前节点值相加，加上上一位的进位（初始进位为 0）。</li><li>当前位结果 = (val1 + val2 + carry) % 10</li><li>新进位 carry = Math.floor((val1 + val2 + carry) / 10)</li></ul></li><li><strong>使用哑节点（dummy head）简化代码</strong>：<ul><li>创建一个哑节点，尾指针指向它，便于统一处理头部节点，避免单独处理第一个节点。</li></ul></li><li><strong>处理链表长度不等和最终进位</strong>：<ul><li>当一个链表遍历完时，将另一个链表的剩余节点视为 val = 0 继续相加。</li><li>遍历结束后，若仍有进位（carry = 1），需添加一个新节点值为 1。</li></ul></li></ol><p>提供以下 ListNode 类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params"><span class="hljs-attr">l1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">l2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dummy</span>: <span class="hljs-title class_">ListNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 哑节点，没有 dummy，直接从第一个节点开始构建，结果链表的头节点会在循环中不断变化</span><br>  <span class="hljs-comment">//需要额外判断是否是第一个节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">ListNode</span> = dummy;<br>  <span class="hljs-comment">//始终指向结果链表的“当前最后一个节点”。</span><br>  <span class="hljs-comment">//每次计算出一位新数字后，直接在 tail 后面添加新节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">carry</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 进位，当前这一位加完后，是否需要给下一位（更高位）额外加 1</span><br><br>  <span class="hljs-keyword">while</span> (l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span> || carry !== <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val1</span>: <span class="hljs-built_in">number</span> = l1 ? l1.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val2</span>: <span class="hljs-built_in">number</span> = l2 ? l2.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">sum</span>: <span class="hljs-built_in">number</span> = val1 + val2 + carry;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">digit</span>: <span class="hljs-built_in">number</span> = sum % <span class="hljs-number">10</span>;<br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br><br>    tail.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(digit);<br>    tail = tail.<span class="hljs-property">next</span>;<br><br>    <span class="hljs-keyword">if</span> (l1) l1 = l1.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (l2) l2 = l2.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p>要求给定一个字符串 s，找出其中不含有重复字符的最长<strong>子串</strong>的长度<br>（而非子序列）</p><p><strong>示例：</strong></p><ul><li>输入：”abcabcbb” → 输出：3（子串 “abc”）</li><li>输入：”bbbbb” → 输出：1</li><li>输入：”pwwkew” → 输出：3（子串 “wke”）</li></ul><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp" alt="Longest Substring Without Repeating Characters - GeeksforGeeks"></p><p>直接上滑动窗口，结合哈希集合（Set）或映射</p><ul><li>使用左指针 left 和右指针 right 维护一个窗口 (left, right)</li><li>扩展右指针，若遇到重复字符，则收缩左指针直到无重复</li><li>每次更新最大长度 maxLength = Math.max(maxLength, right - left)</li></ul><p class='item-img' data-src='https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png'><img src="https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png" alt=""></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// 记录窗口内字符</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 左指针</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-property">length</span>; right++) {<br>        <span class="hljs-comment">// 若当前字符已存在，收缩左指针</span><br>        <span class="hljs-keyword">while</span> (charSet.<span class="hljs-title function_">has</span>(s[right])) {<br>            charSet.<span class="hljs-title function_">delete</span>(s[left]);<br>            left++;<br>        }<br>        charSet.<span class="hljs-title function_">add</span>(s[right]);<br>        maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLength, right - left + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> maxLength;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><p>要求在两个已排序数组 nums1 和 nums2 中找到合并后的中位数，且时间复杂度必须为 O(log(m + n))，其中 m 和 n 分别为数组长度</p><p><strong>示例</strong>：</p><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><h3 id="最初思路"><a href="#最初思路" class="headerlink" title="最初思路"></a>最初思路</h3><p>最开始打算做双指针合并，使用两个指针 i 和 j 分别指向 nums1 和 nums2 的当前待比较位置（初始为 0），每次比较 nums1[i] 和 nums2[j]，将较小的元素放入结果数组 merged，并将对应指针后移，当某个数组遍历完后，将另一个数组剩余元素全部追加到 merged，合并完成后，merged 就是一个完整有序数组</p><p>然后就可以根据总长度奇偶性计算中位数：<br>奇数直接取第 (total+1)/2 个元素（索引 mid）<br>偶数取第 total/2 和第 total/2 + 1 个元素的平均（索引 mid-1 和 mid）</p><p>想了 40 分钟，但是复杂度 m * n，直接寄了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; nums2.<span class="hljs-property">length</span>; j++) {<br>        <span class="hljs-keyword">while</span>(nums2[j] &lt;= nums1[i]);<br>            merged.<span class="hljs-title function_">push</span>(nums2[j]);<br>        }<br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; nums2.<span class="hljs-property">length</span>; k++) {<br>        merged.<span class="hljs-title function_">push</span>(nums2[k]);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> ? merged[mid] : (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li><strong>外层 for</strong>：遍历 nums1 的每一个元素 nums1[i]。</li><li><strong>内层 while</strong>（代替 for，避免重复遍历）：在放入 nums1[i] 之前，先检查 nums2 的头部元素（nums2[0]）。<ul><li>只要 nums2[0] &lt;= nums1[i]，就说明这个元素应该排在 nums1[i] 前面，先放入 merged，并从 nums2 中移除（使用 shift()）。</li><li>这样保证了顺序正确。</li></ul></li><li>放入当前 nums1[i]。</li><li>外层循环结束后，如果 nums2 还有剩余元素（说明它们都大于 nums1 所有元素），直接全部追加。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>  <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>      merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!); <span class="hljs-comment">// 取出 nums2 头部元素</span><br>    }<br>    <span class="hljs-comment">// 放入当前 nums1[i]</span><br>    merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>  }<br>  <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>  <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>    merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>  }<br><br>  <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-keyword">return</span> merged[mid];<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>暴力合并为 O(m + n)，但题目要求对数复杂度，因此需避免完整合并。核心思路是将问题转化为<strong>在较短数组上二分查找一个分区点</strong>，使左右部分满足中位数条件：</p><ul><li>总元素数 total = m + n。</li><li>中位数位置：若 total 奇数，为第 (total + 1)/2 个元素；若偶数，为第 total/2 和第 total/2 + 1 个元素的平均。</li><li>我们需要在合并数组的“左侧”选取 total/2 个元素（使用 (total + 1)/2 以统一奇偶处理）。</li><li>在较短数组 A 上二分查找左侧元素个数 i（0 ≤ i ≤ m），则较长数组 B 左侧元素个数 j = (total + 1)/2 - i。</li><li>分区条件：<ul><li>左侧最大值 ≤ 右侧最小值：max(A[i-1], B[j-1]) ≤ min(A[i], B[j])。</li></ul></li><li>处理边界：使用 -∞ 和 +∞ 填充空侧。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>确保 nums1 为较短数组（若不是，交换）。</li><li>二分范围：low = 0, high = nums1.length。</li><li>计算分区：i = (low + high) / 2, j = (m + n + 1) / 2 - i。</li><li>检查分区：<ul><li>若 A[i-1] &gt; B[j]，则 i 太大，high = i - 1。</li><li>若 B[j-1] &gt; A[i]，则 i 太小，low = i + 1。</li><li>否则，分区正确。</li></ul></li><li>计算中位数：<ul><li>左侧最大：max(A[i-1], B[j-1])。</li><li>右侧最小：min(A[i], B[j])。</li><li>若 total 奇数，返回左侧最大；偶数，返回平均。</li></ul></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入 merged</span><br>        <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>            merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);  <span class="hljs-comment">// 取出 nums2 头部元素</span><br>        }<br><br>        <span class="hljs-comment">// 放入当前 nums1[i]</span><br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> merged[mid];<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="5-最长的回文子串"><a href="#5-最长的回文子串" class="headerlink" title="5.最长的回文子串"></a>5.最长的回文子串</h2><p>要求给定一个字符串 s，返回其中最长的回文子串（回文指正读反读相同的连续子串）<br>示例：</p><ul><li>输入：”babad” → 输出：”bab” 或 “aba”（长度 3）</li><li>输入：”cbbd” → 输出：”bb”（长度 2）</li></ul><p class='item-img' data-src='https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png'><img src="https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png" alt="Leetcode 5. Longest Palindromic Substring | Nick Li"></p><h3 id="中心扩展法（Expand-Around-Center）"><a href="#中心扩展法（Expand-Around-Center）" class="headerlink" title="中心扩展法（Expand Around Center）"></a>中心扩展法（Expand Around Center）</h3><p>时间复杂度 O(n²)，空间复杂度 O(1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回文串以中心对称。中心可能为单个字符（奇数长度回文）或两个相同字符间（偶数长度回文）。 对于字符串每个可能中心（共 2n-1 个），向两侧扩展比较字符，直至不对称。记录扩展中最长回文。</p><p>步骤：</p><ol><li>遍历字符串索引 i 从 0 到 n-1。</li><li>以 i 为中心扩展奇数长度回文。</li><li>以 i 和 i+1 为中心扩展偶数长度回文。</li><li>每次扩展更新最长回文起点和长度。</li><li>返回对应子串。</li></ol><p class='item-img' data-src='https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg'><img src="https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg" alt="Longest Palindromic Substring (With Visualization)"></p><h3 id="TypeScript-实现"><a href="#TypeScript-实现" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 最长回文起点</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最长回文长度（初始至少 1）</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">expandAroundCenter</span>(<span class="hljs-params"><span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-property">length</span> &amp;&amp; s[left] === s[right]) {<br>            <span class="hljs-keyword">const</span> currentLength = right - left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (currentLength &gt; maxLength) {<br>                start = left;<br>                maxLength = currentLength;<br>            }<br>            left--;<br>            right++;<br>        }<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 奇数长度回文（中心为 i）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i);<br>        <span class="hljs-comment">// 偶数长度回文（中心为 i 和 i+1）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(start, start + maxLength);<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="6-Z-字变换"><a href="#6-Z-字变换" class="headerlink" title="6. Z 字变换"></a>6. Z 字变换</h2><p>将一个给定字符串  <code>s</code>  根据给定的行数  <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列<br>比如输入字符串为  <code>"PAYPALISHIRING"</code>  行数为  <code>3</code>  时，排列如下：</p><p>P A H N<br>A P L S I I G<br>Y I R</p><p>之后输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>"PAHNAPLSIIGYIR"</code></p><p>实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><p>输入：s = “PAYPALISHIRING”, numRows = 3<br>输出：”PAHNAPLSIIGYIR”</p><p>示例 2：</p><p>输入：s = “PAYPALISHIRING”, numRows = 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br>P I N<br>A L S I G<br>Y A H R<br>P I</p><h3 id="TypeScript-实现-1"><a href="#TypeScript-实现-1" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><p>直接计算位置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">numRows</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (numRows === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> cycle = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; numRows; row++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i + row &lt; s.<span class="hljs-property">length</span>; i += cycle) {<br>      result += s[i + row];<br>      <span class="hljs-keyword">if</span> (row !== <span class="hljs-number">0</span> &amp;&amp; row !== numRows - <span class="hljs-number">1</span> &amp;&amp; i + cycle - row &lt; s.<span class="hljs-property">length</span>) {<br>        result += s[i + cycle - row];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><p>给你一个 32 位的有符号整数  <code>x</code> ，返回将  <code>x</code>  中的数字部分反转后的结果<br>如果反转后整数超过 32 位的有符号整数的范围  <code>[−231, 231 − 1]</code> ，就返回 0<br>假设环境不允许存储 64 位整数（有符号或无符号</p><p>示例 1：<br>输入：x = 123<br>输出：321</p><p>示例 2：<br>输入：x = -123<br>输出：-321</p><p>没啥好讲的，转字符串反转再转回去，处理一下负号和边界情况就成</p><p>反转字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> [...str].<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">return</span> x;<br>  }<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX</span> = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN</span> = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> mid = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">LI</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (mid[<span class="hljs-number">0</span>] === <span class="hljs-string">"-"</span>) {<br>    <span class="hljs-variable constant_">LI</span> = <span class="hljs-literal">false</span>;<br>  }<br>  <span class="hljs-keyword">const</span> reverseString = mid.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">true</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(reverseString) &lt; <span class="hljs-variable constant_">MIN</span> || <span class="hljs-built_in">parseInt</span>(reverseString) &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(reverseString);<br>  }<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">false</span>) {<br>    <span class="hljs-keyword">let</span> fin = reverseString.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, reverseString.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> fin2 = -<span class="hljs-built_in">parseInt</span>(fin);<br>    <span class="hljs-keyword">if</span> (fin2 &lt; <span class="hljs-variable constant_">MIN</span> || fin2 &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> fin2;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8.字符串转换整数"></a>8.字符串转换整数</h2><p>实现一个  <code>myAtoi(string s)</code>  函数，使其能将字符串转换成一个 32 位有符号整数。</p><p>函数  <code>myAtoi(string s)</code>  的算法如下：</p><ol><li>空格：读入字符串并丢弃无用的前导空格（<code>" "</code>）</li><li>符号：检查下一个字符（假设还未到字符末尾）为  <code>'-'</code>  还是  <code>'+'</code>如果两者都不存在，则假定结果为正</li><li>转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾，如果没有读取数字，则结果为 0</li><li>舍入：如果整数数超过 32 位有符号整数范围  <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于  <code>−231</code>  的整数应该被舍入为  <code>−231</code> ，大于  <code>231 − 1</code>  的整数应该被舍入为  <code>231 − 1</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myAtoi</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> min = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">sign</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> fin = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> clac = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (i &lt;= s.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">" "</span>) {<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">"-"</span> || s[i] === <span class="hljs-string">"+"</span>) {<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"-"</span>) {<br>        sign = -<span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"+"</span>) {<br>        sign = <span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (clac === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      }<br>      clac = <span class="hljs-number">1</span>;<br>      i++;<br>    }<br>    <span class="hljs-keyword">while</span> (s[i] &lt;= <span class="hljs-string">"9"</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">"0"</span>) {<br>      fin = fin + s[i];<br>      i++;<br>    }<br>    <span class="hljs-keyword">if</span> (fin === <span class="hljs-string">""</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sign === <span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(fin);<br>    }<br>    <span class="hljs-keyword">if</span> (sign === -<span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> -fin;<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure><p>没啥好说的，处理一下转换和条件判断的事情</p><hr><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h2><p>给一个整数  <code>x</code> ，如果  <code>x</code>  是一个回文整数，返回  <code>true</code> ；否则，返回  <code>false</code><br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数<br>例如，<code>121</code>  是回文，而  <code>123</code>  不是</p><p>智斗程度堪比两数之和，转字符串逆序比较秒了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> arr = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> brr = arr.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (arr === brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">if</span> (arr !== brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.正则表达式匹配</h2><p>给你一个字符串  <code>s</code>  和一个字符规律  <code>p</code>，请你来实现一个支持  <code>'.'</code>  和  <code>'*'</code>  的正则表达式匹配。</p><ul><li><code>'.'</code>  匹配任意单个字符</li><li><code>'*'</code>  匹配零个或多个前面的那一个元素</li></ul><p>匹配是要涵盖  <strong>整个</strong>  字符串  <code>s</code>  的，而不是部分字符串。</p><p>示例 1：</p><p>输入：s = “aa”, p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:</p><p>输入：s = “aa”, p = “a<em>“<br>输出：true<br>解释：因为 ‘</em>‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p>示例 3：</p><p>输入：s = “ab”, p = “.<em>“<br>输出：true<br>解释：”.</em>“ 表示可匹配零个或多个（’*‘）任意字符（’.’）</p><p>这道题最开始是想要用纯同步双指针来解，没解出来</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">if</span> (s == p) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">let</span> sindex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> pindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (sindex &lt; s.<span class="hljs-property">length</span> &amp;&amp; pindex &lt; p.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">if</span> (s[sindex] === p[pindex] || p[pindex] === <span class="hljs-string">"."</span>) {<br>      sindex++;<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (p[pindex] === <span class="hljs-string">"*"</span>) {<br>      <span class="hljs-keyword">while</span> (s[sindex] === s[sindex + <span class="hljs-number">1</span>]) {<br>        sindex++;<br>      }<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (s[sindex] !== p[pindex]) {<br>      <span class="hljs-keyword">if</span> (p[pindex] !== <span class="hljs-string">"*"</span> &amp;&amp; p[pindex] !== <span class="hljs-string">"."</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>↑ 错误答案</p><p>主要是该问题具有<strong>非确定性</strong>：同一个 “x*“ 可以有多种匹配方式（0 次、1 次、多次），需要尝试不同分支。纯同步双指针（单路径贪婪）无法处理回溯需求，会在某些案例中错误消耗字符，导致后续失败。</p><p>比如说在 s = “aaa”, p = “ab<em>a” 里贪婪匹配可能错误使用 “b</em>“，而实际应跳过 “b*“（匹配 0 次）</p><p>因此<strong>不能用简单 while 循环同步双指针线性解决</strong>，必须引入分支或状态记录</p><p>然后题解就是使用 dp 解决：</p><p><code>定义二维布尔数组 dp[i][j] 表示：s 的前 i 个字符（s[0..i-1]）是否能被 p 的前 j 个字符（p[0..j-1]）匹配，最终答案为 dp[m][n]，其中 m = s.length，n = p.length</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">const</span> m = s.<span class="hljs-property">length</span>,<br>    n = p.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> dp = <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));<br><br>  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>      dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>    }<br>  }<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>      <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>        dp[i][j] =<br>          dp[i][j - <span class="hljs-number">2</span>] ||<br>          ((s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">2</span>] || p[j - <span class="hljs-number">2</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j]);<br>      } <span class="hljs-keyword">else</span> {<br>        dp[i][j] =<br>          (s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> dp[m][n];<br>}<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p><strong>空串与空模式</strong><code>dp[0][0] = true</code>：空字符串可以被空模式匹配。<br><strong>空字符串与非空模式</strong> 只有当模式中某些 “x*” 可以匹配 0 次字符时，才可能匹配空字符串。 因此从左向右扫描模式：</p>   <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'*'</span>) {<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">2</span>];  <span class="hljs-comment">// 直接继承“跳过当前 x*”的状态</span><br>    }<br>}<br></code></pre></td></tr></table></figure><p>   示例：p = “a<em>b</em>c*“ 可以匹配空字符串，故 dp[0][2]、dp[0][4]、dp[0][6] 均为 true。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>遍历 <code>i = 1..m</code> 和 <code>j = 1..n</code>，根据 <code>p[j-1]</code> 的类型分为两种情况：</p><ol><li><p><strong>当前模式字符不是 ‘*‘</strong>（普通字符或 ‘.’） 只能进行单字符匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = (s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">1</span>] || p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>含义：当前字符匹配且前一个子问题也匹配，则当前子问题成立。</p></li><li><p><strong>当前模式字符是 ‘*‘</strong>（与前一个字符组成 “x<em>”） ‘</em>‘ 提供了两种选择：</p><ul><li>匹配 0 次：直接跳过整个 “x*”，状态等同于 dp[i][j-2]。</li><li>匹配 1 次或多次：前提是当前 <code>s[i-1]</code> 能与 “x” 匹配（<code>s[i-1] === p[j-2]</code> 或 <code>p[j-2] === '.'</code>），且在上一个字符已匹配的基础上继续使用 “x*” 匹配当前字符，即 <code>dp[i-1][j]</code></li></ul><p>两者任一成立即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] ||<br>          ((s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">2</span>] || p[j-<span class="hljs-number">2</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j]);<br></code></pre></td></tr></table></figure></li></ol><h3 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h3><ul><li>时间复杂度：O(mn)，每个状态只计算一次。</li><li>空间复杂度：O(mn)，可进一步优化为 O(n)（仅使用两行或一行滚动数组）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-20-关于滑动窗口</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/25943.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/25943.html</id>
    <published>2025-12-20T07:04:40.000Z</published>
    <updated>2025-12-26T09:10:49.754Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口（Sliding Window）是一种经典的算法设计技巧，主要用于处理<strong>线性数据结构</strong>（如数组、字符串、链表）上的<strong>连续子序列</strong>（子数组或子串）问题。它通过维护一个“窗口”在数据上滑动，避免重复计算，从而将暴力枚举的 O(n²) 或更高复杂度优化至 O(n)。</p><p class='item-img' data-src='https://miro.medium.com/v2/resize:fit:1400/1*Wl4bBtOCKkcVhVEcTCEh-A.png'><img src="https://miro.medium.com/v2/resize:fit:1400/1*Wl4bBtOCKkcVhVEcTCEh-A.png" alt=""></p><ul><li><strong>窗口</strong>：数据中一段连续的区间 [left, right]（左闭右开）或 [left, right]。</li><li><strong>左指针（left）</strong>：窗口左侧边界。</li><li><strong>右指针（right）</strong>：窗口右侧边界。</li><li><strong>滑动过程</strong>：<ul><li>先扩展右指针（right++），扩大窗口。</li><li>当窗口状态不满足条件时，收缩左指针（left++），缩小窗口。</li><li>每次窗口合法时，记录或更新答案。</li></ul></li></ul><h3 id="算法设计通用模板（以数组为例）"><a href="#算法设计通用模板（以数组为例）" class="headerlink" title="算法设计通用模板（以数组为例）"></a>算法设计通用模板（以数组为例）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">slidingWindow</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> maxResult = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 或 minResult、count 等，根据题目</span><br>    <span class="hljs-keyword">let</span> windowState = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 维护窗口内的某种状态（如和、元素个数、唯一字符等）</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; arr.<span class="hljs-property">length</span>; right++) {<br>        <span class="hljs-comment">// 1. 扩展右边界：加入 arr[right]</span><br>        windowState = <span class="hljs-title function_">updateWhenAdd</span>(windowState, arr[right]);<br><br>        <span class="hljs-comment">// 2. 当窗口不合法时，收缩左边界</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-title function_">windowInvalid</span>(windowState, target) &amp;&amp; left &lt;= right) {<br>            windowState = <span class="hljs-title function_">updateWhenRemove</span>(windowState, arr[left]);<br>            left++;<br>        }<br><br>        <span class="hljs-comment">// 3. 此时窗口合法，更新答案</span><br>        maxResult = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxResult, right - left + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 例如求最大长度</span><br>    }<br><br>    <span class="hljs-keyword">return</span> maxResult;<br>}<br></code></pre></td></tr></table></figure><h3 id="常见滑动窗口类型"><a href="#常见滑动窗口类型" class="headerlink" title="常见滑动窗口类型"></a>常见滑动窗口类型</h3><ol><li><strong>固定窗口大小</strong>（窗口长度固定为 k）<ul><li>典型问题：求长度为 k 的子数组的最大/最小和、最大平均值等。</li><li>方法：右指针移动 k 步后开始记录，左指针始终与右指针保持距离 k。</li><li>示例：LeetCode 209（最小长度子数组和 ≥ target）可变形为固定窗口。</li></ul></li><li><strong>可变窗口大小</strong>（窗口长度动态变化）<ul><li><strong>最大/最小长度</strong>：求满足条件的最长或最短子数组。</li><li><strong>计数类</strong>：统计满足条件的子数组个数。</li><li>典型问题：<ul><li>LeetCode 3：无重复字符的最长子串（窗口内字符唯一）。</li><li>LeetCode 76：最小覆盖子串（窗口包含所有目标字符）。</li><li>LeetCode 424：最多替换 k 个字符后的最长重复字符子串。</li></ul></li></ul></li></ol><h3 id="设计滑动窗口的关键步骤"><a href="#设计滑动窗口的关键步骤" class="headerlink" title="设计滑动窗口的关键步骤"></a>设计滑动窗口的关键步骤</h3><ol><li><strong>明确窗口代表什么</strong>：窗口内维护的是一段连续子数组/子串。</li><li><strong>定义窗口的合法状态</strong>：例如，和 ≤ target、无重复字符、包含所有所需元素等。</li><li><strong>维护窗口状态</strong>：<ul><li>使用变量（如 sum、count）、哈希表（Map/Set 统计频率或位置）、双指针等。</li><li>高效更新：添加右元素 O(1)，移除左元素 O(1)。</li></ul></li><li><strong>决定何时移动左/右指针</strong>：<ul><li>右指针通常在外层 for 循环中单向移动（保证总时间 O(n)）。</li><li>左指针在内层 while 循环中移动，直到窗口重新合法。</li></ul></li><li><strong>记录答案</strong>：在窗口合法时更新全局最优解。</li></ol><p><strong>适用问题特征</strong>：</p><ul><li>要求连续子数组/子串的极值（最大、最小、个数）。</li><li>数据具有线性顺序。</li><li>条件具有单调性（扩大窗口使条件更严格，缩小则更宽松）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;滑动窗口（Sliding Window）是一种经典的算法设计技巧，主要用于处理&lt;strong&gt;线性数据结构&lt;/strong&gt;（如数组、字符串、链表）上的&lt;strong&gt;连续子序列&lt;/strong&gt;（子数组或子串）问题。它通过维护一个“窗口”在数据上滑动，避免重复计算，从而将</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-15-杂谈-系统问题</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/48096.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/48096.html</id>
    <published>2025-12-15T03:51:13.000Z</published>
    <updated>2025-12-25T03:23:33.852Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="请联系站长。WXID:Zhong_ye1" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">      <script id="hbeData" type="hbeData" data-hmacdigest="78f4e4fe8655628d1d724594c95dc4f8fe7281231185175246db8764b6d9c1a9" data-keysalt="3dfdaa094f0a23515b23564b4759625a5c7d41bd4a1a6198245849bcec9b60d9" data-ivsalt="e024a60c5e98a73efc4322e08564bbbb839433f1a0ce98690ad516dfbc65b1dd">        6e5cfc95b789f2c461ce8f1e219b84036b84d72c9d2c7545cc76001acd6088f34b18ad902e55dd67be1036f1a27822c8e73503f7cb5a07c78084b526b3ddfcd05368bc39e14b7fe3a31b165cc49f00227c2c6cb920745d4262d76b61ffde53afdc57fb234833862855f250793eac6c5df621dad1ab07d5c1dbf685453c9d3a169279bd3b841ab5169ccc55e370be60553abf553682e4f78711144640de668a7886179e255b954d4c20035b02b477171b7c03fba414b6ec746b9be37ede7d0a3789b21af5213421120f607c9fd87d19e7bed9630d29e1a75eb0fbdc83458dfd73720cf5dc40fdb0d401eea6b3d52a03ded82b968af20a697bf6d655bb0fdc1568dfcf369e6b002d9bd1e8179c2acf6307db49a10ea931cba76b8227f5f6bfefc9b33e8333ac255e91e7d8e90b996bbb20ea435e040b91dc302c5b1f1e29d3d7b71a2d06169c1eb69aacc3ad2a34ce1a87a96bedace0d0210c6d6bd37b4f55c67787426265901abbbd13e839094b869fecacb6bdc560237489115d592e7f5ee1c3e316ffce4c9275f1a06ac3ff46c9ee5b7ea700b7a550df7d2d6e9a81a2158e7f8ef5533b40dd8d2d29ac7ee5911bc8adfacfba88cbe2073b8e210bfa2a72d96d9dc25ea532dc59fd2ce26d4f4a13c4e182c3207951f5c4abc5b6011a750b408ee2f60dc03aeead70c2ce08bb6364a112105d0f312fe4620a08ed7244a838ee040f9ed3dad2450b3caca5d2fe97ba262e4dee76d6445b8af7dd313cf77e5b02ea13a8d0f29bfedcacbcd0a3f8502c54fc30b55d26bf026f70b054b34fbfa63e63f6855457d79671675ea74ef7926193153c07cdfca311029083d72375c08f978dd4ce5459bbf790734243ca3b15620d92cc7ee9b70a4dab15f80d07ed844f2365e0a95a29c871505c2abdc0c924897a64cf6bacf34fc7b80da0942c3cc15f177dd1bd0e01df80e60a855477c141254c13e924c6365fc483ce819fb2009fd8cbd7822bdfaeb5777d40db7d5e6671d021a2dfa0b2945c48ea8269c77befc5c80929a31d9089980c95e4ead9c24602dc525a315d9c8b328100f80d08cf96d26894e8bb7b240f5175f4e9f3378ec3b11f5fa56ac7053b6fc4a2e57191f0d5bca9cc2d50b8fe4b1cabf28b55d243456e8cb1e2f7e7d254ae651027da8670a47e931fd5ed2fa70e8a26cf4bbf084427b5f1582f726e5cfe51d9e8fbde34a50ee4f46b8acff37aa26e5d02f926011984487af13a39250c47bda50744a21cb782a90b065f28752019d832bfff21973fb7a30a8208dab8b93fd0df5d9d9c8d0389e0095ef02b12172081207d5a59c3ee098c830b70fb70bc8492075c2e3f107a20ee90745bf581f35658351966b31d28985c45acffd19e580ca9bd8f788462af418b7d966e7999de5b4be65c0398471d4db7d8bba07520ba2c0501c64c04ca5642c76f78f94c3b27f8fe1ce53f3bbe9c40a4bcf0861473242ad3e4675c0de5cb98d00b516b14265c5e81a895ddcb3f1284fc71bc9b453ff52dff8f2ddd1adba1c282811f60495ecd8d71827500e6d2079add34531dfa311cff2cf8168d30114da9bea75b8b7f86567e775e9a17ac1aa7d5b50ef62303a0b277c704721a4146bed62edbb5246d8849c4c17d13be29495b7f03aa49f5d07c7692ece31ce3a23fc8e2c67e4b0bf8024ab544e9bdc3650e8344bb7a60774822ba6b513a7ce65abd112179de5407cf6ceb1f9985f252d9a4c2cfc5d06278c79e5554f12f61ebb596c23f4c962348e39ec3d2a25fe0dca9c09c6899091448b52453316e3568763bb5999b015cd493727d96eebf9edcb33acdca89e3b0a4057abc82491f518ebde10a3b0220e8941e6d1281a82989d112a74684a48584f3722c78c8dbf21964b90e88b9be4455740259d4fd8d66c26642845cc4ce079ff0e7c7f67b434b0665fb6b2f8c59fdb2418efe5144f63dc0a20ff4d1d1c38a6ad5b6b24ac83b833a444c50969d3ff65e00a6316fd769f2459416a2a7ab29f2d1cbd34359ab03e24f2d2917ca4ce3c8ae2c5341a70049fb5a0c706e08a44fd77ad2f27020dd53b35c822c5ab1f3cacbd65d01d4996ea2da8614d7b1a9322c5f260e881721548dd3a5ea190759000669bc86ac6306e47df881a9acd9bf105b5d44b6404ded09bccab353582e1ca05f2f23e8a9203939b2873b70633a61100c682f2572111346915b4f153652928c78f627fe97c43945ac4cb09af4667cdec774f971818a800baee9017ea02a58d456a0c086505de523bab449929603e75a59b5045f16a301bef26890ba17dfac652529029cb311b78e110e859fba6f54013143b76acee235b25a227b6d69a7c278f08e49589a06495f82ee4e48289bb98ce5d07079d32d4b84caae38270e93012ea3ed6def2fd4b6955ead62bc71d1d8aadae180a4f3a5cc736afa1fa834909f884bd7bd03383f862fb72a4d05618be1732641929ffde216197f4bea4e3a0a9131c23f8f9fd3be3720d40dcef0fd1fc3014be6206fc534adab4ad43e6e4554df4a2d5c3ebdce9bf1248c39a7834c421ac382105aed09e5972ca4e150b207d7cc563fe94aaf9b9f488982026fa02f12345cdc6f7c31bc8e413f1bbe3a6bd21cbf4abdee98a2d85aecde455f81ddfca0e62a9d11a648382366908dbfd466bcb7424eb9c3634cacab770222a88c91994c122fd5cbcb4434f6b89fd71a62e127e84e7d7ad242f598ff6e02d261dd7b832dbf297c36d04cd839ecf81b406710890352566f7e45dda3ea7769ad2316dada44f8d57757e5a29421c66e576a05ef74594d33944567ee92a461dc049d9c5162a83c0e5e4823f458e925c6359deb63a6059960a15eb30dc64886afde0d540b065ec8d5286e65d2fc38bb5a4cdccb76cf9fd9a9d0aa615c8ab98c3693c2ed532f8521cef2c8edae2d61580d29330eb5d026bc5d321d841fa167968aad09a6de78cedeffc10adb9223d41569436d64c983353ad2df2010eeb8e7594ad35cfce9132faa2547af33e52f6083dd136df3d6a931e1ecae46853e65063e79126a949d31c4711564a985ca3528d30e7b8b81d9d7e9e4e0c06427c6a7011336936f3182bcd2693dfb44191c7a7b806d902e4acdb3b1e0682d16eb60ae15a514ec9d9dc7dd16fb28514711509544b130bb4fa1765d5aa2c6d2b0b5d7d5b79314dd90bdab7163c1273212b50383e13bced3cdf801d1de1cb1755fd9300e20260cd71b8836a0aad3890c2d106240483c44ea41c321f91645b0a522b146c6418f09663ffe232dd2647ee3d8c82736396707755bb8a25ca9680bce5f4fc8a65320fb232a0fda49426a6b3e0e84a443da78061d3a51e05d01fb973f62dd2fa59d601dd29827d4ca5a6ee0471b32b0453795c3920df4c60c6e64e56797c8fadbfe18f058a85ef9ac52571e97e144c7c5543f42cfc3fa20c61f95ecea43c26d0bfe7f4c2b8195e87421fc245f29a614566fcc484ee161b91ac0ac8634dcf8ad4abab208a1a49786cb231ab6345c8779d1afc97a4a5ba2ca663494898b9694b5e569e1b7654bdf17ca1789f26a78baf8c259b054de25faeb5cf1aceb2b431bd8e02b1c6f507ce6b9bec3e6b65ba758f52b74e1595f9727b62244a6e9f67a1e13b29ec857dccc70efceee033a082ed2b5269d7c21285a0c9752c2ba0b40325b9f17696361f03446e121c14de9b31d37c5f16c823e9e4cf772b9e5da4f87798db40b92071c4e17908612183a22ad535e875a30e79bf074d9ca1c2920958f0b5f6117e98214b5715bd1e29c4670e7a7608238c4fe1af3ca395a6bb7535892a796eea844d60c2756f241cae24e2f4aa69a5c425c6b14f9f9b36cbfe8b317b17eeb5266113005d1bb3ff74982c6edcf4c8f40cb10ea53ff9fd4f72ad24e19351603baf0fbdcc19723ab96617942525196a1f4b4db430ab06030e19472ab91b334a4e502da2d4f3c2e07ad32a73147d61e0510f20a61a4b961e6d5b2a1fa6fd69b03bd9225f1f639c3e9107ef4d0209be762974419e9fd0b761afd321d35fbc5667c9a34c44f5e62acab2b7d17b76e28e220db833506d841e9271a444c1a508d1a0e30cf2699a9cdec6c68032234a2c5cd72edf8150f7280d59c3eb17d4d56f09cb80e0a5d30518448109b9115c323c432879ed864cccb74fdfa8da57147da8c1ea479841d29d956c501d02001d53430f41b05ac3a668343fe9bedfad4f00e0515b5ab34add6b12bd1551c17f51c7fb1b7034bce29e6cd30f3f43f71b040935f71d9d63f76dabece8bcf40a5271af7f40fb8b29b39825c728581636b6f85ad3973eda41a6bca9e1fb5862ed6a698aab3e1698c75b083893f6db38c8b9832f630718cdb9065bb3bdb883aaa74d46a026706b57360e75ea0167fcb23a90e2d27353641c370350301dd28b804a23fcb943ec7eed869517a804d59b274a6ea718014f0514924efa7f4859c65320b2d77bab60a284e085792a8b5a56303356f79d8cbcca9854ff14f70c030520d4da3f7ba295a2376e36ae576483f9e6fef04518263592c34962a4e31ba0a96ba79133ae009b23a3a78e5b7c638fade89a1fe28baaeff584db78b8dd25ddd25d9050793da9fff550e1cde943bb357bf205899955ed93c1562617e42370618b37bb6b66e462079e9d6257c3d8ab6c1b910d3bd44e526cf2f61860d3c129776dd9286d27e11190f3866fbc1ab9d90fc5d2503570dea595d006fa898a28b57dec56c3008717a01f3fbd666587c860f7dd5666d145bd0d625d3afefd75af626c08a8b0a3fd09f756d764a341d6d7a50f0a637f623f85a5871aeefd3b15b3f23a12de364dae6cebf5aa67d4d8c6011c306d3783226036fd1ac306027e0990ae38baf86ec41a5d64017d364b896e2ae9c61dc10b071553d0ff063d1b3bdb7e300d62469af869f93e8b36b50fff7fa38816a22fcfb7d53bd59f0d64e8d1c437104ddb79308a2d31a278671e94cb48df27567408de2ee0eea9f375264fc81a094b61be54608a2826edcdf4d31edfab8bd5252822b9566b078f5f925b4762af4d05bc5bdf5e7e4042f327c1cfa66bb304a49a2f8c74a3e9d6c53d4e6176679efb181be89924497bd944916a4c882077d6eb0321aa81db87e5a39bea7fc11f0e9c57faa8a417fc5bc4718ce4abdebd4b64e1dd462c3902f7319bf148324ae2dd6b054d6304ccc1769a82a0eb78aa4de0c9c461bf64ceb6275e921dcc3ca1d1b60a2d2339195a1626a5b0ec14ed158d195f44bc275a3fce1048bcdf06dd7f2a2e09c156a8cf5885cad533fd5a8f78802acf9af93bcb755106c0723ad625d4047c60559c4a3cd6506b97824ae10f971fd37a5a789d17a36e1d9bfebf15df47f5cb380ed1daa82fe3c951c1ecd20a1ba9fa301d565c1c12fe1fb500daaecff8db6012b6f3b165d82ae28a6fb3b03e200e5979c998b92d029d6c291aff72d394643f465a441781c76c36494660fcdd32d5ad22e0bd257d77366dc1364ccf268b1f4e5f41d060d771fa55bd4362597ad7dea54f8160c8336e99a5272cac3f259131f3b6c87ef503dc5c4be1060286bf855b3e4c60fd5d38caf823f95d658098c3365a5eda4f09e46c31a9175c834f4f85b88a4ab8c454f84f267c9713a616f180638fdfdb3d2c7da620a77cfaeb622b97744cfd1e08dfa0ffccbbcf23d33df30bff8d5e03826d55faa4d255bae32b100042f9418cb59856334ea211cf7e8991686b341892624bc4b1b1cb515ea25e57daf1bb2a74638a0f720051ca1c51318412c2ac7869653543bfc9777266b13558d0d4fdbc54de4692e99b22dcb678d78571c158a05191d1e10ab0fad455ecb43c0c7796318fc7cb96db2b82d07d0e6a1c76d4b2ff2fa1ae735b4024d82b97559f2fc3a70a266875f710127e495a2580971c8004c22e25c6bd28e01495f0cacefe26dd4dd7ef2349205ec81d42ed6e5d685b29df88ca2ef9feb7a41f29624e4ff4d2899185158d27920a42c90bcb8ed3e30896e728d8f131607aecfe2fdc77869435d46e89fa1664896ab564c428bd9188ada127da5dd600c2a3928c793d6e7c6feb88db781df09ce187ef311749d718dfb4a8815238cc371c9c0c47df8bae0175bbf32a8cd53c30c18394beab33c58464e9d49d550975e1b62d111bf2716c2d84d5d9004c84fb8d03b2a467354fe5c6634848f02bdfb4fa7d50d3dd5fac51211c5564f1c86c0f96bbb6af1b80ce14f94885428366f01f1f3fe266ef2851a62b236f6838cabe91e65ab92a83129ea530be3a0afab8e349cd1319f1e883b2bc56a800e486ebae30abeb8f31c7708cc2567fc620c6384b2012af15e28f2eba19ce821477b834ff49e089c2f49cc51fae533d1b4b0a4cf06afaa8cfeb2eebf8c15154e151b6f4e953aee17ea6875bd44a4fba9209fa2a1e78fe642295fb0a9b6b0e86409a647ed4e02f4d139a88ba9ae28bacadfe6baa791fdb6f06f9396f0f327ad1f983e5f3efdbc8895c643bb746d6798259ae4037ac00c2fd9b5a7092c83a0dfed1b4abc800194222f18fb28b423827ee92a1ddcc8e3112df77b939a2beb27c75d448c615828cbe01fbc06a2565911ea811bce04b397807a40c1dd3cdac0fcb62bc4de41ad36c7fdcd0c40ce40cc436d3437219e46d7eea2ee64d98d351a1a353a1a226eee1c2221d0b53fd2221bfb077bc587c648e996d6fd707ee0228ef9bfa4a323fb6d73ede5e2e77d89bf38b7f29057b710faede499a12d4610300c34588c588f1fae69fa9a8e8dbbab62f6607323aa06fd34e6927da14ee42590c2309a383b48faf036e28960d0490e6f9e9b53a7166225b7698bc5b850c3abab7356484e5b58733fde58ea614d977f9c901dd57ebb929f8e6bdd7a552f352defaf118c77e852a4bb37ae5ff083a7ea87cebb253c7a2fab844afd22472c03c5874ba7244489c43756b7ea69af71193f3c12e4599cf82dd47ea65760a58c328e78978f87efaaf9bb18766433ee8fcbc5aec19be3a2a2cbcb97f74445ba8c345c73f6eadfc1f0c619e15b6f99bc8bba4d1105ef34c793c4be829d7838f9dcafd608ba7d15f42ec4eff30fb01ee6cdfcbea99fa69666fdd4cdf8650a19480a0761da93dc78ee7da0512e2215a264878ab79a43d0b784625e2ccdd761a098b7339812eb8c2477e1669f9d30ed7eed0bf1e2c56fec4fd13064ce52037ced5b0cf451115cb52c54f0709a56ad5804df592e8ddc0a8e1fc9e494b8bce5c23ec5e7da52dd823a4f80655ef8dafcea7bf636000db7290c02cd4e343af44d432d7077ebbb2a8d45f9e11301f6974655dca0d12a9748f0b0ea9c54a32a2ceeebc4c932eebdafc299f7019554b22a21e9f0ccd7e84f4ed56a8dd02adf1d6cb1d7f0f93a37af1dbf5eb94237f8b104eb914dde8ef13a2cf8c6bc5789b49a164c62eca3092d01f1aedf185abd774becf1661605b90e8bcba44adf61e099e3122bfb5994a96db5426fc64a84a0668de6182a6da3eebe8706ec2177679512930cfb2f834751a2d2505f32ffc42c6d9da67d98c5facd3f27f4b54e090f3af40841d841341cb0ea7b7560ec201fa1f5e907fb9de18649bfeb8fb07186cfcc733e7453c463805fe62e6c06d883452f09737750fdd95786dc57d0a94bbc8db65d12aed288994aeab38d6798f82ee0bcb7beccf1a0402e79ee34406e7a14f2f59f1a153a0a96d0cb131ead490b30a39c35171f8e548855e21176b1be315f8d05db5388be38d603bdd9f5ffec0880a630804a1adc00b7ba6a4eac8882a493d29245cd1d7f7d73142ee49fca6c67708b5613ddbb4eb8f9be99def9f210d247746e3a136ea62c57fe8d19a263927e2c29c6fddbeab04db51e1d39642806ec8d0acae385f0c207626fb6213d3690a29548d02ee0410a87bf3129742293e5663553cbc94b80a96fe75da4eccc7bc709e49c9641812210f07dd8180a6bca431dbba7c8e5f339f41aaa8fc16bcd32560dd1656d3b29219d80dde3f3709590e5b6c75f9c3a424d0fe3e07a7bb6772ec01b72073a581753cc9e2b21d8e129dbdfd175cfc3599dec0bba2d50896d770078dea2495987ef3b05916e7cd1528c4a97ebaa944dfc21d89705d89331d8e4648a0bc94a189a8c6d0dd6bffa4491a63c7ea0b1189e1d4e8e508db8474bb87bce0a0297732800c829110755954d6ebee5daa021620449b43eaf230aa0ec54ddde095a1b667445de4bfb59bf394f96a863efc4c8e457fc1c7af9bae4898bf0adfb2cc9a2fa10f1080a2d7bace6bee4976ec00f793b07fd393ed0bef2ff8bbc30d3e3fefd9d0b98b76a28b8acc77b4bcf5c741b6b9d70ca30163cfa8e43f2fffa682f13132972bb38f3e08227bb4f9f2b7f7372a0d141ed98d7fc8780299299c438e7db05e77087fa693568722909cd145e35016c32fd699ff6add8909dfea31da807271cea8a83b79d3e2dcce099f201dc869cffeaf0b07ef32803f3a98fb8a1f445bc0148021998aac499790c1470ea5fa0dd5ebda84f37ec9248490eb55ce22b8c814f77f514de958110d64c9d507dd40196fba729cb6422719792d911fe1a1fc43b8fda64139bfd09fe9fbc0ebf7459bfe3c39aaf7bedb8727a040c7a8b9a5f159f414a99ae2e8a3d70147c7855c111732242657de227989f8cb342d41531ed1b55d2a1faac173347adad0ae6ab5b94ada874fb88b0d54ff346291f614bb25d5fa9e178fecef2482e043a4ac35189fdf35bd15b2732fa09bab17f42b782f6817d5a7b0f25b12c81e0d501203ec526e96c41343ea9fd21c8e2da0fa91098800b7bfebfbd78e28ed86bc4748bbf77ac39cea14ea01fa5b8bffd445f5baea41481bcdacbe2b25304ba8dcc4ace1da2d499b969139b7d05d9a2416cf3ed9e896ddf4225e450633e569cd98c34275d8ac3b7e0e6594f3b96063b8f0b9166640e37d7ef3a0e94b6ecdd0b4dc5ebb8f0a09748d9a89027cbe01b88cf303d90f51c10e4878c90d7e34909585e5a5bbf3c773f2f1dcaa0eb16f38674dac1c2356685bc4998bd6cc76b59a6bbcb27014bfe48edd388fb0def758fdf23104b2a49830014577cfb964385456a1c9bbe9ed502da20ced7e17598ef19bac3aac6bead992fc68d076e6f7f2f816000833d5329c18541c6683ce69d41dc2f92a18f4950d76c0d0b723d5cc6bca8a35b506e1ddf762a05f91ebd23c9b83a39899b1070ee2deee3ed77a38d14730cffd2d3fad1ab3d837b95dc3c0deffb0fa6cccd30e9ce99270d3d93edd9919913738e47c1a88d38239182cea274eaef81b63c9341e8383e033e7556d76e513a6583d22348044e63bc8781e3d39073929edb6024acec0dbe0dca9506bcbe0489604a7fc89bb9e1973af63f37dc64b56942cf233cadf0f4d9d4d44c0e51c8626b9801abeb9921660327923f3ff9ef068c60c7686a10cdc1dbc0531a2d3a59aeef2d1a360e8a4df6aa940045e37d8e73b3ae4c3e62b9a96d268f51dfd5da0a03bd4047337180d1938e9e38d876f67507519f01d324c665662d659f9400ed65b2c96dada36de0ac2bb9272e92fa6af74430c86fe75c0792078d18214625c7c71c0b6ac13f63473134d382702c6381fed108f6c7ec5b348a244a16984c9373407c111590fae28ddc0ebc3bc092a0868ec9cf12b211b636183345aad539bbb12b51eb8d70857e7e2669aba4601c949eeea4a8f264b7439d690051c4efa8e98c5ff65f5a3c3d4044d3e54e25903d763e2ce7788178cdab3b2aebcf55d71bc4cf03f1fbb494a24e2649eb35f93105a8c13cac16629cd1caccf838e6558b784cc26fc1716feea6c99c3b96475cb1edcf49cc1f02ae28ab939c59b0985d652fd60633ff084a1fce7d1e408a0f4f050cef814c0256abcdd6ff2d1d51f9165b0d0db527493ac2b6c6e4c3fa1264379939a74c7a7c913b20e4441089a599d9b5ea28310a332caceba550301c7301b5d6a2ed4440e22cf16fbf33561f05d389c06a7e35bfcf29b663fd8e6800a04b9bfb0150a013956d3f231636b87ad1704f8fe988737f9510ffb47c362e413331d8804426de19093cbcb45864cbc84fcd830a986a401dbd610b7985554717e9800de437a98e66cbec017a45aae7b1709ceb202b06643fd6173aa3b654da7db740fa0099a38b07caa79773bf830f16a42f603a4cf67a9c3de9ceb5c62e6f8a63c5f4485f9fb800624c018867d7488c3c29f0042484b7da8c746be19cc17026c1146c0e8d5161b8b6a56cc4e9221c300a3aeea65130abccedd9bf281e32e74d2f0f0c310743e818f1bc3bddb85b01ca88b883ab67c3f2ec18220b1d98b2bdb7d2d1e13cd191c84f2ccecc9d55cb62627aa3c99f5d6f8ca1bea4ba9540f49c07186d922b251b537ae1858fae78c9bb7a9ef6b158bff843e54a418e3a1deb5759895ac2ee2c220c5e3ff7b624e285e08b63d7eaf809c39d5c4e6f7abee9f4d912dca088a0f6491a11cb02971035e1625667a5d93103bd59c0b3680dff2fdd665aab9c900c11de8ee9f12765b7f84d3b03d947b302d9646b50fb90ce0608ffa0c72a0db384878638699a7c6319e10b27e8d84dd5833cbace76b9720cf04c65a5af23335559511b34577c05d061186a7cc4cf882c15b9a619777a0315f8e7fe65895e1a157039fef96843e110e85c7fe0f3cd02b2846e13488e80cc6983f54ff01c813bd9e27b896fa228225076003c1da9f1abebf476305223f3bced00cd96a475527a57aaa36ae12441953727da9f1da992bafe3458c32384deb51f43d79688e2a75c5ae014311a2396da9f088a47e7cc6b17bba6b156bc1a3b5546f66b265a918a0d4c352c9d3cce6e45910110036f339b68556180226a5a9312e45c2e8a98a0f2dfaaf787f5719e3382d277b212e115f355706768c9a4d9dcb8f54a9ab1cb806baa258dcdae354b5b9653e6d31eb3528951744b5f5c6b4dc4176062e9e32bff11b3058eab8208f1579b958245463135741841f860bd02ddaa7eb289fbc94603208d9a116996c49134eb6d2987043a523a06d0f7fd88b3cbffcc5b2c7ddb720f622ed08f9bf6f0538a34b97a600e4227b0c80a4acee472f710e4b4cadc8262263e3406a2a41c8fdfc87327694d6e3489c08607cbfb479bc529a0cf91077bec56819fb0c0eea21d3e6dbf6989f247bf6c7bff3a50b3db10b613e3706749d0083608ce9455ee189ed8c03b66e462bc01a8374b763c24b7ef1128d9cfc382e62a850519b8d14930a804a918243c1aba80e8ae0c9ca605d02f7418b3e1a628a8d963748819f96f883e99e819d68abff6009112aa950ad3b653a45f39cb9f8f455fb6316046d22fc3f03849a1d192b80ced847e6dd390fedf03cdb73989d6528c3b791535ff55b87f26e7b0269f2b8bbb5690a426890c6c76a20150a1a3e6dcdd2bf02c81f24c4f884ec693d49490579b8d7eca263439a5413d026b9da16e35a773e608c530b3dc1061771417025b96b4669f54babd00d53e0af15789665a972eac5c1283bf2d54bde28af6581ff1226be603a21490ee90f9485edb737c83235a9964430dc18d7cc4d108a22493e7130b04ef8280fdd14a1efb3552b18212a86415a9ef90233af57a219933c16cf1be077f22fb33c8808f8d8a2664aa8b75742e857f1025786a495770081bdc913af9dfa6b93d1e18778308a17658605424102e71227af96dffa3cc1b2d2d1239b2c97c1f4fd32110b54c8c929449c88f1656362aa1ec963653313013c348a921cfa180a84a53ad6877c59b5bb62a52d9080afc639cae2f21d8c6ead941970ccb08bfd5a596640dc4a69b229cc11bb3a1b013c1ec2e0e3159f3bca55ab18f53237e82218b9c23e2b29c3f6dc37b3d2ecbc723a4f44a9254535ba2483d258a847afd86b705e4ce9a4145928f51b4ebc0898cd53f8e4d40b5c83daa77153b5cd2dbe29543cb73b112ca6306866715f43412d886ae157cd96e3015995623f1070a0fb75647d08ab340473edcb9305438ea96ef7bc6db668d3b767ae727e73196da476dc78988ef62fb4c9630affa873e8b262ea9ba80ad100ad0ec2faad84e6272b048682a40fc7de839ce5d0dc4c09653f88e614b1b8dee079d33151963e1c65f0c07940f5f724dff0df288b06d5f9ff564d7c0f9766331deb3ca55f760542313e2edef2985a5e4180a53a96b3b0a25ac8c642d3c557ecee4ab37f1c405e61ad4891ae0df823a92998b83d38c65956abd2cb8d76d9f886cc0ba11ffebe6a9928bbee932482dcb48f8eabb163fa6b393655fd76febfd6f8685497e84f64a606abced11f4f54e5864eeda71a449b3a4a70f077d6d250bea912f5eb6e2b7593915d97e7004b476b76f803730a507d53ca4b2a487191f3b6addf22cbf104ebf9862d03cea219af1a8ae2d60f6e65fb46979e8990dafbebed3902df8ded529f5356c87003d66af704d1fe6af9d6df33b9459dfac8b59e0c7b0c1feff7d2c118504dcfdcc9bf22c5e87c91e8d76e6d7a300261fc5c1bfd165ad0d5fc5239661399db389584ea4063ebdaf9fa165f25c59e691375edc97f894db15f531494f4ba3922694abfe79944f1a0f7bf771d49b407f2fc8158c9ffdf319e2a135822ca17e9248725a9bd274fb90b8d8d3877ec9057d655466c6c57eb146084ffacf8ece0939c495ec947732eaeccf5983cc871d6f018370b8995d417813c4c381e0502e10ff19219a64ccd976ee68e31a2a7c0d72da5c90b564c321cf46018ac550a58223453d6569e38f0f12947b8591ef20c82a78030bec2104b88607e59487c6b5145ab694bb89332547b63cf089dc628b8b692b7d21674837e73c26502558aa25819400d88e01fc657a4f4e38b4642b538160ece245d71135e95c52e6f0a41ab739b6230a693b5d9ed36abe48511cdc070c5ab9713f324c6f5d1632f76a9a919dcfd78ac8e6882b9db4c17092fe3fb292fa3713d79daecd2823972d62e3749c9a8595486458762cd6aa1a0457da03b4685001134ec5481df107a23589167929b05d2c986d29d29f0cfd40d7b949171ab684c4ae4b90361685964eb9ac3c1b0b45c1fc66eec6edb00f049ac0953a0024446b1872829043efeddd488e7523d9730ee384c86d111090246865140c14f439de3957697e55be1f6c5c3e140f133f658e85df786ec898b0b0fea99acc048879d3a18d83b14efec09b335f4e370a71de3e27fce71c73115c7feea12b07a32087265f7189466afa8e4cf0c2ac195a38a201d5f314ded2b3eebbc4c19449d0b5c8537829810b7fbbe590cddd3384b704511cc2ea588e8c2f30f3b043898da1936d0d4f14bb05af9571e0008fa8ea07341fa16a81a4b051d77f62699c176f13935939367c45f0e13803c7a5237f47f2aed9530e5c7ceecff8f397a1592c844bd6b2c0a0755e0dcbd9a0c6f19c234bf284e7aaa13869e8d9b6095a8a9268817bd669ce251243740931778303494a7c74f9541e330ad34c26527b07fc2737ccb7b531e96153731044881dc370a71672777f56149797fca86e737d65489ee34dc82a3fc6495c48a7f88795e662db7b33935ad00de0173c1a4f639e3b6d5a3c3c675150a06f8c3bd50e783068b34279a2fc4487f500deb890972e8bd22fb2cd33282474de3baeb094290613da2d1d016c6e07d6b96c2aa5887d089f003b35fb07691f0340bf88e506d6ae16fe160862bcc7915a2a7cbbedd2cf453c3502f798ac68c22b53d5ea64044b309265641f4a9d558babfbb2ee00138369f9d8443bb95b88d9546469cd7fde61b2ac3994a70d5198a7ee2e52bd71f8d97e723be142efe42e007a77dc917661693ed9bcf08ea1e1b10ceab0c96d02a35ad11d3d76ce77a120f5a06d7118e948af523ba8c125d8f516aba8da0bb68570d70f718327c5ac641cacb8704748bce71f7eb354c164370f7d716736d6f5d9fd8807efdf5a0854af473bde0b4ea3a3263b356a9a9dfe55ec7b2564d1a91630282f3e3a60efd15a104756ed79a57f5f89361298a603743aea15bb141395133f94dc41e6579e9aced7f50f1c785d8e3daa2a133d1c1d8eca7079ecd3d205908595741a84f3c5787dd12ac3e41660f781d1fc23afd9c581865891ba755068e7f9a679def63ff4026fb7664a7c5d25ede169dde8151c689f28e1d5bd2188188043a44cc47b83226cdd25eb77db3a8712a4a3df08e47ed12da2ba8b533b12b33941ce552d9a3e197deaa060cac93fba1c2ce41846ff46cbff2884e3352a8cea756f488f498f16ba7019477243e8b6d265e82d80ef4b692a7e0e5ef0662b48f927ee2d64ddf03273b69281b469b817d387466ec6e05a88167f350cca08b87bc95769035a8cf6d87ce9bbab167018bc89203426fd0ab90a3e619d0253f89b6804a5a7903ae93853de5fd98ae02c7371d302a1ad1eb76bde4350b91b73203443515035f38449aa1854c1c5227924db1285f6d95dce49a7cf3c155dc05938a217a32fec454b28bc11151a053a7d31bc1f3a850fa225f20b162327d0e9a3bf4f9186bce0b8d376af4118756f27ca38822b7fb9fb0e325f33cd84b81ba26c40f8a72ca7e9e0ba630b24262f8909f1aba1743f3a2417f8bd0f25797e8486f9865c20a08e9a07f2c247062229c88136023ba6870770180618c6749796f04c78c94dd4b4aaea72fa5d567dab52c6c59c440c8ebde41e8f52217d67f78e3d30d38e60a0cc24a2866f4ec2eb48799c5bbdeb2e8cc82c1fd4ef0de17d9efafe1d8dae788690998973f8af5e443a148e0d2133af0b3a190cf3e4b7553cd011247ccdaa783fbbd875444da14480cec74821f0f6ea1b55e2e993c3ef0632f9d4bc54132e3ba87b957d125beb5cac56c6ec3a6f7475c25575427544dbdec8d373f3adde834faf42366f8bc6c034a4d294f0ebba2b3b9a7c44d8d213f649b6050fde57092ba7659fbfd8f05e0b785d0cc87101181e8e36ce937d7c49064632205a7075fe177020b5114644178daa98a86820bcd810fa1bb2755e3f594a1f0b1ad462ef59cbc576b637965e31b048f71e288f9b177a342f8d6c6b831b9e72159be66b5c2e665372b67376ce868b196b99a61e761433ffb44ac83e8117d7a78a2378ba18e547eecf9f7b8d3db37c420917b95ede88749cee026244c1f5e8fde4ea88b736aee0f30dd5855c5af423db63eaccbfffa92319c443292cbc128057b1e29787d74c4f3796dbe4d0a3b4cce2e2733a262cd9a5a75176594b1576c09c5a5d08a0cf8f1c327a3625ce5e2a4704ba813231661979b7e1a19dc3c5bd433d7c466eecab0d3b88e5d400745c71788df4644a950b7287c0e0d6436ed794ffb3c198714688655fd83dee076da0fa3969b4149638e146638d305f8ae4370b08f8f5d530713a16c46ab9b4add4a82c020b09ddf047c25ed09423a237a7303a265fdd2618e920145ff737341a285d79feabdbf3d06cb69d62933f8f5826002633102ce9722b2566ed3a6030325841a5a00a99d0d6fe72220629b54071e73361121cab868579e5561c715dcf5fb4f8683c470eca8bcbd95b8b1fe2b5c078a9756e6b25304161f4eb94abb593a6c773b044758047f98d636250767b9945f064a021f21d9be37375bdd0125c1d15d8babebb27490701fc9a944d15f0c94dd50c5b613338dfa8d070a239ace10687ec5896b4261f81c15bd70a45dcf705eb808fc093a23427360a4c0674f0de92a7ecf0326894a91be0775147e07353faa73b6b3399814fd9f5faebb8ad543fb9d310bb57a02e3de3fe4afd57e44152a3175d9fc85c7f73351d568eaeba6c6ce693d897607bc8e642ca0eee456ec496b3439aa774c112a05b2bb1f227eec5933d27bcd7d86d5bbcf323440eb44569896446f408f050c9ed69c04afcc236cc0142ce54937f553b2ed369d8121cac78c23a68d9acb255f92b05944af284e99adaf517408a26b6f1ab0ac0c5c65ac46f075ad31770ab3548428d8041e0b19338e63271d9e57543f6d609e565159417c237286550be1aa12efa496ae15e1f661068d5da943fe07486724ed44f968dae1aba2aaf1ca8ada947bda53e1bb8cd0a856d60b1339182a2cd4d09722e922123b26f6ce9d0bcc81e7bcab182438d0632abeedb17f38d22c7d4f7017afd74da53ad10bb24bd065d921d07a4f14f80f0c3a85ec9c14dbbeca4ecd9a03837ea5decbfc82e369255bae172289363a9553ef9d8a356842f1cc90c27accbf585847315b8251f9f370c0676cb8cf98d5efdced16c4c8f4af62c8b4eaa63added4f8be76ec4e123647dd902793cb1edd83a2abe645b44ceecbc050bc6a4a192896cc76ba28966e5d6dceeea3a390044c9f8408f13962d994f426d041e0181d8b233a91e28718b3c66ba56cef4c4acb051a3deddb2c4df5024b02be672f309cbdc88b1d33ae841534991a7ca16dbc5e6d7209c5effd6c1c57b103b06e6b379327ad7d79cf100e6d28439629b966e4b7c964102abc3c3d5556a9aea4432e12ee8ffff5afbebfb33b761d4c43e92b730d2ddee00282d05eae1399a054728d40d459d58dc49394b873bad2ec081d2c251f86e62486c41267506394344f9403c5b7974d2f65118bc055bc41fd19956784f4d9f3b2a22b9684e3d6937f15aea751d4545d85b58bc54ec4d033d4c96bd5a6e60060b1f69adb87f4dd7f1107a36c7fbe0270d5ffd3299529fe1b14f97fb5e5124c7dbc8b750779bb6d3db3cdbee6c4ff8ee0bf54cf86c4fc2ab50d91549aacc29089dfe9d189f0b1f38c4c42ca7e59259ff1ff7d318591bcea74f6ff36662c30572e1fa380cfd32fd9d1b1074a0908629c811833c9690832d65a3eb0741c28f1e13bcebcf7a9eda0b8e4f79673c90b946fd7b1d19d7af667ba70623a3747715d55a1989f9650f69480dbd3ee22122b9dfd634d447ce7f206d8381706d2a29ad37d8099466475d4b9821b2de654f5d2828d42a6eb9163bcf3890564e6019e380abe63bf1244e62366a3a30387bdec3d6ad6321f75888f787cfae6dad3d50210cb7d4dc00369722ef1b09052625aff3ba121d3c497df07723a96023fcff187d853ff2c99465c94f1796b9585c61e28a802ec1b91b153f0ff84d06f4c1b3f7650a2889c44b878842d46dbb6e77c2658056d9c56bb0467485c517c1a99b9860c37eca0ee2fb1435c804d6f6067f65621ab993778d27d51baa722238921ff5bf877366f9bbbfcf1761d19336c448397e9eb943dd8bd3b330925c29b07cc39bf00586aca128be5754200544452c5573e60b92de6da929349d2d15ca7512252decf7129f2334eb7062060a8b9a6e7ce7d99ef2655d9c2357de205496e7f3023f356bef7d800c4bce535aff7701303c486ef8c4fa01a0352225babc13c71d28b8ceda548c3c2992ffdf4e8b376223a92fd694ab00f866af076d6e4f5a8de04e90342803a9ca9cf5a781966b8053d686a07e1d5d4f6cdaecdf749fb94984d33894285da76064d83152703be328a643b620414bec7c941982a282bfb564b4c971bf2fb1bbea374a66f6f78e03d0d823af852465ef1a8987b950660a84123c875a7e586b07ad262397e8780a1289518b42c31a3c2f60893f4c9ceb35e65300b3f632f47a741cd388f0bd2a0614160a7cbc6e1a58ad078bb19df279ba3698addf33620ce26936e8f2243e6703afb48ab8422925b1f1e9216330473c7d6546e8754e573238a5714ee1f88ed498ba39bad71877b089ecab98f9a972035cebcea2beaaca701f78dbb492596a0b7676f24cbb48676d0961d1470dc265bb267566e1fdf4ccad102fbefe434fb08d28cf074a049361458cab40a1cbf2a9b64e9d4b9b6e08a10a231935419a9b1f0bb3701b0fddd9de55c56912dab7f35607987705a90e2261646e05878c642f538c3d4ce7b778146ab019f4dd08c97caacf18564c2356e7171c110a4e7da264b687f9c3a39c06bca043fd44dd98d22861a0a4fc28695c57b9260a79ee8937ec1f069f7d687993c2b000ea188ba65b6251a99e7487681cc181e1ec5d5bdf900663b30a1f7d4c4d99774a20d235b1870dd708207fedc48cd4592fd7683371701b2f10efc9de5ae4d3c5ca13cd0ea893fd596319f9e4110f155f3d4e1bbaf8a711a73cf6124831a92b6b8bd05d9975a7620d268090f9787c7423fb60e0fbaaf0391c8c48b01e3b78c124556ce497d17413349b6969f8abfeeb6cf24cf661a2b1e8f27d61652af91a3887f2d424ee69013c8f687284a43e03ffefad759b7104e64a08e40c351cb158474403a755be7096ab72b4fe9f931ec6f6cec32c95c858dc8ea65a7acd7d84fa1833ba84edea085b1aaeb69eb96afabc87c677184e64db964c64754dd83f91d212c087cadd5b20568497f84fa4765726b60db0227bc2518848ebbff1e345a6e6a0b9b0262a147225bcbdc15237331c18ed84f4254397c792c149e3f01489bd82654611c48d4e548918ffea35b069f50a2234976679e986bd0e50fab74df0ecbc6838193a382e2e7b6c546288e60c72f92b5f4aec2b3b2844999daa5a754c47043ce0fbeb91337f70d3292f28ec3563f3de1429c02f930d1f2fe352efbef919ebfaf8f5998651ad0a93416a99866f012e58f743b7c7692260651b7dd7773fa25f2538abe4688508286b7fdb9a97a43504c03d486342f48f5835780bf510c408cfc05ac8cf6b7abc03318b53d8f86030a764aecccfb8392f8bb4d30d8f0812f836c663af3938b5fe5abcb3542be702f45b9279de64d9de18cf6b6e9d799bfa631df851d19c36b15d3b573f66ae3f7d21ba8db1908b53c780132a98faacde81c2853db0534b3147d9c1ee5747c1fe5d03c95321871ebc71f039d2aec862a949721cc5a2aca2f5c75e5264228c2df700b04ec07d930604a33187e90ae2a4eec34ff6343125266542e52c2de99f413787ce28e1ba975422d95be01db1d000bd68e23fc34925cc7b906f384f1645614b1e600d087e14ede59779e0dc808a1fbba35b19dc4a4d6515b5224760dfb339a5224eb567aad9b647ff8918d7e816a636f54abbf27413c9e1c95d9e32d28175e7f38875f0bd7d79d165a02930f541cb0e8ff2fecf253f5366e4ddf71a3a91887df4ab965e7dd42956b66047d188347d3fb721faf77deff4786c34ecbe5b981a47bf2f820d9f2eb90107298e9cae64f711ee993b7c9b106a73c3381c3e85c0714e39952d75ca5952832cdcc52f92f32f951350413b27998ea9466a39e778d6fdbed2254da5b993c8c76b9366787c91cc4bca3ceaa930237fe377c1051379c77de7675099d4b77e05bb751911b30e028f3806576e61f4daa24f6c98709dceecaaab154b77c55dba30430615158eb2506b7b177477ee74bfefd880e7546e3a8b755641a44e67b990fc7f98f484c5e6a588a2cc58c923f7cf91aa0851170744b34418fc98ad03cbe120683a6bc84f7be71488ebc154f7d68dc25f28c1e962ac2fbf60060818e3d6d064c5ae8a82b5b3a894fb042c0784da35338f8dcbe25552f3e1878f6c1eb81e848cdc37e1eddda2043b605846ba24e443e571fd2164db5b3a82ce7bba807fb5eec72a00c1d9c8bf34e6ee0f365ab5eba6cbe2bf107e79e74ec8d492c42e6a30b9f2f3c2b4fdf1175ef7a4d550f6d0122ea259a1db54ae227805626eb5193d4cc34b0ee165267cc0933c61f6fdf3c018e40a46b8b202b79fec453787f7a6ea9950183bfffb2d3090303d435a799676112f571db8582a820e46b8e28592d88f156ac2ea32d8fa8fa9f2817165f30249bbb3a89907d69da47727b8b9a3dd18d3fcd20795d1172ec87b55776506952a59d127bdbb021af86d59cd7884e0da29bee56cd64ae04cb241317ccf11a7d4d8eb5f8e508fdca90e06529e3e7ad00b0fccad0b62d06a52b3a0c5655b3a43042e7a8716282c5a316a420f4709783c23079c9a918e4780d213481054192dd43d566bd6d46ac6743b8187e4eeabe38c295ceede634a1e15955babec5a914871fa516098ba809b64ef2b7d4787af9f7b09ab8c39e796b7798562172d9c25ff6797ae7a7b9cc3c0fe0355448c9db12eed2d0b3680b65e3d7b759832016e83dae238e83dccaa3ae7efeeb97a0815c0f332e8ce4a81fd608ba3a6bb20ce83f38c8f1caa6a74e65d5773ca353d41ce6900ed900a34f4013430a25afeba82febc5667b91e4f3a1a46ebc60e52d3fb49dc4e620030effedf8a7879dccd2ae17838458caf28fc0f15cad63641b41cf326fb55fb91e59145f935d8dbe0e8f287c56f5a26abbcf86256e3ea1a5e8dd3faf8a1b4b11630f9b7e8f9be6836830c7b4cca443d0d3e68c12270f656ff7a0d103954ed919974d76340356bab5f506303734a31851e00dd84c0aa21a18f64bedb096fd2e650f767d24ca2ec4256975f11307c68fb1420a1b927e76d070f7fbc64afb0f0b6a7c3911392ae456d385d33aabf6eaeabe23bc44573b536b7f3be66c7110c7327f676c0423a4ac910ae699cc00b3ad0c0154402bc3c2980624199cbf519c3596032529bc4c0b6dc3b0808918c3db6722bf366ff6b2081c78107af30c53f346e5273069107f190eba9a62d6e25e65ad0bbbd4617df4b01f01094895ec972f396efb381b8ddca7595fcbfe0877900443195fa81bfa01ec9d5ee462572061a03b7d87e0953af2da77faf2e6e625ca205cbb3b87e2826c70693c7d1b0e8528238cbe6483f3cfcf708c99ec2c8d6c66538b37898773fbf53e79fbaa93a4f430b2784fedee60cb62c3235abe47406a4bb5817804581b5f31f4e6dde898d6a1fa7225e59e229fe75724ff0fed1f77f1e7b9a0d48436b6d7b0f8c485918627af57ed8570cc48319faa7740d399e4b75ec506883761eeaa9a93bf4ebcca72e2e6b8e55a4e291ee4fe5abe9748b3dff268b32953a82397681254bb941102a23286f7dcf03aa720f24ada51be604648f37c1f6408670106c783e1577fa0e4dd6c1ecb9415a014faa7ad      </script>      <div class="hbe hbe-content">        <div class="hbe hbe-input hbe-input-default">          <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">          <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">            <span class="hbe hbe-input-label-content hbe-input-label-content-default" data-content="联系站长以查看密码">联系站长以查看密码</span>          </label>        </div>        <button class="hbe hbe-confirm"></button>      </div>    </div>    ]]></content>
    
    
    <summary type="html">联系站长以查看密码</summary>
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-07-杂谈-复杂异构系统监控与可视化项目设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/51477.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/51477.html</id>
    <published>2025-12-07T13:09:33.000Z</published>
    <updated>2025-12-26T10:56:50.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复杂异构系统监控与可视化项目设计"><a href="#复杂异构系统监控与可视化项目设计" class="headerlink" title="复杂异构系统监控与可视化项目设计"></a><strong>复杂异构系统监控与可视化</strong>项目设计</h2><h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><p>现在需要设计一个系统，使用 py 的 fastapi 作为后端</p><p>目前有一个使用 Docker Compose 编排的复杂容器化环境，基于 SeedEmu（SEED Internet Emulator）框架构建。该框架专用于模拟大规模互联网基础设施，常用于网络安全研究、教育和实验，特别是区块链网络的安全性测试。<br>此 docker-compose.yml 定义了一个模拟的互联网环境，其中部署了一个完整的 Ethereum Proof-of-Stake (PoS) 区块链网络，分布在多个自治系统（Autonomous Systems, AS）中，并通过互联网交换点（Internet Exchange Points, IXP）和路由器实现互联。该环境的主要目的是模拟真实互联网拓扑下的区块链网络行为，支持研究区块链在复杂网络环境下的安全性、性能、攻击与防御（如 Eclipse 攻击、分区攻击、路由攻击等），并提供可视化监控、数据采集和分析工具。</p><p>主要组件与功能有：数据库与辅助服务，包括用于存储区块链监控数据的 postgresql（数据库名为 ethereum_monitor），作为缓存或消息队列的 redis，以及用于存储和分析网络拓扑、区块链节点关系等复杂关系数据的图数据库 neo4j。</p><p>Ethereum 区块链网络在 AS 101–112（共 12 个自治系统）中部署了大量 Ethereum PoS 节点。每个 AS 内部包含 3 个本地网络（inet0、inet1、inet2），每个网络内有 3 个 Ethereum 节点（共 9 个节点/AS）。总计约 108 个 Ethereum validator/miner 节点（节点 ID 从 2 到 108），加上一个 BootNode 和 BeaconSetup 节点。所有节点运行在自定义的链上（chain_id: 1337, chain_name: posCurrentEnhancedNet）。部分节点（如 AS101 的 host0）暴露了 JSON-RPC (8545)、WebSocket (8546) 和 Web 界面 (8000) 端口，便于外部交互。</p><p>网络路由基础设施基于 SeedEmu，AS 2 作为一个骨干/中转 AS，包含四个边界路由器（r51–r54），通过点对点链路（net_2_net_51_52 等）连接。IXP（互联网交换点）包括四个全球 IXP（ix51–ix54），每个有 Route Server（路由服务器），用于多边对等互联。AS 21–24 作为 IXP 的参与者（peering AS），每个连接一个 IXP。AS 101–112 每个 AS 有一个边界路由器连接到对应的 IXP（例如 AS101 连接 ix51），实现与外部互联网的连通。所有路由器运行真实路由协议（如 BGP），支持模拟路由攻击、劫持等。</p><p>可视化与监控工具包括运行 SeedEmu 的互联网拓扑可视化界面的 seedemu-internet-client，映射端口 8080，提供整个网络拓扑的图形化视图，以及运行 Ethereum 网络专用可视化界面的 seedemu-ether-client，映射端口 5000，用于查看区块链节点状态、同步情况、交易等。eth_node_cleaner 是自定义服务，暴露端口 8888，可能用于中央数据收集、节点状态清理或监控指标聚合，连接 PostgreSQL、Redis 和 Neo4j。</p><p>其他特性包括大量自定义网络（local 和 global 类型），精确分配 IP 地址段，节点标签丰富（org.seedsecuritylabs.seedemu.meta.*），便于 SeedEmu 工具识别和渲染，部分服务使用 privileged 模式和 cap_add: ALL，以支持模拟路由所需的网络权限。</p><p>现在需要实现一系列功能，提供基于 FastAPI 框架的 RESTful API 路由模块（topology_router），专用于提供区块链仿真环境（特别是结合 SeedEmu 和 Ethereum PoS 网络）的完整拓扑数据访问接口如下：GET /overview 获取整个仿真环境的拓扑概览信息（如节点总数、层级结构等）；GET /statistics 获取拓扑统计数据（如节点、链路数量等汇总指标）；GET /health 检查拓扑服务的健康状态，返回组件运行状况。</p><p>GET /ethereum 获取完整的以太坊网络拓扑数据（节点与 P2P 连接）；GET /ethereum/nodes 获取所有以太坊节点列表，支持按层级过滤（execution 或 consensus）；GET /ethereum/nodes/{node_id}获取指定以太坊节点（执行层或共识层）的详细信息；GET /ethereum/validators/{validator_id}根据验证者公钥获取单个验证者节点的详细状态和信息。</p><p>GET /physical 获取纯物理拓扑结构（不包含容器运行时监控数据）；GET /physical/devices 获取物理设备列表（路由器、主机等），支持按设备类型过滤；GET /physical/links 获取物理链路（网络连接）列表，支持按连接类型过滤；GET /physical/networks 获取所有物理网络的配置信息（网络 ID、名称、子网、网关等）。</p><p>GET /contract 获取智能合约相关的拓扑视图（合约部署、调用关系等）；GET /contract/statistics 获取合约层面的统计信息（如合约数量、调用频率等）。</p><p>GET /transaction 获取交易拓扑数据，支持通过时间范围（start_time 和 end_time）过滤；GET /transaction/statistics 获取交易层面的统计信息；GET /transaction/address/{address}/analysis 分析特定以太坊地址的资金/交易流向（流入流出关系图）。</p><p>GET /layer/{layer}根据指定拓扑层（枚举值，如 ethereum、physical 等）获取对应层级的完整拓扑数据；POST /combined 支持组合多个拓扑层（如以太坊层+物理层）生成统一的拓扑视图，可指定渲染格式。</p><p>POST /render 接收任意拓扑数据和渲染请求（格式如 cytoscape、graphviz 等），返回经过布局算法处理的可直接用于前端可视化的数据。</p><p>GET /nodes/{node_id}获取任意节点（跨层级）的详细信息，支持指定层级；GET /analysis/{layer}对指定层级进行网络分析（如连通性、中心性、社区检测等指标）。</p><p>POST /cache/clear 清空服务内部所有缓存（用于强制刷新数据）；GET /debug/info 获取详细的调试信息，包括服务组件状态、各处理器缓存大小、支持的层级与渲染格式等，便于开发与运维排查。</p><hr><h2 id="针对该环境和需求的系统设计方案"><a href="#针对该环境和需求的系统设计方案" class="headerlink" title="针对该环境和需求的系统设计方案"></a>针对该环境和需求的<strong>系统设计方案</strong></h2><p>需要设计一个 FastAPI 后端，它充当一个”中间层（Middleware）”或”聚合层（Aggregator）”，将底层分散的基础设施（Docker）、网络拓扑（SeedEmu/Neo4j）和应用状态（Ethereum/PostgreSQL）整合成统一的 API 暴露给前端</p><h3 id="1-系统架构概览"><a href="#1-系统架构概览" class="headerlink" title="1. 系统架构概览"></a>1. 系统架构概览</h3><p>由于涉及 140+ 容器和多种数据源，系统的核心挑战在于数据聚合和性能优化。建议采用分层架构，包括前端/可视化大屏与 FastAPI 网关的交互，以及 FastAPI 后端应用内的 Redis 缓存层、业务逻辑层 TopologyService，和各种适配器（Docker Adapter、Neo4j Adapter、Ethereum Adapter Web3.py、DB Adapter SQLAlchemy）的协作，最终与基础设施 Docker Compose 中的 Docker Socket、Neo4j 图数据库、JSON-RPC AS101 Host0 和 PostgreSQL ethereum_monitor 进行交互。</p><h3 id="2-核心模块设计"><a href="#2-核心模块设计" class="headerlink" title="2. 核心模块设计"></a>2. 核心模块设计</h3><p>我们需要将代码组织为清晰的模块，以应对你列出的 9 大类接口。</p><h4 id="2-1-数据模型层-Models-Schemas"><a href="#2-1-数据模型层-Models-Schemas" class="headerlink" title="2.1 数据模型层 (Models/Schemas)"></a>2.1 数据模型层 (Models/Schemas)</h4><p>使用 Pydantic 定义统一的拓扑数据结构，这是所有接口返回的基础。网络拓扑系统采用了分层架构设计，主要包括以下几个层级：API 层 - topology_api.py 提供 RESTful 接口，服务层 - topology_service.py 协调各种拓扑功能，数据层 - real_topology_service.py 处理真实数据获取，专门处理器层 - 处理合约、交易等特定类型的拓扑，管理与渲染层 - 负责生命周期管理和数据渲染。</p><p>用户通过 API 请求拓扑数据（如 /topology/ethereum），API 调用 TopologyService 的 get_ethereum_topology() 方法，TopologyService 委托给 _real_data_service（即 RealTopologyService），RealTopologyService 从 Neo4j 数据库获取真实的以太坊 P2P 网络拓扑数据，数据经过处理和格式化后返回给用户。</p><p>对于以太坊拓扑，从 Neo4j 数据库查询执行层和共识层节点及其连接关系，查询验证者节点并与共识节点关联，将原始数据转换为前端友好的拓扑格式，通过 Docker 客户端获取容器信息，建立 IP 地址与容器名称的映射。对于物理拓扑，通过 Docker 客户端获取所有容器的详细信息，根据容器名称识别设备类型（路由器、主机等），根据容器连接的网络建立设备间连接关系，使用共享网络原则确定设备连接。</p><p>在 topology_interfaces.py 中定义了核心抽象类：TopologyNode 作为拓扑节点基类，包含 id（节点唯一标识）、name（节点名称）、node_type（节点类型，执行层、共识层、验证者等）、ip_address（IP 地址）、layer（所属层级）、status（状态）、metadata（元数据）等属性；TopologyLink 作为拓扑连接基类，包含 source（源节点 ID）、target（目标节点 ID）、link_type（连接类型）、layer（所属层级）、direction（连接方向）、metadata（元数据）等属性。</p><p>不同类型的拓扑节点包括以太坊节点（执行层节点、共识层节点、验证者节点）和物理节点（路由器、主机、交换机）。拓扑数据最终以 nodes（节点列表，每个节点包含 id、name、type、ip_address、status 等属性）、links（连接列表，每个连接包含 source、target、type 等属性）、元数据（时间戳、数据源、统计信息等）的格式组织。</p><p>这是与底层交互的关键。InfrastructureAdapter (Docker &amp; SeedEmu) 作用是获取物理拓扑，实现方式是使用 docker Python 库读取容器列表，解析 com.docker.compose.service 和 org.seedsecuritylabs.seedemu.meta.<em> 标签来识别节点角色（AS、路由器、主机）；对应接口是 /physical/</em>。</p><p>GraphDBAdapter (Neo4j) 作用是获取网络静态拓扑和关联关系，实现方式是使用 neo4j Python 驱动，SeedEmu 通常会将生成的拓扑导入 Neo4j，查询 Cypher 语句来获取节点间的连接；对应接口是 /overview, /analysis/{layer}。</p><p>BlockchainAdapter (Web3.py &amp; Postgres) 作用是获取链上实时状态，实现方式是使用 web3.py (AsyncHTTPProvider) 连接开放 RPC 端口的节点（如 AS101 的 8545）获取 Block Height, Peer Count，以及连接 PostgreSQL (ethereum<em>monitor) 查询交易历史、合约调用统计；对应接口是 /ethereum/</em>, /contract/_, /transaction/*。</p><h4 id="2-3-业务服务层-Services"><a href="#2-3-业务服务层-Services" class="headerlink" title="2.3 业务服务层 (Services)"></a>2.3 业务服务层 (Services)</h4><p>这是实现 RealTopologyService 的地方，负责组装数据。TopologyService 能够根据请求的 layer (physical, ethereum) 调用不同的 Adapter，实现 /combined 接口，将 Docker 的运行状态（Up/Down）注入到 Neo4j 查出的静态拓扑中，并将 Ethereum 节点的逻辑 ID（Validator ID）映射到物理容器 IP。非常重要的是使用 Redis 缓存完整的拓扑 JSON，并设置后台定时任务（FastAPI lifespan 或 APScheduler）每 5-10 秒刷新一次缓存。</p><p>AnalysisService 将拓扑数据加载到 Python 的 networkx 库中，计算中心性（Centrality）、最短路径（用于分析攻击传播）、社区发现等算法；对应接口是 /analysis/*。</p><h3 id="3-具体接口实现策略"><a href="#3-具体接口实现策略" class="headerlink" title="3. 具体接口实现策略"></a>3. 具体接口实现策略</h3><p>针对你提供的文档，以下是具体实现建议：</p><p>物理层 (Physical Layer) 的挑战是如何知道哪个容器连接哪个。方案是 SeedEmu 通常会在生成容器时将连接信息写入 Neo4j 或生成的 metadata 文件。优先从 Neo4j 读取链路关系，从 Docker API 读取节点存活状态（Status: Running/Exited）。</p><p>以太坊层 (Ethereum Layer) 的挑战是 108 个节点，如何获取所有节点状态。方案是使用信标链数据 (Consensus)，连接 Beacon Node API (如果环境中有) 获取验证者状态 (Active/Slashed)；使用 P2P 拓扑，使用 admin_peers RPC 方法（需要节点开启该 API）查询节点的连接对象。由于无法轮询所有 108 个节点，可以只轮询几个关键 Bootnode 和 AS 网关节点，构建局部图；使用 Postgres 补充，从数据库中读取已知的节点列表和 Validator ID 映射。</p><p>交易与合约 (Transaction &amp; Contract) 的挑战是实时分析交易流向。方案是不要直接扫描链，而是利用环境中的 postgresql (ethereum_monitor)。SeedEmu 的监控器应该已经将区块和交易写入库中。接口 /transaction/address/{address}/analysis 直接执行 SQL 聚合查询（Group by to/from），返回资金流向图。</p><p>可视化渲染 (Rendering) 的接口是 POST /render，逻辑是前端可能只需传递原始数据，后端使用 networkx 计算布局（如 ForceAtlas2 或层级布局），计算出每个节点的 (x, y) 坐标，返回给前端直接绘制。这能减轻前端浏览器处理 140+ 节点布局的压力。</p><h3 id="4-代码结构示例"><a href="#4-代码结构示例" class="headerlink" title="4. 代码结构示例"></a>4. 代码结构示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/topology.py</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">from</span> app.schemas.topology <span class="hljs-keyword">import</span> TopologyGraph<br><br>router = APIRouter(prefix=<span class="hljs-string">"/topology"</span>, tags=[<span class="hljs-string">"Topology"</span>])<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/overview"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_overview</span>(<span class="hljs-params">service: TopologyService = Depends(<span class="hljs-params">get_topology_service</span>)</span>):<br>    <span class="hljs-comment"># 从缓存获取，如果无则计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.get_system_overview()<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/ethereum/nodes/{node_id}"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eth_node_detail</span>(<span class="hljs-params">node_id: <span class="hljs-built_in">str</span>, service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 1. 查 Neo4j 获取节点基础信息</span><br>    <span class="hljs-comment"># 2. 查 Docker 确认容器是否在线</span><br>    <span class="hljs-comment"># 3. 查 Web3/DB 获取链上余额和状态</span><br>    data = <span class="hljs-keyword">await</span> service.get_node_composite_info(node_id, layer=<span class="hljs-string">"ethereum"</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"Node not found"</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">"/combined"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_combined_view</span>(<span class="hljs-params">layers: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 融合物理层和区块链层</span><br>    <span class="hljs-comment"># 例如：展示 区块链P2P连线 覆盖在 物理AS拓扑 上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.generate_combined_topology(layers)<br></code></pre></td></tr></table></figure><h3 id="5-关键技术难点与解决方案"><a href="#5-关键技术难点与解决方案" class="headerlink" title="5. 关键技术难点与解决方案"></a>5. 关键技术难点与解决方案</h3><p>Docker 网络访问方面，FastAPI 容器需要挂载 /var/run/docker.sock 才能查询兄弟容器的状态。docker-compose.yml 配置中需要添加 volumes: - /var/run/docker.sock:/var/run/docker.sock。</p><p>跨容器数据库连接方面，连接 Neo4j 和 Postgres 时，Host 应使用 Docker Compose 服务名（如 neo4j, postgresql），而不是 localhost。</p><p>性能瓶颈方面，问题在于/ethereum 接口如果实时调用 100+ 次 RPC 会超时。解决方法是使用”后台采集 + 前端读取”模式，编写一个后台 Task (使用 asyncio 或 Celery) 每 10 秒扫描一次网络状态存入 Redis。API 接口只读 Redis。</p><p>IP 地址管理方面，SeedEmu 的自定义网络（inet0, net_2_net_51_52）非常复杂。在返回 /physical 拓扑时，务必解析 Docker inspect 结果中的 NetworkSettings，将特定网段 IP 映射给前端，否则前端无法理解路由关系。</p><h3 id="6-总结建议"><a href="#6-总结建议" class="headerlink" title="6. 总结建议"></a>6. 总结建议</h3><p>设计这个系统时，请遵循以下步骤：首先打通 Neo4j，它是拓扑的真理来源（Source of Truth），确保能查询出 AS、Router 和 Host 的关系；其次实现缓存机制，复杂的 Docker 集群状态获取很慢，不要让 API 直接穿透到 Docker Daemon；定义清晰的 ID 映射，最大的坑在于关联 “Docker Container Name” (e.g., as101_host0) 和 “Ethereum Node ID” (e.g., Validator-3)，需要在服务启动时建立这个映射表；按层开发，先做 Physical（最简单，只读 Docker），再做 Ethereum（读 DB），最后做高级的 Contract/Transaction 分析。</p><p>实现”实时更新”并”高亮变化”的核心在于结合 FastAPI 的 WebSocket 推送机制与 D3.js 的 General Update Pattern（通用更新模式）。这里有三个关键点：后端推送，只推送最新的全量/增量状态；前端数据绑定，D3 必须通过 Key Function 识别哪些是新节点、哪些是旧节点，而不是每次清空画布重绘；视觉反馈，利用 CSS 动画或 D3 Transition 让变化的节点产生”闪烁”或”颜色渐变”。</p><h3 id="1-整体架构设计"><a href="#1-整体架构设计" class="headerlink" title="1. 整体架构设计"></a>1. 整体架构设计</h3><p>后端 (FastAPI) 运行一个后台任务（Background Task），每隔几秒扫描一次 Docker/Ethereum 状态，通过 WebSocket 广播给前端；前端 (D3.js) 维护一个长连接，收到数据后，执行 updateGraph(newData)。</p><h3 id="2-后端：FastAPI-WebSocket-实现"><a href="#2-后端：FastAPI-WebSocket-实现" class="headerlink" title="2. 后端：FastAPI WebSocket 实现"></a>2. 后端：FastAPI WebSocket 实现</h3><p>我们需要一个 ConnectionManager 来管理前端连接，并推送拓扑数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/ws_topology.py</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, WebSocket, WebSocketDisconnect<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><br>router = APIRouter()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections: <span class="hljs-built_in">list</span>[WebSocket] = []<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-keyword">await</span> websocket.accept()<br>        <span class="hljs-variable language_">self</span>.active_connections.append(websocket)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections.remove(websocket)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">self, message: <span class="hljs-built_in">dict</span></span>):<br>        <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.active_connections:<br>            <span class="hljs-keyword">await</span> connection.send_json(message)<br><br>manager = ConnectionManager()<br><br><span class="hljs-comment"># 模拟后台数据推送任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">topology_broadcaster</span>(<span class="hljs-params">service: TopologyService</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    这个函数需要在 main.py 的 @app.on_event("startup") 中启动</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 获取最新拓扑（包含 Docker 状态 + Geth 连接）</span><br>        topology_data = <span class="hljs-keyword">await</span> service.get_full_topology_snapshot()<br><br>        <span class="hljs-comment"># 广播数据</span><br>        <span class="hljs-keyword">if</span> manager.active_connections:<br>            <span class="hljs-keyword">await</span> manager.broadcast(topology_data)<br><br>        <span class="hljs-comment"># 每 5 秒推送一次，避免前端渲染压力过大</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-meta">@router.websocket(<span class="hljs-params"><span class="hljs-string">"/ws/topology"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">websocket_endpoint</span>(<span class="hljs-params">websocket: WebSocket</span>):<br>    <span class="hljs-keyword">await</span> manager.connect(websocket)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 保持连接活跃，也可以接收前端的控制指令（比如点击了某个节点）</span><br>            data = <span class="hljs-keyword">await</span> websocket.receive_text()<br>    <span class="hljs-keyword">except</span> WebSocketDisconnect:<br>        manager.disconnect(websocket)<br></code></pre></td></tr></table></figure><h3 id="3-前端：D3-js-实时更新与高亮逻辑"><a href="#3-前端：D3-js-实时更新与高亮逻辑" class="headerlink" title="3. 前端：D3.js 实时更新与高亮逻辑"></a>3. 前端：D3.js 实时更新与高亮逻辑</h3><p>这是最关键的部分。不要清空 SVG！使用 D3 的 Enter (新增), Update (更新), Exit (删除) 模式。</p><p>核心策略包括 ID 绑定，告诉 D3 如何通过 ID（如 enode_id 或 container_name）区分节点，而不是数组索引；平滑模拟，数据更新时，不要将 alpha 重置为 1（会导致整个图剧烈爆炸），而是重置为 0.3 左右（轻微调整）；样式 Diff，比对新旧数据，如果状态变化（如 IP 变了，Peer 数变了），添加 CSS 类名触发动画。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;a href=&quot;#复杂异构系统监控与可视化项目设计&quot; class=&quot;headerlink&quot; title=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;复杂异构系统监控与可视化&lt;/strong&gt;项目设计&lt;/h2&gt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-06-杂记-前端图拓扑渲染优化</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/7900.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/7900.html</id>
    <published>2025-12-06T03:25:47.000Z</published>
    <updated>2025-12-14T17:56:13.795Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>性能优化 (Web Workers)</strong>: 目前的数据获取、解析和Diff算法都在<strong>主线程</strong>运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 <strong>Web Worker</strong>。</p></li><li><p><strong>D3 渲染优化</strong>: 目前的设计倾向于每次更新都全量替换 filteredNodes，这会导致 D3 力导向图重新初始化或位置抖动。应该利用 Diff 结果进行<strong>增量渲染 (Enter/Update/Exit)</strong>。</p></li><li><p><strong>状态管理解耦</strong>: useTopologyData 承担了太多职责（数据存储、UI状态、标签逻辑）。应该拆分为“数据层”和“视觉层”。</p></li><li><p><strong>数据结构优化</strong>: 数组查找（.find）效率低，应更多使用 Map/Set 索引。</p></li></ol><h3 id="优化后文件结构"><a href="#优化后文件结构" class="headerlink" title="优化后文件结构"></a>优化后文件结构</h3><p>采用了 <strong>Core (数据核心) + Visual (视觉逻辑) + Worker (后台计算)</strong> 的分层结构。</p><p>codeText</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span>/<br>  ├── types/<br>  │   └── topology<span class="hljs-selector-class">.ts</span>           <span class="hljs-comment">// (保持不变) 类型定义</span><br>  ├── workers/<br>  │   └── topology<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [新] 负责Fetch、解析数据、计算Diff</span><br>  ├── composables/<br>  │   ├── useTopologyCore<span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [优化] 负责与Worker通信，持有原始数据</span><br>  │   ├── useTopologyVisual<span class="hljs-selector-class">.ts</span>  <span class="hljs-comment">// [拆分] 负责过滤、标签、高亮等UI逻辑</span><br>  │   └── useD3Renderer<span class="hljs-selector-class">.ts</span>      <span class="hljs-comment">// [新] 封装D3的具体操作，接受Diff指令</span><br>  └── components/<br>      └── EthereumTopology<span class="hljs-selector-class">.vue</span>  <span class="hljs-comment">// [优化] 变得很薄，只负责组装</span><br></code></pre></td></tr></table></figure><p>现在的以太坊拓扑渲染架构采用了 <strong>“分层响应式架构” (Layered Reactive Architecture)</strong>，结合了 <strong>Web Worker 多线程计算</strong> 和 <strong>D3 增量渲染</strong> 技术。</p><p>这是一种高性能、低耦合的现代前端架构，专门为了处理大量节点（数千级）的实时动态拓扑而设计。</p><p>以下是该架构的详细层级解析：</p><h3 id="1-架构总览图"><a href="#1-架构总览图" class="headerlink" title="1. 架构总览图"></a>1. 架构总览图</h3><p>数据流向是单向的，状态管理是响应式的：</p><p>codeMermaid</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">graph TD<br>    BackEnd[FastAPI 后端] --&gt;|<span class="hljs-type">JSON</span> Stream| <span class="hljs-type">Worker</span>[Web Worker (后台线程)]<br>    <br>    subgraph <span class="hljs-string">"Main Thread (主线程)"</span><br>        Worker --&gt;|<span class="hljs-type">Diff</span> Update (增量/全量)| <span class="hljs-type">Store</span>[useTopologyCore (数据层)]<br>        Store --&gt;|<span class="hljs-type">Raw</span> Data| <span class="hljs-type">Visual</span>[useTopologyVisual (视觉层)]<br>        <br>        subgraph <span class="hljs-string">"UI Components (视图层)"</span><br>            Visual --&gt;|<span class="hljs-type">Filtered</span> Data| <span class="hljs-type">Renderer</span>[useD3Renderer (渲染层)]<br>            Visual --&gt;|<span class="hljs-type">Filters</span>/<span class="hljs-keyword">Mode</span>| <span class="hljs-type">Controls</span>[TopologyVisualization (控制面板)]<br>            Renderer --&gt;|<span class="hljs-type">Click</span> Event| <span class="hljs-type">Details</span>[PhysicalTopology (详情抽屉)]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br>    Renderer --&gt;|<span class="hljs-type">Draw</span>| <span class="hljs-type">DOM</span>[SVG/Canvas]<br></code></pre></td></tr></table></figure><hr><h3 id="2-核心层级详细解析"><a href="#2-核心层级详细解析" class="headerlink" title="2. 核心层级详细解析"></a>2. 核心层级详细解析</h3><h4 id="第一层：数据处理层-Worker-Thread"><a href="#第一层：数据处理层-Worker-Thread" class="headerlink" title="第一层：数据处理层 (Worker Thread)"></a>第一层：数据处理层 (Worker Thread)</h4><p><strong>文件</strong>: workers/topology.worker.ts<br>这是架构的“发动机”，完全脱离主线程运行。</p><ul><li><p><strong>职责</strong>：</p><ol><li><p><strong>数据拉取</strong>：直接发起 Fetch 请求，不占用主线程网络资源。</p></li><li><p><strong>数据清洗</strong>：解析复杂的 JSON 结构，标准化为 TopologyNode 和 TopologyLink。</p></li><li><p><strong>智能 Diff (差异计算)</strong>：</p><ul><li><p>这是性能优化的关键。它对比新旧数据，计算出新增、删除和更新的节点。</p></li><li><p><strong>坐标继承</strong>：在 Worker 中将旧节点的 x, y 坐标赋值给新节点，防止 D3 在数据更新时重新计算布局导致视图“爆炸”或闪烁。</p></li></ul></li></ol></li></ul><h4 id="第二层：状态管理层-Composables"><a href="#第二层：状态管理层-Composables" class="headerlink" title="第二层：状态管理层 (Composables)"></a>第二层：状态管理层 (Composables)</h4><p>这一层利用 Vue 3 的 Composition API 将业务逻辑拆分为独立的模块。</p><ul><li><p><strong>数据持有 (useTopologyCore.ts)</strong>：</p><ul><li><p>与 Worker 通信的桥梁。</p></li><li><p>使用 shallowRef 存储庞大的拓扑数据。<strong>优化点</strong>：shallowRef 不会深度监听节点内部属性的变化（如 x, y 坐标），这极大减轻了 Vue 响应式系统的负担，因为 D3 会直接操作这些原生对象。</p></li></ul></li><li><p><strong>视觉逻辑 (useTopologyVisual.ts)</strong>：</p><ul><li><p><strong>纯粹的计算层</strong>。它不关心数据怎么来的，只关心怎么显示。</p></li><li><p><strong>动态过滤</strong>：利用 computed 属性，根据 filters（如隐藏共识节点）实时生成 filteredNodes。</p></li><li><p><strong>样式映射</strong>：集中管理颜色 (getNodeColor) 和标签 (getNodeLabel) 逻辑，实现逻辑与渲染分离。</p></li></ul></li></ul><h4 id="第三层：渲染驱动层-Render-Engine"><a href="#第三层：渲染驱动层-Render-Engine" class="headerlink" title="第三层：渲染驱动层 (Render Engine)"></a>第三层：渲染驱动层 (Render Engine)</h4><p><strong>文件</strong>: useD3Renderer.ts<br>这是 D3.js 与 Vue 的结合点。</p><ul><li><p><strong>生命周期接管</strong>：它在 onMounted 时初始化 D3 仿真器。</p></li><li><p><strong>增量渲染 (Incremental Rendering)</strong>：</p><ul><li><p>使用 Vue 的 watch 监听过滤后的数据。</p></li><li><p>利用 D3 的 enter(), update(), exit() 模式。</p></li><li><p><strong>Enter</strong>: 新节点淡入。</p></li><li><p><strong>Exit</strong>: 被过滤或删除的节点淡出移除。</p></li><li><p><strong>Update</strong>: 现有节点平滑移动到新位置。</p></li></ul></li><li><p><strong>事件桥接</strong>：将 D3 的 click、drag 事件转换为 Vue 的回调函数，传递给上层组件。</p></li></ul><h4 id="第四层：视图组装层-View-Integration"><a href="#第四层：视图组装层-View-Integration" class="headerlink" title="第四层：视图组装层 (View Integration)"></a>第四层：视图组装层 (View Integration)</h4><p><strong>文件</strong>: EthereumTopology.vue (父组件)<br>这是架构的“容器”和“胶水”。</p><ul><li><p><strong>依赖注入 (Dependency Injection)</strong>：</p><ul><li><p>父组件通过 provide(‘topology-state’, …) 将 mode、filters 等状态下发。</p></li><li><p>子组件 TopologyVisualization 通过 inject 直接获取并修改这些状态。避免了深层 Prop 传递（Prop Drilling）。</p></li></ul></li><li><p><strong>组件编排</strong>：</p><ul><li><p>负责布局：左上角悬浮控制面板、中间 D3 画布、右侧详情抽屉。</p></li><li><p>负责联动：当 D3 点击节点时，控制 showPhysicalDetails 变量来弹出侧边栏。</p></li></ul></li></ul><hr><h3 id="3-关键性能优化点总结"><a href="#3-关键性能优化点总结" class="headerlink" title="3. 关键性能优化点总结"></a>3. 关键性能优化点总结</h3><ol><li><p><strong>非阻塞主线程 (Off-Main-Thread)</strong>:</p><ul><li><p><strong>旧架构</strong>：在组件内 fetch 数据 -&gt; 解析 -&gt; 赋值。数据量大时 UI 会卡顿。</p></li><li><p><strong>新架构</strong>：所有数据处理都在 Worker 中完成，主线程只负责接收“准备好渲染”的数据。</p></li></ul></li><li><p><strong>浅层响应式 (Shallow Reactivity)</strong>:</p><ul><li>使用 shallowRef 代替 ref 存储节点数组。D3 内部高频修改 node.x 和 node.y 时，不会触发 Vue 的依赖更新系统，显著提升动画帧率。</li></ul></li><li><p><strong>状态保持 (State Preservation)</strong>:</p><ul><li>Worker 在处理新数据时，会查找旧数据的 ID，并将 x, y, vx, vy (速度向量) 复制给新数据。这保证了在轮询更新时，节点不会重置位置，实现了“流式”的平滑更新效果。</li></ul></li><li><p><strong>按需计算 (Computed Filtering)</strong>:</p><ul><li>连接 (links) 的过滤依赖于节点 (nodes) 的过滤结果。新架构使用了 Set 来建立索引，将连接过滤的时间复杂度从 O(N*M) 降低到 O(M)（其中 N 是节点数，M 是连接数）。</li></ul></li></ol><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>现在的架构是一个 <strong>“重后台、轻前台、数据驱动视图”</strong> 的专业可视化架构。</p><ul><li><p><strong>Worker</strong> 负责“脏活累活”（数据处理）。</p></li><li><p><strong>D3</strong> 负责“精细活”（物理仿真和绘图）。</p></li><li><p><strong>Vue</strong> 负责“指挥”（状态管理和组件通信）。</p></li></ul><p>这种架构非常适合需要长时间运行、实时监控网络状态的生产级系统。</p><hr><p>根据提供的代码（EthereumTopologyHandler 和 RealTopologyService），以太坊网络拓扑的处理流程是一个<strong>分层获取、数据融合、格式化输出</strong>的过程。核心逻辑依赖于 <strong>Neo4j 图数据库</strong>（存储P2P关系）和 <strong>Docker 守护进程</strong>（提供容器运行时信息）。</p><p>以下是详细的处理步骤解析：</p><h3 id="1-数据源获取-Data-Acquisition"><a href="#1-数据源获取-Data-Acquisition" class="headerlink" title="1. 数据源获取 (Data Acquisition)"></a>1. 数据源获取 (Data Acquisition)</h3><p>系统主要通过两个渠道获取数据：</p><ul><li><p><strong>Neo4j 数据库 (核心数据源)</strong>：存储了爬虫或客户端上报的节点发现数据，包含节点ID、IP、以及节点间的 P2P 连接关系。</p></li><li><p><strong>Docker Client (辅助数据源)</strong>：用于获取运行中容器的实时状态、名称映射和网络设置。</p></li></ul><h3 id="2-核心处理流程"><a href="#2-核心处理流程" class="headerlink" title="2. 核心处理流程"></a>2. 核心处理流程</h3><p>整个拓扑生成的逻辑主要集中在 _get_real_topology_from_neo4j 和 _convert_topology_format 方法中。</p><h4 id="步骤-A：从-Neo4j-提取原始拓扑结构"><a href="#步骤-A：从-Neo4j-提取原始拓扑结构" class="headerlink" title="步骤 A：从 Neo4j 提取原始拓扑结构"></a>步骤 A：从 Neo4j 提取原始拓扑结构</h4><p>代码通过 Cypher 查询语句分三步提取数据：</p><ol><li><p><strong>查询执行层 (Execution Layer)</strong>：</p><ul><li><p>查找所有 ExecNode 标签的节点。</p></li><li><p>查找 EXEC_PEERS_WITH 关系，获取该节点的对等节点（Peers）。</p></li></ul></li><li><p><strong>查询共识层 (Consensus Layer)</strong>：</p><ul><li><p>查找所有 ConsNode 标签的节点。</p></li><li><p>查找 CONS_PEERS_WITH 关系。</p></li></ul></li><li><p><strong>查询验证者 (Validators)</strong>：</p><ul><li><p>查找与共识节点通过 MANAGES_VALIDATOR 关系连接的 Validator 节点。</p></li><li><p>这反映了哪个信标节点（Beacon Node）管理着哪些验证者客户端。</p></li></ul></li></ol><h4 id="步骤-B：容器身份映射-Container-Mapping"><a href="#步骤-B：容器身份映射-Container-Mapping" class="headerlink" title="步骤 B：容器身份映射 (Container Mapping)"></a>步骤 B：容器身份映射 (Container Mapping)</h4><ul><li><p><strong>目的</strong>：数据库中只有 IP 地址，但在前端展示时，最好能显示具体的 Docker 容器名称（如 geth-node-1）。</p></li><li><p><strong>实现</strong>：_create_ip_to_container_mapping 方法遍历所有 Docker 容器，提取其网络设置中的 IP 地址，建立 IP -&gt; ContainerName 的映射表。</p></li></ul><h4 id="步骤-C：构建拓扑对象-Topology-Construction"><a href="#步骤-C：构建拓扑对象-Topology-Construction" class="headerlink" title="步骤 C：构建拓扑对象 (Topology Construction)"></a>步骤 C：构建拓扑对象 (Topology Construction)</h4><p>系统将原始数据转换为前端可视化的 JSON 格式，包含 nodes 和 links。</p><p><strong>1. 节点生成 (Nodes):</strong><br>代码根据逻辑自动计算节点的坐标 (x, y) 以便可视化布局：</p><ul><li><p><strong>执行层节点</strong>：</p><ul><li><p>type: execution</p></li><li><p>位置：固定在 Y=150 的水平线上。</p></li></ul></li><li><p><strong>共识层节点</strong>：</p><ul><li><p>type: consensus</p></li><li><p>位置：固定在 Y=350 的水平线上（位于执行层下方）。</p></li></ul></li><li><p><strong>验证者节点</strong>：</p><ul><li><p>type: validator</p></li><li><p>位置：簇拥在所属共识节点的下方 (y + 60)，通过计算偏移量排成小方阵。</p></li></ul></li></ul><p><strong>2. 连接生成 (Links):</strong><br>系统构建了四种类型的连接：</p><ul><li><p><strong>执行层 P2P (exec_peer)</strong>：基于 Neo4j 中的 EXEC_PEERS_WITH 关系，表示 Geth/Nethermind 节点间的 Gossip 协议连接。</p></li><li><p><strong>共识层 P2P (cons_peer)</strong>：基于 CONS_PEERS_WITH 关系，表示 Lighthouse/Prysm 节点间的连接。</p></li><li><p><strong>管理关系 (manages_validator)</strong>：连接共识节点和它管理的验证者节点。</p></li><li><p><strong>跨层连接 (cross_layer)</strong>：<strong>关键逻辑</strong>。代码会自动匹配 IP 地址相同的执行层节点和共识层节点，并创建一个垂直连接。这代表了以太坊客户端组合（Engine API 通信，例如 Geth &lt;-&gt; Lighthouse 在同一台机器/Pod内）。</p></li></ul><h3 id="3-容错与缓存机制"><a href="#3-容错与缓存机制" class="headerlink" title="3. 容错与缓存机制"></a>3. 容错与缓存机制</h3><p>为了保证性能和稳定性，代码中包含了以下机制：</p><ul><li><p><strong>缓存 (Caching)</strong>：</p><ul><li><p>使用 self.cache 存储计算好的拓扑。</p></li><li><p>设置 cache_ttl (20-30秒)，防止频繁查询 Neo4j 导致数据库过载。</p></li></ul></li><li><p><strong>降级模式 (Fallback - 仅在 Service 中)</strong>：</p><ul><li><p>如果 Neo4j 连接失败或返回空数据，RealTopologyService 会调用 _get_container_based_topology。</p></li><li><p><strong>Fallback 逻辑</strong>：直接扫描 Docker 容器，如果发现名为 ethereum 的容器，就根据容器数量“伪造”一个链式的拓扑结构（非网状），以确保界面上至少能看到节点存在，而不是一片空白。</p></li></ul></li></ul><h3 id="4-统计与验证-Statistics-amp-Validation"><a href="#4-统计与验证-Statistics-amp-Validation" class="headerlink" title="4. 统计与验证 (Statistics & Validation)"></a>4. 统计与验证 (Statistics &amp; Validation)</h3><p>EthereumTopologyHandler 还提供了额外的高级功能：</p><ul><li><p><strong>独立查询</strong>：get_nodes 和 get_links 可以不依赖完整拓扑逻辑，直接查询特定层的数据，提高效率。</p></li><li><p><strong>拓扑验证</strong>：validate_topology 检查数据一致性：</p><ul><li><p>节点 ID 是否唯一。</p></li><li><p>连接的源/目标节点是否存在。</p></li><li><p>是否存在孤立节点。</p></li><li><p>IP 地址分布是否异常（例如一个 IP 运行了超过2个主要节点）。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该系统处理以太坊拓扑的核心思想是：<strong>“数据库定义逻辑关系，Docker 定义物理属性，代码负责视觉组装”</strong>。</p><ol><li><p><strong>逻辑层</strong>：谁连谁？由 Neo4j 决定。</p></li><li><p><strong>物理层</strong>：你是谁？由 Docker IP 映射决定。</p></li><li><p><strong>视觉层</strong>：你在哪？由代码中的分层坐标计算逻辑决定（执行层在上，共识层在中，验证者在下）。</p></li></ol><hr><p>目前的实现逻辑虽然功能完整，但在性能上存在几个显著的<strong>瓶颈</strong>，特别是在节点数量增多或 Docker 容器较多时，响应速度会明显下降。</p><p>以下是针对代码的具体性能优化方案，按<strong>提升幅度从大到小</strong>排序：</p><h3 id="1-痛点分析：目前的性能瓶颈在哪里？"><a href="#1-痛点分析：目前的性能瓶颈在哪里？" class="headerlink" title="1. 痛点分析：目前的性能瓶颈在哪里？"></a>1. 痛点分析：目前的性能瓶颈在哪里？</h3><ol><li><p><strong>Docker API 调用过于频繁 (主要瓶颈)</strong>：</p><ul><li><p>_create_ip_to_container_mapping 每次生成拓扑都会被调用。它会遍历<strong>所有</strong>容器并检查网络设置。Docker API 的响应通常是毫秒级到秒级的，如果不缓存，这会严重阻塞主线程。</p></li><li><p>在物理拓扑中，_get_link_bandwidth 会对每个连接进入容器执行 tc 命令。如果有 50 个连接，就要串行执行 50 次 docker exec，这是极慢的 IO 操作。</p></li></ul></li><li><p><strong>串行数据库查询</strong>：</p><ul><li>在 _get_real_topology_from_neo4j 中，执行层查询及处理完之后，才开始共识层的查询。这两者没有依赖关系，完全可以并行。</li></ul></li><li><p><strong>计算密集型的重复操作</strong>：</p><ul><li>每次请求都重新计算所有节点的坐标和映射关系，即使数据没有变化。</li></ul></li></ol><hr><h3 id="2-优化方案一：Docker-数据的独立缓存与后台更新"><a href="#2-优化方案一：Docker-数据的独立缓存与后台更新" class="headerlink" title="2. 优化方案一：Docker 数据的独立缓存与后台更新"></a>2. 优化方案一：Docker 数据的独立缓存与后台更新</h3><p>Docker 的元数据（IP、容器名）变化频率远低于 P2P 网络连接的变化频率。<strong>不要在每次请求拓扑时都去查询 Docker。</strong></p><p><strong>优化策略：</strong> 使用“读写分离”的策略，后台任务更新 Docker 映射，前台请求只读内存变量。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 原有初始化 ...</span><br>        <span class="hljs-variable language_">self</span>.ip_container_map_cache = {}<br>        <span class="hljs-variable language_">self</span>.map_last_update = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.map_update_lock = asyncio.Lock()<br>        <br>        <span class="hljs-comment"># 启动时预热</span><br>        <span class="hljs-comment"># 注意：实际代码中建议使用 apscheduler 或 asyncio.create_task 在后台循环运行</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_ip_to_container_map_optimized</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化后的获取映射方法：</span><br><span class="hljs-string">        1. 优先返回内存缓存</span><br><span class="hljs-string">        2. 缓存过期（如5分钟）才异步更新</span><br><span class="hljs-string">        """</span><br>        current_time = time.time()<br>        <span class="hljs-comment"># 缓存有效期设为 300秒 (Docker容器IP不会频繁变动)</span><br>        <span class="hljs-keyword">if</span> current_time - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br><br>        <span class="hljs-comment"># 如果需要更新，且未被锁定</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.map_update_lock.locked():<br>             <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.map_update_lock:<br>                 <span class="hljs-comment"># 二次检查</span><br>                 <span class="hljs-keyword">if</span> time.time() - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span>: <br>                     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br>                 <br>                 <span class="hljs-comment"># 执行耗时的 Docker 查询</span><br>                 <span class="hljs-comment"># 建议：在一个线程池中运行同步的 docker client 操作，避免阻塞事件循环</span><br>                 loop = asyncio.get_running_loop()<br>                 <span class="hljs-variable language_">self</span>.ip_container_map_cache = <span class="hljs-keyword">await</span> loop.run_in_executor(<br>                     <span class="hljs-literal">None</span>, <span class="hljs-variable language_">self</span>._create_ip_to_container_mapping<br>                 )<br>                 <span class="hljs-variable language_">self</span>.map_last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br></code></pre></td></tr></table></figure><h3 id="3-优化方案二：物理拓扑带宽检测的“非阻塞化”"><a href="#3-优化方案二：物理拓扑带宽检测的“非阻塞化”" class="headerlink" title="3. 优化方案二：物理拓扑带宽检测的“非阻塞化”"></a>3. 优化方案二：物理拓扑带宽检测的“非阻塞化”</h3><p>在 RealTopologyService 中，物理连接的带宽检测（tc 命令）是极其耗时的。绝对不能在用户请求 API 时实时去跑 tc 命令。</p><p><strong>优化策略：</strong> 将带宽数据设为“最终一致性”。主接口只返回拓扑结构，带宽字段先返回缓存值或 “Checking…”，后台任务专门负责轮询更新带宽。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealTopologyService</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-variable language_">self</span>.bandwidth_cache = {} <span class="hljs-comment"># Key: "container_ip", Value: "100Mbit"</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_dynamic_physical_topology_from_containers</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 前面生成 nodes 和 links 的逻辑保持不变 ...</span><br>        <br>        <span class="hljs-comment"># --- 优化点：移除实时 await _get_link_bandwidth ---</span><br>        <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>            target_id = link[<span class="hljs-string">'target'</span>]<br>            target_node = nodes_by_id[target_id]<br>            container_name = target_node[<span class="hljs-string">'container_name'</span>]<br>            link_ip = target_node[<span class="hljs-string">'networks'</span>].get(link[<span class="hljs-string">'shared_network'</span>])<br>            <br>            <span class="hljs-comment"># 1. 尝试从缓存获取</span><br>            cache_key = <span class="hljs-string">f"<span class="hljs-subst">{container_name}</span>::<span class="hljs-subst">{link_ip}</span>"</span><br>            cached_bw = <span class="hljs-variable language_">self</span>.bandwidth_cache.get(cache_key)<br>            <br>            <span class="hljs-keyword">if</span> cached_bw:<br>                link[<span class="hljs-string">'bandwidth'</span>] = cached_bw<br>            <span class="hljs-keyword">else</span>:<br>                link[<span class="hljs-string">'bandwidth'</span>] = <span class="hljs-string">"Querying..."</span><br>                <span class="hljs-comment"># 2. 触发后台更新任务 (Fire and Forget)</span><br>                asyncio.create_task(<span class="hljs-variable language_">self</span>._update_bandwidth_cache(container_name, link_ip, cache_key))<br>                <br>        <span class="hljs-keyword">return</span> nodes, links<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bandwidth_cache</span>(<span class="hljs-params">self, container_name, link_ip, cache_key</span>):<br>        <span class="hljs-string">"""后台单独更新带宽"""</span><br>        bw = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>._get_link_bandwidth(container_name, link_ip)<br>        <span class="hljs-variable language_">self</span>.bandwidth_cache[cache_key] = bw<br></code></pre></td></tr></table></figure><h3 id="4-优化方案三：Neo4j-并发查询"><a href="#4-优化方案三：Neo4j-并发查询" class="headerlink" title="4. 优化方案三：Neo4j 并发查询"></a>4. 优化方案三：Neo4j 并发查询</h3><p>Neo4j 的 Python Driver (尤其是 Bolt 协议) 支持并发。执行层和共识层的查询是独立的，可以使用 asyncio.gather 同时发起查询。</p><p><strong>注意</strong>：这需要你的 database_manager 支持异步操作。如果底层是同步驱动，可以用 run_in_executor 包装。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 EthereumTopologyHandler 中</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_real_topology_from_neo4j</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Dict</span>, <span class="hljs-type">Dict</span>]:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># ... 连接检查 ...</span><br><br>            <span class="hljs-comment"># 定义查询函数</span><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_exec</span>():<br>                <span class="hljs-comment"># 这里假设 database_manager 提供了某种异步执行方式，</span><br>                <span class="hljs-comment"># 或者我们将同步的 session.run 放入线程池</span><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        result = session.run(<span class="hljs-string">"MATCH (n:ExecNode)..."</span>) <span class="hljs-comment"># 填入完整的 Cypher</span><br>                        <span class="hljs-keyword">return</span> {r[<span class="hljs-string">'node_id'</span>]: ... <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result} <span class="hljs-comment"># 处理结果</span><br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_cons_and_validators</span>():<br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        <span class="hljs-comment"># 合并共识节点和验证者的查询逻辑，减少一次 session 创建开销</span><br>                        cons_result = session.run(<span class="hljs-string">"MATCH (n:ConsNode)..."</span>) <br>                        <span class="hljs-comment"># ... 处理共识 ...</span><br>                        validator_result = session.run(<span class="hljs-string">"MATCH ... validators ..."</span>)<br>                        <span class="hljs-comment"># ... 处理验证者 ...</span><br>                        <span class="hljs-keyword">return</span> cons_data<br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-comment"># 并发执行</span><br>            exec_nodes_data, cons_nodes_data = <span class="hljs-keyword">await</span> asyncio.gather(<br>                fetch_exec(), <br>                fetch_cons_and_validators()<br>            )<br><br>            <span class="hljs-keyword">return</span> exec_nodes_data, cons_nodes_data<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># ... Error handling</span><br></code></pre></td></tr></table></figure><h3 id="5-优化方案四：Cypher-查询语句优化"><a href="#5-优化方案四：Cypher-查询语句优化" class="headerlink" title="5. 优化方案四：Cypher 查询语句优化"></a>5. 优化方案四：Cypher 查询语句优化</h3><p>目前的 Cypher 使用了 OPTIONAL MATCH 和 collect，这在数据量大时比较慢。</p><p><strong>原查询：</strong></p><p>codeCypher</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">MATCH (n:ExecNode)<br>OPTIONAL MATCH (n)-<span class="hljs-selector-attr">[r:EXEC_PEERS_WITH]</span>-&gt;(p:ExecNode)<br>RETURN ... <span class="hljs-built_in">collect</span>(...)<br></code></pre></td></tr></table></figure><p>如果在节点很多的情况下，这个查询会扫描整个图。</p><p><strong>优化建议：</strong></p><ol><li><p><strong>分批次</strong>：如果节点超过 1000 个，不要一次性 collect 所有 Peers。前端通常不需要展示所有几千条连线（会卡死浏览器）。可以限制返回的 Peer 数量，例如 LIMIT 10。</p></li><li><p><strong>索引</strong>：确保 node_id, ip 在 Neo4j 中建立了索引 (CREATE INDEX ON :ExecNode(node_id)).</p></li><li><p><strong>只查 ID</strong>：先查出所有 Node 的基础信息，再查 Relation 表（Links），在内存中组装，通常比 Graph DB 做复杂的聚合（Map/Collect）要快。</p></li></ol><h3 id="6-综合改进后的代码结构建议"><a href="#6-综合改进后的代码结构建议" class="headerlink" title="6. 综合改进后的代码结构建议"></a>6. 综合改进后的代码结构建议</h3><p>这里给出一个集成优化思路的 EthereumTopologyHandler 核心方法重构示例：</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-comment"># ... init ...</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_topology</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        <span class="hljs-string">"""获取完整的以太坊拓扑 (优化版)"""</span><br>        <span class="hljs-comment"># 1. 检查拓扑缓存 (Short TTL: e.g., 5s)</span><br>        <span class="hljs-comment"># 拓扑结构变化很快，缓存时间短一点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._is_cache_valid(<span class="hljs-string">"full_ethereum_topology"</span>, ttl=<span class="hljs-number">5</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>]<br><br>        <span class="hljs-comment"># 2. 并行获取数据</span><br>        <span class="hljs-comment"># A. 获取 Docker 映射 (从长效缓存或后台任务获取，极快)</span><br>        <span class="hljs-comment"># B. 获取 Neo4j 数据 (并发查询)</span><br>        <br>        task_docker = <span class="hljs-variable language_">self</span>._get_ip_to_container_map_optimized() <span class="hljs-comment"># 优化点1</span><br>        task_neo4j = <span class="hljs-variable language_">self</span>._get_real_topology_from_neo4j()       <span class="hljs-comment"># 优化点3 (并发内部实现)</span><br>        <br>        ip_map, (exec_data, cons_data) = <span class="hljs-keyword">await</span> asyncio.gather(task_docker, task_neo4j)<br><br>        <span class="hljs-comment"># 3. 转换数据 (CPU 密集型)</span><br>        <span class="hljs-comment"># 如果节点数非常多 (&gt;5000)，可以考虑放入 ProcessPoolExecutor</span><br>        nodes, links = <span class="hljs-variable language_">self</span>._convert_topology_format_optimized(exec_data, cons_data, ip_map)<br><br>        topology_data = {<br>            <span class="hljs-string">'nodes'</span>: nodes, <span class="hljs-string">'links'</span>: links, <span class="hljs-string">'timestamp'</span>: time.time(),<br>            <span class="hljs-comment"># ...</span><br>        }<br><br>        <span class="hljs-comment"># 更新缓存</span><br>        <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>] = topology_data<br>        <span class="hljs-variable language_">self</span>.last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> topology_data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_convert_topology_format_optimized</span>(<span class="hljs-params">self, exec_data, cons_data, ip_map</span>):<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化点：</span><br><span class="hljs-string">        1. 使用 ip_map.get 避免重复循环</span><br><span class="hljs-string">        2. 预计算 positions 字典，避免列表遍历查找</span><br><span class="hljs-string">        """</span><br>        nodes = []<br>        links = []<br>        <span class="hljs-comment"># 使用字典加速查找: key=node_id, value={idx, type, ...}</span><br>        node_lookup = {} <br>        <br>        <span class="hljs-comment"># ... 处理 Exec 节点 ...</span><br>        <span class="hljs-keyword">for</span> i, (nid, data) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exec_data.items()):<br>            <span class="hljs-comment"># 直接查预热好的 Map，O(1)</span><br>            container = ip_map.get(data[<span class="hljs-string">'ip'</span>], <span class="hljs-string">f"exec-<span class="hljs-subst">{data[<span class="hljs-string">'ip'</span>]}</span>"</span>)<br>            <span class="hljs-comment"># ... 创建 node ...</span><br>            node_lookup[nid] = {<span class="hljs-string">'type'</span>: <span class="hljs-string">'execution'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-string">f'<span class="hljs-subst">{nid}</span>-exec'</span>}<br>            <br>        <span class="hljs-comment"># ... 处理 Cons 节点 ...</span><br>        <br>        <span class="hljs-comment"># ... 处理连接 ...</span><br>        <span class="hljs-comment"># 只需要遍历一次 exec_data 的 peers，利用 node_lookup 快速验证</span><br>        <span class="hljs-keyword">for</span> nid, data <span class="hljs-keyword">in</span> exec_data.items():<br>             source_full_id = <span class="hljs-string">f"<span class="hljs-subst">{nid}</span>-exec"</span><br>             <span class="hljs-keyword">for</span> peer <span class="hljs-keyword">in</span> data.get(<span class="hljs-string">'peers'</span>, []):<br>                 target_nid = peer[<span class="hljs-string">'peer_id'</span>]<br>                 <span class="hljs-comment"># O(1) 检查目标是否存在</span><br>                 <span class="hljs-keyword">if</span> target_nid <span class="hljs-keyword">in</span> node_lookup <span class="hljs-keyword">and</span> node_lookup[target_nid][<span class="hljs-string">'type'</span>] == <span class="hljs-string">'execution'</span>:<br>                     links.append({<br>                         <span class="hljs-string">'source'</span>: source_full_id,<br>                         <span class="hljs-string">'target'</span>: <span class="hljs-string">f"<span class="hljs-subst">{target_nid}</span>-exec"</span>,<br>                         <span class="hljs-comment"># ...</span><br>                     })<br>                     <br>        <span class="hljs-keyword">return</span> nodes, links<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>要进行性能优化，最关键的修改是：</p><ol><li><p><strong>Docker 映射</strong>：改为后台定时更新或长缓存，不要每秒都去 inspect 容器。</p></li><li><p><strong>物理带宽 (tc)</strong>：改为异步/后台获取，不要阻塞 API 响应。</p></li><li><p><strong>Neo4j</strong>：使用并发查询，并限制 Cypher 复杂度。</p></li></ol><hr><h2 id="攻击方式（Attack-Strategies）"><a href="#攻击方式（Attack-Strategies）" class="headerlink" title="攻击方式（Attack Strategies）"></a>攻击方式（Attack Strategies）</h2><p>系统目前支持以下6种攻击方式：</p><h3 id="1-节点断网攻击（Node-Disconnection-Attack）"><a href="#1-节点断网攻击（Node-Disconnection-Attack）" class="headerlink" title="1. 节点断网攻击（Node Disconnection Attack）"></a>1. 节点断网攻击（Node Disconnection Attack）</h3><p>通过网络隔离手段切断目标节点与其他节点的连接。支持的方法包括：</p><ul><li><code>interface_down</code>: 禁用网络接口</li><li><code>route_flush</code>: 清除路由表</li><li><code>firewall_block</code>: 防火墙阻断</li><li><code>p2p_block</code>: P2P连接阻断</li></ul><h3 id="2-通信干扰攻击（Communication-Interference-Attack）"><a href="#2-通信干扰攻击（Communication-Interference-Attack）" class="headerlink" title="2. 通信干扰攻击（Communication Interference Attack）"></a>2. 通信干扰攻击（Communication Interference Attack）</h3><p>通过大量无效通信干扰目标节点正常通信。支持的方法包括：</p><ul><li><code>json_rpc_flood</code>: JSON-RPC请求泛洪</li><li><code>p2p_flood</code>: P2P消息泛洪</li><li><code>memory_exhaustion</code>: 内存耗尽攻击</li></ul><h3 id="3-时间攻击（Timestamp-Attack）"><a href="#3-时间攻击（Timestamp-Attack）" class="headerlink" title="3. 时间攻击（Timestamp Attack）"></a>3. 时间攻击（Timestamp Attack）</h3><p>针对共识机制的时间同步进行攻击。支持的方法包括：</p><ul><li>time_shift: 时间偏移</li><li><code>ntp_block</code>: 阻断NTP时间同步</li><li><code>time_drift</code>: 时间漂移</li></ul><h3 id="4-简化Sybil攻击（Simplified-Sybil-Attack）"><a href="#4-简化Sybil攻击（Simplified-Sybil-Attack）" class="headerlink" title="4. 简化Sybil攻击（Simplified Sybil Attack）"></a>4. 简化Sybil攻击（Simplified Sybil Attack）</h3><p>创建虚假节点来影响网络。可以配置：</p><ul><li>虚假节点数量（1-20）</li><li>节点类型（轻节点、全节点、验证者节点）</li><li>网络环境（主网、测试网、开发网）</li><li>连接真实节点选项</li></ul><h3 id="5-存储攻击（Storage-Attack）"><a href="#5-存储攻击（Storage-Attack）" class="headerlink" title="5. 存储攻击（Storage Attack）"></a>5. 存储攻击（Storage Attack）</h3><p>针对节点存储系统的攻击。支持的方法包括：</p><ul><li><code>disk_fill</code>: 磁盘空间填充</li><li><code>database_corruption</code>: 数据库损坏</li><li><code>state_pollution</code>: 状态污染</li><li><code>chain_data_spam</code>: 链上数据垃圾信息</li></ul><h3 id="6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）"><a href="#6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）" class="headerlink" title="6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）"></a>6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）</h3><p>针对特定以太坊客户端的攻击。支持的方法包括：</p><ul><li><code>process_kill</code>: 终止进程</li><li><code>db_corruption</code>: 数据库损坏</li><li><code>port_blocking</code>: 端口阻断</li><li><code>config_modification</code>: 配置文件修改</li></ul><h2 id="攻击模式（Execution-Modes）"><a href="#攻击模式（Execution-Modes）" class="headerlink" title="攻击模式（Execution Modes）"></a>攻击模式（Execution Modes）</h2><p>系统支持三种攻击执行模式：</p><h3 id="1-一次性攻击（One-shot）"><a href="#1-一次性攻击（One-shot）" class="headerlink" title="1. 一次性攻击（One-shot）"></a>1. 一次性攻击（One-shot）</h3><p>执行一次攻击，持续指定时间后自动清理恢复。 配置参数：</p><ul><li>duration_seconds: 攻击持续时间（秒）</li></ul><h3 id="2-重复攻击（Repeated）"><a href="#2-重复攻击（Repeated）" class="headerlink" title="2. 重复攻击（Repeated）"></a>2. 重复攻击（Repeated）</h3><p>按指定间隔重复执行多次攻击。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>repeat_count: 重复次数</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h3 id="3-持续攻击（Continuous）"><a href="#3-持续攻击（Continuous）" class="headerlink" title="3. 持续攻击（Continuous）"></a>3. 持续攻击（Continuous）</h3><p>持续不断地执行攻击，直到手动停止。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h2 id="动态目标攻击"><a href="#动态目标攻击" class="headerlink" title="动态目标攻击"></a>动态目标攻击</h2><p>系统还支持一种特殊的动态目标攻击功能，可以根据网络拓扑分析结果自动选择攻击目标。支持的中心性指标包括：</p><ul><li>度中心性（Degree Centrality）</li><li>介数中心性（Betweenness Centrality）</li><li>接近中心性（Closeness Centrality）</li><li>特征向量中心性（Eigenvector Centrality）</li></ul><p>通过这些攻击方式和模式的组合，系统可以模拟各种真实的以太坊网络攻击场景，帮助评估网络的安全性和鲁棒性。</p><hr><h3 id="1-发起普通攻击-Standard-Attack"><a href="#1-发起普通攻击-Standard-Attack" class="headerlink" title="1. 发起普通攻击 (Standard Attack)"></a>1. 发起普通攻击 (Standard Attack)</h3><p>此接口用于对<strong>明确指定的静态 IP 列表</strong>发起攻击。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate</p></li><li><p><strong>功能</strong>: 发起针对特定静态目标（IP/ID列表）的攻击模拟。</p></li><li><p><strong>逻辑约束</strong>:</p><ol><li><p>parameters.target_nodes 必须是字符串数组 [“ip1”, “ip2”]。</p></li><li><p>支持所有三种执行模式 (one_shot, repeated, continuous)。</p></li></ol></li><li><p><strong>请求体构建规则</strong>:</p><ul><li><p><strong>Level 1 (执行配置)</strong>: 决定攻击的时间维度。</p><ul><li><p>若是 one_shot: 仅需 duration_seconds。</p></li><li><p>若是 repeated: 需额外提供 interval_seconds 和 repeat_count。</p></li></ul></li><li><p><strong>Level 2 (策略参数)</strong>: 决定攻击的具体手段。</p><ul><li><p>必须包含 strategy 字段（枚举值）。</p></li><li><p>其余字段根据 strategy 变化（如 storage_attack 需要 size_mb，而 node_disconnection 不需要）。</p></li></ul></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 场景：对两个节点进行重复的 P2P 洪水攻击</span><br>{<br>  <span class="hljs-string">"execution_config"</span>: {<br>    <span class="hljs-string">"mode"</span>: <span class="hljs-string">"repeated"</span>,<br>    <span class="hljs-string">"duration_seconds"</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">"interval_seconds"</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">"repeat_count"</span>: <span class="hljs-number">5</span><br>  },<br>  <span class="hljs-string">"parameters"</span>: {<br>    <span class="hljs-string">"strategy"</span>: <span class="hljs-string">"communication_interference"</span>,<br>    <span class="hljs-string">"method"</span>: <span class="hljs-string">"p2p_flood"</span>,<br>    <span class="hljs-string">"intensity"</span>: <span class="hljs-string">"high"</span>,<br>    <span class="hljs-string">"target_nodes"</span>: <span class="hljs-selector-attr">[<span class="hljs-string">"192.168.1.10"</span>, <span class="hljs-string">"192.168.1.11"</span>]</span><br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h3 id="2-发起自适应攻击-Adaptive-Attack"><a href="#2-发起自适应攻击-Adaptive-Attack" class="headerlink" title="2. 发起自适应攻击 (Adaptive Attack)"></a>2. 发起自适应攻击 (Adaptive Attack)</h3><p>此接口用于<strong>动态目标</strong>攻击，系统会在每一轮攻击开始前重新计算受害者（例如：总是攻击网络中连接数最多的节点）。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>功能</strong>: 发起自适应攻击，目标由后端实时计算。</p></li><li><p><strong>关键区别</strong>:</p><ol><li><p><strong>不支持</strong> one_shot 模式（因为一次性攻击不需要”自适应”变化）。必须是 repeated 或 continuous。</p></li><li><p>parameters.target_nodes <strong>必须</strong>是特定格式的字符串指令，以 dynamic: 开头。</p></li></ol></li><li><p><strong>目标指令语法</strong>: dynamic:{指标}:{选择策略}</p><ul><li><p>示例: dynamic:degree:top:5 (度中心性最高的前5个)</p></li><li><p>示例: dynamic:betweenness:highest (介数中心性最高的1个)</p></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 场景：持续攻击网络中度中心性最高的前5个节点</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"execution_config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"continuous"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"duration_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"interval_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"strategy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_disconnection"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"firewall_block"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"target_nodes"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dynamic:degree:top:5"</span> <span class="hljs-comment">// 注意这里是字符串</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-前端分流逻辑-Frontend-Logic"><a href="#3-前端分流逻辑-Frontend-Logic" class="headerlink" title="3. 前端分流逻辑 (Frontend Logic)"></a>3. 前端分流逻辑 (Frontend Logic)</h3><p>这是前端 Vue 组件如何决定调用哪个接口的核心逻辑说明。</p><p><strong>Prompt / 逻辑说明:</strong></p><p>前端在点击”发起攻击”按钮时，必须执行以下判断逻辑：</p><ol><li><p><strong>检查目标类型</strong>:</p><ul><li><p>获取用户在表单中输入的目标配置。</p></li><li><p>如果目标是<strong>字符串指令</strong>且以 dynamic: 开头 -&gt; 标记为 isDynamic。</p></li><li><p>如果目标是<strong>手动输入的 IP 列表</strong> -&gt; 标记为 isStatic。</p></li></ul></li><li><p><strong>检查执行模式</strong>:</p><ul><li>获取用户选择的模式 (one_shot, repeated, continuous)。</li></ul></li><li><p><strong>路由决策树</strong>:</p><ul><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode == one_shot):</p><ul><li>❌ <strong>报错</strong>: 自适应攻击不支持一次性模式。</li></ul></li><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode != one_shot):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段发送字符串。</p></li></ul></li><li><p><strong>ELSE</strong> (即静态目标，无论什么模式):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段必须转换为数组 [] 发送。</p></li></ul></li></ul></li></ol><hr><h3 id="4-停止攻击-Stop-Attack"><a href="#4-停止攻击-Stop-Attack" class="headerlink" title="4. 停止攻击 (Stop Attack)"></a>4. 停止攻击 (Stop Attack)</h3><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: DELETE /api/simulations/{attack_id}</p></li><li><p><strong>功能</strong>: 立即终止一个正在运行 (running) 或挂起 (pending) 的攻击任务。</p></li><li><p><strong>适用场景</strong>:</p><ul><li><p>用户点击”紧急停止”按钮。</p></li><li><p>用于中断 continuous (无限持续) 类型的攻击。</p></li><li><p>用于中断剩余轮次尚未执行的 repeated 攻击。</p></li></ul></li><li><p><strong>后端行为</strong>:</p><ul><li><p>取消对应的 asyncio.Task。</p></li><li><p>执行清理逻辑（如恢复防火墙规则、删除垃圾文件）。</p></li><li><p>将数据库中的状态更新为 stopped。</p></li></ul></li></ul><hr><h3 id="5-状态轮询与监控-Monitoring"><a href="#5-状态轮询与监控-Monitoring" class="headerlink" title="5. 状态轮询与监控 (Monitoring)"></a>5. 状态轮询与监控 (Monitoring)</h3><p><strong>Prompt / 接口说明:</strong></p><p>为了在前端展示”实时状态”和”系统日志”，需要配合使用以下两个接口：</p><ol><li><p><strong>获取活跃列表</strong>: GET /api/simulations/active</p><ul><li><p><strong>用途</strong>: 判断当前是否有攻击在跑 (isRunning 状态)。</p></li><li><p><strong>频率</strong>: 建议每 3-5 秒轮询一次。</p></li><li><p><strong>返回</strong>: 包含 progress (进度百分比) 和 current_round (当前轮次)。</p></li></ul></li><li><p><strong>获取详情/日志</strong>: GET /api/simulations/{attack_id}</p><ul><li><p><strong>用途</strong>: 获取特定攻击的详细日志流。</p></li><li><p><strong>返回</strong>: 包含 logs 数组 ([“Attack started”, “Round 1 finished”])。</p></li><li><p><strong>前端展示</strong>: 将 logs 渲染到控制台面板中。</p></li></ul></li></ol><hr><h3 id="总结：数据结构对照表-Type-Mapping"><a href="#总结：数据结构对照表-Type-Mapping" class="headerlink" title="总结：数据结构对照表 (Type Mapping)"></a>总结：数据结构对照表 (Type Mapping)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>参数字段</td><td>描述</td><td>类型限制</td></tr><tr><td><strong>execution_config</strong></td><td></td><td></td></tr><tr><td>mode</td><td>执行模式</td><td>“one_shot” \</td><td>“repeated” \</td><td>“continuous”</td></tr><tr><td>duration_seconds</td><td>单次持续时长</td><td>Integer (秒)</td></tr><tr><td>interval_seconds</td><td>轮次间隔</td><td>Integer (秒), 仅 repeated/continuous 有效</td></tr><tr><td>repeat_count</td><td>重复次数</td><td>Integer, 仅 repeated 有效</td></tr><tr><td><strong>parameters</strong></td><td></td><td></td></tr><tr><td>strategy</td><td>攻击策略</td><td>“node_disconnection” \</td><td>“storage_attack” …</td></tr><tr><td>target_nodes</td><td>攻击目标</td><td>Array [str] (普通) <strong>OR</strong> String dynamic:… (自适应)</td></tr><tr><td>method</td><td>具体手段</td><td>依赖于 strategy (如 firewall_block, disk_fill)</td></tr><tr><td>…</td><td>其他参数</td><td>依赖于 strategy (如 size_mb, intensity)</td></tr></tbody></table></div><hr><h3 id="1-全局枚举定义-Global-Enums"><a href="#1-全局枚举定义-Global-Enums" class="headerlink" title="1. 全局枚举定义 (Global Enums)"></a>1. 全局枚举定义 (Global Enums)</h3><p>这些枚举值用于填充请求体中的特定字段。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>枚举类型</td><td>字段名</td><td>可选值 (Value)</td><td>说明</td></tr><tr><td><strong>执行模式</strong></td><td>mode</td><td>one_shot</td><td><strong>一次性</strong>：执行一次，持续指定时间后恢复。</td></tr><tr><td></td><td></td><td>repeated</td><td><strong>重复执行</strong>：按间隔重复执行多次。</td></tr><tr><td></td><td></td><td>continuous</td><td><strong>持续执行</strong>：按间隔无限执行，直到手动停止。</td></tr><tr><td><strong>攻击策略</strong></td><td>strategy</td><td>node_disconnection</td><td>节点断连攻击</td></tr><tr><td></td><td></td><td>communication_interference</td><td>通信干扰攻击</td></tr><tr><td></td><td></td><td>storage_attack</td><td>存储耗尽攻击</td></tr><tr><td></td><td></td><td>timestamp_attack</td><td>时间/NTP攻击</td></tr><tr><td></td><td></td><td>simplified_sybil_attack</td><td>简化版女巫攻击</td></tr><tr><td></td><td></td><td>geth_lighthouse_attack</td><td>客户端特定攻击 (Geth/Lighthouse)</td></tr></tbody></table></div><hr><h3 id="2-执行配置-execution-config"><a href="#2-执行配置-execution-config" class="headerlink" title="2. 执行配置 (execution_config)"></a>2. 执行配置 (execution_config)</h3><p>根据 mode 的不同，所需字段不同。<strong>注意：自适应攻击接口 (/simulate/adaptive) 不支持 one_shot。</strong></p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>模式 (Mode)</td><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>约束/说明</td></tr><tr><td><strong>通用</strong></td><td>duration_seconds</td><td>Int</td><td>✅</td><td>30</td><td>攻击生效持续时间 (秒)，&gt;=1</td></tr><tr><td><strong>Repeated</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr><tr><td>(重复)</td><td>repeat_count</td><td>Int</td><td>✅</td><td>-</td><td>重复执行的总轮数，&gt;=1</td></tr><tr><td><strong>Continuous</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr></tbody></table></div><hr><h3 id="3-策略参数详情-parameters"><a href="#3-策略参数详情-parameters" class="headerlink" title="3. 策略参数详情 (parameters)"></a>3. 策略参数详情 (parameters)</h3><p>此部分为多态结构，根据 strategy 字段的值，JSON 结构发生变化。</p><h4 id="3-1-节点断连-node-disconnection"><a href="#3-1-节点断连-node-disconnection" class="headerlink" title="3.1 节点断连 (node_disconnection)"></a>3.1 节点断连 (node_disconnection)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>interface_down (网卡下线), route_flush (清空路由), firewall_block (防火墙), p2p_block (P2P阻断)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令 (见第4节)</td></tr></tbody></table></div><h4 id="3-2-通信干扰-communication-interference"><a href="#3-2-通信干扰-communication-interference" class="headerlink" title="3.2 通信干扰 (communication_interference)"></a>3.2 通信干扰 (communication_interference)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>json_rpc_flood (RPC泛洪), p2p_flood (P2P泛洪), memory_exhaustion (内存耗尽)</td></tr><tr><td>intensity</td><td>String</td><td>❌</td><td>medium</td><td>low, medium, high, extreme</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h4 id="3-3-存储攻击-storage-attack"><a href="#3-3-存储攻击-storage-attack" class="headerlink" title="3.3 存储攻击 (storage_attack)"></a>3.3 存储攻击 (storage_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>disk_fill (填充), database_corruption (脏数据), state_pollution (状态污染), chain_data_spam (链上垃圾)</td></tr><tr><td>size_mb</td><td>Int</td><td>❌</td><td>1000</td><td>填充大小 (MB)，100 - 10000</td></tr><tr><td>file_count</td><td>Int</td><td>❌</td><td>100</td><td>生成文件数量，10 - 1000</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-4-时间攻击-timestamp-attack"><a href="#3-4-时间攻击-timestamp-attack" class="headerlink" title="3.4 时间攻击 (timestamp_attack)"></a>3.4 时间攻击 (timestamp_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>time_shift (平移), ntp_block (NTP阻断), time_drift (漂移)</td></tr><tr><td>time_shift</td><td>String</td><td>❌</td><td>+1 hour</td><td>偏移量 (如 +1 hour, -30 minutes)，仅 time_shift 方法有效</td></tr><tr><td>drift_seconds</td><td>Int</td><td>❌</td><td>3600</td><td>漂移秒数，-86400 到 86400，仅 time_drift 方法有效</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-5-女巫攻击-simplified-sybil-attack"><a href="#3-5-女巫攻击-simplified-sybil-attack" class="headerlink" title="3.5 女巫攻击 (simplified_sybil_attack)"></a>3.5 女巫攻击 (simplified_sybil_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>fake_node_count</td><td>Int</td><td>❌</td><td>5</td><td>虚假节点数量 (1-20)</td></tr><tr><td>node_type</td><td>String</td><td>❌</td><td>light</td><td>light (轻节点), full (全节点), validator (验证者)</td></tr><tr><td>network</td><td>String</td><td>❌</td><td>testnet</td><td>mainnet, testnet, devnet</td></tr><tr><td>connect_to_real</td><td>Bool</td><td>❌</td><td>True</td><td>是否连接真实节点</td></tr><tr><td>min_connections</td><td>Int</td><td>❌</td><td>3</td><td>最小连接数 (0-10)</td></tr><tr><td>target_nodes</td><td>-</td><td>-</td><td>-</td><td><strong>注意：此策略通常不需要指定具体目标节点</strong></td></tr></tbody></table></div><h4 id="3-6-客户端攻击-geth-lighthouse-attack"><a href="#3-6-客户端攻击-geth-lighthouse-attack" class="headerlink" title="3.6 客户端攻击 (geth_lighthouse_attack)"></a>3.6 客户端攻击 (geth_lighthouse_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>process_kill, db_corruption, port_blocking, config_modification</td></tr><tr><td>attack_type</td><td>String</td><td>✅</td><td>-</td><td>geth, lighthouse (指定攻击的客户端类型)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><hr><h3 id="4-目标节点配置-target-nodes"><a href="#4-目标节点配置-target-nodes" class="headerlink" title="4. 目标节点配置 (target_nodes)"></a>4. 目标节点配置 (target_nodes)</h3><p>target_nodes 字段在不同接口下有严格的格式要求。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>接口端点</td><td>格式类型</td><td>数据结构示例</td><td>说明</td></tr><tr><td>/api/simulate</td><td><strong>静态列表</strong></td><td>[“192.168.1.10”, “node_id_123”]</td><td>明确指定要攻击的节点列表。</td></tr><tr><td>/api/simulate/adaptive</td><td><strong>动态指令</strong></td><td>“dynamic:degree:top:5”</td><td>字符串格式，后端自动计算目标。</td></tr></tbody></table></div><p><strong>动态指令语法:</strong> dynamic:{指标}:{选择器}</p><ol><li><p><strong>指标 (Metric)</strong>:</p><ul><li><p>degree (度中心性)</p></li><li><p>betweenness (介数中心性)</p></li><li><p>closeness (接近中心性)</p></li><li><p>eigenvector (特征向量中心性)</p></li></ul></li><li><p><strong>选择器 (Selector)</strong>:</p><ul><li><p>highest (选最高的1个)</p></li><li><p>top:N (选前 N 个，N为数字)</p></li></ul></li></ol><hr><h3 id="5-防护配置-defense-enable"><a href="#5-防护配置-defense-enable" class="headerlink" title="5. 防护配置 (/defense/enable)"></a>5. 防护配置 (/defense/enable)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>示例</td><td>说明</td></tr><tr><td>enabled</td><td>Bool</td><td>❌</td><td>true</td><td>是否启用防护</td></tr><tr><td>rules</td><td>Object</td><td>✅</td><td>{“rate_limit”: 100}</td><td>防护规则字典，具体Key由后端逻辑决定</td></tr></tbody></table></div><hr><h3 id="6-响应结构概览"><a href="#6-响应结构概览" class="headerlink" title="6. 响应结构概览"></a>6. 响应结构概览</h3><p>所有接口通常遵循统一的响应格式：</p><p>codeJSON</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">{<br>  <span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>,  <span class="hljs-string">//</span> 或 <span class="hljs-string">"error"</span><br>  <span class="hljs-string">"message"</span>: <span class="hljs-string">"操作描述"</span>,<br>  <span class="hljs-string">"data"</span>: { <span class="hljs-string">...</span> }       <span class="hljs-string">//</span> 具体业务数据<br>}<br></code></pre></td></tr></table></figure><p><strong>关键数据字段 (data)</strong>:</p><ul><li><p>attack_id: (String) 攻击任务的唯一标识符。</p></li><li><p>status: (Enum) pending, running, completed, failed, stopped, cancelled。</p></li><li><p>logs: (Array[Str]) 攻击日志列表。</p></li></ul><p>{<br>  “nodes”: [<br>    {<br>      “id”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”,<br>      “name”: “Tether USD (USDT)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 5<br>    },<br>    {<br>      “id”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”,<br>      “name”: “USD Coin (USDC)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 3<br>    },<br>    {<br>      “id”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”,<br>      “name”: “Uniswap V3: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 8<br>    },<br>    {<br>      “id”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”,<br>      “name”: “Uniswap V3: SwapRouter02”,<br>      “type”: “SwapRouter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 6<br>    },<br>    {<br>      “id”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”,<br>      “name”: “Uniswap V3: Quoter”,<br>      “type”: “Quoter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”,<br>      “name”: “Uniswap V2: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 7<br>    },<br>    {<br>      “id”: “0x881D40237659C251811CEC9c364ef91dC08D300C”,<br>      “name”: “Curve: 3pool Controller”,<br>      “type”: “CurvePool”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”,<br>      “name”: “Curve: 3pool Gauge”,<br>      “type”: “Gauge”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 2<br>    }<br>  ],<br>  “links”: [<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “type”: “transfer_approve” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap_out” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “type”: “swap_in” },<br>    { “source”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “target”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “type”: “call” },<br>    { “source”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “target”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”, “type”: “quote” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “type”: “approve” },<br>    { “source”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “type”: “deposit” },<br>    { “source”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “target”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”, “type”: “stake” }<br>  ],<br>  “timestamp”: 1765095677.891234,<br>  “data_source”: “real_web3”,<br>  “topology_type”: “contract”<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[ETH前端] --&gt; B[src]<br>    A --&gt; C[package.json]<br>    A --&gt; D[index.html]<br>    A --&gt; E[vite.config.ts]<br>    A --&gt; F[README.md]<br>    A --&gt; G[public]<br>    <br>    B --&gt; H[__tests__]<br>    B --&gt; I[api]<br>    B --&gt; J[assets]<br>    B --&gt; K[components]<br>    B --&gt; L[composables]<br>    B --&gt; M[router]<br>    B --&gt; N[services]<br>    B --&gt; O[types]<br>    B --&gt; P[utils]<br>    B --&gt; Q[views]<br>    B --&gt; R[App.vue]<br>    B --&gt; S[main.ts]<br>    <br>    I --&gt; T[api_docs]<br>    I --&gt; U[attack]<br>    <br>    J --&gt; V[styles]<br>    V --&gt; W[global.css]<br>    V --&gt; X[tailwind.css]<br>    <br>    K --&gt; Y[blockchain]<br>    K --&gt; Z[common]<br>    K --&gt; AA[layout]<br>    K --&gt; AB[tabs]<br>    K --&gt; AC[topology]<br>    <br>    Y --&gt; AD[BlockchainCanvas.vue]<br>    Y --&gt; AE[BlockchainInfoPanel.vue]<br>    Y --&gt; AF[BlockchainModal.vue]<br>    Y --&gt; AG[BlockchainVisualization.vue]<br>    Y --&gt; AH[composables]<br>    Y --&gt; AI[types]<br>    <br>    AH --&gt; AJ[useBlockchainAPI.ts]<br>    AH --&gt; AK[useBlockchainAnimations.ts]<br>    AH --&gt; AL[useBlockchainData.ts]<br>    AH --&gt; AM[useBlockchainEvents.ts]<br>    AH --&gt; AN[useBlockchainRenderer.ts]<br>    AH --&gt; AO[useBlockchainScrolling.ts]<br>    <br>    Z --&gt; AP[ContainerTerminal.vue]<br>    Z --&gt; AQ[DEP-TERM.vue]<br>    Z --&gt; AR[StandaloneTerminal.vue]<br>    Z --&gt; AS[Terminal.vue]<br>    Z --&gt; AT[websocket_terminal8080.vue]<br>    <br>    AA --&gt; AU[DashboardHeader.vue]<br>    AA --&gt; AV[LeftPanel.vue]<br>    AA --&gt; AW[PanelSplitter.vue]<br>    AA --&gt; AX[RightPanel.vue]<br>    <br>    AB --&gt; AY[AttackMonitoringTab.vue]<br>    AB --&gt; AZ[Attack_sys]<br>    AB --&gt; BA[BlockchainBrowserTab.css]<br>    AB --&gt; BB[BlockchainBrowserTab.vue]<br>    AB --&gt; BC[ContainerListTab.vue]<br>    AB --&gt; BD[NetworkTopologyTab.vue]<br>    AB --&gt; BE[sections]<br>    AB --&gt; BF[tabstyle.css]<br>    <br>    AZ --&gt; BG[AttackSystemTab.vue]<br>    BE --&gt; BH[Network-analysis.vue]<br>    BE --&gt; BI[NodeInfoPanel.vue]<br>    BE --&gt; BJ[RealTimeMonitoring.vue]<br>    <br>    AC --&gt; BK[ContractTopology.vue]<br>    AC --&gt; BL[Ethereum_Topology]<br>    AC --&gt; BM[Physical_Topology]<br>    AC --&gt; BN[TopologyVisualization.vue]<br>    AC --&gt; BO[TransactionTopology.vue]<br>    AC --&gt; BP[composables]<br>    AC --&gt; BQ[types]<br>    <br>    BL --&gt; BR[types]<br>    BL --&gt; BS[workers]<br>    BL --&gt; BT[EthereumTopology_new.vue]<br>    BL --&gt; BU[useD3Renderer.ts]<br>    BL --&gt; BV[use_topology_core.ts]<br>    BL --&gt; BW[use_topology_visuals.ts]<br>    <br>    BM --&gt; BX[composables]<br>    BM --&gt; BY[PhysicalTopology.vue]<br>    <br>    BP --&gt; BZ[index.ts]<br>    BP --&gt; CA[topology.css]<br>    BP --&gt; CB[useTopologyAPI.ts]<br>    BP --&gt; CC[useTopologyData.ts]<br>    BP --&gt; CD[useTopologyRendererBase.ts]<br>    <br>    L --&gt; CE[useDashboardData.ts]<br>    L --&gt; CF[useDashboardLayout.ts]<br>    L --&gt; CG[useDashboardTabs.ts]<br>    <br>    M --&gt; CH[index.ts]<br>    <br>    N --&gt; CI[analysis.ts]<br>    N --&gt; CJ[api.ts]<br>    N --&gt; CK[apiService.ts]<br>    N --&gt; CL[attack.ts]<br>    N --&gt; CM[blockchain.ts]<br>    N --&gt; CN[daily-operations.ts]<br>    N --&gt; CO[device-monitoring.ts]<br>    N --&gt; CP[execution.ts]<br>    N --&gt; CQ[foundation.ts]<br>    N --&gt; CR[monitoring.ts]<br>    N --&gt; CS[readme.md]<br>    N --&gt; CT[root-api.ts]<br>    N --&gt; CU[security.ts]<br>    N --&gt; CV[temporal.ts]<br>    N --&gt; CW[topology.ts]<br>    <br>    O --&gt; CX[topology.ts]<br>    <br>    P --&gt; CY[http.ts]<br>    P --&gt; CZ[index.ts]<br>    P --&gt; DA[types.ts]<br>    <br>    Q --&gt; DB[BlockchainTest.vue]<br>    Q --&gt; DC[Dashboard.vue]<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;性能优化 (Web Workers)&lt;/strong&gt;: 目前的数据获取、解析和Diff算法都在&lt;strong&gt;主线程&lt;/strong&gt;运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 &lt;strong&gt;Web Worker&lt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-05-字节工训营画布项目相关设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/17798.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/17798.html</id>
    <published>2025-12-04T18:00:16.000Z</published>
    <updated>2025-12-25T03:23:33.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BDdraw-DEV"><a href="#BDdraw-DEV" class="headerlink" title="BDdraw_DEV"></a>BDdraw_DEV</h1><p>代码仓库：<br><a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>现代协同 2D 画布编辑器 · React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8</p><h4 id="技术栈-·-Tech-Stack"><a href="#技术栈-·-Tech-Stack" class="headerlink" title="技术栈 · Tech Stack"></a>技术栈 · Tech Stack</h4><p class='item-img' data-src='https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white'><img src="https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white" alt="React 18"> <img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5" class='item-img' data-src='https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white'><img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5"> <img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6" class='item-img' data-src='https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white'><img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6"> <img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate" class='item-img' data-src='https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4'><img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate"> <img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design" class='item-img' data-src='https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white'><img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design"> <img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide" class='item-img' data-src='https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white'><img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide"> <img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer" class='item-img' data-src='https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white'><img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer"> <img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8" class='item-img' data-src='https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white'><img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8"> <img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3" class='item-img' data-src='https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white'><img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3"> <img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12" class='item-img' data-src='https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white'><img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12"> <img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid" class='item-img' data-src='https://img.shields.io/badge/nanoid-5.1.6-000000'><img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid"> <img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint" class='item-img' data-src='https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white'><img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint"> <img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky" class='item-img' data-src='https://img.shields.io/badge/Husky-8.0.3-7711A4'><img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky"> <img src="https://img.shields.io/badge/Deploy-GitHub_Pages-222222?logo=githubpages&logoColor=white" alt="GitHub Pages"></p><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p><strong>frontend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:Zhongye1/BDdraw_DEV.git<br><br><span class="hljs-built_in">cd</span> BDdraw_DEV (进入项目)<br>bun install (安装依赖包)<br>bun start (启动服务)<br></code></pre></td></tr></table></figure><p><strong>backend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> BDdraw_DEV/ALD_Backend/<br>bun install <span class="hljs-comment">#安装依赖</span><br>bun index.ts  <span class="hljs-comment">#启动后端服务</span><br></code></pre></td></tr></table></figure><p>推荐使用 bun 包管理器，见个人博客</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/15722.html">关于包管理器 npm,pnpm,yarn 和 bun 以及我为何选择后者</a></p><h4 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h4><p>项目支持通过 Docker 进行容器化部署，使用 Node 22 和 Bun 包管理器。</p><p><strong>开发环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><strong>生产环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -f docker-compose.prod.yml up -d<br></code></pre></td></tr></table></figure><p>部署完成后，可以通过以下地址访问：</p><ul><li>前端应用: <a href="http://localhost:5000/BDdraw_DEV/">http://localhost:5000/BDdraw_DEV/</a></li><li>后端 API 文档: <a href="http://localhost:3000/swagger-ui">http://localhost:3000/swagger-ui</a></li></ul><h4 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h4><p>项目采用了模块化的架构设计，将不同的功能划分为独立的模块，以方便后续维护和扩展</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>60 FPS 渲染（得益于 PixiJS WebGL）</li><li>完整撤销/重做（Command Pattern + 防抖快照）</li><li>多元素选择与群组操作</li><li>画布元素变换控制器</li><li>富文本所见即所得编辑（WanngEditor + PIXI.HTMLText）</li><li>图片插入 + 内置滤镜（模糊、亮度、灰度等）</li><li>插件式元素系统</li><li>插件式元素系统</li><li>完整的 TypeScript 类型支持</li><li>现代开发体验（Vite + ESLint + Prettier + Husky）</li><li>集成 GitHub-Actions 支持， 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</li></ul><hr><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>这时候需要简单做一个技术选型分析，根据任务拆解，选择了如下技术栈</p><p><strong>【框架】</strong>【技术方案：采用 React 18 + TypeScript 5 构建应用，React 提供完整的 UI 生态，TypeScript 提供更清晰可靠的类型安全，相比 JavaScript 更易于维护】</p><p><strong>【构建工具】</strong>【技术方案：使用 Vite 5 作为构建工具，其开发服务器启动和热模块替换（HMR）速度明显快于 Webpack】</p><p><strong>【路由】</strong>【技术方案：采用 React Router DOM 6 实现路由管理，API 稳定且文档完善】</p><p><strong>【样式】</strong>【技术方案：使用 Tailwind CSS 3 + PostCSS 处理样式，开发时编写样式更快，生产环境会自动进行 tree-shaking 优化，相比 CSS Modules 和 styled-components 更高效且原子化更直观，对 AI 工具友好】</p><p><strong>【样式扩展】</strong>【技术方案：少量使用 Less 覆盖 Tailwind 主题变量，保持兼容性】</p><p><strong>【SVG 处理】</strong>【技术方案：使用 SVGR 1.5 处理 SVG，Vite 原生支持，可以将 SVG 作为 React 组件使用，比直接使用 SVG 或 SVG sprite 更灵活】</p><p><strong>【UI 组件库】</strong>【技术方案：采用 shadcn/ui（latest）和 Arco Design 2 实现 UI 组件，易于使用，符合字节项目使用字节组件库的习惯】</p><p><strong>【全局状态】</strong>【技术方案：采用 Zustand 4 管理全局状态，API 简洁、性能良好且无样板代码，相比 Redux Toolkit、Pinia、Jotai 代码量更少且配有 Devtools】</p><p><strong>【图形/画布】</strong>【技术方案：使用 PixiJS 8 + pixi-viewport 实现图形和画布功能，基于 WebGL 渲染，适合处理大量精灵元素，相比其他可选方案性能更高】</p><p><strong>【富文本编辑器】</strong>【技术方案：采用 WangEditor 5 作为富文本编辑器，轻量且文档和社区均为中文，相比 Slate/TipTap 等编辑器，默认输出的 HTML 可直接给 PixiJS HTMLText 进行渲染】</p><p><strong>【图标】</strong>【技术方案：使用 Lucide React 图标库，图标数量多、风格统一且支持 Tree-shaking】</p><p><strong>【工具库】</strong>【技术方案：采用 nanoid 3 为画布元素生成唯一标识符等操作，轻量实用】</p><p><strong>【代码质量】</strong>【技术方案：使用 ESLint + Stylelint + Prettier + Husky + lint-staged + commitlint 保证团队代码风格一致，这是中大型项目的基本配置，有利于多人协作开发】</p><p>此外，还配置了 react 开发者工具 react-dev-inspector，配置了一下，开发环境下 ctrl+q 可以实现点击页面上的组件，在 VSCode 中自动跳转到对应文件，并定位到对应行号，方便调试（先前写 vue 也用过类似的）</p><p>项目 <a href="https://react-dev-inspector.zthxxx.me/docs">https://react-dev-inspector.zthxxx.me/docs</a></p><h3 id="功能要素和方案"><a href="#功能要素和方案" class="headerlink" title="功能要素和方案"></a>功能要素和方案</h3><p>分析以上需求，查阅相关资料后，进行各个核心模块的技术方案选型，确定初步实现方案</p><p><strong>【基础渲染引擎】</strong>【技术方案：PixiJS v8（WebGL）提供高性能 2D 渲染，根据不同元素类型创建对应的 Pixi 对象（图形、文本、图像），通过 pixi-viewport 实现无限画布的视口控制，支持缩放、拖拽等交互】</p><p><strong>【无限画布视口】</strong>【技术方案：pixi-viewport（内置 zoom、drag、decelerate、clampZoom）库创建无限画布，在 StageManagerCore.ts 中初始化 viewport，并添加拖拽、缩放等交互功能，支持鼠标中键拖拽画布、滚轮缩放等常见操作】</p><p><strong>【富文本编辑】</strong>【技术方案：WangEditor 5 作为富文本编辑器，提供完整的文本编辑功能，编辑结果以 HTML 格式存储在元素的 text/string 属性中，元素使用 PixiJS 内置的 HTMLText 进行渲染实现富文本效果】</p><p><strong>【状态管理与数据结构】</strong>【技术方案：Zustand 作为全局状态管理库，通过 structuredClone 函数手动创建状态快照，管理画布元素、选中状态、工具类型等，通过中间件监听状态变化并触发重渲染，在特定的 ts 中定义所有状态和操作方法】</p><p><strong>【图片上传显示与滤镜】</strong>【技术方案：PixiJS 内置 Filter 系统包括 BlurFilter、ColorMatrixFilter（黑白、对比度、饱和度）实现图像处理效果，支持模糊、亮度调整、灰度等多种滤镜效果，在 ElementRenderer.ts 中根据元素的 filter 属性应用相应滤镜，支持 blur（模糊）、brightness（亮度）、grayscale（灰度）等滤镜类型】</p><p><strong>【选中与变换系统】</strong>【技术方案：SelectionManager + TransformOverlay（8 个把手 + 旋转把手）实现变换控件渲染，支持单个元素选中和多个元素群组选中，提供 8 个控制点和 1 个旋转点进行变换操作，根据不同元素类型提供不同的控制方式】</p><p><strong>【旋转与组合嵌套】</strong>【技术方案：每个元素维护自己的 matrix（局部矩阵），组合后父容器统一应用矩阵变换，支持多层级嵌套和复杂变换】</p><p><strong>【Minimap】</strong>【技术方案：单独一个小的 Pixi.Application（共享 texture 缓存）实现缩略图功能，主画布所有容器使用 cacheAsBitmap 后生成低分辨率 texture，实时更新到小画布，视口框用一个半透明矩形表示在主画布中的位置】</p><p><strong>【元素永久缓存】</strong>【技术方案：使用 spriteMap 来存储 PIXI 对象，元素更新时只修改属性并设置 container.dirty = true，而不是销毁重建，来解决拖拽中断、光标丢失、闪烁等问题】</p><p><strong>【辅助对齐线】</strong>【技术方案：拖拽时实时遍历所有元素 bounds，计算对齐情况（水平/垂直/间距相等），差值&lt;6px 就吸附并画蓝线，支持水平、垂直对齐以及等间距对齐等多种对齐方式，当距离小于阈值时自动吸附并对齐】</p><p><strong>【Undo/Redo】</strong>【技术方案：Command Pattern + structuredClone 完整快照（每步 before/after）实现撤销/重做功能，通过管理命令栈（undo，redo 栈），使用 structuredClone 创建状态快照，记录操作前后的完整状态，来支持添加元素、删除元素、修改元素属性等操作的撤销/重做，针对拖拽和调整大小操作的命令生成逻辑可能还要具体再处理一套】</p><p><strong>【数据持久化与离线】</strong>【技术方案：Zustand-persist + localForage（IndexedDB）实现数据持久化和离线使用，使用 Zustand 的持久化中间件保存状态，通过 localForage 将数据存储到 IndexedDB 中，实现数据的自动保存和恢复功能】</p><p><strong>【实时协同】</strong>【技术方案：Y.js + y-websocket（或自己写 CRDT）+ Operation Transform 合并策略实现无冲突的实时协同编辑，通过 y-websocket 插件实现服务端同步（问的 AI），有个思路是把操作打给时间 tag，然后然后按时间合并】</p><hr><h4 id="项目架构树"><a href="#项目架构树" class="headerlink" title="项目架构树"></a>项目架构树</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs sh">BDdraw_DEV/<br>├── ALD_Backend/                    <span class="hljs-comment"># 后端服务目录</span><br>│   ├── src/                        <span class="hljs-comment"># 后端源代码</span><br>│   │   ├── api/                    <span class="hljs-comment"># API接口目录</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关API</span><br>│   │   │   │   ├── types/          <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   │   ├── CORE.ts         <span class="hljs-comment"># 核心房间管理逻辑</span><br>│   │   │   │   ├── Room_CRUD.ts    <span class="hljs-comment"># 房间增删改查操作实现</span><br>│   │   │   │   ├── Room_List.ts    <span class="hljs-comment"># 房间列表管理实现</span><br>│   │   │   │   └── Room_users.ts   <span class="hljs-comment"># 房间用户管理实现</span><br>│   │   │   ├── USER_management/    <span class="hljs-comment"># 用户管理相关API</span><br>│   │   │   │   ├── auth_API.ts     <span class="hljs-comment"># 用户认证API实现</span><br>│   │   │   │   └── auth_API_types.ts  <span class="hljs-comment"># 用户认证类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API索引文件</span><br>│   │   ├── auth.ts                 <span class="hljs-comment"># 认证模块实现</span><br>│   │   ├── collab.ts               <span class="hljs-comment"># 协作功能模块实现</span><br>│   │   └── db.ts                   <span class="hljs-comment"># 数据库连接和操作实现</span><br>│   ├── ARCHITECTURE.md             <span class="hljs-comment"># 后端架构说明文档</span><br>│   ├── README.md                   <span class="hljs-comment"># 后端说明文档</span><br>│   ├── index.ts                    <span class="hljs-comment"># 后端服务入口文件</span><br>│   ├── package.json                <span class="hljs-comment"># 后端依赖配置文件</span><br>│   └── tsconfig.json               <span class="hljs-comment"># 后端TypeScript配置</span><br>├── src/                            <span class="hljs-comment"># 前端源代码目录</span><br>│   ├── api/                        <span class="hljs-comment"># 前端API客户端</span><br>│   │   ├── types/                  <span class="hljs-comment"># API类型定义</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   ├── auth_API_types.ts   <span class="hljs-comment"># 认证相关类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API类型索引文件</span><br>│   │   ├── utils/                  <span class="hljs-comment"># API工具函数</span><br>│   │   │   └── apiClient.ts        <span class="hljs-comment"># API客户端工具</span><br>│   │   ├── apiService.ts           <span class="hljs-comment"># API服务封装实现</span><br>│   │   └── index.ts                <span class="hljs-comment"># API索引文件</span><br>│   ├── components/                 <span class="hljs-comment"># React组件目录</span><br>│   │   ├── Richtext_editor/        <span class="hljs-comment"># 富文本编辑器组件</span><br>│   │   │   ├── BottomTextEditor.tsx    <span class="hljs-comment"># 底部文本编辑器实现</span><br>│   │   │   └── Richtext_editor.tsx     <span class="hljs-comment"># 富文本编辑器主组件</span><br>│   │   ├── canvas_toolbar/         <span class="hljs-comment"># 画布工具栏组件</span><br>│   │   │   ├── ContextMenu.tsx     <span class="hljs-comment"># 上下文菜单实现</span><br>│   │   │   └── TopToolbar.tsx      <span class="hljs-comment"># 顶部工具栏实现</span><br>│   │   ├── collaboration/          <span class="hljs-comment"># 协作功能组件</span><br>│   │   │   ├── CollaboratorCursors.tsx <span class="hljs-comment"># 协作者光标显示组件</span><br>│   │   │   └── RemoteSelectionLayer.tsx <span class="hljs-comment"># 远程选择层组件</span><br>│   │   ├── error-page/             <span class="hljs-comment"># 错误页面组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 错误页面实现</span><br>│   │   ├── header/                 <span class="hljs-comment"># 页面头部组件</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 头部内容组件</span><br>│   │   │   │   ├── ExportCanvasModal.tsx   <span class="hljs-comment"># 导出画布模态框</span><br>│   │   │   │   └── StageManagerContext.tsx <span class="hljs-comment"># 舞台管理上下文</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 头部组件入口</span><br>│   │   ├── image-insert-modal/     <span class="hljs-comment"># 图片插入模态框组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 图片插入模态框实现</span><br>│   │   ├── layout/                 <span class="hljs-comment"># 布局组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 布局组件实现</span><br>│   │   ├── minimap/                <span class="hljs-comment"># 小地图组件</span><br>│   │   │   └── Minimap.tsx         <span class="hljs-comment"># 小地图实现</span><br>│   │   ├── property-panel/         <span class="hljs-comment"># 属性面板组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 属性面板实现</span><br>│   │   ├── settings/               <span class="hljs-comment"># 设置组件</span><br>│   │   │   └── setting.tsx         <span class="hljs-comment"># 设置组件实现</span><br>│   │   ├── ui/                     <span class="hljs-comment"># 基础UI组件</span><br>│   │   │   ├── blackwhitebutton.tsx    <span class="hljs-comment"># 黑白按钮组件</span><br>│   │   │   ├── button.tsx          <span class="hljs-comment"># 按钮组件</span><br>│   │   │   ├── icon-circle.tsx     <span class="hljs-comment"># 圆形图标组件</span><br>│   │   │   ├── icon-clear.tsx      <span class="hljs-comment"># 清除图标组件</span><br>│   │   │   ├── icon-rect.tsx       <span class="hljs-comment"># 矩形图标组件</span><br>│   │   │   ├── icon-select.tsx     <span class="hljs-comment"># 选择图标组件</span><br>│   │   │   └── icon-triangle.tsx   <span class="hljs-comment"># 三角形图标组件</span><br>│   │   ├── AnimatedRoutes.tsx      <span class="hljs-comment"># 动画路由组件</span><br>│   │   ├── ParallaxBackground.tsx  <span class="hljs-comment"># 视差背景组件</span><br>│   │   └── WipeTransition.tsx      <span class="hljs-comment"># 擦除过渡动画组件</span><br>│   ├── hooks/                      <span class="hljs-comment"># 自定义React Hooks</span><br>│   │   ├── use-localstorage-state.ts   <span class="hljs-comment"># localStorage状态管理Hook</span><br>│   │   └── use_React_hotkeys_management.ts <span class="hljs-comment"># 快捷键管理Hook</span><br>│   ├── lib/                        <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   │   ├── AddElementCommand.ts    <span class="hljs-comment"># 添加元素命令实现</span><br>│   │   ├── RemoveElementCommand.ts <span class="hljs-comment"># 删除元素命令实现</span><br>│   │   ├── UndoRedoManager.ts      <span class="hljs-comment"># 撤销重做管理器实现</span><br>│   │   ├── UpdateElementCommand.ts <span class="hljs-comment"># 更新元素命令实现</span><br>│   │   ├── UpdateElementPropertyCommand.ts <span class="hljs-comment"># 更新元素属性命令实现</span><br>│   │   ├── constants.ts            <span class="hljs-comment"># 常量定义文件</span><br>│   │   ├── env.ts                  <span class="hljs-comment"># 环境变量配置</span><br>│   │   ├── minimapUtils.ts         <span class="hljs-comment"># 小地图工具函数</span><br>│   │   └── utils.ts                <span class="hljs-comment"># 通用工具函数</span><br>│   ├── pages/                      <span class="hljs-comment"># 页面组件目录</span><br>│   │   ├── auth/                   <span class="hljs-comment"># 认证相关页面</span><br>│   │   │   ├── Login.tsx           <span class="hljs-comment"># 登录页面实现</span><br>│   │   │   └── Register.tsx        <span class="hljs-comment"># 注册页面实现</span><br>│   │   ├── canvas/                 <span class="hljs-comment"># 画布主页面</span><br>│   │   │   ├── Pixi_STM_modules/   <span class="hljs-comment"># Pixi.js状态管理模块</span><br>│   │   │   │   ├── core/           <span class="hljs-comment"># 核心类和初始化逻辑</span><br>│   │   │   │   │   ├── Core_StageManager.ts    <span class="hljs-comment"># 核心舞台管理器</span><br>│   │   │   │   │   ├── ElementRender.ts        <span class="hljs-comment"># 元素渲染器</span><br>│   │   │   │   │   ├── TF_controler_Renderer.ts <span class="hljs-comment"># 变换控制器渲染器</span><br>│   │   │   │   │   └── types.ts                <span class="hljs-comment"># 核心类型定义</span><br>│   │   │   │   ├── interaction/    <span class="hljs-comment"># 交互处理模块</span><br>│   │   │   │   │   ├── Base_InteractionHandler.ts   <span class="hljs-comment"># 基础交互处理器</span><br>│   │   │   │   │   └── Stage_InteractionHandler.ts  <span class="hljs-comment"># 舞台交互处理器</span><br>│   │   │   │   ├── shared/         <span class="hljs-comment"># 共享类型定义</span><br>│   │   │   │   │   └── types.ts    <span class="hljs-comment"># 共享类型定义文件</span><br>│   │   │   │   ├── utils/          <span class="hljs-comment"># 工具函数目录</span><br>│   │   │   │   │   ├── commandUtils.ts      <span class="hljs-comment"># 命令工具函数</span><br>│   │   │   │   │   ├── cursorUtils.ts       <span class="hljs-comment"># 光标工具函数</span><br>│   │   │   │   │   ├── destroyUtils.ts      <span class="hljs-comment"># 销毁工具函数</span><br>│   │   │   │   │   ├── dragUtils.ts         <span class="hljs-comment"># 拖拽工具函数</span><br>│   │   │   │   │   ├── drawingUtils.ts      <span class="hljs-comment"># 绘图工具函数</span><br>│   │   │   │   │   ├── eraserUtils.ts       <span class="hljs-comment"># 橡皮擦工具函数</span><br>│   │   │   │   │   ├── geometryUtils.ts     <span class="hljs-comment"># 几何工具函数</span><br>│   │   │   │   │   ├── guidelineUtils.ts    <span class="hljs-comment"># 辅助线工具函数</span><br>│   │   │   │   │   ├── interactionUtils.ts  <span class="hljs-comment"># 交互工具函数</span><br>│   │   │   │   │   ├── renderUtils.ts       <span class="hljs-comment"># 渲染工具函数</span><br>│   │   │   │   │   ├── resizeUtils.ts       <span class="hljs-comment"># 调整大小工具函数</span><br>│   │   │   │   │   ├── rotationUtils.ts     <span class="hljs-comment"># 旋转工具函数</span><br>│   │   │   │   │   ├── scaleUtils.ts        <span class="hljs-comment"># 缩放工具函数</span><br>│   │   │   │   │   ├── selectionUtils.ts    <span class="hljs-comment"># 选择工具函数</span><br>│   │   │   │   │   └── stateUtils.ts        <span class="hljs-comment"># 状态工具函数</span><br>│   │   │   │   └── STM_modules.md  <span class="hljs-comment"># 状态管理模块说明文档</span><br>│   │   │   ├── Pixi_stageManager.ts    <span class="hljs-comment"># Pixi舞台管理器入口</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 画布页面入口文件</span><br>│   │   ├── home/                   <span class="hljs-comment"># 主页</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 主页内容组件</span><br>│   │   │   │   └── AKN.tsx         <span class="hljs-comment"># AKN内容组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 主页入口文件</span><br>│   │   ├── intro/                  <span class="hljs-comment"># 介绍页面</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 介绍页面实现</span><br>│   │   └── room/                   <span class="hljs-comment"># 房间管理页面</span><br>│   │       └── RoomManagement.tsx  <span class="hljs-comment"># 房间管理页面实现</span><br>│   ├── router/                     <span class="hljs-comment"># 路由配置目录</span><br>│   │   └── router.tsx              <span class="hljs-comment"># 路由配置实现</span><br>│   ├── stores/                     <span class="hljs-comment"># 状态存储目录(Zustand)</span><br>│   │   ├── canvasStore.ts          <span class="hljs-comment"># 画布状态存储</span><br>│   │   ├── persistenceStore.ts     <span class="hljs-comment"># 持久化状态存储</span><br>│   │   └── themeStore.ts           <span class="hljs-comment"># 主题状态存储</span><br>│   ├── app.tsx                     <span class="hljs-comment"># 应用根组件</span><br>│   ├── main.tsx                    <span class="hljs-comment"># 应用入口文件</span><br>│   └── vite-env.d.ts               <span class="hljs-comment"># Vite环境声明文件</span><br>├── README.md                       <span class="hljs-comment"># 项目说明文档</span><br>├── components.json                 <span class="hljs-comment"># 组件配置文件</span><br>├── index.html                      <span class="hljs-comment"># HTML入口文件</span><br>├── lint-staged.config.js           <span class="hljs-comment"># Lint-staged配置</span><br>├── package.json                    <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js               <span class="hljs-comment"># PostCSS配置</span><br>├── tailwind.config.js              <span class="hljs-comment"># Tailwind CSS配置</span><br>├── transmart.config.ts             <span class="hljs-comment"># Transmart配置</span><br>├── tsconfig.json                   <span class="hljs-comment"># TypeScript配置</span><br>├── tsconfig.node.json              <span class="hljs-comment"># Node.js TypeScript配置</span><br>└── vite.config.ts                  <span class="hljs-comment"># Vite构建配置</span><br></code></pre></td></tr></table></figure><h3 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h3><p>项目采用数据驱动视图（Data-Driven View）模式，使用<strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>的三层架构</p><p>React 只负责 UI 和事件入口<br>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）<br>PixiJS 层只做”渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建<br>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</p><p>项目主要划分为三个层次：渲染层、状态管理层和逻辑层，来实现关注点分离，提高代码的可维护性和可扩展性。</p><h4 id="渲染层"><a href="#渲染层" class="headerlink" title="渲染层"></a><strong>渲染层</strong></h4><p>主要由 PixiJS (WebGL) 负责处理图形渲染，包括创建、更新和删除图形对象。这一层负责将状态管理层的数据转换为可视化的图形元素，并处理用户的交互操作，如拖拽、缩放和旋转等</p><h4 id="状态管理层"><a href="#状态管理层" class="headerlink" title="状态管理层"></a><strong>状态管理层</strong></h4><p>采用 Zustand 管理 JSON 画布数据。<br>先定义一个 CanvasState 接口（JSON 数据结构，包含 id, type, x, y, width, height 等属性）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span> <span class="hljs-comment">// 当前工具类型</span><br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt; <span class="hljs-comment">// 画布元素集合</span><br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[] <span class="hljs-comment">// 选中元素ID列表</span><br>  <span class="hljs-attr">editingId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 正在编辑的元素ID</span><br>  <span class="hljs-attr">clipboard</span>: <span class="hljs-title class_">CanvasElement</span>[] | <span class="hljs-literal">null</span> <span class="hljs-comment">// 剪贴板数据</span><br>  <span class="hljs-attr">pasteOffset</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 粘贴偏移计数</span><br>  <span class="hljs-attr">currentStyle</span>: {<br>    <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-comment">// ... 其他样式属性</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p>使用 Zustand 状态管理库，其中 elements 被定义为 Record<string, CanvasElement="">类型，表示一个以 id 为键，CanvasElement 为值的对象，用于存储画布上的所有元素。更新元素时使用 structuredClone 函数来克隆状态数据。后续持久化存储和撤销重做机制也是基于这一套状态管理来实现。这一层作为数据核心，主要维护画布上所有元素的状态信息，通过集中管理状态，确保了数据的一致性，便于后续的协同编辑和撤销重做功能的开发。</string,></p><h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a><strong>逻辑层</strong></h4><p>核心是 StageManagerCore 类，通过 StageManagerState 接口管理交互状态，包括当前交互模式、起始位置、当前元素 ID、初始元素状态等，处理多种交互模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">idle - 空闲状态<br>panning - 画布平移<br>selecting - 选择元素<br>dragging - 拖拽元素<br>resizing - 调整元素大小<br>drawing - 绘制元素<br>texting - 文本编辑<br>erasing - 擦除元素<br></code></pre></td></tr></table></figure><p>处理多种元素操作逻辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建元素 - 根据不同工具类型创建相应元素<br>选择元素 - 支持单选和多选<br>拖拽元素 - 记录初始状态，计算偏移量<br>调整大小 - 通过控制手柄调整元素尺寸<br>删除元素 - 通过橡皮擦工具删除元素<br></code></pre></td></tr></table></figure><p>通过这种方式来实现面向对象编程并封装业务逻辑，提高代码的可维护性，利用后续拓展</p><hr><h3 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h3><p class='item-img' data-src='./assets/image-20251123121234358.png'><img src="./assets/image-20251123121234358.png" alt="image-20251123121234358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互类型}<br>    B --&gt;|创建元素| C[StageManagerCore.onPointerDown]<br>    B --&gt;|拖拽元素| D[StageManagerCore.onPointerMove]<br>    B --&gt;|调整大小| E[StageManagerCore.onHandleDown]<br>    B --&gt;|选择元素| F[StageManagerCore.onPointerUp]<br><br>    C --&gt; G[Zustand Store.addElement]<br>    D --&gt; H[Zustand Store.updateElement]<br>    E --&gt; I[Zustand Store.updateElement]<br>    F --&gt; J[Zustand Store.setSelected]<br><br>    G --&gt; K[Zustand 状态更新]<br>    H --&gt; K<br>    I --&gt; K<br>    J --&gt; K<br><br>    K --&gt; L{状态变化}<br>    L --&gt;|元素变化| M[ElementRenderer.renderElements]<br>    L --&gt;|选择变化| N[TransformerRenderer.renderTransformer]<br><br>    M --&gt; O[PixiJS 图形渲染]<br>    N --&gt; O<br><br>    O --&gt; P[用户看到更新结果]<br><br>    K --&gt; Q[Zustand 持久化]<br>    Q --&gt; R[本地存储/IndexedDB]<br><br>    K --&gt; S[撤销/重做管理]<br>    S --&gt; T[命令栈管理]<br><br>    style A fill:#e1f5fe<br>    style O fill:#e8f5e8<br>    style K fill:#fff3e0<br>    style Q fill:#fce4ec<br></code></pre></td></tr></table></figure><p>流程如下：</p><h4 id="用户交互输入"><a href="#用户交互输入" class="headerlink" title="用户交互输入"></a>用户交互输入</h4><p>所有用户交互事件由 StageManagerCore 处理<br>用户通过鼠标、键盘等方式与画布进行交互：</p><ul><li>创建新元素（点击工具栏选择图形类型后在画布上绘制）</li><li>拖拽元素（选中元素后拖动）</li><li>调整元素大小（拖拽元素控制点）</li><li>选择元素（点击或框选元素）</li></ul><h4 id="创建元素流程"><a href="#创建元素流程" class="headerlink" title="创建元素流程"></a>创建元素流程</h4><ol><li>用户在画布上按下鼠标开始绘制</li><li><a href="">onPointerDown</a>捕获事件，创建新元素</li><li>调用 Zustand store 的<a href="">addElement</a>方法添加元素</li></ol><blockquote><p>创建元素时的中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="拖拽元素流程"><a href="#拖拽元素流程" class="headerlink" title="拖拽元素流程"></a>拖拽元素流程</h4><ol><li>用户按下并拖动已选中的元素</li><li><a href="">onPointerMove</a>持续捕获鼠标移动事件</li><li>实时调用 Zustand store 的<a href="">updateElement</a>更新元素位置</li></ol><blockquote><p>拖拽元素时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="调整大小流程"><a href="#调整大小流程" class="headerlink" title="调整大小流程"></a>调整大小流程</h4><ol><li>用户拖拽元素的控制点（resize handle）</li><li><a href="">onHandleDown</a>捕获控制点拖拽事件</li><li><a href="">onPointerMove</a>计算缩放比例并更新元素大小</li><li>调用 Zustand store 的<a href="">updateElement</a>更新元素属性</li></ol><blockquote><p>调整元素大小时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="交互结束处理"><a href="#交互结束处理" class="headerlink" title="交互结束处理"></a>交互结束处理</h4><ol><li>用户释放鼠标按键，<a href="">onPointerUp</a>处理交互结束,解锁撤销/重做管理器</li><li>创建相应的命令（<a href="">UpdateElementCommand</a>并添加到命令栈中</li><li>清理临时状态</li></ol><h4 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h4><p>Zustand 作为全局状态管理器，处理所有状态更新：</p><ol><li><strong>状态更新</strong>：自定义一套<a href="">originalSet</a>方法更新状态</li><li><strong>撤销/重做处理</strong>：创建状态快照并生成命令对象</li><li><strong>状态订阅</strong>：通知所有订阅者状态变化</li></ol><h4 id="渲染更新"><a href="#渲染更新" class="headerlink" title="渲染更新"></a>渲染更新</h4><p>Zustand 状态变化触发 StageManagerCore 的订阅回调：</p><ol><li><a href="">ElementRenderer.renderElements</a> 根据元素数据更新 PixiJS 图形对象</li><li><a href="">TransformerRenderer.renderTransformer</a> 更新选中元素的变换控制器</li><li>PixiJS 自动进行渲染</li></ol><h4 id="撤销-重做管理"><a href="#撤销-重做管理" class="headerlink" title="撤销/重做管理"></a>撤销/重做管理</h4><p>通过命令模式实现撤销/重做功能：</p><ol><li>每个操作生成对应的命令对象（<a href="">UpdateElementCommand</a>、<a href="">SnapshotCommand</a>等）</li><li>命令对象保存操作前后的状态快照</li><li>通过<a href="">UndoRedoManager</a>管理命令栈，实现撤销和重做功能</li></ol><h4 id="数据持久化阶段"><a href="#数据持久化阶段" class="headerlink" title="数据持久化阶段"></a>数据持久化阶段</h4><p>Zustand 状态变化同时触发数据持久化：</p><ol><li>状态通过<a href="">persist</a>中间件自动保存到本地存储</li><li>数据存储在 IndexedDB 中，来支持离线使用</li></ol><blockquote><p>这一块还在写</p></blockquote><hr><h3 id="设计的相关考虑"><a href="#设计的相关考虑" class="headerlink" title="设计的相关考虑"></a>设计的相关考虑</h3><p><strong>解耦</strong>：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展</p><p><strong>便于后续的协同编辑</strong>：实现多人协同，要监听 WebSocket 消息，然后更新 Zustand Store。StageManager 可以去监听到 Store 的变化，并作出相应的渲染更新</p><p><strong>对撤销/重做的实现</strong>：因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照</p><p><strong>序列化/反序列化</strong>：保存项目只需 JSON.stringify(store.elements)</p><h4 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h4><p>【待补充】</p><h2 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h2><p>部署地址：<a href="https://zhongye1.github.io/BDdraw_DEV/">https://zhongye1.github.io/BDdraw_DEV/</a></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h4 id="【P0】基础渲染"><a href="#【P0】基础渲染" class="headerlink" title="【P0】基础渲染"></a><del>【P0】基础渲染</del></h4><ul><li><del>支持图形渲染，需要支持至少 3 种不同图形，比如矩形、圆角矩形、圆形、三角形等。需要支持以下图形属性：</del><ul><li><del>背景色（background）</del></li><li><del>边框宽度（border-width）</del></li><li><del>边框颜色（border-color）</del></li></ul></li><li><del>支持图片渲染，需要支持 png、jpeg 格式，支持设置三种简单滤镜</del></li><li><del>支持富文本文字渲染，需要支持以下文本属性：</del><ul><li><del>字体（font-family）</del></li><li><del>字号（font-size）</del></li><li><del>颜色（color）</del></li><li><del>背景色（background）</del></li><li><del>BIUS（加粗、斜体、下划线、删除线）</del></li></ul></li></ul><h4 id="【P0】画布交互"><a href="#【P0】画布交互" class="headerlink" title="【P0】画布交互"></a><del>【P0】画布交互</del></h4><ul><li><del>支持无限画布的缩放、滚动、拖拽</del><ul><li><del>支持无限画布滚动条</del></li><li><del>支持无限画布的 minimap 功能</del></li></ul></li><li><del>支持选区功能：</del><ul><li><del>点击选中单个元素</del></li><li><del>框选选中多个元素</del></li></ul></li><li><del>支持数据持久化，每次操作后自动保存数据，刷新页面数据仍然存在</del></li><li><del>快捷键复制选中元素</del></li><li><del>支持辅助线功能</del></li></ul><h4 id="【P0】调参工具栏"><a href="#【P0】调参工具栏" class="headerlink" title="【P0】调参工具栏"></a><del>【P0】调参工具栏</del></h4><ul><li><del>浮动工具栏</del><ul><li><del>当选中文本元素时出现在上方，支持设置不同文本属性</del>（做了个编辑器）</li><li><del>当选中图形元素时出现在上方，支持设置不同图形属性</del></li><li><del>选中文本元素的部分文字时也能够出现，支持设置局部文本的文本属性</del>（编辑器内编辑可实现）</li></ul></li></ul><h4 id="【P0】元素编辑"><a href="#【P0】元素编辑" class="headerlink" title="【P0】元素编辑"></a><del>【P0】元素编辑</del></h4><ul><li><del>支持双击文本进入编辑，可以输入/删除文本内容</del></li><li><del>支持对选中元素（单个或多个）删除</del></li><li><del>支持对选中元素（单个或多个）拖拽</del></li><li><del>支持对选中元素（单个或多个）缩放</del></li><li><del>支持对选中元素（单个或多个）旋转</del></li><li><del>支持对多个元素进行组合操作，组合可以嵌套</del></li><li><del>支持对多个元素进行打组、解组</del><del>(组操作 bug 复现了，目前在修)</del>（已修复）</li></ul><h4 id="【P0】性能优化"><a href="#【P0】性能优化" class="headerlink" title="【P0】性能优化"></a><del>【P0】性能优化</del></h4><ul><li><del>画布存在 100 个元素，打开页面到渲染完成 &lt; 3s</del></li><li><del>同时操作 100 个元素，FPS 50+</del></li></ul><h4 id="【P1】协同"><a href="#【P1】协同" class="headerlink" title="【P1】协同"></a><del>【P1】协同</del></h4><ul><li><del>支持 undo &amp; redo 操作</del> <del>（大体实现了，可能要修一下 undo，redo 栈，有个不能稳定复现的 bug）</del>（已实现）</li><li><del>支持协同编辑，多人打开同一个画布可以协同编辑</del> (写了个 Node.js 后端)</li><li><del>支持离线编辑，断网后仍然可以对画布编辑，恢复网络后自动提交数据</del>（IndexedDB）</li></ul><blockquote><p>各模块的技术文档补充中<br>此文档最后编辑于 2025.11.27<br>项目开发中，欢迎提 issue 和 pr</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BDdraw-DEV&quot;&gt;&lt;a href=&quot;#BDdraw-DEV&quot; class=&quot;headerlink&quot; title=&quot;BDdraw_DEV&quot;&gt;&lt;/a&gt;BDdraw_DEV&lt;/h1&gt;&lt;p&gt;代码仓库：&lt;br&gt;&lt;a href=&quot;https://github.com/Z</summary>
      
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="excalidraw" scheme="https://zhongye1.github.io/Arknight-notes/tags/excalidraw/"/>
    
    <category term="github" scheme="https://zhongye1.github.io/Arknight-notes/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-27-前端学习-关于JavaScript 实现哈希表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39960.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39960.html</id>
    <published>2025-11-27T03:31:39.000Z</published>
    <updated>2025-12-26T09:09:52.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-实现哈希表"><a href="#JavaScript-实现哈希表" class="headerlink" title="JavaScript 实现哈希表"></a>JavaScript 实现哈希表</h1><p><strong>哈希表</strong>（Hash Table，散列表）是一种通过键（Key）直接访问值（Value）的数据结构，通过哈希函数将键映射到表中的位置</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 简单的哈希函数示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashString</span>(<span class="hljs-params">key, tableSize</span>) {<br>  <span class="hljs-keyword">let</span> hash = <span class="hljs-number">17</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-property">length</span>; i++) {<br>    hash = (<span class="hljs-number">13</span> * hash * key.<span class="hljs-title function_">charCodeAt</span>(i)) % tableSize;<br>  }<br>  <span class="hljs-keyword">return</span> hash;<br>}<br></code></pre></td></tr></table></figure><h2 id="用-JavaScript-实现哈希表"><a href="#用-JavaScript-实现哈希表" class="headerlink" title="用 JavaScript 实现哈希表"></a>用 JavaScript 实现哈希表</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 哈希函数</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX_LENGTH</span> = <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(key.<span class="hljs-property">length</span>, <span class="hljs-variable constant_">MAX_LENGTH</span>); i++) {<br>      <span class="hljs-keyword">const</span> char = key[i];<br>      <span class="hljs-keyword">const</span> value = char.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">96</span>; <span class="hljs-comment">// a=1, b=2...</span><br>      total = (total * <span class="hljs-variable constant_">PRIME</span> + value) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>;<br>    }<br>    <span class="hljs-keyword">return</span> total;<br>  }<br><br>  <span class="hljs-comment">// 插入键值对</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index] = [];<br>    }<br>    <br>    <span class="hljs-comment">// 检查键是否已存在，存在则更新</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>  }<br><br>  <span class="hljs-comment">// 获取值</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>];<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-comment">// 删除键值对</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取所有键</span><br>  <span class="hljs-title function_">keys</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> keysArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!keysArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>])) {<br>            keysArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> keysArr;<br>  }<br><br>  <span class="hljs-comment">// 获取所有值</span><br>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> valuesArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!valuesArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>])) {<br>            valuesArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> valuesArr;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialCapacity = <span class="hljs-number">8</span>, loadFactor = <span class="hljs-number">0.75</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = initialCapacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span> = loadFactor;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>  }<br><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> hashCode = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <br>    <span class="hljs-comment">// 处理不同类型的键</span><br>    <span class="hljs-keyword">const</span> keyStr = <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span> ? key : <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keyStr.<span class="hljs-property">length</span>; i++) {<br>      hashCode = (<span class="hljs-variable constant_">PRIME</span> * hashCode + keyStr.<span class="hljs-title function_">charCodeAt</span>(i)) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>    }<br>    <span class="hljs-keyword">return</span> hashCode;<br>  }<br><br>  <span class="hljs-title function_">_resize</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> oldBuckets = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> *= <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bucket <span class="hljs-keyword">of</span> oldBuckets) {<br>      <span class="hljs-keyword">if</span> (bucket) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> bucket) {<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">set</span>(key, value);<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-comment">// 检查是否需要扩容</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_resize</span>();<br>    }<br><br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index] = [];<br>    }<br><br>    <span class="hljs-comment">// 更新或添加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">const</span> bucket = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index];<br>    <br>    <span class="hljs-keyword">if</span> (bucket) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> bucket) {<br>        <span class="hljs-keyword">if</span> (k === key) <span class="hljs-keyword">return</span> v;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(key) !== <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取负载因子</span><br>  <span class="hljs-title function_">getLoadFactor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="支持任何类型键的通用哈希表"><a href="#支持任何类型键的通用哈希表" class="headerlink" title="支持任何类型键的通用哈希表"></a>支持任何类型键的通用哈希表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniversalHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 通用哈希函数，支持多种类型</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'number'</span>) {<br>      <span class="hljs-keyword">return</span> key % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span>) {<br>      <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-property">length</span>; i++) {<br>        hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + key.<span class="hljs-title function_">charCodeAt</span>(i);<br>        hash = hash &amp; hash; <span class="hljs-comment">// 转为32位整数</span><br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'object'</span> &amp;&amp; key !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 对象使用JSON字符串化</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key));<br>    }<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希解决冲突</span><br>  <span class="hljs-title function_">_hash2</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key) % <span class="hljs-number">7</span>);<br>  }<br><br>  <span class="hljs-comment">// 使用线性探测开放寻址</span><br>  <span class="hljs-title function_">_findSlot</span>(<span class="hljs-params">key, forInsert = <span class="hljs-literal">false</span></span>) {<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">let</span> step = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">undefined</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到键</span><br>      }<br>      <br>      <span class="hljs-keyword">if</span> (forInsert &amp;&amp; (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">undefined</span>)) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到可插入的空槽</span><br>      }<br>      <br>      <span class="hljs-comment">// 线性探测</span><br>      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>      step++;<br>      <br>      <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Hash table is full'</span>);<br>      }<br>    }<br>    <br>    <span class="hljs-keyword">return</span> forInsert ? index : -<span class="hljs-number">1</span>;<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">true</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = { key, value };<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> index !== -<span class="hljs-number">1</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">value</span> : <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 标记为删除</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="使用-JavaScript-内置结构"><a href="#使用-JavaScript-内置结构" class="headerlink" title="使用 JavaScript 内置结构"></a>使用 JavaScript 内置结构</h2><p>使用 Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 最简单的哈希表实现</span><br><span class="hljs-keyword">const</span> hashTable = {};<br>hashTable[<span class="hljs-string">'key1'</span>] = <span class="hljs-string">'value1'</span>;<br>hashTable[<span class="hljs-string">'key2'</span>] = <span class="hljs-string">'value2'</span>;<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-keyword">const</span> value = hashTable[<span class="hljs-string">'key1'</span>];<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> hashTable[<span class="hljs-string">'key1'</span>];<br></code></pre></td></tr></table></figure><p>使用 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 Map 是更好的哈希表实现</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 设置键值对</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'name'</span>, <span class="hljs-string">'Alice'</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">42</span>, <span class="hljs-string">'The Answer'</span>);<br>map.<span class="hljs-title function_">set</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }, <span class="hljs-string">'Object Key'</span>);<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'name'</span>)); <span class="hljs-comment">// Alice</span><br><br><span class="hljs-comment">// 检查是否存在</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br>map.<span class="hljs-title function_">delete</span>(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// 大小</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>);<br><br><span class="hljs-comment">// 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>});<br><br><span class="hljs-comment">// 清空</span><br>map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>使用 Set（类似哈希集合）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用于存储唯一值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复，不会被添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>);   <span class="hljs-comment">// 2</span><br><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>选择合适的哈希函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 更好的字符串哈希函数（djb2算法）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashDJB2</span>(<span class="hljs-params">str, tableSize</span>) {<br>  <span class="hljs-keyword">let</span> hash = <span class="hljs-number">5381</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) {<br>    hash = (hash * <span class="hljs-number">33</span>) ^ str.<span class="hljs-title function_">charCodeAt</span>(i);<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % tableSize;<br>}<br></code></pre></td></tr></table></figure><p>优化冲突处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleted</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'deleted'</span>); <span class="hljs-comment">// 特殊标记删除</span><br>  }<br><br>  <span class="hljs-comment">// 二次探测</span><br>  <span class="hljs-title function_">_probe</span>(<span class="hljs-params">index, i, tableSize</span>) {<br>    <span class="hljs-keyword">return</span> (index + i * i) % tableSize;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希</span><br>  <span class="hljs-title function_">_doubleHash</span>(<span class="hljs-params">index, i, tableSize, key</span>) {<br>    <span class="hljs-keyword">const</span> hash2 = <span class="hljs-number">1</span> + (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash2</span>(key) % (tableSize - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> (index + i * hash2) % tableSize;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>频率计数器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">frequencyCounter</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">const</span> frequency = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) {<br>    frequency.<span class="hljs-title function_">set</span>(item, (frequency.<span class="hljs-title function_">get</span>(item) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> frequency;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'banana'</span>];<br><span class="hljs-keyword">const</span> freq = <span class="hljs-title function_">frequencyCounter</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(freq.<span class="hljs-title function_">get</span>(<span class="hljs-string">'banana'</span>)); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>缓存实现（LRU Cache）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 哈希表 + 维护顺序</span><br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value); <span class="hljs-comment">// 更新为最近使用</span><br>    <br>    <span class="hljs-keyword">return</span> value;<br>  }<br><br>  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>      <span class="hljs-comment">// 删除最久未使用的</span><br>      <span class="hljs-keyword">const</span> oldestKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(oldestKey);<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value);<br>  }<br>}<br></code></pre></td></tr></table></figure><p>分组算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">groupBy</span>(<span class="hljs-params">array, keyFn</span>) {<br>  <span class="hljs-keyword">const</span> groups = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) {<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">typeof</span> keyFn === <span class="hljs-string">'function'</span> <br>      ? <span class="hljs-title function_">keyFn</span>(item) <br>      : item[keyFn];<br>    <br>    <span class="hljs-keyword">if</span> (!groups.<span class="hljs-title function_">has</span>(key)) {<br>      groups.<span class="hljs-title function_">set</span>(key, []);<br>    }<br>    <br>    groups.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">push</span>(item);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> groups;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> people = [<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> }<br>];<br><br><span class="hljs-keyword">const</span> groupedByAge = <span class="hljs-title function_">groupBy</span>(people, <span class="hljs-string">'age'</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(groupedByAge.<span class="hljs-title function_">get</span>(<span class="hljs-number">25</span>));<br><span class="hljs-comment">// [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }]</span><br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><div class="table-container"><table><thead><tr><th>操作</th><th>Object</th><th>Map</th><th>自定义哈希表</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>遍历键</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div><p>最坏情况（所有键冲突）会退化为 O(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-实现哈希表&quot;&gt;&lt;a href=&quot;#JavaScript-实现哈希表&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 实现哈希表&quot;&gt;&lt;/a&gt;JavaScript 实现哈希表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;哈希表&lt;/s</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-25 关于JavaScript链表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33314.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33314.html</id>
    <published>2025-11-25T05:00:48.000Z</published>
    <updated>2025-12-26T09:10:01.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-JavaScript-链表"><a href="#关于-JavaScript-链表" class="headerlink" title="关于 JavaScript 链表"></a>关于 JavaScript 链表</h1><p>链表是一种常见的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用，在 JavaScript 中广泛应用于算法问题和实际开发</p><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><h5 id="1-单向链表的实现"><a href="#1-单向链表的实现" class="headerlink" title="1. 单向链表的实现"></a>1. 单向链表的实现</h5><p>下面是一个简单的单向链表的实现，包括节点定义和基本操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value; <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向下一个节点的指针，初始为 null</span><br>  }<br>}<br><br><span class="hljs-comment">// 定义单向链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表头节点，初始为 null</span><br>  }<br><br>  <span class="hljs-comment">// 在链表末尾添加节点</span><br>  <span class="hljs-title function_">append</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 如果链表为空，新的节点作为头节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>      <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-comment">// 遍历链表找到最后一个节点</span><br>        current = current.<span class="hljs-property">next</span>;<br>      }<br>      current.<span class="hljs-property">next</span> = newNode; <span class="hljs-comment">// 将新的节点添加到最后一个节点的 next</span><br>    }<br>  }<br><br>  <span class="hljs-comment">// 在链表头部添加节点</span><br>  <span class="hljs-title function_">prepend</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>; <span class="hljs-comment">// 新节点的 next 指向当前的头节点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode; <span class="hljs-comment">// 新节点作为头节点</span><br>  }<br><br>  <span class="hljs-comment">// 删除指定值的节点</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果链表为空，直接返回</span><br><br>    <span class="hljs-comment">// 如果头节点就是要删除的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">value</span> === value) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>      <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">next</span>.<span class="hljs-property">value</span> === value) {<br>        <span class="hljs-comment">// 找到要删除的节点</span><br>        current.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>; <span class="hljs-comment">// 将要删除的节点移出链表</span><br>        <span class="hljs-keyword">return</span>;<br>      }<br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>  }<br><br>  <span class="hljs-comment">// 打印链表</span><br>  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>      process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">${current.value}</span> -&gt; `</span>); <span class="hljs-comment">// 输出当前节点的值</span><br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"null"</span>); <span class="hljs-comment">// 表示链表结束</span><br>  }<br>}<br><br><span class="hljs-comment">// 示例：使用单向链表</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>list.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>list.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>list.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>list.<span class="hljs-title function_">prepend</span>(<span class="hljs-number">0</span>);<br>list.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; null</span><br>list.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);<br>list.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 -&gt; 1 -&gt; 3 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="2-双向链表的实现"><a href="#2-双向链表的实现" class="headerlink" title="2. 双向链表的实现"></a>2. 双向链表的实现</h5><p>下面是一个简单的双向链表的实现，包括节点定义和基本操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义双向节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyListNode</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value; <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向下一个节点的指针，初始为 null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向前一个节点的指针，初始为 null</span><br>  }<br>}<br><br><span class="hljs-comment">// 定义双向链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表头节点，初始为 null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表尾节点，初始为 null</span><br>  }<br><br>  <span class="hljs-comment">// 在链表末尾添加节点</span><br>  <span class="hljs-title function_">append</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> === <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 如果链表为空，新的节点作为头和尾节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">next</span> = newNode; <span class="hljs-comment">// 将新的节点添加到尾节点的 next</span><br>      newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>; <span class="hljs-comment">// 新节点的 prev 指向当前的尾节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode; <span class="hljs-comment">// 新节点作为新的尾节点</span><br>    }<br>  }<br><br>  <span class="hljs-comment">// 在链表头部添加节点</span><br>  <span class="hljs-title function_">prepend</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 如果链表为空，新的节点作为头和尾节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span> = newNode; <span class="hljs-comment">// 头节点的 prev 指向新的节点</span><br>      newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>; <span class="hljs-comment">// 新节点的 next 指向当前的头节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode; <span class="hljs-comment">// 新节点作为新的头节点</span><br>    }<br>  }<br><br>  <span class="hljs-comment">// 删除指定值的节点</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果链表为空，直接返回</span><br><br>    <span class="hljs-comment">// 如果头节点就是要删除的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">value</span> === value) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>;<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 如果链表为空，更新尾节点</span><br>      }<br>      <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">value</span> === value) {<br>        <span class="hljs-comment">// 找到要删除的节点</span><br>        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>          current.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = current.<span class="hljs-property">prev</span>;<br>        } <span class="hljs-keyword">else</span> {<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = current.<span class="hljs-property">prev</span>; <span class="hljs-comment">// 更新尾节点</span><br>        }<br>        current.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>  }<br><br>  <span class="hljs-comment">// 打印链表</span><br>  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>      process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">${current.value}</span> &lt;-&gt; `</span>); <span class="hljs-comment">// 输出当前节点的值</span><br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"null"</span>); <span class="hljs-comment">// 表示链表结束</span><br>  }<br>}<br><br><span class="hljs-comment">// 示例：使用双向链表</span><br><span class="hljs-keyword">const</span> dList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyLinkedList</span>();<br>dList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>dList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>dList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>dList.<span class="hljs-title function_">prepend</span>(<span class="hljs-number">0</span>);<br>dList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; null</span><br>dList.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);<br>dList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 &lt;-&gt; 1 &lt;-&gt; 3 &lt;-&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="查找某个元素"><a href="#查找某个元素" class="headerlink" title="查找某个元素"></a>查找某个元素</h5><p><strong>问题描述</strong>：在链表中查找指定值的节点，并返回其位置索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查找指定值的节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 要查找的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 节点的位置索引，如果未找到返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findElement</span>(<span class="hljs-params">list, value</span>) {<br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">if</span> (current.<span class="hljs-property">value</span> === value) {<br>      <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到值，返回索引</span><br>    }<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到，返回-1</span><br>}<br><br><span class="hljs-comment">// 示例：查找元素</span><br><span class="hljs-keyword">const</span> searchList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findElement</span>(searchList, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findElement</span>(searchList, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 -1</span><br></code></pre></td></tr></table></figure><h5 id="2-在指定位置插入元素"><a href="#2-在指定位置插入元素" class="headerlink" title="2. 在指定位置插入元素"></a>2. 在指定位置插入元素</h5><p><strong>问题描述</strong>：在链表的指定位置插入新节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在指定位置插入节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">position</span> - 插入位置（从0开始）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 要插入的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 插入成功返回true，否则返回false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtPosition</span>(<span class="hljs-params">list, position, value</span>) {<br>  <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 位置无效</span><br>  }<br><br>  <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 在头部插入</span><br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value);<br>    newNode.<span class="hljs-property">next</span> = list.<span class="hljs-property">head</span>;<br>    list.<span class="hljs-property">head</span> = newNode;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 找到指定位置的前一个节点</span><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; index &lt; position - <span class="hljs-number">1</span>) {<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-comment">// 如果位置超出链表长度</span><br>  <span class="hljs-keyword">if</span> (index !== position - <span class="hljs-number">1</span> &amp;&amp; current === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 插入新节点</span><br>  <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value);<br>  newNode.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;<br>  current.<span class="hljs-property">next</span> = newNode;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 示例：在指定位置插入元素</span><br><span class="hljs-keyword">const</span> insertList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>insertList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>insertList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>insertList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><br>insertList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">insertAtPosition</span>(insertList, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 在索引2的位置插入3</span><br>insertList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">insertAtPosition</span>(insertList, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 在开头插入0</span><br>insertList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="3-查找指定位置的元素"><a href="#3-查找指定位置的元素" class="headerlink" title="3. 查找指定位置的元素"></a>3. 查找指定位置的元素</h5><p><strong>问题描述</strong>：获取链表中指定位置的元素值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取指定位置的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">position</span> - 位置索引（从0开始）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any|undefined</span>} - 位置上的值，如果位置无效返回undefined</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getElementAtPosition</span>(<span class="hljs-params">list, position</span>) {<br>  <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || list.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 位置无效或链表为空</span><br>  }<br><br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; index &lt; position) {<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-keyword">if</span> (index === position &amp;&amp; current !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> current.<span class="hljs-property">value</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 位置超出链表长度</span><br>}<br><br><span class="hljs-comment">// 示例：获取指定位置的元素</span><br><span class="hljs-keyword">const</span> positionList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>positionList.<span class="hljs-title function_">append</span>(<span class="hljs-number">10</span>);<br>positionList.<span class="hljs-title function_">append</span>(<span class="hljs-number">20</span>);<br>positionList.<span class="hljs-title function_">append</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getElementAtPosition</span>(positionList, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getElementAtPosition</span>(positionList, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getElementAtPosition</span>(positionList, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 undefined</span><br></code></pre></td></tr></table></figure><h5 id="4-删除指定位置的元素"><a href="#4-删除指定位置的元素" class="headerlink" title="4. 删除指定位置的元素"></a>4. 删除指定位置的元素</h5><p><strong>问题描述</strong>：删除链表中指定位置的节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除指定位置的节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">position</span> - 要删除的位置（从0开始）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 删除成功返回true，否则返回false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAtPosition</span>(<span class="hljs-params">list, position</span>) {<br>  <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || list.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 位置无效或链表为空</span><br>  }<br><br>  <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 删除头节点</span><br>    list.<span class="hljs-property">head</span> = list.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 找到指定位置的前一个节点</span><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; index &lt; position - <span class="hljs-number">1</span>) {<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-comment">// 如果位置超出链表长度</span><br>  <span class="hljs-keyword">if</span> (index !== position - <span class="hljs-number">1</span> || current.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 删除节点</span><br>  current.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 示例：删除指定位置的元素</span><br><span class="hljs-keyword">const</span> deleteList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><br>deleteList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">deleteAtPosition</span>(deleteList, <span class="hljs-number">2</span>); <span class="hljs-comment">// 删除索引2的位置（值为3）</span><br>deleteList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">deleteAtPosition</span>(deleteList, <span class="hljs-number">0</span>); <span class="hljs-comment">// 删除索引0的位置（值为1）</span><br>deleteList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 2 -&gt; 4 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="5-获取链表长度"><a href="#5-获取链表长度" class="headerlink" title="5. 获取链表长度"></a>5. 获取链表长度</h5><p><strong>问题描述</strong>：计算链表中节点的数量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取链表长度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 链表长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getListLength</span>(<span class="hljs-params">list</span>) {<br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>    length++;<br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> length;<br>}<br><br><span class="hljs-comment">// 示例：获取链表长度</span><br><span class="hljs-keyword">const</span> lengthList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getListLength</span>(lengthList)); <span class="hljs-comment">// 输出 3</span><br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getListLength</span>(lengthList)); <span class="hljs-comment">// 输出 4</span><br></code></pre></td></tr></table></figure><hr><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul><li>查找元素：根据值查找节点位置</li><li>指定位置插入：在特定位置插入新节点</li><li>指定位置获取：获取特定位置的节点值</li><li>指定位置删除：删除特定位置的节点</li><li>递归反转：使用递归方式反转链表</li><li>获取长度：统计链表中节点的数量<h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h5></li></ul><p><strong>问题描述</strong>：反转一个单向链表</p><ul><li>初始化 prev 为 null（新链表的尾部）。</li><li>current 从链表头节点开始。</li><li>在循环中：<ul><li>暂存 next = current.next（避免指针丢失）。</li><li>将 current.next 指向 prev（反转当前指针）。</li><li>更新 prev = current（前移 prev）。</li><li>更新 current = next（前移 current）。</li></ul></li><li>循环结束后，prev 指向原链表的尾节点（新头节点），更新 list.head = prev。</li></ul><p>其实就是三指针原地反转</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp'><img src="https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp" alt="alt text"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反转单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">LinkedList</span>} - 反转后的链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseLinkedList</span>(<span class="hljs-params">list</span>) {<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">let</span> next = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 暂存下一个节点</span><br>    current.<span class="hljs-property">next</span> = prev; <span class="hljs-comment">// 将当前节点的 next 指向前一个节点</span><br>    prev = current; <span class="hljs-comment">// 更新前一个节点为当前节点</span><br>    current = next; <span class="hljs-comment">// 继续遍历下一个节点</span><br>  }<br>  list.<span class="hljs-property">head</span> = prev; <span class="hljs-comment">// 更新头节点为最后一个非空节点</span><br>  <span class="hljs-keyword">return</span> list;<br>}<br><br><span class="hljs-comment">// 示例：反转链表</span><br><span class="hljs-keyword">const</span> rList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>rList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>rList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>rList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>rList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; null</span><br><span class="hljs-title function_">reverseLinkedList</span>(rList);<br>rList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 3 -&gt; 2 -&gt; 1 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h5><p><strong>问题描述</strong>：合并两个有序链表，使结果链表仍然有序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 合并两个有序链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">l1</span> - 第一个有序链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">l2</span> - 第二个有序链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">LinkedList</span>} - 合并后的有序链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">l1, l2</span>) {<br>  <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 创建一个哨兵节点</span><br>  <span class="hljs-keyword">let</span> current = dummy;<br><br>  <span class="hljs-keyword">let</span> p1 = l1.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> p2 = l2.<span class="hljs-property">head</span>;<br><br>  <span class="hljs-comment">// 遍历两个链表</span><br>  <span class="hljs-keyword">while</span> (p1 !== <span class="hljs-literal">null</span> &amp;&amp; p2 !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">if</span> (p1.<span class="hljs-property">value</span> &lt; p2.<span class="hljs-property">value</span>) {<br>      current.<span class="hljs-property">next</span> = p1; <span class="hljs-comment">// 将较小值的节点添加到结果链表中</span><br>      p1 = p1.<span class="hljs-property">next</span>;<br>    } <span class="hljs-keyword">else</span> {<br>      current.<span class="hljs-property">next</span> = p2;<br>      p2 = p2.<span class="hljs-property">next</span>;<br>    }<br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 将剩余的节点连接到结果链表中</span><br>  <span class="hljs-keyword">if</span> (p1 !== <span class="hljs-literal">null</span>) {<br>    current.<span class="hljs-property">next</span> = p1;<br>  }<br>  <span class="hljs-keyword">if</span> (p2 !== <span class="hljs-literal">null</span>) {<br>    current.<span class="hljs-property">next</span> = p2;<br>  }<br><br>  <span class="hljs-keyword">let</span> mergedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>  mergedList.<span class="hljs-property">head</span> = dummy.<span class="hljs-property">next</span>; <span class="hljs-comment">// 哨兵节点的 next 为合并后的头节点</span><br>  <span class="hljs-keyword">return</span> mergedList;<br>}<br><br><span class="hljs-comment">// 示例：合并两个有序链表</span><br><span class="hljs-keyword">const</span> list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>list1.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>list1.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>list1.<span class="hljs-title function_">append</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">const</span> list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>list2.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>list2.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br>list2.<span class="hljs-title function_">append</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-keyword">const</span> mergedList = <span class="hljs-title function_">mergeTwoLists</span>(list1, list2);<br>mergedList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</span><br></code></pre></td></tr></table></figure><hr><p>更新中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于-JavaScript-链表&quot;&gt;&lt;a href=&quot;#关于-JavaScript-链表&quot; class=&quot;headerlink&quot; title=&quot;关于 JavaScript 链表&quot;&gt;&lt;/a&gt;关于 JavaScript 链表&lt;/h1&gt;&lt;p&gt;链表是一种常见的数据结构，由</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="链表" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-Undo/Redo机制具体实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/52695.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/52695.html</id>
    <published>2025-11-23T11:15:00.000Z</published>
    <updated>2025-11-23T16:03:47.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>Undo/Redo 机制是画布应用中实现操作撤销和重做的核心功能模块。它基于命令模式（Command Pattern）实现来，管理操作历史、执行撤销/重做操作和防止操作冲突，通过维护撤销栈和重做栈来管理用户的操作历史。</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>├── lib/<br>│   ├── UndoRedoManager.ts        <span class="hljs-comment"># 撤销重做管理器核心实现</span><br>│   └── UpdateElementCommand.ts   <span class="hljs-comment"># 元素更新命令实现</span><br>└── stores/<br>    └── canvasStore.ts            <span class="hljs-comment"># 状态存储，命令操作的目标</span><br></code></pre></td></tr></table></figure><ul><li><code>Command Pattern</code>：设计模式，用于封装操作命令</li><li><code>Zustand</code>：状态管理库，作为命令操作的目标</li><li><code>TypeScript</code>：提供类型安全和代码可维护性</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-UndoRedoManager-核心方法"><a href="#2-1-UndoRedoManager-核心方法" class="headerlink" title="2.1 UndoRedoManager 核心方法"></a>2.1 UndoRedoManager 核心方法</h4><p>撤销重做管理器提供了一系列核心方法用于管理操作命令。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>参数</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>executeCommand</td><td>command: Command</td><td>void</td><td>执行并记录命令</td></tr><tr><td>undo</td><td>无</td><td>void</td><td>执行撤销操作</td></tr><tr><td>redo</td><td>无</td><td>void</td><td>执行重做操作</td></tr><tr><td>lock</td><td>无</td><td>void</td><td>锁定管理器，防止记录新命令</td></tr><tr><td>unlock</td><td>无</td><td>void</td><td>解锁管理器</td></tr><tr><td>isLocked</td><td>无</td><td>boolean</td><td>检查管理器是否被锁定</td></tr><tr><td>canUndo</td><td>无</td><td>boolean</td><td>检查是否可以撤销</td></tr><tr><td>canRedo</td><td>无</td><td>boolean</td><td>检查是否可以重做</td></tr></tbody></table></div><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口</strong>：<br>定义了命令对象必须实现的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><p><strong>UpdateOperation 接口</strong>：<br>定义了元素更新操作的数据结构。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 元素ID</span><br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><blockquote><p>⚠️ 为防止在执行撤销/重做操作时记录新的命令，系统实现了锁定机制。在执行命令时会先锁定管理器，执行完成后再解锁，确保操作的原子性。</p></blockquote><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>UndoRedoManager 维护以下内部状态用于管理操作历史：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>undoStack</td><td>Command[]</td><td>撤销命令栈，存储可以撤销的命令</td></tr><tr><td>redoStack</td><td>Command[]</td><td>重做命令栈，存储可以重做的命令</td></tr><tr><td>locked</td><td>boolean</td><td>锁定状态，防止在执行命令时记录新命令</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>Undo/Redo 机制通过 Zustand 状态管理库操作外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据，命令操作的目标</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户操作] --&gt; B{StageManager}<br>    B --&gt; C[创建命令对象]<br>    C --&gt; D[UndoRedoManager.executeCommand]<br>    D --&gt; E{管理器锁定?}<br>    E --&gt;|是| F[忽略命令]<br>    E --&gt;|否| G[执行命令]<br>    G --&gt; H[命令入撤销栈]<br>    H --&gt; I[清空重做栈]<br>    I --&gt; J[Zustand 状态更新]<br>    <br>    subgraph 撤销操作<br>      K[UndoRedoManager.undo]<br>      K --&gt; L{撤销栈空?}<br>      L --&gt;|是| M[无法撤销]<br>      L --&gt;|否| N[弹出命令]<br>      N --&gt; O[执行命令.undo]<br>      O --&gt; P[命令入重做栈]<br>      P --&gt; Q[Zustand 状态更新]<br>    end<br>    <br>    subgraph 重做操作<br>      R[UndoRedoManager.redo]<br>      R --&gt; S{重做栈空?}<br>      S --&gt;|是| T[无法重做]<br>      S --&gt;|否| U[弹出命令]<br>      U --&gt; V[执行命令.redo]<br>      V --&gt; W[命令入撤销栈]<br>      W --&gt; X[Zustand 状态更新]<br>    end<br>    <br>    style A fill:#e1f5fe<br>    style J fill:#e8f5e8<br>    style Q fill:#e8f5e8<br>    style X fill:#e8f5e8<br>    style F fill:#ffebee<br></code></pre></td></tr></table></figure><h3 id="4-命令管理机制"><a href="#4-命令管理机制" class="headerlink" title="4. 命令管理机制"></a>4. 命令管理机制</h3><p>Undo/Redo 机制采用命令模式（Command Pattern）来管理操作命令，通过定义统一的接口和不同的实现类来处理各种操作。</p><h4 id="4-1-命令类型"><a href="#4-1-命令类型" class="headerlink" title="4.1 命令类型"></a>4.1 命令类型</h4><p>系统中主要有两种命令类型：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：用于记录整个画布状态的变化，通常用于添加元素、删除元素等较大范围的操作，保存完整的状态快照</p></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：用于记录特定元素的属性变化，主要用于拖拽移动和调整大小操作，只保存相关元素的特定属性变化</p></li></ol><h4 id="4-2-命令接口定义"><a href="#4-2-命令接口定义" class="headerlink" title="4.2 命令接口定义"></a>4.2 命令接口定义</h4><p>所有命令都实现统一的 <a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><h4 id="4-3-快照命令（SnapshotCommand）"><a href="#4-3-快照命令（SnapshotCommand）" class="headerlink" title="4.3 快照命令（SnapshotCommand）"></a>4.3 快照命令（SnapshotCommand）</h4><p>快照命令用于记录整个画布状态的变化，适用于影响范围较大的操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">any</span></span>) {<br>    <span class="hljs-comment">// 使用 structuredClone 进行深拷贝，确保状态隔离</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span> = <span class="hljs-title function_">structuredClone</span>(prevState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span> = <span class="hljs-title function_">structuredClone</span>(nextState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>    <span class="hljs-comment">// 生成唯一的命令ID用于调试</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() % <span class="hljs-number">1000000</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// execute在添加到命令栈之前已经执行了</span><br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之前的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span>);<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之后的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-4-更新元素命令（UpdateElementCommand）"><a href="#4-4-更新元素命令（UpdateElementCommand）" class="headerlink" title="4.4 更新元素命令（UpdateElementCommand）"></a>4.4 更新元素命令（UpdateElementCommand）</h4><p>更新元素命令用于记录特定元素的属性变化，适用于影响范围较小的精细操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operations</span>: <span class="hljs-title class_">UpdateOperation</span>[],</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operationType</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"更新元素"</span></span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-comment">// 生成唯一命令ID</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-string">`UpdateElementCommand-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random()</span></span><br><span class="hljs-subst"><span class="hljs-string">      .toString(<span class="hljs-number">36</span>)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .slice(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)}</span>`</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 应用最终状态</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 撤销：恢复到 initialAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">initialAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 重做：恢复到 finalAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-5-命令生命周期"><a href="#4-5-命令生命周期" class="headerlink" title="4.5 命令生命周期"></a>4.5 命令生命周期</h4><p>命令的生命周期包括创建、执行、撤销和重做四个阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[命令创建] --&gt; B[命令执行]<br>    B --&gt; C{用户操作}<br>    C --&gt;|撤销| D[执行undo方法]<br>    C --&gt;|重做| E[执行redo方法]<br>    D --&gt; F[命令状态切换]<br>    E --&gt; F<br>    F --&gt; G[状态更新完成]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style D fill:#fff3e0<br>    style E fill:#fff3e0<br>    style G fill:#e8f5e8<br></code></pre></td></tr></table></figure><h3 id="5-命令栈管理机制"><a href="#5-命令栈管理机制" class="headerlink" title="5. 命令栈管理机制"></a>5. 命令栈管理机制</h3><p>撤销/重做机制使用两个栈来管理命令历史：</p><ol><li><strong>撤销栈（Undo Stack）</strong>：</li></ol><p>存储用户可以撤销的操作命令，栈顶是最近执行的命令，执行新命令时，命令被推入此栈，执行撤销操作时，命令从此栈弹出并推入重做栈</p><ol><li><strong>重做栈（Redo Stack）</strong>：</li></ol><p>存储用户可以重做的操作命令，在执行撤销操作时，被撤销的命令被推入此栈，执行重做操作时，命令从此栈弹出并推入撤销栈，执行新命令时，此栈被清空</p><h4 id="5-1-命令栈操作流程"><a href="#5-1-命令栈操作流程" class="headerlink" title="5.1 命令栈操作流程"></a>5.1 命令栈操作流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[执行新命令] --&gt; B[命令入撤销栈]<br>    B --&gt; C[清空重做栈]<br>    <br>    D[执行撤销] --&gt; E{撤销栈空?}<br>    E --&gt;|是| F[无操作]<br>    E --&gt;|否| G[弹出命令]<br>    G --&gt; H[执行命令.undo]<br>    H --&gt; I[命令入重做栈]<br>    <br>    J[执行重做] --&gt; K{重做栈空?}<br>    K --&gt;|是| L[无操作]<br>    K --&gt;|否| M[弹出命令]<br>    M --&gt; N[执行命令.redo]<br>    N --&gt; O[命令入撤销栈]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#f3e5f5<br>    style D fill:#e1f5fe<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style J fill:#e1f5fe<br>    style N fill:#e8f5e8<br>    style O fill:#e8f5e8<br></code></pre></td></tr></table></figure><h4 id="5-2-不同类型的命令"><a href="#5-2-不同类型的命令" class="headerlink" title="5.2 不同类型的命令"></a>5.2 不同类型的命令</h4><p>撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：</p><ul><li>用于记录整个画布状态的变化</li><li>通常用于添加元素、删除元素等较大范围的操作</li><li>保存完整的状态快照</li></ul></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：</p><ul><li>用于记录特定元素的属性变化</li><li>主要用于拖拽移动和调整大小操作</li><li>只保存相关元素的特定属性变化</li></ul></li></ol><h4 id="5-3-操作序列和撤销栈状态变化示例"><a href="#5-3-操作序列和撤销栈状态变化示例" class="headerlink" title="5.3 操作序列和撤销栈状态变化示例"></a>5.3 操作序列和撤销栈状态变化示例</h4><h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><p>撤销栈：空<br>重做栈：空</p><h5 id="1-创建元素-A"><a href="#1-创建元素-A" class="headerlink" title="1. 创建元素 A"></a>1. 创建元素 A</h5><p>当创建元素 A 时，系统会生成一个快照命令，记录整个画布状态的变化。<br>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：空</p><h5 id="2-移动-A-到一个位置"><a href="#2-移动-A-到一个位置" class="headerlink" title="2. 移动 A 到一个位置"></a>2. 移动 A 到一个位置</h5><p>当移动元素 A 时，系统会生成一个更新元素命令（UpdateElementCommand），只记录 A 元素位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：空</p><h5 id="3-创建元素-B"><a href="#3-创建元素-B" class="headerlink" title="3. 创建元素 B"></a>3. 创建元素 B</h5><p>当创建元素 B 时，系统会生成另一个快照命令，记录添加 B 元素后的状态。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：空</p><h5 id="4-缩放-B-到一个位置"><a href="#4-缩放-B-到一个位置" class="headerlink" title="4. 缩放 B 到一个位置"></a>4. 缩放 B 到一个位置</h5><p>当缩放元素 B 时，系统会生成一个更新元素命令，记录 B 元素尺寸和位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：空</p><h5 id="5-移动-B-到一个位置"><a href="#5-移动-B-到一个位置" class="headerlink" title="5. 移动 B 到一个位置"></a>5. 移动 B 到一个位置</h5><p>当再次移动元素 B 时，系统会生成另一个更新元素命令，记录 B 元素位置的新变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5)<br>重做栈：空</p><h4 id="5-4-执行撤销操作时的状态变化"><a href="#5-4-执行撤销操作时的状态变化" class="headerlink" title="5.4 执行撤销操作时的状态变化"></a>5.4 执行撤销操作时的状态变化</h4><h5 id="第一次撤销（移动-B-操作）"><a href="#第一次撤销（移动-B-操作）" class="headerlink" title="第一次撤销（移动 B 操作）"></a>第一次撤销（移动 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB</li><li>执行该命令的 undo()方法，将 B 元素恢复到缩放后的位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：[UpdateElementCommand_MoveB] (大小: 1)</p><h5 id="第二次撤销（缩放-B-操作）"><a href="#第二次撤销（缩放-B-操作）" class="headerlink" title="第二次撤销（缩放 B 操作）"></a>第二次撤销（缩放 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB</li><li>执行该命令的 undo()方法，将 B 元素恢复到刚创建时的尺寸和位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)</p><h5 id="第三次撤销（创建-B-操作）"><a href="#第三次撤销（创建-B-操作）" class="headerlink" title="第三次撤销（创建 B 操作）"></a>第三次撤销（创建 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_B</li><li>执行该命令的 undo()方法，将整个画布状态恢复到创建 B 之前的状态（即只包含 A 元素的状态）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)</p><h5 id="第四次撤销（移动-A-操作）"><a href="#第四次撤销（移动-A-操作）" class="headerlink" title="第四次撤销（移动 A 操作）"></a>第四次撤销（移动 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA</li><li>执行该命令的 undo()方法，将 A 元素恢复到初始位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)</p><h5 id="第五次撤销（创建-A-操作）"><a href="#第五次撤销（创建-A-操作）" class="headerlink" title="第五次撤销（创建 A 操作）"></a>第五次撤销（创建 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_A</li><li>执行该命令的 undo()方法，将整个画布状态恢复到初始状态（空画布）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：空<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)</p><h3 id="6-逻辑流程-Logic-Flow"><a href="#6-逻辑流程-Logic-Flow" class="headerlink" title="6. 逻辑流程 (Logic Flow)"></a>6. 逻辑流程 (Logic Flow)</h3><h4 id="6-1-交互时序图-Mermaid"><a href="#6-1-交互时序图-Mermaid" class="headerlink" title="6.1 交互时序图 (Mermaid)"></a>6.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManager<br>    participant URM as UndoRedoManager<br>    participant C as Command<br>    participant ZS as Zustand Store<br>    <br>    U-&gt;&gt;SM: 执行操作（如拖拽元素）<br>    SM-&gt;&gt;SM: 记录操作初始状态<br>    SM-&gt;&gt;ZS: 更新元素状态<br>    SM-&gt;&gt;C: 创建 UpdateElementCommand<br>    SM-&gt;&gt;URM: executeCommand(command)<br>    URM-&gt;&gt;C: command.execute()<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 清空重做栈<br>    <br>    U-&gt;&gt;URM: 执行撤销 (Ctrl+Z)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.undo()<br>    C-&gt;&gt;ZS: 恢复初始状态<br>    C-&gt;&gt;URM: 命令入重做栈<br>    URM-&gt;&gt;URM: 解锁管理器<br>    <br>    U-&gt;&gt;URM: 执行重做 (Ctrl+Y)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.redo()<br>    C-&gt;&gt;ZS: 恢复最终状态<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 解锁管理器<br></code></pre></td></tr></table></figure><h4 id="6-2-核心函数解析"><a href="#6-2-核心函数解析" class="headerlink" title="6.2 核心函数解析"></a>6.2 核心函数解析</h4><p><strong>executeCommand 函数</strong>：当用户完成一个操作（如创建、更新、删除元素）时触发，执行命令并将命令添加到撤销栈，同时清空重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">executeCommand</span>(<span class="hljs-params"><span class="hljs-attr">command</span>: <span class="hljs-title class_">Command</span></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">locked</span>) {<br>    <span class="hljs-comment">// 如果管理器被锁定，忽略命令</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-comment">// 执行命令</span><br>  command.<span class="hljs-title function_">execute</span>()<br><br>  <span class="hljs-comment">// 将命令添加到撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)<br><br>  <span class="hljs-comment">// 清空重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span> = []<br>}<br></code></pre></td></tr></table></figure><p><strong>undo 函数</strong>：当用户执行撤销操作（如按 Ctrl+Z）时触发，从撤销栈弹出命令，执行命令的 undo 方法，并将命令放入重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">undo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 撤销栈为空，无法撤销</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">undo</span>()  <span class="hljs-comment">// 执行撤销</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><p><strong>redo 函数</strong>：当用户执行重做操作（如按 Ctrl+Y）时触发，从重做栈弹出命令，执行命令的 redo 方法，并将命令放入撤销栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">redo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 重做栈为空，无法重做</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">redo</span>()  <span class="hljs-comment">// 执行重做</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><h3 id="7-UI-与样式实现-UI-Implementation"><a href="#7-UI-与样式实现-UI-Implementation" class="headerlink" title="7. UI 与样式实现 (UI Implementation)"></a>7. UI 与样式实现 (UI Implementation)</h3><p>Undo/Redo 机制通过快捷键和控制台界面与用户交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互方式}<br>    B --&gt; C[键盘快捷键]<br>    B --&gt; D[控制台界面]<br>    C --&gt; E[Ctrl+Z 撤销]<br>    C --&gt; F[Ctrl+Y 重做]<br>    D --&gt; G[命令栈控制台]<br>    G --&gt; H[撤销按钮]<br>    G --&gt; I[重做按钮]<br>    G --&gt; J[清空按钮]<br>    <br>    style A fill:#e1f5fe<br>    style C fill:#f3e5f5<br>    style D fill:#f3e5f5<br>    style E fill:#e8f5e8<br>    style F fill:#e8f5e8<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="状态管理" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-逻辑层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/62457.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/62457.html</id>
    <published>2025-11-23T09:45:00.000Z</published>
    <updated>2025-11-23T16:04:12.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>逻辑层是整个画布应用的中枢神经系统，负责协调状态管理层和渲染层之间的交互。它通过 StageManagerCore 类实现，主要处理用户交互、协调状态更新、管理渲染流程、维护交互状态</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── pages/<br>    └── canvas/<br>        ├── Pixi_stageManager.ts               <span class="hljs-comment"># StageManager 入口文件</span><br>        └── Pixi_STM_modules/                  <span class="hljs-comment"># StageManager 模块目录</span><br>            ├── core/<br>            │   ├── StageManagerCore.ts        <span class="hljs-comment"># 核心类</span><br>            │   └── types.ts                   <span class="hljs-comment"># 类型定义文件</span><br>            ├── rendering/<br>            │   ├── ElementRenderer.ts         <span class="hljs-comment"># 元素渲染器</span><br>            │   └── TransformerRenderer.ts     <span class="hljs-comment"># 变换控制器渲染器</span><br>            ├── interaction/<br>            │   └── InteractionHandler.ts      <span class="hljs-comment"># 交互处理器</span><br>            └── utils/<br>                └── cursorUtils.ts             <span class="hljs-comment"># 光标工具函数</span><br></code></pre></td></tr></table></figure><ul><li><code>PixiJS</code>：WebGL 渲染引擎，负责图形渲染</li><li><code>pixi-viewport</code>：视口管理插件，处理画布缩放和平移</li><li><code>Zustand</code>：状态管理库，与状态管理层对接</li><li><code>nanoid</code>：用于生成唯一 ID</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-StageManagerCore-构造函数参数"><a href="#2-1-StageManagerCore-构造函数参数" class="headerlink" title="2.1 StageManagerCore 构造函数参数"></a>2.1 StageManagerCore 构造函数参数</h4><p>StageManagerCore 类通过构造函数接收容器元素参数。</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>container</td><td>HTMLElement</td><td>是</td><td>无</td><td>用于挂载 PixiJS 应用的 DOM 容器</td></tr></tbody></table></div><p>代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 创建 StageManager 实例</span><br><span class="hljs-keyword">const</span> stageManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StageManagerCore</span>(containerElement);<br></code></pre></td></tr></table></figure><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L11-L38">StageManagerState</a> 类型</strong>：<br>定义了 StageManager 的核心状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StageManagerState</span> {<br>  <span class="hljs-attr">mode</span>: <span class="hljs-title class_">InteractionMode</span>; <span class="hljs-comment">// 当前交互模式</span><br>  <span class="hljs-attr">startPos</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> }; <span class="hljs-comment">// 起始坐标</span><br>  <span class="hljs-attr">currentId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前操作元素 ID</span><br>  <span class="hljs-attr">initialElementsMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始元素映射</span><br>  <span class="hljs-attr">initialGroupBounds</span>: {<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  } | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始群组边界</span><br>  <span class="hljs-attr">initialElementState</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始元素状态</span><br>  <span class="hljs-attr">resizeInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 调整大小初始状态</span><br>  <span class="hljs-attr">dragInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 拖拽初始状态</span><br>  <span class="hljs-attr">activeHandle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 激活的手柄</span><br>  <span class="hljs-attr">isSpacePressed</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 空格键是否按下</span><br>  <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 是否已销毁</span><br>}<br></code></pre></td></tr></table></figure><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L3-L8">InteractionMode</a> 类型</strong>：<br>定义了用户与画布交互的各种模式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">InteractionMode</span> =<br>  | <span class="hljs-string">"idle"</span> <span class="hljs-comment">// 空闲状态</span><br>  | <span class="hljs-string">"panning"</span> <span class="hljs-comment">// 画布平移</span><br>  | <span class="hljs-string">"selecting"</span> <span class="hljs-comment">// 选择元素</span><br>  | <span class="hljs-string">"dragging"</span> <span class="hljs-comment">// 拖拽元素</span><br>  | <span class="hljs-string">"resizing"</span> <span class="hljs-comment">// 调整元素大小</span><br>  | <span class="hljs-string">"drawing"</span> <span class="hljs-comment">// 绘制元素</span><br>  | <span class="hljs-string">"texting"</span> <span class="hljs-comment">// 文本编辑</span><br>  | <span class="hljs-string">"erasing"</span>; <span class="hljs-comment">// 擦除元素</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>StageManagerCore 维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>app</td><td>PIXI.Application</td><td>PixiJS 应用实例</td></tr><tr><td>viewport</td><td>Viewport</td><td>pixi-viewport 实例</td></tr><tr><td>elementLayer</td><td>PIXI.Container</td><td>元素图层容器</td></tr><tr><td>uiLayer</td><td>PIXI.Container</td><td>UI 图层容器</td></tr><tr><td>elementRenderer</td><td>ElementRenderer</td><td>元素渲染器实例</td></tr><tr><td>transformerRenderer</td><td>TransformerRenderer</td><td>变换控制器渲染器实例</td></tr><tr><td>interactionHandler</td><td>InteractionHandler</td><td>交互处理器实例</td></tr><tr><td>state</td><td>StageManagerState</td><td>交互状态对象</td></tr><tr><td>selectionRectGraphic</td><td>PIXI.Graphics</td><td>选区框图形对象</td></tr><tr><td>eraserGraphic</td><td>PIXI.Graphics</td><td>橡皮擦指示器图形对象</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>逻辑层通过 Zustand 状态管理库订阅外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据</td></tr><tr><td>selectedIds</td><td>string[]</td><td>当前选中的元素 ID 数组</td></tr><tr><td>tool</td><td>ToolType</td><td>当前工具类型</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store 状态变更] --&gt; B{StageManager 订阅}<br>    B --&gt; C{状态处理}<br>    C --&gt; D[ElementRenderer.renderElements]<br>    C --&gt; E[TransformerRenderer.renderTransformer]<br>    C --&gt; F[更新视口状态]<br>    C --&gt; G[更新光标样式]<br>    D --&gt; H[PixiJS 渲染元素]<br>    E --&gt; I[PixiJS 渲染变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style H fill:#e8f5e8<br>    style I fill:#e8f5e8<br>    style F fill:#fff3e0<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManagerCore<br>    participant IH as InteractionHandler<br>    participant ZS as Zustand Store<br>    participant ER as ElementRenderer<br>    participant TR as TransformerRenderer<br>    <br>    U-&gt;&gt;IH: 触发交互事件 (点击/拖拽等)<br>    IH-&gt;&gt;SM: 调用处理函数 (onPointerDown等)<br>    SM-&gt;&gt;SM: 更新内部状态 (mode, startPos等)<br>    SM-&gt;&gt;ZS: 更新画布数据 (addElement等)<br>    ZS-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;ER: 调用renderElements()<br>    SM-&gt;&gt;TR: 调用renderTransformer()<br>    ER-&gt;&gt;ER: 更新 PIXI 元素<br>    TR-&gt;&gt;TR: 更新变换控制器<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><p><strong>onPointerDown 函数</strong>：当用户在画布上按下鼠标时触发，根据当前工具和点击位置处理不同的交互逻辑（选择、绘制、拖拽等）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理防抖</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerDebounceSnapshot</span>()<br><br>  <span class="hljs-comment">// 获取当前状态</span><br>  <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>()<br>  <span class="hljs-keyword">const</span> tool = state.<span class="hljs-property">tool</span><br>  <span class="hljs-keyword">const</span> worldPos = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>)<br><br>  <span class="hljs-comment">// 根据工具类型处理不同逻辑</span><br>  <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'text'</span>) {<br>    <span class="hljs-comment">// 处理文本工具</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'eraser'</span>) {<br>    <span class="hljs-comment">// 处理橡皮擦工具</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> &amp;&amp; e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>) {<br>    <span class="hljs-comment">// 处理元素点击</span><br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 处理绘制或选择</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p><strong>onPointerMove 函数</strong>：当用户在画布上移动鼠标时触发，根据当前交互模式处理不同的移动逻辑（绘制、拖拽、调整大小等）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerMove = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理防抖</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerDebounceSnapshot</span>()<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> === <span class="hljs-string">'idle'</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>()<br>  <span class="hljs-keyword">const</span> currentPos = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>)<br><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span>) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'selecting'</span>:<br>      <span class="hljs-comment">// 处理选择框绘制</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'erasing'</span>:<br>      <span class="hljs-comment">// 处理橡皮擦操作</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'dragging'</span>:<br>      <span class="hljs-comment">// 处理元素拖拽</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'resizing'</span>:<br>      <span class="hljs-comment">// 处理元素调整大小</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'drawing'</span>:<br>      <span class="hljs-comment">// 处理元素绘制</span><br>      <span class="hljs-keyword">break</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="5-UI-与样式实现-UI-Implementation"><a href="#5-UI-与样式实现-UI-Implementation" class="headerlink" title="5. UI 与样式实现 (UI Implementation)"></a>5. UI 与样式实现 (UI Implementation)</h3><p>逻辑层通过管理不同图层来实现 UI 布局：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Viewport] --&gt; B[elementLayer]<br>    A --&gt; C[uiLayer]<br>    B --&gt; D[图形元素]<br>    C --&gt; E[选区框]<br>    C --&gt; F[橡皮擦指示器]<br>    C --&gt; G[变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#e8f5e8<br>    style D fill:#fce4ec<br>    style E fill:#fff3e0<br>    style F fill:#fff3e0<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure><p>使用 PixiJS 的容器系统管理图层，分为元素层和 UI 层，通过 PIXI.Graphics API 实现图形绘制，通过 CSS 控制光标样式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="PixiJS" scheme="https://zhongye1.github.io/Arknight-notes/tags/PixiJS/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-状态管理层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/61173.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/61173.html</id>
    <published>2025-11-23T09:17:00.000Z</published>
    <updated>2025-11-23T16:04:20.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>状态管理层管理画布元素数据、选中状态、工具状态、剪贴板数据等核心业务数据，是整个画布应用的数据核心，负责维护所有画布元素的状态信息和用户交互相关的全局状态。它采用了 Zustand 作为状态管理库，实现了数据的集中管理和状态变更的响应式更新</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── stores/<br>    └── canvasStore.ts        <span class="hljs-comment"># Zustand 状态管理核心文件</span><br></code></pre></td></tr></table></figure><ul><li><code>Zustand</code>：轻量级状态管理库，用于管理全局状态</li><li><code>nanoid</code>：用于生成唯一 ID</li><li><code>structuredClone</code>：用于深拷贝状态数据</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-useStore-参数"><a href="#2-1-useStore-参数" class="headerlink" title="2.1 useStore 参数"></a>2.1 useStore 参数</h4><p>状态管理模块通过 <a href="/src/stores/canvasStore.ts#L35-L136">useStore</a> Hook 提供状态访问和更新功能。</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>setTool</td><td>Function</td><td>是</td><td>无</td><td>设置当前使用的工具类型</td></tr><tr><td>addElement</td><td>Function</td><td>是</td><td>无</td><td>添加新元素到画布</td></tr><tr><td>updateElement</td><td>Function</td><td>是</td><td>无</td><td>更新指定元素的属性</td></tr><tr><td>removeElements</td><td>Function</td><td>是</td><td>无</td><td>从画布中移除指定元素</td></tr><tr><td>setSelected</td><td>Function</td><td>是</td><td>无</td><td>设置当前选中的元素</td></tr><tr><td>setEditingId</td><td>Function</td><td>是</td><td>无</td><td>设置当前正在编辑的元素</td></tr><tr><td>copyElements</td><td>Function</td><td>是</td><td>无</td><td>复制指定元素到剪贴板</td></tr><tr><td>pasteElements</td><td>Function</td><td>是</td><td>无</td><td>从剪贴板粘贴元素到画布</td></tr></tbody></table></div><p>代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 设置工具类型</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">setTool</span>(<span class="hljs-string">"rect"</span>);<br><br><span class="hljs-comment">// 添加元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>({<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">"element1"</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"rect"</span>,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">150</span>,<br>  <span class="hljs-attr">fill</span>: <span class="hljs-string">"#ff0000"</span>,<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-string">"#000000"</span>,<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">2</span>,<br>});<br><br><span class="hljs-comment">// 更新元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-string">"element1"</span>, { <span class="hljs-attr">fill</span>: <span class="hljs-string">"#00ff00"</span> });<br><br><span class="hljs-comment">// 移除元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-string">"element1"</span>]);<br></code></pre></td></tr></table></figure><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15">CanvasElement</a> 类型</strong>：<br>定义了画布上所有元素的基本属性和可选属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 元素唯一标识符</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span>; <span class="hljs-comment">// 元素类型</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素左上角 x 坐标</span><br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素左上角 y 坐标</span><br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素宽度</span><br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素高度</span><br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 填充颜色</span><br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 描边颜色</span><br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 描边宽度</span><br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 透明度</span><br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][]; <span class="hljs-comment">// 点坐标数组（用于线条类元素）</span><br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 旋转角度（弧度制）</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本内容（HTML 格式）</span><br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 字体大小</span><br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 字体族</span><br>  <span class="hljs-attr">textAlign</span>?: <span class="hljs-string">"left"</span> | <span class="hljs-string">"center"</span> | <span class="hljs-string">"right"</span>; <span class="hljs-comment">// 文本对齐方式</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图片 URL</span><br>  <span class="hljs-attr">filter</span>?: <span class="hljs-string">"none"</span> | <span class="hljs-string">"blur"</span> | <span class="hljs-string">"brightness"</span> | <span class="hljs-string">"grayscale"</span>; <span class="hljs-comment">// 图片滤镜</span><br>  <span class="hljs-attr">radius</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 圆角半径</span><br>}<br></code></pre></td></tr></table></figure><p><strong><a href="/src/stores/canvasStore.ts#L6-L21">ToolType</a> 类型</strong>：<br>定义了用户可选择的工具类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToolType</span> =<br>  | <span class="hljs-string">"select"</span> <span class="hljs-comment">// 选择工具</span><br>  | <span class="hljs-string">"hand"</span> <span class="hljs-comment">// 手型工具</span><br>  | <span class="hljs-string">"rect"</span> <span class="hljs-comment">// 矩形工具</span><br>  | <span class="hljs-string">"circle"</span> <span class="hljs-comment">// 圆形工具</span><br>  | <span class="hljs-string">"triangle"</span> <span class="hljs-comment">// 三角形工具</span><br>  | <span class="hljs-string">"diamond"</span> <span class="hljs-comment">// 菱形工具</span><br>  | <span class="hljs-string">"line"</span> <span class="hljs-comment">// 直线工具</span><br>  | <span class="hljs-string">"arrow"</span> <span class="hljs-comment">// 箭头工具</span><br>  | <span class="hljs-string">"pencil"</span> <span class="hljs-comment">// 铅笔工具</span><br>  | <span class="hljs-string">"text"</span> <span class="hljs-comment">// 文本工具</span><br>  | <span class="hljs-string">"image"</span> <span class="hljs-comment">// 图片工具</span><br>  | <span class="hljs-string">"eraser"</span>; <span class="hljs-comment">// 橡皮擦工具</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><p>状态管理层维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>tool</td><td><a href="/src/stores/canvasStore.ts#L6-L21">ToolType</a></td><td>当前选中的工具类型</td></tr><tr><td>elements</td><td>Record&lt;string, [CanvasElement](/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15)&gt;</td><td>所有画布元素的集合</td></tr><tr><td>selectedIds</td><td>string[]</td><td>当前选中的元素 ID 数组</td></tr><tr><td>editingId</td><td>string \</td><td>null</td><td>当前正在编辑的元素 ID</td></tr><tr><td>clipboard</td><td><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15">CanvasElement</a>[] \</td><td>null</td><td>剪贴板数据</td></tr><tr><td>pasteOffset</td><td>number</td><td>粘贴偏移计数</td></tr><tr><td>currentStyle</td><td>Object</td><td>当前样式设置</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store 状态变更] --&gt; B{订阅者监听}<br>    B --&gt; C[StageManager 订阅]<br>    B --&gt; D[UI 组件订阅]<br>    C --&gt; E[触发渲染层更新]<br>    D --&gt; F[触发 UI 更新]<br>    <br>    style A fill:#e1f5fe<br>    style E fill:#e8f5e8<br>    style F fill:#fff3e0<br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant C as CanvasStore<br>    participant SM as StageManager<br>    participant R as 渲染层<br>    <br>    U-&gt;&gt;C: 调用 Action (如 addElement)<br>    C-&gt;&gt;C: 更新内部状态<br>    C-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;R: 触发重新渲染<br>    R-&gt;&gt;R: 更新 PIXI 对象<br>    R-&gt;&gt;U: 显示更新结果<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数"><a href="#4-2-核心函数" class="headerlink" title="4.2 核心函数"></a>4.2 核心函数</h4><p><strong>addElement 函数</strong>：当用户创建新元素时调用，创建新元素并添加到 elements 集合中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({<br>    <span class="hljs-attr">elements</span>: { ...state.<span class="hljs-property">elements</span>, [el.<span class="hljs-property">id</span>]: el },<br>  }));<br></code></pre></td></tr></table></figure><p><strong>updateElement 函数</strong>：当用户修改元素属性时调用，更新指定元素的属性并保持其他元素不变</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params">id, attrs</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">elements</span>[id]) <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">return</span> {<br>      <span class="hljs-attr">elements</span>: {<br>        ...state.<span class="hljs-property">elements</span>,<br>        [id]: { ...state.<span class="hljs-property">elements</span>[id], ...attrs },<br>      },<br>    };<br>  });<br></code></pre></td></tr></table></figure><p>状态管理层作为纯数据层，不直接涉及 UI 和样式实现，但为上层 UI 提供了必要的状态支持，通过状态结构支持上层组件的布局逻辑和状态中的样式属性支持上层组件的样式实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Zustand" scheme="https://zhongye1.github.io/Arknight-notes/tags/Zustand/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-渲染层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/8350.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/8350.html</id>
    <published>2025-11-23T06:56:37.000Z</published>
    <updated>2025-11-23T16:06:10.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>渲染层是基于 PixiJS 构建的可视化层，负责将存储在 Zustand 状态管理器中的画布元素数据转化为可视化的图形界面，并处理用户的交互操作。它主要包括元素渲染（ElementRenderer）和变换控制器渲染（TransformerRenderer）两大部分，分别负责绘制元素本身和元素的选中状态、控制手柄等辅助 UI。</p><p>其项目结构树如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nix">src<span class="hljs-symbol">/</span><br>└── pages<span class="hljs-symbol">/</span><br>    └── canvas<span class="hljs-symbol">/</span><br>        ├── Pixi_stageManager.ts               <span class="hljs-comment"># 整合StageManager各模块的入口文件</span><br>        ├── index.tsx                          <span class="hljs-comment"># 画布页面组件，整合渲染层到React组件中</span><br>        └── Pixi_STM_modules<span class="hljs-symbol">/</span>                  <span class="hljs-comment"># StageManager模块目录</span><br>            ├── STM_modules.md                 <span class="hljs-comment"># 模块设计文档</span><br>            ├── core<span class="hljs-symbol">/</span><br>            │   ├── StageManagerCore.ts        <span class="hljs-comment"># 核心类，整合渲染、交互和状态管理</span><br>            │   └── types.ts                   <span class="hljs-comment"># 类型定义文件</span><br>            ├── rendering<span class="hljs-symbol">/</span><br>            │   ├── ElementRenderer.ts         <span class="hljs-comment"># 元素渲染器，负责渲染各类画布元素</span><br>            │   └── TransformerRenderer.ts     <span class="hljs-comment"># 变换控制器渲染器，负责渲染选中元素的手柄等</span><br>            ├── interaction<span class="hljs-symbol">/</span><br>            │   └── InteractionHandler.ts      <span class="hljs-comment"># 交互处理器，绑定和处理各种交互事件</span><br>            └── utils<span class="hljs-symbol">/</span><br>                └── cursorUtils.ts             <span class="hljs-comment"># 光标工具函数</span><br></code></pre></td></tr></table></figure><p>该模块主要负责将状态管理层的数据渲染成可视化图形，并处理用户交互反馈</p><ul><li><code>pixi.js</code>：WebGL 渲染引擎</li><li><code>pixi-viewport</code>：视口管理插件</li><li><code>zustand</code>：状态管理库（虽然不是渲染层直接依赖，但与其紧密协作）</li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><p>渲染层接收来自逻辑层的 props 参数，用于驱动元素渲染和交互控制。这些参数主要包括元素数据、状态信息和事件回调函数。</p><h4 id="2-1-ElementRenderer-renderElements-方法参数"><a href="#2-1-ElementRenderer-renderElements-方法参数" class="headerlink" title="2.1 ElementRenderer.renderElements 方法参数"></a>2.1 ElementRenderer.renderElements 方法参数</h4><p>ElementRenderer 负责将画布元素数据渲染为 PIXI 可视化对象，其 <a href="src/pages/canvas/Pixi_STM_modules/rendering/ElementRenderer.ts#L57-L157">renderElements</a> 方法接收以下参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">类型</th><th style="text-align:left">必填</th><th style="text-align:left">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">elements</td><td style="text-align:left">Record<string, CanvasElement=""></string,></td><td style="text-align:left">是</td><td style="text-align:left">无</td><td style="text-align:left">包含所有画布元素的数据对象</td></tr><tr><td style="text-align:left">elementLayer</td><td style="text-align:left">PIXI.Container</td><td style="text-align:left">是</td><td style="text-align:left">无</td><td style="text-align:left">用于承载所有可视元素的容器</td></tr><tr><td style="text-align:left">destroyed</td><td style="text-align:left">boolean</td><td style="text-align:left">是</td><td style="text-align:left">false</td><td style="text-align:left">标识组件是否已被销毁</td></tr></tbody></table></div><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// elements对象结构示例</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-string">"element1"</span>: <span class="hljs-punctuation">{</span><br><span class="hljs-symbol">    id:</span> <span class="hljs-string">"element1"</span>,<br><span class="hljs-symbol">    type:</span> <span class="hljs-string">"rect"</span>,<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">200</span>,<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">150</span>,<br><span class="hljs-symbol">    fill:</span> <span class="hljs-string">"#ff0000"</span><br>  <span class="hljs-punctuation">}</span>,<br>  <span class="hljs-string">"element2"</span>: <span class="hljs-punctuation">{</span><br><span class="hljs-symbol">    id:</span> <span class="hljs-string">"element2"</span>,<br><span class="hljs-symbol">    type:</span> <span class="hljs-string">"text"</span>,<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">50</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">50</span>,<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">300</span>,<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    text:</span> <span class="hljs-string">"&lt;p&gt;示例文本&lt;/p&gt;"</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p><a href="src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a>: PIXI.Container - PIXI.js 中的容器对象，用于承载所有画布元素的可视化对象。ElementRenderer 会将创建的 PIXI 对象添加到这个容器中，以便在画布上显示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在StageManagerCore.ts中创建elementLayer</span><br><span class="hljs-keyword">private</span> elementLayer: PIXI.Container = new PIXI.Container()<br><span class="hljs-comment">// 然后传给ElementRenderer</span><br><span class="hljs-keyword">this</span>.elementRenderer.renderElements(elements, <span class="hljs-keyword">this</span>.elementLayer, <span class="hljs-keyword">this</span>.state.destroyed)<br></code></pre></td></tr></table></figure><p>destroyed: boolean - 标识渲染器是否已被销毁。当组件被销毁时，此参数防止在销毁后继续执行渲染操作，避免内存泄漏。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderElements</span>(<span class="hljs-params"><span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;, <span class="hljs-attr">elementLayer</span>: PIXI.<span class="hljs-title class_">Container</span>, <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span></span>) {<br>  <span class="hljs-keyword">if</span> (destroyed) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已销毁，直接返回不执行渲染</span><br>  <span class="hljs-comment">// ... 其他渲染逻辑</span><br>}<br></code></pre></td></tr></table></figure><h4 id="2-2-TransformerRenderer-renderTransformer-方法参数"><a href="#2-2-TransformerRenderer-renderTransformer-方法参数" class="headerlink" title="2.2 TransformerRenderer.renderTransformer 方法参数"></a>2.2 TransformerRenderer.renderTransformer 方法参数</h4><p>TransformerRenderer 负责渲染选中元素的变换控制器（手柄、边框等），其 <a href="src/pages/canvas/Pixi_STM_modules/rendering/TransformerRenderer.ts#L31-L182">renderTransformer</a> 方法接收以下参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">elements</td><td style="text-align:left">Record<string, CanvasElement=""></string,></td><td style="text-align:left">所有画布元素的数据</td></tr><tr><td style="text-align:left">selectedIds</td><td style="text-align:left">string[]</td><td style="text-align:left">当前选中元素的 ID 数组</td></tr><tr><td style="text-align:left">spriteMap</td><td style="text-align:left">Map<string, PIXI.DisplayObject=""></string,></td><td style="text-align:left">元素 ID 到 PIXI 可视化对象的映射</td></tr><tr><td style="text-align:left">onHandleDown</td><td style="text-align:left">Function</td><td style="text-align:left">手柄按下事件的回调函数</td></tr><tr><td style="text-align:left">viewportScale</td><td style="text-align:left">number</td><td style="text-align:left">当前视口的缩放比例</td></tr></tbody></table></div><p>elements: Record<string, CanvasElement=""> - 与 ElementRenderer 中的 elements 相同，提供所有画布元素的数据。TransformerRenderer 需要访问元素数据来计算选中元素的边界框和位置信息。</string,></p><p>selectedIds: string[] - 包含当前选中元素 ID 的数组。TransformerRenderer 根据这个数组决定是否以及如何绘制变换控制器（选中框和手柄）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// selectedIds数组示例</span><br>;<span class="hljs-selector-attr">[<span class="hljs-string">'element1'</span>, <span class="hljs-string">'element3'</span>]</span> <span class="hljs-comment">// 表示element1和element3被选中</span><br></code></pre></td></tr></table></figure><p>spriteMap: Map&lt;string, PIXI.Graphics | PIXI.HTMLText | PIXI.Sprite&gt; - 提供元素 ID 到 PIXI 可视化对象的映射。TransformerRenderer 需要访问实际的 PIXI 对象来准确计算元素的边界（特别是文本元素）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// spriteMap结构示例</span><br><span class="hljs-built_in">Map</span>(<span class="hljs-number">2</span>) {<br>  <span class="hljs-string">"element1"</span> =&gt; Graphics {},     <span class="hljs-comment">// 矩形元素的PIXI.Graphics对象</span><br>  <span class="hljs-string">"element2"</span> =&gt; HTMLText {}      <span class="hljs-comment">// 文本元素的PIXI.HTMLText对象</span><br>}<br></code></pre></td></tr></table></figure><p>onHandleDown: Function - 手柄按下事件的回调函数。当用户点击变换控制器上的手柄时，会调用这个函数开始变换操作（如缩放、旋转）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在StageManagerCore.ts中定义并传递给TransformerRenderer</span><br><span class="hljs-keyword">private</span> onHandleDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span>, <span class="hljs-attr">handle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>, <span class="hljs-attr">elementId</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理手柄按下事件</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">'resizing'</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">activeHandle</span> = handle <span class="hljs-keyword">as</span> <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// ... 其他逻辑</span><br>}<br></code></pre></td></tr></table></figure><p>viewportScale: number - 当前视口的缩放比例。TransformerRenderer 使用这个值来调整手柄和控制器的大小，确保在不同缩放级别下都有合适的尺寸。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在StageManagerCore.ts中获取并传递视口缩放比例</span><br><span class="hljs-keyword">this</span>.transformerRenderer.renderTransformer(<br>  elements,<br>  selectedIds,<br>  <span class="hljs-keyword">this</span>.elementRenderer.getSpriteMap(),<br>  <span class="hljs-keyword">this</span>.onHandleDown,<br>  <span class="hljs-keyword">this</span>.viewport.scale.x, <span class="hljs-comment">// 传递视口缩放比例</span><br>)<br></code></pre></td></tr></table></figure><h3 id="2-3-核心类型定义"><a href="#2-3-核心类型定义" class="headerlink" title="2.3 核心类型定义"></a>2.3 核心类型定义</h3><p>渲染层涉及到的关键类型定义如下：</p><h4 id="CanvasElement-类型"><a href="#CanvasElement-类型" class="headerlink" title="CanvasElement 类型"></a>CanvasElement 类型</h4><p>定义了画布元素的基本属性和可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>:<br>    | <span class="hljs-string">"rect"</span><br>    | <span class="hljs-string">"circle"</span><br>    | <span class="hljs-string">"triangle"</span><br>    | <span class="hljs-string">"text"</span><br>    | <span class="hljs-string">"image"</span><br>    | <span class="hljs-string">"line"</span><br>    | <span class="hljs-string">"arrow"</span><br>    | <span class="hljs-string">"pencil"</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 根据元素类型可能包含额外属性</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图片元素</span><br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][]; <span class="hljs-comment">// 线条/铅笔元素</span><br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 透明度</span><br>  <span class="hljs-attr">radius</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 圆角矩形</span><br>}<br></code></pre></td></tr></table></figure><h4 id="HandleType-类型"><a href="#HandleType-类型" class="headerlink" title="HandleType 类型"></a>HandleType 类型</h4><p>定义了变换控制器上各种手柄的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">HandleType</span> =<br>  | <span class="hljs-string">"tl"</span> <span class="hljs-comment">// top-left 左上角</span><br>  | <span class="hljs-string">"t"</span> <span class="hljs-comment">// top 顶部中间</span><br>  | <span class="hljs-string">"tr"</span> <span class="hljs-comment">// top-right 右上角</span><br>  | <span class="hljs-string">"r"</span> <span class="hljs-comment">// right 右侧中间</span><br>  | <span class="hljs-string">"br"</span> <span class="hljs-comment">// bottom-right 右下角</span><br>  | <span class="hljs-string">"b"</span> <span class="hljs-comment">// bottom 底部中间</span><br>  | <span class="hljs-string">"bl"</span> <span class="hljs-comment">// bottom-left 左下角</span><br>  | <span class="hljs-string">"l"</span> <span class="hljs-comment">// left 左侧中间</span><br>  | <span class="hljs-string">"p0"</span> <span class="hljs-comment">// 线段起点</span><br>  | <span class="hljs-string">"p1"</span> <span class="hljs-comment">// 线段终点</span><br>  | <span class="hljs-string">"rotate"</span>; <span class="hljs-comment">// 旋转手柄</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><p>渲染层采用内外结合的状态管理模式，既维护自身的局部状态，又与外部的 Zustand 状态管理库协同工作。</p><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>渲染层维护一组局部状态，用于管理 PIXI 对象和渲染优化：</p><div class="table-container"><table><thead><tr><th style="text-align:left">状态名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>spriteMap</code></td><td style="text-align:left">`Map&lt;string, PIXI.Graphics \</td><td style="text-align:left">PIXI.HTMLText \</td><td>PIXI.Sprite&gt;`</td><td>存储元素 ID 到 PIXI 图形对象的映射关系，用于快速查找和更新元素</td></tr><tr><td style="text-align:left"><code>textureCache</code></td><td style="text-align:left"><code>Map&lt;string, PIXI.Texture&gt;</code></td><td style="text-align:left">图片纹理缓存，避免重复加载相同图片</td></tr><tr><td style="text-align:left"><code>loadingSet</code></td><td style="text-align:left"><code>Set&lt;string&gt;</code></td><td style="text-align:left">正在加载中的图片 URL 集合，防止重复加载</td></tr><tr><td style="text-align:left"><code>imageUpdateTimers</code></td><td style="text-align:left"><code>Map&lt;string, NodeJS.Timeout&gt;</code></td><td style="text-align:left">图像元素更新检查定时器映射</td></tr><tr><td style="text-align:left"><code>transformerGraphic</code></td><td style="text-align:left"><code>PIXI.Graphics</code></td><td style="text-align:left">用于绘制变换控制器（选中框、手柄等）的图形对象</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// ElementRenderer 内部状态示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">textureCache</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Texture</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">loadingSet</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">imageUpdateTimers</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><br><span class="hljs-comment">// TransformerRenderer 内部状态示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">transformerGraphic</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Graphics</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Graphics</span>()<br><br></code></pre></td></tr></table></figure><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>渲染层通过订阅 Zustand 状态管理库中的 <a href="src/stores/canvasStore.ts#L35-L136">canvasStore</a> 来获取画布元素数据和选中状态：</p><div class="table-container"><table><thead><tr><th style="text-align:left">状态名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>elements</code></td><td style="text-align:left"><code>Record&lt;string, CanvasElement&gt;</code></td><td style="text-align:left">所有画布元素的数据对象</td></tr><tr><td style="text-align:left"><code>selectedIds</code></td><td style="text-align:left"><code>string[]</code></td><td style="text-align:left">当前选中元素的 ID 数组</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// StageManagerCore.ts 中订阅外部状态的方式</span><br>useStore.<span class="hljs-title function_">subscribe</span>(<br>  <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">elements</span>: state.<span class="hljs-property">elements</span>, <span class="hljs-attr">selectedIds</span>: state.<span class="hljs-property">selectedIds</span> }),<br>  <span class="hljs-function">(<span class="hljs-params">{ elements, selectedIds }</span>) =&gt;</span> {<br>    <span class="hljs-comment">// 当 elements 或 selectedIds 发生变化时触发重新渲染</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();<br>  },<br>  { <span class="hljs-attr">equalityFn</span>: shallow }<br>);<br></code></pre></td></tr></table></figure><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><p>渲染层通过增量更新（Diffing）算法实现高效的状态同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A[Zustand Store 状态变更] --&gt; B{StageManager 订阅}<br>B --&gt; C{Diff 算法对比}<br>C --&gt;|新增元素| D[创建 PIXI 对象]<br>C --&gt;|更新元素| E[更新 PIXI 对象属性]<br>C --&gt;|删除元素| F[销毁 PIXI 对象]<br>D --&gt; G[添加到 spriteMap]<br>E --&gt; G<br>F --&gt; H[从 spriteMap 移除]<br>G --&gt; I[PixiJS 渲染]<br>H --&gt; I<br>    style A fill:#e1f5fe<br>    style I fill:#e8f5e8<br>    style G fill:#fff3e0<br>    style H fill:#ffebee<br><br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>participant U as 用户<br>participant SM as StageManagerCore<br>participant ER as ElementRenderer<br>participant TR as TransformerRenderer<br>participant S as Zustand Store<br><br>    U-&gt;&gt;SM: 触发状态变更 (添加/更新元素)<br>    SM-&gt;&gt;S: 更新elements数据<br>    S-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;ER: 调用renderElements()<br>    ER-&gt;&gt;ER: 根据元素类型创建/更新PIXI对象<br>    ER-&gt;&gt;SM: 更新spriteMap<br>    <br>    U-&gt;&gt;SM: 选择元素<br>    SM-&gt;&gt;S: 更新selectedIds<br>    S-&gt;&gt;SM: 通知选中状态变更<br>    SM-&gt;&gt;TR: 调用renderTransformer()<br>    TR-&gt;&gt;TR: 根据选中元素绘制变换控制器<br></code></pre></td></tr></table></figure><hr><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><ul><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/rendering/ElementRenderer.ts#L57-L157">ElementRenderer.renderElements()</a></strong>:</p><ul><li><p><strong>触发时机</strong>: 当画布元素数据发生变更时，通过状态订阅机制触发。每当 Zustand store 中的 <a href="/src/stores/canvasStore.ts#L44-L44">elements</a> 对象发生变化时，StageManagerCore 会调用此方法进行重新渲染。</p></li><li><p><strong>逻辑闭环</strong>: 遍历所有元素数据，根据元素类型创建或更新对应的 PIXI 对象，并将其添加到容器中。通过 diff 算法比较现有 spriteMap 和新元素数据（遍历 spriteMap 中的所有元素 ID，检查哪些元素在新的 elements 数据中不存在，这些元素需要被删除，遍历新的 elements 数据中的所有元素 ID，检查哪些是新增的元素需要创建，哪些是已存在的元素需要更新），确定需要创建、更新或删除的元素，最终保持 PIXI 对象与数据状态同步。</p></li><li><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 核心渲染逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderElements</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">elementLayer</span>: PIXI.<span class="hljs-title class_">Container</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (destroyed) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 获取当前所有元素ID</span><br>  <span class="hljs-keyword">const</span> elementIds = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(elements);<br><br>  <span class="hljs-comment">// 删除已移除的元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">keys</span>()) {<br>    <span class="hljs-keyword">if</span> (!elementIds.<span class="hljs-title function_">includes</span>(id)) {<br>      <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id)!;<br>      sprite.<span class="hljs-title function_">destroy</span>({ <span class="hljs-attr">children</span>: <span class="hljs-literal">true</span> });<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">delete</span>(id);<br>    }<br>  }<br><br>  <span class="hljs-comment">// 更新或创建元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> elementIds) {<br>    <span class="hljs-keyword">const</span> data = elements[id];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">has</span>(id)) {<br>      <span class="hljs-comment">// 更新现有元素</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateElement</span>(data, <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id)!);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// 创建新元素</span><br>      <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createElement</span>(data);<br>      elementLayer.<span class="hljs-title function_">addChild</span>(sprite);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">set</span>(id, sprite);<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>差异化渲染处理</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 根据不同类型元素进行差异化渲染处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">CanvasElement</span>): <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span> {<br>  <span class="hljs-keyword">switch</span> (data.<span class="hljs-property">type</span>) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'rect'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'circle'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'triangle'</span>:<br>      <span class="hljs-comment">// 几何图形处理逻辑：使用Graphics API绘制形状</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createGraphicsElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>:<br>      <span class="hljs-comment">// 文本元素处理逻辑：使用HTMLText组件渲染富文本</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createTextElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'image'</span>:<br>      <span class="hljs-comment">// 图片元素处理逻辑：加载纹理并创建Sprite</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createImageElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'line'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'arrow'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'pencil'</span>:<br>      <span class="hljs-comment">// 线条/铅笔元素处理逻辑：使用Graphics API绘制线条</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createLineElement</span>(data);<br><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Unsupported element type: <span class="hljs-subst">${data.<span class="hljs-keyword">type</span>}</span>`</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/rendering/TransformerRenderer.ts#L31-L182">TransformerRenderer.renderTransformer()</a></strong>:</p><ul><li><p><strong>触发时机</strong>: 当选中元素发生变更时触发。每当 Zustand store 中的 <a href="/src/stores/canvasStore.ts#L45-L45">selectedIds</a> 数组发生变化时，StageManagerCore 会调用此方法更新变换控制器的显示。</p></li><li><p><strong>逻辑闭环</strong>: 根据选中元素的数量和类型，绘制相应的变换控制器（如缩放手柄、旋转手柄等）。通过清除之前的控制器图形并根据当前选中状态重新绘制，保持变换控制器与选中状态同步。</p></li><li><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 变换控制器渲染逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderTransformer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, PIXI.<span class="hljs-title class_">DisplayObject</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">onHandleDown</span>: (</span><br><span class="hljs-params">    e: PIXI.FederatedPointerEvent,</span><br><span class="hljs-params">    handle: HandleType | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>,</span><br><span class="hljs-params">    elementId: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  ) =&gt; <span class="hljs-built_in">void</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">viewportScale</span>: <span class="hljs-built_in">number</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 清除之前的变换控制器</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">clear</span>();<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-comment">// 单个元素选中逻辑</span><br>    <span class="hljs-keyword">const</span> element = elements[selectedIds[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">const</span> sprite = spriteMap.<span class="hljs-title function_">get</span>(selectedIds[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (sprite) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawSingleElementTransformer</span>(element, sprite, onHandleDown, viewportScale);<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 多个元素选中逻辑</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawMultiElementTransformer</span>(elements, selectedIds, spriteMap, onHandleDown, viewportScale);<br>  }<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="UI-与样式实现-UI-Implementation"><a href="#UI-与样式实现-UI-Implementation" class="headerlink" title="UI 与样式实现 (UI Implementation)"></a>UI 与样式实现 (UI Implementation)</h4><ul><li><p><strong>布局策略</strong>: 使用 PIXI 的容器系统进行布局管理，分为 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a>（元素层）和 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L37-L37">uiLayer</a>（UI 层）两个层级，通过坐标系统定位元素</p><ul><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a></strong>: 用于承载所有画布元素的容器层，包括矩形、圆形、文本、图像等各种元素的 PIXI 对象都添加到这一层。这是渲染层的主要内容，负责显示用户创建的所有图形元素。</p></li><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L37-L37">uiLayer</a></strong>: 用于承载所有 UI 元素的容器层，包括选区框、橡皮擦指示器、变换控制器等辅助 UI 元素。这一层位于元素层之上，确保 UI 元素始终显示在图形元素的前面。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore.ts 中创建两个容器层</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">elementLayer</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Container</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Container</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">uiLayer</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Container</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Container</span>()<br><br><span class="hljs-comment">// 将两个容器层添加到视口中</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">addChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementLayer</span>)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">addChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiLayer</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>样式方案</strong>:</p><ul><li>几何图形使用 PIXI 的绘图 API 进行绘制，支持描边、填充、透明度等样式</li><li>文本元素使用 HTMLText 组件支持富文本渲染</li><li>图片元素使用 PIXI.Sprite 并支持滤镜效果（模糊、亮度、灰度等）</li><li>变换控制器统一使用紫色 (#8b5cf6) 作为主题色</li></ul></li><li><p><strong>条件渲染</strong>:</p><ul><li>根据元素类型选择不同的渲染方式</li><li>根据选中状态决定是否显示变换控制器</li><li>根据选中元素数量显示不同的控制器形态（单选手柄 vs 群组控制器）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A[Viewport] --&gt; B[elementLayer]<br>A --&gt; C[uiLayer]<br>B --&gt; D[图形元素 1]<br>B --&gt; E[图形元素 2]<br>B --&gt; F[文本元素]<br>B --&gt; G[图像元素]<br>C --&gt; H[选区框]<br>C --&gt; I[橡皮擦指示器]<br>C --&gt; J[变换控制器]<br><br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#e8f5e8<br>    style D fill:#fce4ec<br>    style E fill:#fce4ec<br>    style F fill:#fce4ec<br>    style G fill:#fce4ec<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style J fill:#fff3e0<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>前端项目安装和配置指南 Vite + React + TypeScript + Tailwind CSS</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39845.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39845.html</id>
    <published>2025-11-23T04:38:32.000Z</published>
    <updated>2025-11-23T06:46:44.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南"><a href="#Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南" class="headerlink" title="Vite + React + TypeScript + Tailwind CSS 脚手架搭建指南"></a>Vite + React + TypeScript + Tailwind CSS 脚手架搭建指南</h2><p>本文记录从零搭建 <code>Vite + React + Tailwind CSS</code> 项目，省去一个个官网去查阅文档，旨在方便快速丝滑的创建项目</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><strong>Vite 4.2.0</strong> - 新一代构建工具，提供极快的冷启动和热更新。基于原生 ES 模块实现，开发时按需编译，相比传统打包工具具有显著的速度优势。</li><li><strong>React 18.2.0</strong> - 流行的前端 UI 库，采用组件化架构和虚拟 DOM 技术，提供高效的渲染性能和良好的开发体验。</li><li><strong>TypeScript 5.3.3</strong> - JavaScript 的超集，提供静态类型检查，在编译阶段发现潜在错误，增强代码可维护性和开发效率。</li><li><strong>Tailwind CSS 3.3.1</strong> - 实用优先的 CSS 框架，通过组合预定义的原子类来构建界面，无需编写自定义 CSS 即可实现复杂设计。</li><li><strong>ESLint &amp; Prettier</strong> - 代码规范和格式化工具。ESLint 用于检测代码质量问题和潜在错误，Prettier 专注于代码格式统一，共同保障代码质量。</li><li><strong>Husky &amp; lint-staged</strong> - Git 钩子工具，用于提交前代码检查。Husky 简化 Git 钩子配置，lint-staged 仅对暂存文件执行操作，提升提交前检查效率。</li><li><strong>React Router DOM 6</strong> - React 应用的路由管理工具，提供声明式路由配置，支持动态路由、嵌套路由等特性，是构建单页应用的核心组件。</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">BDdraw_DEV/<br>├── .husky/                     <span class="hljs-comment"># Git hooks 配置</span><br>├── .vscode/                    <span class="hljs-comment"># VSCode 配置</span><br>├── docs/                       <span class="hljs-comment"># 文档目录</span><br>├── public/                     <span class="hljs-comment"># 静态资源目录</span><br>├── src/                        <span class="hljs-comment"># 源代码主目录</span><br>│   ├── api/                    <span class="hljs-comment"># API 接口定义</span><br>│   ├── assets/                 <span class="hljs-comment"># 静态资源文件</span><br>│   ├── components/             <span class="hljs-comment"># 公共组件</span><br>│   ├── hooks/                  <span class="hljs-comment"># 自定义 React Hooks</span><br>│   ├── lib/                    <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   ├── pages/                  <span class="hljs-comment"># 页面组件</span><br>│   ├── router/                 <span class="hljs-comment"># 路由配置</span><br>│   │   └── router.tsx          <span class="hljs-comment"># 路由定义</span><br>│   ├── stores/                 <span class="hljs-comment"># 状态管理</span><br>│   ├── styles/                 <span class="hljs-comment"># 样式文件</span><br>│   ├── app.tsx                 <span class="hljs-comment"># 应用入口组件</span><br>│   ├── main.tsx                <span class="hljs-comment"># 主入口文件</span><br>│   └── vite-env.d.ts           <span class="hljs-comment"># Vite 环境声明文件</span><br>├── .editorconfig               <span class="hljs-comment"># 编辑器配置</span><br>├── .eslintrc                  <span class="hljs-comment"># ESLint 配置</span><br>├── .gitignore                 <span class="hljs-comment"># Git 忽略文件配置</span><br>├── .prettierrc.js             <span class="hljs-comment"># Prettier 配置</span><br>├── .stylelintrc.json          <span class="hljs-comment"># Stylelint 配置</span><br>├── commitlint.config.cjs      <span class="hljs-comment"># Commitlint 配置</span><br>├── components.json            <span class="hljs-comment"># 组件配置</span><br>├── index.html                 <span class="hljs-comment"># HTML 入口</span><br>├── lint-staged.config.js      <span class="hljs-comment"># Lint-staged 配置</span><br>├── package.json               <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js          <span class="hljs-comment"># PostCSS 配置</span><br>├── tailwind.config.js         <span class="hljs-comment"># Tailwind CSS 配置</span><br>├── transmart.config.ts        <span class="hljs-comment"># Transmart 配置</span><br>├── tsconfig.json              <span class="hljs-comment"># TypeScript 配置</span><br>├── tsconfig.node.json         <span class="hljs-comment"># Node.js TypeScript 配置</span><br>├── vite.config.ts             <span class="hljs-comment"># Vite 配置</span><br>└── README.md                  <span class="hljs-comment"># 项目说明文档</span><br><br></code></pre></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>使用 Vite 创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm create vite@latest [项目名] -- --template react-ts<br><span class="hljs-built_in">cd</span> [项目名]<br></code></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure><h3 id="集成-Tailwind-CSS-v3"><a href="#集成-Tailwind-CSS-v3" class="headerlink" title="集成 Tailwind CSS v3"></a>集成 Tailwind CSS v3</h3><p>Tailwind CSS 是一个功能类优先的 CSS 框架，它提供了大量的实用类，可以直接在 HTML 中组合使用来构建任何设计。通过配置文件可以自定义主题、颜色、间距等设计系统，并且只生成实际使用的样式，使得最终的 CSS 文件非常精简。其 JIT（Just-In-Time）模式可以按需生成样式，大大提高了编译速度并支持更多功能。</p><p>安装 Tailwind CSS v3 及其依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D tailwindcss postcss autoprefixer<br>npx tailwindcss init -p<br></code></pre></td></tr></table></figure><p>如果出问题可以去翻一下官方文档，v4 改变了一些部署方式</p><p>配置 Tailwind CSS</p><p>编辑 <code>tailwind.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import('tailwindcss').Config</span>} */</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">content</span>: [<span class="hljs-string">"./index.html"</span>, <span class="hljs-string">"./src/**/*.{js,ts,jsx,tsx}"</span>],<br>  <span class="hljs-attr">theme</span>: {<br>    <span class="hljs-attr">extend</span>: {},<br>  },<br>  <span class="hljs-attr">plugins</span>: [],<br>};<br></code></pre></td></tr></table></figure><h3 id="引入-Tailwind-CSS-v3"><a href="#引入-Tailwind-CSS-v3" class="headerlink" title="引入 Tailwind CSS v3"></a>引入 Tailwind CSS v3</h3><p>在 <code>src/index.css</code> 文件中添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@tailwind</span> base;<br><span class="hljs-keyword">@tailwind</span> components;<br><span class="hljs-keyword">@tailwind</span> utilities;<br></code></pre></td></tr></table></figure><p>并在入口文件中导入该 CSS 文件：</p><p>Tailwind CSS 的三个核心层：</p><ul><li><code>@tailwind base</code> - 包含 Normalize.css 和一些基础样式重置</li><li><code>@tailwind components</code> - 包含框架的组件类，可用于添加结构样式</li><li><code>@tailwind utilities</code> - 包含所有实用类，这是 Tailwind 的核心部分</li></ul><p>通过这种分层方式，Tailwind 提供了一种灵活的方式来组织和扩展样式。</p><h3 id="配置-TypeScript"><a href="#配置-TypeScript" class="headerlink" title="配置 TypeScript"></a>配置 TypeScript</h3><p>TypeScript 是 JavaScript 的超集，添加了可选的静态类型。它可以帮助开发者在编码阶段捕获错误，提供更好的代码补全和重构支持。通过配置 <code>tsconfig.json</code>，我们可以控制 TypeScript 编译器的行为，如目标 JavaScript 版本、模块解析策略、严格性级别等。在本项目中，我们启用了严格的类型检查，同时配置了 React JSX 支持。</p><p>项目中的 <code>tsconfig.json</code> 文件已经包含了基本的 TypeScript 配置。根据项目需求，我们可以对其进行定制：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"useDefineForClassFields"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"DOM"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"DOM.Iterable"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"skipLibCheck"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"allowSyntheticDefaultImports"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"forceConsistentCasingInFileNames"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Node"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"resolveJsonModule"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"isolatedModules"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"jsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"react-jsx"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"references"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span> <span class="hljs-attr">"path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./tsconfig.node.json"</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><h3 id="配置-ESLint-和-Prettier"><a href="#配置-ESLint-和-Prettier" class="headerlink" title="配置 ESLint 和 Prettier"></a>配置 ESLint 和 Prettier</h3><p>ESLint 是一个可插拔的 JavaScript 和 TypeScript 代码质量检查工具，它可以识别语法错误和代码风格问题。Prettier 是一个代码格式化工具，专注于代码风格统一。两者结合使用可以确保团队代码质量和风格的一致性。通过配置规则，我们可以自定义检查标准，例如是否使用分号、引号类型、缩进大小等。</p><p>安装相关依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser<br></code></pre></td></tr></table></figure><p>配置 ESLint</p><p>创建 <code>.eslintrc</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"browser"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"es2021"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"extends"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">"eslint:recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:@typescript-eslint/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:react/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:react-hooks/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"prettier"</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parser"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@typescript-eslint/parser"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parserOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"ecmaVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"latest"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"sourceType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"plugins"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"@typescript-eslint"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"react"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"prettier"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"rules"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"prettier/prettier"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"error"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"react/react-in-jsx-scope"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"off"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"settings"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"react"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"detect"</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p>配置 Prettier</p><p>创建 <code>.prettierrc</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"semi"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"singleQuote"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"tabWidth"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"trailingComma"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"es5"</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><h3 id="配置-Git-Hooks"><a href="#配置-Git-Hooks" class="headerlink" title="配置 Git Hooks"></a>配置 Git Hooks</h3><p>Git Hooks 允许我们在 Git 操作的不同阶段执行自定义脚本。通过 Husky 和 lint-staged，我们可以在代码提交前自动运行 ESLint 和 Prettier，确保只有符合规范的代码才能进入代码库。lint-staged 只会针对暂存区的文件运行检查，提高效率。这有助于保持整个项目的代码质量和一致性。</p><p>使用 Husky 和 lint-staged 在代码提交前自动运行代码检查和格式化。</p><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D husky lint-staged<br></code></pre></td></tr></table></figure><p>初始化 Husky</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky install<br></code></pre></td></tr></table></figure><p>配置 lint-staged</p><p>创建 <code>lint-staged.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-string">"*.{ts,tsx}"</span>: [<span class="hljs-string">"eslint --fix"</span>, <span class="hljs-string">"prettier --write"</span>],<br>  <span class="hljs-string">"*.{css,md}"</span>: <span class="hljs-string">"prettier --write"</span>,<br>};<br></code></pre></td></tr></table></figure><p>添加 pre-commit 钩子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky add .husky/pre-commit <span class="hljs-string">"npx lint-staged"</span><br></code></pre></td></tr></table></figure><h3 id="集成-React-Router"><a href="#集成-React-Router" class="headerlink" title="集成 React Router"></a>集成 React Router</h3><p>React Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。</p><p>安装 React Router</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install react-router-dom<br>npm install -D @types/react-router-dom<br></code></pre></td></tr></table></figure><p>创建路由配置</p><p>创建 <code>src/router/router.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { createBrowserRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"../pages/Home"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"../pages/About"</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  {<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span>,<br>  },<br>  {<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">"/about"</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span> /&gt;</span></span>,<br>  },<br>]);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p>在应用中使用路由</p><p>更新 <code>src/App.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">RouterProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">"./router/router"</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterProvider</span> <span class="hljs-attr">router</span>=<span class="hljs-string">{router}</span> /&gt;</span></span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>创建页面组件</p><p>创建 <code>src/pages/Home.tsx</code> 和 <code>src/pages/About.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/pages/Home.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/pages/About.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">About</span>;<br></code></pre></td></tr></table></figure><p>React Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。</p><h3 id="配置-Vite"><a href="#配置-Vite" class="headerlink" title="配置 Vite"></a>配置 Vite</h3><p>项目的 <code>vite.config.ts</code> 文件配置如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;<br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;<br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">resolve</span>: {<br>    <span class="hljs-attr">alias</span>: {<br>      <span class="hljs-string">"@"</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src"</span>),<br>    },<br>  },<br>  <span class="hljs-attr">css</span>: {<br>    <span class="hljs-attr">postcss</span>: <span class="hljs-string">"./postcss.config.js"</span>,<br>  },<br>  <span class="hljs-attr">server</span>: {<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>  },<br>});<br></code></pre></td></tr></table></figure><h3 id="配置-PostCSS"><a href="#配置-PostCSS" class="headerlink" title="配置 PostCSS"></a>配置 PostCSS</h3><p>PostCSS 是一个使用 JavaScript 插件转换 CSS 的工具。在这个项目中，我们使用了两个关键插件：</p><ul><li>Tailwind CSS 插件：处理 Tailwind CSS 相关的样式生成</li><li>Autoprefixer 插件：自动添加厂商前缀以确保样式在不同浏览器中的兼容性</li></ul><p>通过 PostCSS，我们可以自动化处理 CSS，减少手动工作并提高样式兼容性。</p><p><code>postcss.config.js</code> 文件配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">plugins</span>: {<br>    <span class="hljs-attr">tailwindcss</span>: {},<br>    <span class="hljs-attr">autoprefixer</span>: {},<br>  },<br>};<br></code></pre></td></tr></table></figure><h3 id="添加常用组件和工具"><a href="#添加常用组件和工具" class="headerlink" title="添加常用组件和工具"></a>添加常用组件和工具</h3><p>通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。</p><p>创建基础 UI 组件：在 <code>src/components/ui</code> 目录下创建一些基础 UI 组件，例如按钮、输入框等</p><p>创建自定义 Hooks：在 <code>src/hooks</code> 目录下创建常用的自定义 Hooks，例如 <code>useLocalStorage</code>、<code>useToggle</code> 等</p><p>配置路径别名：在 <code>tsconfig.json</code> 中配置路径别名，方便导入模块：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-comment">// ... 其他配置</span><br>    <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"."</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/*"</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p>通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。</p><h3 id="其他重要配置文件说明"><a href="#其他重要配置文件说明" class="headerlink" title="其他重要配置文件说明"></a>其他重要配置文件说明</h3><h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p><code>.gitignore</code> 文件用于指定 Git 应当忽略的文件和目录，防止不必要的文件被提交到代码仓库。在本项目中，该文件包含了以下几类被忽略的内容：</p><ol><li><strong>系统文件</strong>：如 macOS 系统生成的 <code>.DS_Store</code> 文件</li><li><strong>日志文件</strong>：如 npm、yarn 等生成的日志文件</li><li><strong>依赖目录</strong>：如 <code>node_modules/</code> 目录</li><li><strong>构建输出</strong>：如构建工具生成的 <code>dist/</code>、<code>.next/</code> 等目录</li><li><strong>缓存文件</strong>：如各种工具生成的缓存文件</li><li><strong>环境变量文件</strong>：如 <code>.env</code> 及其变体文件，防止敏感信息泄露</li><li><strong>编辑器配置</strong>：如编辑器生成的临时文件</li></ol><p>通过合理配置 <code>.gitignore</code>，可以减小代码仓库体积，保护敏感信息，并避免无关文件干扰开发。</p><h4 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h4><p><code>.editorconfig</code> 文件用于统一不同编辑器和 IDE 的代码格式设置。在团队协作中，不同开发者可能使用不同的编辑器，该文件可以确保所有人使用相同的编码规范：</p><ul><li>使用空格缩进，缩进大小为 2 个空格</li><li>行尾符使用 LF (Unix 风格)</li><li>字符编码使用 UTF-8</li><li>自动删除行尾空白字符</li><li>文件末尾自动添加新行</li></ul><p>这有助于保持代码风格的一致性，避免因编辑器差异导致的格式混乱。</p><h4 id="prettierrc-js"><a href="#prettierrc-js" class="headerlink" title=".prettierrc.js"></a>.prettierrc.js</h4><p>Prettier 配置文件，用于统一代码格式化风格：</p><ul><li>不使用分号结尾</li><li>对象和数组末尾保留逗号</li><li>使用单引号而非双引号</li><li>单行最大宽度为 120 字符</li><li>缩进使用 2 个空格</li><li>行尾符自动适应操作系统</li></ul><p>Prettier 会在保存文件或执行格式化命令时自动应用这些规则，确保整个项目的代码风格统一。</p><h4 id="commitlint-config-cjs"><a href="#commitlint-config-cjs" class="headerlink" title="commitlint.config.cjs"></a>commitlint.config.cjs</h4><p>Commitlint 配置文件，用于校验 Git 提交信息的格式。它继承了 <code>@commitlint/config-conventional</code> 规则，要求提交信息遵循约定式提交规范：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&lt;<span class="hljs-keyword">type</span>&gt;[<span class="hljs-keyword">optional</span> scope]: &lt;description&gt;<br><br>[<span class="hljs-keyword">optional</span> body]<br><br>[<span class="hljs-keyword">optional</span> footer(s)]<br></code></pre></td></tr></table></figure><p>其中 type 必须是以下几种之一：</p><ul><li>feat: 新功能</li><li>fix: 修复 bug</li><li>chore: 构建过程或辅助工具的变动</li><li>docs: 文档更新</li><li>style: 代码格式调整</li><li>refactor: 重构</li><li>perf: 性能优化</li><li>test: 测试用例</li></ul><p>这有助于生成标准化的变更日志，便于团队理解和维护项目历史。</p><h4 id="stylelintrc-json"><a href="#stylelintrc-json" class="headerlink" title=".stylelintrc.json"></a>.stylelintrc.json</h4><p>Stylelint 配置文件，用于检查 CSS/LESS 样式代码的质量和风格。该项目配置了：</p><ul><li>继承标准规则集和 Prettier 推荐规则</li><li>支持 LESS 语法</li><li>启用 Prettier 规则</li><li>自定义类名命名规范（小写字母和连字符）</li><li>允许未知的 at-rule（为了支持 LESS 特性）</li></ul><p>通过 Stylelint 可以确保样式代码的一致性和质量，避免常见的样式错误。</p><h4 id="lint-staged-config-js"><a href="#lint-staged-config-js" class="headerlink" title="lint-staged.config.js"></a>lint-staged.config.js</h4><p>Lint-staged 配置文件，用于对 Git 暂存区的文件执行检查和格式化：</p><ul><li>对 TypeScript 文件执行 ESLint 和 Prettier</li><li>对 JavaScript 文件执行 ESLint 和 Prettier</li><li>对 LESS 和 CSS 文件执行 Stylelint</li><li>对其他文件执行相应检查</li></ul><p>这确保只有符合规范的代码才能被提交到仓库，提升整体代码质量。</p><h3 id="开发环境和生产环境配置"><a href="#开发环境和生产环境配置" class="headerlink" title="开发环境和生产环境配置"></a>开发环境和生产环境配置</h3><p>开发环境启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run dev<br></code></pre></td></tr></table></figure><p>构建生产版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><p>预览生产构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run preview<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南&quot;&gt;&lt;a href=&quot;#Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南&quot; class=&quot;headerlink&quot; title=&quot;Vite + R</summary>
      
    
    
    
    <category term="Github" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-22- 使用 GitHub Actions 自动部署基于vite的项目到 GitHub Pages</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33040.html</id>
    <published>2025-11-22T17:59:24.000Z</published>
    <updated>2025-11-23T09:48:37.352Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记主要讲在新创建前端项目后，如何通过 GitHub-Actions 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</p><p>参考 <a href="https://zhongye1.github.io/BDdraw_DEV/#/">https://zhongye1.github.io/BDdraw_DEV/#/</a><br>其从仓库 <a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a> 实现自动构建和部署</p><h3 id="0-前置条件"><a href="#0-前置条件" class="headerlink" title="0.前置条件"></a>0.前置条件</h3><ul><li>GitHub 账户 + 一个 public 仓库（私有仓库需要 GitHub Pro 才能开 Pages）</li></ul><h3 id="1-创建-GitHub-Actions-工作流"><a href="#1-创建-GitHub-Actions-工作流" class="headerlink" title="1. 创建 GitHub Actions 工作流"></a>1. 创建 GitHub Actions 工作流</h3><p>在仓库根目录创建文件： .github/workflows/deploy.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">main</span>]<br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">read</span><br>  <span class="hljs-attr">pages:</span> <span class="hljs-string">write</span><br>  <span class="hljs-attr">id-token:</span> <span class="hljs-string">write</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">github-pages</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">${{</span> <span class="hljs-string">steps.deployment.outputs.page_url</span> <span class="hljs-string">}}</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Bun</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">oven-sh/setup-bun@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">bun-version:</span> <span class="hljs-string">latest</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">bun</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">bun</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/configure-pages@v5</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">artifact</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/upload-pages-artifact@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">"./dist"</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">deployment</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/deploy-pages@v4</span><br></code></pre></td></tr></table></figure><h3 id="2-配置-vite-config-ts-的-base"><a href="#2-配置-vite-config-ts-的-base" class="headerlink" title="2. 配置 vite.config.ts 的 base"></a>2. 配置 vite.config.ts 的 base</h3><p>打开 vite.config.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span><br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-react'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">base</span>: <span class="hljs-string">'/BDdraw_DEV/'</span>,   <span class="hljs-comment">// 必须和仓库名完全一致！大小写也要一样</span><br>})<br></code></pre></td></tr></table></figure><p>如果想让它在本地开发和 GitHub Pages 都正常，可以写成动态 base：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">base</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">'production'</span> ? <span class="hljs-string">'/BDdraw_DEV/'</span> : <span class="hljs-string">'/'</span>,<br>})<br></code></pre></td></tr></table></figure><h3 id="3-GitHub-仓库设置-Pages-为-Actions-模式"><a href="#3-GitHub-仓库设置-Pages-为-Actions-模式" class="headerlink" title="3. GitHub 仓库设置 Pages 为 Actions 模式"></a>3. GitHub 仓库设置 Pages 为 Actions 模式</h3><ol><li>进入仓库 → Settings → Pages（左侧菜单）</li><li>Build and deployment → Source 选 <strong>GitHub Actions</strong></li><li>保存</li></ol><h3 id="4-提交代码触发第一次部署"><a href="#4-提交代码触发第一次部署" class="headerlink" title="4. 提交代码触发第一次部署"></a>4. 提交代码触发第一次部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add .<br>git commit -m <span class="hljs-string">"chore: 新建 GitHub Actions 部署工作流"</span><br>git push origin main<br></code></pre></td></tr></table></figure><p>然后去仓库 → Actions 标签页，就能看到正在跑的 “Deploy to GitHub Pages” 工作流。</p><p>成功后可以前往对应的 GitHub Pages 地址查看效果</p><p class='item-img' data-src='https://pica.zhimg.com/v2-25ed9b20ac34367edf61581afc6742ea_r.jpg'><img src="https://pica.zhimg.com/v2-25ed9b20ac34367edf61581afc6742ea_r.jpg" alt="alt text"></p><p>只要 push 到 main 分支，GitHub Actions 就会自动触发工作流，实现自动部署。</p><blockquote><p>如果是私有仓库，需要 GitHub Pro 才能开 Pages</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇笔记主要讲在新创建前端项目后，如何通过 GitHub-Actions 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作&lt;/p&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://zhongye1.github.io/BDdraw_DE</summary>
      
    
    
    
    <category term="Github" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
