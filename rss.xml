<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes|笔记站</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2025-11-24T06:01:03.121Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025-11-24-canvas项目相关-TransformerRenderer设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/46327.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/46327.html</id>
    <published>2025-11-24T05:58:19.000Z</published>
    <updated>2025-11-24T06:01:03.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TransformerRenderer-设计"><a href="#TransformerRenderer-设计" class="headerlink" title="TransformerRenderer 设计"></a>TransformerRenderer 设计</h1><p>TransformerRenderer 模块负责渲染画布中选中元素的变换控制器（选择框和控制手柄），包括：</p><ul><li>绘制元素选择边界框</li><li>显示控制手柄（用于移动、缩放、旋转等操作）</li><li>处理用户与控制手柄的交互</li></ul><h3 id="项目结构树"><a href="#项目结构树" class="headerlink" title="项目结构树"></a>项目结构树</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">src<span class="hljs-symbol">/</span><br>└── pages<span class="hljs-symbol">/</span><br>    └── canvas<span class="hljs-symbol">/</span><br>        └── Pixi_STM_modules<span class="hljs-symbol">/</span><br>            └── rendering<span class="hljs-symbol">/</span><br>                └── TransformerRenderer.ts<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>作用</th></tr></thead><tbody><tr><td>PixiJS</td><td>2D 渲染引擎，用于绘制图形元素和交互控制器</td></tr><tr><td>TypeScript</td><td>提供类型安全和更好的开发体验</td></tr><tr><td>CanvasElement</td><td>数据模型，提供元素属性用于渲染</td></tr></tbody></table></div><h2 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h2><h3 id="2-1-renderTransformer-参数"><a href="#2-1-renderTransformer-参数" class="headerlink" title="2.1 renderTransformer 参数"></a>2.1 renderTransformer 参数</h3><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td><code>Record&lt;string, CanvasElement&gt;</code></td><td>是</td><td>-</td><td>所有画布元素的集合</td></tr><tr><td>selectedIds</td><td><code>string[]</code></td><td>是</td><td>-</td><td>当前选中元素的 ID 数组</td></tr><tr><td>spriteMap</td><td>`Map&lt;string, PIXI.Graphics \</td><td>PIXI.HTMLText \</td><td>PIXI.Sprite&gt;`</td><td>是</td><td>-</td><td>元素 ID 到 Pixi 图形对象的映射</td></tr><tr><td>onHandleDown</td><td>`(e: PIXI.FederatedPointerEvent, handle: HandleType \</td><td>‘p0’ \</td><td>‘p1’, elementId: string) =&gt; void`</td><td>是</td><td>-</td><td>控制手柄按下时的回调函数</td></tr><tr><td>viewportScale</td><td><code>number</code></td><td>是</td><td>-</td><td>视口缩放比例，用于调整手柄大小</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">transformerRenderer.<span class="hljs-title function_">renderTransformer</span>(<br>  elements, <span class="hljs-comment">// 所有画布元素</span><br>  selectedIds, <span class="hljs-comment">// 选中元素ID数组</span><br>  spriteMap, <span class="hljs-comment">// 元素到图形对象的映射</span><br>  onHandleDown, <span class="hljs-comment">// 手柄按下回调</span><br>  viewport.<span class="hljs-property">scale</span>.<span class="hljs-property">x</span> <span class="hljs-comment">// 视口缩放比例</span><br>);<br></code></pre></td></tr></table></figure><h3 id="2-2-类型定义"><a href="#2-2-类型定义" class="headerlink" title="2.2 类型定义"></a>2.2 类型定义</h3><h4 id="CanvasElement-类型"><a href="#CanvasElement-类型" class="headerlink" title="CanvasElement 类型"></a>CanvasElement 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][];<br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 旋转角度（弧度）</span><br>  <span class="hljs-comment">// 其他文本和图像相关属性...</span><br>}<br></code></pre></td></tr></table></figure><p>字段说明：</p><ul><li><code>id</code>: 元素唯一标识符</li><li><code>type</code>: 元素类型（如’rect’, ‘circle’, ‘text’等）</li><li><code>x, y</code>: 元素位置坐标</li><li><code>width, height</code>: 元素尺寸</li><li><code>fill, stroke, strokeWidth</code>: 填充色、边框色和边框宽度</li><li><code>alpha</code>: 透明度</li><li><code>points</code>: 点集（用于 pencil, line, arrow 等）</li><li><code>rotation</code>: 旋转角度（弧度制）</li></ul><h4 id="HandleType-类型"><a href="#HandleType-类型" class="headerlink" title="HandleType 类型"></a>HandleType 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">HandleType</span> =<br>  | <span class="hljs-string">"tl"</span><br>  | <span class="hljs-string">"t"</span><br>  | <span class="hljs-string">"tr"</span><br>  | <span class="hljs-string">"r"</span><br>  | <span class="hljs-string">"br"</span><br>  | <span class="hljs-string">"b"</span><br>  | <span class="hljs-string">"bl"</span><br>  | <span class="hljs-string">"l"</span><br>  | <span class="hljs-string">"p0"</span><br>  | <span class="hljs-string">"p1"</span><br>  | <span class="hljs-string">"rotate"</span>;<br></code></pre></td></tr></table></figure><p>各控制手柄类型含义：</p><ul><li><code>tl</code>, <code>t</code>, <code>tr</code>, <code>r</code>, <code>br</code>, <code>b</code>, <code>bl</code>, <code>l</code>: 八个方向的缩放手柄</li><li><code>p0</code>, <code>p1</code>: 线段两个端点的移动手柄</li><li><code>rotate</code>: 旋转手柄</li></ul><h2 id="3-状态管理-State-Architecture"><a href="#3-状态管理-State-Architecture" class="headerlink" title="3. 状态管理 (State Architecture)"></a>3. 状态管理 (State Architecture)</h2><h3 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h3><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>transformerGraphic</td><td><code>PIXI.Graphics</code></td><td>用于绘制变换控制器的 Pixi 图形对象</td></tr></tbody></table></div><h3 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h3><p>TransformerRenderer 是一个纯渲染模块，不直接管理外部状态。它通过以下方式接收外部状态：</p><ol><li><code>elements</code>: 从 Zustand store 获取的所有画布元素</li><li><code>selectedIds</code>: 从 Zustand store 获取的当前选中元素 ID 数组</li><li><code>spriteMap</code>: 从 ElementRenderer 获取的元素到图形对象的映射</li></ol><h3 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store] --&gt; B[StageManager 订阅状态变化]<br>    B --&gt; C[获取 elements 和 selectedIds]<br>    C --&gt; D[调用 TransformerRenderer.renderTransformer]<br>    D --&gt; E[根据选中元素绘制变换控制器]<br>    F[ElementRenderer] --&gt; G[提供 spriteMap]<br>    G --&gt; D<br></code></pre></td></tr></table></figure><h2 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h2><h3 id="4-1-交互时序图"><a href="#4-1-交互时序图" class="headerlink" title="4.1 交互时序图"></a>4.1 交互时序图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant TR as TransformerRenderer<br>    participant SM as StageManager<br>    participant CS as CanvasStore<br><br>    U-&gt;&gt;TR: 点击控制手柄<br>    TR-&gt;&gt;SM: 调用 onHandleDown 回调<br>    SM-&gt;&gt;SM: 设置交互模式(移动/缩放/旋转)<br>    SM-&gt;&gt;CS: 更新元素属性<br>    CS-&gt;&gt;SM: 状态变更通知<br>    SM-&gt;&gt;TR: 重新调用 renderTransformer<br>    TR-&gt;&gt;TR: 重新绘制变换控制器<br></code></pre></td></tr></table></figure><h3 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h3><h4 id="renderTransformer-函数"><a href="#renderTransformer-函数" class="headerlink" title="renderTransformer 函数:"></a>renderTransformer 函数:</h4><p>当画布元素或选中状态发生变化时，由 StageManager 调用，接收当前所有元素和选中元素 ID，根据选中元素类型和状态决定绘制方式，调用相应方法绘制变换控制器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderTransformer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, PIXI.<span class="hljs-title class_">Graphics</span> | PIXI.<span class="hljs-title class_">HTMLText</span> | PIXI.<span class="hljs-title class_">Sprite</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">onHandleDown</span>: (e: PIXI.FederatedPointerEvent, handle: HandleType | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>, elementId: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">void</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">viewportScale</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 清空之前的绘制内容</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">clear</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">removeChildren</span>()<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-comment">// 根据选中元素类型决定绘制方式</span><br>  <span class="hljs-keyword">const</span> el = elements[selectedIds[<span class="hljs-number">0</span>]]<br>  <span class="hljs-keyword">const</span> isLinearElement = selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> &amp;&amp; (el.<span class="hljs-property">type</span> === <span class="hljs-string">'line'</span> || el.<span class="hljs-property">type</span> === <span class="hljs-string">'arrow'</span>) &amp;&amp; el.<span class="hljs-property">points</span>?.<span class="hljs-property">length</span> === <span class="hljs-number">2</span><br><br>  <span class="hljs-keyword">if</span> (isLinearElement) {<br>    <span class="hljs-comment">// 绘制线段控制手柄</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawLinearHandles</span>(el, selectedIds, onHandleDown, viewportScale)<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 绘制包围盒控制手柄</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBoundingBoxHandles</span>(elements, selectedIds, spriteMap, onHandleDown, viewportScale)<br>  }<br>}<br></code></pre></td></tr></table></figure><p>一些处理</p><ul><li>区分线性元素（line/arrow）和普通元素的不同控制手柄绘制方式</li><li>根据是否有旋转属性决定绘制普通边界框还是旋转边界框</li><li>根据选中元素数量决定是否显示控制手柄</li></ul><h4 id="drawRotatedBounds-函数"><a href="#drawRotatedBounds-函数" class="headerlink" title="drawRotatedBounds 函数:"></a>drawRotatedBounds 函数:</h4><p>当选中元素具有旋转属性时，在 renderTransformer 中被调用，接收边界框信息和旋转角度，计算旋转后各角点坐标，绘制旋转后的边界框和控制手柄</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">drawRotatedBounds</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">bounds</span>: { x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>; width: <span class="hljs-built_in">number</span>; height: <span class="hljs-built_in">number</span> },</span><br><span class="hljs-params">  <span class="hljs-attr">rotation</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">viewportScale</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">onHandleDown</span>: (e: PIXI.FederatedPointerEvent, handle: HandleType | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>, elementId: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">void</span>,</span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">const</span> centerX = bounds.<span class="hljs-property">x</span> + bounds.<span class="hljs-property">width</span> / <span class="hljs-number">2</span><br>  <span class="hljs-keyword">const</span> centerY = bounds.<span class="hljs-property">y</span> + bounds.<span class="hljs-property">height</span> / <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// 计算旋转后的四个角点</span><br>  <span class="hljs-keyword">const</span> halfWidth = bounds.<span class="hljs-property">width</span> / <span class="hljs-number">2</span><br>  <span class="hljs-keyword">const</span> halfHeight = bounds.<span class="hljs-property">height</span> / <span class="hljs-number">2</span><br><br>  <span class="hljs-keyword">const</span> corners = [<br>    { <span class="hljs-attr">x</span>: -halfWidth, <span class="hljs-attr">y</span>: -halfHeight }, <span class="hljs-comment">// 左上</span><br>    { <span class="hljs-attr">x</span>: halfWidth, <span class="hljs-attr">y</span>: -halfHeight },  <span class="hljs-comment">// 右上</span><br>    { <span class="hljs-attr">x</span>: halfWidth, <span class="hljs-attr">y</span>: halfHeight },   <span class="hljs-comment">// 右下</span><br>    { <span class="hljs-attr">x</span>: -halfWidth, <span class="hljs-attr">y</span>: halfHeight }   <span class="hljs-comment">// 左下</span><br>  ]<br><br>  <span class="hljs-comment">// 应用旋转矩阵计算实际坐标</span><br>  <span class="hljs-keyword">const</span> rotatedCorners = corners.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">corner</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> cos = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rotation)<br>    <span class="hljs-keyword">const</span> sin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rotation)<br>    <span class="hljs-keyword">return</span> {<br>      <span class="hljs-attr">x</span>: centerX + corner.<span class="hljs-property">x</span> * cos - corner.<span class="hljs-property">y</span> * sin,<br>      <span class="hljs-attr">y</span>: centerY + corner.<span class="hljs-property">x</span> * sin + corner.<span class="hljs-property">y</span> * cos<br>    }<br>  })<br><br>  <span class="hljs-comment">// 绘制旋转后的边界框</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">poly</span>(rotatedCorners)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">color</span>: <span class="hljs-number">0x8b5cf6</span> })<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">closePath</span>()<br><br>  <span class="hljs-comment">// 绘制控制手柄和其他UI元素</span><br>  <span class="hljs-comment">// ...</span><br>}<br></code></pre></td></tr></table></figure><ul><li>使用三角函数计算旋转后坐标</li><li>正确放置旋转手柄位置，使其始终位于边界框上方</li><li>保持手柄与边界框一同旋转</li></ul><h2 id="5-UI-与样式实现-UI-Implementation"><a href="#5-UI-与样式实现-UI-Implementation" class="headerlink" title="5. UI 与样式实现 (UI Implementation)"></a>5. UI 与样式实现 (UI Implementation)</h2><h3 id="布局策略"><a href="#布局策略" class="headerlink" title="布局策略"></a>布局策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[transformerGraphic 容器] --&gt; B[边界框/多边形]<br>    A --&gt; C[控制手柄]<br>    A --&gt; D[旋转手柄]<br>    A --&gt; E[手柄点击区域]<br><br>    C --&gt; C1[左上手柄]<br>    C --&gt; C2[上边手柄]<br>    C --&gt; C3[右上手柄]<br>    C --&gt; C4[右边手柄]<br>    C --&gt; C5[右下手柄]<br>    C --&gt; C6[下边手柄]<br>    C --&gt; C7[左下手柄]<br>    C --&gt; C8[左边手柄]<br><br>    D --&gt; D1[旋转手柄圆形]<br>    D --&gt; D2[连接线]<br><br>    E --&gt; E1[手柄透明点击区域]<br></code></pre></td></tr></table></figure><h3 id="样式方案"><a href="#样式方案" class="headerlink" title="样式方案"></a>样式方案</h3><p>TransformerRenderer 使用 PixiJS 的 Graphics API 进行绘制：</p><ol><li><p><strong>边界框样式</strong>:</p><ul><li>颜色: 紫色 (#8b5cf6)</li><li>线宽: 1px</li></ul></li><li><p><strong>控制手柄样式</strong>:</p><ul><li>形状: 矩形</li><li>填充色: 白色</li><li>边框色: 紫色 (#8b5cf6)</li><li>边框宽度: 1px</li></ul></li><li><p><strong>旋转手柄样式</strong>:</p><ul><li>形状: 圆形</li><li>填充色: 白色</li><li>边框色: 紫色 (#8b5cf6)</li><li>边框宽度: 1px</li></ul></li><li><p><strong>手柄大小自适应</strong>:<br>根据视口缩放比例调整手柄大小:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> handleSize = <span class="hljs-number">8</span> / viewportScale;<br></code></pre></td></tr></table></figure></li></ol><h3 id="元素操作机制实现"><a href="#元素操作机制实现" class="headerlink" title="元素操作机制实现"></a>元素操作机制实现</h3><h4 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h4><ol><li>检测元素是否有 rotation 属性</li><li>计算元素中心点和旋转后各角点坐标</li><li>绘制旋转后的边界框</li><li><p>旋转手柄位置通过以下方式计算:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 计算未旋转时顶部中心点</span><br><span class="hljs-keyword">const</span> topCenterX = centerX;<br><span class="hljs-keyword">const</span> topCenterY = bounds.<span class="hljs-property">y</span>;<br><br><span class="hljs-comment">// 将顶部中心点也进行旋转</span><br><span class="hljs-keyword">const</span> rotatedTopCenterX =<br>  centerX +<br>  (topCenterX - centerX) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rotation) -<br>  (topCenterY - centerY) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rotation);<br><span class="hljs-keyword">const</span> rotatedTopCenterY =<br>  centerY +<br>  (topCenterX - centerX) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rotation) +<br>  (topCenterY - centerY) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rotation);<br></code></pre></td></tr></table></figure></li></ol><h4 id="缩放操作"><a href="#缩放操作" class="headerlink" title="缩放操作"></a>缩放操作</h4><ol><li>根据手柄类型确定缩放方向</li><li>通过拖拽距离计算新的元素尺寸</li><li>更新元素的 width/height 属性</li></ol><h4 id="移动操作"><a href="#移动操作" class="headerlink" title="移动操作"></a>移动操作</h4><ol><li>通过拖拽偏移量更新元素的 x/y 属性</li><li>对于多选元素，保持相对位置不变</li></ol><h4 id="元素打组机制"><a href="#元素打组机制" class="headerlink" title="元素打组机制"></a>元素打组机制</h4><p>当前实现中，多元素选择时:</p><ol><li>计算所有选中元素的包围盒</li><li>在包围盒周围显示控制手柄</li><li>操作时同时影响所有选中元素</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TransformerRenderer-设计&quot;&gt;&lt;a href=&quot;#TransformerRenderer-设计&quot; class=&quot;headerlink&quot; title=&quot;TransformerRenderer 设计&quot;&gt;&lt;/a&gt;TransformerRenderer </summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-24-canvas项目相关-元素操作和打组机制实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/54304.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/54304.html</id>
    <published>2025-11-24T05:52:47.000Z</published>
    <updated>2025-11-24T05:57:53.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="元素操作机制和元素打组机制实现文档"><a href="#元素操作机制和元素打组机制实现文档" class="headerlink" title="元素操作机制和元素打组机制实现文档"></a>元素操作机制和元素打组机制实现文档</h1><h2 id="1-DES"><a href="#1-DES" class="headerlink" title="1. DES"></a>1. DES</h2><p>元素操作机制（移动、缩放、旋转）和元素打组机制的实现方案，包括数据结构、交互逻辑、状态管理和相关组件的实现细节。</p><h3 id="项目结构树"><a href="#项目结构树" class="headerlink" title="项目结构树"></a>项目结构树</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nix">src<span class="hljs-symbol">/</span><br>├── pages<span class="hljs-symbol">/</span><br>│   └── canvas<span class="hljs-symbol">/</span><br>│       └── Pixi_STM_modules<span class="hljs-symbol">/</span><br>│           ├── core<span class="hljs-symbol">/</span><br>│           │   └── StageManagerCore.ts     <span class="hljs-comment"># 主要操作逻辑实现</span><br>│           ├── rendering<span class="hljs-symbol">/</span><br>│           │   ├── ElementRenderer.ts      <span class="hljs-comment"># 元素渲染</span><br>│           │   └── TransformerRenderer.ts  <span class="hljs-comment"># 选择框和控制手柄渲染</span><br>│           └── core<span class="hljs-symbol">/</span><br>│               └── types.ts                <span class="hljs-comment"># 相关类型定义</span><br>├── stores<span class="hljs-symbol">/</span><br>│   └── canvasStore.ts                      <span class="hljs-comment"># CanvasElement 接口定义和状态管理</span><br>└── lib<span class="hljs-symbol">/</span><br>    └── UpdateElementCommand.ts             <span class="hljs-comment"># 撤销/重做命令实现</span><br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>作用</th></tr></thead><tbody><tr><td>PixiJS</td><td>2D 渲染引擎，用于绘制图形元素和交互控制器</td></tr><tr><td>pixi-viewport</td><td>提供无限画布支持和视口控制</td></tr><tr><td>TypeScript</td><td>提供类型安全和更好的开发体验</td></tr><tr><td>Zustand</td><td>全局状态管理</td></tr><tr><td>nanoid</td><td>生成元素唯一标识符</td></tr></tbody></table></div><h2 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h2><h3 id="2-1-核心方法参数"><a href="#2-1-核心方法参数" class="headerlink" title="2.1 核心方法参数"></a>2.1 核心方法参数</h3><p>StageManagerCore 交互方法：</p><h4 id="onPointerDown-方法"><a href="#onPointerDown-方法" class="headerlink" title="onPointerDown 方法"></a>onPointerDown 方法</h4><p>处理指针按下事件，开始各种操作</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>e</td><td><code>PIXI.FederatedPointerEvent</code></td><td>是</td><td>-</td><td>PixiJS 指针事件对象</td></tr></tbody></table></div><h4 id="onPointerMove-方法"><a href="#onPointerMove-方法" class="headerlink" title="onPointerMove 方法"></a>onPointerMove 方法</h4><p>处理指针移动事件，执行操作过程</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>e</td><td><code>PIXI.FederatedPointerEvent</code></td><td>是</td><td>-</td><td>PixiJS 指针事件对象</td></tr></tbody></table></div><h4 id="onPointerUp-方法"><a href="#onPointerUp-方法" class="headerlink" title="onPointerUp 方法"></a>onPointerUp 方法</h4><p>处理指针释放事件，结束操作</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>无参数</td><td>-</td><td>-</td><td>-</td><td>无参数</td></tr></tbody></table></div><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore 中注册指针事件处理</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">interactionHandler</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InteractionHandler</span>(<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onPointerDown</span>, <span class="hljs-comment">// 指针按下处理</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onPointerMove</span>, <span class="hljs-comment">// 指针移动处理</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onPointerUp</span>, <span class="hljs-comment">// 指针释放处理</span><br>)<br></code></pre></td></tr></table></figure><h3 id="2-2-类型定义"><a href="#2-2-类型定义" class="headerlink" title="2.2 类型定义"></a>2.2 类型定义</h3><h4 id="StageManagerState-类型"><a href="#StageManagerState-类型" class="headerlink" title="StageManagerState 类型"></a>StageManagerState 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StageManagerState</span> {<br>  <span class="hljs-attr">mode</span>: <span class="hljs-title class_">InteractionMode</span> <span class="hljs-comment">// 当前交互模式</span><br>  <span class="hljs-attr">startPos</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } <span class="hljs-comment">// 操作起始位置</span><br>  <span class="hljs-attr">currentId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 当前操作元素ID</span><br>  <span class="hljs-attr">initialElementsMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span> <span class="hljs-comment">// 调整大小初始状态</span><br>  <span class="hljs-attr">initialGroupBounds</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span> } | <span class="hljs-literal">null</span> <span class="hljs-comment">// 群组初始边界</span><br>  <span class="hljs-attr">activeHandle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 激活的控制手柄</span><br>  <span class="hljs-attr">isSpacePressed</span>: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 空格键是否按下</span><br>  <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 是否已销毁</span><br>  <span class="hljs-attr">resizeInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span> <span class="hljs-comment">// 缩放初始状态</span><br>  <span class="hljs-attr">dragInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span> <span class="hljs-comment">// 拖拽初始状态</span><br>  <span class="hljs-attr">rotationInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<br>    <span class="hljs-built_in">string</span>,<br>    {<br>      <span class="hljs-comment">// 旋转初始状态</span><br>      <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>      <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>      <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span><br>      <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span><br>      <span class="hljs-attr">rotation</span>: <span class="hljs-built_in">number</span><br>      <span class="hljs-attr">cx</span>: <span class="hljs-built_in">number</span><br>      <span class="hljs-attr">cy</span>: <span class="hljs-built_in">number</span><br>    }<br>  &gt; | <span class="hljs-literal">null</span><br>  <span class="hljs-attr">rotationCenter</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } | <span class="hljs-literal">null</span> <span class="hljs-comment">// 旋转中心点</span><br>  <span class="hljs-attr">startRotationAngle</span>: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 起始旋转角度</span><br>}<br></code></pre></td></tr></table></figure><h4 id="InteractionMode-类型"><a href="#InteractionMode-类型" class="headerlink" title="InteractionMode 类型"></a>InteractionMode 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">InteractionMode</span> =<br>  | <span class="hljs-string">'idle'</span> <span class="hljs-comment">// 空闲状态</span><br>  | <span class="hljs-string">'panning'</span> <span class="hljs-comment">// 画布平移</span><br>  | <span class="hljs-string">'selecting'</span> <span class="hljs-comment">// 选择元素</span><br>  | <span class="hljs-string">'dragging'</span> <span class="hljs-comment">// 拖拽元素</span><br>  | <span class="hljs-string">'resizing'</span> <span class="hljs-comment">// 调整大小</span><br>  | <span class="hljs-string">'drawing'</span> <span class="hljs-comment">// 绘制元素</span><br>  | <span class="hljs-string">'texting'</span> <span class="hljs-comment">// 文本编辑</span><br>  | <span class="hljs-string">'erasing'</span> <span class="hljs-comment">// 擦除元素</span><br>  | <span class="hljs-string">'rotating'</span> <span class="hljs-comment">// 旋转元素</span><br></code></pre></td></tr></table></figure><h4 id="HandleType-类型"><a href="#HandleType-类型" class="headerlink" title="HandleType 类型"></a>HandleType 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">HandleType</span> =<br>  | <span class="hljs-string">'tl'</span><br>  | <span class="hljs-string">'t'</span><br>  | <span class="hljs-string">'tr'</span> <span class="hljs-comment">// 上方三个手柄</span><br>  | <span class="hljs-string">'r'</span> <span class="hljs-comment">// 右侧手柄</span><br>  | <span class="hljs-string">'br'</span><br>  | <span class="hljs-string">'b'</span><br>  | <span class="hljs-string">'bl'</span> <span class="hljs-comment">// 下方三个手柄</span><br>  | <span class="hljs-string">'l'</span> <span class="hljs-comment">// 左侧手柄</span><br>  | <span class="hljs-string">'p0'</span><br>  | <span class="hljs-string">'p1'</span> <span class="hljs-comment">// 线段端点手柄</span><br>  | <span class="hljs-string">'rotate'</span> <span class="hljs-comment">// 旋转手柄</span><br></code></pre></td></tr></table></figure><h2 id="3-状态管理-State-Architecture"><a href="#3-状态管理-State-Architecture" class="headerlink" title="3. 状态管理 (State Architecture)"></a>3. 状态管理 (State Architecture)</h2><h3 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h3><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>mode</td><td><code>InteractionMode</code></td><td>当前交互模式</td></tr><tr><td>startPos</td><td><code>{ x: number; y: number }</code></td><td>操作起始位置</td></tr><tr><td>currentId</td><td>`string</td><td>null`</td><td>当前操作元素 ID</td></tr><tr><td>activeHandle</td><td>`HandleType</td><td>null`</td><td>激活的控制手柄</td></tr><tr><td>isSpacePressed</td><td><code>boolean</code></td><td>空格键是否按下</td></tr><tr><td>destroyed</td><td><code>boolean</code></td><td>是否已销毁</td></tr><tr><td>resizeInitialStates</td><td>`Record<string, Partial<CanvasElement="">&gt;</string,></td><td>null`</td><td>缩放操作初始状态</td></tr><tr><td>dragInitialStates</td><td>`Record<string, Partial<CanvasElement="">&gt;</string,></td><td>null`</td><td>拖拽操作初始状态</td></tr><tr><td>rotationInitialStates</td><td>`Record&lt;…&gt;</td><td>null`</td><td>旋转操作初始状态</td></tr><tr><td>rotationCenter</td><td>`{ x: number; y: number }</td><td>null`</td><td>旋转中心点</td></tr><tr><td>startRotationAngle</td><td>`number</td><td>null`</td><td>起始旋转角度</td></tr></tbody></table></div><h3 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h3><p>StageManagerCore 订阅了 Zustand store 中的状态：</p><ol><li><code>elements</code>: 所有画布元素</li><li><code>selectedIds</code>: 当前选中元素 ID 数组</li><li><code>tool</code>: 当前工具类型</li></ol><h3 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store] --&gt; B[StageManager 订阅状态变化]<br>    B --&gt; C[获取 elements, selectedIds, tool]<br>    C --&gt; D[调用 ElementRenderer.renderElements]<br>    C --&gt; E[调用 TransformerRenderer.renderTransformer]<br>    F[用户交互] --&gt; G[onPointerDown/Move/Up]<br>    G --&gt; H[更新 Zustand Store]<br>    H --&gt; B<br></code></pre></td></tr></table></figure><h2 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h2><h3 id="4-1-交互时序图"><a href="#4-1-交互时序图" class="headerlink" title="4.1 交互时序图"></a>4.1 交互时序图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManager<br>    participant CS as CanvasStore<br>    participant ER as ElementRenderer<br>    participant TR as TransformerRenderer<br><br>    U-&gt;&gt;SM: 按下鼠标开始操作<br>    SM-&gt;&gt;SM: 设置操作模式(移动/缩放/旋转)<br>    SM-&gt;&gt;CS: 记录初始状态并锁定撤销管理器<br>    SM-&gt;&gt;CS: 更新元素属性<br><br>    CS-&gt;&gt;SM: 状态变更通知<br>    SM-&gt;&gt;ER: 重新渲染元素<br>    SM-&gt;&gt;TR: 重新渲染变换控制器<br><br>    U-&gt;&gt;SM: 移动鼠标执行操作<br>    SM-&gt;&gt;CS: 持续更新元素属性<br><br>    U-&gt;&gt;SM: 释放鼠标结束操作<br>    SM-&gt;&gt;CS: 解锁撤销管理器<br>    SM-&gt;&gt;CS: 创建并执行操作命令<br></code></pre></td></tr></table></figure><h3 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h3><h4 id="onPointerDown-函数"><a href="#onPointerDown-函数" class="headerlink" title="onPointerDown 函数:"></a>onPointerDown 函数:</h4><p>用户在画布上按下鼠标时触发<br>根据当前工具和鼠标位置确定操作类型,设置相应的操作模式和初始状态,为后续的 onPointerMove 操作做准备</p><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 省略部分代码...</span><br><br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> &amp;&amp; e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span> &amp;&amp; !e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'handle:'</span>)) {<br>    <span class="hljs-keyword">const</span> hitId = e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>;<br>    <span class="hljs-comment">// 如果我们不在选择模式，切换到选择模式</span><br>    <span class="hljs-keyword">if</span> (tool !== <span class="hljs-string">'select'</span>) {<br>      state.<span class="hljs-title function_">setTool</span>(<span class="hljs-string">'select'</span>);<br>    }<br>    <span class="hljs-comment">// 选择元素并开始拖拽</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">'dragging'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">currentId</span> = hitId;<br>    <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">selectedIds</span>.<span class="hljs-title function_">includes</span>(hitId)) {<br>      state.<span class="hljs-title function_">setSelected</span>([hitId]);<br>    }<br><br>    <span class="hljs-comment">// 捕获所有选中元素在拖拽前的初始状态</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">initialDragMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    state.<span class="hljs-property">selectedIds</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> el = state.<span class="hljs-property">elements</span>[id];<br>      <span class="hljs-keyword">if</span> (el) {<br>        <span class="hljs-comment">// 记录 x, y (如果是直线/箭头，可能也需要记录 points)</span><br>        initialDragMap[id] = {<br>          <span class="hljs-attr">x</span>: el.<span class="hljs-property">x</span>,<br>          <span class="hljs-attr">y</span>: el.<span class="hljs-property">y</span>,<br>          <span class="hljs-attr">points</span>: el.<span class="hljs-property">points</span> ? [...el.<span class="hljs-property">points</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> [...p])] : <span class="hljs-literal">undefined</span>,<br>        };<br>      }<br>    });<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">dragInitialStates</span> = initialDragMap;<br><br>    <span class="hljs-comment">// 开始拖拽时锁定撤销/重做管理器</span><br>    undoRedoManager.<span class="hljs-title function_">lock</span>();<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 省略部分代码...</span><br>}<br></code></pre></td></tr></table></figure><p><strong>特殊处理</strong>:</p><ul><li>区分不同的操作类型（拖拽、缩放、旋转）</li><li>记录操作前的初始状态用于撤销/重做</li><li>锁定撤销管理器防止中间状态被记录</li></ul><h4 id="onHandleDown-函数"><a href="#onHandleDown-函数" class="headerlink" title="onHandleDown 函数:"></a>onHandleDown 函数:</h4><p><strong>触发时机</strong>: 用户点击控制手柄时触发</p><p><strong>逻辑闭环</strong>:</p><ol><li>根据手柄类型确定操作类型（缩放或旋转）</li><li>设置相应的操作模式和初始状态</li><li>为后续的 onPointerMove 操作做准备</li></ol><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onHandleDown = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-attr">handle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span> | <span class="hljs-string">'rotate'</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-attr">elementId</span>: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> {<br>  e.<span class="hljs-title function_">stopPropagation</span>();<br><br>  <span class="hljs-comment">// 旋转逻辑分支</span><br>  <span class="hljs-keyword">if</span> (handle === <span class="hljs-string">'rotate'</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">'rotating'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">currentId</span> = elementId;<br><br>    <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>();<br>    <span class="hljs-keyword">const</span> { elements, selectedIds } = state;<br>    <span class="hljs-keyword">const</span> mousePos = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>);<br><br>    <span class="hljs-comment">// 1. 计算旋转中心（选中元素的包围盒中心）</span><br>    <span class="hljs-keyword">const</span> bounds = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getSelectionBounds</span>(selectedIds, elements);<br>    <span class="hljs-keyword">if</span> (!bounds) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">const</span> centerX = bounds.<span class="hljs-property">x</span> + bounds.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">const</span> centerY = bounds.<span class="hljs-property">y</span> + bounds.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">rotationCenter</span> = { <span class="hljs-attr">x</span>: centerX, <span class="hljs-attr">y</span>: centerY };<br><br>    <span class="hljs-comment">// 2. 计算鼠标起始角度（相对于中心点）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startRotationAngle</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">atan2</span>(mousePos.<span class="hljs-property">y</span> - centerY, mousePos.<span class="hljs-property">x</span> - centerX);<br><br>    <span class="hljs-comment">// 3. 记录所有选中元素的初始状态</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">initialMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = {};<br>    selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> el = elements[id];<br>      <span class="hljs-keyword">if</span> (el) {<br>        initialMap[id] = {<br>          <span class="hljs-attr">x</span>: el.<span class="hljs-property">x</span>,<br>          <span class="hljs-attr">y</span>: el.<span class="hljs-property">y</span>,<br>          <span class="hljs-attr">width</span>: el.<span class="hljs-property">width</span>,<br>          <span class="hljs-attr">height</span>: el.<span class="hljs-property">height</span>,<br>          <span class="hljs-attr">rotation</span>: el.<span class="hljs-property">rotation</span> || <span class="hljs-number">0</span>,<br>          <span class="hljs-comment">// 记录元素自身的中心点，方便后续计算</span><br>          <span class="hljs-attr">cx</span>: el.<span class="hljs-property">x</span> + el.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>          <span class="hljs-attr">cy</span>: el.<span class="hljs-property">y</span> + el.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>        };<br>      }<br>    });<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">rotationInitialStates</span> = initialMap;<br><br>    undoRedoManager.<span class="hljs-title function_">lock</span>();<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 缩放逻辑</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">'resizing'</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">activeHandle</span> = handle <span class="hljs-keyword">as</span> <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">currentId</span> = elementId;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startPos</span> = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>);<br><br>  <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>();<br>  <span class="hljs-keyword">const</span> { elements, selectedIds } = state;<br><br>  <span class="hljs-comment">// 捕捉所有选中元素的初始状态</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">initialMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> el = elements[id];<br>    <span class="hljs-keyword">if</span> (el) {<br>      initialMap[id] = {<br>        <span class="hljs-attr">x</span>: el.<span class="hljs-property">x</span>,<br>        <span class="hljs-attr">y</span>: el.<span class="hljs-property">y</span>,<br>        <span class="hljs-attr">width</span>: el.<span class="hljs-property">width</span>,<br>        <span class="hljs-attr">height</span>: el.<span class="hljs-property">height</span>,<br>        <span class="hljs-attr">type</span>: el.<span class="hljs-property">type</span>,<br>        <span class="hljs-attr">points</span>: el.<span class="hljs-property">points</span> ? el.<span class="hljs-property">points</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> [...p]) : <span class="hljs-literal">undefined</span>,<br>      };<br>    }<br>  });<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">resizeInitialStates</span> = initialMap;<br><br>  <span class="hljs-comment">// 计算初始的群组包围盒</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">initialGroupBounds</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getSelectionBounds</span>(selectedIds, elements);<br><br>  <span class="hljs-comment">// 保存初始元素映射用于调整大小计算</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">initialElementsMap</span> = initialMap;<br><br>  <span class="hljs-comment">// 开始调整大小时锁定撤销/重做管理器</span><br>  undoRedoManager.<span class="hljs-title function_">lock</span>();<br>}<br></code></pre></td></tr></table></figure><p><strong>特殊处理</strong>:</p><ul><li>特殊处理旋转操作，计算旋转中心和起始角度</li><li>记录所有选中元素的完整初始状态</li><li>为多元素操作计算群组边界</li></ul><h4 id="onPointerMove-函数"><a href="#onPointerMove-函数" class="headerlink" title="onPointerMove 函数:"></a>onPointerMove 函数:</h4><p><strong>触发时机</strong>: 用户在按住鼠标移动时触发</p><p><strong>逻辑闭环</strong>:</p><ol><li>根据当前操作模式执行相应的操作逻辑</li><li>持续更新元素属性</li><li>触发重新渲染</li></ol><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerMove = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 省略部分代码...</span><br><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> === <span class="hljs-string">'dragging'</span>) {<br>    <span class="hljs-keyword">const</span> dx = currentPos.<span class="hljs-property">x</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startPos</span>.<span class="hljs-property">x</span>;<br>    <span class="hljs-keyword">const</span> dy = currentPos.<span class="hljs-property">y</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startPos</span>.<span class="hljs-property">y</span>;<br><br>    <span class="hljs-keyword">if</span> (state.<span class="hljs-property">selectedIds</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>      state.<span class="hljs-property">selectedIds</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {<br>        <span class="hljs-keyword">const</span> el = state.<span class="hljs-property">elements</span>[id];<br>        state.<span class="hljs-title function_">updateElement</span>(id, { <span class="hljs-attr">x</span>: el.<span class="hljs-property">x</span> + dx, <span class="hljs-attr">y</span>: el.<span class="hljs-property">y</span> + dy });<br>      });<br>      <span class="hljs-comment">// 重置起点，使 dx/dy 成为增量</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startPos</span> = { <span class="hljs-attr">x</span>: currentPos.<span class="hljs-property">x</span>, <span class="hljs-attr">y</span>: currentPos.<span class="hljs-property">y</span> };<br>    }<br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> === <span class="hljs-string">'resizing'</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">initialElementsMap</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">initialGroupBounds</span>) {<br>    <span class="hljs-comment">// 修复后的 Resize 逻辑</span><br>    <span class="hljs-keyword">const</span> selectedIds = state.<span class="hljs-property">selectedIds</span>;<br>    <span class="hljs-keyword">const</span> initBounds = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">initialGroupBounds</span>;<br>    <span class="hljs-keyword">const</span> handle = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">activeHandle</span>;<br><br>    <span class="hljs-comment">// 处理单个线段/箭头的端点拖拽 (特例)</span><br>    <span class="hljs-keyword">const</span> singleId = selectedIds[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> singleEl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">initialElementsMap</span>[singleId];<br>    <span class="hljs-keyword">if</span> (<br>      selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> &amp;&amp;<br>      singleEl &amp;&amp;<br>      (singleEl.<span class="hljs-property">type</span> === <span class="hljs-string">'line'</span> || singleEl.<span class="hljs-property">type</span> === <span class="hljs-string">'arrow'</span>) &amp;&amp;<br>      (handle === <span class="hljs-string">'p0'</span> || handle === <span class="hljs-string">'p1'</span>)<br>    ) {<br>      <span class="hljs-comment">// 省略具体实现...</span><br>    }<br><br>    <span class="hljs-comment">// 通用群组缩放逻辑</span><br>    <span class="hljs-comment">// 计算鼠标相对于点击时的位移</span><br>    <span class="hljs-keyword">const</span> totalDx = currentPos.<span class="hljs-property">x</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startPos</span>.<span class="hljs-property">x</span>;<br>    <span class="hljs-keyword">const</span> totalDy = currentPos.<span class="hljs-property">y</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startPos</span>.<span class="hljs-property">y</span>;<br><br>    <span class="hljs-comment">// 基于初始包围盒计算新的包围盒</span><br>    <span class="hljs-keyword">let</span> finalL = initBounds.<span class="hljs-property">x</span>;<br>    <span class="hljs-keyword">let</span> finalR = initBounds.<span class="hljs-property">x</span> + initBounds.<span class="hljs-property">width</span>;<br>    <span class="hljs-keyword">let</span> finalT = initBounds.<span class="hljs-property">y</span>;<br>    <span class="hljs-keyword">let</span> finalB = initBounds.<span class="hljs-property">y</span> + initBounds.<span class="hljs-property">height</span>;<br><br>    <span class="hljs-comment">// 根据手柄方向应用位移</span><br>    <span class="hljs-keyword">if</span> (handle?.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'l'</span>)) finalL += totalDx;<br>    <span class="hljs-keyword">if</span> (handle?.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'r'</span>)) finalR += totalDx;<br>    <span class="hljs-keyword">if</span> (handle?.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'t'</span>)) finalT += totalDy;<br>    <span class="hljs-keyword">if</span> (handle?.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'b'</span>)) finalB += totalDy;<br><br>    <span class="hljs-comment">// 处理翻转（如果拉过了头）</span><br>    <span class="hljs-keyword">if</span> (finalR &lt; finalL) {<br>      [finalL, finalR] = [finalR, finalL];<br>    }<br>    <span class="hljs-keyword">if</span> (finalB &lt; finalT) {<br>      [finalT, finalB] = [finalB, finalT];<br>    }<br><br>    <span class="hljs-keyword">const</span> newBoundsW = finalR - finalL;<br>    <span class="hljs-keyword">const</span> newBoundsH = finalB - finalT;<br><br>    <span class="hljs-comment">// 计算缩放比例</span><br>    <span class="hljs-keyword">const</span> scaleX = initBounds.<span class="hljs-property">width</span> === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : newBoundsW / initBounds.<span class="hljs-property">width</span>;<br>    <span class="hljs-keyword">const</span> scaleY = initBounds.<span class="hljs-property">height</span> === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : newBoundsH / initBounds.<span class="hljs-property">height</span>;<br><br>    <span class="hljs-comment">// 应用到所有选中的元素</span><br>    selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> initEl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">initialElementsMap</span>![id];<br>      <span class="hljs-keyword">if</span> (!initEl) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 计算新位置：新原点 + (相对位移 * 缩放)</span><br>      <span class="hljs-keyword">const</span> relX = initEl.<span class="hljs-property">x</span>! - initBounds.<span class="hljs-property">x</span>;<br>      <span class="hljs-keyword">const</span> relY = initEl.<span class="hljs-property">y</span>! - initBounds.<span class="hljs-property">y</span>;<br><br>      <span class="hljs-keyword">const</span> finalElX = finalL + relX * scaleX;<br>      <span class="hljs-keyword">const</span> finalElY = finalT + relY * scaleY;<br>      <span class="hljs-keyword">const</span> finalElW = initEl.<span class="hljs-property">width</span>! * scaleX;<br>      <span class="hljs-keyword">const</span> finalElH = initEl.<span class="hljs-property">height</span>! * scaleY;<br><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">updatePayload</span>: <span class="hljs-built_in">any</span> = {<br>        <span class="hljs-attr">x</span>: finalElX,<br>        <span class="hljs-attr">y</span>: finalElY,<br>        <span class="hljs-attr">width</span>: finalElW,<br>        <span class="hljs-attr">height</span>: finalElH,<br>      };<br><br>      <span class="hljs-comment">// 如果有内部点集，也需要缩放</span><br>      <span class="hljs-keyword">if</span> (initEl.<span class="hljs-property">points</span>) {<br>        updatePayload.<span class="hljs-property">points</span> = initEl.<span class="hljs-property">points</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> [p[<span class="hljs-number">0</span>] * scaleX, p[<span class="hljs-number">1</span>] * scaleY]);<br>      }<br><br>      state.<span class="hljs-title function_">updateElement</span>(id, updatePayload);<br>    });<br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> === <span class="hljs-string">'rotating'</span> &amp;&amp;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">rotationInitialStates</span> &amp;&amp;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">rotationCenter</span> &amp;&amp;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startRotationAngle</span> !== <span class="hljs-literal">null</span><br>  ) {<br>    <span class="hljs-comment">// 旋转逻辑</span><br>    <span class="hljs-keyword">const</span> { <span class="hljs-attr">x</span>: cx, <span class="hljs-attr">y</span>: cy } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">rotationCenter</span>;<br><br>    <span class="hljs-comment">// 1. 计算当前鼠标角度</span><br>    <span class="hljs-keyword">const</span> currentAngle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">atan2</span>(currentPos.<span class="hljs-property">y</span> - cy, currentPos.<span class="hljs-property">x</span> - cx);<br><br>    <span class="hljs-comment">// 2. 计算旋转增量（当前角度 - 起始角度）</span><br>    <span class="hljs-keyword">const</span> deltaAngle = currentAngle - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">startRotationAngle</span>;<br><br>    <span class="hljs-comment">// 3. 更新每一个选中元素</span><br>    state.<span class="hljs-property">selectedIds</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> initEl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">rotationInitialStates</span>![id];<br>      <span class="hljs-keyword">if</span> (!initEl) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// A. 计算新的自转角度</span><br>      <span class="hljs-keyword">const</span> newRotation = initEl.<span class="hljs-property">rotation</span> + deltaAngle;<br><br>      <span class="hljs-comment">// B. 计算新的位置 (公转)</span><br>      <span class="hljs-comment">// 将元素的中心点 (initEl.cx, initEl.cy) 绕着 组中心 (cx, cy) 旋转 deltaAngle</span><br>      <span class="hljs-keyword">const</span> newCenter = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotatePoint</span>(initEl.<span class="hljs-property">cx</span>, initEl.<span class="hljs-property">cy</span>, cx, cy, deltaAngle);<br><br>      <span class="hljs-comment">// C. 根据新的中心点反推 x, y (x = center.x - width/2)</span><br>      <span class="hljs-keyword">const</span> newX = newCenter.<span class="hljs-property">x</span> - initEl.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">const</span> newY = newCenter.<span class="hljs-property">y</span> - initEl.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;<br><br>      <span class="hljs-comment">// D. 更新 Store</span><br>      state.<span class="hljs-title function_">updateElement</span>(id, {<br>        <span class="hljs-attr">x</span>: newX,<br>        <span class="hljs-attr">y</span>: newY,<br>        <span class="hljs-attr">rotation</span>: newRotation,<br>      });<br>    });<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 省略部分代码...</span><br>}<br></code></pre></td></tr></table></figure><p>分别处理拖拽、缩放和旋转操作,特殊处理线段元素的端点操作,处理多元素群组操作时的相对位置保持,实现旋转时元素公转和自转的计算</p><h2 id="5-元素打组机制实现"><a href="#5-元素打组机制实现" class="headerlink" title="5. 元素打组机制实现"></a>5. 元素打组机制实现</h2><h3 id="5-1-当前实现状态"><a href="#5-1-当前实现状态" class="headerlink" title="5.1 当前实现状态"></a>5.1 当前实现状态</h3><p>目前项目中已经实现了多元素选择和同时操作的功能，但尚未实现完整的元素打组机制。</p><h3 id="5-2-现有相关实现"><a href="#5-2-现有相关实现" class="headerlink" title="5.2 现有相关实现"></a>5.2 现有相关实现</h3><ol><li><p><strong>多元素选择</strong>:</p><ul><li>支持框选多个元素</li><li>支持同时对多个元素进行移动、缩放、旋转操作</li></ul></li><li><p><strong>群组操作处理</strong>:</p><ul><li>在缩放操作中计算所有选中元素的包围盒</li><li>保持元素间的相对位置关系</li><li>同时更新所有选中元素的属性</li></ul></li><li><p><strong>旋转操作中的群组处理</strong>:</p><ul><li>计算群组的中心点作为旋转中心</li><li>每个元素围绕群组中心进行公转</li><li>保持各自的自转角度</li></ul></li></ol><h3 id="5-3-群组操作核心逻辑"><a href="#5-3-群组操作核心逻辑" class="headerlink" title="5.3 群组操作核心逻辑"></a>5.3 群组操作核心逻辑</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 计算选中元素的整体包围盒</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">getSelectionBounds</span>(<span class="hljs-params"><span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[], <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;</span>) {<br>  <span class="hljs-keyword">let</span> minX = <span class="hljs-title class_">Infinity</span>,<br>    minY = <span class="hljs-title class_">Infinity</span>,<br>    maxX = -<span class="hljs-title class_">Infinity</span>,<br>    maxY = -<span class="hljs-title class_">Infinity</span>;<br><br>  <span class="hljs-keyword">let</span> hasValid = <span class="hljs-literal">false</span>;<br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> el = elements[id];<br>    <span class="hljs-keyword">if</span> (!el) <span class="hljs-keyword">return</span>;<br>    hasValid = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 使用数据模型中的宽高计算</span><br>    minX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(minX, el.<span class="hljs-property">x</span>);<br>    minY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(minY, el.<span class="hljs-property">y</span>);<br>    maxX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxX, el.<span class="hljs-property">x</span> + el.<span class="hljs-property">width</span>);<br>    maxY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxY, el.<span class="hljs-property">y</span> + el.<span class="hljs-property">height</span>);<br>  });<br><br>  <span class="hljs-keyword">if</span> (!hasValid) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: minX, <span class="hljs-attr">y</span>: minY, <span class="hljs-attr">width</span>: maxX - minX, <span class="hljs-attr">height</span>: maxY - minY };<br>}<br></code></pre></td></tr></table></figure><h3 id="5-4-待实现功能"><a href="#5-4-待实现功能" class="headerlink" title="5.4 待实现功能"></a>5.4 待实现功能</h3><p>要实现完整的元素打组机制，还需要添加以下功能：</p><ol><li><p><strong>创建组</strong>:</p><ul><li>将选中的多个元素组合成一个组对象</li><li>组对象拥有自己的位置、尺寸和变换属性</li></ul></li><li><p><strong>解散组</strong>:</p><ul><li>将组拆分为原来的独立元素</li><li>保持元素在解散时的位置和属性</li></ul></li><li><p><strong>嵌套组</strong>:</p><ul><li>支持组内包含其他组</li><li>实现层级化的变换传递</li></ul></li><li><p><strong>组专用操作</strong>:</p><ul><li>双击进入组编辑模式</li><li>组的专用控制手柄和操作逻辑</li></ul></li></ol><h3 id="5-5-后续实现方案"><a href="#5-5-后续实现方案" class="headerlink" title="5.5 后续实现方案"></a>5.5 后续实现方案</h3><ol><li><p><strong>数据结构扩展</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasGroup</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'group'</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">children</span>: (<span class="hljs-title class_">CanvasElement</span> | <span class="hljs-title class_">CanvasGroup</span>)[] <span class="hljs-comment">// 组内元素</span><br>}<br></code></pre></td></tr></table></figure></li></ol><p>组操作时，将组视为单个元素处理，组内元素的变换需要相对于组坐标系计算，支持组的嵌套和递归操作</p><p>组作为一个整体进行渲染优化，支持组的缓存渲染</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;元素操作机制和元素打组机制实现文档&quot;&gt;&lt;a href=&quot;#元素操作机制和元素打组机制实现文档&quot; class=&quot;headerlink&quot; title=&quot;元素操作机制和元素打组机制实现文档&quot;&gt;&lt;/a&gt;元素操作机制和元素打组机制实现文档&lt;/h1&gt;&lt;h2 id=&quot;1-DES</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-视口管理机制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/12487.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/12487.html</id>
    <published>2025-11-23T13:45:00.000Z</published>
    <updated>2025-11-23T16:02:36.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>视口管理机制是画布应用中实现无限画布、缩放、拖拽等交互功能的核心模块。它基于 pixi-viewport 库实现，提供了完整的视口控制功能，包括平移、缩放、手势控制等。实现了管理画布视口、处理用户交互、实现无限画布功能</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── pages/<br>    └── canvas/<br>        └── Pixi_STM_modules/<br>            └── core/<br>                └── StageManagerCore.ts    <span class="hljs-comment"># 视口管理核心实现</span><br></code></pre></td></tr></table></figure><ul><li><code>pixi-viewport</code>：视口管理库，提供平移、缩放、手势等交互功能</li><li><code>PixiJS</code>：WebGL 渲染引擎，作为视口的渲染基础</li><li><code>TypeScript</code>：提供类型安全和代码可维护性</li></ul></li></ul><h3 id="2-视口管理机制类型定义"><a href="#2-视口管理机制类型定义" class="headerlink" title="2. 视口管理机制类型定义"></a>2. 视口管理机制类型定义</h3><h4 id="2-1-Viewport-相关配置"><a href="#2-1-Viewport-相关配置" class="headerlink" title="2.1 Viewport 相关配置"></a>2.1 Viewport 相关配置</h4><p>pixi-viewport 库的主要配置参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ViewportOptions</span> {<br>  <span class="hljs-attr">screenWidth</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 视口宽度</span><br>  <span class="hljs-attr">screenHeight</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 视口高度</span><br>  <span class="hljs-attr">worldWidth</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 世界宽度</span><br>  <span class="hljs-attr">worldHeight</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 世界高度</span><br>  <span class="hljs-attr">events</span>: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// 事件系统</span><br>}<br></code></pre></td></tr></table></figure><h4 id="2-2-视口交互配置"><a href="#2-2-视口交互配置" class="headerlink" title="2.2 视口交互配置"></a>2.2 视口交互配置</h4><p>pixi-viewport 支持的交互配置：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>drag()</td><td>启用拖拽功能</td></tr><tr><td>pinch()</td><td>启用捏合缩放功能</td></tr><tr><td>wheel()</td><td>启用滚轮缩放功能</td></tr><tr><td>clampZoom()</td><td>限制缩放范围</td></tr><tr><td>decelerate()</td><td>启用惯性滚动</td></tr></tbody></table></div><h3 id="3-视口管理机制架构"><a href="#3-视口管理机制架构" class="headerlink" title="3. 视口管理机制架构"></a>3. 视口管理机制架构</h3><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>视口管理机制维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>viewport</td><td>Viewport</td><td>pixi-viewport 实例</td></tr><tr><td>app</td><td>PIXI.Application</td><td>PixiJS 应用实例</td></tr><tr><td>elementLayer</td><td>PIXI.Container</td><td>元素图层容器</td></tr><tr><td>uiLayer</td><td>PIXI.Container</td><td>UI 图层容器</td></tr></tbody></table></div><h4 id="3-2-外部依赖-External-Dependencies"><a href="#3-2-外部依赖-External-Dependencies" class="headerlink" title="3.2 外部依赖 (External Dependencies)"></a>3.2 外部依赖 (External Dependencies)</h4><p>视口管理机制依赖以下外部组件：</p><div class="table-container"><table><thead><tr><th>组件</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>HTML Container</td><td>HTMLElement</td><td>用于挂载 PixiJS 画布的 DOM 元素</td></tr><tr><td>ElementRenderer</td><td>ElementRenderer</td><td>元素渲染器</td></tr><tr><td>TransformerRenderer</td><td>TransformerRenderer</td><td>变换控制器渲染器</td></tr></tbody></table></div><h4 id="3-3-视口管理流程"><a href="#3-3-视口管理流程" class="headerlink" title="3.3 视口管理流程"></a>3.3 视口管理流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[初始化 StageManager] --&gt; B{创建 PIXI.Application}<br>    B --&gt; C[初始化视口]<br>    C --&gt; D[配置视口交互]<br>    D --&gt; E[添加图层]<br>    E --&gt; F[挂载到 DOM]<br>    F --&gt; G[处理用户交互]<br>    G --&gt; H[更新视口状态]<br>    H --&gt; I[重新渲染元素]<br>    <br>    style A fill:#e1f5fe<br>    style C fill:#f3e5f5<br>    style D fill:#fff3e0<br>    style G fill:#e8f5e8<br></code></pre></td></tr></table></figure><h3 id="4-视口初始化与配置"><a href="#4-视口初始化与配置" class="headerlink" title="4. 视口初始化与配置"></a>4. 视口初始化与配置</h3><h4 id="4-1-视口初始化流程"><a href="#4-1-视口初始化流程" class="headerlink" title="4.1 视口初始化流程"></a>4.1 视口初始化流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant SM as StageManager<br>    participant PA as PixiJS Application<br>    participant PV as pixi-viewport<br>    participant DOM as HTML Container<br>    <br>    SM-&gt;&gt;PA: 创建 PIXI.Application<br>    PA-&gt;&gt;SM: 返回应用实例<br>    SM-&gt;&gt;PV: 创建 Viewport 实例<br>    PV-&gt;&gt;SM: 返回视口实例<br>    SM-&gt;&gt;PV: 配置视口交互<br>    SM-&gt;&gt;PA: 添加视口到舞台<br>    SM-&gt;&gt;DOM: 挂载画布到 DOM<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><p><strong>setupViewport 函数</strong>：在 StageManager 初始化时调用，创建并配置 pixi-viewport 实例，设置交互功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">setupViewport</span>(<span class="hljs-params"><span class="hljs-attr">container</span>: <span class="hljs-title class_">HTMLElement</span></span>) {<br>  <span class="hljs-comment">// 创建视口实例</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Viewport</span>({<br>    <span class="hljs-attr">screenWidth</span>: container.<span class="hljs-property">clientWidth</span>,<br>    <span class="hljs-attr">screenHeight</span>: container.<span class="hljs-property">clientHeight</span>,<br>    <span class="hljs-attr">worldWidth</span>: <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">worldHeight</span>: <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">events</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-property">renderer</span>.<span class="hljs-property">events</span>,<br>  })<br><br>  <span class="hljs-comment">// 添加视口到 Pixi 舞台</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-property">stage</span>.<span class="hljs-title function_">addChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>)<br><br>  <span class="hljs-comment">// 配置视口交互功能</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span><br>    .<span class="hljs-title function_">drag</span>({ <span class="hljs-attr">mouseButtons</span>: <span class="hljs-string">'middle'</span> })  <span class="hljs-comment">// 鼠标中键拖拽</span><br>    .<span class="hljs-title function_">pinch</span>()                           <span class="hljs-comment">// 触摸捏合缩放</span><br>    .<span class="hljs-title function_">wheel</span>()                           <span class="hljs-comment">// 滚轮缩放</span><br>}<br></code></pre></td></tr></table></figure><h3 id="5-视口交互功能"><a href="#5-视口交互功能" class="headerlink" title="5. 视口交互功能"></a>5. 视口交互功能</h3><h4 id="5-1-拖拽功能"><a href="#5-1-拖拽功能" class="headerlink" title="5.1 拖拽功能"></a>5.1 拖拽功能</h4><p>用户可以通过鼠标中键拖拽画布，实现视口平移：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 鼠标中键拖拽</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">drag</span>({ <span class="hljs-attr">mouseButtons</span>: <span class="hljs-string">"middle"</span> });<br><br><span class="hljs-comment">// 空格键+左键拖拽（手型工具）</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">drag</span>({ <span class="hljs-attr">mouseButtons</span>: <span class="hljs-string">"all"</span> });<br></code></pre></td></tr></table></figure><h4 id="5-2-缩放功能"><a href="#5-2-缩放功能" class="headerlink" title="5.2 缩放功能"></a>5.2 缩放功能</h4><p>支持多种缩放方式：</p><ol><li><p><strong>滚轮缩放</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">wheel</span>(); <span class="hljs-comment">// 鼠标滚轮缩放</span><br></code></pre></td></tr></table></figure></li><li><p><strong>手势缩放</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">pinch</span>(); <span class="hljs-comment">// 触摸设备捏合缩放</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="5-3-视口状态更新"><a href="#5-3-视口状态更新" class="headerlink" title="5.3 视口状态更新"></a>5.3 视口状态更新</h4><p>根据当前工具和用户操作更新视口状态：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-title function_">updateViewportState</span>(<span class="hljs-params"><span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span></span>) {<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">const</span> isHandMode = tool === <span class="hljs-string">'hand'</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isSpacePressed</span><br>  <span class="hljs-keyword">if</span> (isHandMode) {<br>    <span class="hljs-comment">// 手型工具或按下空格键时，启用全键拖拽</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">drag</span>({ <span class="hljs-attr">mouseButtons</span>: <span class="hljs-string">'all'</span> })<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">'grab'</span><br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 默认情况下，仅启用中键拖拽</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">drag</span>({ <span class="hljs-attr">mouseButtons</span>: <span class="hljs-string">'middle'</span> })<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">'default'</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="6-UI-与样式实现"><a href="#6-UI-与样式实现" class="headerlink" title="6. UI 与样式实现"></a>6. UI 与样式实现</h3><h4 id="6-1-视口层次结构"><a href="#6-1-视口层次结构" class="headerlink" title="6.1 视口层次结构"></a>6.1 视口层次结构</h4><p>视口内部采用分层结构管理不同类型的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Viewport] --&gt; B[elementLayer]<br>    A --&gt; C[uiLayer]<br>    B --&gt; D[图形元素]<br>    B --&gt; E[文本元素]<br>    B --&gt; F[图像元素]<br>    C --&gt; G[选区框]<br>    C --&gt; H[橡皮擦指示器]<br>    C --&gt; I[变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#e8f5e8<br>    style D fill:#fff3e0<br>    style E fill:#fff3e0<br>    style F fill:#fff3e0<br>    style G fill:#ffebee<br>    style H fill:#ffebee<br>    style I fill:#ffebee<br></code></pre></td></tr></table></figure><h4 id="6-2-光标样式管理"><a href="#6-2-光标样式管理" class="headerlink" title="6.2 光标样式管理"></a>6.2 光标样式管理</h4><p>根据不同状态和工具显示不同的光标样式：</p><div class="table-container"><table><thead><tr><th>状态/工具</th><th>光标样式</th></tr></thead><tbody><tr><td>默认状态</td><td>default</td></tr><tr><td>手型工具</td><td>grab</td></tr><tr><td>拖拽中</td><td>grabbing</td></tr><tr><td>选择工具</td><td>default</td></tr><tr><td>绘制工具</td><td>crosshair</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="PixiJS" scheme="https://zhongye1.github.io/Arknight-notes/tags/PixiJS/"/>
    
    <category term="视口管理" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E8%A7%86%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-富文本文本元素处理机制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/61908.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/61908.html</id>
    <published>2025-11-23T13:15:00.000Z</published>
    <updated>2025-11-23T16:02:57.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>富文本文本元素处理机制是画布应用中实现文本元素创建、编辑和渲染的核心功能模块。它结合了 WangEditor 5 富文本编辑器和 PixiJS 的 HTMLText 组件，实现了所见即所得的文本编辑体验。用户可以通过工具栏创建文本元素，在画布上直接选中编辑，或通过底部的富文本编辑器进行详细编辑。</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>├── components/<br>│   ├── Richtext_editor/<br>│   │   ├── Richtext_editor.tsx      <span class="hljs-comment"># 富文本编辑器组件</span><br>│   │   └── BottomTextEditor.tsx     <span class="hljs-comment"># 底部文本编辑器</span><br>└── pages/<br>    └── canvas/<br>        └── Pixi_STM_modules/<br>            └── rendering/<br>                └── ElementRenderer.ts   <span class="hljs-comment"># 文本元素渲染器</span><br></code></pre></td></tr></table></figure><ul><li><code>WangEditor 5</code>：富文本编辑器，提供文本编辑功能</li><li><code>PIXI.HTMLText</code>：PixiJS 组件，用于在画布上渲染 HTML 文本</li><li><code>Zustand</code>：状态管理，存储文本元素数据</li></ul></li></ul><h3 id="2-文本处理机制类型定义"><a href="#2-文本处理机制类型定义" class="headerlink" title="2. 文本处理机制类型定义"></a>2. 文本处理机制类型定义</h3><h4 id="2-1-CanvasElement-文本相关属性"><a href="#2-1-CanvasElement-文本相关属性" class="headerlink" title="2.1 CanvasElement 文本相关属性"></a>2.1 CanvasElement 文本相关属性</h4><p>CanvasElement 接口中与文本相关的属性定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-comment">// ... 其他通用属性</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>; <span class="hljs-comment">// 元素类型为文本</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 存储 HTML 字符串</span><br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 字体大小</span><br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 字体族</span><br>  <span class="hljs-attr">textAlign</span>?: <span class="hljs-string">"left"</span> | <span class="hljs-string">"center"</span> | <span class="hljs-string">"right"</span>; <span class="hljs-comment">// 文本对齐方式</span><br>}<br></code></pre></td></tr></table></figure><h4 id="2-2-富文本编辑器组件-Props"><a href="#2-2-富文本编辑器组件-Props" class="headerlink" title="2.2 富文本编辑器组件 Props"></a>2.2 富文本编辑器组件 Props</h4><p>富文本编辑器组件的属性定义：</p><div class="table-container"><table><thead><tr><th>属性名</th><th>类型</th><th>必填</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>string</td><td>是</td><td>当前文本内容（HTML 格式）</td></tr><tr><td>onChange</td><td>(value: string) =&gt; void</td><td>是</td><td>文本内容变化回调</td></tr><tr><td>className</td><td>string</td><td>否</td><td>自定义 CSS 类名</td></tr></tbody></table></div><h3 id="3-文本处理机制架构"><a href="#3-文本处理机制架构" class="headerlink" title="3. 文本处理机制架构"></a>3. 文本处理机制架构</h3><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>文本处理机制涉及多个组件的内部状态：</p><div class="table-container"><table><thead><tr><th>组件</th><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>BottomTextEditor</td><td>localHtml</td><td>string</td><td>本地中间状态，用于解决输入法冲突</td></tr><tr><td>ElementRenderer</td><td>spriteMap</td><td>Map<string, PIXI.DisplayObject=""></string,></td><td>元素 ID 到显示对象的映射</td></tr><tr><td>RichTextEditor</td><td>editor</td><td>IDomEditor</td><td>WangEditor 编辑器实例</td></tr></tbody></table></div><h4 id="3-2-外部依赖-External-Dependencies"><a href="#3-2-外部依赖-External-Dependencies" class="headerlink" title="3.2 外部依赖 (External Dependencies)"></a>3.2 外部依赖 (External Dependencies)</h4><p>文本处理机制依赖以下外部组件：</p><div class="table-container"><table><thead><tr><th>组件</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Zustand Store</td><td>CanvasState</td><td>存储文本元素数据</td></tr><tr><td>PixiJS</td><td>HTMLText</td><td>渲染文本元素</td></tr><tr><td>WangEditor</td><td>Editor, Toolbar</td><td>提供富文本编辑功能</td></tr></tbody></table></div><h4 id="3-3-文本处理流程"><a href="#3-3-文本处理流程" class="headerlink" title="3.3 文本处理流程"></a>3.3 文本处理流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[创建文本元素] --&gt; B{ElementRenderer}<br>    B --&gt; C[创建HTMLText对象]<br>    C --&gt; D[渲染到画布]<br>    D --&gt; E[用户选中文本元素]<br>    E --&gt; F{编辑方式}<br>    F --&gt;|直接编辑| G[画布上直接编辑]<br>    F --&gt;|底部编辑器| H[BottomTextEditor显示]<br>    H --&gt; I[WangEditor编辑器]<br>    I --&gt; J[文本内容更新]<br>    J --&gt; K[Zustand Store更新]<br>    K --&gt; B<br>    <br>    style A fill:#e1f5fe<br>    style D fill:#e8f5e8<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style K fill:#f3e5f5<br></code></pre></td></tr></table></figure><h3 id="4-文本元素处理流程"><a href="#4-文本元素处理流程" class="headerlink" title="4. 文本元素处理流程"></a>4. 文本元素处理流程</h3><h4 id="4-1-文本元素创建"><a href="#4-1-文本元素创建" class="headerlink" title="4.1 文本元素创建"></a>4.1 文本元素创建</h4><p>用户可以通过工具栏创建文本元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant TB as TopToolbar<br>    participant SM as StageManager<br>    participant ZS as Zustand Store<br>    participant ER as ElementRenderer<br>    <br>    U-&gt;&gt;TB: 点击文本工具<br>    TB-&gt;&gt;TB: 设置工具为text<br>    U-&gt;&gt;SM: 在画布上点击<br>    SM-&gt;&gt;ZS: 添加文本元素<br>    ZS-&gt;&gt;ER: 触发重新渲染<br>    ER-&gt;&gt;ER: 创建HTMLText对象<br>    ER-&gt;&gt;ER: 设置文本样式<br>    ER-&gt;&gt;ER: 添加到画布<br></code></pre></td></tr></table></figure><h4 id="4-2-文本元素渲染"><a href="#4-2-文本元素渲染" class="headerlink" title="4.2 文本元素渲染"></a>4.2 文本元素渲染</h4><p>ElementRenderer 负责将文本元素数据渲染为可视化的 HTMLText 对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 处理 Text 类型 (HTMLText)</span><br><span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">"text"</span>) {<br>  <span class="hljs-comment">// 创建或更新 HTMLText 对象</span><br>  <span class="hljs-keyword">if</span> (!graphic) {<br>    graphic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLText</span>({<br>      <span class="hljs-attr">text</span>: <span class="hljs-string">""</span>,<br>      <span class="hljs-attr">style</span>: {<br>        <span class="hljs-attr">wordWrap</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">breakWords</span>: <span class="hljs-literal">true</span>,<br>      },<br>    });<br>    <span class="hljs-comment">// 设置标签和事件模式</span><br>    graphic.<span class="hljs-property">label</span> = id;<br>    graphic.<span class="hljs-property">eventMode</span> = <span class="hljs-string">"static"</span>;<br>    graphic.<span class="hljs-property">cursor</span> = <span class="hljs-string">"move"</span>;<br>    elementLayer.<span class="hljs-title function_">addChild</span>(graphic);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">set</span>(id, graphic);<br>  }<br><br>  <span class="hljs-keyword">const</span> textObj = graphic <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLText</span>;<br><br>  <span class="hljs-comment">// 设置文本内容</span><br>  <span class="hljs-keyword">const</span> htmlContent =<br>    data.<span class="hljs-property">text</span> || <span class="hljs-string">'&lt;span style="color:#cccccc"&gt;请输入文本&lt;/span&gt;'</span>;<br>  <span class="hljs-keyword">if</span> (textObj.<span class="hljs-property">text</span> !== htmlContent) {<br>    textObj.<span class="hljs-property">text</span> = htmlContent;<br>  }<br><br>  <span class="hljs-comment">// 设置样式</span><br>  textObj.<span class="hljs-property">style</span> = {<br>    <span class="hljs-attr">wordWrap</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">wordWrapWidth</span>: data.<span class="hljs-property">width</span> || <span class="hljs-number">400</span>,<br>    <span class="hljs-attr">fontSize</span>: data.<span class="hljs-property">fontSize</span> || <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">fontFamily</span>: data.<span class="hljs-property">fontFamily</span> || <span class="hljs-string">"Arial"</span>,<br>    <span class="hljs-attr">fill</span>: data.<span class="hljs-property">fill</span> || <span class="hljs-string">"#000000"</span>,<br>    <span class="hljs-attr">align</span>: data.<span class="hljs-property">textAlign</span> || <span class="hljs-string">"left"</span>,<br>    <span class="hljs-attr">cssOverrides</span>: [<span class="hljs-string">"p { margin: 0; padding: 0; }"</span>, <span class="hljs-string">"span { display: inline; }"</span>],<br>  };<br><br>  textObj.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">x</span>, data.<span class="hljs-property">y</span>);<br>}<br></code></pre></td></tr></table></figure><h4 id="4-3-文本编辑处理"><a href="#4-3-文本编辑处理" class="headerlink" title="4.3 文本编辑处理"></a>4.3 文本编辑处理</h4><p class='item-img' data-src='https://github.com/Zhongye1/BDdraw_DEV/blob/main/assets/image-20251122221138270.png?raw=true'><img src="https://github.com/Zhongye1/BDdraw_DEV/blob/main/assets/image-20251122221138270.png?raw=true" alt="alt text"></p><p>当用户选中文本元素时，底部自动显示富文本编辑器，使用编辑功能时编辑内容实时同步到 Zustand Store<br>用户可以直接在画布上选中文本元素进行位置调整，也可以用变换控制器调整文本元素的尺寸和位置</p><h3 id="5-核心组件解析"><a href="#5-核心组件解析" class="headerlink" title="5. 核心组件解析"></a>5. 核心组件解析</h3><h4 id="5-1-ElementRenderer-文本渲染"><a href="#5-1-ElementRenderer-文本渲染" class="headerlink" title="5.1 ElementRenderer 文本渲染"></a>5.1 ElementRenderer 文本渲染</h4><p>ElementRenderer 负责将文本元素数据渲染为可视化的 HTMLText 对象：</p><p>当画布元素数据发生变更时触发，检查是否存在对应的 HTMLText 对象，如不存在则创建，否则更新其内容和样式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 处理 Text 类型元素</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">'text'</span>) {<br>  <span class="hljs-comment">// 如果之前的 sprite 不是 HTMLText，销毁重建</span><br>  <span class="hljs-keyword">if</span> (graphic &amp;&amp; !(graphic <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLText</span>)) {<br>    elementLayer.<span class="hljs-title function_">removeChild</span>(graphic)<br>    graphic.<span class="hljs-title function_">destroy</span>({ <span class="hljs-attr">children</span>: <span class="hljs-literal">true</span> })<br>    graphic = <span class="hljs-literal">undefined</span><br>  }<br>  <br>  <span class="hljs-keyword">if</span> (!graphic) {<br>    <span class="hljs-comment">// 创建 HTMLText</span><br>    graphic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLText</span>({<br>      <span class="hljs-attr">text</span>: <span class="hljs-string">''</span>,<br>      <span class="hljs-attr">style</span>: {<br>        <span class="hljs-attr">wordWrap</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">breakWords</span>: <span class="hljs-literal">true</span>,<br>      },<br>    })<br>    <span class="hljs-comment">// ... 设置属性</span><br>  }<br><br>  <span class="hljs-keyword">const</span> textObj = graphic <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLText</span><br>  <span class="hljs-comment">// 更新文本内容和样式</span><br>}<br></code></pre></td></tr></table></figure><h4 id="5-2-BottomTextEditor-底部编辑器"><a href="#5-2-BottomTextEditor-底部编辑器" class="headerlink" title="5.2 BottomTextEditor 底部编辑器"></a>5.2 BottomTextEditor 底部编辑器</h4><p>BottomTextEditor 是一个 React 组件，当用户选中文本元素时自动显示在底部：</p><p>当 Zustand Store 中的 selectedIds 变化且选中单个文本元素时显示，监听选中元素变化，同步元素文本内容到本地状态，通过 WangEditor 编辑后更新 Store</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 当选中元素改变时，同步 Store 的值到本地状态</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (element &amp;&amp; element.<span class="hljs-property">type</span> === <span class="hljs-string">"text"</span>) {<br>    <span class="hljs-title function_">setLocalHtml</span>(element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>);<br>  }<br>}, [element?.<span class="hljs-property">id</span>, element?.<span class="hljs-property">text</span>]);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params"><span class="hljs-attr">html</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-title function_">setLocalHtml</span>(html);<br>  <span class="hljs-comment">// 实时更新 Store，驱动 Canvas 重新渲染</span><br>  <span class="hljs-title function_">updateElement</span>(element.<span class="hljs-property">id</span>, { <span class="hljs-attr">text</span>: html });<br>};<br></code></pre></td></tr></table></figure><h4 id="5-3-RichTextEditor-富文本编辑器"><a href="#5-3-RichTextEditor-富文本编辑器" class="headerlink" title="5.3 RichTextEditor 富文本编辑器"></a>5.3 RichTextEditor 富文本编辑器</h4><p>RichTextEditor 封装了 WangEditor 的功能，提供富文本编辑功能，包括加粗、斜体、下划线、字体、颜色等<br>通过 toolbarConfig 和 editorConfig 配置编辑器功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 工具栏配置：仅保留基础文本样式</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">toolbarConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IToolbarConfig</span>&gt; = {<br>  <span class="hljs-attr">toolbarKeys</span>: [<br>    <span class="hljs-string">"bold"</span>,<br>    <span class="hljs-string">"italic"</span>,<br>    <span class="hljs-string">"underline"</span>,<br>    <span class="hljs-string">"through"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"fontSize"</span>,<br>    <span class="hljs-string">"fontFamily"</span>,<br>    <span class="hljs-string">"color"</span>,<br>    <span class="hljs-string">"bgColor"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"justifyLeft"</span>,<br>    <span class="hljs-string">"justifyCenter"</span>,<br>    <span class="hljs-string">"justifyRight"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"undo"</span>,<br>    <span class="hljs-string">"redo"</span>,<br>  ],<br>};<br></code></pre></td></tr></table></figure><h3 id="6-UI-与-文本渲染样式实现"><a href="#6-UI-与-文本渲染样式实现" class="headerlink" title="6. UI 与 文本渲染样式实现"></a>6. UI 与 文本渲染样式实现</h3><p>文本元素通过 PIXI.HTMLText 渲染，支持 HTML 标签和内联样式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[文本元素] --&gt; B[HTMLText对象]<br>    B --&gt; C[解析HTML内容]<br>    C --&gt; D[应用CSS样式]<br>    D --&gt; E[渲染到画布]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#fff3e0<br>    style D fill:#e8f5e8<br>    style E fill:#e1f5fe<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://github.com/Zhongye1/BDdraw_DEV/blob/main/assets/image-20251122221138270.png?raw=true'><img src="https://github.com/Zhongye1/BDdraw_DEV/blob/main/assets/image-20251122221138270.png?raw=true" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="PixiJS" scheme="https://zhongye1.github.io/Arknight-notes/tags/PixiJS/"/>
    
    <category term="富文本" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-画布元素控制调整机制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/38568.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/38568.html</id>
    <published>2025-11-23T12:30:00.000Z</published>
    <updated>2025-11-23T16:03:15.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>画布元素控制调整机制是画布应用中实现元素选中、变换和调整的核心功能模块。它通过变换控制器渲染器(<a href="/src/pages/canvas/Pixi_STM_modules/rendering/TransformerRenderer.ts#L5-L212">TransformerRenderer</a>)实现，在用户选中元素时显示控制手柄和边界框，并处理用户的调整操作，支持单个元素和多个元素的控制调整</p><ul><li><p><strong>项目结构</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── pages/<br>    └── canvas/<br>        └── Pixi_STM_modules/<br>            └── rendering/<br>                └── TransformerRenderer.ts    <span class="hljs-comment"># 变换控制器渲染器实现</span><br></code></pre></td></tr></table></figure><p>依赖库</p><ul><li><code>PixiJS</code>：WebGL 渲染引擎，用于绘制控制手柄和边界框</li><li><code>PIXI.Graphics</code>：用于绘制变换控制器的图形对象</li><li><code>TypeScript</code>：提供类型安全和代码可维护性</li></ul></li></ul><h3 id="2-控制调整机制类型定义"><a href="#2-控制调整机制类型定义" class="headerlink" title="2. 控制调整机制类型定义"></a>2. 控制调整机制类型定义</h3><h4 id="2-1-HandleType-类型"><a href="#2-1-HandleType-类型" class="headerlink" title="2.1 HandleType 类型"></a>2.1 HandleType 类型</h4><p>定义了变换控制器上各种手柄的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">HandleType</span> =<br>  | <span class="hljs-string">"tl"</span> <span class="hljs-comment">// top-left 左上角</span><br>  | <span class="hljs-string">"t"</span> <span class="hljs-comment">// top 顶部中间</span><br>  | <span class="hljs-string">"tr"</span> <span class="hljs-comment">// top-right 右上角</span><br>  | <span class="hljs-string">"r"</span> <span class="hljs-comment">// right 右侧中间</span><br>  | <span class="hljs-string">"br"</span> <span class="hljs-comment">// bottom-right 右下角</span><br>  | <span class="hljs-string">"b"</span> <span class="hljs-comment">// bottom 底部中间</span><br>  | <span class="hljs-string">"bl"</span> <span class="hljs-comment">// bottom-left 左下角</span><br>  | <span class="hljs-string">"l"</span> <span class="hljs-comment">// left 左侧中间</span><br>  | <span class="hljs-string">"p0"</span> <span class="hljs-comment">// 线段起点</span><br>  | <span class="hljs-string">"p1"</span> <span class="hljs-comment">// 线段终点</span><br>  | <span class="hljs-string">"rotate"</span>; <span class="hljs-comment">// 旋转手柄</span><br></code></pre></td></tr></table></figure><h4 id="2-2-TransformerRenderer-renderTransformer-参数"><a href="#2-2-TransformerRenderer-renderTransformer-参数" class="headerlink" title="2.2 TransformerRenderer.renderTransformer 参数"></a>2.2 TransformerRenderer.renderTransformer 参数</h4><p>变换控制器渲染方法的参数定义：</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素的数据</td></tr><tr><td>selectedIds</td><td>string[]</td><td>当前选中元素的 ID 数组</td></tr><tr><td>spriteMap</td><td>Map<string, PIXI.DisplayObject=""></string,></td><td>元素 ID 到 PIXI 对象的映射</td></tr><tr><td>onHandleDown</td><td>Function</td><td>手柄按下事件的回调函数</td></tr><tr><td>viewportScale</td><td>number</td><td>当前视口的缩放比例</td></tr></tbody></table></div><h3 id="3-控制调整机制架构"><a href="#3-控制调整机制架构" class="headerlink" title="3. 控制调整机制架构"></a>3. 控制调整机制架构</h3><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>TransformerRenderer 维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>transformerGraphic</td><td>PIXI.Graphics</td><td>用于绘制变换控制器的图形对象</td></tr></tbody></table></div><h4 id="3-2-外部依赖-External-Dependencies"><a href="#3-2-外部依赖-External-Dependencies" class="headerlink" title="3.2 外部依赖 (External Dependencies)"></a>3.2 外部依赖 (External Dependencies)</h4><p>控制调整机制依赖以下外部组件：</p><div class="table-container"><table><thead><tr><th>组件</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>画布元素数据</td></tr><tr><td>selectedIds</td><td>string[]</td><td>选中元素 ID 数组</td></tr><tr><td>spriteMap</td><td>Map<string, PIXI.DisplayObject=""></string,></td><td>元素到显示对象的映射</td></tr><tr><td>onHandleDown</td><td>Function</td><td>手柄事件处理回调</td></tr></tbody></table></div><h4 id="3-3-控制调整机制流程"><a href="#3-3-控制调整机制流程" class="headerlink" title="3.3 控制调整机制流程"></a>3.3 控制调整机制流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[元素选中状态变化] --&gt; B{TransformerRenderer}<br>    B --&gt; C[清除之前的控制器]<br>    C --&gt; D{选中元素数量}<br>    D --&gt;|0| E[无操作]<br>    D --&gt;|1:线性元素| F[绘制端点手柄]<br>    D --&gt;|1:普通元素| G[绘制8个控制手柄]<br>    D --&gt;|&gt;1| H[绘制群组控制手柄和旋转手柄]<br>    F --&gt; I[添加手柄点击区域]<br>    G --&gt; I<br>    H --&gt; I<br>    I --&gt; J[绑定事件处理]<br>    J --&gt; K[显示变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style K fill:#e8f5e8<br>    style E fill:#ffebee<br></code></pre></td></tr></table></figure><h3 id="4-控制调整类型"><a href="#4-控制调整类型" class="headerlink" title="4. 控制调整类型"></a>4. 控制调整类型</h3><p>控制调整机制根据选中元素的不同类型和数量，提供不同的控制方式：</p><h4 id="4-1-线性元素控制（单个线段-箭头）"><a href="#4-1-线性元素控制（单个线段-箭头）" class="headerlink" title="4.1 线性元素控制（单个线段/箭头）"></a>4.1 线性元素控制（单个线段/箭头）</h4><p>对于线段和箭头元素，提供两个端点控制手柄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[线段元素] --&gt; B[端点p0控制手柄]<br>    A --&gt; C[端点p1控制手柄]<br>    B --&gt; D[移动端点位置]<br>    C --&gt; D<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#f3e5f5<br>    style D fill:#e8f5e8<br></code></pre></td></tr></table></figure><h4 id="4-2-单个元素控制"><a href="#4-2-单个元素控制" class="headerlink" title="4.2 单个元素控制"></a>4.2 单个元素控制</h4><p>对于单个普通元素（矩形、圆形、文本等），提供 8 个控制手柄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[单个元素] --&gt; B[tl手柄]<br>    A --&gt; C[t手柄]<br>    A --&gt; D[tr手柄]<br>    A --&gt; E[r手柄]<br>    A --&gt; F[br手柄]<br>    A --&gt; G[b手柄]<br>    A --&gt; H[bl手柄]<br>    A --&gt; I[l手柄]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#f3e5f5<br>    style D fill:#f3e5f5<br>    style E fill:#f3e5f5<br>    style F fill:#f3e5f5<br>    style G fill:#f3e5f5<br>    style H fill:#f3e5f5<br>    style I fill:#f3e5f5<br></code></pre></td></tr></table></figure><h4 id="4-3-多个元素控制"><a href="#4-3-多个元素控制" class="headerlink" title="4.3 多个元素控制"></a>4.3 多个元素控制</h4><p>对于多个选中元素，提供群组控制手柄和旋转手柄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[多个元素] --&gt; B[计算包围盒]<br>    B --&gt; C[tl手柄]<br>    B --&gt; D[t手柄]<br>    B --&gt; E[tr手柄]<br>    B --&gt; F[r手柄]<br>    B --&gt; G[br手柄]<br>    B --&gt; H[b手柄]<br>    B --&gt; I[bl手柄]<br>    B --&gt; J[l手柄]<br>    B --&gt; K[旋转手柄]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#fff3e0<br>    style C fill:#f3e5f5<br>    style D fill:#f3e5f5<br>    style E fill:#f3e5f5<br>    style F fill:#f3e5f5<br>    style G fill:#f3e5f5<br>    style H fill:#f3e5f5<br>    style I fill:#f3e5f5<br>    style J fill:#f3e5f5<br>    style K fill:#f3e5f5<br></code></pre></td></tr></table></figure><h3 id="5-控制调整交互流程"><a href="#5-控制调整交互流程" class="headerlink" title="5. 控制调整交互流程"></a>5. 控制调整交互流程</h3><h4 id="5-1-交互时序图"><a href="#5-1-交互时序图" class="headerlink" title="5.1 交互时序图"></a>5.1 交互时序图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant TR as TransformerRenderer<br>    participant SM as StageManager<br>    participant ZS as Zustand Store<br>    <br>    U-&gt;&gt;TR: 点击控制手柄<br>    TR-&gt;&gt;TR: 识别手柄类型<br>    TR-&gt;&gt;SM: 调用onHandleDown回调<br>    SM-&gt;&gt;SM: 设置调整模式和激活手柄<br>    SM-&gt;&gt;SM: 记录初始状态<br>    SM-&gt;&gt;ZS: 锁定撤销管理器<br>    U-&gt;&gt;SM: 拖拽鼠标<br>    SM-&gt;&gt;SM: 计算元素新位置和尺寸<br>    SM-&gt;&gt;ZS: 更新元素状态<br>    U-&gt;&gt;SM: 释放鼠标<br>    SM-&gt;&gt;SM: 创建更新命令<br>    SM-&gt;&gt;ZS: 解锁撤销管理器<br>    ZS-&gt;&gt;SM: 触发状态变更<br>    SM-&gt;&gt;TR: 重新渲染变换控制器<br></code></pre></td></tr></table></figure><h4 id="5-2-核心函数解析"><a href="#5-2-核心函数解析" class="headerlink" title="5.2 核心函数解析"></a>5.2 核心函数解析</h4><p><strong>renderTransformer 函数</strong>：</p><p>当选中元素发生变化时触发，根据选中元素的类型和数量，绘制相应的控制手柄和边界框</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderTransformer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, PIXI.<span class="hljs-title class_">DisplayObject</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">onHandleDown</span>: <span class="hljs-title class_">Function</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">viewportScale</span>: <span class="hljs-built_in">number</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 清除之前的控制器</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">clear</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">removeChildren</span>()<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-comment">// 根据选中元素类型和数量绘制不同的控制器</span><br>  <span class="hljs-keyword">if</span> (isLinearElement) {<br>    <span class="hljs-comment">// 绘制线性元素控制器</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-comment">// 绘制单个元素控制器</span><br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 绘制多个元素控制器</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="6-UI-与样式实现"><a href="#6-UI-与样式实现" class="headerlink" title="6. UI 与样式实现"></a>6. UI 与样式实现</h3><h4 id="6-1-控制手柄样式"><a href="#6-1-控制手柄样式" class="headerlink" title="6.1 控制手柄样式"></a>6.1 控制手柄样式</h4><p>控制手柄使用统一的视觉样式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[控制手柄] --&gt; B[白色填充]<br>    A --&gt; C[紫色边框#8b5cf6]<br>    A --&gt; D[尺寸8px/10px]<br>    A --&gt; E[点击区域16px/20px]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#f3e5f5<br>    style D fill:#fff3e0<br>    style E fill:#fff3e0<br></code></pre></td></tr></table></figure><h4 id="6-2-光标样式"><a href="#6-2-光标样式" class="headerlink" title="6.2 光标样式"></a>6.2 光标样式</h4><p>不同类型的控制手柄提供不同的光标样式，提升用户体验：</p><div class="table-container"><table><thead><tr><th>手柄类型</th><th>光标样式</th></tr></thead><tbody><tr><td>tl, br</td><td>nwse-resize</td></tr><tr><td>tr, bl</td><td>nesw-resize</td></tr><tr><td>t, b</td><td>ns-resize</td></tr><tr><td>l, r</td><td>ew-resize</td></tr><tr><td>rotate</td><td>grab</td></tr><tr><td>p0, p1</td><td>move</td></tr></tbody></table></div><blockquote><p>控制调整机制通过 hitZone（点击区域）来处理用户交互</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="PixiJS" scheme="https://zhongye1.github.io/Arknight-notes/tags/PixiJS/"/>
    
    <category term="画布控制" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%94%BB%E5%B8%83%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-快捷键管理</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/25119.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/25119.html</id>
    <published>2025-11-23T12:11:21.000Z</published>
    <updated>2025-11-23T13:09:46.568Z</updated>
    
    <content type="html"><![CDATA[<p>快捷键管理模块负责处理画布应用中的各种键盘快捷键操作，包括撤销/重做、元素操作（删除、复制、粘贴）以及工具切换等核心功能。该模块通过监听键盘事件，提供直观、高效的用户交互方式。</p><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">src<span class="hljs-symbol">/</span><br>├── hooks<span class="hljs-symbol">/</span><br>│   ├── useHotkeysManagement.ts        <span class="hljs-comment"># 撤销/重做快捷键管理</span><br>│   └── use_React_hotkeys_management.ts <span class="hljs-comment"># 画布操作快捷键管理</span><br>└── stores<span class="hljs-symbol">/</span><br>    └── canvasStore.ts                 <span class="hljs-comment"># 提供快捷键操作对应的状态管理方法</span><br></code></pre></td></tr></table></figure><h3 id="2-依赖库"><a href="#2-依赖库" class="headerlink" title="2. 依赖库"></a>2. 依赖库</h3><ul><li><code>react-hotkeys-hook</code>：用于监听和处理键盘快捷键的 React Hook</li><li><code>Zustand</code>：全局状态管理，提供操作实现方法</li></ul><h2 id="3-核心状态管理"><a href="#3-核心状态管理" class="headerlink" title="3. 核心状态管理"></a>3. 核心状态管理</h2><p>快捷键管理模块本身不维护独立状态，而是依赖于 canvasStore 中的状态：</p><ul><li><code>selectedIds</code>：当前选中的元素 ID 列表</li><li><code>clipboard</code>：复制的元素数据</li><li><code>pasteOffset</code>：粘贴时的偏移量计数</li><li><code>tool</code>：当前选择的工具类型</li></ul><h2 id="4-逻辑流程"><a href="#4-逻辑流程" class="headerlink" title="4. 逻辑流程"></a>4. 逻辑流程</h2><h3 id="4-1-整体架构"><a href="#4-1-整体架构" class="headerlink" title="4.1 整体架构"></a>4.1 整体架构</h3><p>快捷键管理采用两个自定义 Hook 分别处理不同类型的快捷键操作：</p><ol><li><a href="/src/hooks/useHotkeysManagement.ts#L5-L27">useHotkeysManagement</a>：专门处理撤销/重做快捷键</li><li><a href="/src/hooks/use_React_hotkeys_management.ts#L10-L180">useCanvasShortcuts</a>：处理画布操作相关快捷键</li></ol><h3 id="4-2-快捷键注册与处理流程"><a href="#4-2-快捷键注册与处理流程" class="headerlink" title="4.2 快捷键注册与处理流程"></a>4.2 快捷键注册与处理流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[初始化快捷键Hook] --&gt; B[调用useHotkeys注册快捷键]<br>    B --&gt; C[监听键盘事件]<br>    C --&gt; D{匹配快捷键?}<br>    D --&gt;|是| E[执行回调函数]<br>    D --&gt;|否| C<br>    E --&gt; F[调用canvasStore对应方法]<br>    F --&gt; G[更新状态并触发重渲染]<br></code></pre></td></tr></table></figure><h2 id="5-核心函数解析"><a href="#5-核心函数解析" class="headerlink" title="5. 核心函数解析"></a>5. 核心函数解析</h2><h3 id="5-1-useHotkeysManagement-Hook"><a href="#5-1-useHotkeysManagement-Hook" class="headerlink" title="5.1 useHotkeysManagement Hook"></a>5.1 useHotkeysManagement Hook</h3><p>该 Hook 专门处理撤销/重做相关的快捷键操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useHotkeysManagement</span> = (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">const</span> { undo, redo } = <span class="hljs-title function_">useStore</span>();<br><br>  <span class="hljs-comment">// Ctrl+Z 撤销</span><br>  <span class="hljs-title function_">useHotkeys</span>(<br>    <span class="hljs-string">"ctrl+z"</span>,<br>    <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {<br>      event.<span class="hljs-title function_">preventDefault</span>();<br>      <span class="hljs-title function_">undo</span>();<br>    },<br>    {},<br>    [undo]<br>  );<br><br>  <span class="hljs-comment">// Ctrl+Shift+Z 或 Ctrl+Y 重做</span><br>  <span class="hljs-title function_">useHotkeys</span>(<br>    <span class="hljs-string">"ctrl+y, ctrl+shift+z"</span>,<br>    <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {<br>      event.<span class="hljs-title function_">preventDefault</span>();<br>      <span class="hljs-title function_">redo</span>();<br>    },<br>    {},<br>    [redo]<br>  );<br>};<br></code></pre></td></tr></table></figure><ul><li>监听 <code>Ctrl+Z</code> 组合键触发撤销操作</li><li>监听 <code>Ctrl+Y</code> 或 <code>Ctrl+Shift+Z</code> 组合键触发重做操作</li><li>使用 <a href="">event.preventDefault()</a> 阻止浏览器默认行为</li><li>依赖 canvasStore 提供的 <a href="/src/stores/canvasStore.ts#L281-L281">undo</a> 和 <a href="/src/stores/canvasStore.ts#L282-L282">redo</a> 方法</li></ul><h3 id="5-2-useCanvasShortcuts-Hook"><a href="#5-2-useCanvasShortcuts-Hook" class="headerlink" title="5.2 useCanvasShortcuts Hook"></a>5.2 useCanvasShortcuts Hook</h3><p>该 Hook 处理画布操作相关的快捷键，包括元素操作和工具切换。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useCanvasShortcuts</span> = (<span class="hljs-params">{</span><br><span class="hljs-params">  stageManagerRef,</span><br><span class="hljs-params">}: <span class="hljs-title class_">UseCanvasShortcutsProps</span></span>) =&gt; {<br>  <span class="hljs-keyword">const</span> { selectedIds, removeElements, setTool, copyElements, pasteElements } =<br>    <span class="hljs-title function_">useStore</span>();<br><br>  <span class="hljs-comment">// 删除选中元素</span><br>  <span class="hljs-title function_">useHotkeys</span>(<br>    <span class="hljs-string">"delete, backspace"</span>,<br>    <span class="hljs-function">() =&gt;</span> {<br>      <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-title function_">removeElements</span>(selectedIds);<br>      }<br>    },<br>    {<br>      <span class="hljs-attr">enableOnFormTags</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">ignoreEventWhen</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> event.<span class="hljs-property">target</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLInputElement</span>,<br>    },<br>    [selectedIds, removeElements]<br>  );<br><br>  <span class="hljs-comment">// 复制元素</span><br>  <span class="hljs-title function_">useHotkeys</span>(<br>    <span class="hljs-string">"ctrl+c, cmd+c"</span>,<br>    <span class="hljs-function">() =&gt;</span> {<br>      <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-title function_">copyElements</span>(selectedIds);<br>      }<br>    },<br>    {<br>      <span class="hljs-attr">enableOnFormTags</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">ignoreEventWhen</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> event.<span class="hljs-property">target</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLInputElement</span>,<br>    },<br>    [selectedIds, copyElements]<br>  );<br><br>  <span class="hljs-comment">// 粘贴元素</span><br>  <span class="hljs-title function_">useHotkeys</span>(<br>    <span class="hljs-string">"ctrl+v, cmd+v"</span>,<br>    <span class="hljs-function">() =&gt;</span> {<br>      <span class="hljs-title function_">pasteElements</span>();<br>    },<br>    {<br>      <span class="hljs-attr">enableOnFormTags</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">ignoreEventWhen</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> event.<span class="hljs-property">target</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLInputElement</span>,<br>    },<br>    [pasteElements]<br>  );<br><br>  <span class="hljs-comment">// 工具切换快捷键 (Shift+1 到 Shift+0)</span><br>  <span class="hljs-title function_">useHotkeys</span>(<br>    <span class="hljs-string">"shift+1"</span>,<br>    <span class="hljs-function">() =&gt;</span> {<br>      <span class="hljs-title function_">setTool</span>(<span class="hljs-string">"select"</span>);<br>    },<br>    {<br>      <span class="hljs-attr">enableOnFormTags</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">ignoreEventWhen</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> event.<span class="hljs-property">target</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLInputElement</span>,<br>    },<br>    [setTool]<br>  );<br>  <span class="hljs-comment">// ... 其他工具切换快捷键</span><br>};<br></code></pre></td></tr></table></figure><p>主要功能包括：</p><p><strong>元素删除</strong>：快捷键：<code>Delete</code> 或 <code>Backspace</code>，调用 <a href="/src/stores/canvasStore.ts#L271-L277">removeElements</a> 删除选中元素</p><p><strong>元素复制</strong>：快捷键：<code>Ctrl+C</code> (Windows) 或 <code>Cmd+C</code> (Mac)，操作：调用 <a href="/src/stores/canvasStore.ts#L257-L262">copyElements</a> 将选中元素复制到剪贴板</p><p><strong>元素粘贴</strong>：快捷键：<code>Ctrl+V</code> (Windows) 或 <code>Cmd+V</code> (Mac)，操作：调用 <a href="/src/stores/canvasStore.ts#L263-L280">pasteElements</a> 从剪贴板粘贴元素</p><p><strong>工具切换</strong>：</p><ul><li><code>Shift+1</code>：切换到选择工具</li><li><code>Shift+2</code>：切换到矩形工具</li><li><code>Shift+3</code>：切换到菱形工具</li><li><code>Shift+4</code>：切换到圆形工具</li><li><code>Shift+5</code>：切换到箭头工具</li><li><code>Shift+6</code>：切换到直线工具</li><li><code>Shift+7</code>：切换到铅笔工具</li><li><code>Shift+8</code>：切换到文字工具</li><li><code>Shift+9</code>：切换到图像工具</li><li><code>Shift+0</code>：切换到橡皮擦工具</li></ul><p>配置参数说明：</p><ul><li><a href="/node_modules/react-hotkeys-hook/dist/useHotkeys.d.ts#L7-L7">enableOnFormTags</a>：设置为 <code>false</code> 表示在表单元素上不启用快捷键</li><li><a href="/node_modules/react-hotkeys-hook/dist/useHotkeys.d.ts#L8-L8">ignoreEventWhen</a>：当目标元素是 HTMLInputElement 时不处理事件，防止在输入框中使用快捷键</li></ul><h2 id="6-快捷键操作实现"><a href="#6-快捷键操作实现" class="headerlink" title="6. 快捷键操作实现"></a>6. 快捷键操作实现</h2><h3 id="6-1-撤销-重做操作"><a href="#6-1-撤销-重做操作" class="headerlink" title="6.1 撤销/重做操作"></a>6.1 撤销/重做操作</h3><p>撤销/重做操作通过调用 canvasStore 中的 <a href="/src/stores/canvasStore.ts#L281-L281">undo</a> 和 <a href="/src/stores/canvasStore.ts#L282-L282">redo</a> 方法实现，这些方法进一步委托给 <a href="/src/lib/UndoRedoManager.ts#L171-L171">undoRedoManager</a> 实例处理。</p><h3 id="6-2-元素操作"><a href="#6-2-元素操作" class="headerlink" title="6.2 元素操作"></a>6.2 元素操作</h3><p>元素操作包括删除、复制和粘贴：</p><ol><li><p><strong>删除操作</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">removeElements</span>: <span class="hljs-function">(<span class="hljs-params">ids</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>    ids.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-keyword">delete</span> newElements[id]);<br>    <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements, <span class="hljs-attr">selectedIds</span>: [] };<br>  });<br></code></pre></td></tr></table></figure></li><li><p><strong>复制操作</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">copyElements</span>: <span class="hljs-function">(<span class="hljs-params">ids</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> elementsToCopy = ids<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> state.<span class="hljs-property">elements</span>[id])<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>);<br>    <span class="hljs-keyword">return</span> { <span class="hljs-attr">clipboard</span>: elementsToCopy };<br>  });<br></code></pre></td></tr></table></figure></li><li><p><strong>粘贴操作</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">pasteElements</span>: <span class="hljs-function">() =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">clipboard</span> || state.<span class="hljs-property">clipboard</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> state;<br><br>    <span class="hljs-comment">// 增加粘贴偏移量</span><br>    <span class="hljs-keyword">const</span> newOffset = state.<span class="hljs-property">pasteOffset</span> + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">newElements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt; = {};<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">newIds</span>: <span class="hljs-built_in">string</span>[] = [];<br><br>    state.<span class="hljs-property">clipboard</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newId = <span class="hljs-title function_">nanoid</span>();<br>      <span class="hljs-keyword">const</span> randomSign = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>; <span class="hljs-comment">// 随机选择正负</span><br>      <span class="hljs-keyword">const</span> randomOffset = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">20</span>; <span class="hljs-comment">// 0-20的随机偏移量</span><br>      newIds.<span class="hljs-title function_">push</span>(newId);<br>      newElements[newId] = {<br>        ...element,<br>        <span class="hljs-attr">id</span>: newId,<br>        <span class="hljs-comment">// 每次粘贴都在前一次的基础上继续偏移</span><br>        <span class="hljs-attr">x</span>: element.<span class="hljs-property">x</span> + randomOffset * randomSign,<br>        <span class="hljs-attr">y</span>: element.<span class="hljs-property">y</span> + randomOffset * randomSign,<br>      };<br>    });<br><br>    <span class="hljs-keyword">return</span> {<br>      <span class="hljs-attr">elements</span>: { ...state.<span class="hljs-property">elements</span>, ...newElements },<br>      <span class="hljs-attr">selectedIds</span>: newIds,<br>      <span class="hljs-attr">pasteOffset</span>: newOffset,<br>    };<br>  });<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-3-工具切换"><a href="#6-3-工具切换" class="headerlink" title="6.3 工具切换"></a>6.3 工具切换</h3><p>工具切换通过调用 canvasStore 的 <a href="/src/stores/canvasStore.ts#L255-L255">setTool</a> 方法实现，更新当前选择的工具类型并清除选中状态。</p><h2 id="7-特殊处理与优化"><a href="#7-特殊处理与优化" class="headerlink" title="7. 特殊处理与优化"></a>7. 特殊处理与优化</h2><h3 id="7-1-表单元素兼容性处理"><a href="#7-1-表单元素兼容性处理" class="headerlink" title="7.1 表单元素兼容性处理"></a>7.1 表单元素兼容性处理</h3><p>为了避免在输入框等表单元素中意外触发快捷键，所有快捷键都配置了以下选项：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">{<br>  <span class="hljs-attr">enableOnFormTags</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">ignoreEventWhen</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> event.<span class="hljs-property">target</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLInputElement</span>,<br>}<br></code></pre></td></tr></table></figure><h3 id="7-2-粘贴偏移处理"><a href="#7-2-粘贴偏移处理" class="headerlink" title="7.2 粘贴偏移处理"></a>7.2 粘贴偏移处理</h3><p>为了区分多次粘贴的元素，每次粘贴时会给新元素添加一个随机偏移量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> randomSign = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span> <span class="hljs-comment">// 随机选择正负</span><br><span class="hljs-keyword">const</span> randomOffset = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">20</span> <span class="hljs-comment">// 0-20的随机偏移量</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-attr">x</span>: element.<span class="hljs-property">x</span> + randomOffset * randomSign,<br><span class="hljs-attr">y</span>: element.<span class="hljs-property">y</span> + randomOffset * randomSign,<br></code></pre></td></tr></table></figure><p>TODO:后续会新增一个自定义快捷键功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快捷键管理模块负责处理画布应用中的各种键盘快捷键操作，包括撤销/重做、元素操作（删除、复制、粘贴）以及工具切换等核心功能。该模块通过监听键盘事件，提供直观、高效的用户交互方式。&lt;/p&gt;
&lt;h3 id=&quot;1-项目结构&quot;&gt;&lt;a href=&quot;#1-项目结构&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-工具栏选择机制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/36977.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/36977.html</id>
    <published>2025-11-23T11:48:44.000Z</published>
    <updated>2025-11-23T13:05:32.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目工具栏模块"><a href="#项目工具栏模块" class="headerlink" title="项目工具栏模块"></a>项目工具栏模块</h1><p>工具栏提供用户界面以选择和切换不同的绘图工具，使用户能够在画布上执行各种操作，如选择、绘制、添加文本、插入图片等。它是用户与画布交互的主要入口之一。</p><h3 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nix">src<span class="hljs-symbol">/</span><br>├── components<span class="hljs-symbol">/</span><br>│   └── canvas_toolbar<span class="hljs-symbol">/</span><br>│       └── TopToolbar.tsx        <span class="hljs-comment"># 顶部工具栏组件</span><br>├── stores<span class="hljs-symbol">/</span><br>│   └── canvasStore.ts            <span class="hljs-comment"># 全局状态管理，包含工具类型定义和切换方法</span><br>└── pages<span class="hljs-symbol">/</span><br>    └── canvas<span class="hljs-symbol">/</span><br>        └── Pixi_STM_modules<span class="hljs-symbol">/</span><br>            └── core<span class="hljs-symbol">/</span><br>                └── StageManagerCore.ts  <span class="hljs-comment"># 根据工具类型处理不同交互逻辑</span><br></code></pre></td></tr></table></figure><h3 id="1-3-DSF"><a href="#1-3-DSF" class="headerlink" title="1.3 DSF"></a>1.3 DSF</h3><ul><li>React：用于构建用户界面</li><li>TypeScript：提供类型安全</li><li>Zustand：全局状态管理</li><li>Tailwind CSS：样式设计</li><li>Lucide React：图标组件库</li></ul><h2 id="2-类型定义"><a href="#2-类型定义" class="headerlink" title="2. 类型定义"></a>2. 类型定义</h2><h3 id="2-1-工具类型定义"><a href="#2-1-工具类型定义" class="headerlink" title="2.1 工具类型定义"></a>2.1 工具类型定义</h3><p>在 <a href="/src/stores/canvasStore.ts">canvasStore.ts</a> 中定义了完整的工具类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ToolType</span> =<br>  | <span class="hljs-string">"select"</span><br>  | <span class="hljs-string">"hand"</span><br>  | <span class="hljs-string">"rect"</span><br>  | <span class="hljs-string">"circle"</span><br>  | <span class="hljs-string">"triangle"</span><br>  | <span class="hljs-string">"diamond"</span><br>  | <span class="hljs-string">"line"</span><br>  | <span class="hljs-string">"arrow"</span><br>  | <span class="hljs-string">"pencil"</span><br>  | <span class="hljs-string">"text"</span><br>  | <span class="hljs-string">"image"</span><br>  | <span class="hljs-string">"eraser"</span>;<br></code></pre></td></tr></table></figure><p>在 <a href="/src/components/canvas_toolbar/TopToolbar.tsx">TopToolbar.tsx</a> 中也有一个局部的工具类型定义，但略有不同：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToolType</span> =<br>  | <span class="hljs-string">"select"</span><br>  | <span class="hljs-string">"hand"</span><br>  | <span class="hljs-string">"rect"</span><br>  | <span class="hljs-string">"diamond"</span><br>  | <span class="hljs-string">"circle"</span><br>  | <span class="hljs-string">"arrow"</span><br>  | <span class="hljs-string">"line"</span><br>  | <span class="hljs-string">"pencil"</span><br>  | <span class="hljs-string">"text"</span><br>  | <span class="hljs-string">"image"</span><br>  | <span class="hljs-string">"eraser"</span>;<br></code></pre></td></tr></table></figure><p>附：<a href="/src/components/canvas_toolbar/TopToolbar.tsx">TopToolbar.tsx</a> 中没有定义 <code>triangle</code> 类型，这个某天会改</p><h3 id="2-2-工具配置项定义"><a href="#2-2-工具配置项定义" class="headerlink" title="2.2 工具配置项定义"></a>2.2 工具配置项定义</h3><p>在 <a href="/src/components/canvas_toolbar/TopToolbar.tsx">TopToolbar.tsx</a> 中定义了工具配置项接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ToolItemConfig</span> {<br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span> | <span class="hljs-string">"action"</span>; <span class="hljs-comment">// action 代表锁、库等非绘图工具</span><br>  <span class="hljs-attr">icon</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">ElementType</span>;<br>  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 用于 tooltip</span><br>  <span class="hljs-attr">value</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// store 中的 tool 值</span><br>  <span class="hljs-attr">shortcut</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 右下角快捷键提示</span><br>  <span class="hljs-attr">isSeparator</span>?: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 是否是分隔符</span><br>}<br></code></pre></td></tr></table></figure><h2 id="3-状态管理"><a href="#3-状态管理" class="headerlink" title="3. 状态管理"></a>3. 状态管理</h2><p>工具栏选择机制的核心状态存储在 canvasStore 中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span>; <span class="hljs-comment">// 当前选中的工具类型</span><br>  <span class="hljs-comment">// ... 其他状态</span><br>}<br></code></pre></td></tr></table></figure><p>工具切换方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">setTool</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><h2 id="4-工具分类与实现逻辑"><a href="#4-工具分类与实现逻辑" class="headerlink" title="4. 工具分类与实现逻辑"></a>4. 工具分类与实现逻辑</h2><h3 id="4-1-工具分类"><a href="#4-1-工具分类" class="headerlink" title="4.1 工具分类"></a>4.1 工具分类</h3><p>BDdraw 项目中的工具可以分为以下几类：</p><ol><li><p><strong>导航与选择工具</strong></p><ul><li>手形工具（hand）：用于拖动画布</li><li>选择工具（select）：用于选择和操作元素</li></ul></li><li><p><strong>绘图工具</strong></p><ul><li>矩形工具（rect）</li><li>菱形工具（diamond）</li><li>圆形工具（circle）</li><li>箭头工具（arrow）</li><li>直线工具（line）</li><li>铅笔工具（pencil）</li></ul></li><li><p><strong>特殊内容工具</strong></p><ul><li>文本工具（text）：用于添加和编辑文本</li><li>图片工具（image）：用于插入图片</li><li>橡皮擦工具（eraser）：用于删除元素</li></ul></li><li><p><strong>操作工具</strong></p><ul><li>撤销/重做工具：用于撤销或重做操作</li></ul></li></ol><h3 id="4-2-工具实现逻辑"><a href="#4-2-工具实现逻辑" class="headerlink" title="4.2 工具实现逻辑"></a>4.2 工具实现逻辑</h3><p>工具栏选择机制通过以下几套逻辑实现：</p><h4 id="4-2-1-工具栏-UI-渲染逻辑"><a href="#4-2-1-工具栏-UI-渲染逻辑" class="headerlink" title="4.2.1 工具栏 UI 渲染逻辑"></a>4.2.1 工具栏 UI 渲染逻辑</h4><p>工具栏在 <a href="/src/components/canvas_toolbar/TopToolbar.tsx">TopToolbar.tsx</a> 中定义，采用配置驱动的方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> tools = [<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"lock"</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">"action"</span>,<br>    <span class="hljs-attr">icon</span>: locked ? <span class="hljs-title class_">Lock</span> : <span class="hljs-title class_">Unlock</span>,<br>    <span class="hljs-attr">label</span>: locked ? <span class="hljs-string">"Unlock (Ctrl+Shift+L)"</span> : <span class="hljs-string">"Lock (Ctrl+Shift+L)"</span>,<br>    <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLocked</span>(!locked),<br>  },<br>  { <span class="hljs-attr">isSeparator</span>: <span class="hljs-literal">true</span> },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"hand"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"hand"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Hand</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Hand tool (H)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">""</span>,<br>  },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"select"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"select"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">MousePointer2</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Selection (V)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"1"</span>,<br>  },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"rect"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"rect"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Square</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Rectangle (R)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"2"</span>,<br>  },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"diamond"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"diamond"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Diamond</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Diamond (D)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"3"</span>,<br>  },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"circle"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"circle"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Circle</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Ellipse (E)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"4"</span>,<br>  },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"arrow"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"arrow"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">ArrowRight</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Arrow (A)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"5"</span>,<br>  },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-string">"line"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"line"</span>, <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Minus</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">"Line (L)"</span>, <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"6"</span> },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"pencil"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"pencil"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Pencil</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Draw (P)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"7"</span>,<br>  },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Type</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">"Text (T)"</span>, <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"8"</span> },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"image"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"image"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">ImageIcon</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Insert image"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"9"</span>,<br>    <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setImageModalVisible</span>(<span class="hljs-literal">true</span>),<br>  },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"eraser"</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">"eraser"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">Eraser</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Eraser (E)"</span>,<br>    <span class="hljs-attr">shortcut</span>: <span class="hljs-string">"0"</span>,<br>  },<br>  { <span class="hljs-attr">isSeparator</span>: <span class="hljs-literal">true</span> },<br>  {<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">"library"</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">"action"</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-title class_">LayoutGrid</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">"Library"</span>,<br>    <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span><br>      <span class="hljs-title class_">Notification</span>.<span class="hljs-title function_">error</span>({<br>        <span class="hljs-attr">closable</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">"DEV"</span>,<br>        <span class="hljs-attr">content</span>: <span class="hljs-string">"lib功能还没完善"</span>,<br>      }),<br>  },<br>];<br></code></pre></td></tr></table></figure><p>工具栏渲染逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[渲染工具栏] --&gt; B[遍历工具配置]<br>    B --&gt; C{是否为分隔符?}<br>    C --&gt;|是| D[渲染分隔线]<br>    C --&gt;|否| E[渲染按钮]<br>    E --&gt; F{是否有自定义点击处理?}<br>    F --&gt;|是| G[执行自定义处理]<br>    F --&gt;|否| H[调用setTool设置工具]<br>    D --&gt; I[继续下一个工具]<br>    G --&gt; I<br>    H --&gt; I<br>    I --&gt; J{是否还有工具?}<br>    J --&gt;|是| B<br>    J --&gt;|否| K[渲染完成]<br></code></pre></td></tr></table></figure><h4 id="4-2-2-工具状态管理逻辑"><a href="#4-2-2-工具状态管理逻辑" class="headerlink" title="4.2.2 工具状态管理逻辑"></a>4.2.2 工具状态管理逻辑</h4><p>工具状态管理通过 Zustand 实现：</p><ol><li>在 <a href="/src/stores/canvasStore.ts">canvasStore.ts</a> 中定义工具状态和切换方法：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span><br>  <span class="hljs-comment">// ...</span><br>}<br><br><span class="hljs-attr">setTool</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><ol><li>实现工具切换方法：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">setTool</span>: <span class="hljs-function">(<span class="hljs-params">tool</span>) =&gt;</span> <span class="hljs-title function_">originalSet</span>({ tool, <span class="hljs-attr">selectedIds</span>: [], <span class="hljs-attr">editingId</span>: <span class="hljs-literal">null</span> });<br></code></pre></td></tr></table></figure><p>每次切换工具时，都会清空当前选中的元素和正在编辑的元素 ID。</p><h4 id="4-2-3-工具交互逻辑"><a href="#4-2-3-工具交互逻辑" class="headerlink" title="4.2.3 工具交互逻辑"></a>4.2.3 工具交互逻辑</h4><p>工具交互逻辑在 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts">StageManagerCore.ts</a> 中实现，根据当前工具类型处理不同的交互：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">const</span> tool = state.<span class="hljs-property">tool</span><br>  <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'hand'</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isSpacePressed</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-comment">// 根据不同工具类型执行不同逻辑</span><br>  <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'eraser'</span>) {<br>    <span class="hljs-comment">// 橡皮擦逻辑</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'text'</span>) {<br>    <span class="hljs-comment">// 文本工具逻辑</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> &amp;&amp; e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span> &amp;&amp; !e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'handle:'</span>)) {<br>    <span class="hljs-comment">// 元素点击逻辑</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'select'</span>) {<br>    <span class="hljs-comment">// 选择模式逻辑</span><br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 绘制模式逻辑</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="5-核心函数解析"><a href="#5-核心函数解析" class="headerlink" title="5. 核心函数解析"></a>5. 核心函数解析</h2><h3 id="5-1-TopToolbar-组件"><a href="#5-1-TopToolbar-组件" class="headerlink" title="5.1 TopToolbar 组件"></a>5.1 TopToolbar 组件</h3><p><a href="/src/components/canvas_toolbar/TopToolbar.tsx">TopToolbar.tsx</a> 是工具栏的主要实现组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TopToolbar</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">const</span> { tool, setTool, undo, redo, canUndo, canRedo } = <span class="hljs-title function_">useStore</span>();<br>  <span class="hljs-keyword">const</span> [locked, setLocked] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> [imageModalVisible, setImageModalVisible] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">// ...</span><br>}<br></code></pre></td></tr></table></figure><p>组件主要功能：</p><ol><li>从 store 获取当前工具状态</li><li>提供工具切换功能</li><li>提供撤销/重做按钮</li><li>处理图片插入模态框显示</li></ol><h3 id="5-2-工具按钮渲染逻辑"><a href="#5-2-工具按钮渲染逻辑" class="headerlink" title="5.2 工具按钮渲染逻辑"></a>5.2 工具按钮渲染逻辑</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript">{<br>  tools.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {<br>    <span class="hljs-comment">// 渲染分隔线</span><br>    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">isSeparator</span>) {<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">sep-</span>${<span class="hljs-attr">index</span>}`} <span class="hljs-attr">className</span>=<span class="hljs-string">"mx-1 h-6 w-px bg-gray-200"</span> /&gt;</span></span>;<br>    }<br><br>    <span class="hljs-comment">// 渲染按钮</span><br>    <span class="hljs-keyword">const</span> isActive = tool === item.<span class="hljs-property">value</span> &amp;&amp; item.<span class="hljs-property">type</span> !== <span class="hljs-string">"action"</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Icon</span> = item.<span class="hljs-property">icon</span>;<br><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id</span> || <span class="hljs-attr">index</span>}</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">title</span>=<span class="hljs-string">{item.label}</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {</span><br><span class="language-xml">          if (item.onClick) item.onClick();</span><br><span class="language-xml">          if (item.value) setTool(item.value as any);</span><br><span class="language-xml">        }}</span><br><span class="language-xml">        className={cls(</span><br><span class="language-xml">          "relative flex h-9 w-9 items-center justify-center transition-colors duration-100",</span><br><span class="language-xml">          // 选中状态：淡紫色背景，深紫色图标</span><br><span class="language-xml">          isActive</span><br><span class="language-xml">            ? "bg-violet-100 text-violet-700"</span><br><span class="language-xml">            : "bg-transparent text-gray-600 hover:bg-gray-100",</span><br><span class="language-xml">          // 锁的特殊样式</span><br><span class="language-xml">          item.id === "lock" &amp;&amp; locked ? "text-gray-900" : ""</span><br><span class="language-xml">        )}</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        {Icon &amp;&amp; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Icon</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">className</span>=<span class="hljs-string">{cls(</span>"<span class="hljs-attr">h-4</span> <span class="hljs-attr">w-4</span>", <span class="hljs-attr">item.value</span> === <span class="hljs-string">"line"</span> ? "<span class="hljs-attr">rotate-45</span>" <span class="hljs-attr">:</span> "")}</span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">strokeWidth</span>=<span class="hljs-string">{2}</span></span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">        )}</span><br><span class="language-xml"></span><br><span class="language-xml">        {/* 右下角的快捷键数字 */}</span><br><span class="language-xml">        {item.shortcut &amp;&amp; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"absolute bottom-[2px] right-[2px] text-[9px] font-medium leading-none opacity-50"</span>&gt;</span></span><br><span class="language-xml">            {item.shortcut}</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        )}</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    );<br>  });<br>}<br></code></pre></td></tr></table></figure><h3 id="5-3-工具切换逻辑"><a href="#5-3-工具切换逻辑" class="headerlink" title="5.3 工具切换逻辑"></a>5.3 工具切换逻辑</h3><p>工具切换通过调用 store 的 <a href="/src/stores/canvasStore.ts#L255-L255">setTool</a> 方法实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">setTool</span>: <span class="hljs-function">(<span class="hljs-params">tool</span>) =&gt;</span> <span class="hljs-title function_">originalSet</span>({ tool, <span class="hljs-attr">selectedIds</span>: [], <span class="hljs-attr">editingId</span>: <span class="hljs-literal">null</span> });<br></code></pre></td></tr></table></figure><h2 id="6-特殊工具处理"><a href="#6-特殊工具处理" class="headerlink" title="6. 特殊工具处理"></a>6. 特殊工具处理</h2><h3 id="6-1-图片工具"><a href="#6-1-图片工具" class="headerlink" title="6.1 图片工具"></a>6.1 图片工具</h3><p>图片工具与其他工具不同，它不直接在画布上创建元素，而是打开一个模态框让用户选择图片：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript">{<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">'image'</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">'image'</span>,<br>  <span class="hljs-attr">icon</span>: <span class="hljs-title class_">ImageIcon</span>,<br>  <span class="hljs-attr">label</span>: <span class="hljs-string">'Insert image'</span>,<br>  <span class="hljs-attr">shortcut</span>: <span class="hljs-string">'9'</span>,<br>  <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setImageModalVisible</span>(<span class="hljs-literal">true</span>),<br>}<br></code></pre></td></tr></table></figure><h3 id="6-2-锁定工具"><a href="#6-2-锁定工具" class="headerlink" title="6.2 锁定工具"></a>6.2 锁定工具</h3><p>锁定工具是一个特殊操作工具，用于锁定/解锁画布：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">{<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">'lock'</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'action'</span>,<br>  <span class="hljs-attr">icon</span>: locked ? <span class="hljs-title class_">Lock</span> : <span class="hljs-title class_">Unlock</span>,<br>  <span class="hljs-attr">label</span>: locked ? <span class="hljs-string">'Unlock (Ctrl+Shift+L)'</span> : <span class="hljs-string">'Lock (Ctrl+Shift+L)'</span>,<br>  <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLocked</span>(!locked),<br>}<br></code></pre></td></tr></table></figure><h3 id="6-3-库工具"><a href="#6-3-库工具" class="headerlink" title="6.3 库工具"></a>6.3 库工具</h3><p>库工具是一个占位符，目前尚未实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">{<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">'library'</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'action'</span>,<br>  <span class="hljs-attr">icon</span>: <span class="hljs-title class_">LayoutGrid</span>,<br>  <span class="hljs-attr">label</span>: <span class="hljs-string">'Library'</span>,<br>  <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span><br>    <span class="hljs-title class_">Notification</span>.<span class="hljs-title function_">error</span>({<br>      <span class="hljs-attr">closable</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">'DEV'</span>,<br>      <span class="hljs-attr">content</span>: <span class="hljs-string">'lib功能还没完善'</span>,<br>    }),<br>}<br></code></pre></td></tr></table></figure><h2 id="7-工具交互实现"><a href="#7-工具交互实现" class="headerlink" title="7. 工具交互实现"></a>7. 工具交互实现</h2><p>不同工具在 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts">StageManagerCore.ts</a> 中有不同的交互实现：</p><h3 id="7-1-选择工具-select"><a href="#7-1-选择工具-select" class="headerlink" title="7.1 选择工具 (select)"></a>7.1 选择工具 (select)</h3><p>选择工具用于选择和操作画布上的元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (tool === <span class="hljs-string">"select"</span>) {<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">"selecting"</span>;<br>  state.<span class="hljs-title function_">setSelected</span>([]);<br>  <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="7-2-手形工具-hand"><a href="#7-2-手形工具-hand" class="headerlink" title="7.2 手形工具 (hand)"></a>7.2 手形工具 (hand)</h3><p>手形工具用于拖动画布：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (tool === <span class="hljs-string">"hand"</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isSpacePressed</span>) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><h3 id="7-3-绘图工具-rect-circle-diamond-arrow-line-pencil"><a href="#7-3-绘图工具-rect-circle-diamond-arrow-line-pencil" class="headerlink" title="7.3 绘图工具 (rect, circle, diamond, arrow, line, pencil)"></a>7.3 绘图工具 (rect, circle, diamond, arrow, line, pencil)</h3><p>这些工具用于在画布上绘制相应形状：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// Drawing Mode</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">"drawing"</span>;<br><span class="hljs-keyword">const</span> newId = <span class="hljs-title function_">nanoid</span>();<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">currentId</span> = newId;<br><span class="hljs-comment">// ... 创建元素配置</span><br>state.<span class="hljs-title function_">addElement</span>(commonProps);<br></code></pre></td></tr></table></figure><h3 id="7-4-文本工具-text"><a href="#7-4-文本工具-text" class="headerlink" title="7.4 文本工具 (text)"></a>7.4 文本工具 (text)</h3><p>文本工具用于添加文本元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (tool === <span class="hljs-string">"text"</span>) {<br>  <span class="hljs-keyword">const</span> newId = <span class="hljs-title function_">nanoid</span>();<br>  state.<span class="hljs-title function_">addElement</span>({<br>    <span class="hljs-attr">id</span>: newId,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>,<br>    <span class="hljs-attr">x</span>: worldPos.<span class="hljs-property">x</span>,<br>    <span class="hljs-attr">y</span>: worldPos.<span class="hljs-property">y</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">40</span>,<br>    <span class="hljs-attr">fill</span>: <span class="hljs-string">"#000000"</span>,<br>    <span class="hljs-attr">stroke</span>: <span class="hljs-string">"#000000"</span>,<br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">"&lt;p&gt;请输入文本&lt;/p&gt;"</span>,<br>    <span class="hljs-attr">fontSize</span>: state.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">fontSize</span> || <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">fontFamily</span>: state.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">fontFamily</span> || <span class="hljs-string">"Arial"</span>,<br>  });<br>  state.<span class="hljs-title function_">setSelected</span>([newId]);<br>  state.<span class="hljs-title function_">setTool</span>(<span class="hljs-string">"select"</span>);<br>  <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="7-5-橡皮擦工具-eraser"><a href="#7-5-橡皮擦工具-eraser" class="headerlink" title="7.5 橡皮擦工具 (eraser)"></a>7.5 橡皮擦工具 (eraser)</h3><p>橡皮擦工具用于删除元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (tool === <span class="hljs-string">"eraser"</span>) {<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">"erasing"</span>;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> &amp;&amp; e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>) {<br>    <span class="hljs-keyword">const</span> hitId = e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>;<br>    state.<span class="hljs-title function_">removeElements</span>([hitId]);<br>  }<br>  <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目工具栏模块&quot;&gt;&lt;a href=&quot;#项目工具栏模块&quot; class=&quot;headerlink&quot; title=&quot;项目工具栏模块&quot;&gt;&lt;/a&gt;项目工具栏模块&lt;/h1&gt;&lt;p&gt;工具栏提供用户界面以选择和切换不同的绘图工具，使用户能够在画布上执行各种操作，如选择、绘制、添加文本</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-23-Undo/Redo机制具体实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/52695.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/52695.html</id>
    <published>2025-11-23T11:15:00.000Z</published>
    <updated>2025-11-23T16:03:47.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>Undo/Redo 机制是画布应用中实现操作撤销和重做的核心功能模块。它基于命令模式（Command Pattern）实现来，管理操作历史、执行撤销/重做操作和防止操作冲突，通过维护撤销栈和重做栈来管理用户的操作历史。</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>├── lib/<br>│   ├── UndoRedoManager.ts        <span class="hljs-comment"># 撤销重做管理器核心实现</span><br>│   └── UpdateElementCommand.ts   <span class="hljs-comment"># 元素更新命令实现</span><br>└── stores/<br>    └── canvasStore.ts            <span class="hljs-comment"># 状态存储，命令操作的目标</span><br></code></pre></td></tr></table></figure><ul><li><code>Command Pattern</code>：设计模式，用于封装操作命令</li><li><code>Zustand</code>：状态管理库，作为命令操作的目标</li><li><code>TypeScript</code>：提供类型安全和代码可维护性</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-UndoRedoManager-核心方法"><a href="#2-1-UndoRedoManager-核心方法" class="headerlink" title="2.1 UndoRedoManager 核心方法"></a>2.1 UndoRedoManager 核心方法</h4><p>撤销重做管理器提供了一系列核心方法用于管理操作命令。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>参数</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>executeCommand</td><td>command: Command</td><td>void</td><td>执行并记录命令</td></tr><tr><td>undo</td><td>无</td><td>void</td><td>执行撤销操作</td></tr><tr><td>redo</td><td>无</td><td>void</td><td>执行重做操作</td></tr><tr><td>lock</td><td>无</td><td>void</td><td>锁定管理器，防止记录新命令</td></tr><tr><td>unlock</td><td>无</td><td>void</td><td>解锁管理器</td></tr><tr><td>isLocked</td><td>无</td><td>boolean</td><td>检查管理器是否被锁定</td></tr><tr><td>canUndo</td><td>无</td><td>boolean</td><td>检查是否可以撤销</td></tr><tr><td>canRedo</td><td>无</td><td>boolean</td><td>检查是否可以重做</td></tr></tbody></table></div><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口</strong>：<br>定义了命令对象必须实现的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><p><strong>UpdateOperation 接口</strong>：<br>定义了元素更新操作的数据结构。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 元素ID</span><br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><blockquote><p>⚠️ 为防止在执行撤销/重做操作时记录新的命令，系统实现了锁定机制。在执行命令时会先锁定管理器，执行完成后再解锁，确保操作的原子性。</p></blockquote><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>UndoRedoManager 维护以下内部状态用于管理操作历史：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>undoStack</td><td>Command[]</td><td>撤销命令栈，存储可以撤销的命令</td></tr><tr><td>redoStack</td><td>Command[]</td><td>重做命令栈，存储可以重做的命令</td></tr><tr><td>locked</td><td>boolean</td><td>锁定状态，防止在执行命令时记录新命令</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>Undo/Redo 机制通过 Zustand 状态管理库操作外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据，命令操作的目标</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户操作] --&gt; B{StageManager}<br>    B --&gt; C[创建命令对象]<br>    C --&gt; D[UndoRedoManager.executeCommand]<br>    D --&gt; E{管理器锁定?}<br>    E --&gt;|是| F[忽略命令]<br>    E --&gt;|否| G[执行命令]<br>    G --&gt; H[命令入撤销栈]<br>    H --&gt; I[清空重做栈]<br>    I --&gt; J[Zustand 状态更新]<br>    <br>    subgraph 撤销操作<br>      K[UndoRedoManager.undo]<br>      K --&gt; L{撤销栈空?}<br>      L --&gt;|是| M[无法撤销]<br>      L --&gt;|否| N[弹出命令]<br>      N --&gt; O[执行命令.undo]<br>      O --&gt; P[命令入重做栈]<br>      P --&gt; Q[Zustand 状态更新]<br>    end<br>    <br>    subgraph 重做操作<br>      R[UndoRedoManager.redo]<br>      R --&gt; S{重做栈空?}<br>      S --&gt;|是| T[无法重做]<br>      S --&gt;|否| U[弹出命令]<br>      U --&gt; V[执行命令.redo]<br>      V --&gt; W[命令入撤销栈]<br>      W --&gt; X[Zustand 状态更新]<br>    end<br>    <br>    style A fill:#e1f5fe<br>    style J fill:#e8f5e8<br>    style Q fill:#e8f5e8<br>    style X fill:#e8f5e8<br>    style F fill:#ffebee<br></code></pre></td></tr></table></figure><h3 id="4-命令管理机制"><a href="#4-命令管理机制" class="headerlink" title="4. 命令管理机制"></a>4. 命令管理机制</h3><p>Undo/Redo 机制采用命令模式（Command Pattern）来管理操作命令，通过定义统一的接口和不同的实现类来处理各种操作。</p><h4 id="4-1-命令类型"><a href="#4-1-命令类型" class="headerlink" title="4.1 命令类型"></a>4.1 命令类型</h4><p>系统中主要有两种命令类型：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：用于记录整个画布状态的变化，通常用于添加元素、删除元素等较大范围的操作，保存完整的状态快照</p></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：用于记录特定元素的属性变化，主要用于拖拽移动和调整大小操作，只保存相关元素的特定属性变化</p></li></ol><h4 id="4-2-命令接口定义"><a href="#4-2-命令接口定义" class="headerlink" title="4.2 命令接口定义"></a>4.2 命令接口定义</h4><p>所有命令都实现统一的 <a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><h4 id="4-3-快照命令（SnapshotCommand）"><a href="#4-3-快照命令（SnapshotCommand）" class="headerlink" title="4.3 快照命令（SnapshotCommand）"></a>4.3 快照命令（SnapshotCommand）</h4><p>快照命令用于记录整个画布状态的变化，适用于影响范围较大的操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">any</span></span>) {<br>    <span class="hljs-comment">// 使用 structuredClone 进行深拷贝，确保状态隔离</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span> = <span class="hljs-title function_">structuredClone</span>(prevState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span> = <span class="hljs-title function_">structuredClone</span>(nextState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>    <span class="hljs-comment">// 生成唯一的命令ID用于调试</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() % <span class="hljs-number">1000000</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// execute在添加到命令栈之前已经执行了</span><br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之前的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span>);<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之后的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-4-更新元素命令（UpdateElementCommand）"><a href="#4-4-更新元素命令（UpdateElementCommand）" class="headerlink" title="4.4 更新元素命令（UpdateElementCommand）"></a>4.4 更新元素命令（UpdateElementCommand）</h4><p>更新元素命令用于记录特定元素的属性变化，适用于影响范围较小的精细操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operations</span>: <span class="hljs-title class_">UpdateOperation</span>[],</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operationType</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"更新元素"</span></span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-comment">// 生成唯一命令ID</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-string">`UpdateElementCommand-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random()</span></span><br><span class="hljs-subst"><span class="hljs-string">      .toString(<span class="hljs-number">36</span>)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .slice(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)}</span>`</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 应用最终状态</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 撤销：恢复到 initialAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">initialAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 重做：恢复到 finalAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-5-命令生命周期"><a href="#4-5-命令生命周期" class="headerlink" title="4.5 命令生命周期"></a>4.5 命令生命周期</h4><p>命令的生命周期包括创建、执行、撤销和重做四个阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[命令创建] --&gt; B[命令执行]<br>    B --&gt; C{用户操作}<br>    C --&gt;|撤销| D[执行undo方法]<br>    C --&gt;|重做| E[执行redo方法]<br>    D --&gt; F[命令状态切换]<br>    E --&gt; F<br>    F --&gt; G[状态更新完成]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style D fill:#fff3e0<br>    style E fill:#fff3e0<br>    style G fill:#e8f5e8<br></code></pre></td></tr></table></figure><h3 id="5-命令栈管理机制"><a href="#5-命令栈管理机制" class="headerlink" title="5. 命令栈管理机制"></a>5. 命令栈管理机制</h3><p>撤销/重做机制使用两个栈来管理命令历史：</p><ol><li><strong>撤销栈（Undo Stack）</strong>：</li></ol><p>存储用户可以撤销的操作命令，栈顶是最近执行的命令，执行新命令时，命令被推入此栈，执行撤销操作时，命令从此栈弹出并推入重做栈</p><ol><li><strong>重做栈（Redo Stack）</strong>：</li></ol><p>存储用户可以重做的操作命令，在执行撤销操作时，被撤销的命令被推入此栈，执行重做操作时，命令从此栈弹出并推入撤销栈，执行新命令时，此栈被清空</p><h4 id="5-1-命令栈操作流程"><a href="#5-1-命令栈操作流程" class="headerlink" title="5.1 命令栈操作流程"></a>5.1 命令栈操作流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[执行新命令] --&gt; B[命令入撤销栈]<br>    B --&gt; C[清空重做栈]<br>    <br>    D[执行撤销] --&gt; E{撤销栈空?}<br>    E --&gt;|是| F[无操作]<br>    E --&gt;|否| G[弹出命令]<br>    G --&gt; H[执行命令.undo]<br>    H --&gt; I[命令入重做栈]<br>    <br>    J[执行重做] --&gt; K{重做栈空?}<br>    K --&gt;|是| L[无操作]<br>    K --&gt;|否| M[弹出命令]<br>    M --&gt; N[执行命令.redo]<br>    N --&gt; O[命令入撤销栈]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#f3e5f5<br>    style D fill:#e1f5fe<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style J fill:#e1f5fe<br>    style N fill:#e8f5e8<br>    style O fill:#e8f5e8<br></code></pre></td></tr></table></figure><h4 id="5-2-不同类型的命令"><a href="#5-2-不同类型的命令" class="headerlink" title="5.2 不同类型的命令"></a>5.2 不同类型的命令</h4><p>撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：</p><ul><li>用于记录整个画布状态的变化</li><li>通常用于添加元素、删除元素等较大范围的操作</li><li>保存完整的状态快照</li></ul></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：</p><ul><li>用于记录特定元素的属性变化</li><li>主要用于拖拽移动和调整大小操作</li><li>只保存相关元素的特定属性变化</li></ul></li></ol><h4 id="5-3-操作序列和撤销栈状态变化示例"><a href="#5-3-操作序列和撤销栈状态变化示例" class="headerlink" title="5.3 操作序列和撤销栈状态变化示例"></a>5.3 操作序列和撤销栈状态变化示例</h4><h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><p>撤销栈：空<br>重做栈：空</p><h5 id="1-创建元素-A"><a href="#1-创建元素-A" class="headerlink" title="1. 创建元素 A"></a>1. 创建元素 A</h5><p>当创建元素 A 时，系统会生成一个快照命令，记录整个画布状态的变化。<br>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：空</p><h5 id="2-移动-A-到一个位置"><a href="#2-移动-A-到一个位置" class="headerlink" title="2. 移动 A 到一个位置"></a>2. 移动 A 到一个位置</h5><p>当移动元素 A 时，系统会生成一个更新元素命令（UpdateElementCommand），只记录 A 元素位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：空</p><h5 id="3-创建元素-B"><a href="#3-创建元素-B" class="headerlink" title="3. 创建元素 B"></a>3. 创建元素 B</h5><p>当创建元素 B 时，系统会生成另一个快照命令，记录添加 B 元素后的状态。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：空</p><h5 id="4-缩放-B-到一个位置"><a href="#4-缩放-B-到一个位置" class="headerlink" title="4. 缩放 B 到一个位置"></a>4. 缩放 B 到一个位置</h5><p>当缩放元素 B 时，系统会生成一个更新元素命令，记录 B 元素尺寸和位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：空</p><h5 id="5-移动-B-到一个位置"><a href="#5-移动-B-到一个位置" class="headerlink" title="5. 移动 B 到一个位置"></a>5. 移动 B 到一个位置</h5><p>当再次移动元素 B 时，系统会生成另一个更新元素命令，记录 B 元素位置的新变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5)<br>重做栈：空</p><h4 id="5-4-执行撤销操作时的状态变化"><a href="#5-4-执行撤销操作时的状态变化" class="headerlink" title="5.4 执行撤销操作时的状态变化"></a>5.4 执行撤销操作时的状态变化</h4><h5 id="第一次撤销（移动-B-操作）"><a href="#第一次撤销（移动-B-操作）" class="headerlink" title="第一次撤销（移动 B 操作）"></a>第一次撤销（移动 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB</li><li>执行该命令的 undo()方法，将 B 元素恢复到缩放后的位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：[UpdateElementCommand_MoveB] (大小: 1)</p><h5 id="第二次撤销（缩放-B-操作）"><a href="#第二次撤销（缩放-B-操作）" class="headerlink" title="第二次撤销（缩放 B 操作）"></a>第二次撤销（缩放 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB</li><li>执行该命令的 undo()方法，将 B 元素恢复到刚创建时的尺寸和位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)</p><h5 id="第三次撤销（创建-B-操作）"><a href="#第三次撤销（创建-B-操作）" class="headerlink" title="第三次撤销（创建 B 操作）"></a>第三次撤销（创建 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_B</li><li>执行该命令的 undo()方法，将整个画布状态恢复到创建 B 之前的状态（即只包含 A 元素的状态）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)</p><h5 id="第四次撤销（移动-A-操作）"><a href="#第四次撤销（移动-A-操作）" class="headerlink" title="第四次撤销（移动 A 操作）"></a>第四次撤销（移动 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA</li><li>执行该命令的 undo()方法，将 A 元素恢复到初始位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)</p><h5 id="第五次撤销（创建-A-操作）"><a href="#第五次撤销（创建-A-操作）" class="headerlink" title="第五次撤销（创建 A 操作）"></a>第五次撤销（创建 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_A</li><li>执行该命令的 undo()方法，将整个画布状态恢复到初始状态（空画布）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：空<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)</p><h3 id="6-逻辑流程-Logic-Flow"><a href="#6-逻辑流程-Logic-Flow" class="headerlink" title="6. 逻辑流程 (Logic Flow)"></a>6. 逻辑流程 (Logic Flow)</h3><h4 id="6-1-交互时序图-Mermaid"><a href="#6-1-交互时序图-Mermaid" class="headerlink" title="6.1 交互时序图 (Mermaid)"></a>6.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManager<br>    participant URM as UndoRedoManager<br>    participant C as Command<br>    participant ZS as Zustand Store<br>    <br>    U-&gt;&gt;SM: 执行操作（如拖拽元素）<br>    SM-&gt;&gt;SM: 记录操作初始状态<br>    SM-&gt;&gt;ZS: 更新元素状态<br>    SM-&gt;&gt;C: 创建 UpdateElementCommand<br>    SM-&gt;&gt;URM: executeCommand(command)<br>    URM-&gt;&gt;C: command.execute()<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 清空重做栈<br>    <br>    U-&gt;&gt;URM: 执行撤销 (Ctrl+Z)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.undo()<br>    C-&gt;&gt;ZS: 恢复初始状态<br>    C-&gt;&gt;URM: 命令入重做栈<br>    URM-&gt;&gt;URM: 解锁管理器<br>    <br>    U-&gt;&gt;URM: 执行重做 (Ctrl+Y)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.redo()<br>    C-&gt;&gt;ZS: 恢复最终状态<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 解锁管理器<br></code></pre></td></tr></table></figure><h4 id="6-2-核心函数解析"><a href="#6-2-核心函数解析" class="headerlink" title="6.2 核心函数解析"></a>6.2 核心函数解析</h4><p><strong>executeCommand 函数</strong>：当用户完成一个操作（如创建、更新、删除元素）时触发，执行命令并将命令添加到撤销栈，同时清空重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">executeCommand</span>(<span class="hljs-params"><span class="hljs-attr">command</span>: <span class="hljs-title class_">Command</span></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">locked</span>) {<br>    <span class="hljs-comment">// 如果管理器被锁定，忽略命令</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-comment">// 执行命令</span><br>  command.<span class="hljs-title function_">execute</span>()<br><br>  <span class="hljs-comment">// 将命令添加到撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)<br><br>  <span class="hljs-comment">// 清空重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span> = []<br>}<br></code></pre></td></tr></table></figure><p><strong>undo 函数</strong>：当用户执行撤销操作（如按 Ctrl+Z）时触发，从撤销栈弹出命令，执行命令的 undo 方法，并将命令放入重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">undo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 撤销栈为空，无法撤销</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">undo</span>()  <span class="hljs-comment">// 执行撤销</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><p><strong>redo 函数</strong>：当用户执行重做操作（如按 Ctrl+Y）时触发，从重做栈弹出命令，执行命令的 redo 方法，并将命令放入撤销栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">redo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 重做栈为空，无法重做</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">redo</span>()  <span class="hljs-comment">// 执行重做</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><h3 id="7-UI-与样式实现-UI-Implementation"><a href="#7-UI-与样式实现-UI-Implementation" class="headerlink" title="7. UI 与样式实现 (UI Implementation)"></a>7. UI 与样式实现 (UI Implementation)</h3><p>Undo/Redo 机制通过快捷键和控制台界面与用户交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互方式}<br>    B --&gt; C[键盘快捷键]<br>    B --&gt; D[控制台界面]<br>    C --&gt; E[Ctrl+Z 撤销]<br>    C --&gt; F[Ctrl+Y 重做]<br>    D --&gt; G[命令栈控制台]<br>    G --&gt; H[撤销按钮]<br>    G --&gt; I[重做按钮]<br>    G --&gt; J[清空按钮]<br>    <br>    style A fill:#e1f5fe<br>    style C fill:#f3e5f5<br>    style D fill:#f3e5f5<br>    style E fill:#e8f5e8<br>    style F fill:#e8f5e8<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="状态管理" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-图像编辑机制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/55740.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/55740.html</id>
    <published>2025-11-23T10:27:41.000Z</published>
    <updated>2025-11-23T16:03:59.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>图像编辑机制是画布应用中处理图片元素显示、加载和交互的核心模块，处理图像元素的加载、渲染、滤镜应用和内存管理。它通过 ElementRenderer 类实现，主要负责图片资源的异步加载、纹理缓存管理、滤镜效果应用以及图像元素的渲染更新。</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── pages/<br>    └── canvas/<br>        └── Pixi_STM_modules/<br>            └── rendering/<br>                └── ElementRenderer.ts    <span class="hljs-comment"># 图像渲染核心实现</span><br></code></pre></td></tr></table></figure><ul><li><code>PixiJS</code>：WebGL 渲染引擎，提供图像渲染和滤镜支持</li><li><code>PIXI.Assets</code>：资源加载系统，用于异步加载图像资源</li><li><code>PIXI.Sprite</code>：用于显示图像的显示对象</li><li><code>PIXI.Filter</code>：图像滤镜系统，支持模糊、亮度、灰度等效果</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-ElementRenderer-renderElements-参数"><a href="#2-1-ElementRenderer-renderElements-参数" class="headerlink" title="2.1 ElementRenderer.renderElements 参数"></a>2.1 ElementRenderer.renderElements 参数</h4><p>图像渲染通过 <a href="\src\pages\canvas\Pixi_STM_modules\rendering\ElementRenderer.ts#L57-L157">renderElements</a> 方法实现。</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>是</td><td>无</td><td>包含所有画布元素的数据对象</td></tr><tr><td>elementLayer</td><td>PIXI.Container</td><td>是</td><td>无</td><td>用于承载所有可视元素的容器</td></tr><tr><td>destroyed</td><td>boolean</td><td>是</td><td>false</td><td>标识组件是否已被销毁</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore.ts 中调用图像渲染</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRenderer</span>.<span class="hljs-title function_">renderElements</span>(<br>  state.<span class="hljs-property">elements</span>,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementLayer</span>,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">destroyed</span><br>);<br></code></pre></td></tr></table></figure><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="\src\pages\canvas\Pixi_STM_modules\core\types.ts#L15-L15">CanvasElement</a> 图像相关属性</strong>：<br>定义了图像元素特有的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-comment">// ... 其他通用属性</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"image"</span>; <span class="hljs-comment">// 元素类型为图像</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图像资源 URL</span><br>  <span class="hljs-attr">filter</span>?: <span class="hljs-string">"none"</span> | <span class="hljs-string">"blur"</span> | <span class="hljs-string">"brightness"</span> | <span class="hljs-string">"grayscale"</span>; <span class="hljs-comment">// 图像滤镜</span><br>}<br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>图像编辑机制维护以下内部状态用于优化性能和管理资源：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>spriteMap</td><td>Map&lt;string, PIXI.Graphics \</td><td>HTMLText \</td><td>PIXI.Sprite&gt;</td><td>存储元素 ID 到 PIXI 显示对象的映射</td></tr><tr><td>textureCache</td><td>Map<string, PIXI.Texture=""></string,></td><td>图片纹理缓存，避免重复加载相同图片</td></tr><tr><td>loadingSet</td><td>Set<string></string></td><td>正在加载中的图片 URL 集合，防止重复加载</td></tr><tr><td>imageUpdateTimers</td><td>Map<string, NodeJS.Timeout=""></string,></td><td>图像元素更新检查定时器映射</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>图像编辑机制通过 Zustand 状态管理库订阅外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据，包括图像元素</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store 状态变更] --&gt; B{ElementRenderer 订阅}<br>    B --&gt; C{图像元素检测}<br>    C --&gt;|新图像元素| D[PIXI.Assets.load 异步加载]<br>    C --&gt;|已缓存图像| E[直接使用缓存纹理]<br>    D --&gt; F[纹理缓存]<br>    E --&gt; F<br>    F --&gt; G[创建/更新 PIXI.Sprite]<br>    G --&gt; H[PixiJS 渲染图像]<br>    <br>    style A fill:#e1f5fe<br>    style H fill:#e8f5e8<br>    style F fill:#fff3e0<br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManagerCore<br>    participant ER as ElementRenderer<br>    participant PA as PIXI.Assets<br>    participant ZS as Zustand Store<br>    <br>    U-&gt;&gt;SM: 插入图像元素<br>    SM-&gt;&gt;ZS: addElement (imageUrl)<br>    ZS-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;ER: 调用 renderElements<br>    ER-&gt;&gt;ER: 检测到图像元素<br>    ER-&gt;&gt;PA: PIXI.Assets.load(imageUrl)<br>    PA-&gt;&gt;ER: 返回纹理数据<br>    ER-&gt;&gt;ER: 缓存纹理并创建 Sprite<br>    ER-&gt;&gt;ER: 应用滤镜效果<br>    ER-&gt;&gt;ER: 添加到渲染层<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><p><strong>图像加载与渲染函数</strong>：当画布中添加或更新图像元素时触发，检查纹理缓存，如未缓存则异步加载图像资源，加载完成后创建 PIXI.Sprite 并应用滤镜</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 处理 Image 类型元素</span><br><span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">"image"</span> &amp;&amp; data.<span class="hljs-property">imageUrl</span>) {<br>  <span class="hljs-comment">// 检查纹理缓存</span><br>  <span class="hljs-keyword">const</span> texture = <span class="hljs-variable language_">this</span>.<span class="hljs-property">textureCache</span>.<span class="hljs-title function_">get</span>(data.<span class="hljs-property">imageUrl</span>);<br><br>  <span class="hljs-keyword">if</span> (!texture) {<br>    <span class="hljs-comment">// 未缓存，异步加载</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">loadingSet</span>.<span class="hljs-title function_">has</span>(data.<span class="hljs-property">imageUrl</span>)) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadingSet</span>.<span class="hljs-title function_">add</span>(data.<span class="hljs-property">imageUrl</span>);<br><br>      <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Assets</span>.<span class="hljs-title function_">load</span>(data.<span class="hljs-property">imageUrl</span>)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">loadedTexture</span>) =&gt;</span> {<br>          <span class="hljs-comment">// 加载完成，存入缓存</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">textureCache</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">imageUrl</span>, loadedTexture);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadingSet</span>.<span class="hljs-title function_">delete</span>(data.<span class="hljs-property">imageUrl</span>);<br><br>          <span class="hljs-comment">// 创建 Sprite 并应用滤镜</span><br>          <span class="hljs-keyword">const</span> sprite = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Sprite</span>(loadedTexture);<br>          <span class="hljs-comment">// ... 应用滤镜逻辑</span><br>        })<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {<br>          <span class="hljs-comment">// 处理加载错误</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadingSet</span>.<span class="hljs-title function_">delete</span>(data.<span class="hljs-property">imageUrl</span>);<br>        });<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 已缓存，直接使用</span><br>    <span class="hljs-keyword">const</span> sprite = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Sprite</span>(texture);<br>    <span class="hljs-comment">// ... 应用滤镜逻辑</span><br>  }<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>特殊处理</strong>:<ol><li><strong>纹理缓存</strong>：避免重复加载相同图像资源</li><li><strong>加载状态管理</strong>：防止同一图像的重复加载请求</li><li><strong>占位符</strong>：在图像加载过程中显示占位符</li><li><strong>滤镜</strong>：支持模糊、亮度增强、灰度三种滤镜效果</li><li><strong>内存管理</strong>：及时清理不再使用的纹理和定时器</li></ol></li></ul><h3 id="5-UI-与样式实现-UI-Implementation"><a href="#5-UI-与样式实现-UI-Implementation" class="headerlink" title="5. UI 与样式实现 (UI Implementation)"></a>5. UI 与样式实现 (UI Implementation)</h3><p>图像编辑机制通过 PIXI.Sprite 实现图像显示，并支持多种滤镜效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[图像元素] --&gt; B[PIXI.Sprite]<br>    B --&gt; C[纹理应用]<br>    C --&gt; D[滤镜处理]<br>    D --&gt; E[模糊滤镜]<br>    D --&gt; F[亮度增强滤镜]<br>    D --&gt; G[灰度滤镜]<br>    B --&gt; H[位置和尺寸设置]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style E fill:#e8f5e8<br>    style F fill:#e8f5e8<br>    style G fill:#e8f5e8<br>    style H fill:#fff3e0<br></code></pre></td></tr></table></figure><ol><li><strong>模糊滤镜</strong>：使用 PIXI.BlurFilter 实现</li><li><strong>亮度增强滤镜</strong>：使用 PIXI.ColorMatrixFilter 的 brightness 方法实现</li><li><strong>灰度滤镜</strong>：使用 PIXI.ColorMatrixFilter 的 grayscale 方法实现</li></ol><blockquote><p>图像元素采用异步加载机制，在网络较慢或图像较大时可能会出现短暂的占位符显示</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="PixiJS" scheme="https://zhongye1.github.io/Arknight-notes/tags/PixiJS/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-逻辑层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/62457.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/62457.html</id>
    <published>2025-11-23T09:45:00.000Z</published>
    <updated>2025-11-23T16:04:12.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>逻辑层是整个画布应用的中枢神经系统，负责协调状态管理层和渲染层之间的交互。它通过 StageManagerCore 类实现，主要处理用户交互、协调状态更新、管理渲染流程、维护交互状态</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── pages/<br>    └── canvas/<br>        ├── Pixi_stageManager.ts               <span class="hljs-comment"># StageManager 入口文件</span><br>        └── Pixi_STM_modules/                  <span class="hljs-comment"># StageManager 模块目录</span><br>            ├── core/<br>            │   ├── StageManagerCore.ts        <span class="hljs-comment"># 核心类</span><br>            │   └── types.ts                   <span class="hljs-comment"># 类型定义文件</span><br>            ├── rendering/<br>            │   ├── ElementRenderer.ts         <span class="hljs-comment"># 元素渲染器</span><br>            │   └── TransformerRenderer.ts     <span class="hljs-comment"># 变换控制器渲染器</span><br>            ├── interaction/<br>            │   └── InteractionHandler.ts      <span class="hljs-comment"># 交互处理器</span><br>            └── utils/<br>                └── cursorUtils.ts             <span class="hljs-comment"># 光标工具函数</span><br></code></pre></td></tr></table></figure><ul><li><code>PixiJS</code>：WebGL 渲染引擎，负责图形渲染</li><li><code>pixi-viewport</code>：视口管理插件，处理画布缩放和平移</li><li><code>Zustand</code>：状态管理库，与状态管理层对接</li><li><code>nanoid</code>：用于生成唯一 ID</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-StageManagerCore-构造函数参数"><a href="#2-1-StageManagerCore-构造函数参数" class="headerlink" title="2.1 StageManagerCore 构造函数参数"></a>2.1 StageManagerCore 构造函数参数</h4><p>StageManagerCore 类通过构造函数接收容器元素参数。</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>container</td><td>HTMLElement</td><td>是</td><td>无</td><td>用于挂载 PixiJS 应用的 DOM 容器</td></tr></tbody></table></div><p>代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 创建 StageManager 实例</span><br><span class="hljs-keyword">const</span> stageManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StageManagerCore</span>(containerElement);<br></code></pre></td></tr></table></figure><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L11-L38">StageManagerState</a> 类型</strong>：<br>定义了 StageManager 的核心状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StageManagerState</span> {<br>  <span class="hljs-attr">mode</span>: <span class="hljs-title class_">InteractionMode</span>; <span class="hljs-comment">// 当前交互模式</span><br>  <span class="hljs-attr">startPos</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> }; <span class="hljs-comment">// 起始坐标</span><br>  <span class="hljs-attr">currentId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前操作元素 ID</span><br>  <span class="hljs-attr">initialElementsMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始元素映射</span><br>  <span class="hljs-attr">initialGroupBounds</span>: {<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  } | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始群组边界</span><br>  <span class="hljs-attr">initialElementState</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始元素状态</span><br>  <span class="hljs-attr">resizeInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 调整大小初始状态</span><br>  <span class="hljs-attr">dragInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 拖拽初始状态</span><br>  <span class="hljs-attr">activeHandle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 激活的手柄</span><br>  <span class="hljs-attr">isSpacePressed</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 空格键是否按下</span><br>  <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 是否已销毁</span><br>}<br></code></pre></td></tr></table></figure><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L3-L8">InteractionMode</a> 类型</strong>：<br>定义了用户与画布交互的各种模式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">InteractionMode</span> =<br>  | <span class="hljs-string">"idle"</span> <span class="hljs-comment">// 空闲状态</span><br>  | <span class="hljs-string">"panning"</span> <span class="hljs-comment">// 画布平移</span><br>  | <span class="hljs-string">"selecting"</span> <span class="hljs-comment">// 选择元素</span><br>  | <span class="hljs-string">"dragging"</span> <span class="hljs-comment">// 拖拽元素</span><br>  | <span class="hljs-string">"resizing"</span> <span class="hljs-comment">// 调整元素大小</span><br>  | <span class="hljs-string">"drawing"</span> <span class="hljs-comment">// 绘制元素</span><br>  | <span class="hljs-string">"texting"</span> <span class="hljs-comment">// 文本编辑</span><br>  | <span class="hljs-string">"erasing"</span>; <span class="hljs-comment">// 擦除元素</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>StageManagerCore 维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>app</td><td>PIXI.Application</td><td>PixiJS 应用实例</td></tr><tr><td>viewport</td><td>Viewport</td><td>pixi-viewport 实例</td></tr><tr><td>elementLayer</td><td>PIXI.Container</td><td>元素图层容器</td></tr><tr><td>uiLayer</td><td>PIXI.Container</td><td>UI 图层容器</td></tr><tr><td>elementRenderer</td><td>ElementRenderer</td><td>元素渲染器实例</td></tr><tr><td>transformerRenderer</td><td>TransformerRenderer</td><td>变换控制器渲染器实例</td></tr><tr><td>interactionHandler</td><td>InteractionHandler</td><td>交互处理器实例</td></tr><tr><td>state</td><td>StageManagerState</td><td>交互状态对象</td></tr><tr><td>selectionRectGraphic</td><td>PIXI.Graphics</td><td>选区框图形对象</td></tr><tr><td>eraserGraphic</td><td>PIXI.Graphics</td><td>橡皮擦指示器图形对象</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>逻辑层通过 Zustand 状态管理库订阅外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据</td></tr><tr><td>selectedIds</td><td>string[]</td><td>当前选中的元素 ID 数组</td></tr><tr><td>tool</td><td>ToolType</td><td>当前工具类型</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store 状态变更] --&gt; B{StageManager 订阅}<br>    B --&gt; C{状态处理}<br>    C --&gt; D[ElementRenderer.renderElements]<br>    C --&gt; E[TransformerRenderer.renderTransformer]<br>    C --&gt; F[更新视口状态]<br>    C --&gt; G[更新光标样式]<br>    D --&gt; H[PixiJS 渲染元素]<br>    E --&gt; I[PixiJS 渲染变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style H fill:#e8f5e8<br>    style I fill:#e8f5e8<br>    style F fill:#fff3e0<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManagerCore<br>    participant IH as InteractionHandler<br>    participant ZS as Zustand Store<br>    participant ER as ElementRenderer<br>    participant TR as TransformerRenderer<br>    <br>    U-&gt;&gt;IH: 触发交互事件 (点击/拖拽等)<br>    IH-&gt;&gt;SM: 调用处理函数 (onPointerDown等)<br>    SM-&gt;&gt;SM: 更新内部状态 (mode, startPos等)<br>    SM-&gt;&gt;ZS: 更新画布数据 (addElement等)<br>    ZS-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;ER: 调用renderElements()<br>    SM-&gt;&gt;TR: 调用renderTransformer()<br>    ER-&gt;&gt;ER: 更新 PIXI 元素<br>    TR-&gt;&gt;TR: 更新变换控制器<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><p><strong>onPointerDown 函数</strong>：当用户在画布上按下鼠标时触发，根据当前工具和点击位置处理不同的交互逻辑（选择、绘制、拖拽等）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理防抖</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerDebounceSnapshot</span>()<br><br>  <span class="hljs-comment">// 获取当前状态</span><br>  <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>()<br>  <span class="hljs-keyword">const</span> tool = state.<span class="hljs-property">tool</span><br>  <span class="hljs-keyword">const</span> worldPos = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>)<br><br>  <span class="hljs-comment">// 根据工具类型处理不同逻辑</span><br>  <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'text'</span>) {<br>    <span class="hljs-comment">// 处理文本工具</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tool === <span class="hljs-string">'eraser'</span>) {<br>    <span class="hljs-comment">// 处理橡皮擦工具</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> &amp;&amp; e.<span class="hljs-property">target</span>.<span class="hljs-property">label</span>) {<br>    <span class="hljs-comment">// 处理元素点击</span><br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 处理绘制或选择</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p><strong>onPointerMove 函数</strong>：当用户在画布上移动鼠标时触发，根据当前交互模式处理不同的移动逻辑（绘制、拖拽、调整大小等）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> onPointerMove = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理防抖</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerDebounceSnapshot</span>()<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> === <span class="hljs-string">'idle'</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">const</span> state = useStore.<span class="hljs-title function_">getState</span>()<br>  <span class="hljs-keyword">const</span> currentPos = e.<span class="hljs-title function_">getLocalPosition</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>)<br><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span>) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'selecting'</span>:<br>      <span class="hljs-comment">// 处理选择框绘制</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'erasing'</span>:<br>      <span class="hljs-comment">// 处理橡皮擦操作</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'dragging'</span>:<br>      <span class="hljs-comment">// 处理元素拖拽</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'resizing'</span>:<br>      <span class="hljs-comment">// 处理元素调整大小</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'drawing'</span>:<br>      <span class="hljs-comment">// 处理元素绘制</span><br>      <span class="hljs-keyword">break</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="5-UI-与样式实现-UI-Implementation"><a href="#5-UI-与样式实现-UI-Implementation" class="headerlink" title="5. UI 与样式实现 (UI Implementation)"></a>5. UI 与样式实现 (UI Implementation)</h3><p>逻辑层通过管理不同图层来实现 UI 布局：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Viewport] --&gt; B[elementLayer]<br>    A --&gt; C[uiLayer]<br>    B --&gt; D[图形元素]<br>    C --&gt; E[选区框]<br>    C --&gt; F[橡皮擦指示器]<br>    C --&gt; G[变换控制器]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#e8f5e8<br>    style D fill:#fce4ec<br>    style E fill:#fff3e0<br>    style F fill:#fff3e0<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure><p>使用 PixiJS 的容器系统管理图层，分为元素层和 UI 层，通过 PIXI.Graphics API 实现图形绘制，通过 CSS 控制光标样式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="PixiJS" scheme="https://zhongye1.github.io/Arknight-notes/tags/PixiJS/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-状态管理层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/61173.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/61173.html</id>
    <published>2025-11-23T09:17:00.000Z</published>
    <updated>2025-11-23T16:04:20.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>状态管理层管理画布元素数据、选中状态、工具状态、剪贴板数据等核心业务数据，是整个画布应用的数据核心，负责维护所有画布元素的状态信息和用户交互相关的全局状态。它采用了 Zustand 作为状态管理库，实现了数据的集中管理和状态变更的响应式更新</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>└── stores/<br>    └── canvasStore.ts        <span class="hljs-comment"># Zustand 状态管理核心文件</span><br></code></pre></td></tr></table></figure><ul><li><code>Zustand</code>：轻量级状态管理库，用于管理全局状态</li><li><code>nanoid</code>：用于生成唯一 ID</li><li><code>structuredClone</code>：用于深拷贝状态数据</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-useStore-参数"><a href="#2-1-useStore-参数" class="headerlink" title="2.1 useStore 参数"></a>2.1 useStore 参数</h4><p>状态管理模块通过 <a href="/src/stores/canvasStore.ts#L35-L136">useStore</a> Hook 提供状态访问和更新功能。</p><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>setTool</td><td>Function</td><td>是</td><td>无</td><td>设置当前使用的工具类型</td></tr><tr><td>addElement</td><td>Function</td><td>是</td><td>无</td><td>添加新元素到画布</td></tr><tr><td>updateElement</td><td>Function</td><td>是</td><td>无</td><td>更新指定元素的属性</td></tr><tr><td>removeElements</td><td>Function</td><td>是</td><td>无</td><td>从画布中移除指定元素</td></tr><tr><td>setSelected</td><td>Function</td><td>是</td><td>无</td><td>设置当前选中的元素</td></tr><tr><td>setEditingId</td><td>Function</td><td>是</td><td>无</td><td>设置当前正在编辑的元素</td></tr><tr><td>copyElements</td><td>Function</td><td>是</td><td>无</td><td>复制指定元素到剪贴板</td></tr><tr><td>pasteElements</td><td>Function</td><td>是</td><td>无</td><td>从剪贴板粘贴元素到画布</td></tr></tbody></table></div><p>代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 设置工具类型</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">setTool</span>(<span class="hljs-string">"rect"</span>);<br><br><span class="hljs-comment">// 添加元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>({<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">"element1"</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"rect"</span>,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">150</span>,<br>  <span class="hljs-attr">fill</span>: <span class="hljs-string">"#ff0000"</span>,<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-string">"#000000"</span>,<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">2</span>,<br>});<br><br><span class="hljs-comment">// 更新元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-string">"element1"</span>, { <span class="hljs-attr">fill</span>: <span class="hljs-string">"#00ff00"</span> });<br><br><span class="hljs-comment">// 移除元素</span><br>useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-string">"element1"</span>]);<br></code></pre></td></tr></table></figure><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15">CanvasElement</a> 类型</strong>：<br>定义了画布上所有元素的基本属性和可选属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 元素唯一标识符</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span>; <span class="hljs-comment">// 元素类型</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素左上角 x 坐标</span><br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素左上角 y 坐标</span><br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素宽度</span><br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素高度</span><br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 填充颜色</span><br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 描边颜色</span><br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 描边宽度</span><br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 透明度</span><br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][]; <span class="hljs-comment">// 点坐标数组（用于线条类元素）</span><br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 旋转角度（弧度制）</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本内容（HTML 格式）</span><br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 字体大小</span><br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 字体族</span><br>  <span class="hljs-attr">textAlign</span>?: <span class="hljs-string">"left"</span> | <span class="hljs-string">"center"</span> | <span class="hljs-string">"right"</span>; <span class="hljs-comment">// 文本对齐方式</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图片 URL</span><br>  <span class="hljs-attr">filter</span>?: <span class="hljs-string">"none"</span> | <span class="hljs-string">"blur"</span> | <span class="hljs-string">"brightness"</span> | <span class="hljs-string">"grayscale"</span>; <span class="hljs-comment">// 图片滤镜</span><br>  <span class="hljs-attr">radius</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 圆角半径</span><br>}<br></code></pre></td></tr></table></figure><p><strong><a href="/src/stores/canvasStore.ts#L6-L21">ToolType</a> 类型</strong>：<br>定义了用户可选择的工具类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToolType</span> =<br>  | <span class="hljs-string">"select"</span> <span class="hljs-comment">// 选择工具</span><br>  | <span class="hljs-string">"hand"</span> <span class="hljs-comment">// 手型工具</span><br>  | <span class="hljs-string">"rect"</span> <span class="hljs-comment">// 矩形工具</span><br>  | <span class="hljs-string">"circle"</span> <span class="hljs-comment">// 圆形工具</span><br>  | <span class="hljs-string">"triangle"</span> <span class="hljs-comment">// 三角形工具</span><br>  | <span class="hljs-string">"diamond"</span> <span class="hljs-comment">// 菱形工具</span><br>  | <span class="hljs-string">"line"</span> <span class="hljs-comment">// 直线工具</span><br>  | <span class="hljs-string">"arrow"</span> <span class="hljs-comment">// 箭头工具</span><br>  | <span class="hljs-string">"pencil"</span> <span class="hljs-comment">// 铅笔工具</span><br>  | <span class="hljs-string">"text"</span> <span class="hljs-comment">// 文本工具</span><br>  | <span class="hljs-string">"image"</span> <span class="hljs-comment">// 图片工具</span><br>  | <span class="hljs-string">"eraser"</span>; <span class="hljs-comment">// 橡皮擦工具</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><p>状态管理层维护以下内部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>tool</td><td><a href="/src/stores/canvasStore.ts#L6-L21">ToolType</a></td><td>当前选中的工具类型</td></tr><tr><td>elements</td><td>Record&lt;string, [CanvasElement](/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15)&gt;</td><td>所有画布元素的集合</td></tr><tr><td>selectedIds</td><td>string[]</td><td>当前选中的元素 ID 数组</td></tr><tr><td>editingId</td><td>string \</td><td>null</td><td>当前正在编辑的元素 ID</td></tr><tr><td>clipboard</td><td><a href="/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15">CanvasElement</a>[] \</td><td>null</td><td>剪贴板数据</td></tr><tr><td>pasteOffset</td><td>number</td><td>粘贴偏移计数</td></tr><tr><td>currentStyle</td><td>Object</td><td>当前样式设置</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[Zustand Store 状态变更] --&gt; B{订阅者监听}<br>    B --&gt; C[StageManager 订阅]<br>    B --&gt; D[UI 组件订阅]<br>    C --&gt; E[触发渲染层更新]<br>    D --&gt; F[触发 UI 更新]<br>    <br>    style A fill:#e1f5fe<br>    style E fill:#e8f5e8<br>    style F fill:#fff3e0<br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant C as CanvasStore<br>    participant SM as StageManager<br>    participant R as 渲染层<br>    <br>    U-&gt;&gt;C: 调用 Action (如 addElement)<br>    C-&gt;&gt;C: 更新内部状态<br>    C-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;R: 触发重新渲染<br>    R-&gt;&gt;R: 更新 PIXI 对象<br>    R-&gt;&gt;U: 显示更新结果<br></code></pre></td></tr></table></figure><h4 id="4-2-核心函数"><a href="#4-2-核心函数" class="headerlink" title="4.2 核心函数"></a>4.2 核心函数</h4><p><strong>addElement 函数</strong>：当用户创建新元素时调用，创建新元素并添加到 elements 集合中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({<br>    <span class="hljs-attr">elements</span>: { ...state.<span class="hljs-property">elements</span>, [el.<span class="hljs-property">id</span>]: el },<br>  }));<br></code></pre></td></tr></table></figure><p><strong>updateElement 函数</strong>：当用户修改元素属性时调用，更新指定元素的属性并保持其他元素不变</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params">id, attrs</span>) =&gt;</span><br>  <span class="hljs-title function_">originalSet</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">elements</span>[id]) <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">return</span> {<br>      <span class="hljs-attr">elements</span>: {<br>        ...state.<span class="hljs-property">elements</span>,<br>        [id]: { ...state.<span class="hljs-property">elements</span>[id], ...attrs },<br>      },<br>    };<br>  });<br></code></pre></td></tr></table></figure><p>状态管理层作为纯数据层，不直接涉及 UI 和样式实现，但为上层 UI 提供了必要的状态支持，通过状态结构支持上层组件的布局逻辑和状态中的样式属性支持上层组件的样式实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Zustand" scheme="https://zhongye1.github.io/Arknight-notes/tags/Zustand/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-canvas项目相关-渲染层</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/8350.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/8350.html</id>
    <published>2025-11-23T06:56:37.000Z</published>
    <updated>2025-11-23T16:06:10.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>渲染层是基于 PixiJS 构建的可视化层，负责将存储在 Zustand 状态管理器中的画布元素数据转化为可视化的图形界面，并处理用户的交互操作。它主要包括元素渲染（ElementRenderer）和变换控制器渲染（TransformerRenderer）两大部分，分别负责绘制元素本身和元素的选中状态、控制手柄等辅助 UI。</p><p>其项目结构树如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nix">src<span class="hljs-symbol">/</span><br>└── pages<span class="hljs-symbol">/</span><br>    └── canvas<span class="hljs-symbol">/</span><br>        ├── Pixi_stageManager.ts               <span class="hljs-comment"># 整合StageManager各模块的入口文件</span><br>        ├── index.tsx                          <span class="hljs-comment"># 画布页面组件，整合渲染层到React组件中</span><br>        └── Pixi_STM_modules<span class="hljs-symbol">/</span>                  <span class="hljs-comment"># StageManager模块目录</span><br>            ├── STM_modules.md                 <span class="hljs-comment"># 模块设计文档</span><br>            ├── core<span class="hljs-symbol">/</span><br>            │   ├── StageManagerCore.ts        <span class="hljs-comment"># 核心类，整合渲染、交互和状态管理</span><br>            │   └── types.ts                   <span class="hljs-comment"># 类型定义文件</span><br>            ├── rendering<span class="hljs-symbol">/</span><br>            │   ├── ElementRenderer.ts         <span class="hljs-comment"># 元素渲染器，负责渲染各类画布元素</span><br>            │   └── TransformerRenderer.ts     <span class="hljs-comment"># 变换控制器渲染器，负责渲染选中元素的手柄等</span><br>            ├── interaction<span class="hljs-symbol">/</span><br>            │   └── InteractionHandler.ts      <span class="hljs-comment"># 交互处理器，绑定和处理各种交互事件</span><br>            └── utils<span class="hljs-symbol">/</span><br>                └── cursorUtils.ts             <span class="hljs-comment"># 光标工具函数</span><br></code></pre></td></tr></table></figure><p>该模块主要负责将状态管理层的数据渲染成可视化图形，并处理用户交互反馈</p><ul><li><code>pixi.js</code>：WebGL 渲染引擎</li><li><code>pixi-viewport</code>：视口管理插件</li><li><code>zustand</code>：状态管理库（虽然不是渲染层直接依赖，但与其紧密协作）</li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><p>渲染层接收来自逻辑层的 props 参数，用于驱动元素渲染和交互控制。这些参数主要包括元素数据、状态信息和事件回调函数。</p><h4 id="2-1-ElementRenderer-renderElements-方法参数"><a href="#2-1-ElementRenderer-renderElements-方法参数" class="headerlink" title="2.1 ElementRenderer.renderElements 方法参数"></a>2.1 ElementRenderer.renderElements 方法参数</h4><p>ElementRenderer 负责将画布元素数据渲染为 PIXI 可视化对象，其 <a href="src/pages/canvas/Pixi_STM_modules/rendering/ElementRenderer.ts#L57-L157">renderElements</a> 方法接收以下参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">类型</th><th style="text-align:left">必填</th><th style="text-align:left">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">elements</td><td style="text-align:left">Record<string, CanvasElement=""></string,></td><td style="text-align:left">是</td><td style="text-align:left">无</td><td style="text-align:left">包含所有画布元素的数据对象</td></tr><tr><td style="text-align:left">elementLayer</td><td style="text-align:left">PIXI.Container</td><td style="text-align:left">是</td><td style="text-align:left">无</td><td style="text-align:left">用于承载所有可视元素的容器</td></tr><tr><td style="text-align:left">destroyed</td><td style="text-align:left">boolean</td><td style="text-align:left">是</td><td style="text-align:left">false</td><td style="text-align:left">标识组件是否已被销毁</td></tr></tbody></table></div><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// elements对象结构示例</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-string">"element1"</span>: <span class="hljs-punctuation">{</span><br><span class="hljs-symbol">    id:</span> <span class="hljs-string">"element1"</span>,<br><span class="hljs-symbol">    type:</span> <span class="hljs-string">"rect"</span>,<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">200</span>,<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">150</span>,<br><span class="hljs-symbol">    fill:</span> <span class="hljs-string">"#ff0000"</span><br>  <span class="hljs-punctuation">}</span>,<br>  <span class="hljs-string">"element2"</span>: <span class="hljs-punctuation">{</span><br><span class="hljs-symbol">    id:</span> <span class="hljs-string">"element2"</span>,<br><span class="hljs-symbol">    type:</span> <span class="hljs-string">"text"</span>,<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">50</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">50</span>,<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">300</span>,<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">100</span>,<br><span class="hljs-symbol">    text:</span> <span class="hljs-string">"&lt;p&gt;示例文本&lt;/p&gt;"</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p><a href="src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a>: PIXI.Container - PIXI.js 中的容器对象，用于承载所有画布元素的可视化对象。ElementRenderer 会将创建的 PIXI 对象添加到这个容器中，以便在画布上显示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在StageManagerCore.ts中创建elementLayer</span><br><span class="hljs-keyword">private</span> elementLayer: PIXI.Container = new PIXI.Container()<br><span class="hljs-comment">// 然后传给ElementRenderer</span><br><span class="hljs-keyword">this</span>.elementRenderer.renderElements(elements, <span class="hljs-keyword">this</span>.elementLayer, <span class="hljs-keyword">this</span>.state.destroyed)<br></code></pre></td></tr></table></figure><p>destroyed: boolean - 标识渲染器是否已被销毁。当组件被销毁时，此参数防止在销毁后继续执行渲染操作，避免内存泄漏。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderElements</span>(<span class="hljs-params"><span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;, <span class="hljs-attr">elementLayer</span>: PIXI.<span class="hljs-title class_">Container</span>, <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span></span>) {<br>  <span class="hljs-keyword">if</span> (destroyed) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已销毁，直接返回不执行渲染</span><br>  <span class="hljs-comment">// ... 其他渲染逻辑</span><br>}<br></code></pre></td></tr></table></figure><h4 id="2-2-TransformerRenderer-renderTransformer-方法参数"><a href="#2-2-TransformerRenderer-renderTransformer-方法参数" class="headerlink" title="2.2 TransformerRenderer.renderTransformer 方法参数"></a>2.2 TransformerRenderer.renderTransformer 方法参数</h4><p>TransformerRenderer 负责渲染选中元素的变换控制器（手柄、边框等），其 <a href="src/pages/canvas/Pixi_STM_modules/rendering/TransformerRenderer.ts#L31-L182">renderTransformer</a> 方法接收以下参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">elements</td><td style="text-align:left">Record<string, CanvasElement=""></string,></td><td style="text-align:left">所有画布元素的数据</td></tr><tr><td style="text-align:left">selectedIds</td><td style="text-align:left">string[]</td><td style="text-align:left">当前选中元素的 ID 数组</td></tr><tr><td style="text-align:left">spriteMap</td><td style="text-align:left">Map<string, PIXI.DisplayObject=""></string,></td><td style="text-align:left">元素 ID 到 PIXI 可视化对象的映射</td></tr><tr><td style="text-align:left">onHandleDown</td><td style="text-align:left">Function</td><td style="text-align:left">手柄按下事件的回调函数</td></tr><tr><td style="text-align:left">viewportScale</td><td style="text-align:left">number</td><td style="text-align:left">当前视口的缩放比例</td></tr></tbody></table></div><p>elements: Record<string, CanvasElement=""> - 与 ElementRenderer 中的 elements 相同，提供所有画布元素的数据。TransformerRenderer 需要访问元素数据来计算选中元素的边界框和位置信息。</string,></p><p>selectedIds: string[] - 包含当前选中元素 ID 的数组。TransformerRenderer 根据这个数组决定是否以及如何绘制变换控制器（选中框和手柄）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// selectedIds数组示例</span><br>;<span class="hljs-selector-attr">[<span class="hljs-string">'element1'</span>, <span class="hljs-string">'element3'</span>]</span> <span class="hljs-comment">// 表示element1和element3被选中</span><br></code></pre></td></tr></table></figure><p>spriteMap: Map&lt;string, PIXI.Graphics | PIXI.HTMLText | PIXI.Sprite&gt; - 提供元素 ID 到 PIXI 可视化对象的映射。TransformerRenderer 需要访问实际的 PIXI 对象来准确计算元素的边界（特别是文本元素）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// spriteMap结构示例</span><br><span class="hljs-built_in">Map</span>(<span class="hljs-number">2</span>) {<br>  <span class="hljs-string">"element1"</span> =&gt; Graphics {},     <span class="hljs-comment">// 矩形元素的PIXI.Graphics对象</span><br>  <span class="hljs-string">"element2"</span> =&gt; HTMLText {}      <span class="hljs-comment">// 文本元素的PIXI.HTMLText对象</span><br>}<br></code></pre></td></tr></table></figure><p>onHandleDown: Function - 手柄按下事件的回调函数。当用户点击变换控制器上的手柄时，会调用这个函数开始变换操作（如缩放、旋转）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在StageManagerCore.ts中定义并传递给TransformerRenderer</span><br><span class="hljs-keyword">private</span> onHandleDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">e</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span>, <span class="hljs-attr">handle</span>: <span class="hljs-title class_">HandleType</span> | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>, <span class="hljs-attr">elementId</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> {<br>  <span class="hljs-comment">// 处理手柄按下事件</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">mode</span> = <span class="hljs-string">'resizing'</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">activeHandle</span> = handle <span class="hljs-keyword">as</span> <span class="hljs-title class_">HandleType</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// ... 其他逻辑</span><br>}<br></code></pre></td></tr></table></figure><p>viewportScale: number - 当前视口的缩放比例。TransformerRenderer 使用这个值来调整手柄和控制器的大小，确保在不同缩放级别下都有合适的尺寸。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在StageManagerCore.ts中获取并传递视口缩放比例</span><br><span class="hljs-keyword">this</span>.transformerRenderer.renderTransformer(<br>  elements,<br>  selectedIds,<br>  <span class="hljs-keyword">this</span>.elementRenderer.getSpriteMap(),<br>  <span class="hljs-keyword">this</span>.onHandleDown,<br>  <span class="hljs-keyword">this</span>.viewport.scale.x, <span class="hljs-comment">// 传递视口缩放比例</span><br>)<br></code></pre></td></tr></table></figure><h3 id="2-3-核心类型定义"><a href="#2-3-核心类型定义" class="headerlink" title="2.3 核心类型定义"></a>2.3 核心类型定义</h3><p>渲染层涉及到的关键类型定义如下：</p><h4 id="CanvasElement-类型"><a href="#CanvasElement-类型" class="headerlink" title="CanvasElement 类型"></a>CanvasElement 类型</h4><p>定义了画布元素的基本属性和可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>:<br>    | <span class="hljs-string">"rect"</span><br>    | <span class="hljs-string">"circle"</span><br>    | <span class="hljs-string">"triangle"</span><br>    | <span class="hljs-string">"text"</span><br>    | <span class="hljs-string">"image"</span><br>    | <span class="hljs-string">"line"</span><br>    | <span class="hljs-string">"arrow"</span><br>    | <span class="hljs-string">"pencil"</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 根据元素类型可能包含额外属性</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 图片元素</span><br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][]; <span class="hljs-comment">// 线条/铅笔元素</span><br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文本元素</span><br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 透明度</span><br>  <span class="hljs-attr">radius</span>?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 圆角矩形</span><br>}<br></code></pre></td></tr></table></figure><h4 id="HandleType-类型"><a href="#HandleType-类型" class="headerlink" title="HandleType 类型"></a>HandleType 类型</h4><p>定义了变换控制器上各种手柄的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">HandleType</span> =<br>  | <span class="hljs-string">"tl"</span> <span class="hljs-comment">// top-left 左上角</span><br>  | <span class="hljs-string">"t"</span> <span class="hljs-comment">// top 顶部中间</span><br>  | <span class="hljs-string">"tr"</span> <span class="hljs-comment">// top-right 右上角</span><br>  | <span class="hljs-string">"r"</span> <span class="hljs-comment">// right 右侧中间</span><br>  | <span class="hljs-string">"br"</span> <span class="hljs-comment">// bottom-right 右下角</span><br>  | <span class="hljs-string">"b"</span> <span class="hljs-comment">// bottom 底部中间</span><br>  | <span class="hljs-string">"bl"</span> <span class="hljs-comment">// bottom-left 左下角</span><br>  | <span class="hljs-string">"l"</span> <span class="hljs-comment">// left 左侧中间</span><br>  | <span class="hljs-string">"p0"</span> <span class="hljs-comment">// 线段起点</span><br>  | <span class="hljs-string">"p1"</span> <span class="hljs-comment">// 线段终点</span><br>  | <span class="hljs-string">"rotate"</span>; <span class="hljs-comment">// 旋转手柄</span><br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><p>渲染层采用内外结合的状态管理模式，既维护自身的局部状态，又与外部的 Zustand 状态管理库协同工作。</p><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>渲染层维护一组局部状态，用于管理 PIXI 对象和渲染优化：</p><div class="table-container"><table><thead><tr><th style="text-align:left">状态名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>spriteMap</code></td><td style="text-align:left">`Map&lt;string, PIXI.Graphics \</td><td style="text-align:left">PIXI.HTMLText \</td><td>PIXI.Sprite&gt;`</td><td>存储元素 ID 到 PIXI 图形对象的映射关系，用于快速查找和更新元素</td></tr><tr><td style="text-align:left"><code>textureCache</code></td><td style="text-align:left"><code>Map&lt;string, PIXI.Texture&gt;</code></td><td style="text-align:left">图片纹理缓存，避免重复加载相同图片</td></tr><tr><td style="text-align:left"><code>loadingSet</code></td><td style="text-align:left"><code>Set&lt;string&gt;</code></td><td style="text-align:left">正在加载中的图片 URL 集合，防止重复加载</td></tr><tr><td style="text-align:left"><code>imageUpdateTimers</code></td><td style="text-align:left"><code>Map&lt;string, NodeJS.Timeout&gt;</code></td><td style="text-align:left">图像元素更新检查定时器映射</td></tr><tr><td style="text-align:left"><code>transformerGraphic</code></td><td style="text-align:left"><code>PIXI.Graphics</code></td><td style="text-align:left">用于绘制变换控制器（选中框、手柄等）的图形对象</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// ElementRenderer 内部状态示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">textureCache</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Texture</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">loadingSet</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">imageUpdateTimers</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><br><span class="hljs-comment">// TransformerRenderer 内部状态示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">transformerGraphic</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Graphics</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Graphics</span>()<br><br></code></pre></td></tr></table></figure><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>渲染层通过订阅 Zustand 状态管理库中的 <a href="src/stores/canvasStore.ts#L35-L136">canvasStore</a> 来获取画布元素数据和选中状态：</p><div class="table-container"><table><thead><tr><th style="text-align:left">状态名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>elements</code></td><td style="text-align:left"><code>Record&lt;string, CanvasElement&gt;</code></td><td style="text-align:left">所有画布元素的数据对象</td></tr><tr><td style="text-align:left"><code>selectedIds</code></td><td style="text-align:left"><code>string[]</code></td><td style="text-align:left">当前选中元素的 ID 数组</td></tr></tbody></table></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// StageManagerCore.ts 中订阅外部状态的方式</span><br>useStore.<span class="hljs-title function_">subscribe</span>(<br>  <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">elements</span>: state.<span class="hljs-property">elements</span>, <span class="hljs-attr">selectedIds</span>: state.<span class="hljs-property">selectedIds</span> }),<br>  <span class="hljs-function">(<span class="hljs-params">{ elements, selectedIds }</span>) =&gt;</span> {<br>    <span class="hljs-comment">// 当 elements 或 selectedIds 发生变化时触发重新渲染</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();<br>  },<br>  { <span class="hljs-attr">equalityFn</span>: shallow }<br>);<br></code></pre></td></tr></table></figure><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><p>渲染层通过增量更新（Diffing）算法实现高效的状态同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A[Zustand Store 状态变更] --&gt; B{StageManager 订阅}<br>B --&gt; C{Diff 算法对比}<br>C --&gt;|新增元素| D[创建 PIXI 对象]<br>C --&gt;|更新元素| E[更新 PIXI 对象属性]<br>C --&gt;|删除元素| F[销毁 PIXI 对象]<br>D --&gt; G[添加到 spriteMap]<br>E --&gt; G<br>F --&gt; H[从 spriteMap 移除]<br>G --&gt; I[PixiJS 渲染]<br>H --&gt; I<br>    style A fill:#e1f5fe<br>    style I fill:#e8f5e8<br>    style G fill:#fff3e0<br>    style H fill:#ffebee<br><br></code></pre></td></tr></table></figure><h3 id="4-逻辑流程-Logic-Flow"><a href="#4-逻辑流程-Logic-Flow" class="headerlink" title="4. 逻辑流程 (Logic Flow)"></a>4. 逻辑流程 (Logic Flow)</h3><h4 id="4-1-交互时序图-Mermaid"><a href="#4-1-交互时序图-Mermaid" class="headerlink" title="4.1 交互时序图 (Mermaid)"></a>4.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>participant U as 用户<br>participant SM as StageManagerCore<br>participant ER as ElementRenderer<br>participant TR as TransformerRenderer<br>participant S as Zustand Store<br><br>    U-&gt;&gt;SM: 触发状态变更 (添加/更新元素)<br>    SM-&gt;&gt;S: 更新elements数据<br>    S-&gt;&gt;SM: 通知状态变更<br>    SM-&gt;&gt;ER: 调用renderElements()<br>    ER-&gt;&gt;ER: 根据元素类型创建/更新PIXI对象<br>    ER-&gt;&gt;SM: 更新spriteMap<br>    <br>    U-&gt;&gt;SM: 选择元素<br>    SM-&gt;&gt;S: 更新selectedIds<br>    S-&gt;&gt;SM: 通知选中状态变更<br>    SM-&gt;&gt;TR: 调用renderTransformer()<br>    TR-&gt;&gt;TR: 根据选中元素绘制变换控制器<br></code></pre></td></tr></table></figure><hr><h4 id="4-2-核心函数解析"><a href="#4-2-核心函数解析" class="headerlink" title="4.2 核心函数解析"></a>4.2 核心函数解析</h4><ul><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/rendering/ElementRenderer.ts#L57-L157">ElementRenderer.renderElements()</a></strong>:</p><ul><li><p><strong>触发时机</strong>: 当画布元素数据发生变更时，通过状态订阅机制触发。每当 Zustand store 中的 <a href="/src/stores/canvasStore.ts#L44-L44">elements</a> 对象发生变化时，StageManagerCore 会调用此方法进行重新渲染。</p></li><li><p><strong>逻辑闭环</strong>: 遍历所有元素数据，根据元素类型创建或更新对应的 PIXI 对象，并将其添加到容器中。通过 diff 算法比较现有 spriteMap 和新元素数据（遍历 spriteMap 中的所有元素 ID，检查哪些元素在新的 elements 数据中不存在，这些元素需要被删除，遍历新的 elements 数据中的所有元素 ID，检查哪些是新增的元素需要创建，哪些是已存在的元素需要更新），确定需要创建、更新或删除的元素，最终保持 PIXI 对象与数据状态同步。</p></li><li><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 核心渲染逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderElements</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">elementLayer</span>: PIXI.<span class="hljs-title class_">Container</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">destroyed</span>: <span class="hljs-built_in">boolean</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (destroyed) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 获取当前所有元素ID</span><br>  <span class="hljs-keyword">const</span> elementIds = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(elements);<br><br>  <span class="hljs-comment">// 删除已移除的元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">keys</span>()) {<br>    <span class="hljs-keyword">if</span> (!elementIds.<span class="hljs-title function_">includes</span>(id)) {<br>      <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id)!;<br>      sprite.<span class="hljs-title function_">destroy</span>({ <span class="hljs-attr">children</span>: <span class="hljs-literal">true</span> });<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">delete</span>(id);<br>    }<br>  }<br><br>  <span class="hljs-comment">// 更新或创建元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> elementIds) {<br>    <span class="hljs-keyword">const</span> data = elements[id];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">has</span>(id)) {<br>      <span class="hljs-comment">// 更新现有元素</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateElement</span>(data, <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id)!);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// 创建新元素</span><br>      <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createElement</span>(data);<br>      elementLayer.<span class="hljs-title function_">addChild</span>(sprite);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">set</span>(id, sprite);<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>差异化渲染处理</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 根据不同类型元素进行差异化渲染处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">CanvasElement</span>): <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span> {<br>  <span class="hljs-keyword">switch</span> (data.<span class="hljs-property">type</span>) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'rect'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'circle'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'triangle'</span>:<br>      <span class="hljs-comment">// 几何图形处理逻辑：使用Graphics API绘制形状</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createGraphicsElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>:<br>      <span class="hljs-comment">// 文本元素处理逻辑：使用HTMLText组件渲染富文本</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createTextElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'image'</span>:<br>      <span class="hljs-comment">// 图片元素处理逻辑：加载纹理并创建Sprite</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createImageElement</span>(data);<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'line'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'arrow'</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'pencil'</span>:<br>      <span class="hljs-comment">// 线条/铅笔元素处理逻辑：使用Graphics API绘制线条</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createLineElement</span>(data);<br><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Unsupported element type: <span class="hljs-subst">${data.<span class="hljs-keyword">type</span>}</span>`</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/rendering/TransformerRenderer.ts#L31-L182">TransformerRenderer.renderTransformer()</a></strong>:</p><ul><li><p><strong>触发时机</strong>: 当选中元素发生变更时触发。每当 Zustand store 中的 <a href="/src/stores/canvasStore.ts#L45-L45">selectedIds</a> 数组发生变化时，StageManagerCore 会调用此方法更新变换控制器的显示。</p></li><li><p><strong>逻辑闭环</strong>: 根据选中元素的数量和类型，绘制相应的变换控制器（如缩放手柄、旋转手柄等）。通过清除之前的控制器图形并根据当前选中状态重新绘制，保持变换控制器与选中状态同步。</p></li><li><p><strong>核心实现</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 变换控制器渲染逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">renderTransformer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, PIXI.<span class="hljs-title class_">DisplayObject</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">onHandleDown</span>: (</span><br><span class="hljs-params">    e: PIXI.FederatedPointerEvent,</span><br><span class="hljs-params">    handle: HandleType | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>,</span><br><span class="hljs-params">    elementId: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  ) =&gt; <span class="hljs-built_in">void</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">viewportScale</span>: <span class="hljs-built_in">number</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 清除之前的变换控制器</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">clear</span>();<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-comment">// 单个元素选中逻辑</span><br>    <span class="hljs-keyword">const</span> element = elements[selectedIds[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">const</span> sprite = spriteMap.<span class="hljs-title function_">get</span>(selectedIds[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (sprite) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawSingleElementTransformer</span>(element, sprite, onHandleDown, viewportScale);<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 多个元素选中逻辑</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawMultiElementTransformer</span>(elements, selectedIds, spriteMap, onHandleDown, viewportScale);<br>  }<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="UI-与样式实现-UI-Implementation"><a href="#UI-与样式实现-UI-Implementation" class="headerlink" title="UI 与样式实现 (UI Implementation)"></a>UI 与样式实现 (UI Implementation)</h4><ul><li><p><strong>布局策略</strong>: 使用 PIXI 的容器系统进行布局管理，分为 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a>（元素层）和 <a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L37-L37">uiLayer</a>（UI 层）两个层级，通过坐标系统定位元素</p><ul><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L36-L36">elementLayer</a></strong>: 用于承载所有画布元素的容器层，包括矩形、圆形、文本、图像等各种元素的 PIXI 对象都添加到这一层。这是渲染层的主要内容，负责显示用户创建的所有图形元素。</p></li><li><p><strong><a href="/src/pages/canvas/Pixi_STM_modules/core/StageManagerCore.ts#L37-L37">uiLayer</a></strong>: 用于承载所有 UI 元素的容器层，包括选区框、橡皮擦指示器、变换控制器等辅助 UI 元素。这一层位于元素层之上，确保 UI 元素始终显示在图形元素的前面。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore.ts 中创建两个容器层</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">elementLayer</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Container</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Container</span>()<br><span class="hljs-keyword">private</span> <span class="hljs-attr">uiLayer</span>: <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">Container</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Container</span>()<br><br><span class="hljs-comment">// 将两个容器层添加到视口中</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">addChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementLayer</span>)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">addChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiLayer</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>样式方案</strong>:</p><ul><li>几何图形使用 PIXI 的绘图 API 进行绘制，支持描边、填充、透明度等样式</li><li>文本元素使用 HTMLText 组件支持富文本渲染</li><li>图片元素使用 PIXI.Sprite 并支持滤镜效果（模糊、亮度、灰度等）</li><li>变换控制器统一使用紫色 (#8b5cf6) 作为主题色</li></ul></li><li><p><strong>条件渲染</strong>:</p><ul><li>根据元素类型选择不同的渲染方式</li><li>根据选中状态决定是否显示变换控制器</li><li>根据选中元素数量显示不同的控制器形态（单选手柄 vs 群组控制器）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>A[Viewport] --&gt; B[elementLayer]<br>A --&gt; C[uiLayer]<br>B --&gt; D[图形元素 1]<br>B --&gt; E[图形元素 2]<br>B --&gt; F[文本元素]<br>B --&gt; G[图像元素]<br>C --&gt; H[选区框]<br>C --&gt; I[橡皮擦指示器]<br>C --&gt; J[变换控制器]<br><br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#e8f5e8<br>    style D fill:#fce4ec<br>    style E fill:#fce4ec<br>    style F fill:#fce4ec<br>    style G fill:#fce4ec<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style J fill:#fff3e0<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>前端项目安装和配置指南 Vite + React + TypeScript + Tailwind CSS</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39845.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39845.html</id>
    <published>2025-11-23T04:38:32.000Z</published>
    <updated>2025-11-23T06:46:44.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南"><a href="#Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南" class="headerlink" title="Vite + React + TypeScript + Tailwind CSS 脚手架搭建指南"></a>Vite + React + TypeScript + Tailwind CSS 脚手架搭建指南</h2><p>本文记录从零搭建 <code>Vite + React + Tailwind CSS</code> 项目，省去一个个官网去查阅文档，旨在方便快速丝滑的创建项目</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><strong>Vite 4.2.0</strong> - 新一代构建工具，提供极快的冷启动和热更新。基于原生 ES 模块实现，开发时按需编译，相比传统打包工具具有显著的速度优势。</li><li><strong>React 18.2.0</strong> - 流行的前端 UI 库，采用组件化架构和虚拟 DOM 技术，提供高效的渲染性能和良好的开发体验。</li><li><strong>TypeScript 5.3.3</strong> - JavaScript 的超集，提供静态类型检查，在编译阶段发现潜在错误，增强代码可维护性和开发效率。</li><li><strong>Tailwind CSS 3.3.1</strong> - 实用优先的 CSS 框架，通过组合预定义的原子类来构建界面，无需编写自定义 CSS 即可实现复杂设计。</li><li><strong>ESLint &amp; Prettier</strong> - 代码规范和格式化工具。ESLint 用于检测代码质量问题和潜在错误，Prettier 专注于代码格式统一，共同保障代码质量。</li><li><strong>Husky &amp; lint-staged</strong> - Git 钩子工具，用于提交前代码检查。Husky 简化 Git 钩子配置，lint-staged 仅对暂存文件执行操作，提升提交前检查效率。</li><li><strong>React Router DOM 6</strong> - React 应用的路由管理工具，提供声明式路由配置，支持动态路由、嵌套路由等特性，是构建单页应用的核心组件。</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">BDdraw_DEV/<br>├── .husky/                     <span class="hljs-comment"># Git hooks 配置</span><br>├── .vscode/                    <span class="hljs-comment"># VSCode 配置</span><br>├── docs/                       <span class="hljs-comment"># 文档目录</span><br>├── public/                     <span class="hljs-comment"># 静态资源目录</span><br>├── src/                        <span class="hljs-comment"># 源代码主目录</span><br>│   ├── api/                    <span class="hljs-comment"># API 接口定义</span><br>│   ├── assets/                 <span class="hljs-comment"># 静态资源文件</span><br>│   ├── components/             <span class="hljs-comment"># 公共组件</span><br>│   ├── hooks/                  <span class="hljs-comment"># 自定义 React Hooks</span><br>│   ├── lib/                    <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   ├── pages/                  <span class="hljs-comment"># 页面组件</span><br>│   ├── router/                 <span class="hljs-comment"># 路由配置</span><br>│   │   └── router.tsx          <span class="hljs-comment"># 路由定义</span><br>│   ├── stores/                 <span class="hljs-comment"># 状态管理</span><br>│   ├── styles/                 <span class="hljs-comment"># 样式文件</span><br>│   ├── app.tsx                 <span class="hljs-comment"># 应用入口组件</span><br>│   ├── main.tsx                <span class="hljs-comment"># 主入口文件</span><br>│   └── vite-env.d.ts           <span class="hljs-comment"># Vite 环境声明文件</span><br>├── .editorconfig               <span class="hljs-comment"># 编辑器配置</span><br>├── .eslintrc                  <span class="hljs-comment"># ESLint 配置</span><br>├── .gitignore                 <span class="hljs-comment"># Git 忽略文件配置</span><br>├── .prettierrc.js             <span class="hljs-comment"># Prettier 配置</span><br>├── .stylelintrc.json          <span class="hljs-comment"># Stylelint 配置</span><br>├── commitlint.config.cjs      <span class="hljs-comment"># Commitlint 配置</span><br>├── components.json            <span class="hljs-comment"># 组件配置</span><br>├── index.html                 <span class="hljs-comment"># HTML 入口</span><br>├── lint-staged.config.js      <span class="hljs-comment"># Lint-staged 配置</span><br>├── package.json               <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js          <span class="hljs-comment"># PostCSS 配置</span><br>├── tailwind.config.js         <span class="hljs-comment"># Tailwind CSS 配置</span><br>├── transmart.config.ts        <span class="hljs-comment"># Transmart 配置</span><br>├── tsconfig.json              <span class="hljs-comment"># TypeScript 配置</span><br>├── tsconfig.node.json         <span class="hljs-comment"># Node.js TypeScript 配置</span><br>├── vite.config.ts             <span class="hljs-comment"># Vite 配置</span><br>└── README.md                  <span class="hljs-comment"># 项目说明文档</span><br><br></code></pre></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>使用 Vite 创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm create vite@latest [项目名] -- --template react-ts<br><span class="hljs-built_in">cd</span> [项目名]<br></code></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure><h3 id="集成-Tailwind-CSS-v3"><a href="#集成-Tailwind-CSS-v3" class="headerlink" title="集成 Tailwind CSS v3"></a>集成 Tailwind CSS v3</h3><p>Tailwind CSS 是一个功能类优先的 CSS 框架，它提供了大量的实用类，可以直接在 HTML 中组合使用来构建任何设计。通过配置文件可以自定义主题、颜色、间距等设计系统，并且只生成实际使用的样式，使得最终的 CSS 文件非常精简。其 JIT（Just-In-Time）模式可以按需生成样式，大大提高了编译速度并支持更多功能。</p><p>安装 Tailwind CSS v3 及其依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D tailwindcss postcss autoprefixer<br>npx tailwindcss init -p<br></code></pre></td></tr></table></figure><p>如果出问题可以去翻一下官方文档，v4 改变了一些部署方式</p><p>配置 Tailwind CSS</p><p>编辑 <code>tailwind.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import('tailwindcss').Config</span>} */</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">content</span>: [<span class="hljs-string">"./index.html"</span>, <span class="hljs-string">"./src/**/*.{js,ts,jsx,tsx}"</span>],<br>  <span class="hljs-attr">theme</span>: {<br>    <span class="hljs-attr">extend</span>: {},<br>  },<br>  <span class="hljs-attr">plugins</span>: [],<br>};<br></code></pre></td></tr></table></figure><h3 id="引入-Tailwind-CSS-v3"><a href="#引入-Tailwind-CSS-v3" class="headerlink" title="引入 Tailwind CSS v3"></a>引入 Tailwind CSS v3</h3><p>在 <code>src/index.css</code> 文件中添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@tailwind</span> base;<br><span class="hljs-keyword">@tailwind</span> components;<br><span class="hljs-keyword">@tailwind</span> utilities;<br></code></pre></td></tr></table></figure><p>并在入口文件中导入该 CSS 文件：</p><p>Tailwind CSS 的三个核心层：</p><ul><li><code>@tailwind base</code> - 包含 Normalize.css 和一些基础样式重置</li><li><code>@tailwind components</code> - 包含框架的组件类，可用于添加结构样式</li><li><code>@tailwind utilities</code> - 包含所有实用类，这是 Tailwind 的核心部分</li></ul><p>通过这种分层方式，Tailwind 提供了一种灵活的方式来组织和扩展样式。</p><h3 id="配置-TypeScript"><a href="#配置-TypeScript" class="headerlink" title="配置 TypeScript"></a>配置 TypeScript</h3><p>TypeScript 是 JavaScript 的超集，添加了可选的静态类型。它可以帮助开发者在编码阶段捕获错误，提供更好的代码补全和重构支持。通过配置 <code>tsconfig.json</code>，我们可以控制 TypeScript 编译器的行为，如目标 JavaScript 版本、模块解析策略、严格性级别等。在本项目中，我们启用了严格的类型检查，同时配置了 React JSX 支持。</p><p>项目中的 <code>tsconfig.json</code> 文件已经包含了基本的 TypeScript 配置。根据项目需求，我们可以对其进行定制：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"useDefineForClassFields"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"DOM"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"DOM.Iterable"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"skipLibCheck"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"allowSyntheticDefaultImports"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"forceConsistentCasingInFileNames"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Node"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"resolveJsonModule"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"isolatedModules"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"jsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"react-jsx"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"references"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span> <span class="hljs-attr">"path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./tsconfig.node.json"</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><h3 id="配置-ESLint-和-Prettier"><a href="#配置-ESLint-和-Prettier" class="headerlink" title="配置 ESLint 和 Prettier"></a>配置 ESLint 和 Prettier</h3><p>ESLint 是一个可插拔的 JavaScript 和 TypeScript 代码质量检查工具，它可以识别语法错误和代码风格问题。Prettier 是一个代码格式化工具，专注于代码风格统一。两者结合使用可以确保团队代码质量和风格的一致性。通过配置规则，我们可以自定义检查标准，例如是否使用分号、引号类型、缩进大小等。</p><p>安装相关依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser<br></code></pre></td></tr></table></figure><p>配置 ESLint</p><p>创建 <code>.eslintrc</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"browser"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"es2021"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"extends"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">"eslint:recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:@typescript-eslint/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:react/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"plugin:react-hooks/recommended"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">"prettier"</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parser"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@typescript-eslint/parser"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parserOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"ecmaVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"latest"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"sourceType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"plugins"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"@typescript-eslint"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"react"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"prettier"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"rules"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"prettier/prettier"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"error"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"react/react-in-jsx-scope"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"off"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"settings"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"react"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"detect"</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p>配置 Prettier</p><p>创建 <code>.prettierrc</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"semi"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"singleQuote"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"tabWidth"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"trailingComma"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"es5"</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><h3 id="配置-Git-Hooks"><a href="#配置-Git-Hooks" class="headerlink" title="配置 Git Hooks"></a>配置 Git Hooks</h3><p>Git Hooks 允许我们在 Git 操作的不同阶段执行自定义脚本。通过 Husky 和 lint-staged，我们可以在代码提交前自动运行 ESLint 和 Prettier，确保只有符合规范的代码才能进入代码库。lint-staged 只会针对暂存区的文件运行检查，提高效率。这有助于保持整个项目的代码质量和一致性。</p><p>使用 Husky 和 lint-staged 在代码提交前自动运行代码检查和格式化。</p><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -D husky lint-staged<br></code></pre></td></tr></table></figure><p>初始化 Husky</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky install<br></code></pre></td></tr></table></figure><p>配置 lint-staged</p><p>创建 <code>lint-staged.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-string">"*.{ts,tsx}"</span>: [<span class="hljs-string">"eslint --fix"</span>, <span class="hljs-string">"prettier --write"</span>],<br>  <span class="hljs-string">"*.{css,md}"</span>: <span class="hljs-string">"prettier --write"</span>,<br>};<br></code></pre></td></tr></table></figure><p>添加 pre-commit 钩子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky add .husky/pre-commit <span class="hljs-string">"npx lint-staged"</span><br></code></pre></td></tr></table></figure><h3 id="集成-React-Router"><a href="#集成-React-Router" class="headerlink" title="集成 React Router"></a>集成 React Router</h3><p>React Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。</p><p>安装 React Router</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install react-router-dom<br>npm install -D @types/react-router-dom<br></code></pre></td></tr></table></figure><p>创建路由配置</p><p>创建 <code>src/router/router.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { createBrowserRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"../pages/Home"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"../pages/About"</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  {<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span>,<br>  },<br>  {<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">"/about"</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span> /&gt;</span></span>,<br>  },<br>]);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p>在应用中使用路由</p><p>更新 <code>src/App.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">RouterProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">"./router/router"</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterProvider</span> <span class="hljs-attr">router</span>=<span class="hljs-string">{router}</span> /&gt;</span></span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>创建页面组件</p><p>创建 <code>src/pages/Home.tsx</code> 和 <code>src/pages/About.tsx</code> 文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/pages/Home.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/pages/About.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">About</span>;<br></code></pre></td></tr></table></figure><p>React Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。</p><h3 id="配置-Vite"><a href="#配置-Vite" class="headerlink" title="配置 Vite"></a>配置 Vite</h3><p>项目的 <code>vite.config.ts</code> 文件配置如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;<br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;<br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">resolve</span>: {<br>    <span class="hljs-attr">alias</span>: {<br>      <span class="hljs-string">"@"</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src"</span>),<br>    },<br>  },<br>  <span class="hljs-attr">css</span>: {<br>    <span class="hljs-attr">postcss</span>: <span class="hljs-string">"./postcss.config.js"</span>,<br>  },<br>  <span class="hljs-attr">server</span>: {<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>  },<br>});<br></code></pre></td></tr></table></figure><h3 id="配置-PostCSS"><a href="#配置-PostCSS" class="headerlink" title="配置 PostCSS"></a>配置 PostCSS</h3><p>PostCSS 是一个使用 JavaScript 插件转换 CSS 的工具。在这个项目中，我们使用了两个关键插件：</p><ul><li>Tailwind CSS 插件：处理 Tailwind CSS 相关的样式生成</li><li>Autoprefixer 插件：自动添加厂商前缀以确保样式在不同浏览器中的兼容性</li></ul><p>通过 PostCSS，我们可以自动化处理 CSS，减少手动工作并提高样式兼容性。</p><p><code>postcss.config.js</code> 文件配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">plugins</span>: {<br>    <span class="hljs-attr">tailwindcss</span>: {},<br>    <span class="hljs-attr">autoprefixer</span>: {},<br>  },<br>};<br></code></pre></td></tr></table></figure><h3 id="添加常用组件和工具"><a href="#添加常用组件和工具" class="headerlink" title="添加常用组件和工具"></a>添加常用组件和工具</h3><p>通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。</p><p>创建基础 UI 组件：在 <code>src/components/ui</code> 目录下创建一些基础 UI 组件，例如按钮、输入框等</p><p>创建自定义 Hooks：在 <code>src/hooks</code> 目录下创建常用的自定义 Hooks，例如 <code>useLocalStorage</code>、<code>useToggle</code> 等</p><p>配置路径别名：在 <code>tsconfig.json</code> 中配置路径别名，方便导入模块：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-comment">// ... 其他配置</span><br>    <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"."</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/*"</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><p>通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。</p><h3 id="其他重要配置文件说明"><a href="#其他重要配置文件说明" class="headerlink" title="其他重要配置文件说明"></a>其他重要配置文件说明</h3><h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p><code>.gitignore</code> 文件用于指定 Git 应当忽略的文件和目录，防止不必要的文件被提交到代码仓库。在本项目中，该文件包含了以下几类被忽略的内容：</p><ol><li><strong>系统文件</strong>：如 macOS 系统生成的 <code>.DS_Store</code> 文件</li><li><strong>日志文件</strong>：如 npm、yarn 等生成的日志文件</li><li><strong>依赖目录</strong>：如 <code>node_modules/</code> 目录</li><li><strong>构建输出</strong>：如构建工具生成的 <code>dist/</code>、<code>.next/</code> 等目录</li><li><strong>缓存文件</strong>：如各种工具生成的缓存文件</li><li><strong>环境变量文件</strong>：如 <code>.env</code> 及其变体文件，防止敏感信息泄露</li><li><strong>编辑器配置</strong>：如编辑器生成的临时文件</li></ol><p>通过合理配置 <code>.gitignore</code>，可以减小代码仓库体积，保护敏感信息，并避免无关文件干扰开发。</p><h4 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h4><p><code>.editorconfig</code> 文件用于统一不同编辑器和 IDE 的代码格式设置。在团队协作中，不同开发者可能使用不同的编辑器，该文件可以确保所有人使用相同的编码规范：</p><ul><li>使用空格缩进，缩进大小为 2 个空格</li><li>行尾符使用 LF (Unix 风格)</li><li>字符编码使用 UTF-8</li><li>自动删除行尾空白字符</li><li>文件末尾自动添加新行</li></ul><p>这有助于保持代码风格的一致性，避免因编辑器差异导致的格式混乱。</p><h4 id="prettierrc-js"><a href="#prettierrc-js" class="headerlink" title=".prettierrc.js"></a>.prettierrc.js</h4><p>Prettier 配置文件，用于统一代码格式化风格：</p><ul><li>不使用分号结尾</li><li>对象和数组末尾保留逗号</li><li>使用单引号而非双引号</li><li>单行最大宽度为 120 字符</li><li>缩进使用 2 个空格</li><li>行尾符自动适应操作系统</li></ul><p>Prettier 会在保存文件或执行格式化命令时自动应用这些规则，确保整个项目的代码风格统一。</p><h4 id="commitlint-config-cjs"><a href="#commitlint-config-cjs" class="headerlink" title="commitlint.config.cjs"></a>commitlint.config.cjs</h4><p>Commitlint 配置文件，用于校验 Git 提交信息的格式。它继承了 <code>@commitlint/config-conventional</code> 规则，要求提交信息遵循约定式提交规范：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&lt;<span class="hljs-keyword">type</span>&gt;[<span class="hljs-keyword">optional</span> scope]: &lt;description&gt;<br><br>[<span class="hljs-keyword">optional</span> body]<br><br>[<span class="hljs-keyword">optional</span> footer(s)]<br></code></pre></td></tr></table></figure><p>其中 type 必须是以下几种之一：</p><ul><li>feat: 新功能</li><li>fix: 修复 bug</li><li>chore: 构建过程或辅助工具的变动</li><li>docs: 文档更新</li><li>style: 代码格式调整</li><li>refactor: 重构</li><li>perf: 性能优化</li><li>test: 测试用例</li></ul><p>这有助于生成标准化的变更日志，便于团队理解和维护项目历史。</p><h4 id="stylelintrc-json"><a href="#stylelintrc-json" class="headerlink" title=".stylelintrc.json"></a>.stylelintrc.json</h4><p>Stylelint 配置文件，用于检查 CSS/LESS 样式代码的质量和风格。该项目配置了：</p><ul><li>继承标准规则集和 Prettier 推荐规则</li><li>支持 LESS 语法</li><li>启用 Prettier 规则</li><li>自定义类名命名规范（小写字母和连字符）</li><li>允许未知的 at-rule（为了支持 LESS 特性）</li></ul><p>通过 Stylelint 可以确保样式代码的一致性和质量，避免常见的样式错误。</p><h4 id="lint-staged-config-js"><a href="#lint-staged-config-js" class="headerlink" title="lint-staged.config.js"></a>lint-staged.config.js</h4><p>Lint-staged 配置文件，用于对 Git 暂存区的文件执行检查和格式化：</p><ul><li>对 TypeScript 文件执行 ESLint 和 Prettier</li><li>对 JavaScript 文件执行 ESLint 和 Prettier</li><li>对 LESS 和 CSS 文件执行 Stylelint</li><li>对其他文件执行相应检查</li></ul><p>这确保只有符合规范的代码才能被提交到仓库，提升整体代码质量。</p><h3 id="开发环境和生产环境配置"><a href="#开发环境和生产环境配置" class="headerlink" title="开发环境和生产环境配置"></a>开发环境和生产环境配置</h3><p>开发环境启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run dev<br></code></pre></td></tr></table></figure><p>构建生产版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><p>预览生产构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run preview<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南&quot;&gt;&lt;a href=&quot;#Vite-React-TypeScript-Tailwind-CSS-脚手架搭建指南&quot; class=&quot;headerlink&quot; title=&quot;Vite + R</summary>
      
    
    
    
    <category term="Github" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-22-canvas项目实现说明</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/17360.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/17360.html</id>
    <published>2025-11-23T04:34:05.000Z</published>
    <updated>2025-11-23T13:56:58.737Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DSF-MA"><a href="#DSF-MA" class="headerlink" title="DSF-MA"></a>DSF-MA</h3><p>进入了字节工训营，干的前端方向，发了个任务要实现一个画布类产品对标 Excalidraw 和飞书 Slide 这种</p><p>库的话不允许使用 react-flow、tldraw、konva 等开源图形库，允许使用基础渲染库（pixi），局部功能使用三方库可接受，主要业务逻辑需自行实现，允许使用 Cursor/Trae 等 AI 编辑器，限制目前是这些</p><p>整理一份计划文稿具体拆解一下任务，如下所示</p><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><h4 id="【P0】基础渲染"><a href="#【P0】基础渲染" class="headerlink" title="【P0】基础渲染"></a>【P0】基础渲染</h4><ul><li>支持图形渲染，需要支持至少 3 种不同图形，比如矩形、圆角矩形、圆形、直线、箭头、菱形等。需要支持以下图形属性：<ul><li>背景色（background）</li><li>边框宽度（border-width）</li><li>边框颜色（border-color）</li></ul></li><li>支持图片渲染，需要支持 png、jpeg 格式，支持设置三种简单滤镜</li><li>支持富文本文字渲染，需要支持以下文本属性：<ul><li>字体（font-family）</li><li>字号（font-size）</li><li>颜色（color）</li><li>背景色（background）</li><li>BIUS（加粗、斜体、下划线、删除线）</li></ul></li></ul><h4 id="【P0】画布交互"><a href="#【P0】画布交互" class="headerlink" title="【P0】画布交互"></a>【P0】画布交互</h4><ul><li>支持无限画布的缩放、滚动、拖拽<ul><li>【挑战】支持无限画布滚动条</li><li>【挑战】支持无限画布的 minimap 功能</li></ul></li><li>支持选区功能：<ul><li><strong>点击选中单个元素</strong></li><li><strong>框选选中多个元素</strong></li></ul></li><li>支持数据持久化，每次操作后自动保存数据，刷新页面数据仍然存在</li><li>快捷键复制选中元素，粘贴后刷新页面还存在</li><li>【挑战】支持辅助线功能</li></ul><h4 id="【P0】调参工具栏"><a href="#【P0】调参工具栏" class="headerlink" title="【P0】调参工具栏"></a>【P0】调参工具栏</h4><ul><li>浮动工具栏<ul><li>当选中文本元素时出现在上方，支持设置不同文本属性</li><li>当选中图形元素时出现在上方，支持设置不同图形属性</li><li>当选中图片元素时出现在上方，支持设置不同图片属性</li><li>【挑战】选中文本元素的部分文字时也能够出现，支持设置局部文本的文本属性</li></ul></li></ul><h4 id="【P0】元素编辑"><a href="#【P0】元素编辑" class="headerlink" title="【P0】元素编辑"></a>【P0】元素编辑</h4><ul><li>支持双击文本进入编辑，可以输入/删除文本内容</li><li>支持对选中元素（单个或多个）删除</li><li>支持对选中元素（单个或多个）拖拽</li><li>支持对选中元素（单个或多个）缩放</li><li>【挑战】支持对选中元素（单个或多个）旋转</li><li>【挑战】支持对多个元素进行组合操作，组合可以嵌套</li><li>【挑战】支持对多个元素进行打组、解组</li></ul><h4 id="【P0】性能优化"><a href="#【P0】性能优化" class="headerlink" title="【P0】性能优化"></a>【P0】性能优化</h4><ul><li>画布存在 100 个元素，打开页面到渲染完成 &lt; 3s</li><li>【挑战】同时操作 100 个元素，FPS 50+</li></ul><h4 id="【P1】协同"><a href="#【P1】协同" class="headerlink" title="【P1】协同"></a>【P1】协同</h4><ul><li>【挑战】支持 undo &amp; redo 操作</li><li>【挑战】支持协同编辑，多人打开同一个画布可以协同编辑</li><li>【挑战】支持离线编辑，断网后仍然可以对画布编辑，恢复网络后自动提交数据</li></ul><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>这时候需要简单做一个技术选型分析，根据任务拆解，选择了如下技术栈</p><p><strong>【框架】</strong>【技术方案：采用 React 18 + TypeScript 5 构建应用，React 提供完整的 UI 生态，TypeScript 提供更清晰可靠的类型安全，相比 JavaScript 更易于维护】</p><p><strong>【构建工具】</strong>【技术方案：使用 Vite 5 作为构建工具，其开发服务器启动和热模块替换（HMR）速度明显快于 Webpack】</p><p><strong>【路由】</strong>【技术方案：采用 React Router DOM 6 实现路由管理，API 稳定且文档完善】</p><p><strong>【样式】</strong>【技术方案：使用 Tailwind CSS 3 + PostCSS 处理样式，开发时编写样式更快，生产环境会自动进行 tree-shaking 优化，相比 CSS Modules 和 styled-components 更高效且原子化更直观，对 AI 工具友好】</p><p><strong>【样式扩展】</strong>【技术方案：少量使用 Less 覆盖 Tailwind 主题变量，保持兼容性】</p><p><strong>【SVG 处理】</strong>【技术方案：使用 SVGR 1.5 处理 SVG，Vite 原生支持，可以将 SVG 作为 React 组件使用，比直接使用 SVG 或 SVG sprite 更灵活】</p><p><strong>【UI 组件库】</strong>【技术方案：采用 shadcn/ui（latest）和 Arco Design 2 实现 UI 组件，易于使用，符合字节项目使用字节组件库的习惯】</p><p><strong>【数据获取】</strong>【技术方案：使用 TanStack Query v5 进行数据获取，具备自动缓存、后台重试、预取等功能，并配有 Devtools】</p><p><strong>【全局状态】</strong>【技术方案：采用 Zustand 4 管理全局状态，API 简洁、性能良好且无样板代码，相比 Redux Toolkit、Pinia、Jotai 代码量更少且配有 Devtools】</p><p><strong>【图形/画布】</strong>【技术方案：使用 PixiJS 8 + pixi-viewport 实现图形和画布功能，基于 WebGL 渲染，适合处理大量精灵元素，相比其他可选方案性能更高】</p><p><strong>【富文本编辑器】</strong>【技术方案：采用 WangEditor 5 作为富文本编辑器，轻量且文档和社区均为中文，相比 Slate/TipTap 等编辑器，默认输出的 HTML 可直接给 PixiJS HTMLText 进行渲染】</p><p><strong>【图标】</strong>【技术方案：使用 Lucide React 图标库，图标数量多、风格统一且支持 Tree-shaking】</p><p><strong>【工具库】</strong>【技术方案：采用 nanoid 3 为画布元素生成唯一标识符等操作，轻量实用】</p><p><strong>【代码质量】</strong>【技术方案：使用 ESLint + Stylelint + Prettier + Husky + lint-staged + commitlint 保证团队代码风格一致，这是中大型项目的基本配置，有利于多人协作开发】</p><p>此外，还配置了 react 开发者工具 react-dev-inspector，配置了一下，开发环境下 ctrl+q 可以实现点击页面上的组件，在 VSCode 中自动跳转到对应文件，并定位到对应行号，方便调试（先前写 vue 也用过类似的）</p><p>项目 <a href="https://react-dev-inspector.zthxxx.me/docs">https://react-dev-inspector.zthxxx.me/docs</a></p><h3 id="功能要素和方案"><a href="#功能要素和方案" class="headerlink" title="功能要素和方案"></a>功能要素和方案</h3><p>分析以上需求，查阅相关资料后，进行各个核心模块的技术方案选型，确定初步实现方案</p><p><strong>【基础渲染引擎】</strong>【技术方案：PixiJS v8（WebGL）提供高性能 2D 渲染，根据不同元素类型创建对应的 Pixi 对象（图形、文本、图像），通过 pixi-viewport 实现无限画布的视口控制，支持缩放、拖拽等交互】</p><p><strong>【无限画布视口】</strong>【技术方案：pixi-viewport（内置 zoom、drag、decelerate、clampZoom）库创建无限画布，在 StageManagerCore.ts 中初始化 viewport，并添加拖拽、缩放等交互功能，支持鼠标中键拖拽画布、滚轮缩放等常见操作】</p><p><strong>【富文本编辑】</strong>【技术方案：WangEditor 5 作为富文本编辑器，提供完整的文本编辑功能，编辑结果以 HTML 格式存储在元素的 text/string 属性中，元素使用 PixiJS 内置的 HTMLText 进行渲染实现富文本效果】</p><p><strong>【状态管理与数据结构】</strong>【技术方案：Zustand 作为全局状态管理库，通过 structuredClone 函数手动创建状态快照，管理画布元素、选中状态、工具类型等，通过中间件监听状态变化并触发重渲染，在特定的 ts 中定义所有状态和操作方法】</p><p><strong>【图片上传显示与滤镜】</strong>【技术方案：PixiJS 内置 Filter 系统包括 BlurFilter、ColorMatrixFilter（黑白、对比度、饱和度）实现图像处理效果，支持模糊、亮度调整、灰度等多种滤镜效果，在 ElementRenderer.ts 中根据元素的 filter 属性应用相应滤镜，支持 blur（模糊）、brightness（亮度）、grayscale（灰度）等滤镜类型】</p><p><strong>【选中与变换系统】</strong>【技术方案：SelectionManager + TransformOverlay（8 个把手 + 旋转把手）实现变换控件渲染，支持单个元素选中和多个元素群组选中，提供 8 个控制点和 1 个旋转点进行变换操作，根据不同元素类型提供不同的控制方式】</p><p><strong>【旋转与组合嵌套】</strong>【技术方案：每个元素维护自己的 matrix（局部矩阵），组合后父容器统一应用矩阵变换，支持多层级嵌套和复杂变换】</p><p><strong>【Minimap】</strong>【技术方案：单独一个小的 Pixi.Application（共享 texture 缓存）实现缩略图功能，主画布所有容器使用 cacheAsBitmap 后生成低分辨率 texture，实时更新到小画布，视口框用一个半透明矩形表示在主画布中的位置】</p><p><strong>【元素永久缓存】</strong>【技术方案：使用 spriteMap 来存储 PIXI 对象，元素更新时只修改属性并设置 container.dirty = true，而不是销毁重建，来解决拖拽中断、光标丢失、闪烁等问题】</p><p><strong>【辅助对齐线】</strong>【技术方案：拖拽时实时遍历所有元素 bounds，计算对齐情况（水平/垂直/间距相等），差值&lt;6px 就吸附并画蓝线，支持水平、垂直对齐以及等间距对齐等多种对齐方式，当距离小于阈值时自动吸附并对齐】</p><p><strong>【Undo/Redo】</strong>【技术方案：Command Pattern + structuredClone 完整快照（每步 before/after）实现撤销/重做功能，通过管理命令栈（undo，redo 栈），使用 structuredClone 创建状态快照，记录操作前后的完整状态，来支持添加元素、删除元素、修改元素属性等操作的撤销/重做，针对拖拽和调整大小操作的命令生成逻辑可能还要具体再处理一套】</p><p><strong>【数据持久化与离线】</strong>【技术方案：Zustand-persist + localForage（IndexedDB）实现数据持久化和离线使用，使用 Zustand 的持久化中间件保存状态，通过 localForage 将数据存储到 IndexedDB 中，实现数据的自动保存和恢复功能】</p><p><strong>【实时协同】</strong>【技术方案：Y.js + y-websocket（或自己写 CRDT）+ Operation Transform 合并策略实现无冲突的实时协同编辑，通过 y-websocket 插件实现服务端同步（问的 AI），有个思路是把操作打给时间 tag，然后然后按时间合并】</p><hr><h3 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h3><p>项目采用数据驱动视图（Data-Driven View）模式，使用<strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>的三层架构</p><p>React 只负责 UI 和事件入口<br>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）<br>PixiJS 层只做”渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建<br>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</p><p>项目主要划分为三个层次：渲染层、状态管理层和逻辑层，来实现关注点分离，提高代码的可维护性和可扩展性。</p><h4 id="渲染层"><a href="#渲染层" class="headerlink" title="渲染层"></a><strong>渲染层</strong></h4><p>主要由 PixiJS (WebGL) 负责处理图形渲染，包括创建、更新和删除图形对象。这一层负责将状态管理层的数据转换为可视化的图形元素，并处理用户的交互操作，如拖拽、缩放和旋转等</p><h4 id="状态管理层"><a href="#状态管理层" class="headerlink" title="状态管理层"></a><strong>状态管理层</strong></h4><p>采用 Zustand 管理 JSON 画布数据。<br>先定义一个 CanvasState 接口（JSON 数据结构，包含 id, type, x, y, width, height 等属性）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span>; <span class="hljs-comment">// 当前工具类型</span><br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 画布元素集合</span><br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[]; <span class="hljs-comment">// 选中元素ID列表</span><br>  <span class="hljs-attr">editingId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 正在编辑的元素ID</span><br>  <span class="hljs-attr">clipboard</span>: <span class="hljs-title class_">CanvasElement</span>[] | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 剪贴板数据</span><br>  <span class="hljs-attr">pasteOffset</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 粘贴偏移计数</span><br>  <span class="hljs-attr">currentStyle</span>: {<br>    <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-comment">// ... 其他样式属性</span><br>  };<br>}<br></code></pre></td></tr></table></figure><p>使用 Zustand 状态管理库，其中 elements 被定义为 Record<string, CanvasElement="">类型，表示一个以 id 为键，CanvasElement 为值的对象，用于存储画布上的所有元素。更新元素时使用 structuredClone 函数来克隆状态数据。后续持久化存储和撤销重做机制也是基于这一套状态管理来实现。这一层作为数据核心，主要维护画布上所有元素的状态信息，通过集中管理状态，确保了数据的一致性，便于后续的协同编辑和撤销重做功能的开发。</string,></p><h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a><strong>逻辑层</strong></h4><p>核心是 StageManagerCore 类，通过 StageManagerState 接口管理交互状态，包括当前交互模式、起始位置、当前元素 ID、初始元素状态等，处理多种交互模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">idle - 空闲状态<br>panning - 画布平移<br>selecting - 选择元素<br>dragging - 拖拽元素<br>resizing - 调整元素大小<br>drawing - 绘制元素<br>texting - 文本编辑<br>erasing - 擦除元素<br></code></pre></td></tr></table></figure><p>处理多种元素操作逻辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建元素 - 根据不同工具类型创建相应元素<br>选择元素 - 支持单选和多选<br>拖拽元素 - 记录初始状态，计算偏移量<br>调整大小 - 通过控制手柄调整元素尺寸<br>删除元素 - 通过橡皮擦工具删除元素<br></code></pre></td></tr></table></figure><p>通过这种方式来实现面向对象编程并封装业务逻辑，提高代码的可维护性，利用后续拓展</p><hr><h3 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h3><p class='item-img' data-src='https://picx.zhimg.com/v2-f31564e4cf50242b6d2a363b40f638f3_r.jpg'><img src="https://picx.zhimg.com/v2-f31564e4cf50242b6d2a363b40f638f3_r.jpg" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互类型}<br>    B --&gt;|创建元素| C[StageManagerCore.onPointerDown]<br>    B --&gt;|拖拽元素| D[StageManagerCore.onPointerMove]<br>    B --&gt;|调整大小| E[StageManagerCore.onHandleDown]<br>    B --&gt;|选择元素| F[StageManagerCore.onPointerUp]<br>    <br>    C --&gt; G[Zustand Store.addElement]<br>    D --&gt; H[Zustand Store.updateElement]<br>    E --&gt; I[Zustand Store.updateElement]<br>    F --&gt; J[Zustand Store.setSelected]<br>    <br>    G --&gt; K[Zustand 状态更新]<br>    H --&gt; K<br>    I --&gt; K<br>    J --&gt; K<br>    <br>    K --&gt; L{状态变化}<br>    L --&gt;|元素变化| M[ElementRenderer.renderElements]<br>    L --&gt;|选择变化| N[TransformerRenderer.renderTransformer]<br>    <br>    M --&gt; O[PixiJS 图形渲染]<br>    N --&gt; O<br>    <br>    O --&gt; P[用户看到更新结果]<br>    <br>    K --&gt; Q[Zustand 持久化]<br>    Q --&gt; R[本地存储/IndexedDB]<br>    <br>    K --&gt; S[撤销/重做管理]<br>    S --&gt; T[命令栈管理]<br>    <br>    style A fill:#e1f5fe<br>    style O fill:#e8f5e8<br>    style K fill:#fff3e0<br>    style Q fill:#fce4ec<br></code></pre></td></tr></table></figure><p>流程如下：</p><h4 id="用户交互输入"><a href="#用户交互输入" class="headerlink" title="用户交互输入"></a>用户交互输入</h4><p>所有用户交互事件由 StageManagerCore 处理<br>用户通过鼠标、键盘等方式与画布进行交互：</p><ul><li>创建新元素（点击工具栏选择图形类型后在画布上绘制）</li><li>拖拽元素（选中元素后拖动）</li><li>调整元素大小（拖拽元素控制点）</li><li>选择元素（点击或框选元素）</li></ul><h4 id="创建元素流程"><a href="#创建元素流程" class="headerlink" title="创建元素流程"></a>创建元素流程</h4><ol><li>用户在画布上按下鼠标开始绘制</li><li><a href="">onPointerDown</a>捕获事件，创建新元素</li><li>调用 Zustand store 的<a href="">addElement</a>方法添加元素</li></ol><blockquote><p>创建元素时的中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="拖拽元素流程"><a href="#拖拽元素流程" class="headerlink" title="拖拽元素流程"></a>拖拽元素流程</h4><ol><li>用户按下并拖动已选中的元素</li><li><a href="">onPointerMove</a>持续捕获鼠标移动事件</li><li>实时调用 Zustand store 的<a href="">updateElement</a>更新元素位置</li></ol><blockquote><p>拖拽元素时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="调整大小流程"><a href="#调整大小流程" class="headerlink" title="调整大小流程"></a>调整大小流程</h4><ol><li>用户拖拽元素的控制点（resize handle）</li><li><a href="">onHandleDown</a>捕获控制点拖拽事件</li><li><a href="">onPointerMove</a>计算缩放比例并更新元素大小</li><li>调用 Zustand store 的<a href="">updateElement</a>更新元素属性</li></ol><blockquote><p>调整元素大小时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="交互结束处理"><a href="#交互结束处理" class="headerlink" title="交互结束处理"></a>交互结束处理</h4><ol><li>用户释放鼠标按键，<a href="">onPointerUp</a>处理交互结束,解锁撤销/重做管理器</li><li>创建相应的命令（<a href="">UpdateElementCommand</a>并添加到命令栈中</li><li>清理临时状态</li></ol><h4 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h4><p>Zustand 作为全局状态管理器，处理所有状态更新：</p><ol><li><strong>状态更新</strong>：自定义一套<a href="">originalSet</a>方法更新状态</li><li><strong>撤销/重做处理</strong>：创建状态快照并生成命令对象</li><li><strong>状态订阅</strong>：通知所有订阅者状态变化</li></ol><h4 id="渲染更新"><a href="#渲染更新" class="headerlink" title="渲染更新"></a>渲染更新</h4><p>Zustand 状态变化触发 StageManagerCore 的订阅回调：</p><ol><li><a href="">ElementRenderer.renderElements</a> 根据元素数据更新 PixiJS 图形对象</li><li><a href="">TransformerRenderer.renderTransformer</a> 更新选中元素的变换控制器</li><li>PixiJS 自动进行渲染</li></ol><h4 id="撤销-重做管理"><a href="#撤销-重做管理" class="headerlink" title="撤销/重做管理"></a>撤销/重做管理</h4><p>通过命令模式实现撤销/重做功能：</p><ol><li>每个操作生成对应的命令对象（<a href="">UpdateElementCommand</a>、<a href="">SnapshotCommand</a>等）</li><li>命令对象保存操作前后的状态快照</li><li>通过<a href="">UndoRedoManager</a>管理命令栈，实现撤销和重做功能</li></ol><blockquote><p>目前 undo 栈 redo 栈有一些不能稳定复现的小概率触发的 bug，还在修</p></blockquote><h4 id="数据持久化阶段"><a href="#数据持久化阶段" class="headerlink" title="数据持久化阶段"></a>数据持久化阶段</h4><p>Zustand 状态变化同时触发数据持久化：</p><ol><li>状态通过<a href="">persist</a>中间件自动保存到本地存储</li><li>数据存储在 IndexedDB 中，来支持离线使用</li></ol><blockquote><p>这一块还在写</p></blockquote><hr><h3 id="设计的相关考虑"><a href="#设计的相关考虑" class="headerlink" title="设计的相关考虑"></a>设计的相关考虑</h3><p><strong>解耦</strong>：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展</p><p><strong>便于后续的协同编辑</strong>：实现多人协同，要监听 WebSocket 消息，然后更新 Zustand Store。StageManager 可以去监听到 Store 的变化，并作出相应的渲染更新</p><p><strong>对撤销/重做的实现</strong>：因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照</p><p><strong>序列化/反序列化</strong>：保存项目只需 JSON.stringify(store.elements)</p><h4 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h4><p>【待补充】</p><h3 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h3><h4 id="https-zhongye1-github-io-BDdraw-DEV"><a href="#https-zhongye1-github-io-BDdraw-DEV" class="headerlink" title="https://zhongye1.github.io/BDdraw_DEV/"></a><a href="https://zhongye1.github.io/BDdraw_DEV/">https://zhongye1.github.io/BDdraw_DEV/</a></h4><p class='item-img' data-src='https://github.com/Zhongye1/BDdraw_DEV/blob/main/assets/image-20251122221138270.png?raw=true'><img src="https://github.com/Zhongye1/BDdraw_DEV/blob/main/assets/image-20251122221138270.png?raw=true" alt="image-20251122221138270"></p><h3 id="具体模块设计文档（见博客或项目-doc）"><a href="#具体模块设计文档（见博客或项目-doc）" class="headerlink" title="具体模块设计文档（见博客或项目/doc）"></a>具体模块设计文档（见博客或项目/doc）</h3><p><a href="https://zhongye1.github.io/Arknight-notes/posts/39845.html">前端项目构建 Vite + React + TypeScript + Tailwind CSS</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/62456.html">2025-11-23-canvas 项目相关-逻辑层</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/61172.html">2025-11-23-canvas 项目相关-状态管理层</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/8350.html">2025-11-23-canvas 项目相关-渲染层</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/55740.html">2025-11-23-canvas 项目相关-图像编辑机制</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/52694.html">2025-11-23-Undo/Redo 机制具体实现</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/36977.html">2025-11-23-canvas 项目相关-工具栏选择机制</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/25119.html">2025-11-23-canvas 项目相关-快捷键管理</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/38567.html">2025-11-23-canvas 项目相关-画布元素控制调整机制</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/61907.html">2025-11-23-canvas 项目相关-富文本文本元素处理机制</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/12486.html">2025-11-23-canvas 项目相关-视口管理机制</a></p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/33040.html">2025-11-22-使用 GitHub Actions 自动部署基于 vite 的项目到 GitHub Pages</a></p><h3 id="TODO-待补充的文档"><a href="#TODO-待补充的文档" class="headerlink" title="TODO 待补充的文档"></a>TODO 待补充的文档</h3><p><del>图像编辑机制</del> <del>Undo/Redo 机制具体实现</del> <del>画布元素控制调整机制</del> <del>富文本文本元素处理机制</del> <del>性能优化</del> <del>视口管理机制</del> <del>快捷键管理</del> <del>工具栏选择机制</del></p><p>数据持久化设计 协同编辑设计</p><h2 id="【待补充-2025-11-23】"><a href="#【待补充-2025-11-23】" class="headerlink" title="【待补充 2025.11.23】"></a>【待补充 2025.11.23】</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>React 官方文档 <a href="https://react.dev/">https://react.dev</a></li><li>TypeScript 官方文档 <a href="https://www.typescriptlang.org/">https://www.typescriptlang.org</a></li><li>Vite 官方文档 <a href="https://vitejs.dev/">https://vitejs.dev</a></li><li>React Router 官方文档 <a href="https://reactrouter.com/">https://reactrouter.com</a></li><li>Tailwind CSS 3 官方文档 <a href="https://tailwindcss.com/">https://tailwindcss.com</a></li><li>Zustand 官方文档 <a href="https://docs.pmnd.rs/zustand">https://docs.pmnd.rs/zustand</a></li><li>PixiJS 官方文档 <a href="https://pixijs.download/release/docs">https://pixijs.download/release/docs</a></li><li>pixi-viewport 官方文档 + 示例 <a href="https://davidfig.github.io/pixi-viewport/">https://davidfig.github.io/pixi-viewport/</a></li><li>WangEditor 5 官方文档（中文） <a href="https://www.wangeditor.com/v5/">https://www.wangeditor.com/v5/</a></li><li>ESLint 官方文档 <a href="https://eslint.org/">https://eslint.org</a></li><li>Prettier 官方文档 <a href="https://prettier.io/">https://prettier.io</a></li><li>Husky 官方文档 <a href="https://typicode.github.io/husky">https://typicode.github.io/husky</a></li><li>commitlint 官方文档 <a href="https://commitlint.js.org/">https://commitlint.js.org</a></li><li>Y.js 官方文档（实时协同） <a href="https://docs.yjs.dev/">https://docs.yjs.dev</a></li><li>Excalidraw 主仓库（白板核心） <a href="https://github.com/excalidraw/excalidraw">https://github.com/excalidraw/excalidraw</a></li><li>Excalidraw-room（多人协作服务端） <a href="https://github.com/excalidraw/excalidraw-room">https://github.com/excalidraw/excalidraw-room</a></li><li>react-dev-inspector <a href="https://github.com/zthxxx/react-dev-inspector">https://github.com/zthxxx/react-dev-inspector</a></li><li>localForage <a href="https://github.com/localForage/localForage">https://github.com/localForage/localForage</a></li><li>PixiJS 官方示例合集 <a href="https://pixijs.download/release/examples">https://pixijs.download/release/examples</a></li><li>Quilljou/vite-react-ts-tailwind-starter（优秀脚手架） <a href="https://github.com/Quilljou/vite-react-ts-tailwind-starter">https://github.com/Quilljou/vite-react-ts-tailwind-starter</a></li></ol><p><strong>其他参考文章</strong></p><ol><li>前端研发链路之脚手架 - 阿里云开发者社区 <a href="https://developer.aliyun.com/article/1624016">https://developer.aliyun.com/article/1624016</a></li><li>Excalidraw 案例研究：成功应用与最佳实践 - CSDN <a href="https://blog.csdn.net/gitblog_00992/article/details/151003851">https://blog.csdn.net/gitblog_00992/article/details/151003851</a></li><li>产品经理：客户想要个画板，你们前端能不能做？ | 学习笔记 <a href="https://wang1xiang.github.io/blog/docs/work/excalidraw-use.html#缺点">https://wang1xiang.github.io/blog/docs/work/excalidraw-use.html#缺点</a></li><li>从手绘到架构：Excalidraw React 组件设计的优雅实践 - CSDN <a href="https://blog.csdn.net/gitblog_00090/article/details/150998508">https://blog.csdn.net/gitblog_00090/article/details/150998508</a></li><li>Arco Design - 企业级产品设计与开发解决方案 <a href="https://arco.design/">https://arco.design/</a></li><li>开发者工具 | TanStack Query React 文档 <a href="https://tanstack.com.cn/query/latest/docs/framework/react/devtools">https://tanstack.com.cn/query/latest/docs/framework/react/devtools</a></li><li>react-dev-inspector 使用指南（踩坑） - 掘金 <a href="https://juejin.cn/post/6904438522749386759">https://juejin.cn/post/6904438522749386759</a></li><li>React 状态管理终极指南：深挖 Redux、Zustand 与 MobX 的生存法则（2025） - 掘金 <a href="https://juejin.cn/post/7475715128682217509">https://juejin.cn/post/7475715128682217509</a></li><li>[pixi.js] 刚学 pixi.js 做记录 创建应用 添加图片精灵 - CSDN <a href="https://blog.csdn.net/towrabbit/article/details/82465109">https://blog.csdn.net/towrabbit/article/details/82465109</a></li><li>zustand-pub（跨应用/跨框架状态管理及共享） <a href="https://awesomedevin.github.io/zustand-vue/docs/introduce/start/zustand-pub">https://awesomedevin.github.io/zustand-vue/docs/introduce/start/zustand-pub</a></li><li>从 v6 升级 | React Router 中文文档 <a href="https://reactrouter.remix.org.cn/upgrading/v6">https://reactrouter.remix.org.cn/upgrading/v6</a></li><li>Chrome 插件：Redux DevTools 让你的状态管理调试更高效 - 知乎 <a href="https://zhuanlan.zhihu.com/p/716637376">https://zhuanlan.zhihu.com/p/716637376</a></li><li>devtools | zustand 中文网 <a href="https://zustand.vscing.com/docs/middlewares/devtools">https://zustand.vscing.com/docs/middlewares/devtools</a></li><li>优势 | wangEditor <a href="https://www.wangeditor.com/v5/">https://www.wangeditor.com/v5/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DSF-MA&quot;&gt;&lt;a href=&quot;#DSF-MA&quot; class=&quot;headerlink&quot; title=&quot;DSF-MA&quot;&gt;&lt;/a&gt;DSF-MA&lt;/h3&gt;&lt;p&gt;进入了字节工训营，干的前端方向，发了个任务要实现一个画布类产品对标 Excalidraw 和飞书 Slide</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-22- 使用 GitHub Actions 自动部署基于vite的项目到 GitHub Pages</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33040.html</id>
    <published>2025-11-22T17:59:24.000Z</published>
    <updated>2025-11-23T09:48:37.352Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记主要讲在新创建前端项目后，如何通过 GitHub-Actions 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</p><p>参考 <a href="https://zhongye1.github.io/BDdraw_DEV/#/">https://zhongye1.github.io/BDdraw_DEV/#/</a><br>其从仓库 <a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a> 实现自动构建和部署</p><h3 id="0-前置条件"><a href="#0-前置条件" class="headerlink" title="0.前置条件"></a>0.前置条件</h3><ul><li>GitHub 账户 + 一个 public 仓库（私有仓库需要 GitHub Pro 才能开 Pages）</li></ul><h3 id="1-创建-GitHub-Actions-工作流"><a href="#1-创建-GitHub-Actions-工作流" class="headerlink" title="1. 创建 GitHub Actions 工作流"></a>1. 创建 GitHub Actions 工作流</h3><p>在仓库根目录创建文件： .github/workflows/deploy.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">main</span>]<br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">read</span><br>  <span class="hljs-attr">pages:</span> <span class="hljs-string">write</span><br>  <span class="hljs-attr">id-token:</span> <span class="hljs-string">write</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">github-pages</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">${{</span> <span class="hljs-string">steps.deployment.outputs.page_url</span> <span class="hljs-string">}}</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Bun</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">oven-sh/setup-bun@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">bun-version:</span> <span class="hljs-string">latest</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">bun</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">bun</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/configure-pages@v5</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">artifact</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/upload-pages-artifact@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">"./dist"</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">deployment</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/deploy-pages@v4</span><br></code></pre></td></tr></table></figure><h3 id="2-配置-vite-config-ts-的-base"><a href="#2-配置-vite-config-ts-的-base" class="headerlink" title="2. 配置 vite.config.ts 的 base"></a>2. 配置 vite.config.ts 的 base</h3><p>打开 vite.config.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span><br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-react'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">base</span>: <span class="hljs-string">'/BDdraw_DEV/'</span>,   <span class="hljs-comment">// 必须和仓库名完全一致！大小写也要一样</span><br>})<br></code></pre></td></tr></table></figure><p>如果想让它在本地开发和 GitHub Pages 都正常，可以写成动态 base：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">base</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">'production'</span> ? <span class="hljs-string">'/BDdraw_DEV/'</span> : <span class="hljs-string">'/'</span>,<br>})<br></code></pre></td></tr></table></figure><h3 id="3-GitHub-仓库设置-Pages-为-Actions-模式"><a href="#3-GitHub-仓库设置-Pages-为-Actions-模式" class="headerlink" title="3. GitHub 仓库设置 Pages 为 Actions 模式"></a>3. GitHub 仓库设置 Pages 为 Actions 模式</h3><ol><li>进入仓库 → Settings → Pages（左侧菜单）</li><li>Build and deployment → Source 选 <strong>GitHub Actions</strong></li><li>保存</li></ol><h3 id="4-提交代码触发第一次部署"><a href="#4-提交代码触发第一次部署" class="headerlink" title="4. 提交代码触发第一次部署"></a>4. 提交代码触发第一次部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add .<br>git commit -m <span class="hljs-string">"chore: 新建 GitHub Actions 部署工作流"</span><br>git push origin main<br></code></pre></td></tr></table></figure><p>然后去仓库 → Actions 标签页，就能看到正在跑的 “Deploy to GitHub Pages” 工作流。</p><p>成功后可以前往对应的 GitHub Pages 地址查看效果</p><p class='item-img' data-src='https://pica.zhimg.com/v2-25ed9b20ac34367edf61581afc6742ea_r.jpg'><img src="https://pica.zhimg.com/v2-25ed9b20ac34367edf61581afc6742ea_r.jpg" alt="alt text"></p><p>只要 push 到 main 分支，GitHub Actions 就会自动触发工作流，实现自动部署。</p><blockquote><p>如果是私有仓库，需要 GitHub Pro 才能开 Pages</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇笔记主要讲在新创建前端项目后，如何通过 GitHub-Actions 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作&lt;/p&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://zhongye1.github.io/BDdraw_DE</summary>
      
    
    
    
    <category term="Github" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-22- 关于前端包管理器npm,pnpm,yarn和bun以及我为何选择后者</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/15722.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/15722.html</id>
    <published>2025-11-22T13:21:15.000Z</published>
    <updated>2025-11-22T13:39:37.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>因为快。</strong></p><p>2025 年，Bun 作为一个「全能型」运行时 + 包管理器，在实际项目中对传统包管理器（npm/yarn/pnpm）确实有相当大的优势，很多人已经开始抛弃 npm/yarn/pnpm，转用 Bun 作为前端项目的包管理器</p><h3 id="初识-Bun-管理器"><a href="#初识-Bun-管理器" class="headerlink" title="初识 Bun 管理器"></a>初识 Bun 管理器</h3><p>Bun 是 JavaScript 和 TypeScript 应用程序的一站式工具包。它作为一个名为<code>bun</code>的单个可执行文件提供。</p><p>其核心是 Bun 运行时，这是一个快速的 JavaScript 运行时，设计为 Node.js 的即插即用替代品。它是用 Zig 编写的，在底层由 JavaScriptCore 驱动，大大减少了启动时间和内存使用。</p><h3 id="对比其他包管理器"><a href="#对比其他包管理器" class="headerlink" title="对比其他包管理器"></a>对比其他包管理器</h3><h4 id="1-npm（Node-Package-Manager）"><a href="#1-npm（Node-Package-Manager）" class="headerlink" title="1. npm（Node Package Manager）"></a>1. npm（Node Package Manager）</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：使用扁平化依赖树（flattened dependency tree，自 v3+ 引入），但仍依赖传统的 node_modules 目录结构。每个包及其子依赖都会下载 tarball（压缩包），然后解压到本地 node_modules 中。如果有版本冲突，会创建嵌套的 node_modules 子目录（hoisting 机制试图扁平化，但不总是完美）。</li><li><strong>锁文件</strong>：package-lock.json，记录精确的依赖树和哈希值，确保可重现安装。</li><li><strong>缓存机制</strong>：全局缓存在 ~/.npm（或 Windows 的 %AppData%\npm-cache），存储 tarball 和元数据。安装时先检查缓存，命中则直接解压。</li><li><strong>下载与并行</strong>：自 v7+ 支持并行下载（自 v5+），使用 HTTP/1.1 或 HTTP/2，但解析依赖树时仍依赖 JavaScript 引擎（Node.js），导致启动开销大。</li><li><strong>monorepo 支持</strong>：基本支持（通过 workspaces），但需手动配置，效率一般。</li></ul><p><strong>技术栈</strong>：纯 Node.js 实现，CLI 基于 npm-cli。</p><h4 id="2-pnpm（Performant-NPM）"><a href="#2-pnpm（Performant-NPM）" class="headerlink" title="2. pnpm（Performant NPM）"></a>2. pnpm（Performant NPM）</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：引入<strong>内容寻址存储（content-addressable store）</strong>，所有包统一存储在全局 .pnpm/store（硬链接 + 符号链接）。项目中只生成一个扁平的 node_modules/.pnpm 目录，通过符号链接（symlinks）指向全局包，避免重复下载。严格的 peer dependency 隔离，防止“幽灵依赖”（phantom dependencies）。</li><li><strong>锁文件</strong>：pnpm-lock.yaml，YAML 格式，记录依赖图和完整哈希链。</li><li><strong>缓存机制</strong>：全局 store + 硬链接，安装时直接链接现有包（无解压开销）。支持范围补丁（patching），允许动态修改依赖。</li><li><strong>下载与并行</strong>：并行下载 + 增量更新，自 v8+ 优化为“聪明缓存”，只下载变化部分。monorepo 原生支持（workspace 协议），通过过滤命令（如 pnpm -r）高效处理多包。</li><li><strong>monorepo 支持</strong>：最佳，原生高效，节省 70-80% 磁盘。</li></ul><p><strong>技术栈</strong>：Node.js 实现，但使用 Rust-like 的高效链接系统（实际是 JS + 文件系统优化）。</p><h4 id="3-Yarn-Berry（Yarn-v2-）"><a href="#3-Yarn-Berry（Yarn-v2-）" class="headerlink" title="3. Yarn Berry（Yarn v2+）"></a>3. Yarn Berry（Yarn v2+）</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：革命性 <strong>Plug’n’Play (PnP)</strong> 模式，默认<strong>完全消除 node_modules</strong>。依赖通过 .pnp.cjs（或 .pnp.js）文件映射（类似虚拟文件系统），运行时动态解析路径，而非物理目录。备选 nodeLinker: node-modules 模式回退到传统结构。</li><li><strong>锁文件</strong>：yarn.lock（v2+ 格式），包含完整依赖树、校验和和 ZIP 存档引用。</li><li><strong>缓存机制</strong>：项目级 .yarn/cache，存储 ZIP 压缩的包（可提交到 Git，实现“零安装”——clone 后直接运行）。支持“零安装”（zero-installs），CI/CD 无需重新下载。</li><li><strong>下载与并行</strong>：并行下载 + 增量缓存，自 v3+ 引入 Constraints（依赖规则检查）。monorepo 通过 Workspaces + Plug’n’Play 实现高效共享。</li><li><strong>monorepo 支持</strong>：优秀，支持 Constraints 和 Patch 协议，适合大型团队。</li></ul><p><strong>技术栈</strong>：Node.js 实现，但 PnP 使用自定义加载器（loader）拦截模块解析。</p><h4 id="4-Bun"><a href="#4-Bun" class="headerlink" title="4. Bun"></a>4. Bun</h4><p><strong>核心实现</strong>：</p><ul><li><strong>依赖存储与解析</strong>：<strong>无 node_modules</strong>，所有包存储在全局单例缓存（~/.bun/install/cache），项目只生成极小的 .bun 文件夹（二进制锁文件）。使用<strong>极致压缩 + 硬链接</strong>，运行时直接从缓存加载（跳过解压）。兼容 npm 注册表，但内置 JSR（JavaScript Registry）支持。</li><li><strong>锁文件</strong>：bun.lockb，二进制格式（超小、超快解析）。</li><li><strong>缓存机制</strong>：全局缓存 + 内容哈希，安装时并行下载并验证哈希。支持“热缓存”（hot cache），CI 复用率近 100%。</li><li><strong>下载与并行</strong>：使用 Zig 语言编写的超快解析器（非 JS），HTTP/3 支持 + 原生并行。monorepo 自动识别，无需额外配置。</li><li><strong>monorepo 支持</strong>：优秀，极速安装，但生态仍在完善（2025 年已稳定）。</li></ul><p><strong>技术栈</strong>：Zig + JavaScriptCore（WebKit 引擎），非 Node.js 依赖，实现全栈（包管理 + bundler + 测试运行器）。</p><p>基于 pnpm 官方基准（2025-11-16 更新）、Bun 团队报告和社区测试，四个包管理器中<strong>Bun 整体最快，pnpm/Yarn Berry 在磁盘效率上领先，npm 最稳但最慢</strong>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Bun 支持 Linux（x64 和 arm64）和 macOS（x64 和 Apple Silicon）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用npm</span><br>npm install -g bun<br></code></pre></td></tr></table></figure><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bun upgrade<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>bun</code>命令行工具实现了测试运行器、脚本运行器和与 Node.js 兼容的包管理器。Bun 的内置工具明显比现有选项快，并且在现有 Node.js 项目中几乎不需要进行任何更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">bun <span class="hljs-built_in">test</span>                      <span class="hljs-comment"># 运行测试</span><br>bun run start                 <span class="hljs-comment"># 运行`package.json`中的`start`脚本</span><br>bun install &lt;pkg&gt;             <span class="hljs-comment"># 安装包</span><br>bunx cowsay <span class="hljs-string">'Hello, world!'</span>   <span class="hljs-comment"># 执行包</span><br>bun run index.tsx             <span class="hljs-comment"># 默认支持TS和JSX</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;因为快。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2025 年，Bun 作为一个「全能型」运行时 + 包管理器，在实际项目中对传统包管理器（npm/yarn/pnpm）确实有相当大的优势，很多人已经开始抛弃 npm/yarn/pnpm，转用 Bun 作为前端项目的包</summary>
      
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-22-canvas状态管理杂记其三</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/15704.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/15704.html</id>
    <published>2025-11-22T08:43:45.000Z</published>
    <updated>2025-11-24T03:50:02.066Z</updated>
    
    <content type="html"><![CDATA[<p>撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：</p><ul><li>用于记录整个画布状态的变化</li><li>通常用于添加元素、删除元素等较大范围的操作</li><li>保存完整的状态快照</li></ul></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：</p><ul><li>用于记录特定元素的属性变化</li><li>主要用于拖拽移动和调整大小操作</li><li>只保存相关元素的特定属性变化</li></ul></li></ol><h2 id="操作序列和撤销栈状态变化"><a href="#操作序列和撤销栈状态变化" class="headerlink" title="操作序列和撤销栈状态变化"></a>操作序列和撤销栈状态变化</h2><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>撤销栈：空 重做栈：空</p><h3 id="1-创建元素A"><a href="#1-创建元素A" class="headerlink" title="1. 创建元素A"></a>1. 创建元素A</h3><p>当创建元素A时，系统会生成一个快照命令，记录整个画布状态的变化。</p><p>撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：空</p><h3 id="2-移动A到一个位置"><a href="#2-移动A到一个位置" class="headerlink" title="2. 移动A到一个位置"></a>2. 移动A到一个位置</h3><p>当移动元素A时，系统会生成一个更新元素命令（UpdateElementCommand），只记录A元素位置的变化。</p><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：空</p><h3 id="3-创建元素B"><a href="#3-创建元素B" class="headerlink" title="3. 创建元素B"></a>3. 创建元素B</h3><p>当创建元素B时，系统会生成另一个快照命令，记录添加B元素后的状态。</p><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：空</p><h3 id="4-缩放B到一个位置"><a href="#4-缩放B到一个位置" class="headerlink" title="4. 缩放B到一个位置"></a>4. 缩放B到一个位置</h3><p>当缩放元素B时，系统会生成一个更新元素命令，记录B元素尺寸和位置的变化。</p><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：空</p><h3 id="5-移动B到一个位置"><a href="#5-移动B到一个位置" class="headerlink" title="5. 移动B到一个位置"></a>5. 移动B到一个位置</h3><p>当再次移动元素B时，系统会生成另一个更新元素命令，记录B元素位置的新变化。</p><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5) 重做栈：空</p><h2 id="执行撤销操作时的状态变化"><a href="#执行撤销操作时的状态变化" class="headerlink" title="执行撤销操作时的状态变化"></a>执行撤销操作时的状态变化</h2><h3 id="第一次撤销（移动B操作）"><a href="#第一次撤销（移动B操作）" class="headerlink" title="第一次撤销（移动B操作）"></a>第一次撤销（移动B操作）</h3><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB</li><li>执行该命令的undo()方法，将B元素恢复到缩放后的位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：[UpdateElementCommand_MoveB] (大小: 1)</p><h3 id="第二次撤销（缩放B操作）"><a href="#第二次撤销（缩放B操作）" class="headerlink" title="第二次撤销（缩放B操作）"></a>第二次撤销（缩放B操作）</h3><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB</li><li>执行该命令的undo()方法，将B元素恢复到刚创建时的尺寸和位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)</p><h3 id="第三次撤销（创建B操作）"><a href="#第三次撤销（创建B操作）" class="headerlink" title="第三次撤销（创建B操作）"></a>第三次撤销（创建B操作）</h3><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_B</li><li>执行该命令的undo()方法，将整个画布状态恢复到创建B之前的状态（即只包含A元素的状态）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)</p><h3 id="第四次撤销（移动A操作）"><a href="#第四次撤销（移动A操作）" class="headerlink" title="第四次撤销（移动A操作）"></a>第四次撤销（移动A操作）</h3><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA</li><li>执行该命令的undo()方法，将A元素恢复到初始位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)</p><h3 id="第五次撤销（创建A操作）"><a href="#第五次撤销（创建A操作）" class="headerlink" title="第五次撤销（创建A操作）"></a>第五次撤销（创建A操作）</h3><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_A</li><li>执行该命令的undo()方法，将整个画布状态恢复到初始状态（空画布）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：空 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)</p><p><code>undoRedoManager.lock()</code> 锁定管理器</p><hr><p>redo问题</p><ol><li><p><strong>状态快照不完整</strong>：当创建元素时，状态快照可能在元素完全初始化之前就被捕获了，导致元素的width、height等属性为默认值（可能是0）。</p></li><li><p><strong>引用问题</strong>：虽然使用了深拷贝，但是在某些情况下，元素对象可能在快照创建后又被修改，导致快照中的数据不是预期的值。</p></li><li><p><strong>异步更新问题</strong>：元素创建和状态更新之间可能存在异步延迟，导致快照捕捉到了中间状态而非最终状态。</p></li></ol><p>需要确保在创建状态快照时，所有元素都已经完全初始化，并且使用可靠的方法进行深拷贝。</p><p>修复当用户执行 Undo 后再 Redo 时，恢复的是最初 width:0, height:0 的状态，导致元素不可见的问题，修复日志里“type: ‘未知操作’” 和 “重做无效”的问题，在绘制结束（onPointerUp）时，更新历史栈顶那个“创建命令”的 nextState，将其替换为绘制完成后的最终状态</p><hr><h2 id="元素移动（拖拽）实现"><a href="#元素移动（拖拽）实现" class="headerlink" title="元素移动（拖拽）实现"></a>元素移动（拖拽）实现</h2><p>元素的移动主要在 StageManagerCore.ts 文件中实现：</p><ol><li><p><strong>开始拖拽</strong>：</p><ul><li>在 onPointerDown 方法中检测到点击的是已选中的元素时，将模式设置为 dragging</li><li>记录所有选中元素的初始状态到 dragInitialStates 中</li></ul></li><li><p><strong>拖拽过程中</strong>：</p><ul><li>在 onPointerMove 方法中，当 mode 为 dragging 时，计算位移并更新元素位置</li><li>通过调用 <code>state.updateElement(id, { x: el.x + dx, y: el.y + dy })</code> 来更新元素坐标</li></ul></li><li><p><strong>结束拖拽</strong>：</p><ul><li>在 onPointerUp 方法中处理拖拽结束逻辑</li><li>创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中</li></ul></li></ol><h2 id="元素缩放（调整大小）实现"><a href="#元素缩放（调整大小）实现" class="headerlink" title="元素缩放（调整大小）实现"></a>元素缩放（调整大小）实现</h2><p>元素的缩放也在 StageManagerCore.ts 文件中实现：</p><ol><li><p><strong>开始缩放</strong>：</p><ul><li>在 onHandleDown 方法中处理控制点按下事件</li><li>将模式设置为 resizing</li><li>记录所有选中元素的初始状态到 resizeInitialStates 和 initialElementsMap 中</li><li>计算初始包围盒并存储在 initialGroupBounds 中</li></ul></li><li><p><strong>缩放过程中</strong>：</p><ul><li>在 onPointerMove 方法中，当 mode 为 resizing 时处理缩放逻辑</li><li>对于普通元素，基于初始包围盒和鼠标位移重新计算元素的位置和大小</li><li>对于线条和箭头等特殊元素，单独处理端点的拖拽</li></ul></li><li><p><strong>结束缩放</strong>：</p><ul><li>在 onPointerUp 方法中处理缩放结束逻辑</li><li>创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中</li></ul></li></ol><h2 id="关键类和文件"><a href="#关键类和文件" class="headerlink" title="关键类和文件"></a>关键类和文件</h2><ol><li><strong>StageManagerCore.ts</strong> - 核心逻辑实现</li><li><strong>TransformerRenderer.ts</strong> - 渲染选中元素的控制手柄</li><li><strong>UpdateElementCommand.ts</strong> - 撤销/重做命令实现</li><li><strong>UndoRedoManager.ts</strong> - 撤销/重做管理器</li></ol><p>总的来说，元素的移动和缩放操作都是通过 StageManagerCore 类统一管理和处理的，该类负责监听鼠标事件并根据当前模式执行相应的操作。</p><p>实现元素旋转功能需要涉及三个主要部分的修改：</p><ol><li><p><strong>数据模型与状态定义</strong>：支持 rotation 属性和旋转时的临时状态。</p></li><li><p><strong>交互逻辑 (Math)</strong>：处理单个元素旋转和多选组的旋转（组旋转需要处理“公转”和“自转”）。</p></li><li><p><strong>渲染器支持</strong>：虽然这里主要改 StageManagerCore，但你需要确保 TransformerRenderer 能渲染出旋转手柄（通常位于选中框顶部的延长线上）。</p></li></ol><p>以下是具体的实现步骤和代码修改。</p><h3 id="第一步：修改类型定义"><a href="#第一步：修改类型定义" class="headerlink" title="第一步：修改类型定义"></a>第一步：修改类型定义</h3><p>在 types.ts 或 StageManagerCore.ts 的状态定义中，增加旋转相关的临时状态。</p><p>codeTypeScript</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerState 接口中添加：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StageManagerState</span> {<br>  <span class="hljs-comment">// ... 原有属性</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">'idle'</span> | <span class="hljs-string">'dragging'</span> | <span class="hljs-string">'resizing'</span> | <span class="hljs-string">'selecting'</span> | <span class="hljs-string">'drawing'</span> | <span class="hljs-string">'erasing'</span> | <span class="hljs-string">'rotating'</span>; <span class="hljs-comment">// [修改] 添加 rotating</span><br><br>  <span class="hljs-comment">// [新增] 旋转相关状态</span><br>  <span class="hljs-attr">rotationInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, { <br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">rotation</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">cx</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素中心点 x</span><br>    <span class="hljs-attr">cy</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素中心点 y</span><br>  }&gt; | <span class="hljs-literal">null</span>;<br>  <span class="hljs-attr">rotationCenter</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 旋转中心（群组中心或单元素中心）</span><br>  <span class="hljs-attr">startRotationAngle</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 鼠标按下时的初始角度</span><br>}<br></code></pre></td></tr></table></figure><h3 id="第二步：实现旋转数学逻辑-辅助方法"><a href="#第二步：实现旋转数学逻辑-辅助方法" class="headerlink" title="第二步：实现旋转数学逻辑 (辅助方法)"></a>第二步：实现旋转数学逻辑 (辅助方法)</h3><p>在 StageManagerCore 类中添加一个用于计算旋转后坐标的辅助方法。</p><p>codeTypeScript</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore 类中添加</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算点绕中心旋转后的新坐标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x 点的 x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> y 点的 y</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cx 中心点 x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cy 中心点 y</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> angle 旋转角度 (弧度)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">rotatePoint</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">cx</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">cy</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">angle</span>: <span class="hljs-built_in">number</span></span>) {<br>  <span class="hljs-keyword">const</span> cos = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(angle);<br>  <span class="hljs-keyword">const</span> sin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(angle);<br>  <span class="hljs-keyword">const</span> nx = (cos * (x - cx)) - (sin * (y - cy)) + cx;<br>  <span class="hljs-keyword">const</span> ny = (sin * (x - cx)) + (cos * (y - cy)) + cy;<br>  <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: nx, <span class="hljs-attr">y</span>: ny };<br>}<br></code></pre></td></tr></table></figure><h3 id="第三步：处理-onHandleDown-开始旋转"><a href="#第三步：处理-onHandleDown-开始旋转" class="headerlink" title="第三步：处理 onHandleDown (开始旋转)"></a>第三步：处理 onHandleDown (开始旋转)</h3><p>你需要修改 onHandleDown 方法。首先，你需要在 TransformerRenderer 中定义一个 ID 为 rotate 的手柄。当捕获到该手柄时，初始化旋转状态。</p><p>codeTypeScript</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 修改 <span class="hljs-keyword">on</span>HandleDown 方法<br>private <span class="hljs-keyword">on</span>HandleDown = (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1' | 'rotate', elementId: string) =&gt; {<br>  this.triggerDebounceSnapshot();<br>  e.stopPropagation();<br><br>  // === [新增] 旋转逻辑分支 ===<br>  if (handle === 'rotate') {<br>    this.<span class="hljs-keyword">state</span>.mode = 'rotating';<br>    this.<span class="hljs-keyword">state</span>.currentId = elementId;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = useStore.getState();<br>    <span class="hljs-keyword">const</span> { elements, selectedIds } = <span class="hljs-keyword">state</span>;<br>    <span class="hljs-keyword">const</span> mouseP<span class="hljs-keyword">os</span> = e.getLocalPosition(this.viewport);<br><br>    // <span class="hljs-number">1</span>. 计算旋转中心（选中元素的包围盒中心）<br>    <span class="hljs-keyword">const</span> bounds = this.getSelectionBounds(selectedIds, elements);<br>    if (!bounds) return;<br>    <br>    <span class="hljs-keyword">const</span> centerX = bounds.x + bounds.width / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">const</span> centerY = bounds.y + bounds.height / <span class="hljs-number">2</span>;<br>    this.<span class="hljs-keyword">state</span>.rotationCenter = { x: centerX, y: centerY };<br><br>    // <span class="hljs-number">2</span>. 计算鼠标起始角度（相对于中心点）<br>    this.<span class="hljs-keyword">state</span>.startRotationAngle = Math.atan2(mouseP<span class="hljs-keyword">os</span>.y - centerY, mouseP<span class="hljs-keyword">os</span>.x - centerX);<br><br>    // <span class="hljs-number">3</span>. 记录所有选中元素的初始状态<br>    <span class="hljs-keyword">const</span> initialMap: Record<span class="hljs-variable">&lt;string, any&gt;</span> = {};<br>    selectedIds.<span class="hljs-keyword">for</span>Each(id =&gt; {<br>      <span class="hljs-keyword">const</span> el = elements[id];<br>      if (el) {<br>        initialMap[id] = {<br>          x: el.x,<br>          y: el.y,<br>          width: el.width,<br>          height: el.height,<br>          rotation: el.rotation || <span class="hljs-number">0</span>, // 确保你的 CanvasElement 类型里有 rotation<br>          // 记录元素自身的中心点，方便后续计算<br>          cx: el.x + el.width / <span class="hljs-number">2</span>,<br>          cy: el.y + el.height / <span class="hljs-number">2</span><br>        };<br>      }<br>    });<br>    this.<span class="hljs-keyword">state</span>.rotationInitialStates = initialMap;<br><br>    undoRedoManager.lock();<br>    console.<span class="hljs-keyword">log</span>('[StageManager] 开始旋转操作');<br>    return;<br>  }<br><br>  // ... 原有的 resizing 逻辑保持不变 ...<br>  this.<span class="hljs-keyword">state</span>.mode = 'resizing';<br>  // ...<br>}<br></code></pre></td></tr></table></figure><h3 id="第四步：处理-onPointerMove-旋转进行中"><a href="#第四步：处理-onPointerMove-旋转进行中" class="headerlink" title="第四步：处理 onPointerMove (旋转进行中)"></a>第四步：处理 onPointerMove (旋转进行中)</h3><p>修改 onPointerMove，增加 rotating 模式的处理逻辑。</p><p>codeTypeScript</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 修改 onPointerMove 方法</span><br><span class="hljs-keyword">private</span> onPointerMove = (e: PIXI.FederatedPointerEvent) =&gt; {<br>  <span class="hljs-keyword">this</span>.triggerDebounceSnapshot();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'idle'</span>) <span class="hljs-keyword">return</span>;<br>  <br>  <span class="hljs-keyword">const</span> currentPos = e.getLocalPosition(<span class="hljs-keyword">this</span>.viewport);<br>  <span class="hljs-keyword">const</span> state = useStore.getState();<br><br>  <span class="hljs-comment">// ... selecting, dragging, resizing 等现有逻辑 ...</span><br><br>  <span class="hljs-comment">// === [新增] 旋转逻辑 ===</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationInitialStates &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationCenter) {<br>    <span class="hljs-keyword">const</span> { x: cx, y: cy } = <span class="hljs-keyword">this</span>.state.rotationCenter;<br>    <br>    <span class="hljs-comment">// 1. 计算当前鼠标角度</span><br>    <span class="hljs-keyword">const</span> currentAngle = Math.atan2(currentPos.y - cy, currentPos.x - cx);<br>    <br>    <span class="hljs-comment">// 2. 计算旋转增量（当前角度 - 起始角度）</span><br>    <span class="hljs-keyword">const</span> deltaAngle = currentAngle - <span class="hljs-keyword">this</span>.state.startRotationAngle;<br><br>    <span class="hljs-comment">// 3. 更新每一个选中元素</span><br>    state.selectedIds.forEach(id =&gt; {<br>      <span class="hljs-keyword">const</span> initEl = <span class="hljs-keyword">this</span>.state.rotationInitialStates![id];<br>      <span class="hljs-keyword">if</span> (!initEl) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// A. 计算新的自转角度</span><br>      <span class="hljs-keyword">const</span> newRotation = initEl.rotation + deltaAngle;<br><br>      <span class="hljs-comment">// B. 计算新的位置 (公转)</span><br>      <span class="hljs-comment">// 将元素的中心点 (initEl.cx, initEl.cy) 绕着 组中心 (cx, cy) 旋转 deltaAngle</span><br>      <span class="hljs-keyword">const</span> newCenter = <span class="hljs-keyword">this</span>.rotatePoint(initEl.cx, initEl.cy, cx, cy, deltaAngle);<br><br>      <span class="hljs-comment">// C. 根据新的中心点反推 x, y (x = center.x - width/2)</span><br>      <span class="hljs-keyword">const</span> newX = newCenter.x - initEl.width / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">const</span> newY = newCenter.y - initEl.height / <span class="hljs-number">2</span>;<br><br>      <span class="hljs-comment">// D. 更新 Store</span><br>      state.updateElement(id, {<br>        x: newX,<br>        y: newY,<br>        rotation: newRotation<br>      });<br>    });<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// ... drawing 逻辑 ...</span><br>}<br></code></pre></td></tr></table></figure><h3 id="第五步：处理-onPointerUp-结束旋转并记录历史"><a href="#第五步：处理-onPointerUp-结束旋转并记录历史" class="headerlink" title="第五步：处理 onPointerUp (结束旋转并记录历史)"></a>第五步：处理 onPointerUp (结束旋转并记录历史)</h3><p>在 onPointerUp 中处理旋转结束，生成 Undo/Redo 命令。</p><p>codeTypeScript</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 修改 onPointerUp 方法</span><br><span class="hljs-keyword">private</span> onPointerUp = () =&gt; {<br>  <span class="hljs-keyword">this</span>.triggerDebounceSnapshot();<br>  <span class="hljs-keyword">const</span> state = useStore.getState();<br><br>  <span class="hljs-comment">// ... erasing, selecting, drawing, dragging 等逻辑 ...</span><br><br>  <span class="hljs-comment">// === [新增] 旋转结束逻辑 ===</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationInitialStates) {<br>    console.log(<span class="hljs-string">'[StageManager] 结束旋转操作'</span>);<br>    undoRedoManager.unlock();<br><br>    <span class="hljs-keyword">const</span> operations: any[] = [];<br><br>    Object.entries(<span class="hljs-keyword">this</span>.state.rotationInitialStates).forEach(([id, initialAttrs]) =&gt; {<br>      <span class="hljs-keyword">const</span> finalElement = state.elements[id];<br>      <span class="hljs-keyword">if</span> (!finalElement) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 获取最终状态</span><br>      <span class="hljs-keyword">const</span> finalAttrs = {<br>        x: finalElement.x,<br>        y: finalElement.y,<br>        rotation: finalElement.rotation || <span class="hljs-number">0</span><br>      };<br><br>      <span class="hljs-comment">// 检查是否有变化 (对比 x, y, rotation)</span><br>      <span class="hljs-comment">// 注意：即使只是自转，x/y 也可能因为精度问题微变，或者如果是多选旋转，x/y 必然变</span><br>      <span class="hljs-keyword">const</span> hasChanged = <br>        Math.abs(initialAttrs.x - finalAttrs.x) &gt; <span class="hljs-number">0.01</span> ||<br>        Math.abs(initialAttrs.y - finalAttrs.y) &gt; <span class="hljs-number">0.01</span> ||<br>        Math.abs(initialAttrs.rotation - finalAttrs.rotation) &gt; <span class="hljs-number">0.001</span>;<br><br>      <span class="hljs-keyword">if</span> (hasChanged) {<br>        operations.push({<br>          id,<br>          initialAttrs: { x: initialAttrs.x, y: initialAttrs.y, rotation: initialAttrs.rotation },<br>          finalAttrs<br>        });<br>      }<br>    });<br><br>    <span class="hljs-keyword">if</span> (operations.length &gt; <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">const</span> rotateCommand = new UpdateElementCommand(operations, <span class="hljs-string">'旋转元素'</span>);<br>      undoRedoManager.executeCommand(rotateCommand);<br>    }<br>  }<br><br>  <span class="hljs-comment">// ... resizing 逻辑 ...</span><br>  <br>  <span class="hljs-comment">// 清理状态</span><br>  <span class="hljs-keyword">this</span>.state.mode = <span class="hljs-string">'idle'</span>;<br>  <span class="hljs-keyword">this</span>.state.currentId = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.activeHandle = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialElementState = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialElementsMap = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialGroupBounds = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.resizeInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.dragInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// [新增] 清理旋转状态</span><br>  <span class="hljs-keyword">this</span>.state.rotationInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.rotationCenter = <span class="hljs-literal">null</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h3><ol><li><p><strong>公转与自转</strong>：</p><ul><li><p>如果是<strong>单个元素</strong>被选中，计算出的 rotationCenter 就是该元素中心，公式依然成立（点绕自己旋转位置不变，只有 rotation 属性在变）。</p></li><li><p>如果是<strong>多个元素</strong>，它们会围绕整体的包围盒中心（Group Center）进行旋转，这实现了符合直觉的群组旋转效果。</p></li></ul></li><li><p><strong>CanvasElement 类型</strong>：<br> 请确保你的 CanvasElement 接口定义里加入了 rotation?: number 字段。<br> 同时，在渲染器 ElementRenderer 中，渲染 Sprite 或 Container 时，需要应用这个 rotation：</p><p> codeTypeScript</p> <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 在 ElementRenderer.ts 中</span><br><span class="hljs-comment">// Pixi 的 rotation 是以弧度为单位，且默认绕左上角旋转。</span><br><span class="hljs-comment">// 为了让元素绕中心旋转，通常做法是：</span><br><span class="hljs-comment">// 1. 设置 anchor 为 0.5 (Sprite) 或 pivot 为 width/2, height/2 (Graphics/Container)</span><br><span class="hljs-comment">// 2. 将 position 设置为 x + width/2, y + height/2</span><br><span class="hljs-comment">// 或者保持现有逻辑 (x,y在左上角)，但渲染时做矩阵变换。</span><br><br><span class="hljs-comment">// 推荐做法（在 renderElements 循环中）：</span><br>elementContainer.rotation = element.rotation || <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 注意：如果单纯设置 rotation，它会绕着 (x, y) 即左上角旋转。</span><br><span class="hljs-comment">// 如果要绕中心旋转，需要设置 pivot:</span><br>elementContainer.pivot.<span class="hljs-built_in">set</span>(element.width / <span class="hljs-number">2</span>, element.height / <span class="hljs-number">2</span>);<br>elementContainer.position.<span class="hljs-built_in">set</span>(element.x + element.width / <span class="hljs-number">2</span>, element.y + element.height / <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p> 注意：如果你修改了渲染器的 pivot/position 逻辑，可能会影响到上面的 onPointerMove 里的坐标计算逻辑。我上面给出的 StageManagerCore 代码是基于 <strong>x, y 始终代表左上角坐标</strong> 这一假设编写的（这是最通用的做法）。只要渲染器能正确根据左上角坐标 + 旋转角度绘制出绕中心旋转的图形即可。</p></li><li><p><strong>TransformerRenderer</strong>：<br> 你需要去 TransformerRenderer 里添加绘制一个连接到包围盒顶部的线和小圆圈，并给这个小圆圈设置 label = ‘handle:rotate’ 或者在事件传递时传出 rotate 类型，以便 onHandleDown 能识别。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;快照命令（SnapshotCommand）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于记录整个画布状态的变化&lt;/li&gt;
&lt;li&gt;通常用于添加元素、删除元素等较</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-21-canvas设计项目杂记其二</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39691.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39691.html</id>
    <published>2025-11-21T10:10:06.000Z</published>
    <updated>2025-11-23T16:44:43.096Z</updated>
    
    <content type="html"><![CDATA[<p>设计还原 Excalidraw 顶部栏工具样式</p><div class="table-container"><table><thead><tr><th>工具</th><th>对应代码操作</th></tr></thead><tbody><tr><td><strong>选择工具 (select)</strong></td><td>1. 当点击画布上的元素时，在  onPointerDown  方法中会设置该元素为选中状态<br>2. 当点击空白区域时，会清空选中状态<br>3. 当拖动时，会移动元素位置</td></tr><tr><td><strong>手型工具 (hand)</strong></td><td>目前代码中没有实现手型工具的具体功能，仅在工具栏进行了切换</td></tr><tr><td><strong>矩形工具 (rect)</strong></td><td>1. 在  onPointerDown  中创建新的矩形元素<br>2. 在  onPointerMove  中调整矩形大小<br>3. 在  render  方法中使用  <code>graphic.rect()</code>  或  <code>graphic.roundRect()</code>  绘制矩形</td></tr><tr><td><strong>菱形工具 (diamond)</strong></td><td>代码中有定义但未实现具体功能，目前不会绘制菱形</td></tr><tr><td><strong>圆形工具 (circle)</strong></td><td>1. 在  onPointerDown  中创建新的圆形元素<br>2. 在  onPointerMove  中调整圆形大小<br>3. 在  render  方法中使用  <code>graphic.ellipse()</code>  绘制圆形</td></tr><tr><td><strong>箭头工具 (arrow)</strong></td><td>代码中有定义但未实现具体功能，目前不会绘制箭头</td></tr><tr><td><strong>直线工具 (line)</strong></td><td>代码中有定义但未实现具体功能，目前不会绘制直线</td></tr><tr><td><strong>铅笔工具 (pencil)</strong></td><td>代码中有定义但未实现具体功能，目前不会进行自由绘制</td></tr><tr><td><strong>文本工具 (text)</strong></td><td>代码中有定义但未实现具体功能，目前不会添加文本</td></tr><tr><td><strong>图像工具 (image)</strong></td><td>代码中有定义但未实现具体功能，目前不会插入图片</td></tr><tr><td><strong>橡皮擦工具 (eraser)</strong></td><td>代码中有定义但未实现具体功能，目前不会删除元素</td></tr></tbody></table></div><h3 id="重构-Pixi-stageManager-ts"><a href="#重构-Pixi-stageManager-ts" class="headerlink" title="重构  Pixi_stageManager.ts"></a>重构  Pixi_stageManager.ts</h3><p>我们需要做比较大的改动：</p><ol><li>引入  Viewport  并将其添加到  app.stage。</li><li>所有的绘图元素（Graphics）现在都添加到  viewport  中，而不是  app.stage。</li><li>根据当前工具（hand vs rect/select）来启用或禁用 Viewport 的拖拽插件。</li></ol><h3 id="如何实现-Minimap（小地图）"><a href="#如何实现-Minimap（小地图）" class="headerlink" title="如何实现 Minimap（小地图）"></a>如何实现 Minimap（小地图）</h3><p>你提到了 Minimap，虽然代码量较大不便在此全部贴出，但我可以告诉你<strong>行业标准的实现思路</strong>。</p><p>有了  pixi-viewport  和 Zustand Store，实现 Minimap 其实就是做一个<strong>数据映射</strong></p><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><p>Minimap 本质上是一个独立的、微缩的视图。不要尝试去截取 Pixi Canvas 的图（性能太差）。你应该再画一遍，用简化的图形。</p><h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2. 实现步骤"></a>2. 实现步骤</h4><p><strong>A. 创建 Minimap 组件</strong><br>创建一个 React 组件，它固定在右下角。</p><p><strong>B. 坐标映射 (World -&gt; Minimap)</strong><br>假设你的 Minimap 大小是 200x150px。<br>你需要计算当前所有元素的<strong>包围盒 (Bounding Box)</strong>：</p><ul><li>minX, minY: 最左上角的元素位置</li><li>maxX, maxY: 最右下角的元素位置</li><li>contentWidth = maxX - minX</li><li>scale = minimapWidth / contentWidth</li></ul><p><strong>C. 渲染内容</strong><br>因为我们已经在 Zustand Store 里存了  { type: ‘rect’, x: 100, y: 100 … }  这样的纯数据，所以 Minimap 不需要 PixiJS。直接用 HTML5 <canvas>  或 SVG 渲染即可！</canvas></p><p>codeTsx</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 伪代码示例：Minimap SVG 实现</span><br>&lt;svg width=<span class="hljs-string">"200"</span> height=<span class="hljs-string">"150"</span> viewBox={`${minX} ${minY} ${width} ${height}`}&gt;<br>   {elements.<span class="hljs-built_in">map</span>(el =&gt; (<br>      &lt;rect x={el.x} y={el.y} width={el.width} height={el.height} fill=<span class="hljs-string">"#ccc"</span> /&gt;<br>   ))}<br><br>   {<span class="hljs-comment">/* 视口框：显示当前你正在看哪个区域 */</span>}<br>   &lt;rect<br>     x={viewport.center.x - viewport.worldScreenWidth/<span class="hljs-number">2</span>}<br>     y={viewport.center.y - viewport.worldScreenHeight/<span class="hljs-number">2</span>}<br>     width={viewport.worldScreenWidth}<br>     height={viewport.worldScreenHeight}<br>     stroke=<span class="hljs-string">"red"</span> fill=<span class="hljs-string">"none"</span><br>   /&gt;<br>&lt;/svg&gt;<br></code></pre></td></tr></table></figure><h4 id="3-双向绑定"><a href="#3-双向绑定" class="headerlink" title="3. 双向绑定"></a>3. 双向绑定</h4><ol><li><strong>View -&gt; Map</strong>: 当主画布  viewport  移动 (moved  事件) 时，更新 Minimap 里的红框位置。</li><li><strong>Map -&gt; View</strong>: 当拖拽 Minimap 里的红框时，调用  stageManager.viewport.moveCenter(x, y)  来移动主画布。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>无限画布</strong>：使用  pixi-viewport  代替原生  app.stage  容器。</li><li><p><strong>手型工具</strong>：</p><ul><li>当  tool === ‘hand’  时，调用  viewport.drag()  启用拖拽。</li><li>当  tool !== ‘hand’  时，viewport.plugins.pause(‘drag’)  暂停拖拽，以便进行绘图。</li></ul></li><li><p><strong>Minimap</strong>：使用 SVG 或第二个轻量 Canvas，通过 Store 数据渲染所有元素的微缩版，并计算一个“视口矩形”覆盖在上面。</p></li></ol><h3 id="改动说明"><a href="#改动说明" class="headerlink" title="改动说明"></a>改动说明</h3><ol><li><p><strong>updateViewportState  逻辑变更</strong>：</p><ul><li>之前：hand  模式开启 drag，其他模式暂停 drag。</li><li>现在：所有模式都开启 drag。<ul><li>普通模式：drag({ mouseButtons: ‘middle’ })。中键拖动画布，左键留给选择。</li><li>手型模式：drag({ mouseButtons: ‘all’ })。左键或中键都可以拖动画布。</li></ul></li></ul></li><li><p><strong>onPointerDown  拦截</strong>：</p><ul><li>新增  if (e.button === 1) return。</li><li>这样当用户按下中键时，Pixi_stageManager  的自定义逻辑（选择元素、创建元素）会被跳过，控制权完全交给  pixi-viewport  进行画布平移。</li></ul></li><li><p><strong>默认行为阻止</strong>：</p><ul><li>在  initApp  中添加了  container.addEventListener(‘mousedown’, …)  来阻止中键点击时的默认滚动图标出现，体验更顺滑。</li></ul></li></ol><p>现在，你可以在保持“选择工具”激活的情况下，直接按住鼠标中键来拖拽画布，释放中键后继续使用左键选择或移动元素。同时，左侧工具栏的“手型工具”和“空格键”快捷键依然有效（它们会把左键也变成拖拽）。</p><h2 id="“Rubber-band-Selection”-框选-和-“Transformer-Gizmo”-变换控制器-。"><a href="#“Rubber-band-Selection”-框选-和-“Transformer-Gizmo”-变换控制器-。" class="headerlink" title="“Rubber-band Selection” (框选)  和  “Transformer / Gizmo” (变换控制器)。"></a><strong>“Rubber-band Selection” (框选)</strong>  和  <strong>“Transformer / Gizmo” (变换控制器)</strong>。</h2><p>对  Pixi_stageManager.ts  进行较大幅度的扩展。为了保持代码清晰，我们将逻辑分为两部分：</p><ol><li><strong>框选逻辑</strong>：在空白处拖拽绘制蓝色半透明矩形，松开时计算碰撞。</li><li><strong>变换逻辑</strong>：选中元素时绘制 8 个控制点，拖拽控制点改变元素尺寸。</li></ol><p>以下是完整的实现方案。</p><h3 id="1-核心逻辑修改思路"><a href="#1-核心逻辑修改思路" class="headerlink" title="1. 核心逻辑修改思路"></a>1. 核心逻辑修改思路</h3><p>我们需要引入一个新的图层概念（UI Layer），确保框选框和控制手柄永远画在元素之上。</p><ul><li><strong>状态增加</strong>：增加  interactionMode  状态，区分  idle | panning | dragging (拖拽元素) | selecting (框选) | resizing (调整大小)。</li><li><strong>Resize 算法</strong>：根据当前拖拽的是哪个角（如 Top-Left），反向计算  x, y, width, height。</li></ul><h3 id="2-更新-Pixi-stageManager-ts"><a href="#2-更新-Pixi-stageManager-ts" class="headerlink" title="2. 更新  Pixi_stageManager.ts"></a>2. 更新  Pixi_stageManager.ts</h3><hr><p>改用世界坐标系进行计算：</p><ol><li>通过  <code>e.getLocalPosition(this.viewport)</code>  获取鼠标在世界坐标系中的当前位置</li><li>计算当前位置与起始位置的差值  <code>dx</code>  和  <code>dy</code></li><li>直接将这个差值应用到元素的位置上，无需考虑缩放因子</li><li>更新起始位置为当前位置，为下次移动计算做准备</li></ol><hr><p>StageManager 类<br>├── 类属性定义模块<br>│ ├── PIXI 应用和视口<br>│ ├── 图层管理<br>│ ├── 元素映射<br>│ ├── 交互状态<br>│ ├── 辅助图形<br>│ └── 变换/拖拽相关数据<br>├── 构造函数与初始化模块<br>│ ├── 主构造函数<br>│ │ ├── 应用初始化<br>│ │ ├── 视口设置<br>│ │ ├── 图层结构初始化<br>│ │ ├── UI 元素初始化<br>│ │ ├── 交互设置<br>│ │ └── 状态订阅<br>│ └── 应用初始化方法 (initApp)<br>├── 视口管理模块<br>│ └── 视口设置 (setupViewport)<br>├── 渲染核心模块<br>│ ├── 画布元素渲染 (renderElements)<br>│ └── 变换控制器渲染 (renderTransformer)<br>├── 交互逻辑模块<br>│ ├── 交互设置 (setupInteraction)<br>│ ├── 指针按下处理 (onPointerDown)<br>│ ├── 手柄按下处理 (onHandleDown)<br>│ ├── 指针移动处理 (onPointerMove)<br>│ └── 指针抬起处理 (onPointerUp)<br>├── 辅助函数模块<br>│ ├── 获取手柄光标样式 (getCursorForHandle)<br>│ ├── 更新视口状态 (updateViewportState)<br>│ ├── 设置空格键状态 (setSpacePressed)<br>│ ├── 更新光标 (updateCursor)<br>│ └── 销毁方法 (destroy)</p><hr><p>修复了图像创建后没有立即渲染的问题。主要的修改包括：</p><ol><li>当图像纹理正在加载时，创建一个占位符图形（灰色矩形）立即显示在画布上，这样用户就能立即看到图像的位置和大小。</li><li>在纹理加载完成后，更新纹理缓存并直接更新已存在的图形，而不是等待下一次重新渲染。</li><li>移除了使用非空断言操作符（<code>!</code>）的代码，使类型检查更加安全。</li><li>简化了图像渲染逻辑，确保在纹理加载完成前也能显示占位符。</li></ol><p>这些修改确保了图像元素在创建时能够立即显示（虽然是占位符），而不是完全不可见直到其他操作触发重新渲染。当图像纹理加载完成后，占位符会自动更新为实际的图像。</p><h2 id="图像加载机制详解"><a href="#图像加载机制详解" class="headerlink" title="图像加载机制详解"></a>图像加载机制详解</h2><h3 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1. 整体流程"></a>1. 整体流程</h3><p>图像加载采用异步方式处理，主要分为以下几个步骤：</p><ol><li><strong>检查缓存</strong>：首先检查纹理是否已经在缓存中存在</li><li><strong>加载纹理</strong>：如果不存在，则启动纹理加载过程</li><li><strong>显示占位符</strong>：在纹理加载期间，显示一个灰色占位符矩形</li><li><strong>更新显示</strong>：纹理加载完成后，将占位符替换为实际图像</li></ol><h3 id="2-核心组件"><a href="#2-核心组件" class="headerlink" title="2. 核心组件"></a>2. 核心组件</h3><p>typescript</p><p><code>private spriteMap: Map&lt;string, PIXI.Graphics | HTMLText | PIXI.Sprite&gt; = new Map() private textureCache: Map&lt;string, PIXI.Texture&gt; = new Map() private loadingSet: Set&lt;string&gt; = new Set()</code></p><ul><li><strong>spriteMap</strong>：存储所有已创建的图形对象（包括占位符和实际图像）</li><li><strong>textureCache</strong>：缓存已加载的纹理，避免重复加载</li><li><strong>loadingSet</strong>：记录正在加载的 URL，防止重复发起加载请求</li></ul><h3 id="3-加载过程详解"><a href="#3-加载过程详解" class="headerlink" title="3. 加载过程详解"></a>3. 加载过程详解</h3><h4 id="3-1-检查缓存"><a href="#3-1-检查缓存" class="headerlink" title="3.1 检查缓存"></a>3.1 检查缓存</h4><p>typescript</p><p><code>let texture = this.textureCache.get(data.imageUrl)</code></p><p>如果纹理已存在缓存中，直接使用，无需重新加载。</p><h4 id="3-2-防止重复加载"><a href="#3-2-防止重复加载" class="headerlink" title="3.2 防止重复加载"></a>3.2 防止重复加载</h4><p>typescript</p><p><code>if (!this.loadingSet.has(data.imageUrl)) {   this.loadingSet.add(data.imageUrl)   // 开始加载 }</code></p><p>通过 loadingSet 确保同一 URL 不会被重复加载。</p><h4 id="3-3-异步加载"><a href="#3-3-异步加载" class="headerlink" title="3.3 异步加载"></a>3.3 异步加载</h4><p>typescript</p><p><code>PIXI.Assets.load(data.imageUrl)   .then((loadedTexture) =&gt; {     // 加载成功处理   })   .catch((err) =&gt; {     // 加载失败处理   })</code></p><p>使用 PIXI 的资源加载器进行异步加载。</p><h4 id="3-4-占位符显示"><a href="#3-4-占位符显示" class="headerlink" title="3.4 占位符显示"></a>3.4 占位符显示</h4><p>在纹理加载期间，创建一个灰色矩形作为占位符：</p><p>typescript</p><p><code>graphic = new PIXI.Graphics() graphic.rect(0, 0, data.width, data.height) graphic.fill({ color: 0xdddddd }) graphic.stroke({ width: 1, color: 0x999999 })</code></p><h4 id="3-5-加载完成后更新"><a href="#3-5-加载完成后更新" class="headerlink" title="3.5 加载完成后更新"></a>3.5 加载完成后更新</h4><p>纹理加载完成后，立即替换占位符：</p><p>typescript</p><p><code>// 替换占位符为真实图像 elementLayer.removeChild(graphic) graphic.destroy() // 创建新的Sprite const sprite = new PIXI.Sprite(loadedTexture) // 设置属性... elementLayer.addChild(sprite) this.spriteMap.set(id, sprite)</code></p><h3 id="4-性能优化措施"><a href="#4-性能优化措施" class="headerlink" title="4. 性能优化措施"></a>4. 性能优化措施</h3><ol><li><strong>缓存机制</strong>：避免重复加载相同 URL 的图像</li><li><strong>防止重复请求</strong>：通过 loadingSet 避免对同一 URL 发起多次加载请求</li><li><strong>及时清理</strong>：元素移除时清理相关资源和引用</li><li><strong>立即更新</strong>：纹理加载完成后立即更新显示，无需等待其他操作</li></ol><h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><p>当图像加载失败时，会输出错误日志并从加载集合中移除 URL：</p><p>typescript</p><p><code>.catch((err) =&gt; {   console.error('Failed to load asset:', err)   this.loadingSet.delete(data.imageUrl) })</code></p><h3 id="6-资源清理"><a href="#6-资源清理" class="headerlink" title="6. 资源清理"></a>6. 资源清理</h3><p>当元素被移除时，会进行适当的资源清理：</p><ol><li>移除图形对象</li><li>销毁不再使用的纹理</li><li>清理相关引用和定时器</li></ol><p>这套机制确保了图像加载既高效又用户友好，在图像加载期间提供视觉反馈，并在加载完成后立即显示图像。</p><ol><li><strong>types.ts</strong>: 增加了  initialElementsMap  和  initialGroupBounds  来存储多选时的初始状态。</li><li><p><strong>StageManagerCore.ts</strong>:</p><ul><li>onHandleDown: 现在会捕捉所有选中元素的快照，并计算初始的群组包围盒。</li><li>onPointerMove: 重写了  resizing  逻辑。它不再单纯调整单个元素，而是先计算鼠标移动导致的<strong>新包围盒</strong>，计算出<strong>宽高的缩放比例</strong>，然后应用到所有选中元素上（包括坐标、宽高和内部点集）。</li></ul></li></ol><p>这是一个典型的多选缩放问题。</p><p><strong>问题原因：</strong><br>在现有的  StageManagerCore.ts  中，onPointerMove  的  resizing  逻辑只处理了单体元素 (this.state.currentId) 的更新。当你选中多个元素时，虽然  TransformerRenderer  画出了一个大的包围盒，但交互逻辑实际上只在操作第一个被选中的元素，导致其他元素不动，或者计算逻辑完全错误（因为没有基于群组包围盒进行整体缩放），从而出现“锚点脱离”和“大小失控”的现象。</p><p><strong>解决方案：</strong><br>我们需要修改  StageManagerCore.ts  和  types.ts。</p><ol><li><strong>状态存储</strong>：在  onHandleDown  时，不再只存储单个元素的初始状态，而是需要计算并存储<strong>整个选区的初始包围盒 (Group Bounds)</strong>  以及<strong>所有被选元素的初始状态</strong>。</li><li><strong>移动计算</strong>：在  onPointerMove  时，根据鼠标位移计算出<strong>新的群组包围盒</strong>，得出宽高的<strong>缩放比例 (scaleX, scaleY)</strong>，然后根据这个比例更新所有被选元素的坐标和尺寸。</li></ol><hr><ol><li><p><strong>使用 Command Pattern</strong>：</p><ul><li>实现了基本的命令接口  Command</li><li>提供了  SnapshotCommand  类处理完整的状态快照</li><li>使用两个栈管理撤销和重做操作</li></ul></li><li><p><strong>使用 structuredClone 进行快照</strong>：</p><ul><li>对整个 store 状态进行深克隆</li><li>保证状态回退时不会出现引用问题</li></ul></li><li><p><strong>自动捕获状态变更</strong>：</p><ul><li>通过包装 Zustand 的 set 方法自动捕获所有状态变更</li><li>无需手动在每个操作后调用记录方法</li></ul></li><li><p><strong>防止递归记录</strong>：</p><ul><li>使用锁定机制避免在执行撤销/重做操作时记录新命令</li></ul></li><li><p><strong>键盘快捷键支持</strong>：</p><ul><li>支持标准的 Ctrl+Z 撤销和 Ctrl+Y/Ctrl+Shift+Z 重做</li></ul></li></ol><p>这种实现方式简单有效，能够满足大部分撤销/重做需求，并且与现有的项目架构很好地集成。</p><ol><li><p><strong>使用  <code>structuredClone()</code> API</strong>：</p><ul><li>我们使用浏览器内置的  <a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">structuredClone()</a>  函数来创建状态对象的深拷贝</li><li>这个 API 可以创建对象的完整副本，包括嵌套的对象和数组</li></ul></li><li><p><strong>只克隆数据部分</strong>：</p><ul><li>由于 Zustand store 状态既包含数据属性也包含函数属性，而  <code>structuredClone()</code>  无法克隆函数，所以我们需要分离这两部分</li><li>使用解构赋值语法排除所有函数属性：<br>javascript<br><code>const {    setTool, addElement, updateElement, removeElements, setSelected,   setEditingId, copyElements, pasteElements, undo, redo, canUndo, canRedo,   ...dataOnlyState  } = state;</code></li><li>这样  dataOnlyState  就只包含纯数据属性，如  tool、elements、selectedIds  等</li></ul></li><li><p><strong>在撤销/重做系统中的应用</strong>：</p><ul><li>在每次状态更改前后捕获快照</li><li>将这些快照传递给  SnapshotCommand  来记录状态变化</li><li>当用户执行撤销或重做操作时，可以从这些快照恢复到之前的状态</li></ul></li></ol><p>这种机制确保我们可以准确地跟踪和恢复画布状态的变化历史，同时避免了尝试克隆不可序列化函数的错误。</p><p>你提到的问题非常准确。目前的实现方式确实会在创建选框等操作过程中记录每一步的状态变化，这会导致撤销/重做系统产生过多不必要的快照。</p><p>对于绘图应用来说，用户期望的行为通常是：</p><ol><li>在开始绘制时标记操作起点</li><li>在绘制结束时才生成一个完整的撤销点</li><li>而不是记录过程中的每个微小变化</li></ol><p>针对这个问题，常见的解决方案有几种：</p><ol><li><strong>批量操作机制</strong>：允许临时锁定 undo/redo 系统，在一系列连续操作完成后再解锁并记录最终状态。</li><li><strong>防抖动机制</strong>：在快速连续的操作中，只记录特定时间间隔的状态。</li><li><strong>操作分组</strong>：将相关的操作归为一组，作为一个整体进行撤销/重做。</li></ol><p>考虑到你们项目的情况，我觉得第一种方案比较适合，即增加开始和结束批量操作的方法。</p><p>不过目前的实现也有它的优势，就是可以精确还原到任意一个中间状态。在实际使用中可以根据用户体验需求来权衡是否需要优化这一点。</p><p><del>添加一个防抖动机制。这样可以避免在连续操作（如绘制矩形）过程中产生过多的快照。</del></p><p>更好的方法是在绘制开始时记录初始状态，在绘制结束时记录最终状态，形成一个完整的操作单元。让我来实现这个机制：</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>你当前的代码存在两个主要问题：</p><ol><li><strong>Middleware 过于激进</strong>：subscribeWithSelector  会拦截每一次  set  调用。当你拖拽一个矩形移动 100px 时，会触发约 60 次  set，导致历史记录里塞满了 60 个微小的移动快照。这会导致内存爆炸且撤销体验极差（按一次撤销只动 1px）。</li><li><strong>逻辑分散</strong>：你试图在  UndoRedoManager  里用计时器（setTimeout）来判断什么时候结束创建，这非常不稳定。</li></ol><h3 id="核心思路：Excalidraw-模式"><a href="#核心思路：Excalidraw-模式" class="headerlink" title="核心思路：Excalidraw 模式"></a>核心思路：Excalidraw 模式</h3><p>Excalidraw 的核心逻辑是：</p><ol><li><strong>PointerDown (开始)</strong>：记录当前画布的快照（作为“旧状态”）。</li><li><strong>PointerMove (过程)</strong>：疯狂更新 Store（瞬时状态），<strong>但不</strong>推入历史记录。</li><li><strong>PointerUp (结束)</strong>：对比当前状态和旧状态。如果有变化，将“旧状态”和“新状态”封装成一个命令，推入历史栈。</li></ol><hr><h3 id="重构方案"><a href="#重构方案" class="headerlink" title="重构方案"></a>重构方案</h3><p>我们将移除 Store 中的自动拦截中间件，改为由<strong>交互层 (StageManagerCore)</strong>  主动控制历史记录的时机。</p><h4 id="1-重写-UndoRedoManager-ts-简化版"><a href="#1-重写-UndoRedoManager-ts-简化版" class="headerlink" title="1. 重写  UndoRedoManager.ts (简化版)"></a>1. 重写  UndoRedoManager.ts (简化版)</h4><p>不再需要复杂的计时器和模式判断，回归纯粹的栈管理。</p><ol><li><p><strong>移动（Move/Drag）操作丢失</strong>：</p><ul><li>在  onPointerDown  中，当检测到点击元素（dragging  模式）时，你调用了  undoRedoManager.lock()。</li><li>在  onPointerMove  中，元素位置被更新，但因为处于锁定状态，canvasStore  的中间件忽略了这些更新（这是正确的，防止产生大量快照）。</li><li><strong>关键缺漏</strong>：在  onPointerUp  中，当  mode === ‘dragging’  结束时，代码只执行了  unlock()，<strong>没有创建并执行任何 Command</strong>。</li><li><strong>结果</strong>：Store 中的状态变成了 B，但撤销栈里什么都没记。当你后续进行 Resize 操作（B -&gt; C）并记录了 Command 后，一旦撤销，Resize Command 会把状态恢复到 B。再次撤销时，由于 Move 操作没记录，状态无法回到 A，或者表现为“跳过”了某些步骤。</li></ul></li><li><p><strong>Resize 操作的 “Redo 直接到 B” 现象</strong>：</p><ul><li>这通常是由于历史栈的不连续性造成的。如果 “Move A-&gt;B” 没被记录，那么栈里可能是  [Create(A), Resize(B-&gt;C), Resize(C-&gt;D)]。</li><li>当你撤销  Resize(C-&gt;D) -&gt; 变回 C。</li><li>撤销  Resize(B-&gt;C) -&gt; 变回 B。</li><li>此时再撤销，会直接遇到  Create(A)  或空栈，导致状态突变。</li><li>此外，如果 Resize 的逻辑只依赖于  initialMap，而没有正确处理连续操作间的状态同步，也可能导致此问题。</li></ul></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们需要做一个通用的  <strong>UpdateElementCommand</strong>（替换或扩展  ResizeCommand），并在  StageManagerCore  的  onPointerUp  中，<strong>为移动（Dragging）和调整大小（Resizing）都创建并执行这个命令</strong>。</p><p>时间点操作画布状态（实际）命令 ID说明22:40:08创建矩形 A有 A808615第一次画矩形22:40:25创建矩形 B有 A + B825552第二次画矩形22:40:40撤销（Undo）只剩 A825552撤销“添加 B”22:40:47再次撤销（Undo）画布完全为空808615撤销“添加 A”22:41:48重做（Redo）第一次出现 A（但没看到（可能大小为0位置也不对））808615执行“添加 A”的命令22:41:49重做（Redo）第二次出现 A + B825552执行“添加 B”的命令</p><p>第一次重做“没反应”<br>第二次重做突然正常</p><p>修复这个问题</p><p>Model</p><p class='item-img' data-src='https://www.gstatic.com/aistudio/watermark/watermark.png'><img src="https://www.gstatic.com/aistudio/watermark/watermark.png" alt="Thinking">Thoughts</p><p>Expand to view model thoughts</p><p>chevron_right</p><p>这是一个非常经典的 Canvas 编辑器撤销/重做状态不同步问题。</p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>现象：</strong></p><ol><li><p>创建矩形 A（此时宽/高为 0）。</p></li><li><p>拖拽绘制矩形 A（宽/高变为 100）。</p></li><li><p>撤销。</p></li><li><p>重做 -&gt; <strong>矩形 A 虽然出现了，但大小可能为 0 或者不可见。</strong></p></li></ol><p><strong>原因：</strong></p><ol><li><p>当你在 onPointerDown 中调用 state.addElement 时，Zustand 的中间件（或监听器）立即捕获了状态变更并创建了一个 SnapshotCommand。</p></li><li><p><strong>关键点</strong>：此时创建的 SnapshotCommand 中记录的 nextState 是元素刚创建时的状态（即 width: 0, height: 0）。</p></li><li><p>随后你调用了 undoRedoManager.lock()。</p></li><li><p>在 onPointerMove 和 onPointerUp 过程中，虽然元素的属性更新了，但由于管理器被 <strong>Locked</strong>，且之前的 SnapshotCommand 已经生成完毕，<strong>历史记录中存储的“最终状态”仍然是宽高为 0 的状态</strong>。</p></li><li><p>当你执行 <strong>Undo</strong> 再 <strong>Redo</strong> 时，它恢复的是历史记录中的 nextState (宽高为 0)，导致元素看起来“没反应”或不可见。</p></li></ol><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们需要在绘制结束（onPointerUp）时，更新历史栈顶那个“创建命令”的 nextState，将其替换为绘制完成后的最终状态。</p><p>以下是修复代码：</p><h4 id="1-修改-UndoRedoManager-ts"><a href="#1-修改-UndoRedoManager-ts" class="headerlink" title="1. 修改 UndoRedoManager.ts"></a>1. 修改 UndoRedoManager.ts</h4><p>我们需要给 SnapshotCommand 和 UndoRedoManager 添加更新状态的能力。</p><p>codeTypeScript</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// --- UndoRedoManager.ts ---</span><br><br><span class="hljs-comment">// ... imports</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UndoRedoManager</span> {<br>  <span class="hljs-comment">// ... existing code ...</span><br><br>  <span class="hljs-comment">// [新增] 用于在操作结束时更新栈顶命令的最终状态</span><br>  <span class="hljs-title function_">updateLatestSnapshot</span>(<span class="hljs-params"><span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span></span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">const</span> lastCommand = <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-comment">// 确保只更新 SnapshotCommand 类型的命令</span><br>    <span class="hljs-keyword">if</span> (lastCommand <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SnapshotCommand</span>) {<br>      lastCommand.<span class="hljs-title function_">updateNextState</span>(nextState)<br>      logger.<span class="hljs-title function_">debug</span>(<span class="hljs-string">'[UndoRedoManager] 已更新最近一次快照的最终状态'</span>)<br>    }<br>  }<br>}<br><br><span class="hljs-comment">// ... existing code ...</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-comment">// ... existing properties ...</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span></span>) {<br>    <span class="hljs-comment">// ... existing constructor code ...</span><br>  }<br><br>  <span class="hljs-comment">// [新增] 更新 nextState 的方法</span><br>  <span class="hljs-title function_">updateNextState</span>(<span class="hljs-params"><span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span> = nextState<br>    logger.<span class="hljs-title function_">debug</span>(<span class="hljs-string">`[SnapshotCommand] 命令 ID: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.commandId}</span> 的最终状态已更新`</span>)<br>  }<br><br>  <span class="hljs-comment">// ... execute, undo, redo ...</span><br>}<br></code></pre></td></tr></table></figure><h4 id="2-修改-StageManagerCore-ts"><a href="#2-修改-StageManagerCore-ts" class="headerlink" title="2. 修改 StageManagerCore.ts"></a>2. 修改 StageManagerCore.ts</h4><p>在 onPointerUp 的绘制结束逻辑中，调用刚刚添加的 updateLatestSnapshot 方法。</p><p>codeTypeScript</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pf">// --- StageManagerCore.ts ---<br><br>// ... imports ... <br>// 确保引入了 store<br>import { useStore } <span class="hljs-keyword">from</span> '@/stores/canvasStore' <br><br>export class StageManagerCore {<br>  // ... existing code ...<br><br>  private <span class="hljs-keyword">on</span>PointerUp = () =&gt; {<br>    // 触发防抖检查<br>    this.triggerDebounceSnapshot()<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = useStore.getState()<br>    <br>    // ... erasing logic ...<br>    // ... selecting logic ...<br><br>    // === 修复的核心位置：Drawing 模式结束 ===<br>    if (this.<span class="hljs-keyword">state</span>.mode === 'drawing' &amp;&amp; this.<span class="hljs-keyword">state</span>.currentId) {<br>      <span class="hljs-keyword">const</span> el = <span class="hljs-keyword">state</span>.elements[this.<span class="hljs-keyword">state</span>.currentId]<br>      if ((el.type === 'pencil' || el.type === 'line' || el.type === 'arrow') &amp;&amp; el.points) {<br>        // ... 计算 points 的逻辑 ...<br>        <span class="hljs-keyword">state</span>.updateElement(this.<span class="hljs-keyword">state</span>.currentId, {<br>          x: newX,<br>          y: newY,<br>          width: <span class="hljs-keyword">max</span>X - <span class="hljs-keyword">min</span>X,<br>          height: <span class="hljs-keyword">max</span>Y - <span class="hljs-keyword">min</span>Y,<br>          points: newPoints,<br>        })<br>      }<br>      <br>      // [新增] 修复 Undo/Redo Bug<br>      // 在解锁前或解锁后均可，关键是获取当前的最新 State（包含了最终宽高的 State）<br>      // 并更新掉 <span class="hljs-keyword">on</span>PointerDown 时记录的那个“<span class="hljs-number">0</span>宽高”的快照<br>      undoRedoManager.updateLatestSnapshot(useStore.getState())<br><br>      // 解锁撤销/重做管理器<br>      undoRedoManager.unlock()<br>      console.<span class="hljs-keyword">log</span>('[StageManager] 解锁撤销/重做管理器')<br>    }<br><br>    // ... dragging logic ...<br>    // ... resizing logic ...<br>    <br>    // ... cleanup ...<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="为什么这样做有效？"><a href="#为什么这样做有效？" class="headerlink" title="为什么这样做有效？"></a>为什么这样做有效？</h3><ol><li><p><strong>Down</strong>: 创建元素(0x0) -&gt; 触发快照 -&gt; 锁定管理器。栈顶命令记录为：Prev: 无, Next: 元素(0x0)。</p></li><li><p><strong>Move</strong>: 更新元素(100x100) -&gt; 管理器锁定中，不产生新命令。</p></li><li><p><strong>Up</strong>: 更新元素最终位置 -&gt; <strong>调用 updateLatestSnapshot</strong>。<br> 栈顶命令变为：Prev: 无, Next: 元素(100x100)。</p></li><li><p><strong>Undo</strong>: 回退到 Prev (无)。</p></li><li><p><strong>Redo</strong>: 前进到 Next (元素 100x100)。<strong>现在元素可见了！</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计还原 Excalidraw 顶部栏工具样式&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;对应代码操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;t</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-21-canvas项目杂记</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/14933.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/14933.html</id>
    <published>2025-11-21T06:50:48.000Z</published>
    <updated>2025-11-23T09:36:28.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><del>分析</del></h2><p><del>要做的就是一个<strong>类 Canva / Figma 的在线图形绘板</strong>，完整需求优先级和覆盖范围如下：</del></p><div class="table-container"><table><thead><tr><th>优先级</th><th>功能模块</th><th>具体需求</th><th>是否必须</th><th>难度</th></tr></thead><tbody><tr><td>P0</td><td>基础渲染</td><td>矩形、圆形、三角形任意填充色、边框色、边框宽度、圆角、透明度</td><td>Yes</td><td>★☆</td></tr><tr><td>P0</td><td>图片支持</td><td>上传 png/jpg/webp，任意缩放、圆角、模糊、灰度、亮度调节、裁剪掩模</td><td>Yes</td><td>★★</td></tr><tr><td>P0</td><td>富文本</td><td>字体、字号、颜色、加粗、斜体、下划线、删除线、文本背景色、文字对齐、行距、局部样式支持</td><td>Yes</td><td>★★★★</td></tr><tr><td>P0</td><td>基本交互</td><td>单选、多选（框选 + Shift）、拖拽、删除、复制粘贴、缩放把手（8 个方向）、旋转把手</td><td>Yes</td><td>★★</td></tr><tr><td>P0</td><td>无限画布 + 缩放平移</td><td>Ctrl+滚轮缩放、空格拖拽平移、无限滚动</td><td>Yes</td><td>★☆</td></tr><tr><td>P0</td><td>数据持久化</td><td>自动 localStorage 保存、打开页面自动恢复</td><td>Yes</td><td>★☆</td></tr><tr><td>P1</td><td>高级交互</td><td>组合（Group）、解散组合、图层排序、辅助对齐线、吸附、旋转任意角度</td><td>Yes</td><td>★★★</td></tr><tr><td>P1</td><td>工具栏 &amp; 属性面板</td><td>顶部工具栏（切换文本/形状/图片模式）、右侧属性面板实时编辑属性</td><td>Yes</td><td>★★</td></tr><tr><td>P1</td><td>历史记录</td><td>Undo / Redo（支持跨会话）</td><td>Yes</td><td>★★</td></tr><tr><td>P1</td><td>性能要求</td><td>100 个复杂元素（图片+富文本）打开 &lt; 3s，拖拽 60fps 不闪烁</td><td>Yes</td><td>★★★★</td></tr><tr><td>P2</td><td>未来可扩展</td><td>实时协同编辑、离线编辑、模板库、导出 PNG/SVG/PDF、激光笔、箭头、自由画笔等</td><td>No</td><td>★★★★</td></tr></tbody></table></div><h1 id="架构方案"><a href="#架构方案" class="headerlink" title="架构方案"></a><del>架构方案</del></h1><ul><li><del><strong>渲染层</strong>：PixiJS (WebGL) 处理高性能图形渲染 + HTML DOM 处理文本编辑/输入框。</del></li><li><del><strong>状态管理</strong>：Zustand / Pinia (管理庞大的 JSON 画布数据)。</del></li><li><del><strong>逻辑层</strong>：自定义 Class 结构（如  Shape, Tool, History）实现面向对象编程。</del></li></ul><h3 id="二、项目设计要素"><a href="#二、项目设计要素" class="headerlink" title="二、项目设计要素"></a><del>二、项目设计要素</del></h3><div class="table-container"><table><thead><tr><th>设计维度</th><th>推荐技术方案</th><th></th></tr></thead><tbody><tr><td>1. 渲染引擎</td><td>PixiJS v8（WebGL） + HTMLText</td><td>WebGL 抗锯齿完美 + 高分屏不模糊；HTMLText 是目前唯一能轻松实现富文本局部样式的方案</td></tr><tr><td>2. 状态管理</td><td>Zustand（或 Jotai + signals）</td><td>轻量、响应式、支持中间件（持久化、历史栈）</td></tr><tr><td>3. 元素对象缓存</td><td>Map<string, Container=""> 永久缓存（一个元素一个 Container，永不 destroy）</string,></td><td>彻底解决闪烁、拖拽中断、光标丢失的根本方案</td></tr><tr><td>4. 历史栈</td><td>Command Pattern + structuredClone 快照（每操作记录 before/after）</td><td>简单可靠，支持跨页面 Undo</td></tr><tr><td>5. 选中/变换系统</td><td>单独的 SelectionManager + TransformHandles（旋转、缩放把手层也缓存）</td><td>tldraw/Figma 标配</td></tr><tr><td>6. 辅助对齐线</td><td>拖拽时实时遍历所有元素 bounds，差值 &lt; 5px 就吸附并画蓝线</td><td>提升专业感</td></tr><tr><td>7. 组合（Group）</td><td>元素加 groupId 字段；选中时绘制大虚线框；拖拽/缩放/旋转时整体应用矩阵变换</td><td>必须有，属于 P1 核心</td></tr><tr><td>8. 数据持久化</td><td>Zustand middleware persist + localForage（IndexedDB）</td><td>防止 localStorage 炸掉</td></tr><tr><td>9. 图片处理</td><td>Sprite + Graphics mask（圆角）+ BlurFilter + ColorMatrixFilter</td><td>PixiJS 原生支持</td></tr><tr><td>10. 架构分层</td><td>- store（纯数据） - rendering（Pixi 元素缓存 &amp; 更新） - interaction（拖拽、选中逻辑） - ui（React 面板）</td></tr></tbody></table></div><p><del>installed pixi.js@8.14.3</del><br><del>installed zustand@5.0.8</del><br><del>installed nanoid@5.1.6</del></p><p><del><strong>数据驱动视图”（Data-Driven View）</strong>  模式，采用了  <strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>  的三层分离架构</del></p><p><del>这种架构的核心理念是：<strong>PixiJS 实例不保存“业务状态”，它只是 Zustand 数据的“投影”</strong></del></p><p><del class='item-img' data-src='Pasted%20image%2020251121155817.png'><img src="Pasted%20image%2020251121155817.png" alt=""></del></p><p><del>其中，</del></p><ul><li><del>React 只负责 UI 和事件入口</del></li><li><del>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）</del></li><li><del>PixiJS 层只做“渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建</del></li><li><del>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</del></li></ul><h3 id="三层架构详解"><a href="#三层架构详解" class="headerlink" title="三层架构详解"></a><del>三层架构详解</del></h3><h4 id="第一层：数据层-The-Source-of-Truth-canvasStore-ts"><a href="#第一层：数据层-The-Source-of-Truth-canvasStore-ts" class="headerlink" title="第一层：数据层 (The Source of Truth) - canvasStore.ts"></a><del>第一层：数据层 (The Source of Truth) - canvasStore.ts</del></h4><p><del>这是整个应用的大脑。</del></p><ul><li><del><strong>职责</strong>：只存储纯 JSON 数据（Serializable），不包含任何 UI 实例或 Pixi 对象。</del></li><li><del><strong>存储内容</strong>：</del><ul><li><del>elements: 一个 Map 对象（Record<id, Element="">），存储所有矩形、圆形的坐标、颜色等。</id,></del></li><li><del>selectedIds: 当前选中的 ID 列表。</del></li><li><del>tool: 当前使用的工具。</del></li></ul></li><li><del><strong>特点</strong>：</del><ul><li><del><strong>单一数据源</strong>：画布上显示什么，完全由这里的数据决定。</del></li><li><del><strong>无副作用</strong>：这里的 Action 只修改数据，不直接操作 DOM 或 Canvas。</del></li></ul></li></ul><h4 id="第二层：适配层-The-Bridge-StageManager-ts"><a href="#第二层：适配层-The-Bridge-StageManager-ts" class="headerlink" title="第二层：适配层 (The Bridge) - StageManager.ts"></a><del>第二层：适配层 (The Bridge) - StageManager.ts</del></h4><p><del>这是连接 React/Zustand 和 PixiJS 的胶水层，也是架构中最复杂的部分。</del></p><ul><li><del><strong>职责</strong>：将“声明式”的数据（Zustand）转换为“命令式”的 Pixi 调用。</del></li><li><del><strong>核心机制 - 增量更新 (Diffing)</strong>：</del><ul><li><del>它维护了一个  spriteMap (Map<id, PIXI.Graphics="">)。</id,></del></li><li><del><strong>订阅 (Subscribe)</strong>：它监听 Store 的变化。</del></li><li><del><strong>同步 (Sync/Render Loop)</strong>：</del><ul><li><del><strong>Create</strong>: Store 有 ID，Map 里没有 -&gt; new PIXI.Graphics()。</del></li><li><del><strong>Update</strong>: Store 有，Map 里也有 -&gt; 更新  x, y, width, color。</del></li><li><del><strong>Delete</strong>: Store 没有，Map 里有 -&gt; destroy()。</del></li></ul></li></ul></li><li><del><strong>事件转换</strong>：</del><ul><li><del>它监听 Pixi 的  pointerdown/move/up  事件，将屏幕坐标转换为逻辑坐标，然后调用 Store 的 Action。</del></li></ul></li></ul><h4 id="第三层：视图层-The-Container-Canvas-tsx"><a href="#第三层：视图层-The-Container-Canvas-tsx" class="headerlink" title="第三层：视图层 (The Container) - Canvas.tsx"></a><del>第三层：视图层 (The Container) - Canvas.tsx</del></h4><p><del>这是 React 组件层。</del></p><ul><li><del><strong>职责</strong>：</del><ul><li><del>提供  div  容器供 Pixi 挂载。</del></li><li><del>渲染 HTML UI（工具栏、属性面板）。</del></li><li><del>生命周期管理：组件 Mount 时初始化  StageManager，Unmount 时销毁。</del></li></ul></li></ul><p><del>—-</del></p><h3 id="3-关键数据流转-Data-Flow"><a href="#3-关键数据流转-Data-Flow" class="headerlink" title="3. 关键数据流转 (Data Flow)"></a><del>3. 关键数据流转 (Data Flow)</del></h3><p><del>让我们以  <strong>“拖拽矩形移动”</strong>  为例，看数据如何在架构中流转：</del></p><p><del><strong>Input (输入)</strong>:</del></p><ul><li><del>用户在画布上按住矩形并移动鼠标。</del></li><li><del>StageManager  的  onPointerMove  被触发。</del></li></ul><p><del><strong>Logic (逻辑处理)</strong>:</del></p><ul><li><del>StageManager  计算鼠标的偏移量  (dx, dy)。</del></li><li><del>它<strong>不直接修改</strong> Pixi 图形的  graphics.x (这是关键！)。</del></li><li><del>它调用  store.updateElement(id, { x: newX, y: newY })。</del></li></ul><p><del><strong>State Update (状态更新)</strong>:</del></p><ul><li><del>Zustand Store 更新内部的 JSON 数据。</del></li><li><del>Zustand 触发订阅回调 (subscribe)。</del></li></ul><p><del><strong>Render Sync (渲染同步)</strong>:</del></p><ul><li><del>StageManager  的  render  方法被调用。</del></li><li><del>它从  spriteMap  找到对应的 Pixi 实例。</del></li><li><del>执行  graphic.position.set(newX, newY)。</del></li><li><del>PixiJS 在下一个  requestAnimationFrame  自动重绘 Canvas。</del></li></ul><p><del>—-</del></p><h3 id="4-为什么选择这种架构？"><a href="#4-为什么选择这种架构？" class="headerlink" title="4. 为什么选择这种架构？"></a><del>4. 为什么选择这种架构？</del></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><del>优点：</del></h4><p><del><strong>解耦 (Decoupling)</strong>：渲染引擎可以随时替换（比如换成 Konva 或原生 Canvas），只需要重写  StageManager，数据层和 UI 层不需要动。</del></p><p><del><strong>协同编辑 (Collaboration) 友好</strong>：</del></p><ul><li><del>如果要实现多入协同，只需要监听 WebSocket 消息，然后更新 Zustand Store。StageManager  会自动把队友的操作画出来，无需写额外的同步绘图逻辑。</del><br><del><strong>撤销/重做 (Undo/Redo) 容易</strong>：</del></li><li><del>因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照（或 Patch）即可。</del><br><del><strong>序列化/反序列化</strong>：</del></li><li><del>保存项目只需  JSON.stringify(store.elements)。</del></li></ul><h4 id="潜在挑战（及优化方案）："><a href="#潜在挑战（及优化方案）：" class="headerlink" title="潜在挑战（及优化方案）："></a><del>潜在挑战（及优化方案）：</del></h4><p><del><strong>性能瓶颈</strong>：</del></p><ul><li><del>问题：高频触发  Store Update -&gt; Diff  循环可能在元素极多时（&gt;2000 个）产生开销。</del></li><li><del>优化：对于拖拽这种 60FPS 的操作，可以引入“临时层” (Transient State)。即拖拽时直接修改 Pixi 对象，鼠标松开时再同步到 Store。</del><br><del><strong>复杂性</strong>：</del></li><li><del>相比直接用 Canvas API 画图，这种架构代码量更大，需要维护 ID 映射和 Diff 逻辑。</del></li></ul><p><del>feat(canvas): 重构画布实现，应项目要求，删除了基于tldraw的实现转而选择PixiJS 库重构以进行渲染操作，基于Zustand 进行状态管理。新增的文件中canvasStore.ts主要负责维护整个画布项目的全局可序列化状态，是渲染画布系统中唯一数据来源。Pixi_stageManager.ts 负责将声明式数据（Zustand）实时、高性能地映射为命令式渲染实例（PixiJS），并处理所有用户交互的计算与反馈。canvas下的index.ts最轻量的一层，仅负责生命周期管理与组件组装。三层数据驱动架构详情可见文档</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;&lt;del&gt;分析&lt;/del&gt;&lt;/h2&gt;&lt;p&gt;&lt;del&gt;要做的就是一个&lt;strong&gt;类 Canva / Figma 的在线图形绘板&lt;/strong&gt;，完整需求优先</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-19-重拾编程语言设计与计科相关概念</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/29484.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/29484.html</id>
    <published>2025-11-19T03:06:20.000Z</published>
    <updated>2025-11-19T03:22:30.204Z</updated>
    
    <content type="html"><![CDATA[<p>计算机类专业结果这些都得自己学，整理一套编程语言设计与计算机科学核心概念集，日后开坑学习，博客狠狠写，知识学爆</p><h2 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>指针（Pointer）</li><li>引用（Reference）</li><li>堆（Heap）</li><li>栈（Stack）</li><li>内存布局（Memory Layout）</li><li>垃圾回收（Garbage Collection）</li><li>内存泄漏（Memory Leak）</li><li>悬挂指针/引用（Dangling Pointer/Reference）</li><li>内存序（Memory Ordering）</li><li>写时复制（Copy-on-Write）</li><li>内存映射文件（Memory-mapped Files）</li><li>缓存一致性协议（Cache Coherence Protocol）</li><li>虚拟内存机制（Virtual Memory）</li><li>内存屏障（Memory Barrier）</li><li>内存对齐（Memory Alignment）</li><li>内存分配器（Memory Allocator）</li><li>内存池（Memory Pool）</li><li>引用计数（Reference Counting）</li><li>弱引用（Weak Reference）</li><li>循环引用（Circular Reference）</li><li>内存碎片（Memory Fragmentation）：包括内部碎片和外部碎片</li><li>分页与分段（Paging and Segmentation）：虚拟内存管理技术</li><li>垃圾回收算法：如标记-清除、复制、标记-整理等具体算法</li><li>内存管理单元（Memory Management Unit）</li><li>内存保护（Memory Protection）</li><li>内存访问（Memory Access）</li></ul><h3 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h3><ul><li>自动存储期（Automatic Storage Duration）</li><li>静态存储期（Static Storage Duration）</li><li>动态存储期（Dynamic Storage Duration）</li><li>线程存储期（Thread Storage Duration）</li><li>寄存器变量（Register Variable）</li></ul><h2 id="二、程序执行模型"><a href="#二、程序执行模型" class="headerlink" title="二、程序执行模型"></a>二、程序执行模型</h2><h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><ul><li>调用栈（Call Stack）</li><li>栈帧（Stack Frame）</li><li>调用约定（Calling Convention）</li><li>参数传递（Parameter Passing）</li><li>尾调用优化（Tail Call Optimization）</li><li>尾递归（Tail Recursion）</li><li>Trampoline 机制</li><li>Thunk：延迟计算的代码块</li><li>Thunk 函数：用于实现惰性求值的技术</li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li>作用域（Scope）</li><li>词法作用域（Lexical Scope）</li><li>动态作用域（Dynamic Scope）</li><li>作用域链（Scope Chain）</li><li>闭包（Closure）</li><li>执行上下文（Execution Context）</li><li>变量环境（Variable Environment）</li><li>词法环境（Lexical Environment）</li><li>延续（Continuation）</li><li>协程（Coroutine）</li><li>生成器（Generator）</li></ul><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><ul><li>事件循环（Event Loop）</li><li>计算器模型（Evaluator Model）</li><li>消息传递接口（Message Passing）</li><li>Actor 模型</li><li>CSP（Communicating Sequential Processes）</li><li>控制流图（Control Flow Graph）</li><li>数据流分析（Data Flow Analysis）</li></ul><h2 id="三、并发与并行"><a href="#三、并发与并行" class="headerlink" title="三、并发与并行"></a>三、并发与并行</h2><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><ul><li>并发（Concurrency）</li><li>并行（Parallelism）</li><li>绿色线程（Green Threads）</li><li>内核线程（Kernel Threads）</li><li>用户态线程（User-level Threads）</li><li>线程池（Thread Pool）</li><li>工作窃取（Work Stealing）</li><li>屏障（Barrier）：同步原语</li><li>fork-join 模型：并行任务执行模型</li><li>数据竞争（Data Race）：并发访问共享数据的问题</li></ul><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><ul><li>原子操作（Atomic Operations）</li><li>比较并交换（Compare-and-Swap）</li><li>锁（Lock）</li><li>自旋锁（Spinlock）</li><li>互斥锁（Mutex）</li><li>读写锁（Read-Write Lock）</li><li>信号量（Semaphore）</li><li>条件变量（Condition Variable）</li><li>无锁编程（Lock-free Programming）</li><li>内存模型（Memory Model）</li><li>顺序一致性（Sequential Consistency）</li><li>释放获取语义（Release-Acquire Semantics）</li></ul><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><ul><li>Promise/Future</li><li>async/await</li><li>响应式编程（Reactive Programming）</li><li>数据并行（Data Parallelism）</li><li>任务并行（Task Parallelism）</li><li>事务内存（Transactional Memory）</li></ul><h2 id="四、类型系统"><a href="#四、类型系统" class="headerlink" title="四、类型系统"></a>四、类型系统</h2><h3 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h3><ul><li>静态类型（Static Typing）</li><li>动态类型（Dynamic Typing）</li><li>强类型（Strong Typing）</li><li>弱类型（Weak Typing）</li><li>基本数据类型（Primitive Data Types）</li><li>复合数据类型（Composite Data Types）</li><li>引用类型（Reference Types）</li><li>值类型（Value Types）</li><li>类型推导（Type Inference）</li><li>类型检查（Type Checking）</li><li>类型擦除（Type Erasure）</li><li>类型转换（Type Casting）</li><li>类型别名（Type Alias）</li><li>类型注解（Type Annotation）</li><li>泛型（Generics）</li><li>类型参数（Type Parameter）</li><li>类型变量（Type Variable）</li><li>类型约束（Type Constraint）</li><li>类型构造器（Type Constructor）</li><li>类型等价（Type Equality）</li><li>类型子类型（Type Subtyping）</li><li>类型上界（Type Upper Bound）</li><li>类型下界（Type Lower Bound）</li><li>类型推断（Type Inference）</li><li>类型检查（Type Checking）</li><li>子类型（Subtyping）：类型之间的关系</li><li>型变（Covariance/Contravariance）：更详细的变型规则说明</li><li>不透明类型（Opaque Types）：隐藏实现细节的类型</li></ul><h3 id="高级类型概念"><a href="#高级类型概念" class="headerlink" title="高级类型概念"></a>高级类型概念</h3><ul><li>行多态（Row Polymorphism）</li><li>存在类型（Existential Types）</li><li>高阶类型（Higher-Kinded Types）</li><li>依赖类型（Dependent Types）</li><li>渐进类型（Gradual Typing）</li><li>类型类（Type Classes）</li><li>泛型（Generics）</li><li>变型（Variance）：协变、逆变、不变</li><li>类型安全（Type Safety）</li><li>类型擦除（Type Erasure）</li><li>单态化（Monomorphization）</li></ul><h2 id="五、函数与抽象"><a href="#五、函数与抽象" class="headerlink" title="五、函数与抽象"></a>五、函数与抽象</h2><h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><ul><li>高阶函数（Higher-Order Function）</li><li>回调函数（Callback）</li><li>递归（Recursion）</li><li>匿名函数（Anonymous Function）</li><li>Lambda 表达式</li><li>柯里化（Currying）</li><li>部分应用（Partial Application）</li><li>函数组合（Function Composition）</li></ul><h3 id="抽象机制"><a href="#抽象机制" class="headerlink" title="抽象机制"></a>抽象机制</h3><ul><li>控制抽象（Control Abstraction）</li><li>数据抽象（Data Abstraction）</li><li>迭代器（Iterator）</li><li>流处理（Stream Processing）</li><li>声明式编程（Declarative Programming）</li><li>函子（Functor）：映射结构的抽象概念</li><li>单子（Monad）：具有绑定操作的计算容器</li></ul><h2 id="六、面向对象编程"><a href="#六、面向对象编程" class="headerlink" title="六、面向对象编程"></a>六、面向对象编程</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>类（Class）</li><li>对象（Object）</li><li>封装（Encapsulation）</li><li>继承（Inheritance）</li><li>多态（Polymorphism）</li><li>接口（Interface）</li><li>抽象类（Abstract Class）</li><li>混入（Mixin）</li><li>特质（Trait）</li></ul><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><ul><li>虚函数表（Virtual Method Table）</li><li>方法解析顺序（Method Resolution Order）</li><li>对象布局（Object Layout）</li><li>多重继承（Multiple Inheritance）</li><li>虚继承（Virtual Inheritance）</li><li>原型继承（Prototypal Inheritance）</li><li>消息传递（Message Passing）：对象间的通信机制</li><li>委托（Delegation）：替代继承的复用机制</li></ul><h2 id="七、元编程与反射"><a href="#七、元编程与反射" class="headerlink" title="七、元编程与反射"></a>七、元编程与反射</h2><h3 id="元编程技术"><a href="#元编程技术" class="headerlink" title="元编程技术"></a>元编程技术</h3><ul><li>反射（Reflection）</li><li>内省（Introspection）</li><li>宏系统（Macro System）</li><li>卫生宏（Hygienic Macro）</li><li>语法宏（Syntax Macro）</li><li>过程宏（Procedural Macro）</li><li>模板元编程（Template Metaprogramming）</li><li>注解处理（Annotation Processing）</li><li>属性导向编程（Attribute-Oriented Programming）</li></ul><h3 id="运行时元编程"><a href="#运行时元编程" class="headerlink" title="运行时元编程"></a>运行时元编程</h3><ul><li>动态代理（Dynamic Proxy）</li><li>方法缺失处理（Method Missing）</li><li>代码生成（Code Generation）</li><li>AST 操作（Abstract Syntax Tree Manipulation）</li></ul><h2 id="八、编译与解释"><a href="#八、编译与解释" class="headerlink" title="八、编译与解释"></a>八、编译与解释</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li>词法分析（Lexical Analysis）</li><li>语法分析（Syntax Analysis）</li><li>语义分析（Semantic Analysis）</li><li>中间代码生成（Intermediate Code Generation）</li><li>代码优化（Code Optimization）</li><li>目标代码生成（Target Code Generation）</li><li>编译器架构（Compiler Architecture）</li><li>编译器设计（Compiler Design）</li><li>编译器实现（Compiler Implementation）</li><li>链接时优化（Link Time Optimization, LTO）：跨模块优化技术</li><li>Profile-Guided Optimization (PGO)：基于运行时信息的优化</li></ul><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><ul><li>解释器（Interpreter）</li><li>字节码（Bytecode）</li><li>即时编译（Just-In-Time Compilation）</li><li>抽象语法树（Abstract Syntax Tree, AST）</li><li>单态化（Monomorphization）</li><li>类型擦除（Type Erasure）</li><li>中间表示（Intermediate Representation）</li><li>SSA 形式（Static Single Assignment）</li></ul><h2 id="九、系统接口"><a href="#九、系统接口" class="headerlink" title="九、系统接口"></a>九、系统接口</h2><h3 id="操作系统交互"><a href="#操作系统交互" class="headerlink" title="操作系统交互"></a>操作系统交互</h3><ul><li>系统调用（System Call）</li><li>文件描述符（File Descriptor）</li><li>ABI（Application Binary Interface）</li><li>系统 V ABI</li><li>TLS（Thread Local Storage）</li><li>信号处理（Signal Handling）</li></ul><h2 id="十、异常与错误处理"><a href="#十、异常与错误处理" class="headerlink" title="十、异常与错误处理"></a>十、异常与错误处理</h2><h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><ul><li>异常处理（Exception Handling）</li><li>返回值错误（Error Return Values）</li><li>Result 类型</li><li>可选值（Option/Maybe）</li><li>断言（Assertion）</li><li>契约编程（Design by Contract）</li></ul><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><ul><li>RAII（Resource Acquisition Is Initialization）</li><li>所有权系统（Ownership System）</li><li>借用检查（Borrow Checking）</li><li>生命周期（Lifetime）</li><li>析构函数（Destructor）</li><li>finally 块</li></ul><h2 id="十一、模块化与代码组织"><a href="#十一、模块化与代码组织" class="headerlink" title="十一、模块化与代码组织"></a>十一、模块化与代码组织</h2><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><ul><li>模块化（Modularity）</li><li>命名空间（Namespace）</li><li>包管理（Package Management）</li><li>依赖注入（Dependency Injection）</li><li>接口隔离（Interface Segregation）</li></ul><h3 id="链接与加载"><a href="#链接与加载" class="headerlink" title="链接与加载"></a>链接与加载</h3><ul><li>静态链接（Static Linking）</li><li>动态链接（Dynamic Linking）</li><li>符号解析（Symbol Resolution）</li><li>重定位（Relocation）</li><li>名称修饰（Name Mangling）</li></ul><h2 id="十二、性能优化"><a href="#十二、性能优化" class="headerlink" title="十二、性能优化"></a>十二、性能优化</h2><h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><ul><li>内联优化（Inlining）</li><li>常量传播（Constant Propagation）</li><li>死代码消除（Dead Code Elimination）</li><li>循环优化（Loop Optimization）</li><li>向量化（Vectorization）</li><li>分支目标缓冲（Branch Target Buffer）：提高分支预测准确性的硬件机制</li><li>指令级并行（Instruction Level Parallelism）：CPU 级别的并行执行</li></ul><h3 id="运行时优化"><a href="#运行时优化" class="headerlink" title="运行时优化"></a>运行时优化</h3><ul><li>内联缓存（Inline Cache）</li><li>方法缓存（Method Cache）</li><li>逃逸分析（Escape Analysis）</li><li>栈上替换（On-Stack Replacement）</li><li>热点代码检测（Hotspot Detection）</li></ul><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><ul><li>缓存局部性（Cache Locality）</li><li>分支预测（Branch Prediction）</li><li>流水线冒险（Pipeline Hazard）</li><li>预取（Prefetching）</li><li>SIMD（Single Instruction Multiple Data）</li></ul><h2 id="十三、形式化方法与理论"><a href="#十三、形式化方法与理论" class="headerlink" title="十三、形式化方法与理论"></a>十三、形式化方法与理论</h2><h3 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h3><ul><li>霍尔逻辑（Hoare Logic）</li><li>指称语义（Denotational Semantics）</li><li>操作语义（Operational Semantics）</li><li>公理语义（Axiomatic Semantics）</li><li>进展定理（Progress Theorem）</li><li>保持定理（Preservation Theorem）</li></ul><h3 id="计算理论"><a href="#计算理论" class="headerlink" title="计算理论"></a>计算理论</h3><ul><li>λ 演算（Lambda Calculus）</li><li>组合子逻辑（Combinatory Logic）</li><li>图灵完备性（Turing Completeness）</li><li>邱奇-图灵论题（Church-Turing Thesis）</li><li>停机问题（Halting Problem）</li></ul><h2 id="十四、现代语言特性"><a href="#十四、现代语言特性" class="headerlink" title="十四、现代语言特性"></a>十四、现代语言特性</h2><h3 id="语言设计趋势"><a href="#语言设计趋势" class="headerlink" title="语言设计趋势"></a>语言设计趋势</h3><ul><li>空安全（Null Safety）</li><li>模式匹配（Pattern Matching）</li><li>异步/等待（Async/Await）</li><li>记录类型（Record Types）</li><li>代数数据类型（Algebraic Data Types）</li><li>效应系统（Effect System）</li><li>资源安全（Resource Safety）</li><li>所有权与借用（Ownership and Borrowing）：Rust 中的内存安全机制</li><li>异构编程（Heterogeneous Programming）：利用多种计算设备的编程模型</li></ul><h3 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h3><ul><li>表达式问题（Expression Problem）</li><li>访问者模式（Visitor Pattern）</li><li>模式匹配解构</li></ul><h2 id="十五、编程范式"><a href="#十五、编程范式" class="headerlink" title="十五、编程范式"></a>十五、编程范式</h2><h3 id="主要范式"><a href="#主要范式" class="headerlink" title="主要范式"></a>主要范式</h3><ul><li>命令式编程（Imperative Programming）</li><li>声明式编程（Declarative Programming）</li><li>函数式编程（Functional Programming）</li><li>逻辑编程（Logic Programming）</li><li>面向对象编程（Object-Oriented Programming）</li><li>面向方面编程（Aspect-Oriented Programming）</li></ul><h3 id="混合范式"><a href="#混合范式" class="headerlink" title="混合范式"></a>混合范式</h3><ul><li>多范式编程（Multi-paradigm Programming）</li><li>函数响应式编程（Functional Reactive Programming）</li><li>元对象协议（Metaobject Protocol）</li></ul><h2 id="十六、软件开发基础"><a href="#十六、软件开发基础" class="headerlink" title="十六、软件开发基础"></a>十六、软件开发基础</h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>表达式与语句（Expressions vs Statements）</li><li>控制流（Control Flow）</li><li>数据结构（Data Structures）</li><li>算法（Algorithms）</li><li>复杂度分析（Complexity Analysis）</li><li>设计模式（Design Patterns）：常见问题的标准解决方案</li><li>SOLID 原则：面向对象设计的五个基本原则</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机类专业结果这些都得自己学，整理一套编程语言设计与计算机科学核心概念集，日后开坑学习，博客狠狠写，知识学爆&lt;/p&gt;
&lt;h2 id=&quot;一、内存管理&quot;&gt;&lt;a href=&quot;#一、内存管理&quot; class=&quot;headerlink&quot; title=&quot;一、内存管理&quot;&gt;&lt;/a&gt;一、内存管</summary>
      
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="日志" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
