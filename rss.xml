<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhongye&#39;s Blogs</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2026-01-20T07:40:36.086Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>Zhongye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2026-01-20-开发杂记其二</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/61071.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/61071.html</id>
    <published>2026-01-20T07:03:01.000Z</published>
    <updated>2026-01-20T07:40:36.086Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>序号</th><th>问题</th><th>回答</th></tr></thead><tbody><tr><td>1</td><td>项目里用了泛型，怎么根据传入类型适配不同处理函数</td><td>通常用<strong>泛型约束 + 映射类型 + 条件类型 + infer</strong> 实现函数重载效果 最常见两种做法： 1. 传入对象类型 → 用 keyof T 约束字段名 2. 传入联合类型 → 用条件类型分发实现不同分支</td></tr><tr><td>2</td><td>泛型是什么</td><td><strong>泛型（Generics）</strong> 是 TypeScript（以及许多现代编程语言）中一种强大的类型系统特性，其核心目的是<strong>允许开发者编写可复用、类型安全的代码</strong>，同时让代码在不同具体类型下都能保持正确的类型推断和约束。<br><br>简单来说，泛型就是<strong>“类型参数化”</strong>：把类型当作参数一样传入，让同一个函数、类、接口能够处理多种类型的数据，而无需为每种类型都重复编写代码。</td></tr><tr><td>3</td><td>interface 和 type 的区别</td><td>现在差别已经很小，主要记住这几点： • interface 可<strong>多次声明自动合并</strong>（对库/模块声明补丁最有用） • type 可做<strong>联合、交叉、映射、条件、模板字符串</strong>等复杂类型操作 • interface 性能略好（声明合并时） • 目前绝大多数团队：<strong>能用 type 就用 type</strong>，除非明确需要声明合并</td></tr><tr><td>4</td><td>keyof、in、typeof、infer 实际工作中怎么用</td><td>- keyof：取对象所有键名（表单字段校验、权限映射最常用） - in：映射类型必备（生成只读、部分、可选等类型） - typeof：获取<strong>值</strong>的类型（尤其是从 const 断言对象取类型） - infer：在条件类型中<strong>推断</strong>出某一部分类型（最强大，常用于提取 Promise 返回值、数组元素类型、函数返回值等）</td></tr><tr><td>5</td><td>封装表单组件，要求字段名必须是后端返回字段的一部分，怎么处理</td><td>最推荐做法（2024~2026 主流）： ts<br>type ApiResponse = { id: number; name: string; age: number; email?: string }<br><br>type FormField<t> = keyof T \</t></td><td><code>${keyof T}.${string}</code><br><br>function Form<t extends="" Record<string,="" any="">&gt;(props: { fields: FormField<t>[] }) { … }<br> 进阶：用 const assertion + typeof 做更严格的路径类型</t></t></td></tr><tr><td>6</td><td>回流（reflow）和重绘（repaint）的区别</td><td>回流（Layout/Reflow）：几何属性/布局变化 → 影响元素位置/大小 → 必须重新计算布局 重绘（Repaint）：外观变化（颜色、visibility、阴影等）→ 不影响布局 <strong>回流代价远大于重绘</strong>（通常是重绘的几倍到几十倍）</td></tr><tr><td>7</td><td>浏览器加载一个页面时，整个渲染流程（关键节点）</td><td>1. DNS → TCP → TLS 2. 请求 HTML 3. 构建 DOM + CSSOM 4. 合成 Render Tree 5. Layout（回流） 6. Paint（重绘） 7. Composite（图层合成） 重要：<strong>Parse → Style → Layout → Paint → Composite</strong></td></tr><tr><td>8</td><td>做骨架屏时，怎么判断骨架内容和真实内容之间的切换时机</td><td>推荐组合方式（从激进到保守）： 1. 最激进：<strong>第一个/几个关键接口请求完成</strong>就切 2. 常用：<strong>所有必须数据接口都 resolve</strong> 后切（Promise.all） 3. 保守：<strong>主图/首屏关键资源加载完成</strong>（img onload + 定时兜底） 4. 极致体验：分层渐进式替换（文字先换、图片后换）</td></tr><tr><td>9</td><td>移动端怎么做适配（2025~2026 主流方案）</td><td>当前最主流组合： 1. <strong>postcss-px-to-viewport-8-plugin</strong> / <strong>postcss-px-to-rem</strong> + <strong>tailwindcss</strong> 2. <strong>设计稿 375px</strong> → vw 方案（750 设计稿用 100vw = 750px） 3. 大屏/横屏特殊处理：<strong>100vh polyfill</strong> + <strong>env(safe-area-inset-*)</strong> 4. 字体：<strong>clamp()</strong> + <strong>rem</strong>（根字体 100px 常见）</td></tr><tr><td>10</td><td>async 函数在执行栈中的位置是怎么样的</td><td>async 函数<strong>本身是同步执行</strong>到第一个 await 第一个 await 之后 → <strong>后续代码作为微任务</strong>放入微任务队列 所以：<strong>async 函数 = 同步前半段 + 多个微任务</strong></td></tr><tr><td>11</td><td>Promise.all 和 Promise.allSettled 的区别</td><td>Promise.all：<strong>有一个 reject 就整体 reject</strong>，结果顺序严格对应 Promise.allSettled：<strong>永远 resolve</strong>，返回每个 promise 的 {status, value/reason}，永远不会 reject</td></tr><tr><td>12</td><td>JS 是单线程，为什么可以实现并发加载多个接口？</td><td>JS 单线程指的是<strong>执行 JavaScript 代码的线程只有一个</strong> 真正的网络请求、定时器、DOM事件等都由<strong>浏览器底层多线程</strong>完成 JS 只负责<strong>注册回调</strong>，回调通过<strong>事件循环</strong>被调度执行 → 所以<strong>宏观上是并发</strong></td></tr><tr><td>13</td><td>setTimeout 和 requestAnimationFrame 哪个更精确</td><td>requestAnimationFrame <strong>更精确</strong>（与浏览器刷新率同步，通常 16.7ms/60fps） setTimeout 实际延迟往往<strong>偏长</strong>（最低 4ms + 事件循环排队延迟） <strong>动画/滚动相关优先使用 rAF</strong></td></tr><tr><td>14</td><td>帧率监控你们是怎么做的</td><td>主流几种方式（按精度/成本排序）： 1. requestAnimationFrame 循环 + performance.now() 差值（最常用） 2. PerformanceObserver + ‘longtask’（监控长任务） 3. Web Vitals（CLS、FID、LCP） 4. 第三方：sentry、ddtrace、阿里云 ARMS 等</td></tr><tr><td>15</td><td>小程序渲染卡顿时怎么优化（微信/支付宝小程序）</td><td>优先级排序（效果最明显→一般）： 1. setData 合并 + 减少次数（一次 setData 尽量多字段） 2. 使用 <strong>block wx:if</strong> 代替大量 wx:if 3. 列表用 <strong>virtual-list</strong> / <strong>recycle-view</strong> 4. 图片用 <strong>webp + lazy-load</strong> 5. 避免在循环里写 setData 6. 自定义组件<strong>纯数据组件</strong>化</td></tr><tr><td>16</td><td>H5 页面嵌入小游戏时，遇到过页面内存持续上涨吗？怎么解决的？</td><td>非常常见，尤其 canvas + webgl 小游戏 <strong>常见原因</strong>： • 事件监听未移除 • canvas 未清理（ctx.clearRect 不够） • 纹理/缓冲区未释放 • 闭包引用大对象 • requestAnimationFrame 未取消 <strong>解决办法</strong>： 1. 组件卸载时<strong>务必 cancelAnimationFrame</strong> 2. 清理纹理：gl.deleteTexture/gl.deleteBuffer 3. 用 WeakMap/WeakSet 存引用 4. 定时检查 performance.memory（chrome devtools） 5. 必要时主动销毁整个 canvas 元素再重建</td></tr></tbody></table></div><h3 id="JS中异步的概念是什么？"><a href="#JS中异步的概念是什么？" class="headerlink" title="JS中异步的概念是什么？"></a>JS中异步的概念是什么？</h3><p>JavaScript异步是指代码的执行不必等待某个操作完成，可以继续执行后续代码。当异步操作完成后，通过回调函数、Promise或async/await来处理结果。这是为了解决JS单线程可能导致的阻塞问题。</p><p><strong>核心机制</strong>：事件循环 + 回调队列</p><ul><li>同步任务在主线程执行</li><li>异步任务交由Web APIs处理</li><li>完成后的回调进入任务队列</li><li>事件循环从队列中取出回调执行</li></ul><h3 id="为什么JS是单线程还需要事件循环？"><a href="#为什么JS是单线程还需要事件循环？" class="headerlink" title="为什么JS是单线程还需要事件循环？"></a>为什么JS是单线程还需要事件循环？</h3><p><strong>看似矛盾实则巧妙的设计</strong>：</p><ol><li><strong>单线程的必然性</strong>：避免多线程的复杂性（锁、竞态条件）</li><li><strong>事件循环的价值</strong>：<ul><li>处理I/O密集型操作（网络、文件）</li><li>维持UI响应性</li><li>管理定时器、用户交互</li><li>实现”非阻塞”的并发</li></ul></li></ol><p><strong>简单比喻</strong>：就像餐厅里只有一个服务员（单线程），但通过叫号系统（事件循环）可以高效服务多桌客人。</p><h3 id="栈内存和堆内存的差异？"><a href="#栈内存和堆内存的差异？" class="headerlink" title="栈内存和堆内存的差异？"></a>栈内存和堆内存的差异？</h3><div class="table-container"><table><thead><tr><th>特性</th><th>栈内存</th><th>堆内存</th></tr></thead><tbody><tr><td>存储内容</td><td>基本类型、引用地址</td><td>引用类型（对象、数组）</td></tr><tr><td>分配方式</td><td>自动分配/释放</td><td>动态分配，GC回收</td></tr><tr><td>大小</td><td>固定，较小</td><td>动态，较大</td></tr><tr><td>访问速度</td><td>快</td><td>慢</td></tr><tr><td>管理</td><td>系统自动管理</td><td>开发者/GC管理</td></tr><tr><td>示例</td><td>let a = 1</td><td>let obj = {x: 1}</td></tr></tbody></table></div><h3 id="为什么数组要存在堆内存而不是栈内存？"><a href="#为什么数组要存在堆内存而不是栈内存？" class="headerlink" title="为什么数组要存在堆内存而不是栈内存？"></a>为什么数组要存在堆内存而不是栈内存？</h3><p><strong>根本原因</strong>：</p><ol><li><strong>大小不确定</strong>：数组长度动态变化，栈内存固定大小无法满足</li><li><strong>性能考虑</strong>：复制大数组到栈中成本高</li><li><strong>内存管理</strong>：堆内存可动态扩展，GC负责回收</li><li><strong>引用语义</strong>：多个变量可共享同一数组</li></ol><h3 id="JS中有哪些基本数据类型？"><a href="#JS中有哪些基本数据类型？" class="headerlink" title="JS中有哪些基本数据类型？"></a>JS中有哪些基本数据类型？</h3><p><strong>7种基本类型</strong>：</p><ol><li>String</li><li>Number</li><li>Boolean</li><li>Undefined</li><li>Null</li><li>Symbol（ES6）</li><li>BigInt（ES2020）</li></ol><p><strong>1种引用类型</strong>：Object（包括Array、Function、Date等）</p><h3 id="函数内部的this含义是什么？"><a href="#函数内部的this含义是什么？" class="headerlink" title="函数内部的this含义是什么？"></a>函数内部的this含义是什么？</h3><p><strong>this的指向规则</strong>：</p><ol><li><strong>默认绑定</strong>：独立函数调用 → window/undefined（严格模式）</li><li><strong>隐式绑定</strong>：作为对象方法调用 → 该对象</li><li><strong>显式绑定</strong>：call/apply/bind → 指定的对象</li><li><strong>new绑定</strong>：构造函数调用 → 新创建的对象</li><li><strong>箭头函数</strong>：无自己的this，继承外层</li></ol><h3 id="call、apply、bind的区别？"><a href="#call、apply、bind的区别？" class="headerlink" title="call、apply、bind的区别？"></a>call、apply、bind的区别？</h3><div class="table-container"><table><thead><tr><th>方法</th><th>参数传递</th><th>立即执行</th><th>返回</th></tr></thead><tbody><tr><td>call</td><td>参数列表</td><td>是</td><td>函数结果</td></tr><tr><td>apply</td><td>数组</td><td>是</td><td>函数结果</td></tr><tr><td>bind</td><td>参数列表</td><td>否</td><td>新函数</td></tr></tbody></table></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">func.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2);<br>func.<span class="hljs-title function_">apply</span>(thisArg, [arg1, arg2]);<br><span class="hljs-keyword">const</span> newFunc = func.<span class="hljs-title function_">bind</span>(thisArg, arg1, arg2);<br></code></pre></td></tr></table></figure><h3 id="TypeScript联合类型和交叉类型的概念？"><a href="#TypeScript联合类型和交叉类型的概念？" class="headerlink" title="TypeScript联合类型和交叉类型的概念？"></a>TypeScript联合类型和交叉类型的概念？</h3><p><strong>联合类型 (Union Types)</strong>：<code>|</code>表示”或”</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Status</span> = <span class="hljs-string">"success"</span> | <span class="hljs-string">"error"</span> | <span class="hljs-string">"loading"</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br></code></pre></td></tr></table></figure><p><strong>交叉类型 (Intersection Types)</strong>：<code>&amp;</code>表示”且”</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A {<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>}<br><span class="hljs-keyword">interface</span> B {<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span>;<br>}<br><span class="hljs-keyword">type</span> C = A &amp; B; <span class="hljs-comment">// { x: number, y: string }</span><br></code></pre></td></tr></table></figure><p><strong>区别</strong>：</p><ul><li>联合：可接受任一类型</li><li>交叉：必须同时满足所有类型</li></ul><hr><h2 id="二、浏览器-网络类"><a href="#二、浏览器-网络类" class="headerlink" title="二、浏览器/网络类"></a>二、浏览器/网络类</h2><h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><p><strong>同源</strong>：协议、域名、端口完全相同</p><p><strong>限制内容</strong>：</p><ul><li>DOM访问</li><li>Cookie/LocalStorage访问</li><li>AJAX请求</li><li>脚本执行</li></ul><p><strong>目的</strong>：防止恶意网站窃取用户数据</p><h3 id="如何实现跨域请求？"><a href="#如何实现跨域请求？" class="headerlink" title="如何实现跨域请求？"></a>如何实现跨域请求？</h3><p><strong>常用方案</strong>：</p><ol><li><strong>CORS</strong>：服务器设置响应头</li><li><strong>JSONP</strong>：利用<code>&lt;script&gt;</code>标签</li><li><strong>代理服务器</strong>：同源服务器转发</li><li><strong>WebSocket</strong>：不受同源限制</li><li><strong>postMessage</strong>：窗口间通信</li><li><strong>nginx反向代理</strong>：服务器端代理</li></ol><h3 id="为什么代理可以绕过同源限制？"><a href="#为什么代理可以绕过同源限制？" class="headerlink" title="为什么代理可以绕过同源限制？"></a>为什么代理可以绕过同源限制？</h3><p><strong>核心原理</strong>：</p><ol><li><strong>同源限制是浏览器的安全策略</strong>，不是服务器的</li><li><strong>代理服务器与页面同源</strong>，不受限制</li><li><strong>服务器间无同源限制</strong>，可自由通信</li></ol><p><strong>流程</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">浏览器(同源) → 代理服务器(同源) → 目标服务器(不同源)<br></code></pre></td></tr></table></figure><h3 id="Cookie和Session的定义和差异？"><a href="#Cookie和Session的定义和差异？" class="headerlink" title="Cookie和Session的定义和差异？"></a>Cookie和Session的定义和差异？</h3><div class="table-container"><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>客户端</td><td>服务器端</td></tr><tr><td>安全性</td><td>较低（可篡改）</td><td>较高</td></tr><tr><td>存储大小</td><td>4KB左右</td><td>更大</td></tr><tr><td>生命周期</td><td>可设置过期时间</td><td>依赖服务器配置</td></tr><tr><td>跨域</td><td>可设置domain</td><td>依赖Cookie或token</td></tr></tbody></table></div><h3 id="Cookie是怎么种下的？"><a href="#Cookie是怎么种下的？" class="headerlink" title="Cookie是怎么种下的？"></a>Cookie是怎么种下的？</h3><p><strong>两种方式</strong>：</p><ol><li><strong>HTTP响应头</strong>：<code>Set-Cookie: name=value; options</code></li><li><strong>JavaScript设置</strong>：<code>document.cookie = "name=value; options"</code></li></ol><p><strong>关键属性</strong>：</p><ul><li><code>HttpOnly</code>：禁止JS访问</li><li><code>Secure</code>：仅HTTPS传输</li><li><code>SameSite</code>：限制跨站发送</li><li><code>Domain/Path</code>：作用域</li></ul><h3 id="LocalStorage和SessionStorage的区别？"><a href="#LocalStorage和SessionStorage的区别？" class="headerlink" title="LocalStorage和SessionStorage的区别？"></a>LocalStorage和SessionStorage的区别？</h3><div class="table-container"><table><thead><tr><th>特性</th><th>LocalStorage</th><th>SessionStorage</th></tr></thead><tbody><tr><td>生命周期</td><td>永久，需手动清除</td><td>标签页关闭即清除</td></tr><tr><td>作用域</td><td>同源窗口共享</td><td>仅当前标签页</td></tr><tr><td>存储大小</td><td>5-10MB</td><td>5-10MB</td></tr><tr><td>数据同步</td><td>同源窗口实时同步</td><td>仅当前标签页</td></tr></tbody></table></div><h3 id="HTTP强缓存和协商缓存的区别？"><a href="#HTTP强缓存和协商缓存的区别？" class="headerlink" title="HTTP强缓存和协商缓存的区别？"></a>HTTP强缓存和协商缓存的区别？</h3><p><strong>强缓存</strong>：</p><ul><li>响应头：<code>Cache-Control</code>、<code>Expires</code></li><li>状态码：200 (from cache)</li><li>过程：不请求服务器，直接使用缓存</li></ul><p><strong>协商缓存</strong>：</p><ul><li>响应头：<code>ETag/If-None-Match</code>、<code>Last-Modified/If-Modified-Since</code></li><li>状态码：304 (Not Modified)</li><li>过程：请求服务器，验证缓存有效性</li></ul><h3 id="301和302状态码的区别？"><a href="#301和302状态码的区别？" class="headerlink" title="301和302状态码的区别？"></a>301和302状态码的区别？</h3><p><strong>301 Moved Permanently</strong>：</p><ul><li>永久重定向</li><li>搜索引擎更新索引</li><li>浏览器缓存新地址</li><li>权重传递</li></ul><p><strong>302 Found (临时重定向)</strong>：</p><ul><li>临时重定向</li><li>搜索引擎不更新</li><li>浏览器不缓存</li><li>权重不传递</li></ul><p><strong>实际使用</strong>：</p><ul><li>网站改版用301</li><li>登录跳转用302</li><li>移动端适配用302</li></ul><hr><h2 id="三、CSS类"><a href="#三、CSS类" class="headerlink" title="三、CSS类"></a>三、CSS类</h2><h3 id="1-设备像素和逻辑像素的区别？"><a href="#1-设备像素和逻辑像素的区别？" class="headerlink" title="1. 设备像素和逻辑像素的区别？"></a>1. 设备像素和逻辑像素的区别？</h3><p><strong>设备像素 (Physical Pixel)</strong>：</p><ul><li>物理像素，屏幕实际发光点</li><li>固定不变</li><li>高DPI设备像素更密集</li></ul><p><strong>逻辑像素 (CSS Pixel)</strong>：</p><ul><li>编程使用的像素单位</li><li>与实际像素有比例关系</li><li>由<code>devicePixelRatio</code>决定</li></ul><p><strong>关系</strong>：<code>物理像素 = 逻辑像素 × devicePixelRatio</code></p><h3 id="2-CSS两种盒模型的差异"><a href="#2-CSS两种盒模型的差异" class="headerlink" title="2. CSS两种盒模型的差异"></a>2. CSS两种盒模型的差异</h3><p><strong>标准盒模型 (content-box)</strong>：</p><ul><li><code>width/height</code>= 内容宽度</li><li>总宽度 = width + padding + border + margin</li></ul><p><strong>IE盒模型 (border-box)</strong>：</p><ul><li><code>width/height</code>= 内容 + padding + border</li><li>总宽度 = width + margin</li></ul><p><strong>设置方式</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 默认 */</span><br><span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 常用 */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;回答&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;项目里用了泛型，怎么</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-19-前端相关概念.Vol-1：闭包</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/22446.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/22446.html</id>
    <published>2026-01-19T17:03:26.000Z</published>
    <updated>2026-01-20T07:11:06.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>函数＋创建时的词法环境</p><blockquote><p>当一个函数能够“记住并访问”它被创建时所处的词法作用域中的变量，即使这个函数在它原本的作用域之外被执行，这个函数就形成了闭包。</p></blockquote><p><strong>“闭包就是函数和其词法环境的组合”</strong><br><strong>“闭包就是能够读取其他函数内部变量的函数”</strong></p><p>闭包是语言运行时的一种行为现象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 计数器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 处于外部函数作用域的变量</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {      <span class="hljs-comment">// 内部函数形成了闭包</span><br>    <span class="hljs-keyword">return</span> count++;<br>  };<br>}<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>作用：封装，保存状态，延迟执行<br>判断：能否访问已销毁外部作用域的变量（基于函数定义位置）</p><h4 id="闭包应用场景"><a href="#闭包应用场景" class="headerlink" title="闭包应用场景"></a>闭包应用场景</h4><ul><li><strong>在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中</strong>，只要使用了回调函数，实际上就是在使用闭包：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定时器</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>){<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1'</span>);<br>}，<span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 事件监听</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(app).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Event Listener'</span>);<br>});<br></code></pre></td></tr></table></figure><ul><li><strong>作为函数参数传递的形式：</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>){<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>){<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>  }<br>  <span class="hljs-title function_">bar</span>(baz);<br>}<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>){<br>  <span class="hljs-comment">// 这是闭包</span><br>  <span class="hljs-title function_">fn</span>();<br>}<br><span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// 输出2，而不是1</span><br></code></pre></td></tr></table></figure><ul><li><strong>IIFE（立即执行函数）</strong>，创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"></span>){<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// 输出2</span><br>})();<br></code></pre></td></tr></table></figure><p>IIFE 是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><ul><li><strong>结果缓存（备忘模式）</strong></li></ul><p>备忘模式就是应用闭包的特点的一个典型应用。比如下面函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a</span>) {<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></table></figure><p>当多次执行 add() 时，每次得到的结果都是重新计算得到的，如果是开销很大的计算操作的话就比较消耗性能了，这里可以对已经计算过的输入做一个缓存。所以这里可以利用闭包的特点来实现一个简单的缓存，在函数内部用一个对象存储输入的参数，如果下次再输入相同的参数，那就比较一下对象的属性，如果有缓存，就直接把值从这个对象里面取出来。实现代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memorize</span>(<span class="hljs-params">fn</span>) {<br>    <span class="hljs-keyword">var</span> cache = {}<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-keyword">var</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args)<br>        <span class="hljs-keyword">return</span> cache[key] || (cache[key] = fn.<span class="hljs-title function_">apply</span>(fn, args))<br>    }<br>}<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a</span>) {<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span><br>}<br><br><span class="hljs-keyword">var</span> adder = <span class="hljs-title function_">memorize</span>(add)<br><br><span class="hljs-title function_">adder</span>(<span class="hljs-number">1</span>)            <span class="hljs-comment">// 输出: 2    当前: cache: { '[1]': 2 }</span><br><span class="hljs-title function_">adder</span>(<span class="hljs-number">1</span>)            <span class="hljs-comment">// 输出: 2    当前: cache: { '[1]': 2 }</span><br><span class="hljs-title function_">adder</span>(<span class="hljs-number">2</span>)            <span class="hljs-comment">// 输出: 3    当前: cache: { '[1]': 2, '[2]': 3 }</span><br></code></pre></td></tr></table></figure><p>使用 ES6 的方式实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memorize</span>(<span class="hljs-params">fn</span>) {<br>    <span class="hljs-keyword">const</span> cache = {}<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {<br>        <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args)<br>        <span class="hljs-keyword">return</span> cache[key] || (cache[key] = fn.<span class="hljs-title function_">apply</span>(fn, args))<br>    }<br>}<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a</span>) {<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span><br>}<br><br><span class="hljs-keyword">const</span> adder = <span class="hljs-title function_">memorize</span>(add)<br><br><span class="hljs-title function_">adder</span>(<span class="hljs-number">1</span>)            <span class="hljs-comment">// 输出: 2    当前: cache: { '[1]': 2 }</span><br><span class="hljs-title function_">adder</span>(<span class="hljs-number">1</span>)            <span class="hljs-comment">// 输出: 2    当前: cache: { '[1]': 2 }</span><br><span class="hljs-title function_">adder</span>(<span class="hljs-number">2</span>)            <span class="hljs-comment">// 输出: 3    当前: cache: { '[1]': 2, '[2]': 3 }</span><br></code></pre></td></tr></table></figure><p>备忘函数中用 JSON.stringify 把传给 adder 函数的参数序列化成字符串，把它当做 cache 的索引，将 add 函数运行的结果当做索引的值传递给 cache，这样 adder 运行的时候如果传递的参数之前传递过，那么就返回缓存好的计算结果，不用再计算了，如果传递的参数没计算过，则计算并缓存 fn.apply(fn, args)，再返回计算的结果。</p><h4 id="循环输出问题"><a href="#循环输出问题" class="headerlink" title="循环输出问题"></a>循环输出问题</h4><p>最后来看一个常见的和闭包相关的循环输出问题，代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i ++){<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  }, <span class="hljs-number">0</span>)<br>}<br></code></pre></td></tr></table></figure><p>这段代码输出的结果是 5 个 6，那为什么都是 6 呢？如何才能输出 1、2、3、4、5 呢？</p><p>可以结合以下两点来思考第一个问题：</p><ul><li>setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。</li><li>因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。</li></ul><p>那如何按顺序依次输出 1、2、3、4、5 呢？</p><p><strong>1）利用 IIFE</strong></p><p>可以利用 IIFE（立即执行函数），当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造之后的代码如下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">5</span>;i++){<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>){<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>){<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    }, <span class="hljs-number">0</span>)<br>  })(i)<br>}<br></code></pre></td></tr></table></figure><p>可以看到，通过这样改造使用 IIFE（立即执行函数），可以实现序号的依次输出。利用立即执行函数的入参来缓存每一个循环中的 i 值。</p><p><strong>2）使用 ES6 中的 let</strong></p><p>ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++){<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  },<span class="hljs-number">0</span>)<br>}<br></code></pre></td></tr></table></figure><p>可以看到，通过 let 定义变量的方式，重新定义 i 变量，则可以用最少的改动成本，解决该问题。</p><p><strong>3）定时器第三个参数</strong></p><p>setTimeout 作为经常使用的定时器，它是存在第三个参数的。我们经常使用前两个，一个是回调函数，另外一个是定时时间，setTimeout 从第三个入参位置开始往后，是可以传入无数个参数的。这些参数会作为回调函数的附加参数存在。那么结合第三个参数，调整完之后的代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++){<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>  }, <span class="hljs-number">0</span>, i)<br>}<br></code></pre></td></tr></table></figure><p>可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现想要的结果</p><hr><h2 id="高阶函数（Higher-Order-Function）"><a href="#高阶函数（Higher-Order-Function）" class="headerlink" title="高阶函数（Higher-Order Function）"></a>高阶函数（Higher-Order Function）</h2><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><p>一个最简单的高阶函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y, f</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(x) + <span class="hljs-title function_">f</span>(y);<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="柯里化（Currying）"><a href="#柯里化（Currying）" class="headerlink" title="柯里化（Currying）"></a>柯里化（Currying）</h2><blockquote><p>柯里化是将一个接受 <strong>多个参数</strong> 的函数，转换为 <strong>一系列只接受单个参数</strong> 的函数的变换过程。</p></blockquote><p>f(a, b, c) === f(a)(b)(c)</p><p>把“一次传入多个参数” → 拆成“多次每次只传一个参数”的调用链。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 普通函数（非柯里化）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>) {<br>  <span class="hljs-keyword">return</span> a + b + c;<br>}<br><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);         <span class="hljs-comment">// 6</span><br><br><br><span class="hljs-comment">// 柯里化版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCurried</span>(<span class="hljs-params">a</span>) {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) {<br>      <span class="hljs-keyword">return</span> a + b + c;<br>    };<br>  };<br>}<br><br><span class="hljs-title function_">addCurried</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 6</span><br><br><br><span class="hljs-comment">// 更常见的简写形式（箭头函数）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addC</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> a + b + c;<br><br><span class="hljs-title function_">addC</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);        <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><hr><h2 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h2><p><strong>定义</strong>：当事件被触发后，延迟 n 秒再执行回调函数。如果在这 n 秒内事件再次被触发，则重新开始计时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方式1：简单版（非立即执行）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) {<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {<br>    <span class="hljs-comment">// 每次触发都清除之前的定时器</span><br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>    <br>    <span class="hljs-comment">// 重新设置定时器</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    }, wait);<br>  };<br>}<br><br><span class="hljs-comment">// 方式2：立即执行版 + 尾部执行（更常用）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait, immediate = <span class="hljs-literal">false</span></span>) {<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>;<br>    <br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>    <br>    <span class="hljs-keyword">if</span> (immediate) {<br>      <span class="hljs-keyword">const</span> callNow = !timer;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {<br>        timer = <span class="hljs-literal">null</span>;<br>      }, wait);<br>      <br>      <span class="hljs-keyword">if</span> (callNow) fn.<span class="hljs-title function_">apply</span>(context, args);<br>    } <span class="hljs-keyword">else</span> {<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {<br>        fn.<span class="hljs-title function_">apply</span>(context, args);<br>      }, wait);<br>    }<br>  };<br>}<br></code></pre></td></tr></table></figure><p>**应用：</p><ul><li>搜索框输入自动搜索（用户输入完再发请求）</li><li>表单验证（输入停止后才校验）</li><li>按钮短时间内多次点击（防止重复提交）</li><li>window.resize 事件</li></ul><h2 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h2><p><strong>定义</strong>：规定时间内只执行一次函数，无论这段时间内触发多少次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方式1：时间戳版（第一次触发会立即执行）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, wait</span>) {<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <br>    <span class="hljs-keyword">if</span> (now - prev &gt;= wait) {<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      prev = now;<br>    }<br>  };<br>}<br><br><span class="hljs-comment">// 方式2：定时器版（最后一次一定会执行）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, wait</span>) {<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> lastArgs = <span class="hljs-literal">null</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {<br>    lastArgs = args;<br>    <br>    <span class="hljs-keyword">if</span> (!timer) {<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>      lastArgs = <span class="hljs-literal">null</span>;<br>      <br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (lastArgs) {<br>          fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>        }<br>        timer = <span class="hljs-literal">null</span>;<br>        lastArgs = <span class="hljs-literal">null</span>;<br>      }, wait);<br>    }<br>  };<br>}<br><br><span class="hljs-comment">// 方式3：最推荐的综合版（头尾都能执行）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, wait</span>) {<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">const</span> remaining = wait - (now - previous);<br>    <br>    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">if</span> (timer) {<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      }<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      previous = now;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer) {<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        previous = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        timer = <span class="hljs-literal">null</span>;<br>      }, remaining);<br>    }<br>  };<br>}<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong>：</p><ul><li>页面滚动到底部加载更多（无限滚动）</li><li>拖拽元素时实时计算位置</li><li>鼠标移动时画板实时绘制</li><li>游戏中技能释放冷却（最典型的思想来源）</li></ul><hr><h2 id="call、apply-和-bind"><a href="#call、apply-和-bind" class="headerlink" title="call、apply 和 bind"></a>call、apply 和 bind</h2><p><strong>call、apply 和 bind</strong> 是 JavaScript 中 Function 对象提供的三个非常重要且经常被面试考察的方法，它们的主要作用都是<strong>改变函数执行时的 this 指向</strong>，但在用法、参数传递方式和执行时机上存在显著差异。</p><div class="table-container"><table><thead><tr><th>特性</th><th>call</th><th>apply</th><th>bind</th></tr></thead><tbody><tr><td>主要功能</td><td>立即执行函数，并改变 this 指向</td><td>立即执行函数，并改变 this 指向</td><td><strong>不立即执行</strong>，返回一个新函数，永久绑定 this</td></tr><tr><td>参数传递方式</td><td>逐个参数列出</td><td>参数以数组形式传递</td><td>逐个参数列出（与 call 相同）</td></tr><tr><td>返回值</td><td>函数执行后的返回值</td><td>函数执行后的返回值</td><td>新的绑定了 this 的函数</td></tr><tr><td>是否立即执行</td><td>是</td><td>是</td><td>否</td></tr><tr><td>参数是否可以后续补充</td><td>否（一次性传完）</td><td>否（一次性传完）</td><td>是（可以分两次传参）</td></tr><tr><td>典型使用场景</td><td>需要明确控制 this 并立即执行时</td><td>处理类数组对象/动态参数时</td><td>事件处理、固定 this 的回调函数</td></tr><tr><td>语法示例</td><td>fn.call(obj, 1, 2, 3)</td><td>fn.apply(obj, [1, 2, 3])</td><td>const newFn = fn.bind(obj, 1, 2)</td></tr></tbody></table></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 准备一个测试函数和对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, punctuation</span>) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, 我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span><span class="hljs-subst">${punctuation}</span>`</span>);<br>}<br><br><span class="hljs-keyword">const</span> person = {<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span><br>};<br><br><span class="hljs-keyword">const</span> anotherPerson = {<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">"李四"</span><br>};<br></code></pre></td></tr></table></figure><h4 id="1-call"><a href="#1-call" class="headerlink" title="1. call()"></a>1. call()</h4><p>立即执行，参数逐个传入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">"您好"</span>, <span class="hljs-string">"！"</span>);     <br><span class="hljs-comment">// 输出：您好，我是张三！</span><br><br>greet.<span class="hljs-title function_">call</span>(anotherPerson, <span class="hljs-string">"早上好"</span>, <span class="hljs-string">"～"</span>);<br><span class="hljs-comment">// 输出：早上好，我是李四～</span><br></code></pre></td></tr></table></figure><h4 id="2-apply"><a href="#2-apply" class="headerlink" title="2. apply()"></a>2. apply()</h4><p>立即执行，参数以<strong>数组</strong>形式传入（非常适合处理 arguments 或类数组对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">"下午好"</span>, <span class="hljs-string">"。"</span>]);   <br><span class="hljs-comment">// 输出：下午好，我是张三。</span><br><br><span class="hljs-comment">// 经典用法：求数组最大/最小值（以前常考，现在 Math.max(...arr) 更常用）</span><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, numbers)); <span class="hljs-comment">// 9</span><br><span class="hljs-comment">// 现代写法：Math.max(...numbers)</span><br></code></pre></td></tr></table></figure><h4 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind()"></a>3. bind()</h4><p><strong>最重要</strong>的特点：<strong>不立即执行</strong>，而是返回一个<strong>永久绑定了 this 的新函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 绑定 this，并预设部分参数（函数柯里化常用）</span><br><span class="hljs-keyword">const</span> greetZhangSan = greet.<span class="hljs-title function_">bind</span>(person, <span class="hljs-string">"你好"</span>);  <br><br><span class="hljs-title function_">greetZhangSan</span>(<span class="hljs-string">"!"</span>);      <br><span class="hljs-comment">// 输出：你好，我是张三!</span><br><br><span class="hljs-title function_">greetZhangSan</span>(<span class="hljs-string">"呀～"</span>);   <br><span class="hljs-comment">// 输出：你好，我是张三呀～</span><br><br><span class="hljs-comment">// 事件处理中最常见的用法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">text</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"button"</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">textContent</span> = text;<br>    <br>    <span class="hljs-comment">// 错误写法：this.handleClick 中的 this 会指向 DOM 元素</span><br>    <span class="hljs-comment">// this.element.addEventListener("click", this.handleClick);</span><br>    <br>    <span class="hljs-comment">// 正确写法：</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));<br>  }<br>  <br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮 <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.text}</span> 被点击了`</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure><p>场景：</p><ul><li>需要<strong>立刻执行</strong> → 选 <strong>call</strong> 或 <strong>apply</strong></li><li>处理<strong>数组/类数组</strong>参数 → 优先考虑 <strong>apply</strong></li><li>需要<strong>保存一个固定 this 的函数</strong>（最常见：事件回调、setTimeout、React class 组件等）→ 选 <strong>bind</strong></li><li>想<strong>同时固定 this 又预设部分参数</strong>（函数柯里化）→ 也用 <strong>bind</strong></li></ul><hr><h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p>IIFE是 Immediately Invoked Function Expression 的缩写</p><p>JavaScript 中一种非常常见且重要的设计模式，主要用于创建独立的作用域并立即执行代码，同时避免污染全局命名空间</p><p>ES6前常用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-comment">// 这里的所有变量都是局部变量</span><br>    <span class="hljs-keyword">var</span> privateVar = <span class="hljs-string">'这是一个私有变量'</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'立即执行！'</span>);<br>})();  <span class="hljs-comment">// 最后的 () 负责立即调用</span><br></code></pre></td></tr></table></figure><hr><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环是 JavaScript 单线程运行时用来处理异步任务的调度器，它通过“同步代码 → 微任务 → 一个宏任务 → 微任务 → 下一个宏任务……”的循环，不断地把异步回调安排到合适的时机执行，从而实现了看似并发的效果</p><div class="table-container"><table><thead><tr><th>组成部分</th><th>英文名称</th><th>主要职责</th><th>执行时机</th><th>示例任务来源</th></tr></thead><tbody><tr><td>调用栈</td><td>Call Stack</td><td>存放当前正在执行的同步代码，按 LIFO（后进先出）执行</td><td>立即执行</td><td>函数调用、代码块</td></tr><tr><td>微任务队列</td><td>Microtask Queue</td><td>存放优先级最高的异步回调</td><td>当前宏任务结束后立即清空</td><td>Promise.then/catch/finally、queueMicrotask、MutationObserver</td></tr><tr><td>宏任务队列</td><td>Task Queue / Macrotask Queue</td><td>存放普通的异步回调</td><td>微任务队列清空后取一个执行</td><td>setTimeout、setInterval、setImmediate、I/O、UI rendering、requestAnimationFrame</td></tr><tr><td>Web APIs</td><td>（浏览器提供）</td><td>处理真正的异步操作（定时器、网络请求、DOM事件等），完成后将回调放入队列</td><td>由浏览器/运行时独立线程管理</td><td>XMLHttpRequest、fetch、DOM事件监听</td></tr><tr><td>事件循环（Event Loop）</td><td>Event Loop</td><td>不停询问：调用栈是否为空？→ 是的话先清空微任务 → 再取一个宏任务执行</td><td>持续运行</td><td>—</td></tr></tbody></table></div><h3 id="事件循环一次完整循环的执行顺序"><a href="#事件循环一次完整循环的执行顺序" class="headerlink" title="事件循环一次完整循环的执行顺序"></a>事件循环一次完整循环的执行顺序</h3><ol><li>执行当前调用栈中的所有<strong>同步代码</strong>（直到调用栈清空）</li><li><strong>清空微任务队列</strong>（执行所有微任务，直到微任务队列为空）<br> 只要有微任务，就会一直执行完所有微任务</li><li>从<strong>宏任务队列</strong>中取<strong>一个</strong>任务执行（注意：只取一个！）</li><li>执行完这个宏任务后 → 回到第 2 步，再次清空微任务队列</li><li>重复 3～4 步，直到所有任务处理完毕</li></ol><h3 id="代码示例与执行顺序演示"><a href="#代码示例与执行顺序演示" class="headerlink" title="代码示例与执行顺序演示"></a>代码示例与执行顺序演示</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1'</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2'</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3'</span>));<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'4'</span>));<br>}, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'5'</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'6'</span>));<br>});<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'7'</span>);<br></code></pre></td></tr></table></figure><p><strong>执行结果顺序</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>7<br>5<br>6<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><ol><li>同步代码 → 打印 1、7</li><li>微任务队列有 then(5) → 执行 → 打印 5，并产生新的微任务 then(6)</li><li>继续清空微任务 → 执行 then(6) → 打印 6</li><li>微任务队列清空，执行第一个宏任务（setTimeout 0ms）→ 打印 2</li><li>宏任务执行中产生微任务 then(3) → 宏任务结束后立即清微任务 → 打印 3</li><li>微任务清空，继续下一个宏任务（setTimeout 里面的）→ 打印 4</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;函数＋创建时的词法环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个函数能够“记住并访问”它被创建时所处的词法作用域中的变量，即使这个函数</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-19-力扣百题速练（Javascript、TypeScript）Vol-5</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/57550.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/57550.html</id>
    <published>2026-01-19T07:15:12.000Z</published>
    <updated>2026-01-19T08:45:37.940Z</updated>
    
    <content type="html"><![CDATA[<p>这是力扣百题速练的第5期</p><hr><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> </p><p><strong>注意：</strong> 解集不能包含重复的组合</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> candidates = <code>[10,1,2,7,6,1,5]</code>, target = <code>8</code>,<br><strong>输出:</strong><br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><br><strong>示例 2:</strong></p><p><strong>输入:</strong> candidates = [2,5,2,1,2], target = 5,<br><strong>输出:</strong><br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure></p><p>相对于力扣39新增一个去重的逻辑</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum2</span>(<span class="hljs-params"><span class="hljs-attr">candidates</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[][] {<br>    candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a - b);  <span class="hljs-comment">// 排序</span><br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <br>    <span class="hljs-title function_">backtrack</span>(<span class="hljs-number">0</span>, target);<br>    <br>    <span class="hljs-keyword">return</span> result;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params"><span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">remain</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">if</span> (remain === <span class="hljs-number">0</span>) {<br>            result.<span class="hljs-title function_">push</span>([...path]);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.<span class="hljs-property">length</span>; i++) {<br>            <span class="hljs-comment">// 剪枝：当前数已经大于剩余目标值，后面的更大，直接结束</span><br>            <span class="hljs-keyword">if</span> (candidates[i] &gt; remain) <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-comment">// 去重核心：同一层使用过相同数字，则跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] === candidates[i-<span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <br>            path.<span class="hljs-title function_">push</span>(candidates[i]);<br>            <span class="hljs-comment">// 注意：这里是 i+1，而不是 start（因为每个数只能用一次）</span><br>            <span class="hljs-title function_">backtrack</span>(i + <span class="hljs-number">1</span>, remain - candidates[i]);<br>            path.<span class="hljs-title function_">pop</span>();<br>        }<br>    }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41.缺失的第一个正数"></a>41.缺失的第一个正数</h2><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>nums = [1,2,0]</code><br><strong>输出：</strong><code>3</code><br><strong>解释：</strong><code>范围 [1,2] 中的数字都在数组中</code></p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>nums = [3,4,-1,1]</code><br><strong>输出：</strong><code>2</code><br><strong>解释：</strong><code>1 在数组中，但 2 没有</code></p><p><strong>示例 3：</strong></p><p><strong>输入：</strong><code>nums = [7,8,9,11,12]</code><br><strong>输出：</strong><code>1</code><br><strong>解释：</strong><code>最小的正数 1 没有出现</code></p><p>用ES6秒了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">firstMissingPositive</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {  <br>    <span class="hljs-keyword">let</span> ass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(nums)  <br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){  <br>        <span class="hljs-keyword">if</span>(ass.<span class="hljs-title function_">has</span>(index)){  <br>            index++  <br>        }  <br>        <span class="hljs-keyword">if</span>(!ass.<span class="hljs-title function_">has</span>(index)){  <br>            <span class="hljs-keyword">return</span> index  <br>        }  <br>    }};<br></code></pre></td></tr></table></figure><hr><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p><p><strong>示例 1：</strong></p><p class='item-img' data-src='https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png'><img src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><p><strong>输入：</strong><code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code><br><strong>输出：</strong><code>6</code><br><strong>解释：</strong><code>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）</code></p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>height = [4,2,0,3,2,5]</code><br><strong>输出：</strong><code>9</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是力扣百题速练的第5期&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;40-组合总和II&quot;&gt;&lt;a href=&quot;#40-组合总和II&quot; class=&quot;headerlink&quot; title=&quot;40.组合总和II&quot;&gt;&lt;/a&gt;40.组合总和II&lt;/h2&gt;&lt;p&gt;给定一个候选人编号的集合 &lt;cod</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-17-力扣百题速练（Javascript、TypeScript）Vol-4</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/19198.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/19198.html</id>
    <published>2026-01-17T14:53:01.000Z</published>
    <updated>2026-01-19T07:28:38.514Z</updated>
    
    <content type="html"><![CDATA[<p>依旧刷题</p><h2 id="30-串联所有单词的字串"><a href="#30-串联所有单词的字串" class="headerlink" title="30.串联所有单词的字串"></a>30.串联所有单词的字串</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong></p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串</p><ul><li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么 <code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>， <code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code> 都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>s = "barfoothefoobarman", words = ["foo","bar"]</code><br><strong>输出：</strong><code>[0,9]</code><br><strong>解释：</strong><code>因为 words.length == 2</code> 同时 <code>words[i].length == 3</code>，连接的子字符串的长度必须为 6<br>子串 “barfoo” 开始位置是 0。它是 words 中以 <code>["bar","foo"]</code> 顺序排列的连接<br>子串 “foobar” 开始位置是 9。它是 words 中以 <code>["foo","bar"]</code> 顺序排列的连接<br>输出顺序无关紧要。返回 <code>[9,0]</code> 也是可以的</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]</code><br><strong>输出：</strong><code>[]</code><br><strong>解释：</strong> 因为 <code>words.length == 4</code> 并且 <code>words[i].length == 4</code>，所以串联子串的长度必须为 16<br>s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。<br>所以我们返回一个空数组。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> <code>s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]</code><br><strong>输出：</strong> <code>[6,9,12]</code><br><strong>解释：</strong> 因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9<br>子串 “foobarthe” 开始位置是 6。它是 words 中以 <code>["foo","bar","the"]</code> 顺序排列的连接<br>子串 “barthefoo” 开始位置是 9。它是 words 中以 <code>["bar","the","foo"]</code> 顺序排列的连接<br>子串 “thefoobar” 开始位置是 12。它是 words 中以 <code>["the","foo","bar"]</code> 顺序排列的连接</p><p>滑动窗口 + 哈希表解题</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findSubstring</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">words</span>: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || words.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-keyword">const</span> wordLen = words[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; <span class="hljs-comment">// 每个单词长度</span><br>    <span class="hljs-keyword">const</span> totalLen = wordLen * words.<span class="hljs-property">length</span>; <span class="hljs-comment">// 总共需要匹配的长度</span><br>    <span class="hljs-keyword">const</span> wordCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;(); <span class="hljs-comment">// 目标单词的频率表</span><br><br>    <span class="hljs-comment">// 统计目标单词出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) {<br>        wordCount.<span class="hljs-title function_">set</span>(word, (wordCount.<span class="hljs-title function_">get</span>(word) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-comment">// 对每一种可能的起点偏移量进行滑动窗口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++) {<br>        <span class="hljs-comment">// 当前窗口内已经匹配到的单词数</span><br>        <span class="hljs-keyword">let</span> matchCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当前窗口的单词频率统计（临时）</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-variable language_">window</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;();<br><br>        <span class="hljs-comment">// 滑动窗口右边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = i; right + wordLen &lt;= s.<span class="hljs-property">length</span>; right += wordLen) {<br>            <span class="hljs-comment">// 取出当前单词</span><br>            <span class="hljs-keyword">const</span> word = s.<span class="hljs-title function_">substring</span>(right, right + wordLen);<br><br>            <span class="hljs-comment">// 如果这个单词根本不在目标集合里，直接跳过整个窗口</span><br>            <span class="hljs-keyword">if</span> (!wordCount.<span class="hljs-title function_">has</span>(word)) {<br>                <span class="hljs-comment">// 重置窗口</span><br>                <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">clear</span>();<br>                matchCount = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            }<br><br>            <span class="hljs-comment">// 记录当前窗口单词出现次数</span><br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">set</span>(word, (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(word) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 如果当前单词出现次数 ≤ 需要的次数，匹配数+1</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(word)! &lt;= wordCount.<span class="hljs-title function_">get</span>(word)!) {<br>                matchCount++;<br>            }<br><br>            <span class="hljs-comment">// 窗口大小超过目标长度，需要左移</span><br>            <span class="hljs-keyword">if</span> (right - i + wordLen &gt; totalLen) {<br>                <span class="hljs-keyword">const</span> leftWord = s.<span class="hljs-title function_">substring</span>(i, i + wordLen);<br>                <span class="hljs-keyword">if</span> (wordCount.<span class="hljs-title function_">has</span>(leftWord)) {<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(leftWord)! &lt;= wordCount.<span class="hljs-title function_">get</span>(leftWord)!) {<br>                        matchCount--;<br>                    }<br>                    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">set</span>(leftWord, <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(leftWord)! - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(leftWord) === <span class="hljs-number">0</span>) {<br>                        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">delete</span>(leftWord);<br>                    }<br>                }<br>                i += wordLen; <span class="hljs-comment">// 左边界移动</span><br>            }<br><br>            <span class="hljs-comment">// 完美匹配</span><br>            <span class="hljs-keyword">if</span> (matchCount === words.<span class="hljs-property">length</span>) {<br>                result.<span class="hljs-title function_">push</span>(i);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> </li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。<br>必须原地修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong><br><strong>输入：</strong><code>nums = [1,2,3]</code><br><strong>输出：</strong><code>[1,3,2]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong><code>nums = [3,2,1]</code><br><strong>输出：</strong><code>[1,2,3]</code></p><p><strong>示例 3：</strong><br><strong>输入：</strong><code>nums = [1,1,5]</code><br><strong>输出：</strong><code>[1,5,1]</code></p><p>从右向左，找到第一个位置i，使得<code>nums[i] &lt; nums[i+1]</code>，那么<code>nums[i :-1]</code>就是我们需要变换的区域<br>在<code>nums[i+1 : -1]</code>自右向左中找到第一个大于<code>nums[i]</code>的元素，将它与<code>nums[i]</code>交换，此时<code>nums[i+1 : -1]</code>是降序的<br>将<code>nums[i+1 : -1]</code>升序排列，即将它们逆序</p><p><strong>解题的话，这道题目其实是一道找规律的题目</strong></p><p>对比一下这两个数字，探究一下是怎样变化的：<br>143652<br>145236</p><p>后四位都发生了改变，以保证让这个数大一点点。观察到前两位是没有变化的，也就是如果这个数字是3652，那么下一个排列也是5236，与前面的数字暂时无关。<br>所以，我们其实要关注的是最小的变换区域。这个区域应该是从右向左找，以确保变换后的排列与当前的排列是紧邻的。那么怎样找到这一区域呢？</p><p>为什么52不能是变换区域？因为52已经是这两个数字能组成的最大排列了，所以没法再进一步变大，因此不能变换<br>以此类推，为什么652也不能是变换区域呢？同样是因为已经达到了最大排列</p><p>总结一下，降序排列的部分已经达到了最大的排列，不能再增大。也正是处于这一点，我们最终找到了3652，其中3与6不是降序排列的，并且是从右向左查找过程中的第一个升序段，以保证变换的区域最小。</p><p><strong>如何变换？</strong><br>我们已经弄清楚了怎样确定变换区域，因此下面将目光集中到这一小段上：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3652 </span>——&gt; <span class="hljs-number">5236</span><br></code></pre></td></tr></table></figure><p>我们想要让3652增大，但只增大最小的幅度。由于652已经达到最大，因此以3开头已经达到最大了，所以如果想继续增大，不能再以3开头，要在剩下的数字中比3大、但是只能大一点点的数字进行开头，所以这个数字应该是大于3的数字中最小的，也就是5</p><p>现在已经知道了要怎样找下一个开头，接下来仅剩的问题就是除了开头以外的数字怎样排列。换了一个开头，现在其实需要的是这个新的开头的最小排列，因此剩下的数字升序排列就是符合要求的</p><p><strong>算法总结</strong></p><p><strong>从右向左，找到第一个位置i，使得<code>nums[i] &lt; nums[i+1]</code>，那么<code>nums[i :-1]</code>就是我们需要变换的区域</strong><br><strong>在<code>nums[i+1 : -1]</code>自右向左中找到第一个大于<code>nums[i]</code>的元素，将它与<code>nums[i]</code>交换，此时<code>nums[i+1 : -1]</code>是降序的</strong><br><strong>将<code>nums[i+1 : -1]</code>升序排列，即将它们逆序</strong></p><p>感觉面试根本现场想不到，解题思路要背</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextPermutation</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) {<br>            index = i;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt; index; j--) {<br>        <span class="hljs-keyword">if</span> (nums[j] &gt; nums[index]) {<br>            [nums[index], nums[j]] = [nums[j], nums[index]];<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-keyword">let</span> left = index + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>        [nums[left], nums[right]] = [nums[right], nums[left]];<br>        left++;<br>        right--;<br>    }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。</p><p>左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 <code>"(()())"</code>。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>s = "(()"</code><br><strong>输出：</strong><code>2</code><br><strong>解释：</strong> 最长有效括号子串是 “()”</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>s = ")()())"</code><br><strong>输出：</strong><code>4</code><br><strong>解释：</strong> 最长有效括号子串是 “()()”</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong><code>s = ""</code><br><strong>输出：</strong><code>0</code></p><p>解题的话用栈记录「还没匹配的左括号下标」+ 「上一个有效结束位置」<br>遇到右括号就计算长度，并更新 max_len</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">case</span>     栈操作                 何时更新答案                     长度怎么算<br>──────   ──────────────────     ─────────────────────────────   ────────────<br>遇 <span class="hljs-string">'('</span>   stack.<span class="hljs-built_in">push</span>(i);         不更新                          —<br>遇 <span class="hljs-string">')'</span>   先 <span class="hljs-built_in">pop</span>()               —                               —<br>         ① 弹成功，栈还有东西   更新答案                        i - stack.<span class="hljs-built_in">top</span>()<br>         ② 弹成功，栈空了       更新答案                        i - (<span class="hljs-number">-1</span>) 即 i+<span class="hljs-number">1</span><br>         ③ 弹失败（栈本来就空） 不更新，把自己当新墙            stack.<span class="hljs-built_in">push</span>(i);<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestValidParentheses</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"("</span>) {<br>            stack.<span class="hljs-title function_">push</span>(i);<br>        } <span class="hljs-keyword">else</span> {<br>            stack.<span class="hljs-title function_">pop</span>();<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>                stack.<span class="hljs-title function_">push</span>(i);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">const</span> length = i - stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>                maxLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLen, length);<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> maxLen;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>向左旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 下标 <code>3</code> 上向左旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>nums = [4,5,6,7,0,1,2], target = 0</code><br><strong>输出：</strong><code>4</code></p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>nums = [4,5,6,7,0,1,2], target = 3</code><br><strong>输出：</strong><code>-1</code></p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> <code>nums = [1], target = 0</code><br><strong>输出：</strong> <code>-1</code></p><p>主要就是二分的思想，从left和right出发，在 while(left &lt;= right) 循环中，每次计算 mid 后</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">if</span> nums[<span class="hljs-built_in">mid</span>] == target → 直接返回 <span class="hljs-built_in">mid</span><br><br>否则进行分支判断：<br><br>情况<span class="hljs-number">1</span>：nums[<span class="hljs-built_in">left</span>] &lt;= nums[<span class="hljs-built_in">mid</span>]    ← 左半部分 [left...mid] 是升序的<br>    此时左边这段是连续有序的<br>    判断 target 是否落在这段有序区间内：<br>        如果 nums[<span class="hljs-built_in">left</span>] &lt;= target &lt; nums[<span class="hljs-built_in">mid</span>]  → target 在左半 → <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span><br>        否则                                 → target 不在左半 → <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span><br><br>情况<span class="hljs-number">2</span>：nums[<span class="hljs-built_in">left</span>] &gt; nums[<span class="hljs-built_in">mid</span>]     ← 左半部分无序，则右半部分 [mid...right] 必然有序<br>    判断 target 是否落在右半有序区间内：<br>        如果 nums[<span class="hljs-built_in">mid</span>] &lt; target &lt;= nums[<span class="hljs-built_in">right</span>]  → target 在右半 → <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span><br>        否则                                 → target 不在右半 → <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>算法实现如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">search</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(left + right / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (nums[mid] === nums[target]) {<br>        <span class="hljs-keyword">return</span> nums[target];<br>    }<br><br>    <span class="hljs-comment">// 判断左半边是否有序</span><br>    <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) {<br>        <span class="hljs-comment">// 左半边有序</span><br>        <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) {<br>            <span class="hljs-comment">// target 在有序的左半边</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// target 在可能无序的右半边</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        }<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">// 右半边有序</span><br>        <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) {<br>            <span class="hljs-comment">// target 在有序的右半边</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// target 在可能无序的左半边</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></table></figure><hr><h3 id="34-在排序数组中找出元素的第一个与最后一个位置"><a href="#34-在排序数组中找出元素的第一个与最后一个位置" class="headerlink" title="34.在排序数组中找出元素的第一个与最后一个位置"></a>34.在排序数组中找出元素的第一个与最后一个位置</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>nums = [</code>5,7,7,8,8,10]<code>, target = 8</code><br><strong>输出：</strong><code>[3,4]</code></p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>nums = [</code>5,7,7,8,8,10]<code>, target = 6</code><br><strong>输出：</strong><code>[-1,-1]</code></p><p><strong>示例 3：</strong></p><p><strong>输入：</strong><code>nums = [], target = 0</code><br><strong>输出：</strong><code>[-1,-1]</code></p><p>主要就是二分的思想</p><p>从left和right出发,在 while(left &lt;= right) 循环中，每次计算 mid<br><code>if nums[mid] == target</code>,找到任意一个 target 后，向两侧暴力扩展</p><p>以当前 mid 作为初始的左右指针起点（lindex = mid, rindex = mid）<br>向左扫描：只要左边相邻位置仍然等于 target，就继续左移<br>向右扫描：只要右边相邻位置仍然等于 target，就继续右移</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">let</span> lf = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> rg = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (lf &lt;= rg) {<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((lf + rg) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] === target) {<br>            <span class="hljs-keyword">let</span> lindex = mid;<br>            <span class="hljs-keyword">let</span> rindex = mid;<br>            <span class="hljs-keyword">while</span> (lindex &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[lindex - <span class="hljs-number">1</span>] === target) {<br>                lindex--;<br>            }<br>            <span class="hljs-keyword">while</span> (rindex &lt; nums.<span class="hljs-property">length</span> &amp;&amp; nums[rindex + <span class="hljs-number">1</span>] === target) {<br>                rindex++;<br>            }<br>            <span class="hljs-keyword">return</span> [lindex, rindex];<br>        }<br>        <span class="hljs-keyword">if</span> (target &gt; nums[mid]) {<br>            lf = mid + <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) {<br>            rg = mid - <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> <code>nums = [1,3,5,6], target = 5</code><br><strong>输出:</strong> <code>2</code></p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> <code>nums = [1,3,5,6], target = 2</code><br><strong>输出:</strong> <code>1</code></p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> <code>nums = [1,3,5,6], target = 7</code><br><strong>输出:</strong> <code>4</code></p><p>非常经典的二分查找</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) {<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] === target) {<br>            <span class="hljs-keyword">return</span> mid;<br>        }<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) {<br>            right = mid - <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            left = mid + <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> left;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="36-有趣的数独"><a href="#36-有趣的数独" class="headerlink" title="36.有趣的数独"></a>36.有趣的数独</h2><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>空白格用 <code>'.'</code> 表示。</li></ul><p><strong>示例 1：</strong></p><p class='item-img' data-src='https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png'><img src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt=""></p><p><strong>输入：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs prolog">board =<br>[[<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>]<br>,[<span class="hljs-string">"4"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>]<br>,[<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"5"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>]]<br></code></pre></td></tr></table></figure><p><strong>输出：</strong> true</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs prolog">board =<br>[[<span class="hljs-string">"8"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>]<br>,[<span class="hljs-string">"4"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>]<br>,[<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"5"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>]]<br></code></pre></td></tr></table></figure><p><strong>输出：</strong> false<br><strong>解释：</strong> 除了第一行的第一个数字从 <strong>5</strong> 改为 <strong>8</strong> 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p><p>解法很通俗</p><p>判断数组有无重复项直接用这个</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicate</span> = (<span class="hljs-params">nums</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(nums).<span class="hljs-property">size</span> !== nums.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params"><span class="hljs-attr">board</span>: <span class="hljs-built_in">string</span>[][]</span>): <span class="hljs-built_in">boolean</span> {<br>    <span class="hljs-keyword">let</span> vali = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ine = <span class="hljs-number">0</span>; ine &lt; <span class="hljs-number">9</span>; ine++) {<br>        <span class="hljs-title function_">linevali</span>(ine);<br>        <span class="hljs-title function_">rowvali</span>(ine);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>);<br>    }<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">KT</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>) {<br>            vali = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">linevali</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">let</span> stk = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {<br>            <span class="hljs-keyword">if</span> (board[num][i] !== <span class="hljs-string">"."</span>) {<br>                stk.<span class="hljs-title function_">push</span>(board[num][i]);<br>            }<br>        }<br>        <span class="hljs-title function_">KT</span>(stk);<br>    }<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">rowvali</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">let</span> stk = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {<br>            <span class="hljs-keyword">if</span> (board[i][num] !== <span class="hljs-string">"."</span>) {<br>                stk.<span class="hljs-title function_">push</span>(board[i][num]);<br>            }<br>        }<br>        <span class="hljs-title function_">KT</span>(stk);<br>    }<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">nnvali</span>(<span class="hljs-params"><span class="hljs-attr">HT</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">ST</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">let</span> stk = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) {<br>                <span class="hljs-keyword">if</span> (board[<span class="hljs-variable constant_">HT</span> + i][<span class="hljs-variable constant_">ST</span> + j] !== <span class="hljs-string">"."</span>) {<br>                    stk.<span class="hljs-title function_">push</span>(board[<span class="hljs-variable constant_">HT</span> + i][<span class="hljs-variable constant_">ST</span> + j]);<br>                }<br>            }<br>        }<br>        <span class="hljs-title function_">KT</span>(stk);<br>    }<br>    <span class="hljs-keyword">return</span> vali;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h2><p>（TODO）</p><hr><h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h2><p>「外观数列」是一个数位字符串序列，由递归公式定义：</p><ul><li><code>countAndSay(1) = "1"</code></li><li><code>countAndSay(n)</code> 是 <code>countAndSay(n-1)</code> 的行程长度编码。</li></ul><p><a href="https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940">行程长度编码</a>（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串 <code>"3322251"</code> ，我们将 <code>"33"</code> 用 <code>"23"</code> 替换，将 <code>"222"</code> 用 <code>"32"</code> 替换，将 <code>"5"</code> 用 <code>"15"</code> 替换并将 <code>"1"</code> 用 <code>"11"</code> 替换。因此压缩后字符串变为 <code>"23321511"</code>。</p><p>给定一个整数 <code>n</code> ，返回 <strong>外观数列</strong> 的第 <code>n</code> 个元素。</p><p><strong>示例 1：</strong><br><strong>输入：</strong><code>n = 4</code><br><strong>输出：</strong><code>"1211"</code></p><p><strong>解释：</strong><br>countAndSay(1) = “1”<br>countAndSay(2) = “1” 的行程长度编码 = “11”<br>countAndSay(3) = “11” 的行程长度编码 = “21”<br>countAndSay(4) = “21” 的行程长度编码 = “1211”</p><p><strong>示例 2：</strong><br><strong>输入：</strong><code>n = 1</code><br><strong>输出：</strong><code>"1"</code></p><p><strong>解释：</strong><br>这是基本情况。</p><p>解题的主要步骤：</p><ol><li>从初始字符串 “1” 开始</li><li>每一轮生成新字符串时：<ul><li>遍历上一轮字符串</li><li>统计<strong>连续相同字符</strong>的个数</li><li>遇到不同字符就把「计数+前一个字符」拼接到结果中</li><li>最后一组也加上</li></ul></li><li>重复 n-1 次</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countAndSay</span>(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-string">"1"</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">let</span> next = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; current.<span class="hljs-property">length</span>; j++) {<br>            <span class="hljs-keyword">if</span> (current[j] === current[j - <span class="hljs-number">1</span>]) {<br>                count++;<br>            } <span class="hljs-keyword">else</span> {<br>                next += count + current[j - <span class="hljs-number">1</span>];<br>                count = <span class="hljs-number">1</span>;<br>            }<br>        }<br><br>        next += count + current[current.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>        current = next;<br>    }<br><br>    <span class="hljs-keyword">return</span> current;<br>}<br><span class="hljs-comment">//runtime:5 ms</span><br><span class="hljs-comment">//memory:58.6 MB</span><br></code></pre></td></tr></table></figure><hr><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>candidates = [2,3,6,7], target = 7</code><br><strong>输出：</strong><code>[[2,2,3],[7]]</code><br><strong>解释：</strong><br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次<br>7 也是一个候选， 7 = 7<br>仅有这两种组合</p><p><strong>示例 2：</strong></p><p><strong>输入:</strong> <code>candidates = [2,3,5], target = 8</code><br><strong>输出:</strong> <code>[[2,2,2,2],[2,3,3],[3,5]]</code></p><p><strong>示例 3：</strong></p><p><strong>输入:</strong> <code>candidates = [2], target = 1</code><br><strong>输出:</strong> <code>[]</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params"><span class="hljs-attr">candidates</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[][] {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bt</span>(<span class="hljs-params"><span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">remain</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">if</span> (remain === <span class="hljs-number">0</span>) {<br>            result.<span class="hljs-title function_">push</span>([...path]);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (remain &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.<span class="hljs-property">length</span>; i++) {<br>            <span class="hljs-keyword">if</span> (candidates[i] &gt; remain) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            path.<span class="hljs-title function_">push</span>(candidates[i]);<br>            <span class="hljs-title function_">bt</span>(i, remain - candidates[i]);<br>            path.<span class="hljs-title function_">pop</span>();<br>        }<br>    }<br>    <span class="hljs-title function_">bt</span>(<span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;依旧刷题&lt;/p&gt;
&lt;h2 id=&quot;30-串联所有单词的字串&quot;&gt;&lt;a href=&quot;#30-串联所有单词的字串&quot; class=&quot;headerlink&quot; title=&quot;30.串联所有单词的字串&quot;&gt;&lt;/a&gt;30.串联所有单词的字串&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/c</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-16-记录关于论文细化的方法论</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/56232.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/56232.html</id>
    <published>2026-01-16T07:43:54.000Z</published>
    <updated>2026-01-17T06:24:40.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-如何细化一篇论文"><a href="#0x00-如何细化一篇论文" class="headerlink" title="0x00 如何细化一篇论文"></a>0x00 如何细化一篇论文</h2><p>细化一篇论文（Refining a Paper）是一个将”粗糙的想法/初稿”打磨成”严谨、可信、高质量学术成果”的过程。基于你提供的两篇关于区块链共识算法的论文范例，细化工作通常遵循从逻辑架构到细节内容，再到语言修饰的路径，分为五个维度。</p><h3 id="逻辑与故事线的细化-The-Narrative"><a href="#逻辑与故事线的细化-The-Narrative" class="headerlink" title="逻辑与故事线的细化 (The Narrative)"></a>逻辑与故事线的细化 (The Narrative)</h3><p>论文不仅仅是数据的堆砌，更是一个说服读者的过程。首先需要明确”差距”（Research Gap）。粗糙版本可能是：现在的算法太慢了，我提出了一个新的。而细化版本应该是：现有算法在XX场景下（如大规模网络）表现良好，但在YY场景下（如弱网环境）通信复杂度高达O(N²)，导致扩展性瓶颈。目前的改进方案（如 GHOST）虽然解决了分叉问题，但未根本降低通信量。</p><p>接下来要强化”贡献点”（Contributions）。确保摘要和引言中的贡献点与正文严格对应。细化技巧是不要只说”提出了算法”，要说”提出了基于XXX理论的算法，解决了YYY问题，将性能提升了ZZ%”。</p><p>此外，要统一术语，全篇检查关键词（如”同步网络”、”邻居节点”、”收敛时间”）的定义是否前后一致。</p><h3 id="理论模型的细化-Theoretical-Model"><a href="#理论模型的细化-Theoretical-Model" class="headerlink" title="理论模型的细化 (Theoretical Model)"></a>理论模型的细化 (Theoretical Model)</h3><p>这是你提供的两篇论文中非常出色的一部分（第3节）。理论细化能让算法”站得住脚”。首先，参数定义需要形式化。粗糙版本是假设网络有延迟，而细化版本则需要定义网络为图G=(V,E)，定义延迟τᵢⱼ为随机变量，且满足分布D。所有变量首次出现必须定义。</p><p>如果使用了微分方程（如论文中的dLᵢ(t)/dt），需要解释物理含义。细化技巧是解释方程中每一项代表什么。例如：”第一项α代表算力增长，第二项∑代表邻居传播带来的耦合效应”。</p><p>收敛性证明方面，不要只给出结论。简要描述证明思路（Proof Sketch）：利用了什么数学定理（如李雅普诺夫稳定性、马尔可夫链收敛性）？</p><h3 id="算法设计的细化-Algorithm-Design"><a href="#算法设计的细化-Algorithm-Design" class="headerlink" title="算法设计的细化 (Algorithm Design)"></a>算法设计的细化 (Algorithm Design)</h3><p>这是论文的”肌肉”部分（第4、5节）。首先要提供标准的算法伪代码（Algorithm table）。细化技巧是明确输入（Input）、输出（Output）、初始化步骤、循环条件。</p><p>复杂度分析方面，不仅要给出O(N log N)的结论，还要分步推导。例如：”邻居查询耗时O(d)，全网遍历耗时…”，因此总复杂度为…”。同时讨论最坏情况（Worst-case）和平均情况（Average-case）。</p><p>对于机制的具体化，如果有”特殊机制”（如论文五的时间窗口、论文四的链权重），需要说明参数如何选取？为什么选α=2而不是5？（即使是经验值也要说明）。</p><h3 id="实验验证的细化-Experiments"><a href="#实验验证的细化-Experiments" class="headerlink" title="实验验证的细化 (Experiments)"></a>实验验证的细化 (Experiments)</h3><p>实验是论文的”证据”（第6节）。对比基准（Baselines）的选择上，细化技巧是选择最经典的（如Bitcoin PoW）和最前沿/最相关（如Algorand, GHOST）。解释为什么选这些作为对比。</p><p>多维度的指标（Metrics）方面，不要只看”收敛时间”。细化版本要增加吞吐量（TPS）、通信开销（带宽占用）、分叉率、安全性（抗攻击能力）、延迟分布等。</p><p>敏感性分析（Sensitivity Analysis）是很多论文容易忽略的加分项。做法是改变关键参数（如网络延迟Δ、节点数量N、丢包率），观察算法性能的变化。证明算法在参数波动下是鲁棒的（Robust）。</p><p>图表说明方面，不要只放图。图下方的文字必须解释：”如图X所示，随着节点数增加，本算法曲线平缓，而对比算法呈指数上升，这说明…”</p><h3 id="语言与格式的细化-Language-amp-Formatting"><a href="#语言与格式的细化-Language-amp-Formatting" class="headerlink" title="语言与格式的细化 (Language & Formatting)"></a>语言与格式的细化 (Language &amp; Formatting)</h3><p>结构化表达方面，多用”首先、其次、最后”（First, Second, Finally）。段落核心句（Topic Sentence）置于段首。</p><p>公式排版方面，使用LaTeX规范排版，确保符号清晰。</p><p>引用规范方面，确保参考文献覆盖了经典文献和近3年的最新文献，体现研究的时效性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x00-如何细化一篇论文&quot;&gt;&lt;a href=&quot;#0x00-如何细化一篇论文&quot; class=&quot;headerlink&quot; title=&quot;0x00 如何细化一篇论文&quot;&gt;&lt;/a&gt;0x00 如何细化一篇论文&lt;/h2&gt;&lt;p&gt;细化一篇论文（Refining a Paper）是一</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-16-关于低复杂度最长链共识算法设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/566.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/566.html</id>
    <published>2026-01-16T02:33:23.000Z</published>
    <updated>2026-01-17T07:13:16.212Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="如果是项目组成员，请联系站长。WXID:Zhong_ye1" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">      <script id="hbeData" type="hbeData" data-hmacdigest="81da3fd76591ea9f510a24b56150d407f6384374f09e2ec1cb54c5122bf1f3af" data-keysalt="4a4528a0aa52eff35cb862ae9ec7ff43a4d7ab767fa4f0e94d1e07f51622f03e" data-ivsalt="12cf0312c33a440141fc08d3649b84a0ff7a1898cd48a9cb4a5a0810e6d35a04">        5c2074a1891ba9dc1e53ded94473e9b77ddb6a99d31227be97efae10553e2b4a6cfdc10569bcc7d6ed267e9f733b713b8c67782ebb3e7522b82d5b5d36c0ac8ee74898ac72811ad026b919f61923bc8e64e933dd8848f9ff99fcb386c2c589f8070f7b8c67dbef28361f3bd6ed4b6d2c204eaa4ffa0a3dfe8c3465e2a53a44ab78da3e5478e342ba0acb67cfd2ac85179ec2893cd9fe4cb8485a5c3bc8bf73f347c5727310dccd29b629dc2052afca63931a963fde2963671b35f583a905710adcbc69d4ef0e9c6b70119cb129bf51a2b573e4b170e69ffb5f600acd29b68005b125f6ed5ed868b2aa7d310bb84a5acba857b0dba13d8db18bfbb8f287770c9e02e8b65110380fcfc51a10092359223d5faa19533e6df02f47e9f9fb6112d58815da4793ee4a3b3e22469115f63c7ec99fa368fecdd4f24fa1d3e63a3a1255fa3941311c5f5b750f79015c0585b1033125d7b7bc69877ffc601dc3c670fb59f1fb5eaedede9a39491a517d96880cce6997e959db8a353017e7199b44a5594fc596080cdd11bbb5b440cfac0c60e82ee11652e61b8e9a42d64e326712a6b14555cbee84148cfb1424e8fee418bd4131b74255d27554baacbd6f2843ba444d6790b5fc5a7880be60b11a4bebfad25a36407fade26541c02dc38c537834a9f5f5a4df3bc468c08dd25730ced3002175e760f85c3ad13b9be586ef478b0a23b1c8a0f1571ea3f30233c1cf3301474eb1d0bd520fa6495229c07d114397eb582abc534ee62a67de720820301273ebcd0315144f3a3acfb265f23a1dddd25297cbb268f007f86b30c5044584a246da049cc1cacb4e1edbe311884abcb3affe676da901ef5e5be4fa677c121e22b30b84981390aade11a928eb992a1906435a9116d936a06465afcd671b70847f902f0e1c0bd1c2eec429db352f4dc9f3cdece2f54b973f9d8d9a1909d752dbe46fa3c7d60fc149757758581003b3b4ac8035ab044d8e2c634c7ce3d56af94bfcdb00ffc42973d7345a091c88a80163f420afadfcc6191626476c64bf0ee03680ae29eb8569e16eaa7f62eaa3afeca2fe95d88a1e088ce62b3917f4ed3964046b14e6f276a335e58f9f67d3a41aae1a45619a2c4a676e689b3d3dac6e65bdbaa3ecd45d2631b24619a3a4f4ec6722b0f1cbc06932369df9ee82a83e30afd14767e1f5a10d7d328484120c56961cc4b131c6bfc3b5f26b0247e53d07b178c0825845584958d1736d1b9a2f986ab5b843ddaf7f5efc86ad1abde01df44abfbc3c9f48c5fe8529b6fe075523833d7080c5b774bbba3832eb70e00fe50b126f5e88aec93862b2974b3c10683422a6595581bd6dc6788d2b517ea249aee54cceadc2d97aab0d97a51558121bb5530acd93e9ba8e1a2310b5b4fb4e5c70fd02d3d4cdeff37d9e762d4d1b7f31c1ab27b8cecf0dbee846014f3a017e9d690b1fb6eba226354c3dad31bc0e183e11e68660a16e6ab4727655820ca4485826f302acf1f4d5893621c66bd9f8bd2547f59e6786731bb65894814b6113f2c85c6a590a5868e7738bcaed2c626284241bde11dd529c068ab2123c7b5e2c1dd2e35ec11d3585ffc16ef8b854ca61d5a6d4a0e613f17b18083e3a76e1b02534c9dd6e9792bc6f15180170d70db9b29d0907427b36490f1b00c01c3b6a0428b59a28127f07111e1272d40a24a0985d5e6ae59e5e1b4fe9d494862a465ebbe7a1cd37b6d3151679dc0c585340acab67b20f789b1297781bc14a740a937f15f033900e0a1255147c4fbcff0678dbdc628c99a620c6407e612186762ec15444d4689010ea18d9d263958142cfe1eb8bf41936b3e279c6eda73f4115a72706201604ab96d1ef513d0737db028998c3bd96c3d4e6ce8a2e8a8704e6f7aa7b53ed2718d6a7fbd815c308e32dd2a1ab3ed4dc6ccc7676bacfe588f08181ab52e96eedc822aa520be77351fffe63b6a0a6e959e7900a87a253fde195b9fd221c0a1fee68d48c6131252f3c4e856a336efb1c3a7a7a308a341e663ffbd872bf6e28952027e263fba2cacfde349bd49e260a2bd1e39b800d957ae4a31650b8c350678607e0d157e8357bbfcfa1767c525f970519eb28496bd8eb957caa3393a59e39da1d64b19836ad8acc93fb4ed59079813dc72ea330daea80c5fbd4efa673f2aaefccea83ff7362c63e7f7540e03fa7e786c537dad9710e3e44ff07fe33f358784bda5400dfabdc10cb583786f19dd1bc672fd0355cfa581aaeac469a8154e8cbc7ca65936fb147dfb435c1f6db35bdfa793fd330c02af8a373175f060e13932dda24db68715aea48361db1f697b50828affee5d84f8dd93095d4fd2e4722414d410d1196bf98ad42f56e6c231069282fcc03109639a2ce9789ce243435db26e69f11c65f013a70503c0403897e5061f0177e6477021931cc16317b39f89f389d7cfc31529edbdced078e8a999cdb21fdf342a9d2cb96f03cbb8923c58a776d4965897aab0c88aa3270b82e4d9121b1ce3c1146625d607905245ea0b38430def844b8a5785aa6e43e4cd4aa131cb5c855ae72ed6f3f4644b97f837b5f12003e5415285e5304ccf99f559efcfaf4010d7c7fbe126901e2e636f2785fcbf19c0136328b3484139e33155b345d4262a171223697161ad5e795382d5649290b66df78816bb7ceffc18af79e2c9173e8211a39858e2e13f2cc090f0c66006a31c07ba92d091cd001ef64b9d448d270e4f237831e4a5a5b4740815b4d5210ac371548f821cace8696d9c62f31f02cf73065761335c49ad6286d4a3908792fd238e8ca23786d7a0d0f825ccba823060450503458f7f7ec6a8a9a884ae15535d19b020a3680ef80e8caee70b7387a6d2f1de97185d716d650ff474697bc98ac7ee42b46eafa77353991319db5d55b587e6f615ee93fc7c9e77fc2483389d0e8af22c324475df6cd203e52d29ed6996cbcaafbafc321adc85b4c5be3696ac7fae3d0eda88730c761cda43cfdb25f4a5dd41bf5d627cf47566e3fa0d2ea4fe44e864a63f7be08658a44b2c2cf0f35ee23b92ce30e6f204a629c34697238e05462b73b2c687c3ef0ecfcd348da394f7fc60f51e234a904333d9416a9091a8a800ae89983d9b2af83cb983ba1d2d4518e942d5f2cc6f1b0617b71866f5e420c87c8e88884770704cb14c043919cd7ec72b184d21b8da8b825e4363df38153a38e1e6bc73ed0ceb8adfc5bfa3a5174ac0afc0deaa77d761c86cf55fb6d2552c71e79a40bac49818b13ea017d7e8eb7acaeba17dd2acce7b27ba3f59c194aed11352d1aaa74c592e9c92431a37405bcf8b5b5ac37ea0c4d527a600c8784055eee84a38efc685ade34c91ae31e127d75e59069de1da22db81cfd80656b87d9cb0007b9e439f15064722a245882ca3baef1e3f1227690d272c21a0348a546edc6acb462159197f860cd5e7537dbe2374acc39203e32ac5de41f016291bc33de117dd01493ca937119af77b243d74658077e342f13346ba97dd331cdbb256e5daa3b12eba72c1aaf39347e6e62940e18ea77ebfd4f8218f9c028f68993496c6c0b13a653e6ffa200c2816ff9d74559521ab60d55864529684102a018448ac061c42187ab7a57a961ece4262fa1a336b1241b31e811ecc6a0d6ee5e4729f89f4e4d19621cdd714f4af6da17f35f30c656238b5691ce0e9e198a4e2944c351711c217b32fa48cdbc4cf16d2e183e0be950104207272f1a2c11b4e18d34644fd84743dcc3c0a0c00439dc2ecdda1d4c8b670ee194894035a1fe59e58b0a7a829ecaddabca6d1ec1b79cddf6848b4a82d468dac7544680df23b3d0944bd4a04bbdf0e54a141543047642b94a57e0189d30f9a3de22501ab981c550b08524392387c7e40e6813b1d5706ab92a5dcf72cf5e18bdd425cbcb93df9c3a64f2dd5d28280aedf489e60e2b21e93dc68cb5e2c07202b64a424b2802fb54c5e31f731571a057edf2297b184d5b7224b8e08c99fe337adefd01b2ac46ded295f0c3b02b72f0f3ca023c5625edac907a0bce808010581dca5e25e9e1baa5041bc9400fc696ac23a6a4ce0246c2d29978d8c7284d1c5145eaa93a69f3686f5c0da8c5d9a0225ba009c0ac08479bcb9e50eb8769f18e22bf7d631d970f0792b923b14ca72752ebf16c4936dd65e4afb2ff707708381301f16b51b90e9809c80cd0ba8d86c768f736d384c305e48fee684d04935ad8fd2cfb1c039762a204ff3c0244d858a269f8fe27ade78d327a2e32d38d77bc3b33d575cc22fca87c40bb81911ef7a77c725753098007fe903968e33a4d886754697f5d8a82742cbd1392c5ac85ffdfda60b27f125ff844b7b7b625082a062809f2354da6c62a420534e0e1721195d944129ec9044ea6d0f0f3546c7d3c23534c7951e58d5bef944066ff671cf53c41fefe730c4e2328649ca0b05904707fa784df1d8fbb925a56994496a92e4ed1b695b53e717fde3ae3df611d7a712b43c79eac6f03ef839fc6bf2a5a9d57d03f7ee84fa6257f6d2d574f11796f1178d752c8e8b6c938eee1a4c3dd36ebda59fa4b54362c49f56d9d0918aef608a8b5ac0887131c957d07cb7292835d8b9ad519f88c5ef788b87c442d36fca9751b5d2192f8d4188c5092575f1d34618aba5fbc68ee325974dbc53ed800cfd70827f4db29f7eccc2f6ab678f52ab3d145b632706deef878b00a2119d677f0e927ad9dbf29815a505680318447adbe406d8b02546f0c253bd52b9e1826f680d36538b00ec19d0b632811d68f63f509f3e2e09b2ceab284ba14610089fe6da870e095d672a5de2486f1247eae05e68d7a6381c95df369f550f954791f1824fd080674122784bd2e342d99d05211c6629270699d931de249061af3e118fadbdcaa060a55a1cfe4da41b5cd5b27323780401758edb2be6aeba5ade58fddfdf662d3856240464b18d1d5ae17f94a67423eebd936367bb91e509705ddd2a36646734fa00c3e0d895af16873a4b8d8357a091c672bae99a451307537f6653813409c7ade9575dff827d1f0c44978112d5f56ed04de8f8f3f7c6024685b25b606ddec2aebbca3dd9ee6676cf8fdd8b27201a07877a50198946a3c06b725f2c9ffa337248f76452c2f386b324d32ace5160ac3bbf660ca957f56cd9a5ee2b07b921942c5cae4d133e1a000901c9a4839924de9b63201d822fc4668ecbb6c517529779442cf9500281b1e305eb81ba385e74971de7b3070763f6d47e68ce1b73d5c5cf87322a042aa5c7acaab3e27753e1a2a8e83eac83d7dacdbbd56aed38426ed9018fb823cf43d6b7f58ff2c6b069b684612096fd226d06470e806b0fb5631ca82b6d6119068492aa482f59d31d80c148da9460c6ef65dac74e61290745cacf8a4984101ee6306b74f287546351eecb408802e93eccd390cbaca65d81077a478e2ed518040b65da5e980b7cfd9e35178b79cf57f80d2faccd3dd3461fc0cadd118939f2afeabdff017ad5d13f5ec7c648a5ac79916791567e667778e1fd05742ac13c593d6a85abe53f24120ca181654a031c46c0e57682d0374846edc7fa06e3c7317a1d144c2ba44d2f3fd6c639029c4eb77fbaaf801035932c5c6125e773b35bb1f8838a7cf220f0bbee9862e873485db0929b054772f653de39133199e313eb07a643df34bded0cbee13e05b9c654cbdba2169e2856c9b4d26c9fbbf382004bbe8a95ba69d26885b7946977fbae90f43fcb5256e9192761f765d04921c2c138dd2078247f3f0c901baa778a55d78b5e80109bb0bf2717e939d7d08f2fc1ec11636c91736868207ecdcb5e009625972aa6d600cb051410a4e34015e2c42660972be729c6b0c6815a6d631d3ff37f59ee95576b16fc48585d83ca90987690e91c829a8f6cc663b5414536393a5f9b37f373c7f6c60a27942b324a6ea1970cbe43737d38812e3dfc87f70b7a7d9860636b95b3d3a6a958dd5a87b9867ba759dfcc1abbe931d353dac167c7d8b7775f1eab57d50b4cb02be93bf805ea790365c2f3632cec0f97a444efdb8686a8ad6cb6c3ce89189336eeea9cb6bcf1716d70ff679564b8369d9205c61eb3f90231bc92cd28a27e93551b82565e9dcbc19a2f864453eef9da998d21705c9e6290a3dc42a16f701e948e92b95ac68ecac1dd0e64546319620ff553e5fb145d77a1548026b8b5fc3c90200b63e94eaeb88d85cfaeffd181b63132e5ff5b716ef1c818f3950912cde00dd8731d29262c226be9444afdb324acf4968ecd3ce7517c8a24179865a34ae6cf0bb8b059697837a56b5d399da4bcd7ecc2b425f59c1c173732776b3139d50b556e7bb73f139432c6f6df4ab14257de97fe745ceca04db08a00a57b311e1cfab9a760ad37d753eea738485fb6c5e56ee55037ce6e7efca9ff8bced0c138074b50117929ca7301480de05361aa84d7f1a700a9ae192995a153279c1eb884b7c18dbd2e5e1c6fb746a376a2ca3affef09c9ae04ca7fbb8f10e8fd09aa083cd141f54cf5d4564c3702d0c14db99817c44ad36e7c604a1fc433cafe01b8e1331c6265cc3fcafb9f14de0ca0f4f902acd439d4e5dd7f78170aaaf8696aa3ff4a5a789159b4c68ac4473ed0ae5ef08017ad23e5fcbc7ba52e773f9c23b5738ad122f87228b6cffd9a0b5d60041f4813c8bbde402dc76de96c656f585f5406b6760d57a4755c472427613abbf473c6d894e8b692c810e93c2205196d6b79f0b8d6466a00d215e455f4a76eadb24fb136ecd7b4434d0765059dbc7251ccf6e388bb9285e4ef41ab5805c679d5c6ceae88811816f4149e03cc2dcea7dcb91c9c6119ff3221204b74bb7807a2e6930f280f57806433d6fa95990a452118b99fcce620a1dae4b45ff5c26ae606350eb5d79d72f06d0c0cf6f29e4f9ab263f6f0769239f4d5fa807533bf3d39df316c40a5773eafd12a27acb438f990065cba2a3bb7311baa74090935593558348544790744978c834a9ed0c2c7da37d92f26e87715ad33d2060e2c16c3c15b0fef1b1b4a306def14d19c445c97e572384f6621516b45d41ec7984112fb2401b5a931659014f65d688ff5eb9c7553563006e37d5daf504ce75ac77db2f3d1dc04b7c35c3eec9ffd5f4b6eadd7f868d663252871f56100d9401e990d53416fde68ee329414da93adf0a9378b0c330abcd5f9436127516aa8f3b146426956072c4b5ce8db2d261f454cd6c581c8faa9d64332ab7759640e6234f2f0d395a674e639261d43a497a91372ad1bf20225e424252a79b55e91435665112063afa0cee0c4315397b1fb2b2821aaf4f1a737dcf0f411f7ec869bed7758c3649eae3a41c15add3c814284db738405182db055b5c86b1ca97bf41480a485ec1c3059da653034e5a7f94be91b25207c7fff715c91bb12dadeee9eb5bf40ae04338803dcdbf461b71a6eebb42f1d9110a9b018604edfdae0689a9e01786ee3cf15b004e9d81f5c8b9065566451bb121cc0aff866b08be24797218c87919c7c88b798eb3d8717594d4c462554cab96e6fba207102974a438e7b521b831d7e27bf8ebb84d5f8b773081d763ac8bf6c9222d76b294f17692744cdea4385ecc227af6b0c8e9814f0ed242ede80fc94a604f3a6d73cd3d20d1fc0ef66ceac24108716ec183b066cbc5d86408e87c80636ca6081fb261200dd02b3a9b43c40819d10e92abec9e273a17e99ab8802cdfcc86a73e668096400f9238e2656c94d6b5eb92232635f890e588a7139f34a991399f0268dff9cbbc359140566b0fac60bb57116af211b2b7f47075aa622ed7976600a863431aad9dd8b1004be982bae80094c4d33f43deae063e5eabdf929f4cbc713031c95a6de3eca5022e2f3bc56ea3057a289f737ec6ba71deae92b79c4b95e41d66160295f60864b597a6aa973fa278f3fe5482332b55d6926a62ce6ef84db7d8a5634235e877b2d9cc94ff7b0b2b2bee7edba223f6d3b6646ddce47698c1370169b4a2bd541c48e70f7ed27e7ac3b9b2015b901df7a7afe5c7ad1e5ea3c0f7dc2f944248898cd8f01dc6a074ff607b747b599073573825cf74727e6bbfac4169f1b4fa8daae6468c5e58eac393f7f959d12d69b5033f73474f457fd33b54ac4b91b53c530b78adff1203af03baf0b0e2350be5be4fc5a459f6c61c6e62c185c58b08309a305d2b16154d71a5442cf4131d325ec71985edafb4e92444abd6e747873c3a0b0c271deb36798f8ae168e24f930908a577842ada11e7ea516a9c80578ff6207c75f5cda749261e1f0ff440d26555f125be6a839f5799f8919697a8181e818120a71be3b73bf1deabb9c9988655c6bc1428fd265fd593f1b7d26276091e1f623700641afda9769cdf2ae978f045a8bf087ad14e19ed138f9d92cac168a17d0a79c66c0df712b5939f8f10d18822635418c40d16ac267a844b5bd2a70e0c042d307b05885f2563021b44dc614f3570ce4f235da964cf5ba8d05f007f43b5073ac557ab92608508b192f7ba6fe0798cba6a8f3526c3502bbe282fa7e54004f59e4182d66b51af03e5212a3833416f35903a417f0c26dfedc9f273aca8c82ea8153a014f580bf35596b2fd1e2cd50b05a19d6301f69e8765e895f3ae77d977a9e92f1a010cd62ab5ed0c39c0bf4a214319cd8483af9ce63d7375de7aa13e0c43c53639ec8c97e4892d2f170b98f400867df877631474726f4bd1c7613f2e1c1553636cca39e71b662074a43fcca244fba1f0dd64ded2af856272a766b38f4cb10da8235af1f9f3ce782dd6e4a5f19fe5593e7a9e94ba41ec4433ab898b51a4e5f8390fe70e79a7ab3ecc858feb8389d0b14a072fd40c143fa3052f5f7d4aed48bd6bd0d789dd456ed342bb0c030309536361e337046f63051df43a3a47afce9e3571d89702cd0779c339d9a8fd2b2a81ec0739f1b2cdfd9dc536f3b1d05e5398f22f44675ee5bb41820889bebfebfc07a8b7f32a34fecf38b9215f14868826b0749e8f889361b44dd0e676605eaec598063f45b8f3418067728da36433f81457a08712268fadf6066cd4daaf78b20d7f6cfa981f6616db98873b76d49807cf00af8e6070847724cbc1cfc5c4976cbd036d138fbfa97b59cef9456d902c2b3fbf4b9671a815544669429e122dec3004be0c6d1600183a34035299c57d82af42b6f44708d1d818919a3415027dfcefc33ceda3be82676b68b12c5e9492b466abbed6b31ecae2dea3ab8c80056754beb6950fcef328da09a01d6718ebfc5f8db78e5fe15610d474482e85bbdb257beb0ba0b2b581c4290ed2ab8d8430ebcf8408f62b9156f141ae21462ffdcd0bdc5c162b6ebd0a608fd38871678ea901df7b62ab9b12fd3e077045f0d45b0e5124fb30fce3810ccfd7ec615f50b022deb4fe1c10a13f10ae1e8689d8a5a6d2678c8bbc4b79c19c91458fdf56fe4c32fa60738fe21bc8ffc0712184dbd208e5ca6a90da84547ffee0c5be34ba34bf7ff33451ab3159426b9dbd93be6d37579025335c914b0b44081363a922bb7c1a823997072d735bd77c1aed924db86f5264501602eda98cab048dcc2172dc5a7368d77f771e9aadcc41ee7e042bfdbde120b0aa26d63d43c727f143aa691677fb58d228c3b722e414aa192ffd9f2426a1fdbc0fd00c447df45d4dae1d4d47bdeb2c9f1c3fc8e72047ddffb672284afbbd22d56fae31c0f9c481bd5a1195060d0430568d59f567f4818be2fdc09168d5e07b8be69b7dc8c7c8eed69c39238c8600ac9398309cab19c9abe2ffa2a8cb68b601c6cc533e233880e29af3485d76423cb2d6d5e27b9e47f5ba8e1bf1d51cf3b70ea70051f574dc3a5bfcb9de14b3100441aa0aacd38e964fc9abdfa0d80703d08a80924536f9a8629debbbd2f6ca2e9a25ca67340d9b8c075e58d692267d0fb9e8ca0d8076a54886e0f3f2b8136413eddf21ecd8516d025efaea9639b333891ac3ce471c32d07259302537c357a1c4d6b60db5ad7de0decd595a51db30865a7c4c732340375df29edc730655a356cfcb799e77690cbf33daa7b990c759150056fa75346c58de403d5af66e048fc86fb4ed2cda8cef9baff2a4fea5cb73894aa66dd7e48f22f0e9d1c7ae26241a5a88d5f855ebd5a555c62942690dde4d0506ae6a4d6a859d7a13b60cbc3cefd3ba172313f55dec1e7b0e5b3a7ab17c0207c69f00388d83d2f255402f88c5928383357a9ae5906bffb1d7a66f5ec102c0f3baaad847658bfadc951550b76dee485cb53687840faaf0e39641cce22416973aa40f443638dc31e43c0d3b3c1e4ca62b85724a8a0e570fcfa210fe5902bc5bf9016d320c379773a5a0cf62d0854ebb05def0ce8bedf0dccbd028e1232d2b0efab312883958811eae56cd4d821c10d09a049f1fd20e3723807e53fbdc2bc005d4d11b1f6bf35ac6036b5a3855dd1ef4697e402322affa7c01edf460cd33a24e84e527e9f08293d4e695aff4b0919b080cd1bd9ffc05d4223f41613d2e1b153e918d082b1fa57826f1518d1612cbcdf13e1df9a9fcfe4da0f1d2cbe4940b088846c41cc630077b124af490c10947e90a5a894c21cda19ad7401fce4ebe822e4fdb93dc8a2f560af1d4765506451153b3dc4bb9e4c588a4aa9be6b7cadd38791692872f30328f3db668471e1211eee40a642daa98dc7b505b44d36c246d1720a6efc963a0fc9e5da0596394badf5317cae2b5ef9615907fbcb968dce0fad44985c57b0b784f0151a2427dec10d3001c88173104168db8bda9ad1592f796ecf4972273658b1cf9130ae64fcffe136649dbd297d8807724ca0bdf49b00925d7462ca09f45afdf5845cf1b1d3d4d8d46b9592144e4235371251a8448259ea7843d63fbd5fc0f6559d757cf7a5ff5d32698ea3ce1e6ac00ed46afa83725f5ff485eb24a7647b489e4ddd9651b4cd52d81347bb55d6233ae64fdfb4e7dfb84eedbfedf21fc5d3b0c36af35e2317f91398da00171840d31962c523f735f11211380e31d62e7139f62129de71f94c864435a805c7046831098ac9064e464c0789d18ec1db552ecefba5baada767ee20f4d4c08ee9b599d003b47eb25376116662504216672ccf7f5abafa461e6106758f273e6007d5dab23e754badb2fb55aba62f75c4157c3988773831fb0bd3378d924dc92568f58eb4b7967f3efdb2c478137011e224cccde634b1293508439ca92ba47470a1db2e2cb15884b116de7f84beb370e8bdc74584c43819c1b654a2172e242eb93019cbdb96eb64eac6a0bdaad6121341574b80a81b69380e43669cda346e2fca0d1fbb6c88943bee7d5fff7481bd0a890d66e69cf8470b0d527aaa72aa24415a69a889081c5b2e6b09a346f99784fd7a3ded59b857c781ebf0854f73619da6fe65e0f700824f0bf9cb76c22bf0547dab5166916e33760b365621a9162056ce5f25f809dad3fabd58e0a1dcffc722c36e13c371bd6d2607e70b3226d782d69b3534271a02df02b35c5f2f11ef2c2668249912e540f41df873cb57e761fbe3549f10b915a968328ee022678755cbdba0803109ff82707de301b8d10bcddf8c0b540b509d8f62eb55d970b347ec837fcc0fc2041619f286d14334d26f7ba771e34e06ca32b75648077ef7690327c88b759ae27d0630b22c1161ec87a48698d0616de17b433ce4dc80499f89d52ab903ea7c47a506f8edc877403c251997032009f3b6ef902c70cabb08459074c763e6fc0bd90c30cbba168d8cefd57ac1cffc23037bef80f4d95488f23b65247a15a271aa7235a6a1cc4df43c864a00dad9c5288e64c65c0d43bf783d34dc6b0fd9ec02ec01b096d92b862d1bf044ed111c1749ae77b3c5c818968c282291e0ed99e28258de4a790acc789cabcca0c1d34757b14ace49829b212dc27435827ae908c50d3608c5fba3550ef298c0868cac6cea378e3027818ab598318f734be33ac242c4e19cf0f30634516eb765daacc9346505195c7bdfc6c6e510463b01dbb34235d71fd13f4d292a05955e3ebd891b978df62492b0eeec48baa718d7ced6604f13b7779ce27eec160960e9f31e6051157f5f2ec53c5d1bb5ceccecebec7cdec7483780e273a2bcd6a2417f9f6a04945a02098357cc28ba8d75fc67c3c7b1b1ee4436d4746f11d9a31cde8c2392d30cd74a57a01860f69af374ca10b63b8d6fddab2a0d2611bd36555b2477a6b01a6534f2cbb8af87f1646bd366bbe5b797c95577b4496b7f303ae42b3d477121c3b77ef12ed47ec2c28d42358f26385c599f237cc0c148bbf65392f1eef2accfa1869e45cd28f068f77b230296d05d4ffe6caa40113e54c90d3192646723513f9f45e167c1718d008ae60dc117d96d41b44f0924672346e0e6f97c94644597e799db9ad110a4815c64735a3f2a7e13f5ab231f6405b23c0460a3f8ec7a848eaeee22d60856b3f73b10394b50a1c870f8e66c28323e58764ca3d1f660aec1f022cc191ba7ab5c307c170d3938aa166f97c16c9cf1dfa00dd8327f16ebfe11cba6f0c5f518f94dba36165701ffeceed835fa67677233a74fb1af212311718f6d917cc9b19d8db869c63a3949d9de8fe1e01a91e3a2fde0d9f1c5fa70dffba4330a6871a06f4fb4c46a0873e49d8527a70a456798a19c8d127d28db3496a26d21f707ff4651f2c245195cb82b5df4fb52abe948663417e02bc542a59eafb4c1f9be638ae308337861881b14efa87e3441baa7020ef662a45d8ceaab658fc3cd95fe3fa7c9ec3989f64c3ce17bd219f54151965caf9c8763709080166171737796918583c543ef61382636a4b89b03833678a68ab2326d19851eaec071bb02c3e8944aeae5ce07ad93d81cfeef4f3f4a132da94938ebee37cc7346c829d7b0e9a4f252fa3c9087ce4ba6f05e7dcfabde1fbdf1ea01ba849c3ce24f35a54f7cb10d691839590312a7c3e2e856600709150d821525f88f16f130e9020d4f8d8d913dd540caf98e3616da290b067b4e7b3615c9715081236c953638eec245eae4199d42d8b46d557c587c3ee0b180b7ac68556533b282f59a9ac714be1c054c1d27371eec1aecfdeaab66b03c9048be1b9e7e082e7800fc29f4d6eb138cd97c187b17a48001bd44faefe9ae9dc2a0f838d382974adc2b0dfb39d43817d0f35a1beb7f92cdfa3608b9e6d56a081aca846087738a31ea474abbba618fd77b6700c21eb7b7a80917db0ce66ac21a4b2587cb70240aabf38c926acf97cbddf26ff9d77c6a466d7e9d85878a49d3d29ccc24d889c42ddff8b4c168867aebc0b1806722cd695159e9990b35a7251a7b6177d8945c8175e837fb5358241d6c2abc5064904646ac76e9b1670056dd1fa7ed62810a10070fcc04bcd0d580b2cd088190b52e31360a6483eda1257effeb00e9cb4bc11afdc8c2a6864e4cae519b9ba8a94f0dde86902a579eb99e8c5409d2152c5f6ebbbb333cd01c756b40800830bc0f6156ef695c5b9c6238686d40332326e60f261dd56c8cfcc55e6ed8eb80f1bf04a59cb810c8967e5c4dd8164a2ee5f1681118b7c065f592ba02ff65a0f4cbf112c5b19c4589c09d3ba6b8578afc6607ad93e821a4870e4c1f82ac82ce63daf8580a25c6a9dbcc4d9964fefab377f08ac1dfdd632c36ff00c3f3dbe73deefefd39a8515d4da8e98f7618a83e3e186b04d300ca0d682729801f587fa4ffb3c16d6bd73d0078a74b925efb62587b425b99c1b99cee82bd2bd2ae1051f760a8252dbc60197135e9b23dd68fa367c7bee4ca6d12652a4797b63d6d07130fc7b132ec54d82332bc8d59dd77d830c4d7ee1ab4d983d781225e3019ec4870c71350855266d5ce7647de772a410b52608029f7ac36afeaefc866527f14c58eea004aa1b352145638c93885b465f932da07cb2db4323060a38a8124b568ec8ac3578d54f3c35c6aa11fce3b5dd70f1c8ad3654683edf9fbfcefa89b9563bc84a6ef41f8e35c43515d66f83abe8a1290eb58aef5c061f070df2144d158fb888029d417d2948019735c5ddc250d0d15e5162da7f006cc8418a35def4c9b8732f515482d0fc7066af9e7bdf447d3bc8ae32befc4813e7f59c2d1a3757700bf3f1b446d4cfcff390dee0210c5ca156def9cd367f19efbedfcfebd684d3f55ecee8902ffd8d31ed92a752f0f54bc8ed446b36b87043fd1771dc6e07f79b078531baab045a77113be59bc4ac97d523ae6a4158666dc66a08f98e448902c14413c31c95a698fa36f20032ced559e5732cd25a154a879cd3ce3d829989860b6b85e56d4e7c1d3e6354b7cf26de8d058d30cdffee2b321405d980812858cfbb404b1d498e48adf50821930b54e750ef01e2ba613572c3d3b34e5bdb7e922df78c67915c5c3defb69f7285029d0c4bb723f178c9a198c9ab27441b19329702bb45b127e8b737d23d63677926906265706570758a62a5fdf180ca78f6f5a993d9e0007af6001b2836e5a3cc28d8a3f40a910b0b920cc9a994b1f1e3a1234d4e2fb8e54d64365ca34541fea051577eb13f7bb8aacd1bf3ae2e6ebc4f3af1d51c8dec9cca221ee63bc2dcfdbe7f08da220360eb329da3830737aeb6130a3592358b32d499c340476116f950c4cc06d87cca8511c9bb7ee8d7653e1a17b2df6b2909bf28bb77415978fe900e7f17d7379ec09f12730d303bdcf8eed4de4e9d20bbd2824e72a8ed77b914b338a507df371b60431dcfeca873951b86561eee4822bb7aa7f7ed2952ae24715452dadf57eb544b4a5a529f396ddfd07162908f421f1f657bf64306e8af571e53749171c6c38c876e006459927971f6c0c87329bf039842244c9f57bf08884b2fa2b97247950cd0f8bb27e8f74293e3ff990e3e5de8ca57b83885c9ca1b5baa5f31a8131ee3869437a33a6a72ca311cbcf3c443c87f97ef5d153272ffcbe22b5691d4c79415a9ad35106e804d2ec5223768d8d8f4b4e91b3f40bb3ebb07bfdd9f40b0afc9e5efe3159d2b14343199ba98bd7fe88023d904660549e3dd67708e3f6a85bba83b484a043a84dce9c18d896f477762547d8936a921c954404ac2df20857e8889c9ca97be9563a9611747c234ef799ea69b9aac68758b5bc04ee488ef4262730c8a1442f0fc153a1d53ae299dd55cedea51a2ee3233a81de08c0bb5e9eeaf9243884d68c61802cac8ffbe6452d4049d97e44ce2e773d3a613a61d7b66a4d44608710b477efefbd8ee48da5e7c7d57c07081f07ef165e1b3b4c64f17c73a54221c01e2679af89f03f9192059bd34498498285efd05cae447d40bab3ec193f3e73a4233bf72fc7776917fbed0df7f2c31f47d60d1fc2111f0f43e241b4aec814313202146722afeaa9d9c4cf81826266310f6a2e6391c5821936561360341a4dda15854f311ac1817396dce99f2192e78b5342a294ee2e1096f3320582f9407ae6ac4dfe68478b432724811ffb5f70af66cd0ac1cc3ab75ad02aed5b7360b32632cfce71157138111373c2f5f8c3225b3c17754e2773573ce8a905b55ef4f696a6aa7afaf7dd70f6296b6510750bbf8cf94072a3e9a1eddf50db3d58a938751a3f868e095f658847559e0909f08a7b24bcfc87329d0ac8b3d00b2f54d0193b6188e9997d8a8f0682deaefa6de58d78528ad529d27e090a411153364f12debf9787a4c62c2a714c15254970ec59bb661a2ab2e4cab30207ab0974391d4567b2b9b6f27ee69b8575e9cad26a184f1d8b9258309001b15c7e85be2c8c602ae31e42603e561ee99c2a3eafe04247d1b06a56e166f05a566eefa5f51ec5be18fa606d658ef1a6a25bcf1e9ef95d56d2948c71fc35b84c7665a8fa125ac129ceff0eccfb17a3613c25d6c7cbebc023ae7d94478d10155a0bd45202011b497676fc3ee688428134610e86f5d9990ae5351175c11977ebe127f91aace2c9c2e28bd16f632d11adb38aa8192e5d0439bdda86ecda0f1faf11072e4bd4739104a48ae3027d42fc11315149c29d6e98ecfd3e497522e74b0bbb164dc58284e0a4ee9d029faf7c80d28f5efcc3bb1a50755038ba94592dd104c2f17063db155e1ef8df938d5337cc486a9689ee6ed37b6946ab1bfafce4dd10de8622b60482fa0179da36a9fe14b95ded90fc77cbf92f7259e2c86524583ff28d67e7ce52769aaa1de28ef9289012254d02fa0423fe671d25c565025d4c637e8b330d4eac1a7bfd99212770e3e57ae6e3a2613bab9a79a9e9c3e3843a5d2795f2e38564cada289a45d70a86eddd91f38b94904ba05637152127a1a0c1cc164e03d81bbc2f41f30730425cfaa3d6010592cc01225014483e58bd7448410b15c0f1c780d19dbb04b54d2c8e38a9d4fb9aea2ec927c9ac9821b7f0b9cb2a18c1945929d36d3cc356b098aa38918495edcd71ae47af7dcc635f7f12aa439540421564ed6e7ef6abca5473c4b6531b0085e9629c717fb4900938e60dc11f49b653f273f8ab15341d42ddab89790056109cb26db7b4ee6bcca0b183b09fc1a8bf24bc7230dc9965753b3f59ac0cd46f9ac3baadad1e5850ef372fd46dc4023258ce13914f3c36fb8c1e04057998f66a20ca0ae184071ad9b395266775d5346f773ac41218b6eccaba6ed3786f5d6f13c6a261b195340bbb47e6a595fe68ec2620a83a94abd2fecf54202ccaeff3f7c5ec19c6f9502476e0f4433908cd07954dcfaf16481a876c69cb44b1750d6d259e8c638dcf972c359fec07dd64dc128746e1f437a056527da85cc39926117a341dcb6e04626bf67f02d22cff84df0a659c34b22ce0931d8b2b52cbda9f5939bf24640194ed12fbf49cf5b1a2f4093c9196f15ee4a46ad7b4d6bdba5d516fa5a340ed8da500be5ed399ce44e80071d90970e14dd0b1077594d3d961a0af31cc9cb2e08d444c91931144f3d3d23eeebbfa5cfab0b5cf19fe9abe06eb0564a9e6098a7b896e19561f1d3339596fc6b8602f74e791ae060cc27f9031089fc8da7022a3eebf3addcc4e1a7601d7c6b01d5f659baa78957db4eaf97eb2302ac8c5857e5bb8351bbb2aace301a2c08aa4992df6ad2d7a32b40bd1a332f73fce7d5e436cd7c9ba1d15591eadaf9d4f59b8fbea598ab5f9385e33dffe27ad95811a46a2e5d5f6ba2045626a232a9c1c86ff357d512f796e7a3913a483005d09cf3fef7ae7c68e3156ffc7a14632d2a203fade7fe34ace0cf272e4a9b955332ce568fc494198006d2f9daabca8d7d9b84a91890c769c1b5cd479c858888cac97699ff645b1926247389c6a0100eb15edbb744aa05e044c9ddfa3343dd526ab03b3722e517ae222db33f772072349387cbe7d9d37aa619392f225d603889ec9c099ab96202dbbe8e59b8d57c076b60f8e5b16087b0cfde16247695a996d71e049834a02430c58477699110b0edde90c66c370720dfe5977a5d7bf0aeaf48215517911d24f146d1e2170b9913d3a8091699e240ffe478cdef5b47de8531d5f93ce2a5ebd31ec190fc0bf056ea23eb1d265ca91468dbaf83db6aafdbd0bf632f3648eedc62e18f4c0ddbfea174eeb319879ea94784158e4a257428f46361f1cb1842460edd3bec5bc2ba7cbc13a74692942e51fddf1d2533d5dabfb5f799732674b0a049f13d3ca6398788bb8e81bc13b45a28c0e6150b47b1e5ef17cbe0c2e021381d90db4b7ccb798f06cb2d427e4ac4e3812e6dc377259e8e433a8d6b4036f0be621f14230a7be8e798a68761bff3757e22a951f4102c60e931ad80d03c3c75a2e3c3981324dc4c90801a1b494fcf25bcfb5356dfa8c58ed8703c60ccea9d6282c4e9e39cd316a547c897a02505560fa58ed6ed201f538093e92f4246fecebc89abcb9da1f522064594c494d19001c871ff51febbd18fdad3467cc42b25047d922629e4909da996503ecfcac85f29fcb9f9ff899cfea50bba7e237c45551256384e8bbb047a152585c3b0b1a4024ae29f340568cb709c4ac638ee762adccd2a1670ed1b4cfb78b5962eb7661d983cf571f89c068671241fec0e825b9286cd6a4a4cd45773d821b03398d92b02872730d547a9068627db6cbfc7fd16a8151aa277231fd7ddd7b1badb97dc25078441c957e3e68f807af4921dceadd1f270a1c07ddfdf4314c27b179669f521bbb0539b7753f36126db4f6ff7e7a9110bcb03898b5e080a04f357f9e1da3a2b7d685f1a4f66090988cc9c52698cc36b362dbb8547f5057916922a055a09c98c3e415e298e6ff03eb2dd5f351eb185d0d704d8abce6a59238cad203dc93a99a244fd71fee513471a5539c9b52ebc1b17eb654b6a06d57fa305269b91b27c8596bc34a5fe57d2b4eddaaa17a33e026afc8e9acfa5a70ed344d10e521c72460dfe2386b401ac87b9258bcf59865935bc67d0b472d57d45cab6d28c25e1d24e6aa73b7eb6ea2ca58ca158eca2abe712f3c583f01ae91dc5ba4f8802046ff828a4544b73fd5a3b4acfa09e81de6c63c69c4d10e7b0bde0a62a3a774f6a942ee068dca2126c7bac6b5fe37070081b5f3285c11e40af1f36e725a83395cc7a6ccd97f9bb56cbbdb7e5513cc4dad843c5fe78d60131b825907d4be03fb047ae260a6a4cd9b865495d79404c4355f54cfe384d78ae06f7ec94d17f34269554548c7e760ec803611ba690d6569aba1d91aac7796ea73b929948db14c457cedeff58c6a18843281951cd4b13b4781126ab8bffff4331245e9ece7eab03aaa7e345ae4c5ac109e0705e9682eda9c1d7c25eee5809f4c62ea2ec68dd30477226e6cdd5803203da885eb12730e4eb9b201ae1d3691bbf53b0952e24518b116e3487e32ed95d70015a88ec92a2640f19a61d7cc53d40a469c61875db6dc8ebdbf8a24c4878b7592e3ab795c40d596cd4e4d4355b3db441709dbbdd28eea0febedc14df01a3d4e0d3cb186bd2e0a975061d926dfde301f2c339a8fcba5556a6d81cd7b0d7170e2a7417c2d10f9dfce2f1fcecc04435a9639aa4cdc7caaa42d481c0508a13159e6cc02bdf9f35c24b5ef0728962ab8fa5740200c664aef1136eaceb0d71b0e4f2a48ddcb8ee222d9fc6781465ffe0f63c4d4098c0091b2068caff4891d6c6381bbed86544fb167abf01ad06afbdd46ef9e124a43786df9f814687d627fa1b5f06d869eec493ed06d87c4e68f9ce33996dd464c9a6fccaacff49ae8b31dac3134a70ae5ce4b4772415bfa810046177fa20e6f9e5a899b92a97d0f66bd055bd3a268371c9a822da4e7dc147d456606cbcd6a774c91abafb9e93f75e43e7e02de6e350b3569f97b7ee2a4b273b495c1fbc89e8871e71d954db0df05a94e42e024207daa77135ff33d2844131fb94424f2a0bdb85209cc5caa038e2af3eb04ba9be6e4f53cc77256aeac564842d3d29feddfbaeaecb100ece9ef0e1da88e360f1dc4eda165ab883c0fab45a79fc659ff59ea64a5432f7b7851ba7f72ca20d02c9d7fc76aca04eb840bbb78f6e00e195fa9288643ca43361d7a605ec4fe17a8e225d91ad1aa373d549a83462448b34f22fb19a768a01a166ec7507c4950489220825f0b7a340414f4f8827e72b457f1b2074af2eb6e4251b74b3c6f4c22a581ec74b822ba2cd105a415ba6759f9d6345f3340a5545784563b02ee94562c3589ee6e085316c84dd06558f536fc563de0a6bd085753af3eb6bffa05ba83ab7d0bea40d31de74caeae98fdd6183b1ac54fe99120295d69a68f490e16da8da83bd83bbab3541b6670da5477f5f8e95cdefc43bd7340143b1a1e1067a91409da6109136c97a71fff8944953a2ba00aa387b5210a79ba829a4b095222b88c06d5c9046b15058085e42f54a5cb8f1de008ff0413ed28c2becd0804a8b09a77ef8655419392361a8b7fe2400851a565dbcc5267bad9befe181926e13a259779940a07f72410447a8be04c47c527724fb18cf56d9e09a732d3692585818a5a08e0afe6120da2b043b3b2e9d8baa5dbe47699021d77213dd5196dc4168074786fbf6e35de68f650561a2bdf8072227897625b2de9497feb259efd102718a498760c22a4bc7a8a92ad3960630def9720f0a9ed777e2d884fff86daece63257b22ebea3d7376f88ca9bad97eb1ee1d6c5d49e22665bb77a3a8cf0e2e4c800883b18f1a7d3bf98a47b905ddb152225b8d95e5036fb8bb488315ed43aa41374d953136e8fa233374db07c8eda570a58dbeb14f5db1d539d1f638e996fb92577c2b0e11b2056a70c085b5b7d804a5d1d058f9117647dc449c45df94cfc134fe3fbfa3212d1c228e7fde5b8495c9e1109517f02d1a9911dca7955be189cf257036c76d34b6e87b56ea876f6ab14faa49b22649e0b8adcfba104cd1aea6650427bda055993aeddb4438933c903874d107e27a239c7e0c2c01126148e7beb454ebe0d6fe9cc85fdf66cc86b186e1c5ace3d1c7c70c7ae8e474850690ed373d20e7be27737f40eb748bfee2e6a7377bf595d36ddc5339fded673ec875081c79a69f9c59ada54252851b01b0f0b5a545169afeacd1a17e7d7bee39425cac014c5f326149afa94c1ece63806c261b670163c9f2d40e4b3a4e023856128c9b42aedca179284027e048513590baef3c74c7b688b8117e5983eda53e9acb6abc0f0717a7ad1660ec6870282d5eb47adc6fec65cb3157f3ccd5e9e467932b11c2b2f918be05d52cc7261ef21651531e8d91f547b895ec9d3ca065faf51e8de2ad9c7505d5899344bd5cbd481fc63d5e23d7651b6f6ed24a236ad79a49dbea55d61fc5c89d62bcb92f073099ed405e741804c10379f613c82d35fbf65d2e8240931631ce4db1ef53c4039b131efc94ff08f3d5cb6b938cfff96e1b2b782e8961360a33c920e2382a916b0a821553b2fe6f75ec9a1a72c3334acc4465fa84f1ad9159cd14f711fb0133465822a81c06326c4f28749ca251c0052afee5d871d80078346f5c6ed56ada64c1754243ee639f17c5ab97e6e7bbab5c732879abf591279d4042608071cacad4f3b9fd15274908464e4fb0b8658fe049c6a4735d350cbb95da596f7901e9a215e018f435ee5d64bfcec316201f5defb1b8eb36162f314dff16861981ea2b4e59333300b50f170b2a02aaf64ddc357be0eadc673ac6777ba783c194c946752c0fed484817b86c19667c1791b0c03cbac84f5abe33d39d31fb811f4fcd003ed0cc95e38ea49e140a3081ada73fe29cc01329873ec33bc931ab9540a5afa452cd171e09956dad842402000a2fe84c8aa718dbbd485aca336a2ee8804827f270c28f7036a05f216d93f522330ca085fe9c41d5ec7d864160ad773a1f15fcb61117c2de6ad862f073462e8bbd10a187a3d8d3eae86d4fed7d0a2e9d3324c46c086aadd0899847683688e312485dec213f5c1a984f0c55d87e797d93422c03845720c057bcea0b0831e091377ca45b4418cfcffeeb431da523de16910c97d63d419160f58bd699220fe60bb51a3051dedc88bc301ead8ee7b4b5f16d75201712db172f33bd7adc3877e880e9f080f375ec47d5ca73875fb757df1c237ba12e4ff54265c4075dd134650b4c1922a341524be4d26b54ff37aacbaaad96511a4c94d1480d1ad85fa485a7c60b65ea232e6dce7b1364618ea31afaf814837297c8a9143f6cffaf3d1d6947dcdad7bcf0514dc07017f7efc74e6b5f03a22d915165fe796833f2af14ba7895fc870d28804a2c946c8cf2b4fdeeff2fbfdfed147378b48ef4281663e4fd9495979468d59fc9b5b045443f494ff587d390c38e7444a1ea53fcfa6be1780363b53e1c2598f06710abd87baa3574399ff27c2c8f1c5278675d5f6bc24de9b8a5390f62ae0d07cb80b4e452ab7916e822a8ddc5a857e64db5539d7cee3fce3255a433f2e97d8d8f109c3ea5c32fbbe3b066343d498ad42c0f1fb5145136ae169c81de4b09ca4dad30e065d76dd9cb99e170199fa958b912791b12d89abdd6aca91f03a8eeb056a785a8380f3c45aab56160eeee3bacb960cf3268fa7f09f5916673942ea381792108fcb3203b52865b26c0d247beeab748dbd4b18398445917bcf078ad8f81aa5d6a5d3ee7f38d83d519e0136b19fc1111d8d3ab419ff6995539269c30d7bdffc0f615df51d2933d6326d5f96be9967f9d63ab61dbe16683b2f19e1c1ec174f15e6d252e656d26ae15ec5790fc47afc57e9aa573762fc2da36bdc5608c13f62fba5bdf08563cdf960f383b25a9fd718d0069f59b9551f714d96ba40ed76fbbc1687b51c29793461fded59683c99083ee87a66b3da27f88fa5ee4b24d0a86c8dca01b9726e34666dd13020decd92d45d20bf3472d8332a95b479d2df1c7a66dc5cfa90769bc6354e837a7a2e210ca4a152555af7939bc455332b5935b598defe6c181b1e3588e6296a33630c08f9962bc9cd575338dec81ba8d220ed93ebdde270aa1f14e6c4dee59a869c1d64a588bf12d58f754ed0c4812f954206aca1ee0da73ab321f5a72c4044596b677fa1d71a481009a9c7d3b1c808e1700c78338b3e36a510067973ff8cb256440bc7f940666446cd4e477df33c7fafac48e201563fd7bd6356f1078ee37b31156d6b0308c0baa0ac50ed420c9a5a824c9538394d1a137abfa7b2ee7d8284378199678b3b9985bdfb7e9e191d31ff1f9f4773002d6678b5b8f9e11a66a081aced7d9ff9dcfd71bfe99e93f82094079ba89630d69421e542f473cf80435992fc297ee774913007726bdeea16f3bb4d9849ac57dec417145c3356b05321fa7b5b93007f9c100f7c3e2a6bb5d1a0746c7a9ae2c60f4a131ec40973d021786ef8f47d0cde4e0e078b549c12f4e356773eb46df5fc3733387e952bc177b0d59bd74073dda2b17c3e57a9982260552d1e2a971c4ddb0800c24269c3bbb23616ea15167641a68f16c16020ac9b236c5b8a355f38fb1ddc999ad38b15c92a78415291c64f6a915bf50c06d479789ab5290ef393f2118bddfbc7411382a4c8ba00032278ebb56410be2d0f7e1c17413e5fefd9f345ae917f02ec1344561f29eda6326a54e998ce0000de65a39defbe6bbffde1b9202aa0174f17e03c5afb6d8e2a6ab470d5b644c1fb80b61bfa1462bd3596a89a3afecfde0b416c069e62c648ca772b90585f8769e65fe351758123475b2fcda9181450128bc330e7ae584ff8ee19dbf0b7a2a0d2f8c2d74580b5d35f1eb00cc3317cf38ffeada0ab054a985ec8bdf5da5ec2048b69f5b9fb22ff9df0edd9c996a1d388a10d3e278b612618a6999d0fd3557854e8acabac1a91fd854be5af5bc8ff66a22b36740928668b8103ad5a8b939ea841e8665403959508d5bd096946914dd151e79d5783647d663fca55197a71a1e5ce9cf6e72cdd086ad6104f75c0bb6191add3b9c4f3b9bf1165d9c3580cefc2f3dab72dc972d475cb219c271f6f63fdbbb226d664951fc8f325775328e98eb6310c763586a09f82a61aa69e57aab9c8fb527f67ae8692090f64dd502b6d50f1408c5d224998e60e77a59eb8aa406fa18ca8e642ff87c34523dc718d16c2b5224a1dad3f1399f168346c670cce253d3046965eea109e21b06133e10b2277236ce0d3571adf698d82863a6882b12794649720264e96c00168554e59991d67582c9e69832399c20baa0a72de6dfe4f441649dbffaa0e0c1e723dcb58cca55580b02e0ec148876e5cde07e3f8d181bacb5a7bdcbee3be25e72943a6f7c00de9b902388c7d2f837a9ed8a54359cb05ad518059f5f0a7dc52c3744bca91ec473a9fa304a3795323d7da4a9978603a6469f2263257fe5e6b62f3ada49559852974ca98da5902e5d2393343552a3909ef9a67259055977dfa6e528994b2df559eeaaaca33ea49f7ee947e56fbc10f8d206f94a58507b5e6d69de86a3f1dcd67ec9a994ce7faaa3b76d2f655747ceefc6841271b89093602e827d3d86f7b8bbd4b4d3bf857340640eb4da5a25d910aa747f70d0f74ce90b4e6f83f87c5c82c26a7e48b2127211d69e6a140d0ac47f216e37880b35dcf6f592f53994b22d46225ac13d071ba58b6cec72f294cb1f12a68ec77c66d5e4d1bf0d8f6536af91c02a275382f407212fdde4ae651e44973721ce6d6af6bd737f7c41913f849f3ef3f9e5449f36684a7eec5445730ee0593ee3db22b0d88d6039b521379d8326f5d19aede8cc428632c00aeba773b64c21535c036a368f4c86f58d56b7971f36304f0aa75a598b35816ca116996f7f863da420276bb9d5cd4fc57e0a53f021bb79252136c4a117296a5c4ed75976ab8260df0da8519a44525d657f80734ed295b4c4755e10f0faea93e941ae073be86cf0f8bc90b2f3f1c50458246bd93451d43632fa3d1dcab6c5b013c7486d2ed12411f417ae05184da81a8f5b9f892157c3be3902a8fe8b8cc2722bfff8c258275128a366c95565c91eab53bd9269c581ac924f629c2188da23b23f716892d30f327d65d51d111c7ee64942f1232074ac04424c180d4a1a088c0b88b95ea4fa35ff7efa11edccdeb380c84eef040ccd3fd50eea821482b1e0aad8645dc123db961548ed8e5baf94369bc035d6b1eb42b8e059ab73783150df35370e7bff2d975ddfcb1193afcb5f918a5de2733e5ff9f92b81ad1bb264df10e2580c269b81e8fe6837bcc7d51f733a5e7ea96b3f9962bf57f406158e3ce3344c34300cd7e94fe03907fa68b17ebdc02895b10681364f61981d3419e64ae45b1c5a7441b8ff2410230b1432d2d784232d9cafdb4b3445e0e264d85f5e34a1077c8e0c89554bdd41063367af3286cc51ed7b95423630920a2cfc556e167e7f1c145db2078a2315d3a4adb84aa9d239b07e7312e6fcb42bc62536e7c71db81dc17c8897f093464e8c4fd28d75fa6290282654ddeae3c9949d563013c9e90085ef0325979e166d0d8c0a7303c773c704ccc777d27ea02e27caebe5f5ce40a45e313e0ccdfeb166b9c17bc8e504888d51eda3e2e306c845aae2b3a92c203fa764350f85dba7a8efddd88d2e48b141867e63061d4728835719071cd7004fed0e114f329f3c26b0191a63413708ceebfc7628868b62f7bbb6b841e98d3b0d56103383468eef768c692ffcd784eef9b81cb2e04f6bfa041f86c74bf752868bdc524b1b5bf06d3992f3b346f6fa1252ef988eddee200d147dbcf4c904eb46e45dd7ef66ac6d23af2b189031f6171cf3f528c59d3578e5a6832e39074a872d14e26e665a9510a97d74c3d8072350cf3de9c5b4413d43fb27f1c40f3ffd228388f795abe9bd217e9c44e6e71d5ebc0602486c47aed89044007ff3e7b76bbcbed8eac1cf08b0c71a66e87c7f37a17cab0027bb429b03bd4b05b5996584f6ce02cfd4b6da0165ca18ed9b6b63beb6f78c84518ad492091f7c6aa146ea194c13a4aa45050f291182ea39bbbb884d367437afa061b1b6b28b39b3d27bbb88ecacc7b88715e508334fca659563d62a6671fc7492a3186d5debfa10226c8af5e9cae385956ee87d54e60d8a048c95d7756569fbb6a3c9509d734549e6eb11b34388428831a42e0c0299e733d936580c4a91a17d5c35e93dd3c09917ff2058812a17974fc191191ee3c3c93a17f8e857a1fb7d73b48585c88fd699dd5c9523ddc6a37761206ee01310d5785a1ad160167cf596f0c42fb324ddf372eee90848c7e29a46d5fac9c27e7c5f595f1cabb22119b17029189356edfb023b5f5c3049de2bc4da7a7af727396c68f288be121757232906fe5988a48dde78f443204647c23eee3e0afa03a724ffcd0c1797dea98542ec9db5e8f46334c11561c12a055a9b34b3cc38266d96f47e9967d112184f6f95a7bee1747487122e6051a665ff886e7cacd00f10a257165a1059bf03ce8d96381aa0e3a6c469038435678222ef6a5d02acbcc4ddcbf45b912767e4c1171f76c3118708d8132b007e1133e3b63c6e0a1fc6276b289b7d2863d271185b543dcc6ac63954f84d51025c126c8872d1843f090cdbdc61f21d2e8d1a3bf114816f6af379cc0654c44b93efb528e37a58530d665e8eee3ac1d7cc7d23aa39955978f4fdfe26a6fc45be30303f45be529d0b9d9038571e375a9f65fd90753e1e547fbfd045aef51cff22343352f80c89ebc3e00416b4fea75552ceaca70b3ba9017a8677590089ac8adf8ea6a9708ce7ab4c38860d265ef98cbcfac60bc704a15722d560b463257e04e06fae5cf5aaebe673fa7ef283a8304b875f774fd9f2916fb99328303b15081c64c044cf5c1d94d5089be55cba948e8e6180fb8d7525797f606cbc02354196ba7171d4e3aa27d0508e78f82f3e831fde58108e5131ab309cdb969ac4b001329c09fcc3523ad6a7c744860231002893ba7c2704afd9ed24903f4ffcb1534fb01599dfd556167062bf49cdb0a033a78f0188120b9ae6d470f5522d59c7ddaf62b7a160590621bc49fc531ae86b71193ccc2866d0a50c52d5619545a9c1b6fc6521e6d8647f19e614e285055b78c5e6b120efbd3c4f81390925874194bf886e22246dfa1ecc85f13a5b3881db9272f15b907245b37e2394a2195d60c541d481c070b25eb3a7751d92c3c14e5a853ae4309e4d23d299df13f06f0f1688acbd877153a2ee08b225d338ddf84d4871f194dd1df0f4e08dace9d501c4ba84073d88b9f0ea261be5dbe85793864c39ccfe40beaeadee9536f53d9bac77f71272eb5ebdce3bb564e68f52509db0af0a6050837260c3c102db23fefc23c612b073729a192e9477e50a293ca54c8491a928cf0d88cf1666c06dbd6579061deea8df6e468342a27c40571d97166b61549fa74bb589aae9ffddfafeb4127f8501d98d7e0ab5b7a701fb1cdd13e7a8c0eb6c8548bb569aabf607b8e215cd11e125607eb0efbc3239bb03ef1a041bfc77bb6dc99a174c9dba3dd47a94d5eee76697482057463c56a4cf793c30f11f83a3a5dfaf9f8d88cac3e963102112f1769031d5634e4e8826b55851e9d114a4f7e17dd7e3d48598fb864e6b84e7bd323197c2cdc449aa6daa2cf0a643af928ce008480f7555f5745cdf80f5dc5643d733e7ec09b917bedb638b01703c05a0c2961cad08d97712c47fe7b1fe42baaef77f1b0b2cdd41763ad956a78b59e4304e499495cb6a14999df5397e8883029e756dc1494dc1c69c223afd3b93b09ebaf337f43f3010d69dc4add90665f19efd004285843069efe7d32397067c69e0a072eb3088ca90fcc52ebf4bc8cc563a31c78641d78f3a158a958c49edad99769b7ebfcc6334dfcf61768b4e2a5faa950749611b9a48309e9af4991bb1edc69ea87276c12304ba649066f861a78890aa2049eedb08884c3bdab58be1f8873a11d1f6bf6c7c7539cee28e75632c3bd48a1c58243f54cd5215eb64a2017d74e92612b0899002706e250c74124a22ebbe785e38c6f29b558cfcff25611b0171b15f98c1b3c473b4669bd2cac3c1d2b9daa1ab0585d62351afb5515813b2e6aff24c3e9910dd451498cc549234172d4fc9312af94f628814959b017119ef23bc0936b5f444a9c143bd7fba6a5cb29e830b7c431a7ccdff23acaa7ecb5fca8f48012b69cec644a3b45be175312874c7e6d78475212384e56ed29c64c6f875129d41f340b52913a2876123c644bb3b36c8c484f2bc2c7900f887a575d0b764f1f89eba4ee999192d064bd749b11b8bc7b437e8dbbad78f70440f62aecdbd635e651a11882c163891d1730667232492aea441a352868c3eec8c35a8166296be14cb6245aa5bfa543ff101c13b0519d3a6f37a9b1ef0935958633be2dc3884dbca0429d3afb25060128c7d4caf4427352e893c947908f7715ae6eebd336bd0d7cf38684f523104b919a79e5ae3253f89a612cab4e938245c47188ae3bad153844ff5b995506caee14fbcc4551197f6dc8e08ece2cce54d15c4a91b1d8986d5c48ba9ea69d6b3371b10c4a99b52b6b9e8e9eb65f57e48727e23c5796ba18e5877932f72cb961bd0cd96f4d13e6fc28eff2dcaed61946af08ac952001fa387ea4b41e9cbd130214953f524a6b27e9064606bc2b88c68e2e3fd56a956eb798af4697f75da166e870a95a5d32b835f7f54ddaa676117d81ad837b1e4356934a346ffd7dd266a1b7461f6f224a9700abd1688997fe282199b75ae612776cddfe95fc6d1e531fa358ce2fd78824a8be0e3a7a3a4c0848154e6abaa55f365711b0fa1be5a641f42a62674dfb16d1f7d62674f66e5872dbb702138d0d2bebb04d5e1eaeea3aef446026d955ff9b2345ff6e81a67f6dc2d15f0e1a7e2b5d3c792cedca6b93992ae350a2d77e2646c400a9054f9c4b9739df6cd428053c31e227584df6144d6904f1ff67b2e47c1154667a22e445be9ef6c0d952df3db869240fb5820b7964de6a6c228f84630aefa71ba6b75e76718942775cc61bc48f199b4d6f3726e72f5e0a7047ba304a9b4049c0a189a22ff6aafa653fcf24ea26e34c64594c1fb6b044b40bb6039ecb85fbfa0633d8d3f441ef37fb5334ccb124a60bfbe424b5331053bcc522fb7c101d41ee2a0cc4602632542f5c88ac4b4a6a717488ed14bb3e20c9770b268b376309d5a145bc20252ffac4ef9ebc1d2c8449ce42691c8610af69fbb4b28b99c86edc6fa0748643d324fd4fa5b9eb8a225eca75e118d687a6034fdf1e405f1509eba7e6ee6578e7a879f251d863af7bf59df6a75f8508c43e1331fe017438862a68e30fcfc76618e3b05c9dd5ce3f2fdafc009f155ff485e3de0d70332450fa5cc9e60e02ea5aed801408529561cf93641791343acb611b09683d836c7727aef144411d94594a186370218ff272e0c21ec2fc174edcb167ec9c4f82eea90fe0cf3038db40de7e3df118078dbed8d25e31e10d243034d57e477cf5464d5db39d381199910690890128bdf52a4b24b50886c5e047362931fb05567c0651d8fc8a8420e7a93b1387136cc5acdbfe13be843b98ba70b4f0cf1c82691170ad14fd92c838ee01ec3260c41b2421908957e002315a7784112b5cc814d31fe51b31bfa4d8f775aee35987a6f696ea576db73315fbb6803af505901ee5ccb8cabf437d737e623903977d1aefded7a2d080ea4ad797de7e5c66d68cf32ba16ea7fdd221f7eddf228f3ace04218c408e522da07bb9c8cc536b51b5c99999cfe79cbf99241e9a22649d46ebb935d10534565d2eda7340d5b9d7fa23b69185cf642cc6f851d113b3136f2e8c58a9340fe81975bf90e9c40cce9ceb922af81afcc1b81b3032745bdfbee576acf195428ce20a249b4b4b774c0bf1cb0e2b669321e617f27bdc2eb083b7eec8c31f828fd3daf8574f504d55ab14dc5da63ea5779bd57f834992ffc2dae305b6eeb9170f5e73d29cad179aa6d07fe0d81d53db54459287c20ea2c52638758929fb67b5993d0b106f8ffccd83adcca7f7166c90907ff2edd7127283a1363ff612334cf4efc4a736e460cee6b8da8aae79268d03e231176147d49c3e2642e4a09a4cea7655d63f212ce83dec31ff9f7bd31ea50b98ff2ae05dd3b11ccfac6e0961c61cbd05a208ece183476e3762119e05f1b70462d42502e66d298141142be167bc5db045da85ac203716c7511b2a369edb831e3d8645925e03b8b001f9f68afd5d858f9ae136f393ced4423805c54aff6fe640f6e5caf01616c401744d3da2755996bdd8de5927c444444258bce3486501118388fea5d35c54fbdc734de7b1b159493910ce54d8e04c658f9803ded07e3e4b5544fe9a304c684272c46b75e130dc203ad88d30a61b0a58c92652641b20a755d9cbfd9e4cea824af7ecd6fbddb6fa43b42f95d8f9401c51a0f5c05809067a5be297e5c2518234c0ec133079b73fc85f8e84c6afcebdbbac0779ac549c6b13ed45c4dbc7e8a4f22a23ac5ad8b0281b1cf245b1840f123c702a1898f8bc68aea63d7eff33c5d6a8baba898eedc649ddaf58da214cfcb54f2b7bcb38444d477573034e23c2426c8de5f070733a8189db80e4eb17cc669d3d75b24c641de9451a105746fc940a03e84d17e2ad258c21e5ab3874fbce6eaa562ea8b39fbb2a8ca9416b1ba2c06cad678a6b1254f1b2b8c084220a86495c8d00e72d3c9cd0d3806abf09640ad4a7317077fb43b05608d1f96672920cba8544d717c2a807a81bccc430b04fe84278047f43bf839cb4b96c1b99ad99c15a4204531ec8c532a764342882fe51152d74f1553b1c8fb2229158f41cd3ca3560320f124ebffa7e327ec98ed26ac37ee0af36b1563a62a54a3febd2663c551315f552b59b64622df1320ff4ba2c60ce74be53ae36f2a0ad6ba485926fa491b22f4e09278e61a9c5fc19a3f7c3947f18d9317a7ddc6030e241d62d7685473e4a95eff6484985c97da4bcdb038df6bafd592f106242ae868c5e9673ff41cd5cefcca97ee309f57100d459495f9d7ad01ca6a03e6412e336f4bd096139fc0f139d164b0735d340b4c148ed063c5977b8fc7bd393609f41e5426c0a269f64a352c6117bc45a409dc21ef11f19861fc5f49f4bde830391ae869485ff65249ddccf9144539185a3872d377a22484aa6c3f7c9ef66c4bcbcc6ebebe359399472fa08116eae7733ae7be0bd9a3c5f52534bd74aee16de515587e9361b7c8986a09fcc85dab40ba52b3381e979c0ca71272a3401bcaad544dc23caabb307ced6a1b315d215e376b496b8c50800f68d61b59da2582850e8f87b61302b9ca7da492ab5a365c1a46a73b7c17525da4b0ee93387cfe16d2ebe494c8823255b168a794805922083e95f683f6f4981463d6a4b8c2538c3cab3650276c5aff7eadf460e597e0ad0e4356ac78ac7f218b12245d6b06ce4e95ee45c10ce894486fd212a7cc8e3b104490213555f455490de2b6370d0c8144f8474b3ef27cd0c536399d263c1e3fdfbc11ceb26d7ace464259ee16b0523db11acb7abfcd622cf0eb3a69c6e2ceec6bde980bc06ad38d1cd3648dc9cf8ef1bebbb890360235d7ce26446cb23e4ef4760d8aae020e25af51ec178d1ebe84c20290e0f58ce143683bf09123a075f062ed2e984f9adda38f601ecf2144ff4418dc19c34f848278de365168158a98724e4699d5878add74e3d01bf113d4da83098581d9259cabd692aa414168b44c2177136964cee53f982f576012d34aa003e6895daaf824a7e66754e4abdc5862eeeb68d3778f3a4a3fd9aae298fbf29e5eb56c7d9482c2cd5900613071ce8ef81c4badf8770b8b608545e33f4bea26cb96bce26d7e7d683f989bffa6466c7240146ab621bcd2af1b6b8fc795121c5830aaa4a471f5756c0b1f269f2da3c751d46fd288c98e5962119563ab87db8641416f51ea3e5da6e5df7228d8b8f910690ec52cb86e711a39034da6bd5a4063981e9de8081ecf787f9be2aa9c6267002508df6f6725533716cbf733b79c79010c178ab9a6c6e2c3bd2c641b00cd9cf55b43ffb60365c92b1d0a9ce2a8220610479db6456894c116df638e279ee11a6cfa308d6a8e67b7acc9e9737c23b80eb32ddb24e7fd8717d857423a301fbf6ceb5214c2c3049852d52c8bbd7c77e3d4a82e1c14f2adb7bdd115b15179df3a4d41d67520b5c004979fe933a5a0f1b48a64c6564ca4cbb2df0a5edb369a07b242e302bc9c436b24e95d9a186684eec341e9fcbecc88e014798b99a227c1f2c728d0b1ffb02f2c40e7a3d1adea81618ee113e1dde45f5edd7c8342154e24d136950197f9b1df0ef0b17f8e3b199c4813413088833230b57dcbf2e60fed048b1a63802989977b485251c199ed470687a1ad7e30080d6fa7e9252b9ebfb540b1c8b00735b528dcd91b2d42faefcf03f45d2ae62f2d054cda82ea02a49cc2edf93af95e150122a52aadfc20177b3b5505ae9f0ff71659730847d2ee51a12bee65d462af6b2b9566fc0e9e538975b880d8df05effd95aa21a367c37616022f80804c1737c88e16cb3a57e161b23da83910cb2030838c8aef2cfce7dfba19c7fea97a2d2035ee5c86a887b28e143b9707523cbfc6a18a2de027d5499c6b999d382cee1ca75bc80361276ede4d9752f3898123fd3e968d45212a44dae04b8438d1bb5fce93e254eb4e9cbdce1ed3de851bd7175573fc02cc714b3a232ee31d5a51f1de88d511bbfcf6cc7787f37b765fc5e706e2de9f3afddad1fd43bdacc964d9af77f56ce9b81f6866a2aa586a9077ad6499687352025fb40286972aabc40d2048cd7ca1e316f72ba9fb067b3e4aa486f1fb577361b5e07869023136f7c9535c96a57bb4ce65271b20bd0d32ac568360ee38f28e3866350c16106a615417a6782d08a9a4f3c3a48e0663abd3d9345e95057deda3d6d202e28365005e25eca67b7e8d280b77ceafac34ac483b1686287dd8b65648ba39f7ad05048eecea7a398234803c16a1a2f79db885b8cccd2a2f542f267b6b39b75b192b8db6505e7eb6122038cd211bea14049d0e82b05943f1a41f97f00734d8b6ffd06a2d5ec7ba103e727642ce3d96d3419bf07103c0ab53edb18bbd4dafa3ce0b6aebd31e78ec5603f175563e6d9f8cfc4a7f1b3a42904fded770f7941293c1a5b2824cadfac60f9c1344301cbf82a0c6710318bcc4f4ffb3017ad3347c8c326411eb94b5e2703de28752d3aadf24c5f3744efe3cdf5be8d069ee3e2808c2bf6a0f77dfb0172c3bad9546ea01e7a73c28a930f0e3db78689fe85d4e277eb8b0dd89e44f049169d91571b7f457258e09b199eeb8de8b9d9961535695c177af072421ca45e50dea8f66f0df1d8cb7179bf11403963f2df3993b3b222bb605cdacf71352b06ac744c6e97feab5ab03b7c774664a4b3f849d0222e6a30bf0a43b8eda83d441f244f279713c7702b1ced91268a9138c769efcedab89480fe2dc6eb1c0f3cd5f22195ee7194054e0a80d4b90b9971edf9929beeccb5db490965c6ac649c69e4077e7c5d44f678f604b735ec461943114f692ad54e758e92dec9478730175e0821444015f7b1bc2b5128fa5a431f4b1c1039cd3047f2b2d24bfc9d0fedabca7b430116f758d91b37a16e6400f294904cd4de6208100aa5781ce36c6b5530dbd72c902e35a125552a4134995b4182d80c960bccae2be7ba1a551b3b2a05d249a13dab3dfab6e54fdf857cfeb251d032097b6d1eec79796d52f7925f2d392f2860f112106ac3c829abcb76827f0b3d655715b51dc6200ac368d523f48a3b1dbafc1965357750242e0858f93d71f6003f13f73bc1aec64405c16c5bfe66785f4c4dffa07fd50d71e07fa8fbd5291e1a4177d069e97e7ab74d9fee066ac202ffee75ed7c833d56f8f0cbc7010c5dc010b801b3c3e638cb7637a28dcd8e167799eefc01259b40aa62b5d787dce1e6d1d5d2614d6da11916ad047a87641b8e8b2ec03b8bfe6db9fa77c39b6f491708da6d20ad270f41191f51c487c30a6328bf11758b7d0f2061e0a7c61e8d8d85efdd361738c7494b5cf6d70883b3ece5fba5666363c926db4bb3a5f2a50a5fc8e660ccfd480dceeec4341b639a7a2ecdf89ef19d87227a5e797ae84b5a92c82264b1f41730275fbee7d768c46cdce2e3ec202a8401ca877ff233043e70e097dec71449c72f1829a6b5007ef4ca1d33e8a49c6bc16d8f433851327fbe417b1c33808638009e513b563781fdac4bb8b64cd6b2d9ca05bc7c1a13017f3f4831bb63efaffaaa436d6577f0b87687866250d825acda0d6ab9378f056f730525a3c4aaad2975bcab0a1f9c43a77b9da4829202fdbd26b2ab507c066192f7265f9424d7b34bd71f236c0332d015ca014b593e2b961a278afa878c8cf5f2ae22e7400c15dc989d30056f3a32fd134bbfb1d9b41b924281e14ae8d11af8d8e43fb8265a7f0450439fb3e0acdc7f35501fe300357e703918dc474b8c6c179f3e3149f7b3351c03192b1fac29a51d4604845c0b50d94c264a735f2d15b4f1179ffe3d012f8ee3c478f823a0302d9d2b9fd5c69192af136021bdb945c516fbaecdbe160c81fecdf6037a04d03a172c4c2a78f3b1ddb83a98bc5f8e313815fc89979f073ad11e65268711b5b6c9267ab93c4287f443b9c0027d5fca45604a4bb8659b70ed7fe09f5118c97df832ea366904695016f816ee57fb2620ac3c34e772cb1d7b0b579da966dbd516d6345d1ea2d3271ed76326f547e9c81ef13af4b76efc9ec5608490cee01ce054d1461a3a37ebdbff39246453ab4ccdc223af43cfce1811412f84605f56205fd2d851e32e7aa333e1697373d4a446ea27257f14aecd17384c39b9507dbea859445626ac199c2f89ec0c315f372c9f807465b232904c9610f757d037aac773dd0f5af8b6669286600f676d030d78319f79b2a865ed53d7bfd8696b4fda33de77f370f96627ae2d9780a75f7faf638de7b747aff67d86ba42132d83c5b73b9f50b1fcc70a2053799d53e8346adc3eacb26505441cf98ca02694fe801295b09dc0dce929a1536c640d58061edf3c13424fbd5a37d1bd11201998920e101878c68b1d201f5b9cbf516d7377861b3ab8029ec9a994649d043046b6ada26aa01968efcf630eaa03edb293b09103dacccb1d42b4fe5a489bed483da5b162b1a939fcbc3f70727b87355c54bf0376834c46941c91209dadb8a740375f7ff91e86c091d314ba4f7a73de0566d21d758d4a1cd095127deb8692c2b70539685a0740e6ccb4ac99691ebdad627e51abfb88cdc5494953226d4ad76387845bde34ce752c835875636828ea3df51963117b381f1569c6ca6ab8f6e6d1b3f314ca633904bf0b1e46e870d8cbb60262ea645c31f52291b20ff5c8aa5774cea37a222a6c43c10737bee8ff554591a2b0ca53f325c323ee90f157a96fe51ecb65ca6a06e1ed00dfcb674e76d5f7fb6b62712083e0abf5e6ab517fa4067588a3520b82d1352529fafb50007652cd9d6bc0a7e7890a225ba573db5aaae192a90842c063a3b1d15fcee0d79335ec90ad88ae31e5106dfb2af7f4a8ef9d4066f98d55fc59f6288a1f07947647c08d9532bbe5b865bab134f5468c041fb1e11ed6cf43e21ab7cbaf18bf82d5ac7fae49254130018cd5c412f8b27cb4d2fd1a8f5a1768e491509cb5949975f3862611cb114ddda710fd3bcce597192a48a65c3fbeecdfb01704cf4f9d1be9ada314f655492ecce3e4682fb5a950f8af80b749a55f6b9d044380821dc9c625f2130a57f5994565d8f1a0d6187dcd12549f04333269e74ce372664056baca4ade2f3e447bc6a66605ca2d0d60d8884c792b86c1eac45c5a4fa7e0677fce7b8b2a511adab2213b4bce9e96a1e4cc5215837e027ee965344c738c722dbc5673df0367135580ec925213878b4ad0e1228d65d76207cf01b096a45d80ca1c1d60d4c919afd8a5af0ff4b6b9edba773b79410723f097abb2050ea65cd580b6975781b8a5ba4d05aab67f9e94980aa478266353e19cdb3e2a763c097a8ac1a7faedce13b309918aed62ec425aa16138eb5b9a4b46c62ce90bf2b3991d6cad996d1cb23110da06dff5698be0cd262e75b08e59ad70d266ef5825c4413241c0e7d8bd4fc47010d49338c3c3ce3e8386b0f09eeea4f3470d552c8a13de01949dd026e9f7597cb365770371cf79f2fb247b603363b825a7ef295b2a08dce817831988978d72d1a905de892fa54c824ff7a7c362f9d96ff04f53d8f12d182c63c3f3bfb2105d6acd7b83281f8c405145b5e155d7637db5fca2cc50723812f2fbaa3c792931453762dd42ce99aad46ac9bcab3167b8e3ee0d315dd1c3226647773b23bdcec5684943f4c2061f0583c1b0a90e5164d87e818232b6b518aa7d7d9820a2246abcc6936e4f97495a8b30a290ea5139f6d91347e3866fec5d55cadb83430aa281efa7caeb7e2b47686c663260cac738f2cd1542a18d94ddac8adc950c2e4d3114ed6ab82c6e7a1dab4e2d966cba7108700eb9124e5b4a9f8b89f92f9a257e668365a0eb11f91955364d481e04bb21a8ce3ea5b1b27f5d506cb7994e63adf99a2782e3799eaeb951a380fed6b1f2918ceb4046c1a75d578c05f2551aef366b4fab273f51ced13cf8cc318d72dfa9d9de125cbf5e4d334b8ce2c8cc1620605073e4141ddc14f27594337103bda75e0673c7751e13fc592f7b7409a1c571d6f7e909c09b32d328c16238cc48c4a6878d47d265be712c4e61724bdfc43720bac0bb4045b8655b2e3fe1115e6eff375dc663215c50b791218358c9fe4323a3c917883c1dc9d9fdf9e8774dbad45acb8578a23c64a2522182fbc6f59fe71e5c2398059021cc469c3f9b20ce0e1ca49c06c75ee45f2627f37ce701f5fde9c48925cf17209b7a3a8826f17d5a49866bb0eeb130098e60a9d23712547b79aff72128dfea63edb44c717474a82bbf6e1d94c2f35f390288b51fcf71d7eb30756bb37281d5111a8eae0b591d04da1975b4de4de920bb1994dfaa16384110c6f4bece34a4b5ab49887e96d69ba76922f894cc4a6ced04a0392f6968d52d64e106edca951370676d504e950caaca17d9d30900118a528e1edc2310eec9fd03cdc6fe411802e79223e167923d13daafcbd13e92b8036575f19a88cc33ef9fad53729929aa51863e1bc916255630f95e280ba24a49b98d9df377792cc054008a8ac8701398e5855e427e8f654db253288a2f2b2c541303a59c2e822532bc24db5d35036bf4144500509210bd31696a0ceba3c4989816bd98b0631d4b6ae4a095cd5766f0179e7ded12516f7d93ca12022681b9c1f19d5e498050e89e1a16dbd5c02bbb61b7a8cd44c40323e4fb69ecfabe8db22216a170ca12817330e47b7cf2f81232d646d57d2015d99ad341164c8d3f1c2b4dc0ac4373d86e2585f5c86555efe605eef6327764c81f16f4f3cf1dcf6b67fe4bd3e5cd4a75f4b64d2cbd242cc91cff4ce0782ed3db46de2d2e8805cb250d3a4a13cfd776fed0acca8fc8658a3d664133eacfc34c6a8bcccfe0105a34ba821994b438bbb8fd6a66627dfbeca2650d948ddbd7b450969eae5a91f161dde4c58016082403717d04b713d7238dbb72713aaaa10e69823ebe8ac28829b725e38c692b1afdcc7c55a5180eadb731bdab590db44845c518faa69db8516a017fd66cafbf58d4ce475b437d57e06833402aed10887ca6c1a7e8e05631b29655469991f3ff07766f965b7e44e40f738e7cf69fbd6e9cdf037639ec4fdf2b73b3b810885aeabb6b5d3d6c87f6c1b82d1faae5634c146179d7646816c7d99fd718f44194ba71d1622b6f4c12fa10497c6a2aefa621197f1c7cc09b5305f5e78a329d709c7c7b0b48d0245202c1785ae7735f71a9845bdbe3c4b715112262b196505c9df55169df5250ebab563938721265c39cc9e2ca862cd48e57d52c406e904900d6080cbaa0216246b26f9e1c98e00d331e2bba312dbc63db5a61989948b4739f7ddb637abb6017bb2edfbd255d0b95835de7d2ebaa0eabf85e752022d9a0a8b9e2c1338d671f6facd2901212d6b364fbd7b29973736b138447cd09c3f13ac44166469e39aba3adf48e463f25e3a2d9e83a88ecd6dad12af221b5902366b844d155aff2528b6dbc008ea8da0584eb55254d9314df0aa6703a2b3876ce69c7b165be0bb6ddb09ca5bc2af95e20c5a03ab0438eefbd0ac56b2e67e31c503263cf397a1541ca3455b7d23a32acdf8754d1fe2d3318ce5a715dad1dc2d59376414cdfa2fafcd173aec5d1a866f45f423e7c60dc69f1f00770114de6c664eda3fe92baf8f27832276fec1c23408493cedb98272466854bf1e70a0fb8c5e9014ee4444ec665518c14c6782ff31ff542dc55ad4a26670ba55df0a324b235e63a0666ec912ff8d2ea073c43b3115697383b58d7a2e6252a2d1399a40ba991320c2cea205ca1ac6b8270bf29835ca3bc58881c5f688ad55e34906ed2a67d4ab92e2e06446962381c33ec2ef2661294622e57e7650f1ea2429d8da6ad2782db04cb4b0dd414a594f11d8239390b908bd832c2acda87a44469b1cb78489a8d92e4a2e61b090b6854661ce1751f716457d845da43a8a4b11b3785e8c8e8136fb6721f442d0421c49f862b19b900c8c3ca0648be127e3391d215c97df1343ee7fd440619a9a2f86e58e84ebfa1cbf6a0b1fd666a38338257ef0a4be94ac9bd05f3d4e58c5e5fc768e5fe4f973671516e1f335d16c8919b87e45c3e94ed6fef5785a1085f6821887d0ced2509b3b91a06a4745084214503159f584f806e8a75f782d2e8baf22f713eb11370d9e4402af3bb139f3d33ab5ea0595dda90ff7861b90fcea484903d53e04b3005e99f117b4d970db5a8a5ce373f21a61eaf75dc2b16607a5eb8a0df41b2adf97803f3504801e5af9e827c9ce49c6dbac6116daca150665b50e59ba8bd2610637c3124d964855d836a7b2cef5d9d5720c73d0ec227f1cccf15e38cf45d986a1eaf48db2f0846925a776d22d980baf21cae7b278ec71505817f0745d87d41a63be657763b7fd79e41b36e8173e20133a05a3d99239d4a71daa46486154fa2dc041cf0afeba415a606fe611335abe0698b0a18edd175643b3eaaaa33b1e23f8866046cc4cdbd0ff897cec49bb667dfaadcb275178c15f007d09e1e72afc743b4687cf7b812d828cc7f55fb5d7279487cc0f5bbdfcd92fc66de812ca46b1df05baec146dd44294dda6c5548fcf41e7ed20d23f6a229391df1e691f9220f637aaad227e3b68597ca3da5b80abd5287f67a355515a42136cb640d9a40178de02db4caa91765d8a9afa60ace978c19452fd5ff59e075fdccf336da6860663a2e06b8df47ff66c3f9b8500b98c209079bf9b34c93acd3f2e8f39f36039c166c891e9d1821917a003245aeb5a2debdbe54a89b8ccdb4b1b72f7b99302526b598de08720f00d67983fbd40f0e257ec242f8f0cd96a80700569681f4fd30621404239f1db86ca99768b1e47f7b862da44d959180e6d5c291c041fa0fc1ec3a2a73d7fe6e0c550a68ab237739a4f64c67e1e6ec04d5e53a19abec1d79d6bd35fd78940355d3bddc9a2d5017bfb8e682e9ccdab9f6abd92d1ff52d2abd2b382c8d77fdb42b16d58148007b6f3171f6eca5bab4877ecc17bf2ca5a714b7f458d21ff0f8a30a0763f20950bdb590cd5811385efc70241828bf9fa356f6bf76921e2947e6b143da3a718d5207def502e365bbb68dcc4dfcde256acdeba960de9f76dc0bb2020dd69be4782206fcbe16923d32d90d14dc0f9cf84725c9d7eea7116b545123a2cafcb2dcd2d7eec58db78f1a35e8b827bb56ba72bb972b8d48a4677eb6d40adee48435e71522ad649f83704d4a870d4fe30c82301cd174c1a290c0c39916d0c9b31ecfac4a91a4b695cc6d27600993486ecf2ea4d39b45c5f1311af8e2ae4e9622273f64580b1c0be8c2de3c901aa5855b8f2176a0941be05e0c2b50810dc62096986047f330cb1ebbcc5c405e59ccfad463696ca20c992379f29d4b61c6e2724211da3be1c3e60136d53975c1df30bedb11f9e0f44ad9c3d3044dacfb4407054d792c9f24585b5bcfffef1e5ad4b33ccedd8501bfaf1fe6045ac56f86215ac0da1af856759f1eed3ca8f622887caec99c3e25708cba4f0921d5eb5169165d14248ea1c0a6bbc4454f9bce801919a5cba28783a14a7be425061236808886e8a7c999c2033061fb1a910f02395aa3ff50ac520c6ae33941e4d824bf0ff35b4a06029d4c6fe8c411ac881dd65bfc82bcf4f50bbfbae743e6dcba5b0bb11330bb8179e3b4ae66f06c89e79fab420e7e7a73ec733230c4aa1d9223d1329c9d417cc681902ae11d4522bb825336913cb5eb12fb414bff58e2247b4c71ebbe7c0739d695b5432e5c0891f32d4ee0943dc5a0051eaa917d1f014ba4f6f436164abac428114157d19ba9103931ed97df4864d44d028614d31ff57f1c6a5e8c13565650c1685d46ea64774379dec2d5a743eecd7c92ff6e556c1420185dc6dd62331f88f9b4cf0df9b5f36beb9331d8318bb81ffdf1e524bb9eaf039f48977dced2fbc658eb0116ffefdf73e5d9ab096856ae27f9c60362eb0bc2a13e63523c57cf71346fe982eac478632520ff17f553dd9c70535dd9815d326dc2f4a8164e4bafce5fbfe04ddb1d429178a1d99621db69c8d6127e5df8e4cb7ed87a9254c4442cff3f2b1787ca48d97d4157212a038b60dac473ae9c9d78a400161adf94e75d2307ff0f5b0a926dc524fc0398efa35c076c02aa2656979a819b03b8325081f807487969879e15525abbdc990573935f1e87ce64d1b732110f41344136300a2d1001a9014ae446d45529e7de504ba26c9285523b85a5751f53ffb89374571a8cc8b648182087d870aac4c75b573b0e50916c305e3d96410da3b16a028ff1c765933ec41870892de6411e51933c9ba80d643a44ec666bc540078e199820c6becd5ccc53d06b16ca2ece9cc711b5af44ff19ecd262ea1ab241c21b36ecaedb6406fcd8832c0ab80f85b6ff7c96e7d199ebb0c2ff3056dd39241ae9aad771c334b23682ae1a99f0ac198df292cdb2684c0b69f63401e785bb431840492755e99866bb2a52c6a84f18aee8282d37cfec04e6ae0709f2e1a7a895fff6fbc8ac95780bc8db222439792a58467425f10277b9783166dd2a7debc8f71251977f794855f968693e44f8e760ee0826bdc97bbd5b5c686231590365f6bad0f9f79226ee75eaf6684385cb777ac3962d4d58469c89ba6980833c41b4b5217666a41bf9a862c52403e453cad77d8c26cbc7e7650318796f7661bae7dd90e138b34764f9e10054c4a2d7bf6906a917e3ba6dcb2f1df85f22ff3037a38d14dd180af154d627604dc7fae824b4fb75a722808a7fb31d74cc3b00b2d562c73eb09a083956db39bb8c92a38e720c522c7ec41f2eb84cf74886bc56a5a9682b92925158c4b0a0c059b050a0cc9a6c44d95a4192053d6f3bc4fdd01c78c27b2eeed93f1330d75a3988cebea80ff1a0f6baca1f9ad297913199f00450df267c397058b6226f2297e67d9d52b23a8197008f0e693bf6542d4198678c5f7181c1e88e10c8bae975b0341593b1eec5382b7f737e45bc79306a9a29c6b25783f1e6a01f0677f8264361c42281c0036a7d024c1ddf9640e030f7a936fa8b638a9248cf7e98d6419d4af807ed498b575e3d34b3669e54322d0695e11b9a4f61991c7518693fbe99e5990ffe1a196c47afdf522aa5f25bae6b03d2cabe495b3c54a32dca173cb819d6ac6aa1095195638a83ea12bc1cf27129ae685966bfd6d3112be08b2fa432b5d29ae169da48eabfdaae7262836a5c84536503fdcbd15b6ce9fc73b3e51883de39fa26662ed715e02757e64756ea6909d0d4b963d561a81bf3f207aba498b35b2137f5725733a03ac8bc0191d7a384a009007edfe0175fe1d4e9710ce9462679b19a9d44d44fd0c0d6e1c82b81e860581d6f31003a521e9c9a2df8ae1ff5882ed7353713d15cba1b08a01c5ba452dfe5c5529dae9c54dd6c835ec974917988d5be8a4ca98e2d0aae4c465a97a9c9b0881d76b3da1fd4b7b8561dbeb59534aeb282bada3422021bd0ca26d65f649247664731c792d851de5091732d238018d9a8724792b30effb7bad165cad25980fcb2678dd66ac78b9fba2da4aeb85289a981881cd6e330cf84cf6bced7761ed9c5e4b48e44ef7f1bc7f8e3bc5e6726a1f31314a65b824644734461cf0a6dc32c4bc73893230d19a2465379a500777d4d47c6c771759b99a9691451a7ab24583cce8f669e5b399741dab4a4018c61004075dd92cf518be1f85946d68794adca2ba1aa773556aef0fd9a71c3d67461f34ec6ad763249ed0d5c4e89a849dabb533549203246ecdaaf022704fe818f9840f7433b952514f34813cea11eef2d166830b45e89bb34f41c203c0aa9347c20a300c6389a5e8a59283f773b066808393df00baa36fc2a7cc2a5ba10e934d794da1036b188d340f6484a7f474cadf6181c9cc4b9d9b71168d255930ac821bd7c23f624fd052753da514d6c001ba3ae71a637f1be9233647239246da853d9bfa91b87dec1902a0f9439d3264d06716ec839a1399877436452f07cf9e9a3388a19ea8dff471386f2e7f4d4fe63107c802c72b6d160f522f6632e984eba6e0404f1c0490f20fb04689ebbf3fdefb7dde7c152d0d2e9477304c8f464c5325e45e10d0ce6da1e6945ce5d358f66641671a71d4eb40149f21217fa026ef611a3c4ab8652d5ef7613d193b7f1c4e8078988f918a612f81bba50efc609318da7bcb7973f853adbf72561a1acbbcab4dda41f115d678a74592d5160b02d936222e8a379d28afe1536c16373f9560957af0a92311622f6244ccad361813a08ddd2d3240554e4762b7c1a9da4d95ba8810150d10d1b3ee268dffa8ff89d0e2c91920100ab3b4941ea8b54e9e0ffd3ff6c57aa7c18650e9bd98db1365a467e2d9b7cd0d1e4d62c111f23b04bbeb665de3224365fabe0514db64fbf6518c25cf2a1ea6bb6f16f1856a46b992fcfa71ac348e7451b27d7e061987ec15e140f9d23019cedc76814155ae14553e58efa5842b4f5dd0375d1f3f69da9de52c59931b521c77e72daa8089780be98fdcdaade856b1d8bee6369e751976fb220e32bdcae79af515afacb3eebf6557079e32073028ebb081abdd2855fe44924af857e142c7667aad48fc3f1d931e0e9f6b1ad8c7354365371c25d741425997338227c9f2a51422a078f5a1ae567ce95eac7946417d6d5b3eb4ae77f05496490d03dc84a99f6d39bcbc112544de7e98c54f72f0095f03364f8d83a4dff37ee1790431e0df4b48e50908b204034daaacca9dabcea3ac3173b59f643102b5926626de61ddce574db539ef2876ddca1f32bc72967b926a547220e3b64c4f86c9848109b8eb382dcbb08e49ef123e5d1db3fe9331a74d42c34ef46393e45ea113527c89a5409f79ea51c8ea5cf1edcd088736305f9e8b15f03d52334e07c2f3b89d0929f84d98e0b4ab8e99748e26177715a4d5c5af3f292c8227342e8b49fb1eeb509487376c0fafd3af938f91266686774871f180d1a40a1be26d0a49d17bb3ee25c2c92ac2f0e1a656537123b2b7670275c99db1009acff39e54eef510e47103d87927581e6bcddc81c52b1f57684efc4a10b0ca684938f576684cdd5c39e77a5e7506bb39e1976549d1a375938e1083e2c1a62d26d3d6f9edf17b8300318a5609bbb93ee0ef3d6d6c86788fc897217f4c31d26cd01cf661d42513c0d8d3b1007a4a6db7c694cfa7e33ec9d4bf05aa0886747580b51f23e614bf91fe27bac216c61cb3e7dfc9ff0fe1a0efe2a18c0deb29787830158e0ba91a403b3075181828505615ce340b55ae8509fda4362bae72cbc42f38dae892a8cec9280a62197306b95ceb307211aab651e7d14f4a5fac1a61bcf498f5d51fa7a6470e46823f5a898191f5b331a378164ff2e157e7d87eba35df4662c0df46176c216e1d251b545ef120aa543aecc019d6a91aef4e549d589d1bd17cab1f54be180d6efdf1b6194b923223e0240f9cadcf60faab8a94cc1a7e9cc1eabd5272c375547784c0e1b425794f677973fca5c240c9eeafb5665aa1601d7c2f1931a4a1138cb2f856556ec33eb53f675a7eedb41481be0c6afbe34b4f9f2b1bb23b01e120261e4b379e379736b429daf7e52ee7b9b4449ef5d181e2172f4934bba282e931f0d3d213d5d5e46e79e1307e03446a5e93544856f2534034ea73fb798cea2a8c206a7c97fad3eb66fdeb61d8fa6eeab7d9ef4bd1e680cbf70b6498ba919f1c4443d1211c2325d0cbe9e22fbb88cf8f1f46db6264067d2335f96ecdc8e36cf6a3fe3fec39a4ab45ca4e1293604e2bd23bcf690607035d9b5ce0ded12bca7f138d5ab6d7b2a3eb386a5ce72d17c71206ea466b0b2f1d60c4e02f6e7502b9dfbe24c259a9fb97cfeb1562b4df5e2fdb414f30cd0594f10577c9995dcd21a4ca84daa04bbfce21eb49323e97afc808bb53517ffc255b20986fed08ccdbe21fea593da173a8b53e148b266644b726b9eee12a1b482b2c11c42ca3ffba2269843f998ca7d228ff7b9b83d29504cf9c1382abd89bcf8485d236442a300935d66731b56559eb75626def39fc6ff4a028e4684cd694629b8775e4899b0eb168469e549c3fba4d7ab197d11a43161ae6426a31b8453abd8f0cd5100c68c3cbadcf7a5f049538d3996a95cb1cc2abbcd81455576d0c8709062b63d25d53fe6c97603ed8f571b338db8fd467065522e26d4afe911da9f33ec98b4834e8d5e86398e0f5f509d463b6f313ebad4f60f682b995ddc8916f314c0f355a8f8b86b22f47a5181a851f0583c9401a8037a4a20e253695a7eca394d30506af426077d8f1edc7156997ea763d520b265ae660d284a61350a480d81c6f935d532f795f5da012091499388fc0247a1123fdf7c3a01791ba12dba99fc2801359df244daf1112532de2f15cc0bf826006e810e8c47e5ebb7aa178cdd8e07d189e609ea24a18f1245a6edc8e5ee67915d40dff8d62847f8345789ccbff09428fb86286613c15fa1bfc1250fcc136044e2f4ec202ff449c4f72a6c65fc667d61f8185c7e190dd7726448c14a3bd6c3c70635554c557ab2c63a9553f3bf5d6351ca9bfbff94bbb3155ed85d8cba4e428b4d58cc50d0912ed0bf6581837e71e657346fd85e0a8c8074278d3100d08de8400163f25b7d09ebec1e3adc15845b6441a50a7ee980b4d9f10f51178fa9be46c40192276658a35dc7e7bd26ade9f3eaddf58b459bad7db454e4b4207eb538bf00d01de93ebf988a17cc584b1551ee5ed1209097829f45ce484d8257869f4d7e5f9cc7665589a6a81bf4723ba98f705bbf4d5bdb676604d65e3767c2cd76436c6e4b97e55050bc91e1d166a64949edadd8195553a9c1a3b33c4c0484c11fb09b94afcff82bbfa83ea0a2f3c1f1661e3d119f7862e1480442f3d76a8ffcacac91d2e4eb3e4a256e16970582486103294c6b395ed5b4d216a09f06f0373de122efcf71f8e1cec38cb2856a650b501a634eca3758eaf16eb4abc682fb658c6e3a4824199a332ac40031ea2cfaafbbcb3957606310e9b00e8bd4c6e6f9f0fccb0837e731c9c25da37bfe26f998211b14bf6a0aa4d165697345c4b9ff2f8c91320132dddc49d12906003d43bc25acdbdaa2cdb8ef996833e40c685417f066d6a24c92b287e7fea2ecc5668607aebbde3e76d644f93c537481c3636d6aa62a28a37493bd1115c0565495b5caff8c3996aa3870745eea36d19eaa332a2feb25167a513fdd1638fa6a5db010c78596ac2cb1a70946d504da9acdaff6f44409748db137efb89518456ab8f384ce7615f3a20f12fca206d89d0e62fd4d57d0bb8249f1b6677bd15dfe458bd6ca3afdbb33205066b68fb899ebaebc7ff285eb7c09bba9bef45bc89c34f5834e9e5fa14438ea4d5403afcef61e31debd0f0e61a61e3db1e177413730b8b89db093a96d0d016a3a001350d45a23fa078fa4dcf051effdc6441cca34b2f6214700f6c14cfd0c225cf2d799b43bfab30c7d7a9b1a9cf325a9458dd6708e53881cc4adf81e460baea31305413652113617fd9ac0790484147930b6ca1a21f87dd4074d6b3ff14a9c739d750414a986f82ace22a80cd340448014be5dde11335356ff4ecb0e472980c54698490eac59bc2b3ddc06d2e1e8f173ed39b758bf85e109104461a4c3d21967d5d96300c8dad422ea8acb1272e3a6fc9b641e02d67ddc03f73cb9269358a50f44cfb27b8e4187df0f6b8ab98f0d5a9a517b18fca67768201bfaf1302ed3ee898f6f480707c2ce0408c6d26e0d2129944c882fe4c4cbba58518da7a7c6d5789acd8fe77fc67996239577e593dad1b30c21d61f27febc8e91614f907da6649ddd68e01ede9592d690983ad109034d48699f74d644451880223f2073f08538790414c853b5eef74be958e99797b4a876e7197fb4247e7e3026939173e2f0c9086fcb3fb97c3d5412397dcc59ea478d1f957b3413ebd0093c0dd69db461b404056544e5ecf0ad3bbaaae5a919c479e0b9669398e3422cd2ce9649d929484268ef3d7d55f092f524e071aa69d2cf4051358240a281c78a445a20a28d5fd4014b4b1b9e02ed770436c3519750cb7e77afbc7d0156c4abfbcc658a263ce28c12dbcd6217bd3469a90c030f8c4b723948a6d0f3fe9afc4f32dce9e80a3ffa2a2b013ebf0d45ebd425d2d8eb5e9ba87de82a0969e51950c26b6dbd530fabfa192a71f48476f43d10e0b324cddf960ce3ff8f3fa02d88b147fbab6b918bd7d2621bc5956cb3f663a0238a99cf018f46b676993c5256178c9cc89609c5323c6b61dd745940266d331b0f0c8483b4702e499e2cd7cacb543d88185ff946ecac0b5360be7171d29709bdceba099b43737d697a4cf00eb27e00c62788b589989d409e0e9cc0375284fc00dfed466a668c223dc7aa68ba5d689d2dbfa8d2a1300804b6d12e671fef6cda82f11ef1bd616880651bc80042158c7b06840ecf1da27472e35ccd72dd15ca2e9f899ccbffc5e170d147dc8ad0a73451cdd106596bd377549d76c704e6030ac55fac55081fb6adb38cc00780da70158f91ab4f47d5d474ed78544a3903974c7da50f3324b076061bf3196fb3c1e1cccfbdf555744be9d7e044fbf2103b3edba6b8a633a4b4788c8824db10e9ea10c15085fff6b64342230021412b977610a3425da75564ea1e34b4497eb9fd482ea0b9221a88c11e95feaf5353f71b56c3120f6c5ec7484be6961ef97c3347bf43cc8d5fea239b1b37c991daa2588fdd60dd45bee7b5dda471ba3dbaf5f3f65c69e87b5d9cfb3141197b4a1f474ab74cc77d14cba2618dc1e8282723cf28b416b2e4382631678c114e01b033656b5c8dd871c8050b96104c62311d4d32a06bdd8d9c66f7cf0d28f4817712b8f3203878c9fbbd644dee4fe2115c9994fb8ab0fb5c8d7b1b07ddaf0912518188a0e9dd651f3a22aaef8c6c01b10579f8b5021f9e066137f5a89749ec53cc0ca4f70ad72f4191ffadc1fac9237c071e223f97c0001c2989e72c76057b083c7e4f65c4c8bbe3564f567fbdd98df55fdf76705558c5f92e525adc80f156b0b7f80a205e066321aa9acf95725c16dffa1c1dbfbc417454e73b84c013966eb6b2c905dde2521b94f1929cc8cc541ef80d9df5b7d0759186417cd291b8f0349f4a4a79d74c51364d936214a67c69d0706f784151976ae067332f5063166ea8462e4fa7d567b0ef9e1025612e2c9c0251fce6c672e8c9e1245c7115413d7baa185d9fb7a882152274285d9e7eb3a8d534b4ea1afbd8b06f88efb33baf64ec9edd41b8b583a3f6c262d1da1a680966c04bf01e8e874e2f65eae68769d44bef879fb3408db07643e314addeec70039c7b04c0a6bfda71192ef292dcf29fc0cb19f5d2e2b2b8f88736bc48977e60fabb570cbb4f308bedd572a8e1fe307512b7a1996ee5bd6cfba9b01e638963bd491bee474f48e1b2028fcf7f5ce3ec1aed996f6be4532907de1e72b211aab38a33325c7b4569996524ab4b932731cfdc305b24851fcefb70dbffeac4ea3edba02a0f256fa3049fe07b5c695d415cb70cf4321ad969b9898af9bc106918977f609fc245eb9c3217c96ea13af1e3e2923e364dc8c03db798ea5500fbaeeb6639559eeb01243ff56744fd2285f259b96b896e35a58f1116f47552f96101fcdb5f161fc7de78101ba15d6aaf7d113260b63316aef89dd56c28d64cb6d56d0863ce7e386f55d23e9837b6469b11ca6198cec85be88662aa9a4637735b68324272e0173689b6fcf02245462bdadad16f96517bfca44a897904831250f2dea1687d52a2463ba0555e9ededf032b5666f01883a73797329569ec0b830b2708165bd4c3871e22f9e2e99e9009796bed0c8a57f0bca327b2764df224a8299f985d0f1ecbe4d6842bcea97aa9e30685200970da64171a0df1e85372abeb823f5003c7f45663ffc8beac52fefa780130420114ea21f198cfbe665c86a1c8c40d4187ed35cada642c22dd5406b0b164b15856180c8024d051364caa699b6ea29f1db21e4660a896f806a6c352714cf827b727b3e9804e0c05dc81cfc2acd8c4d5787ae807bd6fe4079d65f4c61ba9f92c953427f60baa7ebd6489147261f880250a368e7e2eea0ea8a2b4804eeef06fa1a7e8045337ccb45aa03a0390f8d4db562b212cfcdec165701a87250df3736353d7049920700226c2379541c4095a857ba336fb85d10f2e9f2333ea165dc5c384e7229838b975ca27f6b8307f4b7cd14b1e4c9a0900ec3a2e986621b080923d0880c253bcb53f4d7890907e17230dba5a695fd05961ece765988cca537264a77f9f9794ce10349600bfb225fb5ff5bcb78b640ff4a8d49a68f5b02164d4bd32dadf2d57b2e3192f38746240bb23d2412cbba2a4acb50a9fc672670f79caacd46fa9e11cc00504696805554a32bb60c014a2034b1c90a50f0f8965fe0e148ddea6546fdc120371cb7693abfe8db79849f83951e544c10a556e04bd59e006f7ba3b2eb121da8920fa42935d58a24fa430ab4857efe68b380e870cee73eaec0037010df7ccefbd395edd53ab86e403d571ed81fef21a2c5f15aaec32ed8be1afb48cc97f11a35dbc50b82940fef2821aabdf300e9a73177a124bbf8050149901ed62f75ae803d0d16c750761fdd392e997fc214afe7b38c64fcb5d4fe8ba138afd17ca40d15d67e1c52f00e51e6000db3900855c1efe489dd3c16a3ad665a827e59909368abf95f92e871c432f35efea2da11f2e749fa13c2792ab453c5536c59aa6d7e39a06de84d8d4ef95438bab2b410f2e6f00bbf11f690f4dfaa846263a3096275aedf5608d4b9bcbaf299333e02dd792a7fd27b851e924798607c6280c1d74391e08e7f554ec3a57f2959bda5e1f0c0542e005cc464b1a92615587766223128e0ac8116526c25301691ef044ebe920d73d183df96a426b7eb7cb69ac558efe37d5f4925a263f054782aa6d3e4b77f12d4e78a0fe1ad8e4c5708bf6c7c449a00629b191e8dae36b65c3554bb95a8afb6d153223a813a0c6da54b468056cb2976a6978bd471bf2698d30bc77476e9fa1b77010e7318754a18495d8ae5f91a969499ed5d9d81097765372d14485c2cac7a27589c8600c0fa9afe64c9d72da958e56cf74aa6a0ec8f2da41fc5475af9a06b23527ef9485dc0c39344918a10b36db50e5b7aca73caeff99d11a1c1cc8c2fc30cd492690c62249f3e550f8fe77047585907e51bad8cddd56707196932a36e5f9427d84bffbab83e04ebf151bb16ad306ab9b20db0db9d667a6acaef054ebc8458e15757446558bbc0592118eee5c058f740a64762989f41bc9180d1d6372316e3bd09bad3dbcf0ea5af12951da0138a04c3a88be06ddbecf75b4bd6a941011d8ca6d7c5300753534110f1b7f4b002372bd47515bc1a23a35338188c31bc764a11235b23a066c8619e7e2b5f7a93c26eac063e4b54d3f14383c3f243f62b7286dd797e48563c34506a068db16482ac17de244e9a9a33204bd2f1a8d57b874107a3862d0d0adec639be6f80b2adcdd19209fc1ed6b666cde3cf220e9a293b7842370f121e3ae55db65e1c4fa2c925fb09ee8c5f8b7cdd6ac5788a933e8f4456df51ad0a523e8d7836beb821d8de7dddaa890806f2e576359f2f517717169d1407c53c200469c381211a2dc1dfa3d6c256c27de6e895ea5bd008d079b3e761ab861b403546d1b1d5361ec895394f0ffcad577e200b134a4a21aa2dd5bd25802b807c590456c5fca40251b02fa1d4170b730e3b2ef9b2b28b3732004de428fbc09808afcb0f6513c2ce4963bceb23f4f30fd387cc60dd43701737cbf54cfd5164f7a88f76b1f9a9736bab06cc7ed75711e5da0d37863e88064ec01905c157bda7dd1b3e5c13344014c543243dfccfd732e88fbb98a64c31836d0da8e6e26f7451b3e6d2cbd851af183f5d908b28cdea2f07505673c9ceb9b1ee91b1b224642c1dd56c130c5b894617090e248a8349c3dde2052392c11b17dbf4b8940006936c5a8294d4bbc0eda1b25d7d8730da6d21e01618d1a57c656762ba6cb02c8c07cc92b6fe09333cd74abe31df8fd756dad0c57ca407fe260d6c01f7358e723a3c2c038cf080d0661be55e9f407ed6ace1da840c2231ba864884fd0db7559aaca0a32fcf440f3a4bb44b5ef3e7bb67d4d13c342aaefb82e70e0ce655fc0d411ca00ff36be936f45e39e33d616500f736a1cc28397f413ed0b3dfbb27291e4be46aaac2de83c2511dcae15d5d35db174880e1e20423ef22b40d0cadbcbc8c1ccdd5e4d008a597cdc761621660f38291a7a59b98b79b23ea276478f77385f785ed077779ade0b2fcc8362422253a26c794486c9b8dabe90d78a348fcda46066aa3119953e322ba7e9754a7f30c0df1340214b0635a73464ae4fee9eebf3d3581927094935d38496cb2179d8a02aacf866a1ab097fb453aecbdea8898d085e3c29be21cd383ad89db38a3e6a91b55589a2fb1640b63f94385b2c23cb0091de06b1aa24ad785de5af81114dd479157fbd8d3eb69f3da12012b7a42be9e59733a3b243118ab1d207b0297a38c2bc6b5d8b27099d6091c1393aaf9e48bacb70ba88f01944a73e9e262463962559c4f38adb8f74c38db2d6ed7b9d915c6257fe7855c1a2440d88f75b70c00acc603f15b6c1e7b6b99b343806b6f0a7b2fe6dde2985a92c2e24032d61046eb20b958ce7acc59a4a25fc5076ce0491a70ffb12665abef317ea04fcd083cda83ddad485f67ffdbf151989178dedf50e064de4240956fac6c242c253422f20fbeda46c93f5a1d563720e9c491fb7dd1f707124d6090dbd837d2c1c29d2ec55df44a05f21c5a41fbde75344ee5fae8dddc3f0c4794a22422299a623b628ae45badbb1f65c3a00b222f2c5cae9e2ddfafb5dfb5217071317c29a0a4e769c0149429c31247ea9c1899b8367ae25b55ce4f5be3eeeb4969721ff5b799aee3255129aae3c927a9b4e0d2e64b9f9d1450c688989548f8f8f3661398042c2b50b962910b3c6c24e9363bf506d3561e4ed8a9bb92d870cece332ebdc67488feeb036078444af83c46b623d91d5e2bf1a0fcee193c7857f0a2e5037be1f940682ab519922d325bef0cb6c0d42a8565b3a9208fa21890ad05d9021983708c68b29d13d83739d1b5d3e0573605e8fa83b876a49daf98b1f4463037cae418d710f2d9f6c034c9f974141ebaffad0eae9445097ab7122cfd8750110689e17698478a73729991f9cc29bbec62c680d929b0b9fd83f894e16c9a0f7744945598e6480ca29ba5321666226754dd06e578d62da6e9efa51c5167771525521f7cc80a53edfeea9ff9236fc5a3c46903992fce6a87e20c3a959f0a379d72ac703e4f2a6470cf1964c9db67e37dcaf0b2efec9f0634ca7fa90df9346e45f63e23a5e249372cdf3d7020a45fd4768aeabf5a62abbd55c71ec7deb9c58d273f29c53a03ca2744bbfc3bc663c79a069ebb6042e1f2812cb66752b9f7ce30895f97e302c672fceec6f542cd72a8f70ca015c2a731e9ef5005ca5b0baa3b15edef6ad15ed0c9206fb085407752cd198f62e490361fabf13a1d0d1377e02230488d8e754bafc8087821303cd0979a53549eabaad289770b279fbed946e76b382eafad99588bf1604eac3bcee663461c8630e7b872cea70ac2dc949b64660da2d3c5c91616fd929a95d7783aa679cc3e289dc50b0a7b8d81e4ae1a029756ca90e0c492de3ef6704287fc788c8d5b891d82f8b1f84393b06a20ae7d71ef9b5e3461a7d0abe1dfb7cbb8d56b18fdb7921c2b9b9d0aa715c20c1c878d5be8f54491651a8c8ab5a0dd87291f8fd5e44f3e7fffa8c9f9ff4c1874f4ae712b0835894d734d0930ae2fb81630f959d4550ccede57396a843d885dd0dedafa0b9f4159f8472537f8be58398a15e694864f434705c955412d4b3f6b0a2da8bc563bbb64909b62902f3b3eb659398baf4c2611cf99384eb95ef84f60fd55d8dd3ca946b3516ba8be5ddf43a227a83d5f3714941b3b3aebd0be82a01cb9a4173b980f1dd27658a153a5cea25b9a993b29ddcbe0bd5d190999c4330be4b8d5b8d239cd35a53c1c11637ab684bbc57381ee4f80fe321f2d1b383ba8fe96c23708aec4f49f35728cdfa064cd020263851f8e1e1fc760811155516fc3f4453f0520a93b814725eaafe143926fed7ac4c9ade5d57a6e6df2152d87068c007fbedd7eef86ecac7f47ab88940120f316de24db274b4f068edc640fb26537d0b140c8102711525c819b1da2c2b6d51e6b8cf37ccf5e95a3f217ab665ba504e10705d5b9554ae48eefea11b0a9e9f3869507f30eda2f529d973e658c9b49c5665ccd2c36346698a6a619cc9452f23dbf392104ef2352604d5a3fb4007ed1c314d72df4b597789bde76c23fc5aa8ac26d0837c40a6e3e983ca68a806e5cedd08ec81c06ef66be76413cdc96818eeb4b5b376a0b86193a51f82f47165a569be918b71099dddc80d2544b598be1378d51afdb15fceadfa145de1ff021194894cebcbdac0a1f9540a219fd52c7ce700f6bc48f9e2ec45b863aa66824f3df4b4213b74deb258b0019e931519fa952123690e04161e9dec9d9eebeba38b89f4a04ef6b6404a0409049a781fad30ed0dfd4a1518414f3938bae52d60735665e140a3ef0cf7bf6deedd5b2680437393b194e483466ac87f0a520217ffc1202fd2e1fa8737b06f3d50978b14753740ef5cd318f49b5f4aec5e7ad541afaab44e033cd47a21b7771d5a86d81e2e57d7c95a1ea43a9abdccc11b6ecbf85e257537cb70043df1f99233e1572f251bc77f0e4bccf88634cb1467c9e5ac20fe6efea6c67a35a92a813ab148aa66a4c2b24a9cc476b7f309351c8e29485af62ed3dd244b9b66c3ecb1216bfb488019733051f2b2be66fa39cb15df3db22063ad76e9825aa0e45445da3d928fd52e41bd05f72d45225f5bd9b7660249eafff31d350594032431608e32346dbb486dd9c4fc5be003d88bff6dbca4568df3294ede97f1e4e6b9fd8e73e3f2f72b7e30c23d489c0f3d74f26cb2887b532787508f6d71d663f699cc3c0d77c5a135ab07d909913cddf2d1bced28077a3d23d1e7049774dc209908d21ea0290dee17fddcc1e16f414bfa27842      </script>      <div class="hbe hbe-content">        <div class="hbe hbe-input hbe-input-default">          <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">          <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">            <span class="hbe hbe-input-label-content hbe-input-label-content-default" data-content="联系站长以查看密码">联系站长以查看密码</span>          </label>        </div>        <button class="hbe hbe-confirm"></button>      </div>    </div>    ]]></content>
    
    
    <summary type="html">联系站长以查看密码</summary>
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-08-机器学习复习</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/2418.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/2418.html</id>
    <published>2026-01-08T16:00:36.000Z</published>
    <updated>2026-01-16T02:18:41.571Z</updated>
    
    <content type="html"><![CDATA[<hr><p>应付期末考试，整理了一些题目</p><h4 id="1-以下哪些是机器学习中的数据预处理步骤-（）"><a href="#1-以下哪些是机器学习中的数据预处理步骤-（）" class="headerlink" title="1. 以下哪些是机器学习中的数据预处理步骤?（）"></a>1. 以下哪些是机器学习中的数据预处理步骤?（）</h4><p>A. 数据清洗</p><p>B. 数据归一化</p><p>C. 特征选择</p><p>D. 数据可视化</p><p><strong>答案: ABC</strong></p><h4 id="2-监督学习包括以下哪些类型-（）"><a href="#2-监督学习包括以下哪些类型-（）" class="headerlink" title="2. 监督学习包括以下哪些类型?（）"></a>2. 监督学习包括以下哪些类型?（）</h4><p>A. 分类</p><p>B. 回归</p><p>C. 聚类</p><p>D. 降维</p><p><strong>答案: AB</strong></p><h4 id="3-以下哪些算法属于无监督学习-（）"><a href="#3-以下哪些算法属于无监督学习-（）" class="headerlink" title="3. 以下哪些算法属于无监督学习?（）"></a>3. 以下哪些算法属于无监督学习?（）</h4><p>A. K-均值聚类</p><p>B. 主成分分析(PCA)</p><p>C. 关联规则挖掘</p><p>D. 线性判别分析(LDA)</p><p><strong>答案: ABC</strong></p><h4 id="4-神经网络中的激活函数有哪些作用-（）"><a href="#4-神经网络中的激活函数有哪些作用-（）" class="headerlink" title="4. 神经网络中的激活函数有哪些作用?（）"></a>4. 神经网络中的激活函数有哪些作用?（）</h4><p>A. 增加模型的非线性</p><p>B. 防止梯度消失</p><p>C. 对输入进行归一化</p><p>D. 加快模型收敛速度</p><p><strong>答案: AB</strong></p><h4 id="5-影响机器学习模型性能的因素有（）"><a href="#5-影响机器学习模型性能的因素有（）" class="headerlink" title="5. 影响机器学习模型性能的因素有（）"></a>5. 影响机器学习模型性能的因素有（）</h4><p>A. 数据质量</p><p>B. 算法选择</p><p>C. 超参数设置</p><p>D. 硬件性能</p><p><strong>答案: ABC</strong></p><h4 id="6-在构建决策树时，以下哪些可以作为分裂节点的选择标准-（）"><a href="#6-在构建决策树时，以下哪些可以作为分裂节点的选择标准-（）" class="headerlink" title="6. 在构建决策树时，以下哪些可以作为分裂节点的选择标准?（）"></a>6. 在构建决策树时，以下哪些可以作为分裂节点的选择标准?（）</h4><p>A. 信息增益</p><p>B. 基尼指数</p><p>C. 均方误差</p><p>D. 准确率</p><p><strong>答案: AB</strong></p><h4 id="7-以下哪些技术可以用于处理过拟合问题-（）"><a href="#7-以下哪些技术可以用于处理过拟合问题-（）" class="headerlink" title="7. 以下哪些技术可以用于处理过拟合问题?（）"></a>7. 以下哪些技术可以用于处理过拟合问题?（）</h4><p>A. 增加数据量</p><p>B. 正则化</p><p>C. 早停法</p><p>D. 降低模型复杂度</p><p><strong>答案: ABCD</strong></p><h4 id="8-以下关于交叉验证的说法正确的是（）"><a href="#8-以下关于交叉验证的说法正确的是（）" class="headerlink" title="8. 以下关于交叉验证的说法正确的是（）"></a>8. 以下关于交叉验证的说法正确的是（）</h4><p>A. 可以有效评估模型的泛化能力</p><p>B. 常见的有 K-折交叉验证</p><p>C. 能避免数据划分的随机性影响</p><p>D. 只适用于小数据集</p><p><strong>答案: AB</strong></p><h4 id="9-以下哪些是深度学习中的优化算法-（）"><a href="#9-以下哪些是深度学习中的优化算法-（）" class="headerlink" title="9. 以下哪些是深度学习中的优化算法?（）"></a>9. 以下哪些是深度学习中的优化算法?（）</h4><p>A. 随机梯度下降(SGD)</p><p>B. Adagrad</p><p>C. Adam</p><p>D. 梯度提升(Gradient Boosting)</p><p><strong>答案: ABC</strong></p><h4 id="10-对于一个二分类问题，以下哪些指标可以全面评估模型性能-（）"><a href="#10-对于一个二分类问题，以下哪些指标可以全面评估模型性能-（）" class="headerlink" title="10. 对于一个二分类问题，以下哪些指标可以全面评估模型性能?（）"></a>10. 对于一个二分类问题，以下哪些指标可以全面评估模型性能?（）</h4><p>A. 准确率</p><p>B. 召回率</p><p>C. F1-分数</p><p>D. 特异度</p><p><strong>答案: ABCD</strong></p><h4 id="11-以下属于机器学习中常用的特征工程方法的有（）"><a href="#11-以下属于机器学习中常用的特征工程方法的有（）" class="headerlink" title="11. 以下属于机器学习中常用的特征工程方法的有（）"></a>11. 以下属于机器学习中常用的特征工程方法的有（）</h4><p>A. 数据标准化</p><p>B. 独热编码</p><p>C. 特征缩放</p><p>D. 交叉验证</p><p><strong>答案: ABC</strong></p><h4 id="12-下列关于支持向量机-SVM-的说法正确的是（）"><a href="#12-下列关于支持向量机-SVM-的说法正确的是（）" class="headerlink" title="12. 下列关于支持向量机(SVM)的说法正确的是（）"></a>12. 下列关于支持向量机(SVM)的说法正确的是（）</h4><p>A. SVM 可以用于线性可分的数据分类</p><p>B. SVM 可以通过核函数处理非线性分类问题</p><p>C. SVM 的目标是找到一个最大间隔的超平面</p><p>D. SVM 对异常值不敏感</p><p><strong>答案: ABC</strong></p><h4 id="13-以下哪些是无监督学习的应用场景-（）"><a href="#13-以下哪些是无监督学习的应用场景-（）" class="headerlink" title="13. 以下哪些是无监督学习的应用场景?（）"></a>13. 以下哪些是无监督学习的应用场景?（）</h4><p>A. 客户细分</p><p>B. 图像识别</p><p>C. 异常检测</p><p>D. 语音识别</p><p><strong>答案: AC</strong></p><h4 id="14-机器学习中常用的损失函数有（）"><a href="#14-机器学习中常用的损失函数有（）" class="headerlink" title="14. 机器学习中常用的损失函数有（）"></a>14. 机器学习中常用的损失函数有（）</h4><p>A. 交叉熵损失函数</p><p>B. 铰链损失函数</p><p>C. 指数损失函数</p><p>D. 对数损失函数</p><p><strong>答案: ABCD</strong></p><h4 id="15-以下属于深度学习框架的有（）"><a href="#15-以下属于深度学习框架的有（）" class="headerlink" title="15. 以下属于深度学习框架的有（）"></a>15. 以下属于深度学习框架的有（）</h4><p>A. TensorFlow</p><p>B. PyTorch</p><p>C. Scikit-learn</p><p>D. Keras</p><p><strong>答案: ABD</strong></p><h4 id="16-以下属于监督学习任务的有（）"><a href="#16-以下属于监督学习任务的有（）" class="headerlink" title="16. 以下属于监督学习任务的有（）"></a>16. 以下属于监督学习任务的有（）</h4><p>A. 分类</p><p>B. 聚类</p><p>C. 回归</p><p>D. 降维</p><p><strong>答案: AC</strong></p><h4 id="17-常用的数据预处理操作包括（）"><a href="#17-常用的数据预处理操作包括（）" class="headerlink" title="17. 常用的数据预处理操作包括（）"></a>17. 常用的数据预处理操作包括（）</h4><p>A. 数据清洗</p><p>B. 特征工程</p><p>C. 数据采样</p><p>D. 模型评估</p><p><strong>答案: ABC</strong></p><h4 id="18-以下哪些是决策树的优点（）"><a href="#18-以下哪些是决策树的优点（）" class="headerlink" title="18. 以下哪些是决策树的优点（）"></a>18. 以下哪些是决策树的优点（）</h4><p>A. 易于理解和解释</p><p>B. 对数据的准备要求低</p><p>C. 抗过拟合能力强</p><p>D. 能处理多分类问题</p><p><strong>答案: ABD</strong></p><h4 id="19-属于集成学习算法的有（）"><a href="#19-属于集成学习算法的有（）" class="headerlink" title="19. 属于集成学习算法的有（）"></a>19. 属于集成学习算法的有（）</h4><p>A. 决策树集成</p><p>B. 随机森林</p><p>C. AdaBoost</p><p>D. K-Means</p><p><strong>答案: ABC</strong></p><h4 id="20-神经网络中常用的激活函数有（）"><a href="#20-神经网络中常用的激活函数有（）" class="headerlink" title="20. 神经网络中常用的激活函数有（）"></a>20. 神经网络中常用的激活函数有（）</h4><p>A. sigmoid</p><p>B. ReLU</p><p>C. tanh</p><p>D. Softmax</p><p><strong>答案: ABCD</strong></p><h4 id="21-评估分类模型的指标有（）"><a href="#21-评估分类模型的指标有（）" class="headerlink" title="21. 评估分类模型的指标有（）"></a>21. 评估分类模型的指标有（）</h4><p>A. 准确率</p><p>B. 精确率</p><p>C. 召回率</p><p>D. F1 值</p><p><strong>答案: ABCD</strong></p><h4 id="22-以下哪些方法可以防止模型过拟合（）"><a href="#22-以下哪些方法可以防止模型过拟合（）" class="headerlink" title="22. 以下哪些方法可以防止模型过拟合（）"></a>22. 以下哪些方法可以防止模型过拟合（）</h4><p>A. 增加数据量</p><p>B. 正则化</p><p>C. 减少特征数量</p><p>D. 早停法</p><p><strong>答案: ABCD</strong></p><h4 id="23-线性回归模型的假设包括（）"><a href="#23-线性回归模型的假设包括（）" class="headerlink" title="23. 线性回归模型的假设包括（）"></a>23. 线性回归模型的假设包括（）</h4><p>A. 自变量与因变量之间存在线性关系</p><p>B. 误差项服从正态分布</p><p>C. 误差项方差齐性</p><p>D. 自变量之间不存在多重共线性</p><p><strong>答案: ABCD</strong></p><h4 id="24-支持向量机的核函数类型有（）"><a href="#24-支持向量机的核函数类型有（）" class="headerlink" title="24. 支持向量机的核函数类型有（）"></a>24. 支持向量机的核函数类型有（）</h4><p>A. 线性核</p><p>B. 多项式核</p><p>C. RBF 核</p><p>D. 高斯核</p><p><strong>答案: ABCD</strong></p><h4 id="25-以下关于-K-Means-算法的描述正确的有（）"><a href="#25-以下关于-K-Means-算法的描述正确的有（）" class="headerlink" title="25. 以下关于 K-Means 算法的描述正确的有（）"></a>25. 以下关于 K-Means 算法的描述正确的有（）</h4><p>A. 是无监督学习算法</p><p>B. 需要预先指定聚类数 K</p><p>C. 对初始聚类中心敏感</p><p>D. 最终聚类结果唯一</p><p><strong>答案: ABC</strong></p><h4 id="26-下列哪些是机器学习的常见应用领域（）"><a href="#26-下列哪些是机器学习的常见应用领域（）" class="headerlink" title="26. 下列哪些是机器学习的常见应用领域（）"></a>26. 下列哪些是机器学习的常见应用领域（）</h4><p>A. 图像识别</p><p>B. 自然语言处理</p><p>C. 推荐系统</p><p>D. 数据加密</p><p>E. 金融预测</p><p><strong>答案: ABCE</strong></p><h4 id="27-下列哪些是数据预处理的方法（）"><a href="#27-下列哪些是数据预处理的方法（）" class="headerlink" title="27. 下列哪些是数据预处理的方法（）"></a>27. 下列哪些是数据预处理的方法（）</h4><p>A. 缺失值处理</p><p>B. 数据标准化</p><p>C. 特征选择</p><p>D. 数据分类</p><p>E. 数据归一化</p><p><strong>答案: ABE</strong></p><h4 id="28-下列哪些是监督学习算法（）"><a href="#28-下列哪些是监督学习算法（）" class="headerlink" title="28. 下列哪些是监督学习算法（）"></a>28. 下列哪些是监督学习算法（）</h4><p>A. 线性回归</p><p>B. 决策树</p><p>C. 支持向量机</p><p>D. K 均值聚类</p><p>E. 逻辑回归</p><p><strong>答案: ABCE</strong></p><h4 id="29-下列哪些是评估模型性能的指标（）"><a href="#29-下列哪些是评估模型性能的指标（）" class="headerlink" title="29. 下列哪些是评估模型性能的指标（）"></a>29. 下列哪些是评估模型性能的指标（）</h4><p>A. 准确率</p><p>B. 精确率</p><p>C. 召回率</p><p>D. F1 分数</p><p>E. 相关系数</p><p><strong>答案: ABCD</strong></p><h4 id="30-下列哪些是特征工程的常用方法（）"><a href="#30-下列哪些是特征工程的常用方法（）" class="headerlink" title="30. 下列哪些是特征工程的常用方法（）"></a>30. 下列哪些是特征工程的常用方法（）</h4><p>A. 特征缩放</p><p>B. 特征编码</p><p>C. 特征选择</p><p>D. 特征组合</p><p>E. 数据标准化</p><p><strong>答案: ABCD</strong></p><h4 id="31-下列哪些是集成学习算法（）"><a href="#31-下列哪些是集成学习算法（）" class="headerlink" title="31. 下列哪些是集成学习算法（）"></a>31. 下列哪些是集成学习算法（）</h4><p>A. 决策树集成</p><p>B. 随机森林</p><p>C. AdaBoost</p><p>D. bagging</p><p>E. 支持向量机</p><p><strong>答案: ABCD</strong></p><h4 id="32-下列哪些是过拟合的解决方法（）"><a href="#32-下列哪些是过拟合的解决方法（）" class="headerlink" title="32. 下列哪些是过拟合的解决方法（）"></a>32. 下列哪些是过拟合的解决方法（）</h4><p>A. 增加数据量</p><p>B. 正则化</p><p>C. 减少模型复杂度</p><p>D. 增加模型参数</p><p>E. 交叉验证</p><p><strong>答案: ABCE</strong></p><h4 id="33-下列哪些是降维方法（）"><a href="#33-下列哪些是降维方法（）" class="headerlink" title="33. 下列哪些是降维方法（）"></a>33. 下列哪些是降维方法（）</h4><p>A. 主成分分析</p><p>B. 因子分析</p><p>C. 线性判别分析</p><p>D. K 均值聚类</p><p>E. 基于矩阵分解的方法</p><p><strong>答案: ABCE</strong></p><h4 id="34-下列哪些是数据挖掘的步骤（）"><a href="#34-下列哪些是数据挖掘的步骤（）" class="headerlink" title="34. 下列哪些是数据挖掘的步骤（）"></a>34. 下列哪些是数据挖掘的步骤（）</h4><p>A. 数据收集</p><p>B. 数据预处理</p><p>C. 模型训练</p><p>D. 模型评估</p><p>E. 数据可视化</p><p><strong>答案: ABCDE</strong></p><h4 id="35-下列哪些是特征选择的方法（）"><a href="#35-下列哪些是特征选择的方法（）" class="headerlink" title="35. 下列哪些是特征选择的方法（）"></a>35. 下列哪些是特征选择的方法（）</h4><p>A. 单变量特征选择</p><p>B. 基于模型的特征选择</p><p>C. 递归特征消除</p><p>D. 岭回归</p><p>E. Lasso 回归</p><p><strong>答案: ABCE</strong></p><h4 id="36-下列哪些是常用的特征工程方法（）"><a href="#36-下列哪些是常用的特征工程方法（）" class="headerlink" title="36. 下列哪些是常用的特征工程方法（）"></a>36. 下列哪些是常用的特征工程方法（）</h4><p>A. 特征缩放</p><p>B. 特征编码</p><p>C. 特征选择</p><p>D. 特征组合</p><p>E. 数据归一化</p><p><strong>答案: ABCDE</strong></p><h4 id="37-下列哪些是评估分类模型性能的指标（）"><a href="#37-下列哪些是评估分类模型性能的指标（）" class="headerlink" title="37. 下列哪些是评估分类模型性能的指标（）"></a>37. 下列哪些是评估分类模型性能的指标（）</h4><p>A. 准确率</p><p>B. 精确率</p><p>C. 召回率</p><p>D. F1 分数</p><p>E. 相关系数</p><p><strong>答案: ABCD</strong></p><h4 id="38-下列哪些是集成学习算法（）"><a href="#38-下列哪些是集成学习算法（）" class="headerlink" title="38. 下列哪些是集成学习算法（）"></a>38. 下列哪些是集成学习算法（）</h4><p>A. 决策树集成</p><p>B. 随机森林</p><p>C. AdaBoost</p><p>D. bagging</p><p>E. 支持向量机</p><p><strong>答案: ABCD</strong></p><h4 id="39-下列哪些是过拟合的解决方法（）"><a href="#39-下列哪些是过拟合的解决方法（）" class="headerlink" title="39. 下列哪些是过拟合的解决方法（）"></a>39. 下列哪些是过拟合的解决方法（）</h4><p>A. 增加数据量</p><p>B. 正则化</p><p>C. 减少模型复杂度</p><p>D. 增加模型参数</p><p>E. 交叉验证</p><p><strong>答案: ABCE</strong></p><h4 id="40-下列哪些是降维方法（）"><a href="#40-下列哪些是降维方法（）" class="headerlink" title="40. 下列哪些是降维方法（）"></a>40. 下列哪些是降维方法（）</h4><p>A. 主成分分析</p><p>B. 因子分析</p><p>C. 线性判别分析</p><p>D. K 均值聚类</p><p>E. 基于矩阵分解的方法</p><p><strong>答案: ABCE</strong></p><h4 id="41-下列哪些是监督学习算法（）"><a href="#41-下列哪些是监督学习算法（）" class="headerlink" title="41. 下列哪些是监督学习算法（）"></a>41. 下列哪些是监督学习算法（）</h4><p>A. 线性回归</p><p>B. 决策树</p><p>C. 支持向量机</p><p>D. K 均值聚类</p><p>E. 逻辑回归</p><p><strong>答案: ABCE</strong></p><h4 id="42-下列哪些是数据预处理的方法（）"><a href="#42-下列哪些是数据预处理的方法（）" class="headerlink" title="42. 下列哪些是数据预处理的方法（）"></a>42. 下列哪些是数据预处理的方法（）</h4><p>A. 缺失值处理</p><p>B. 数据标准化</p><p>C. 特征选择</p><p>D. 数据分类</p><p>E. 数据归一化</p><p><strong>答案: ABE</strong></p><h4 id="43-下列哪些是特征选择的方法（）"><a href="#43-下列哪些是特征选择的方法（）" class="headerlink" title="43. 下列哪些是特征选择的方法（）"></a>43. 下列哪些是特征选择的方法（）</h4><p>A. 单变量特征选择</p><p>B. 基于模型的特征选择</p><p>C. 递归特征消除</p><p>D. 岭回归</p><p>E. Lasso 回归</p><p><strong>答案: ABCE</strong></p><h4 id="44-下列哪些是数据挖掘的步骤（）"><a href="#44-下列哪些是数据挖掘的步骤（）" class="headerlink" title="44. 下列哪些是数据挖掘的步骤（）"></a>44. 下列哪些是数据挖掘的步骤（）</h4><p>A. 数据收集</p><p>B. 数据预处理</p><p>C. 模型训练</p><p>D. 模型评估</p><p>E. 数据可视化</p><p><strong>答案: ABCDE</strong></p><h4 id="45-下列哪些是常用的交叉验证方法（）"><a href="#45-下列哪些是常用的交叉验证方法（）" class="headerlink" title="45. 下列哪些是常用的交叉验证方法（）"></a>45. 下列哪些是常用的交叉验证方法（）</h4><p>A. 留出法</p><p>B. K 折交叉验证</p><p>C. 移动窗口交叉验证</p><p>D. 留一法</p><p>E. 分层交叉验证</p><p><strong>答案: ABCDE</strong></p><h4 id="46-以下属于监督学习任务的有-（）"><a href="#46-以下属于监督学习任务的有-（）" class="headerlink" title="46. 以下属于监督学习任务的有:（）"></a>46. 以下属于监督学习任务的有:（）</h4><p>A. 图像分类</p><p>B. 语音识别</p><p>C. 聚类分析</p><p>D. 回归分析</p><p><strong>答案: ABD</strong></p><h4 id="47-以下哪些方法可以用于降低过拟合风险-（）"><a href="#47-以下哪些方法可以用于降低过拟合风险-（）" class="headerlink" title="47. 以下哪些方法可以用于降低过拟合风险?（）"></a>47. 以下哪些方法可以用于降低过拟合风险?（）</h4><p>A. 增加训练数据</p><p>B. 正则化</p><p>C. 早停法</p><p>D. 减少特征数量</p><p><strong>答案: ABCD</strong></p><h4 id="48-以下关于支持向量机-SVM-的说法，正确的有-（）"><a href="#48-以下关于支持向量机-SVM-的说法，正确的有-（）" class="headerlink" title="48. 以下关于支持向量机(SVM)的说法，正确的有:（）"></a>48. 以下关于支持向量机(SVM)的说法，正确的有:（）</h4><p>A. SVM 可以处理线性可分和线性不可分的数据</p><p>B. 核函数是 SVM 处理线性不可分数据的关键</p><p>C. SVM 的目标是找到一个最大间隔超平面</p><p>D. SVM 对异常值不敏感</p><p><strong>答案: ABC</strong></p><h4 id="49-以下属于无监督学习算法的有-（）"><a href="#49-以下属于无监督学习算法的有-（）" class="headerlink" title="49. 以下属于无监督学习算法的有:（）"></a>49. 以下属于无监督学习算法的有:（）</h4><p>A. 主成分分析(PCA)</p><p>B. 高斯混合模型(GMM)</p><p>C. 决策树</p><p>D. 自编码器</p><p><strong>答案: ABD</strong></p><h4 id="50-以下哪些是评估分类模型性能的指标-（）"><a href="#50-以下哪些是评估分类模型性能的指标-（）" class="headerlink" title="50. 以下哪些是评估分类模型性能的指标?（）"></a>50. 以下哪些是评估分类模型性能的指标?（）</h4><p>A. 准确率</p><p>B. 召回率</p><p>C. F1 值</p><p>D. 均方误差</p><p><strong>答案: ABC</strong></p><h4 id="51-以下关于随机森林的说法，正确的有-（）"><a href="#51-以下关于随机森林的说法，正确的有-（）" class="headerlink" title="51. 以下关于随机森林的说法，正确的有:（）"></a>51. 以下关于随机森林的说法，正确的有:（）</h4><p>A. 随机森林是由多个决策树组成的集成模型</p><p>B. 随机森林可以并行训练多个决策树</p><p>C. 随机森林对缺失值和异常值不敏感</p><p>D. 随机森林只能用于分类问题</p><p><strong>答案: ABC</strong></p><h4 id="52-以下哪些方法可以用于数据降维-（）"><a href="#52-以下哪些方法可以用于数据降维-（）" class="headerlink" title="52. 以下哪些方法可以用于数据降维?（）"></a>52. 以下哪些方法可以用于数据降维?（）</h4><p>A. 主成分分析(PCA)</p><p>B. 线性判别分析(LDA)</p><p>C. 特征选择</p><p>D. 奇异值分解(SVD)</p><p><strong>答案: ABCD</strong></p><h4 id="53-以下关于-K-近邻算法的说法，正确的有-（）"><a href="#53-以下关于-K-近邻算法的说法，正确的有-（）" class="headerlink" title="53. 以下关于 K 近邻算法的说法，正确的有:（）"></a>53. 以下关于 K 近邻算法的说法，正确的有:（）</h4><p>A. K 值越小，模型越容易过拟合</p><p>B. K 值越大，模型越容易欠拟合</p><p>C. 该算法的时间复杂度较高</p><p>D. 该算法对数据的尺度比较敏感</p><p><strong>答案: ABCD</strong></p><h4 id="54-以下关于集成学习的方法，正确的有-（）"><a href="#54-以下关于集成学习的方法，正确的有-（）" class="headerlink" title="54. 以下关于集成学习的方法，正确的有:（）"></a>54. 以下关于集成学习的方法，正确的有:（）</h4><p>A. Bagging 方法通过自助采样得到多个训练集，训练多个弱学习器</p><p>B. Boosting 方法通过迭代训练多个弱学习器，每个弱学习器关注前一个弱学习器的错误样本</p><p>C. Stacking 方法将多个弱学习器的输出作为新的特征，再训练一个元学习器</p><p>D. 集成学习一定能提高模型的性能</p><p><strong>答案: ABC</strong></p><h4 id="55-以下关于深度学习的说法，正确的有-（）"><a href="#55-以下关于深度学习的说法，正确的有-（）" class="headerlink" title="55. 以下关于深度学习的说法，正确的有:（）"></a>55. 以下关于深度学习的说法，正确的有:（）</h4><p>A. 深度学习通常使用大规模的数据集进行训练</p><p>B. 深度学习模型通常具有很多层</p><p>C. 深度学习可以自动学习数据中的特征</p><p>D. 深度学习只适用于图像和语音领域</p><p><strong>答案: ABC</strong></p><h4 id="56-以下哪些是逻辑回归的特点-（）"><a href="#56-以下哪些是逻辑回归的特点-（）" class="headerlink" title="56. 以下哪些是逻辑回归的特点?（）"></a>56. 以下哪些是逻辑回归的特点?（）</h4><p>A. 用于分类问题</p><p>B. 输出是概率值</p><p>C. 可以处理多分类问题</p><p>D. 模型具有线性决策边界</p><p><strong>答案: ABCD</strong></p><h4 id="57-以下关于聚类算法的说法，正确的有-（）"><a href="#57-以下关于聚类算法的说法，正确的有-（）" class="headerlink" title="57. 以下关于聚类算法的说法，正确的有:（）"></a>57. 以下关于聚类算法的说法，正确的有:（）</h4><p>A. K 均值聚类是基于距离的聚类算法</p><p>B. DBSCAN 是基于密度的聚类算法</p><p>C. 层次聚类可以构建聚类的层次结构</p><p>D. 高斯混合模型聚类是基于概率模型的聚类方法</p><p><strong>答案: ABCD</strong></p><h4 id="58-以下哪些方法可以用于处理类别不平衡问题-（）"><a href="#58-以下哪些方法可以用于处理类别不平衡问题-（）" class="headerlink" title="58. 以下哪些方法可以用于处理类别不平衡问题?（）"></a>58. 以下哪些方法可以用于处理类别不平衡问题?（）</h4><p>A. 过采样</p><p>B. 欠采样</p><p>C. 调整分类阈值</p><p>D. 使用代价敏感学习</p><p><strong>答案: ABCD</strong></p><h4 id="59-以下关于梯度下降法的说法，正确的有-（）"><a href="#59-以下关于梯度下降法的说法，正确的有-（）" class="headerlink" title="59. 以下关于梯度下降法的说法，正确的有:（）"></a>59. 以下关于梯度下降法的说法，正确的有:（）</h4><p>A. 批量梯度下降(BGD)使用所有训练样本进行参数更新</p><p>B. 随机梯度下降(SGD)每次只使用一个训练样本进行参数更新</p><p>C. 小批量梯度下降(MBGD)使用一部分训练样本进行参数更新</p><p>D. 梯度下降法的目标是最小化损失函数</p><p><strong>答案: ABCD</strong></p><h4 id="60-下列哪些是机器学习的常见应用领域（）"><a href="#60-下列哪些是机器学习的常见应用领域（）" class="headerlink" title="60. 下列哪些是机器学习的常见应用领域（）"></a>60. 下列哪些是机器学习的常见应用领域（）</h4><p>A. 图像识别</p><p>B. 自然语言处理</p><p>C. 推荐系统</p><p>D. 数据加密</p><p>E. 金融预测</p><p><strong>答案: ABCE</strong></p><h4 id="61-下列哪些是数据预处理的方法（）"><a href="#61-下列哪些是数据预处理的方法（）" class="headerlink" title="61. 下列哪些是数据预处理的方法（）"></a>61. 下列哪些是数据预处理的方法（）</h4><p>A. 缺失值处理</p><p>B. 数据标准化</p><p>C. 特征选择</p><p>D. 数据分类</p><p>E. 数据归一化</p><p><strong>答案: ABE</strong></p><h4 id="62-下列哪些是监督学习算法（）"><a href="#62-下列哪些是监督学习算法（）" class="headerlink" title="62. 下列哪些是监督学习算法（）"></a>62. 下列哪些是监督学习算法（）</h4><p>A. 线性回归</p><p>B. 决策树</p><p>C. 支持向量机</p><p>D. K 均值聚类</p><p>E. 逻辑回归</p><p><strong>答案: ABCE</strong></p><h4 id="63-下列哪些是评估模型性能的指标（）"><a href="#63-下列哪些是评估模型性能的指标（）" class="headerlink" title="63. 下列哪些是评估模型性能的指标（）"></a>63. 下列哪些是评估模型性能的指标（）</h4><p>A. 准确率</p><p>B. 精确率</p><p>C. 召回率</p><p>D. F1 分数</p><p>E. 相关系数</p><p><strong>答案: ABCD</strong></p><h4 id="64-下列哪些是特征工程的常用方法（）"><a href="#64-下列哪些是特征工程的常用方法（）" class="headerlink" title="64. 下列哪些是特征工程的常用方法（）"></a>64. 下列哪些是特征工程的常用方法（）</h4><p>A. 特征缩放</p><p>B. 特征编码</p><p>C. 特征选择</p><p>D. 特征组合</p><p>E. 数据标准化</p><p><strong>答案: ABCD</strong></p><h4 id="65-下列哪些是集成学习算法（）"><a href="#65-下列哪些是集成学习算法（）" class="headerlink" title="65. 下列哪些是集成学习算法（）"></a>65. 下列哪些是集成学习算法（）</h4><p>A. 决策树集成</p><p>B. 随机森林</p><p>C. AdaBoost</p><p>D. bagging</p><p>E. 支持向量机</p><p><strong>答案: ABCD</strong></p><h4 id="66-下列哪些是过拟合的解决方法（）"><a href="#66-下列哪些是过拟合的解决方法（）" class="headerlink" title="66. 下列哪些是过拟合的解决方法（）"></a>66. 下列哪些是过拟合的解决方法（）</h4><p>A. 增加数据量</p><p>B. 正则化</p><p>C. 减少模型复杂度</p><p>D. 增加模型参数</p><p>E. 交叉验证</p><p><strong>答案: ABCE</strong></p><h4 id="67-下列哪些是降维方法（）"><a href="#67-下列哪些是降维方法（）" class="headerlink" title="67. 下列哪些是降维方法（）"></a>67. 下列哪些是降维方法（）</h4><p>A. 主成分分析</p><p>B. 因子分析</p><p>C. 线性判别分析</p><p>D. K 均值聚类</p><p>E. 基于矩阵分解的方法</p><p><strong>答案: ABCE</strong></p><h4 id="68-下列哪些是数据挖掘的步骤（）"><a href="#68-下列哪些是数据挖掘的步骤（）" class="headerlink" title="68. 下列哪些是数据挖掘的步骤（）"></a>68. 下列哪些是数据挖掘的步骤（）</h4><p>A. 数据收集</p><p>B. 数据预处理</p><p>C. 模型训练</p><p>D. 模型评估</p><p>E. 数据可视化</p><p><strong>答案: ABCDE</strong></p><h4 id="69-下列哪些是特征选择的方法（）"><a href="#69-下列哪些是特征选择的方法（）" class="headerlink" title="69. 下列哪些是特征选择的方法（）"></a>69. 下列哪些是特征选择的方法（）</h4><p>A. 单变量特征选择</p><p>B. 基于模型的特征选择</p><p>C. 递归特征消除</p><p>D. 岭回归</p><p>E. Lasso 回归</p><p><strong>答案: ABCE</strong></p><h4 id="70-下列哪些是常用的特征工程方法（）"><a href="#70-下列哪些是常用的特征工程方法（）" class="headerlink" title="70. 下列哪些是常用的特征工程方法（）"></a>70. 下列哪些是常用的特征工程方法（）</h4><p>A. 特征缩放</p><p>B. 特征编码</p><p>C. 特征选择</p><p>D. 特征组合</p><p>E. 数据归一化</p><p><strong>答案: ABCDE</strong></p><h4 id="71-下列哪些是评估分类模型性能的指标（）"><a href="#71-下列哪些是评估分类模型性能的指标（）" class="headerlink" title="71. 下列哪些是评估分类模型性能的指标（）"></a>71. 下列哪些是评估分类模型性能的指标（）</h4><p>A. 准确率</p><p>B. 精确率</p><p>C. 召回率</p><p>D. F1 分数</p><p>E. 相关系数</p><p><strong>答案: ABCD</strong></p><h4 id="72-下列哪些是集成学习算法（）"><a href="#72-下列哪些是集成学习算法（）" class="headerlink" title="72. 下列哪些是集成学习算法（）"></a>72. 下列哪些是集成学习算法（）</h4><p>A. 决策树集成</p><p>B. 随机森林</p><p>C. AdaBoost</p><p>D. bagging</p><p>E. 支持向量机</p><p><strong>答案: ABCD</strong></p><h4 id="73-下列哪些是过拟合的解决方法（）"><a href="#73-下列哪些是过拟合的解决方法（）" class="headerlink" title="73. 下列哪些是过拟合的解决方法（）"></a>73. 下列哪些是过拟合的解决方法（）</h4><p>A. 增加数据量</p><p>B. 正则化</p><p>C. 减少模型复杂度</p><p>D. 增加模型参数</p><p>E. 交叉验证</p><p><strong>答案: ABCE</strong></p><h4 id="74-下列哪些是降维方法（）"><a href="#74-下列哪些是降维方法（）" class="headerlink" title="74. 下列哪些是降维方法（）"></a>74. 下列哪些是降维方法（）</h4><p>A. 主成分分析</p><p>B. 因子分析</p><p>C. 线性判别分析</p><p>D. K 均值聚类</p><p>E. 基于矩阵分解的方法</p><p><strong>答案: ABCE</strong></p><h4 id="75-下列哪些是监督学习算法（）"><a href="#75-下列哪些是监督学习算法（）" class="headerlink" title="75. 下列哪些是监督学习算法（）"></a>75. 下列哪些是监督学习算法（）</h4><p>A. 线性回归</p><p>B. 决策树</p><p>C. 支持向量机</p><p>D. K 均值聚类</p><p>E. 逻辑回归</p><p><strong>答案: ABCE</strong></p><h4 id="76-下列哪些是数据预处理的方法（）"><a href="#76-下列哪些是数据预处理的方法（）" class="headerlink" title="76. 下列哪些是数据预处理的方法（）"></a>76. 下列哪些是数据预处理的方法（）</h4><p>A. 缺失值处理</p><p>B. 数据标准化</p><p>C. 特征选择</p><p>D. 数据分类</p><p>E. 数据归一化</p><p><strong>答案: ABE</strong></p><h4 id="77-下列哪些是特征选择的方法（）"><a href="#77-下列哪些是特征选择的方法（）" class="headerlink" title="77. 下列哪些是特征选择的方法（）"></a>77. 下列哪些是特征选择的方法（）</h4><p>A. 单变量特征选择</p><p>B. 基于模型的特征选择</p><p>C. 递归特征消除</p><p>D. 岭回归</p><p>E. Lasso 回归</p><p><strong>答案: ABCE</strong></p><h4 id="78-下列哪些是数据挖掘的步骤（）"><a href="#78-下列哪些是数据挖掘的步骤（）" class="headerlink" title="78. 下列哪些是数据挖掘的步骤（）"></a>78. 下列哪些是数据挖掘的步骤（）</h4><p>A. 数据收集</p><p>B. 数据预处理</p><p>C. 模型训练</p><p>D. 模型评估</p><p>E. 数据可视化</p><p><strong>答案: ABCDE</strong></p><h4 id="79-下列哪些是常用的交叉验证方法（）"><a href="#79-下列哪些是常用的交叉验证方法（）" class="headerlink" title="79. 下列哪些是常用的交叉验证方法（）"></a>79. 下列哪些是常用的交叉验证方法（）</h4><p>A. 留出法</p><p>B. K 折交叉验证</p><p>C. 移动窗口交叉验证</p><p>D. 留一法</p><p>E. 分层交叉验证</p><p><strong>答案: ABCDE</strong></p><h4 id="80-以下属于监督学习任务的有-（）"><a href="#80-以下属于监督学习任务的有-（）" class="headerlink" title="80. 以下属于监督学习任务的有:（）"></a>80. 以下属于监督学习任务的有:（）</h4><p>A. 图像分类</p><p>B. 语音识别</p><p>C. 聚类分析</p><p>D. 回归分析</p><p><strong>答案: ABD</strong></p><h4 id="81-以下哪些方法可以用于降低过拟合风险-（）"><a href="#81-以下哪些方法可以用于降低过拟合风险-（）" class="headerlink" title="81. 以下哪些方法可以用于降低过拟合风险?（）"></a>81. 以下哪些方法可以用于降低过拟合风险?（）</h4><p>A. 增加训练数据</p><p>B. 正则化</p><p>C. 早停法</p><p>D. 减少特征数量</p><p><strong>答案: ABCD</strong></p><h4 id="82-以下关于支持向量机-SVM-的说法，正确的有-（）"><a href="#82-以下关于支持向量机-SVM-的说法，正确的有-（）" class="headerlink" title="82. 以下关于支持向量机(SVM)的说法，正确的有:（）"></a>82. 以下关于支持向量机(SVM)的说法，正确的有:（）</h4><p>A. SVM 可以处理线性可分和线性不可分的数据</p><p>B. 核函数是 SVM 处理线性不可分数据的关键</p><p>C. SVM 的目标是找到一个最大间隔超平面</p><p>D. SVM 对异常值不敏感</p><p><strong>答案: ABC</strong></p><h4 id="83-以下属于无监督学习算法的有-（）"><a href="#83-以下属于无监督学习算法的有-（）" class="headerlink" title="83. 以下属于无监督学习算法的有:（）"></a>83. 以下属于无监督学习算法的有:（）</h4><p>A. 主成分分析(PCA)</p><p>B. 高斯混合模型(GMM)</p><p>C. 决策树</p><p>D. 自编码器</p><p><strong>答案: ABD</strong></p><h4 id="84-以下哪些是评估分类模型性能的指标-（）"><a href="#84-以下哪些是评估分类模型性能的指标-（）" class="headerlink" title="84. 以下哪些是评估分类模型性能的指标?（）"></a>84. 以下哪些是评估分类模型性能的指标?（）</h4><p>A. 准确率</p><p>B. 召回率</p><p>C. F1 值</p><p>D. 均方误差</p><p><strong>答案: ABC</strong></p><h4 id="85-以下关于随机森林的说法，正确的有-（）"><a href="#85-以下关于随机森林的说法，正确的有-（）" class="headerlink" title="85. 以下关于随机森林的说法，正确的有:（）"></a>85. 以下关于随机森林的说法，正确的有:（）</h4><p>A. 随机森林是由多个决策树组成的集成模型</p><p>B. 随机森林可以并行训练多个决策树</p><p>C. 随机森林对缺失值和异常值不敏感</p><p>D. 随机森林只能用于分类问题</p><p><strong>答案: ABC</strong></p><h4 id="86-以下哪些方法可以用于数据降维-（）"><a href="#86-以下哪些方法可以用于数据降维-（）" class="headerlink" title="86. 以下哪些方法可以用于数据降维?（）"></a>86. 以下哪些方法可以用于数据降维?（）</h4><p>A. 主成分分析(PCA)</p><p>B. 线性判别分析(LDA)</p><p>C. 特征选择</p><p>D. 奇异值分解(SVD)</p><p><strong>答案: ABCD</strong></p><h4 id="87-以下关于-K-近邻算法的说法，正确的有-（）"><a href="#87-以下关于-K-近邻算法的说法，正确的有-（）" class="headerlink" title="87. 以下关于 K 近邻算法的说法，正确的有:（）"></a>87. 以下关于 K 近邻算法的说法，正确的有:（）</h4><p>A. K 值越小，模型越容易过拟合</p><p>B. K 值越大，模型越容易欠拟合</p><p>C. 该算法的时间复杂度较高</p><p>D. 该算法对数据的尺度比较敏感</p><p><strong>答案: ABCD</strong></p><h4 id="88-以下关于集成学习的方法，正确的有-（）"><a href="#88-以下关于集成学习的方法，正确的有-（）" class="headerlink" title="88. 以下关于集成学习的方法，正确的有:（）"></a>88. 以下关于集成学习的方法，正确的有:（）</h4><p>A. Bagging 方法通过自助采样得到多个训练集，训练多个弱学习器</p><p>B. Boosting 方法通过迭代训练多个弱学习器，每个弱学习器关注前一个弱学习器的错误样本</p><p>C. Stacking 方法将多个弱学习器的输出作为新的特征，再训练一个元学习器</p><p>D. 集成学习一定能提高模型的性能</p><p><strong>答案: ABC</strong></p><h4 id="89-以下关于深度学习的说法，正确的有-（）"><a href="#89-以下关于深度学习的说法，正确的有-（）" class="headerlink" title="89. 以下关于深度学习的说法，正确的有:（）"></a>89. 以下关于深度学习的说法，正确的有:（）</h4><p>A. 深度学习通常使用大规模的数据集进行训练</p><p>B. 深度学习模型通常具有很多层</p><p>C. 深度学习可以自动学习数据中的特征</p><p>D. 深度学习只适用于图像和语音领域</p><p><strong>答案: ABC</strong></p><h4 id="90-以下哪些是逻辑回归的特点-（）"><a href="#90-以下哪些是逻辑回归的特点-（）" class="headerlink" title="90. 以下哪些是逻辑回归的特点?（）"></a>90. 以下哪些是逻辑回归的特点?（）</h4><p>A. 用于分类问题</p><p>B. 输出是概率值</p><p>C. 可以处理多分类问题</p><p>D. 模型具有线性决策边界</p><p><strong>答案: ABCD</strong></p><h4 id="91-以下关于聚类算法的说法，正确的有-（）"><a href="#91-以下关于聚类算法的说法，正确的有-（）" class="headerlink" title="91. 以下关于聚类算法的说法，正确的有:（）"></a>91. 以下关于聚类算法的说法，正确的有:（）</h4><p>A. K 均值聚类是基于距离的聚类算法</p><p>B. DBSCAN 是基于密度的聚类算法</p><p>C. 层次聚类可以构建聚类的层次结构</p><p>D. 高斯混合模型聚类是基于概率模型的聚类方法</p><p><strong>答案: ABCD</strong></p><h4 id="92-以下哪些方法可以用于处理类别不平衡问题-（）"><a href="#92-以下哪些方法可以用于处理类别不平衡问题-（）" class="headerlink" title="92. 以下哪些方法可以用于处理类别不平衡问题?（）"></a>92. 以下哪些方法可以用于处理类别不平衡问题?（）</h4><p>A. 过采样</p><p>B. 欠采样</p><p>C. 调整分类阈值</p><p>D. 使用代价敏感学习</p><p><strong>答案: ABCD</strong></p><p><strong>141、SVM 算法的性能取决于（ ）。</strong></p><p>A. 核函数的选择</p><p>B. 核函数的参数</p><p>C. 软间隔参数</p><p>D. 以上所有</p><p><strong>正确答案：D</strong></p><p><strong>142、SVM 中的代价参数 C 表示什么？（ ）</strong></p><p>A. 在分类准确性和模型复杂度之间的权衡</p><p>B. 交叉验证的次数</p><p>C. 以上都不对</p><p>D. 用到的核函数</p><p><strong>正确答案：A</strong></p><p><strong>143、下列有关支持向量机说法不正确的是（ ）。</strong></p><p>A. 得到的是局部最优解</p><p>B. 具有很好的推广能力</p><p>C. 是凸二次优化问题</p><p>D. 采用结构风险最小化原理</p><p><strong>正确答案：A</strong></p><p><strong>144、下列有关核函数不正确的是（ ）。</strong></p><p>A. 可以采用 cross-validation 方法选择最佳核函数</p><p>B. 满足 Mercer 条件的函数不一定能作为支持向量机的核函数</p><p>C. 极大地提高了学习机器的非线性处理能力</p><p>D. 函数与非线性映射并不是一一对应的关系</p><p><strong>正确答案：B</strong></p><p><strong>145、一对一法分类器，k 个类别需要多少个 SVM（ ）。</strong></p><p>A. k(k-1)/2</p><p>B. k(k-1)</p><p>C. k</p><p>D. k!</p><p><strong>正确答案：A</strong></p><p><strong>146、有关聚类分析说法错误的是（ ）。</strong></p><p>A. 无须有标记的样本</p><p>B. 可以用于提取一些基本特征</p><p>C. 可以解释观察数据的一些内部结构和规律</p><p>D. 聚类分析一个簇中的数据之间具有高差异性</p><p><strong>正确答案：D</strong></p><p><strong>147、两个 n 维向量 𝛼(𝑥11, 𝑥12, ⋯ , 𝑥1𝑛) 和 𝛽(𝑥21, 𝑥22, ⋯ , 𝑥2𝑛)之间的欧式距离（euclidean distance)为（ ）。</strong></p><p>A. 𝑑12 = √(𝛼 − 𝛽)(𝛼 − 𝛽)^𝑇</p><p>B. 𝑑12 = ∑ |𝑥1𝑘 − 𝑥2𝑘|</p><p>C. 𝑑12 = max(|𝑥1𝑖 − 𝑥2𝑖|)</p><p>D. cos(𝜃) = (𝛼 ∙ 𝛽)/(|𝛼||𝛽|)</p><p><strong>正确答案：A</strong></p><p><strong>148、闵可夫斯基距离表示为曼哈顿距离时 p 为（ ）。</strong></p><p>A. 1</p><p>B. 2</p><p>C. 3</p><p>D. 4</p><p><strong>正确答案：A</strong></p><p><strong>149、关于 K-means 说法不正确的是（ ）。</strong></p><p>A. 算法可能终止于局部最优解</p><p>B. 簇的数目 k 必须事先给定</p><p>C. 对噪声和离群点数据敏感</p><p>D. 适合发现非凸形状的簇</p><p><strong>正确答案：D</strong></p><p><strong>150、k 中心点算法每次迭代的计算复杂度是多少？（ ）</strong></p><p>A. 𝑂(1)</p><p>B. 𝑂(𝑘)</p><p>C. 𝑂(𝑛𝑘)</p><p>D. 𝑂(𝑘(𝑛 − 𝑘)^2)</p><p><strong>正确答案：D</strong></p><h2 id="概率与贝叶斯相关题目"><a href="#概率与贝叶斯相关题目" class="headerlink" title="概率与贝叶斯相关题目"></a>概率与贝叶斯相关题目</h2><p><strong>151、假设某事件发生的概率为 p，则此事件发生的几率为（ ）。</strong></p><p>A. p</p><p>B. 1-p</p><p>C. p/(1-p)</p><p>D. (1-p)/p</p><p><strong>正确答案：C</strong></p><p><strong>152、贝叶斯网络起源于贝叶斯统计学，是以（ ）为基础的有向图模型，它为处理不确定知识提供了有效的方法。</strong></p><p>A. 线性代数</p><p>B. 逻辑学</p><p>C. 概率论</p><p>D. 信息论</p><p><strong>正确答案：C</strong></p><p><strong>164. 在机器学习中，交叉验证的目的是：</strong></p><p>A. 减少训练时间</p><p>B. 增加模型复杂度</p><p>C. 减少过拟合</p><p>D. 增加模型的泛化能力</p><p><strong>答案：C</strong></p><p><strong>165. 以下关于 K 近邻算法的说法，错误的是：</strong></p><p>A. K 值的选择对算法性能影响很大</p><p>B. 算法的计算复杂度主要取决于特征维度</p><p>C. 该算法不需要进行显式的训练过程</p><p>D. 算法的预测结果可能会受到样本分布的影响</p><p><strong>答案：B</strong></p><p><strong>解析：</strong> K 近邻算法的计算复杂度主要取决于样本数量，而不是特征维度。K 值的选择会影响算法的性能，K 值过小容易过拟合，K 值过大容易欠拟合；该算法不需要进行显式的训练，直接利用训练数据进行预测；样本分布也会影响预测结果。</p><p><strong>166. 决策树中，信息增益是通过以下哪种方式计算的？</strong></p><p>A. 父节点的信息熵减去子节点的信息熵</p><p>B. 子节点的信息熵减去父节点的信息熵</p><p>C. 父节点的信息熵减去各子节点信息熵的加权和</p><p>D. 各子节点信息熵的加权和减去父节点的信息熵</p><p><strong>答案：C</strong></p><p><strong>解析：</strong> 信息增益的计算公式为父节点的信息熵减去各子节点信息熵的加权和，用于衡量划分前后信息的减少程度，信息增益越大，划分越有效。</p><p><strong>167. 支持向量机（SVM）的目标是：</strong></p><p>A. 最大化分类间隔</p><p>B. 最小化分类间隔</p><p>C. 最大化训练误差</p><p>D. 最小化特征维度</p><p><strong>答案：A</strong></p><p><strong>解析：</strong> 支持向量机的目标是在特征空间中找到一个最优的超平面，使得不同类别的样本之间的分类间隔最大，这样可以提高模型的泛化能力。</p><p><strong>168. 以下哪种聚类算法是基于密度的聚类算法？</strong></p><p>A. K 均值聚类</p><p>B. 层次聚类</p><p>C. DBSCAN</p><p>D. 高斯混合模型聚类</p><p><strong>答案：C</strong></p><p><strong>解析：</strong> DBSCAN 是基于密度的聚类算法，它通过寻找数据点的密度相连区域来进行聚类。K 均值聚类是基于距离的聚类算法，通过迭代更新聚类中心；层次聚类是通过构建层次结构进行聚类；高斯混合模型聚类是基于概率模型的聚类方法。</p><p><strong>229、SVM 的原理的简单描述，可概括为：</strong></p><p>A. 最小均方误差分类</p><p>B. 最小距离分类</p><p>C. 最大间隔分类</p><p>D. 最近邻分类</p><p><strong>答案：C</strong></p><p><strong>230、SVM 的算法性能取决于：</strong></p><p>A. 核函数的选择</p><p>B. 核函数的参数</p><p>C. 软间隔参数 C</p><p>D. 以上所有</p><p><strong>答案：D</strong></p><p><strong>231、支持向量机的对偶问题是：</strong></p><p>A. 线性优化问题</p><p>B. 二次优化</p><p>C. 凸二次优化</p><p>D. 有约束的线性优化</p><p><strong>答案：C</strong></p><p><strong>232、以下对支持向量机中的支撑向量描述正确的是：</strong></p><p>A. 最大特征向量</p><p>B. 最优投影向量</p><p>C. 最大间隔支撑面上的向量</p><p>D. 最速下降方向</p><p><strong>答案：C</strong></p><p><strong>233、假定你使用阶数为 2 的线性核 SVM，将模型应用到实际数据集上后，其训练准确率和测试准确率均为 100%。现在增加模型复杂度（增加核函数的阶），会发生以下哪种情况：</strong></p><p>A. 过拟合</p><p>B. 欠拟合</p><p>C. 什么都不会发生，因为模型准确率已经到达极限</p><p>D. 以上都不对</p><p><strong>答案：A</strong></p><p><strong>234、避免直接的复杂非线性变换，采用线性手段实现非线性学习的方法是：</strong></p><p>A. 核函数方法</p><p>B. 集成学习</p><p>C. 决策树</p><p>D. Logistic 回归</p><p><strong>答案：A</strong></p><p><strong>235、关于决策树节点划分指标描述正确的是：</strong></p><p>A. 类别非纯度越大越好</p><p>B. 信息增益越大越好</p><p>C. 信息增益率越小越好</p><p>D. 基尼指数越大越好</p><p><strong>答案：B</strong></p><p><strong>236、以下描述中，属于决策树策略的是：</strong></p><p>A. 最优投影方向</p><p>B. 梯度下降方法</p><p>C. 最大特征值</p><p>D. 最大信息增益</p><p><strong>答案：D</strong></p><p><strong>237、集成学习中基分类器的选择如何，学习效率通常越好：</strong></p><p>A. 分类器相似</p><p>B. 都为线性分类器</p><p>C. 都为非线性分类器</p><p>D. 分类器多样，差异大</p><p><strong>答案：D</strong></p><p><strong>238、集成学习中，每个基分类器的正确率的最低要求：</strong></p><p>A. 50% 以上</p><p>B. 60% 以上</p><p>C. 70% 以上</p><p>D. 80% 以上</p><p><strong>答案：A</strong></p><p><strong>239、下面属于 Bagging 方法的特点是：</strong></p><p>A. 构造训练集时采用 Bootstraping 的方式</p><p>B. 每一轮训练时样本权重不同</p><p>C. 分类器必须按顺序训练</p><p>D. 预测结果时，分类器的比重不同</p><p><strong>答案：A</strong></p><p><strong>240、下面属于 Boosting 方法的特点是：</strong></p><p>A. 构造训练集时采用 Bootstraping 的方式</p><p>B. 每一轮训练时样本权重相同</p><p>C. 分类器可以并行训练</p><p>D. 预测结果时，分类器的比重不同</p><p><strong>答案：D</strong></p><p><strong>241、随机森林方法属于：</strong></p><p>A. 梯度下降优化</p><p>B. Bagging 方法</p><p>C. Boosting 方法</p><p>D. 线性分类</p><p><strong>答案：B</strong></p><p><strong>242、假定有一个数据集 S，但该数据集有很多误差，采用软间隔 SVM 训练，阈值为 C，如果 C 的值很小，以下那种说法正确：</strong></p><p>A. 会发生误分类现象</p><p>B. 数据将被正确分类</p><p>C. 不确定</p><p>D. 以上都不对</p><p><strong>答案：A</strong></p><p><strong>243、软间隔 SVM 的阈值趋于无穷，下面哪种说法正确：</strong></p><p>A. 只要最佳分类超平面存在，它就能将所有数据全部正确分类</p><p>B. 软间隔 SVM 分类器将正确分类数据</p><p>C. 会发生误分类现象</p><p>D. 以上都不对</p><p><strong>答案：A</strong></p><p><strong>244、一般，K-NN 最近邻方法在什么情况下效果好：</strong></p><p>A. 样本较多但典型性不好</p><p>B. 样本较少但典型性较好</p><p>C. 样本呈团状分布</p><p>D. 样本呈链状分布</p><p><strong>答案：B</strong></p><p><strong>注：</strong> 最近邻属于分类算法，样本多而且典型性不好容易造成分类错误（尤其是在分类边界上的样本点）。样本分布对聚类算法的影响较大。</p><p><strong>245、混合高斯聚类中，运用了以下哪种过程：</strong></p><p>A. EM 算法</p><p>B. 集合运算</p><p>C. 密度可达</p><p>D. 样本与集合运算</p><p><strong>答案：A</strong></p><p><strong>246、主成分分析方法是一种什么方法：</strong></p><p>A. 分类方法</p><p>B. 回归方法</p><p>C. 降维方法</p><p>D. 参数估计方法</p><p><strong>答案：C</strong></p><p><strong>247、过拟合现象中：</strong></p><p>A. 训练样本的测试误差最小，测试样本的正确识别率却很低</p><p>B. 训练样本的测试误差最小，测试样本的正确识别率也很高</p><p>C. 模型的泛化能力很高</p><p>D. 通常为线性模型</p><p><strong>答案：A</strong></p><p><strong>248、已知均值和方差，下面哪种分布的熵最大：</strong></p><p>A. 几何分布</p><p>B. 指数分布</p><p>C. 高斯分布</p><p>D. 均匀分布</p><p><strong>答案：C</strong></p><p><strong>249、梯度下降算法的正确步骤是什么：</strong></p><p>(1)计算预测值和真实值之间的误差</p><p>(2)迭代更新，直到找到最佳权重</p><p>(3)把输入传入网络，得到输出值</p><p>(4)初始化随机权重和偏差</p><p>(5)对每一个产生误差的神经元，改变相应的（权重）值以减小误差</p><p>A. 1,2,3,4,5</p><p>B. 4,3,1,5,2</p><p>C. 3,2,1,5,4</p><p>D. 5,4,3,2,1</p><p><strong>答案：B</strong></p><p><strong>250、以下哪种方法会增加模型的欠拟合风险：</strong></p><p>A. 添加新特征</p><p>B. 增加模型复杂度</p><p>C. 减小正则化系数</p><p>D. 数据增强</p><p><strong>答案：D</strong></p><p><strong>251、关于 k-means 算法，正确的描述是：</strong></p><p>A. 能找到任意形状的聚类</p><p>B. 初始值不同，最终结果可能不同</p><p>C. 每次迭代的时间复杂度是 O(n^2)，其中 n 是样本数量</p><p>D. 不能使用核函数</p><p><strong>答案：B</strong></p><p><strong>252、下列关于过拟合现象的描述中，哪个是正确的：</strong></p><p>A. 训练误差小，测试误差大</p><p>B. 训练误差小，测试误差小</p><p>C. 模型的泛化能力高</p><p>D. 其余选项都不对</p><p><strong>答案：A</strong></p><p><strong>253、下方法中属于无监督学习算法的是：</strong></p><p>A. 线性回归</p><p>B. 支持向量机</p><p>C. 决策树</p><p>D. K-Means 聚类</p><p><strong>答案：D</strong></p><p><strong>254、下面关于贝叶斯分类器描述错误的是：</strong></p><p>A. 以贝叶斯定理为基础</p><p>B. 是基于后验概率，推导出先验概率</p><p>C. 可以解决有监督学习的问题</p><p>D. 可以用极大似然估计法解贝叶斯分类器</p><p><strong>答案：B</strong></p><p><strong>255、下面关于 Adaboost 算法的描述中，错误的是：</strong></p><p>A. 是弱分类器的线性组合</p><p>B. 提升树是以分类树或者回归树为基本分类器的提升办法</p><p>C. 该算法实际上是前向分步算法的一个实现，在这个方法里，模型是加法模型，损失函数是指数损失，算法是前向分步算法。</p><p>D. 同时独立地学习多个弱分类器</p><p><strong>答案：D</strong></p><p><strong>256、二分类任务中，有三个分类器 h1, h2, h3，三个测试样本 x1, x2, x3。假设 1 表示分类结果正确，0 表示错误，h1 在 x1, x2, x3 的结果分别 (1,1,0)，h2, h3 分别为 (0,1,1), (1,0,1)，按投票法集成三个分类器，下列说法正确的是：</strong></p><p>A. 集成提高了性能</p><p>B. 集成没有效果</p><p>C. 集成降低了性能</p><p>D. 集成效果不能确定</p><p><strong>答案：A</strong></p><p><strong>257、下列哪个不属于常用的文本分类的特征选择算法：</strong></p><p>A. 卡方检验值</p><p>B. 互信息</p><p>C. 信息增益</p><p>D. 主成分分析</p><p><strong>答案：D</strong></p><p><strong>258、以下哪个模型不是分类模型：</strong></p><p>A. 最近邻</p><p>B. K 均值</p><p>C. 朴素贝叶斯</p><p>D. 逻辑回归</p><p><strong>答案：B</strong></p><p>262、机器学习进行的第一步是（）</p><p>A. 数据收集</p><p>B. 特征提取</p><p>C. 交叉验证</p><p>D. 模型训练</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>机器学习流程的第一步是<strong>数据收集</strong>，因为所有后续步骤（如特征提取、模型训练）都依赖于数据。没有数据，机器学习无法进行。特征提取是数据预处理的一部分，属于后续步骤。</p><p>264、如果一个样本空间线性可分，那么，我们能找到（）个平面来划分样本。</p><p>A. 1</p><p>B. 无数</p><p>C. K</p><p>D. 不确定</p><p><strong>正确答案</strong>：B</p><p><strong>解析</strong>：<br>线性可分时，存在无数个分离超平面。只要超平面不越过样本点，稍微平移或旋转仍能保持分类正确。</p><p>265、向量 <code>x=[1,2,3,4,-9,0]</code>的 L1 范数是多少</p><p>A. 1</p><p>B. 19</p><p>C. 6</p><p>D. 20</p><p><strong>正确答案</strong>：B</p><p><strong>解析</strong>：<br>L1 范数是各元素绝对值之和：</p><script type="math/tex; mode=display">\|x\|_1=|1|+|2|+|3|+|4|+|-9|+|0|=19</script><p>266、向量 X=[1,2,3,4,-9,0] 的 L2 范数为（ ）</p><p>A. 1</p><p>B. 19</p><p>C. 6</p><p>D. √111</p><p><strong>正确答案</strong>：D</p><p><strong>解析</strong>：<br>L2 范数是各元素平方和的平方根：</p><script type="math/tex; mode=display">\|x\|_2=\sqrt{1^2+2^2+3^2+4^2+(-9)^2+0^2}=\sqrt{111}</script><p>267、一般，k-NN 最近邻方法在（ ）的情况下效果较好</p><p>A. 样本较多但典型性不好</p><p>B. 样本较少但典型性好</p><p>C. 样本呈团状分布</p><p>D. 样本呈链状分布</p><p><strong>正确答案</strong>：B</p><p><strong>解析</strong>：<br>KNN 依赖局部相似性，样本少但典型性好时，最近邻投票更可靠。团状分布是理想假设，但”少而典型”是更根本的前提。</p><p>268、以下哪些方法不可以直接来对文本分类？</p><p>A. K-Means</p><p>B. 决策树</p><p>C. 支持向量机</p><p>D. kNN</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>K-Means 是无监督聚类算法，不依赖标签，无法直接用于分类。其他选项均为有监督分类算法。</p><p>269、以下说法错误的一项是</p><p>A. 负梯度方向是使函数值下降最快的方向</p><p>B. 当目标函数是凸函数时，梯度下降法的解是全局最优解</p><p>C. 梯度下降法比牛顿法收敛速度快</p><p>D. 拟牛顿法不需要计算 Hesse 矩阵</p><p><strong>正确答案</strong>：C</p><p><strong>解析</strong>：<br>牛顿法（二阶）在最优解附近收敛速度（二次）快于梯度下降法（线性）。C 选项表述错误。</p><p>270、下列说法错误的是？</p><p>A. 当目标函数是凸函数时，梯度下降算法的解一般就是全局最优解</p><p>B. 进行 PCA 降维时，需要计算协方差矩阵</p><p>C. 沿负梯度的方向一定是最优的方向</p><p>D. 利用拉格朗日函数能解带约束的优化问题</p><p><strong>正确答案</strong>：C</p><p><strong>解析</strong>：<br>负梯度方向是局部下降最快方向，但非全局最优（可能产生锯齿现象）。其他选项正确。</p><p>271、交叉验证方法执行时间排序（样本量 1000）</p><p>A. 1 &gt; 2 &gt; 3 &gt; 4</p><p>B. 2 &gt; 3 &gt; 4 &gt; 1</p><p>C. 4 &gt; 1 &gt; 2 &gt; 3</p><p>D. 2 &gt; 4 &gt; 3 &gt; 1</p><p><strong>正确答案</strong>：D</p><p><strong>解析</strong>：<br>时间开销：</p><ul><li>留一法（1000 次训练）最慢（2）</li><li>重复两次 5 折（10 次训练）次慢（4）</li><li>5 折（5 次训练）较快（3）</li><li>Bootstrap（1 次训练）最快（1）<br>排序：2 &gt; 4 &gt; 3 &gt; 1</li></ul><p>273、下面哪句话是正确</p><p>A. 机器学习模型的精准度越高，则模型的性能越好</p><p>B. 增加模型的复杂度，总能减小测试样本误差</p><p>C. 增加模型的复杂度，总能减小训练样本误差</p><p>D. 以上说法都不对</p><p><strong>正确答案</strong>：C</p><p><strong>解析</strong>：<br>增加复杂度会提升模型拟合能力，训练误差通常减小（可能过拟合）。A 错（需综合评估），B 错（测试误差可能增大）。</p><p>274、集成学习中，下列说法正确的是？</p><p>A. 基本模型之间相关性高</p><p>B. 基本模型之间相关性低</p><p>C. 集成方法中，使用加权平均代替投票方法</p><p>D. 基本模型都来自于同一算法</p><p><strong>正确答案</strong>：B</p><p><strong>解析</strong>：<br>集成学习要求基模型”好而不同”，低相关性使错误相互纠正，提升泛化能力。</p><p>275、SVM 训练后只保留支持向量是否影响分类能力？</p><p>A. 正确</p><p>B. 错误</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>支持向量决定了分离超平面，非支持向量不影响模型，这是 SVM 的稀疏性。</p><p>276、Soft-SVM 中如何保证线性可分？</p><p>A. C = 0</p><p>B. C = 1</p><p>C. C 正无穷大</p><p>D. C 负无穷大</p><p><strong>正确答案</strong>：C</p><p><strong>解析</strong>：<br>C 趋于无穷大时，对分类错误的惩罚无限大，迫使所有样本分类正确（退化为硬间隔）。</p><p>278、点击率预测（99%负样本）中，正确率 99%说明？</p><p>A. 模型正确率很高，不需要优化模型了</p><p>B. 模型正确率并不高，应该建立更好的模型</p><p>C. 无法对模型做出好坏评价</p><p>D. 以上说法都不对</p><p><strong>正确答案</strong>：B</p><p><strong>解析</strong>：<br>极端不平衡时，将所有样本预测为负类即可达到 99%准确率，模型未学到区分能力，需优化。</p><p>279、关于 k 折交叉验证，下列说法正确的是？</p><p>A. k 值并不是越大越好，k 值过大，会降低运算速度</p><p>B. 选择更大的 k 值，会让偏差更小，因为 k 值越大，训练集越接近整个训练样本</p><p>C. 选择合适的 k 值，能减小验证方差</p><p>D. 以上说法都正确</p><p><strong>正确答案</strong>：D</p><p><strong>解析</strong>：<br>A、B、C 均正确：k 过大计算开销大；k 大时训练集接近全集，偏差小；合适 k 可平衡偏差-方差。</p><p>289、EM 算法的核心思想是？</p><p>A. 通过不断地求取目标函数的下界的最优值，从而实现最优化的目标</p><p>B. 列出优化目标函数，通过方法计算出最优值</p><p>C. 列出优化目标函数，通过数值优化方法计算出最优值</p><p>D. 列出优化目标函数，通过坐标下降的优化方法计算出最优值</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>EM 算法通过 E 步构造下界、M 步最大化下界，迭代逼近最优解。</p><p>291、SVM 中的代价参数 C 表示什么？</p><p>A. 在分类准确性和模型复杂度之间的权衡</p><p>B. 交叉验证的次数</p><p>C. 以上都不对</p><p>D. 用到的核函数</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>C 控制误分类惩罚与模型复杂度（间隔大小）的权衡：C 越大，越倾向正确分类（可能过拟合）。</p><p>293、下列有关核函数不正确的是</p><p>A. 可以采用 cross-validation 方法选择最佳核函数</p><p>B. 满足 Mercer 条件的函数不一定能作为支持向量机的核函数</p><p>C. 极大地提高了学习机器的非线性处理能力</p><p>D. 函数与非线性映射并不是一一对应的关系</p><p><strong>正确答案</strong>：B</p><p><strong>解析</strong>：<br>核函数必须满足 Mercer 条件才能用于 SVM。B 选项错误，反过来说才成立。</p><p>298、关于 K-means 说法不正确的是</p><p>A. 算法可能终止于局部最优解</p><p>B. 簇的数目 k 必须事先给定</p><p>C. 对噪声和离群点数据敏感</p><p>D. 适合发现非凸形状的簇</p><p><strong>正确答案</strong>：D</p><p><strong>解析</strong>：<br>K-means 假设簇呈凸形（球形），对非凸形状（如流形、环状）效果差。</p><p>300、同质集成中的个体学习器亦称</p><p>A. 组件学习器</p><p>B. 基学习器</p><p>C. 异质学习器</p><p>D. 同质学习器</p><p><strong>正确答案</strong>：B</p><p><strong>解析</strong>：<br>同质集成中，相同类型的个体学习器称为基学习器。</p><p>302、关于 logistic 回归和 SVM 不正确的是</p><p>A. Logistic 回归目标函数是最小化后验概率</p><p>B. Logistic 回归可以用于预测事件发生概率的大小</p><p>C. SVM 可以有效避免模型过拟合</p><p>D. SVM 目标是结构风险最小化</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>Logistic 回归通过最大似然估计参数，目标是得到后验概率的估计值，而非最小化后验概率。</p><p>303、下面关于 SVM 算法叙述不正确的是</p><p>A. SVM 是一种基于经验风险最小化准则的算法</p><p>B. SVM 求得的解为全局唯一最优解</p><p>C. SVM 在解决小样本、非线性及高维模式识别问题中具有优势</p><p>D. SVM 最终分类结果只与少数支持向量有关</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>SVM 目标是结构风险最小化（间隔最大化+误差惩罚），而非单纯经验风险最小化。</p><p>305、下列中为生成模型的是</p><p>A. 决策树</p><p>B. 支持向量机 SVM</p><p>C. K 近邻</p><p>D. 贝叶斯分类器</p><p><strong>正确答案</strong>：D</p><p><strong>解析</strong>：<br>生成模型对联合概率 P(X,Y)建模（如朴素贝叶斯），判别模型直接对 P(Y|X)或决策边界建模（其他选项）。</p><p>308、距离度量不需要满足的特性是</p><p>A. 非负性</p><p>B. 同一性</p><p>C. 对称性</p><p>D. 递增性</p><p><strong>正确答案</strong>：D</p><p><strong>解析</strong>：<br>距离度量需满足非负性、同一性、对称性、三角不等式，无需”递增性”。</p><p>315、朴素贝叶斯利用了</p><p>A. 先验概率</p><p>B. 后验概率</p><p>C. 以上都是</p><p>D. 以上都不是</p><p><strong>正确答案</strong>：C</p><p><strong>解析</strong>：<br>朴素贝叶斯基于贝叶斯定理，利用先验概率 P(Y)和似然 P(X|Y)计算后验概率 P(Y|X)。</p><p>317、模型评估的常用方法有哪些</p><p>A. 留出法</p><p>B. 交叉验证法</p><p>C. 自助法</p><p>D. 以上都是</p><p><strong>正确答案</strong>：D</p><p><strong>解析</strong>：<br>留出法、交叉验证、自助法均为常用模型评估方法。</p><p>321、关于 EM 算法正确的是</p><p>A. EM 算法包括两步：E 算法和 M 算法</p><p>B. EM 算法一定能收敛到全局最大值点</p><p>C. 英文全称是 Expectation-Minimization</p><p>D. 以上都不正确</p><p><strong>正确答案</strong>：A</p><p><strong>解析</strong>：<br>EM 算法包括 E 步（期望）和 M 步（最大化）。B 错（可能收敛到局部最优），C 错（全称 Expectation-Maximization）。</p><p>在构建决策树时，以下哪些可以作为分裂节点的选择标准？（ ）<br>A. 信息增益 B. 基尼指数 C. 均方误差 D. 准确率<br>答案：A</p><p>以下关于交叉验证的说法正确的是（ ）<br>A. 可以有效评估模型的泛化能力 B. 常见的有 K - 折交叉验证 C. 能避免数据划分的随机性影响 D. 只适用于小数据集<br>答案：AB</p><p>155、以下哪些算法是无监督学习算法?<br>A.空间聚类 149 B.主成分分析 C.支持向量机 D.Q-LEARNING<br>正确答案：A、B</p><p>156、以下哪些算法是监督学习算法?<br>A.人工神经网络 B.高斯混合模型概率密度估计 C.ACTOR-CRITIC 算法 D.支持向量机<br>正确答案：A、D</p><p>157、当我们利用二分类支持向量机来解决多分类问题是，我们有哪两种策略？ （）<br>A.一类对另一类 B.一类对 K-1 类 C.一类对 K 类 D.2 类对 K-2 类<br>正确答案：A、B<br>159、核函数满足的两个条件（）。<br>A.交换性 B.正交性 C.鲁棒性 D.半正定性<br>正确答案：A、D</p><p>135、直观上看，我们希望“物以类聚”，即聚类的结果“簇内相似度”⾼，且 “簇间”相似度低。（√）<br>136、关于 EM 算法的收敛性，EM 算法理论上不能够保证收敛。（×）<br>137、关于 EM 算法的用途，EM 算法只适用不完全数据的情形。（×）</p><p>138、Jessen 不等式等号成立的条件是：变量为常数。 正确答案：√<br>139、Jessen 不等式 E(f(x)) &gt;= f(E(x)), 左边部分大于等于右边部分的条件 是函数 f 是凸函数，如果 f 是凹函数，左边部分应该是小于等于右边部分。 正确答案：√ 140、EM 算法因为是理论可以保证收敛的，所以肯定能够取得最优解。（×</p><p>143、EM 算法通常不需要设置步长，而且收敛速度一般很快。 正确答案：√ 144、吉布斯采样是一种通用的采样方法，对于任何概率分布都可以采样出对应 的样本。（×）</p><p>136、关于 EM 算法的收敛性，EM 算法理论上不能够保证收敛。（×）<br>137、关于 EM 算法的用途，EM 算法只适用不完全数据的情形。（×）<br>138、Jessen 不等式等号成立的条件是：变量为常数。 正确答案：√</p><p>139、Jessen 不等式 E(f(x)) &gt;= f(E(x)), 左边部分大于等于右边部分的条件 是函数 f 是凸函数，如果 f 是凹函数，左边部分应该是小于等于右边部分。 正确答案：√</p><p>140、EM 算法因为是理论可以保证收敛的，所以肯定能够取得最优解。（×）</p><p>141、EM 算法首先猜测每个数据来自哪个高斯分布，然后求取每个高斯的参 数，之后再去重新猜测每个数据来自哪个高斯分布，类推进一步迭代，直到收 敛，从而得到最后的参数估计值。 正确答案：√</p><p>142、EM 算法，具有通用的求解形式，因此对任何问题，其求解过程都是一 样，都能很容易求得结果。（×）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;应付期末考试，整理了一些题目&lt;/p&gt;
&lt;h4 id=&quot;1-以下哪些是机器学习中的数据预处理步骤-（）&quot;&gt;&lt;a href=&quot;#1-以下哪些是机器学习中的数据预处理步骤-（）&quot; class=&quot;headerlink&quot; title=&quot;1. 以下哪些是机器学习中的数据预处理</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-07-机器学习相关算法</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/11390.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/11390.html</id>
    <published>2026-01-07T18:28:13.000Z</published>
    <updated>2026-01-09T13:29:39.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="评估方法（留出法）"><a href="#评估方法（留出法）" class="headerlink" title="评估方法（留出法）"></a>评估方法（留出法）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_test_split</span>(<span class="hljs-params">X,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">5</span></span>):<br>    random.seed(random_state)<br>    n_samples = <span class="hljs-built_in">len</span>(X)<br>    indices = np.arange(n_samples)<br>    train_indexs = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(random.sample(indices.tolist(),<span class="hljs-built_in">int</span>(n_samples*(<span class="hljs-number">1</span>-test_size)))))<br>    test_indexs = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> indices <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> train_indexs]<br>    <span class="hljs-keyword">return</span> X[train_indexs],X[test_indexs]<br><br><br>test_size = <span class="hljs-number">0.2</span><br>X = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>])<br>train_X,test_X = train_test_split(X,test_size=test_size)<br><span class="hljs-built_in">print</span>(train_X,test_X)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(test_X) == <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(X)*test_size))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br></code></pre></td></tr></table></figure><h3 id="评估方法（交叉验证法）"><a href="#评估方法（交叉验证法）" class="headerlink" title="评估方法（交叉验证法）"></a>评估方法（交叉验证法）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">KFold</span>(<span class="hljs-params">X,n_splits,is_shuffle=<span class="hljs-literal">True</span>,random_state=<span class="hljs-number">0</span></span>):<br>    random.seed(random_state)<br>    n_samples = <span class="hljs-built_in">len</span>(X)<br><br>    indices = np.arange(n_samples)<br><br>    train_index = []<br>    test_index = []<br>    result = []<br>    fold_sizes = np.full(n_splits,n_samples//n_splits,dtype=np.<span class="hljs-built_in">int</span>)<br>    fold_sizes[:n_samples%n_splits] += <span class="hljs-number">1</span><br>    current = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fold_size <span class="hljs-keyword">in</span> fold_sizes:<br>        start, stop = current, current+fold_size<br>        test_index = indices[start:stop]<br>        train_index = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(indices)-<span class="hljs-built_in">set</span>(indices[start:stop]))<br>        current = stop<br>        result.append([X[train_index],X[test_index]])<br>    <span class="hljs-keyword">return</span> result<br><br>X = np.array([<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().strip().split()])<br>n_splits = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>result = KFold(X,n_splits)<br><br><br><span class="hljs-keyword">for</span> S,T <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(S,T)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br>res = []<br><span class="hljs-keyword">for</span> _,T <span class="hljs-keyword">in</span> result:<br>    res += <span class="hljs-built_in">list</span>(T)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">set</span>(res)==<span class="hljs-built_in">set</span>(<span class="hljs-built_in">list</span>(X)) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(X)==<span class="hljs-built_in">len</span>(res):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br></code></pre></td></tr></table></figure><h3 id="优化算法-梯度下降法-1"><a href="#优化算法-梯度下降法-1" class="headerlink" title="优化算法-梯度下降法 1"></a>优化算法-梯度下降法 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func_1d_test1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x**<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_1d_test1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func_1d_test2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x**<span class="hljs-number">2</span> - <span class="hljs-number">4</span>*x +<span class="hljs-number">14</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_1d_test2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span>-<span class="hljs-number">4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradient_descent_1d</span>(<span class="hljs-params">grad, cur_x=<span class="hljs-number">0.1</span>, learning_rate=<span class="hljs-number">0.01</span>, precision=<span class="hljs-number">0.0001</span>, max_iters=<span class="hljs-number">10000</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_iters):<br>        grad_cur = grad(cur_x)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(grad_cur) &lt; precision:<br>            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 当梯度趋近为 0 时，视为收敛</span><br>        cur_x = cur_x - grad_cur * learning_rate<br><br>    <span class="hljs-keyword">return</span> cur_x<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"%.7f"</span> %gradient_descent_1d(grad_1d_test1, cur_x=<span class="hljs-number">10</span>, learning_rate=<span class="hljs-number">0.2</span>, precision=<span class="hljs-number">0.0001</span>, max_iters=<span class="hljs-number">10000</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"%.7f"</span> %gradient_descent_1d(grad_1d_test2, cur_x=<span class="hljs-number">10</span>, learning_rate=<span class="hljs-number">0.2</span>, precision=<span class="hljs-number">0.0001</span>, max_iters=<span class="hljs-number">10000</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br><br>test()<br></code></pre></td></tr></table></figure><h2 id="优化算法-梯度下降法-2"><a href="#优化算法-梯度下降法-2" class="headerlink" title="优化算法-梯度下降法 2"></a>优化算法-梯度下降法 2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func_2d_test1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> - math.exp(-(x[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_2d_test1</span>(<span class="hljs-params">x</span>):<br>    deriv0 = <span class="hljs-number">2</span> * x[<span class="hljs-number">0</span>] * math.exp(-(x[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>))<br>    deriv1 = <span class="hljs-number">2</span> * x[<span class="hljs-number">1</span>] * math.exp(-(x[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">return</span> np.array([deriv0, deriv1])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func_2d_test2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> +<span class="hljs-number">2</span>*x[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_2d_test2</span>(<span class="hljs-params">x</span>):<br>    deriv0 = <span class="hljs-number">2</span>*x[<span class="hljs-number">0</span>]+<span class="hljs-number">2</span><br>    deriv1 = <span class="hljs-number">2</span>*x[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> np.array([deriv0,deriv1])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradient_descent_2d</span>(<span class="hljs-params">grad, cur_x=np.array(<span class="hljs-params">[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>]</span>), learning_rate=<span class="hljs-number">0.01</span>, precision=<span class="hljs-number">0.0001</span>, max_iters=<span class="hljs-number">10000</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_iters):<br>        grad_cur = grad(cur_x)<br>        <span class="hljs-keyword">if</span> np.linalg.norm(grad_cur, <span class="hljs-built_in">ord</span>=<span class="hljs-number">2</span>) &lt; precision:<br>            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 当梯度趋近为 0 时，视为收敛</span><br>        cur_x = cur_x - grad_cur * learning_rate<br><br><br>    <span class="hljs-keyword">return</span> cur_x<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    res = gradient_descent_2d(grad_2d_test1, cur_x=np.array([<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]), learning_rate=<span class="hljs-number">0.2</span>, precision=<span class="hljs-number">0.0001</span>, max_iters=<span class="hljs-number">10000</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"%.7f %.7f"</span> %(res[<span class="hljs-number">0</span>],res[<span class="hljs-number">1</span>]) )<br>    res2 = gradient_descent_2d(grad_2d_test2, cur_x=np.array([<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]), learning_rate=<span class="hljs-number">0.2</span>, precision=<span class="hljs-number">0.0001</span>, max_iters=<span class="hljs-number">10000</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"%.7f %.7f"</span> %(res2[<span class="hljs-number">0</span>],res2[<span class="hljs-number">1</span>]) )<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br><br>test()<br></code></pre></td></tr></table></figure><h2 id="线性回归-糖尿病预测"><a href="#线性回归-糖尿病预测" class="headerlink" title="线性回归-糖尿病预测"></a>线性回归-糖尿病预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span>  warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_diabetes</span>():<br>    X = []<br>    y = []<br>    line = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">while</span> line:<br>        dx = []<br>        data = [l <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> line.strip().split(<span class="hljs-string">','</span>)]<br>        X.append(np.array([np.<span class="hljs-built_in">float</span>(d) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data[:-<span class="hljs-number">1</span>]]))<br>        y.append(np.<span class="hljs-built_in">float</span>(data[-<span class="hljs-number">1</span>]))<br>        line = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">return</span> np.array(X),np.array(y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_test_split</span>(<span class="hljs-params">X,Y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">2333</span></span>):<br>    random.seed(random_state)<br>    n_samples = <span class="hljs-built_in">len</span>(X)<br>    indices = np.arange(n_samples)<br>    train_indexs = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(random.sample(indices.tolist(),<span class="hljs-built_in">int</span>(n_samples*(<span class="hljs-number">1</span>-test_size)))))<br>    test_indexs = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> indices <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> train_indexs]<br>    <span class="hljs-keyword">return</span> X[train_indexs],X[test_indexs],Y[train_indexs],Y[test_indexs]<br><br>X,y = load_diabetes()<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span>  warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_diabetes</span>():<br>    X = []<br>    y = []<br>    line = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">while</span> line:<br>        dx = []<br>        data = [l <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> line.strip().split(<span class="hljs-string">','</span>)]<br>        X.append(np.array([np.<span class="hljs-built_in">float</span>(d) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data[:-<span class="hljs-number">1</span>]]))<br>        y.append(np.<span class="hljs-built_in">float</span>(data[-<span class="hljs-number">1</span>]))<br>        line = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">return</span> np.array(X),np.array(y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_test_split</span>(<span class="hljs-params">X,Y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">2333</span></span>):<br>    random.seed(random_state)<br>    n_samples = <span class="hljs-built_in">len</span>(X)<br>    indices = np.arange(n_samples)<br>    train_indexs = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(random.sample(indices.tolist(),<span class="hljs-built_in">int</span>(n_samples*(<span class="hljs-number">1</span>-test_size)))))<br>    test_indexs = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> indices <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> train_indexs]<br>    <span class="hljs-keyword">return</span> X[train_indexs],X[test_indexs],Y[train_indexs],Y[test_indexs]<br><br>X,y = load_diabetes()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearRegression</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">'''初始化模型'''</span><br>    <span class="hljs-variable language_">self</span>.coef_ = <span class="hljs-literal">None</span><br>    <span class="hljs-variable language_">self</span>.interception_ = <span class="hljs-literal">None</span><br>    <span class="hljs-variable language_">self</span>._theta = <span class="hljs-literal">None</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">fit_normal</span>(<span class="hljs-params">self,X_train,y_train</span>):<br>    <span class="hljs-string">'''根据训练数据集X_train,y_train训练模型'''</span><br>    <span class="hljs-keyword">assert</span> X_train.shape[<span class="hljs-number">0</span>] == y_train.shape[<span class="hljs-number">0</span>],<span class="hljs-string">'the number of X_train must equal to the number of y_train'</span><br>    X_b = np.hstack([np.ones((<span class="hljs-built_in">len</span>(X_train),<span class="hljs-number">1</span>)),X_train])<br>    <span class="hljs-variable language_">self</span>._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train)<br>    <span class="hljs-variable language_">self</span>.interception_ = <span class="hljs-variable language_">self</span>._theta[<span class="hljs-number">0</span>]<br>    <span class="hljs-variable language_">self</span>.coef_ = <span class="hljs-variable language_">self</span>._theta[<span class="hljs-number">1</span>:]<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self,X_predict</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-variable language_">self</span>._theta <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>,<span class="hljs-string">'must fit before predict'</span><br>    <span class="hljs-keyword">assert</span> X_predict.shape[<span class="hljs-number">1</span>] == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.coef_),<span class="hljs-string">'the feature number of X_predict must equal to X_train '</span><br><br>    X_b = np.hstack([np.ones((<span class="hljs-built_in">len</span>(X_predict),<span class="hljs-number">1</span>)),X_predict])<br>    <span class="hljs-keyword">return</span> X_b.dot(<span class="hljs-variable language_">self</span>._theta)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mse</span>(<span class="hljs-params">self,y,y_pre</span>):<br>    <span class="hljs-keyword">return</span> np.average((y-y_pre)**<span class="hljs-number">2</span>)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">rmse</span>(<span class="hljs-params">self,y,y_pre</span>):<br>    <span class="hljs-keyword">return</span> np.sqrt(<span class="hljs-variable language_">self</span>.mse(y,y_pre))<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">r2_score</span>(<span class="hljs-params">self,y,y_pre</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>-(<span class="hljs-variable language_">self</span>.mse(y,y_pre)/np.var(y))<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self,X_test,y_test</span>):<br>    <span class="hljs-string">'''根据测试数据集确定当前模型的准确度'''</span><br>    y_predict = <span class="hljs-variable language_">self</span>.predict(X_test)<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.r2_score(y_test,y_predict),<span class="hljs-variable language_">self</span>.rmse(y_test,y_predict)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'LinearRegression()'</span><br><br>x_train,x_test,y_train,y_test = train_test_split(X,y)<br><br>reg = LinearRegression()<br>reg.fit_normal(x_train,y_train)<br>r2,rmse = reg.score(x_test,y_test)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">rmse,r2</span>):<br>    <span class="hljs-keyword">if</span> rmse&gt;<span class="hljs-number">50</span> <span class="hljs-keyword">or</span> r2&gt;<span class="hljs-number">0.5</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br>test(rmse,r2)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">rmse,r2</span>):<br>    <span class="hljs-keyword">if</span> rmse&gt;<span class="hljs-number">50</span> <span class="hljs-keyword">or</span> r2&gt;<span class="hljs-number">0.5</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br>test(rmse,r2)<br><br></code></pre></td></tr></table></figure><h2 id="逻辑回归-乳腺癌预测"><a href="#逻辑回归-乳腺癌预测" class="headerlink" title="逻辑回归-乳腺癌预测"></a>逻辑回归-乳腺癌预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_breast_cancer</span>():<br>    X = []<br>    y = []<br>    line = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">while</span> line:<br>        dx = []<br>        data = [np.float64(l) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> line.strip().split(<span class="hljs-string">','</span>)]<br>        X.append(np.array(data[:-<span class="hljs-number">1</span>]))<br>        y.append(<span class="hljs-built_in">int</span>(data[-<span class="hljs-number">1</span>]))<br>        line = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">return</span> np.array(X),np.array(y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_test_split</span>(<span class="hljs-params">X,Y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">5</span></span>):<br>    n_samples = <span class="hljs-built_in">len</span>(X)<br>    indices = np.arange(n_samples)<br>    train_indexs = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(random.sample(indices.tolist(),<span class="hljs-built_in">int</span>(n_samples*(<span class="hljs-number">1</span>-test_size)))))<br>    test_indexs = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> indices <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> train_indexs]<br>    <span class="hljs-keyword">return</span> X[train_indexs],X[test_indexs],Y[train_indexs],Y[test_indexs]<br><br>X,y = load_breast_cancer()<br>x_train,x_test,y_train,y_test = train_test_split(X,y)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logisticregression</span>():<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, learn_rate = <span class="hljs-number">0.001</span>, max_iteration=<span class="hljs-number">10000</span></span>):<br><br>        <span class="hljs-variable language_">self</span>.learn_rate = learn_rate<br>        <span class="hljs-variable language_">self</span>.max_iteration = max_iteration<br>        <span class="hljs-variable language_">self</span>._X_train = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._y_train = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._w = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fit</span>(<span class="hljs-params">self, X_train, y_train</span>):<br><br>        m_samples, n_features = X_train.shape<br>        <span class="hljs-variable language_">self</span>._X_train = np.insert(X_train, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, axis=<span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>._y_train = np.reshape(y_train, (m_samples, <span class="hljs-number">1</span>))<br>        limit = np.sqrt(<span class="hljs-number">1</span> / n_features)<br>        w = np.random.uniform(-limit, limit, (n_features, <span class="hljs-number">1</span>))<br>        b = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.w = np.insert(w, <span class="hljs-number">0</span>, b, axis=<span class="hljs-number">0</span>)<br>        iteration = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> iteration &lt; <span class="hljs-variable language_">self</span>.max_iteration:<br>            h_x = <span class="hljs-variable language_">self</span>._X_train.dot(<span class="hljs-variable language_">self</span>.w)<br>            y_pred = <span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+np.exp(- h_x))<br>            w_grad = <span class="hljs-variable language_">self</span>._X_train.T.dot(y_pred - <span class="hljs-variable language_">self</span>._y_train)<br>            <span class="hljs-variable language_">self</span>.w = <span class="hljs-variable language_">self</span>.w - <span class="hljs-variable language_">self</span>.learn_rate * w_grad<br>            iteration = iteration + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, X_test</span>):<br><br>        X_test = np.insert(X_test, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, axis=<span class="hljs-number">1</span>)<br>        h_x = X_test.dot(<span class="hljs-variable language_">self</span>.w)<br>        y_pripr_1 = (<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+np.exp(-h_x)))<br>        y_pripr_0 = <span class="hljs-number">1</span> - y_pripr_1<br>        y_cal = y_pripr_1 - y_pripr_0<br>        y_class = np.where(y_cal &gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> y_class<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self, X_test, y_test</span>):<br><br>        j = <span class="hljs-number">0</span><br>        y_test = np.reshape(y_test,(<span class="hljs-built_in">len</span>(y_test),<span class="hljs-number">1</span>))<br>        y_hat = <span class="hljs-variable language_">self</span>.predict(X_test)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(y_test.shape[<span class="hljs-number">0</span>]):<br>            <span class="hljs-keyword">if</span> y_hat[i,<span class="hljs-number">0</span>] == y_test[i,<span class="hljs-number">0</span>]:<br>                j += <span class="hljs-number">1</span><br>        acc = j / <span class="hljs-built_in">len</span>(y_test)<br>        y_test = <span class="hljs-built_in">list</span>(y_test.reshape((<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>])<br>        y_hat = <span class="hljs-built_in">list</span>(y_hat.reshape((<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>])<br><br>        precision = <span class="hljs-variable language_">self</span>.get_precision(y_test,y_hat)<br>        recall = <span class="hljs-variable language_">self</span>.get_recall(y_test,y_hat)<br>        auc = <span class="hljs-variable language_">self</span>.get_auc(y_test,y_hat)<br>        <span class="hljs-keyword">return</span> acc,precision,recall,auc<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_precision</span>(<span class="hljs-params">self,y,y_hat</span>):<br>        true_positive = <span class="hljs-built_in">sum</span>(yi <span class="hljs-keyword">and</span> yi_hat <span class="hljs-keyword">for</span> yi,yi_hat <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(y,y_hat))<br>        predicted_positive = <span class="hljs-built_in">sum</span>(y_hat)<br>        <span class="hljs-keyword">return</span> true_positive/predicted_positive<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_recall</span>(<span class="hljs-params">self,y,y_hat</span>):<br>        true_positive = <span class="hljs-built_in">sum</span>(yi <span class="hljs-keyword">and</span> yi_hat <span class="hljs-keyword">for</span> yi,yi_hat <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(y,y_hat))<br>        actual_positive = <span class="hljs-built_in">sum</span>(y)<br>        <span class="hljs-keyword">return</span> true_positive/actual_positive<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tnr</span>(<span class="hljs-params">self,y,y_hat</span>):<br>        true_negative = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>-(yi <span class="hljs-keyword">or</span> yi_hat) <span class="hljs-keyword">for</span> yi,yi_hat <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(y,y_hat))<br>        actual_negative = <span class="hljs-built_in">len</span>(y) - <span class="hljs-built_in">sum</span>(y)<br>        <span class="hljs-keyword">return</span> true_negative/actual_negative<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_roc</span>(<span class="hljs-params">self,y,y_hat</span>):<br>        thresholds = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(y_hat),reverse=<span class="hljs-literal">True</span>)<br>        ret = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">for</span> threshold <span class="hljs-keyword">in</span> thresholds:<br>            y_hat = [<span class="hljs-built_in">int</span>(yi_hat &gt;= threshold) <span class="hljs-keyword">for</span> yi_hat <span class="hljs-keyword">in</span> y_hat]<br>            ret.append([<span class="hljs-variable language_">self</span>.get_recall(y,y_hat),<span class="hljs-number">1</span>-<span class="hljs-variable language_">self</span>.get_tnr(y,y_hat)])<br>        <span class="hljs-keyword">return</span> ret<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_auc</span>(<span class="hljs-params">self,y,y_hat</span>):<br>        roc = <span class="hljs-built_in">iter</span>(<span class="hljs-variable language_">self</span>.get_roc(y,y_hat))<br>        tpr_pre, fpr_pre = <span class="hljs-built_in">next</span>(roc)<br>        auc = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> tpr,fpr <span class="hljs-keyword">in</span> roc:<br>            auc += (tpr+tpr_pre)*(fpr-fpr_pre)/<span class="hljs-number">2</span><br>            tpr_pre = tpr<br>            fpr_pre = fpr<br>        <span class="hljs-keyword">return</span> auc<br><br>lr = Logisticregression()<br>lr.fit(x_train,y_train)<br>acc,precision,recall,auc = lr.score(x_test,y_test)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">acc,auc</span>):<br>    <span class="hljs-keyword">if</span> acc&gt;<span class="hljs-number">0.8</span> <span class="hljs-keyword">or</span> auc&gt;<span class="hljs-number">0.8</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br>test(acc,auc)<br><br></code></pre></td></tr></table></figure><h2 id="svm-手写数字识别"><a href="#svm-手写数字识别" class="headerlink" title="svm-手写数字识别"></a>svm-手写数字识别</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span>  warnings<br><span class="hljs-keyword">import</span> random<br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_digits</span>():<br>    X = []<br>    y = []<br>    line = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">while</span> line:<br>        dx = []<br>        data = [l <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> line.strip().split(<span class="hljs-string">','</span>)]<br>        X.append(np.array([np.<span class="hljs-built_in">float</span>(d) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data[:-<span class="hljs-number">1</span>]]))<br>        y.append(np.<span class="hljs-built_in">int</span>(data[-<span class="hljs-number">1</span>]))<br>        line = <span class="hljs-built_in">input</span>()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">'#'</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> np.array(X),np.array(y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_test_split</span>(<span class="hljs-params">X,Y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">5</span></span>):<br>    n_samples = <span class="hljs-built_in">len</span>(X)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(X)==<span class="hljs-built_in">len</span>(Y)<br><br>    indices = np.arange(n_samples)<br>    random.seed(random_state)<br><br>    train_indexs = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(random.sample(indices.tolist(),<span class="hljs-built_in">int</span>(n_samples*(<span class="hljs-number">1</span>-test_size)))))<br>    test_indexs = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> indices <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> train_indexs]<br>    <span class="hljs-keyword">return</span> X[train_indexs,:],X[test_indexs,:],Y[train_indexs],Y[test_indexs]<br><br>X,y = load_digits()<br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.5</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SVC</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,X,Y,alpha,steps,reg</span>):<br>        <span class="hljs-variable language_">self</span>.X = X<br>        <span class="hljs-variable language_">self</span>.y = Y<br>        <span class="hljs-variable language_">self</span>.alpha = alpha<br>        <span class="hljs-variable language_">self</span>.steps = steps<br>        <span class="hljs-variable language_">self</span>.reg = reg<br>        <span class="hljs-variable language_">self</span>.model(<span class="hljs-variable language_">self</span>.X,<span class="hljs-variable language_">self</span>.y,<span class="hljs-variable language_">self</span>.alpha,<span class="hljs-variable language_">self</span>.steps,<span class="hljs-variable language_">self</span>.reg)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lossAndGradNaive</span>(<span class="hljs-params">self,X,Y,W,reg</span>):<br>        dW=np.zeros(W.shape)<br>        loss = <span class="hljs-number">0.0</span><br>        num_class=W.shape[<span class="hljs-number">0</span>]<br>        num_X=X.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_X):<br>            scores=np.dot(W,X[i])<br>            cur_scores=scores[<span class="hljs-built_in">int</span>(Y[i])]<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_class):<br>                <span class="hljs-keyword">if</span> j==Y[i]:<br>                    <span class="hljs-keyword">continue</span><br>                margin=scores[j]-cur_scores+<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> margin&gt;<span class="hljs-number">0</span>:<br>                    loss+=margin<br>                    dW[j,:]+=X[i]<br>                    dW[<span class="hljs-built_in">int</span>(Y[i]),:]-=X[i]<br>        loss/=num_X<br>        dW/=num_X<br>        loss+=reg*np.<span class="hljs-built_in">sum</span>(W*W)<br>        dW+=<span class="hljs-number">2</span>*reg*W<br>        <span class="hljs-keyword">return</span> loss,dW<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lossAndGradVector</span>(<span class="hljs-params">self,X,Y,W,reg</span>):<br>        dW=np.zeros(W.shape)<br>        N=X.shape[<span class="hljs-number">0</span>]<br>        Y_=X.dot(W.T)<br>        margin=Y_-Y_[<span class="hljs-built_in">range</span>(N),Y.astype(<span class="hljs-built_in">int</span>)].reshape([-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])+<span class="hljs-number">1.0</span><br>        margin[<span class="hljs-built_in">range</span>(N),Y.astype(<span class="hljs-built_in">int</span>)]=<span class="hljs-number">0.0</span><br>        margin=(margin&gt;<span class="hljs-number">0</span>)*margin<br>        loss=<span class="hljs-number">0.0</span><br>        loss+=np.<span class="hljs-built_in">sum</span>(margin)/N<br>        loss+=reg*np.<span class="hljs-built_in">sum</span>(W*W)<br><br>        countsX=(margin&gt;<span class="hljs-number">0</span>).astype(<span class="hljs-built_in">int</span>)<br>        countsX[<span class="hljs-built_in">range</span>(N),Y.astype(<span class="hljs-built_in">int</span>)]=-np.<span class="hljs-built_in">sum</span>(countsX,axis=<span class="hljs-number">1</span>)<br>        dW+=np.dot(countsX.T,X)/N+<span class="hljs-number">2</span>*reg*W<br>        <span class="hljs-keyword">return</span> loss,dW<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self,X,W</span>):<br>        X=np.hstack([X, np.ones((X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>))])<br>        Y_=np.dot(X,W.T)<br>        Y_pre=np.argmax(Y_,axis=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> Y_pre<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">self,X,Y</span>):<br>        Y_pre=<span class="hljs-variable language_">self</span>.predict(X,<span class="hljs-variable language_">self</span>.W)<br>        acc=(Y_pre==Y).mean()<br>        <span class="hljs-keyword">return</span> acc<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">model</span>(<span class="hljs-params">self,X,Y,alpha,steps,reg</span>):<br>        X=np.hstack([X, np.ones((X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>))])<br>        W = np.random.randn(<span class="hljs-number">10</span>,X.shape[<span class="hljs-number">1</span>]) * <span class="hljs-number">0.0001</span><br>        <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(steps):<br>            loss,grad=<span class="hljs-variable language_">self</span>.lossAndGradNaive(X,Y,W,reg)<br>            W-=alpha*grad<br>        <span class="hljs-variable language_">self</span>.W = W<br><br>svc=SVC(X_train,y_train,<span class="hljs-number">0.01</span>,<span class="hljs-number">25</span>,<span class="hljs-number">0.5</span>)<br>acc = svc.accuracy(X_test,y_test)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_acc</span>(<span class="hljs-params">acc</span>):<br>    res = <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> acc&gt;<span class="hljs-number">0.85</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br>    <span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br><br>test_acc(acc)<br></code></pre></td></tr></table></figure><h2 id="svm-梯度下降实现-SVM-多分类问题"><a href="#svm-梯度下降实现-SVM-多分类问题" class="headerlink" title="svm-梯度下降实现 SVM 多分类问题"></a>svm-梯度下降实现 SVM 多分类问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> warnings<br><br><span class="hljs-keyword">def</span>  <span class="hljs-title function_">load_iris</span>():<br>        X  =  []<br>        y  =  []<br>        line  =  <span class="hljs-built_in">input</span>()<br>        <span class="hljs-keyword">while</span>  line:<br>            dx  =  []<br>            data  =  [l  <span class="hljs-keyword">for</span>  l  <span class="hljs-keyword">in</span>  line.strip().split(<span class="hljs-string">','</span>)]<br>            X.append(np.array([np.<span class="hljs-built_in">float</span>(d)  <span class="hljs-keyword">for</span>  d  <span class="hljs-keyword">in</span>  data[:-<span class="hljs-number">1</span>]]))<br>            y.append(np.<span class="hljs-built_in">int</span>(data[-<span class="hljs-number">1</span>]))<br>            line  =  <span class="hljs-built_in">input</span>()<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">'#'</span> <span class="hljs-keyword">in</span> line:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span>  np.array(X),np.array(y)<br><br>x,y = load_iris()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_begin"</span>);<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_acc</span>(<span class="hljs-params">acc</span>):<br>        res = <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> acc&gt;=<span class="hljs-number">0.9</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br>        <span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"debug_end"</span>);<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalize_data</span>(<span class="hljs-params">data</span>):<br>    mean = np.mean(data, axis=<span class="hljs-number">0</span>)<br>    std = np.std(data, axis=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(data.shape[<span class="hljs-number">0</span>]):<br>        data[i, :] = (data[i, :] - mean) / std<br>    <span class="hljs-keyword">return</span>  data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_to_one_hot</span>(<span class="hljs-params">y, C</span>):<br>    <span class="hljs-keyword">return</span> np.eye(C)[y.reshape(-<span class="hljs-number">1</span>)]<br><br>batchsz = <span class="hljs-number">150</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">obtain_w_via_gradient_descent</span>(<span class="hljs-params">x, c, y, penalty_c, threshold = <span class="hljs-number">1e-19</span>, learn_rate = <span class="hljs-number">1e-4</span></span>):<br>    <span class="hljs-string">""" 利用梯度下降法求解如下的SVM问题：min 1/2 * w^T * w + C * Σ_i=1:n（max(0, 1 - y_i * (w^T * x_i + b))）</span><br><span class="hljs-string">    :param x: 训练样本 x = [x_1, x_2, ..., x_i]</span><br><span class="hljs-string">    :param c: 类别数</span><br><span class="hljs-string">    :param y: 样本标签 y = [y_1, y_2, ..., y_c]</span><br><span class="hljs-string">    :param threshold: 梯度下降停止阈值</span><br><span class="hljs-string">    """</span><br>    data_num = np.shape(x)[<span class="hljs-number">1</span>]<br>    feature_dim = np.shape(x)[<span class="hljs-number">0</span>]<br>    w = np.ones([feature_dim, c], dtype=np.float32)<br>    b = np.ones([c, <span class="hljs-number">1</span>], dtype=np.float32)<br>    dl_dw = np.zeros([feature_dim, c], dtype=np.<span class="hljs-built_in">float</span>)<br>    dl_db = np.zeros([c, <span class="hljs-number">1</span>], dtype=np.<span class="hljs-built_in">float</span>)<br>    it = <span class="hljs-number">1</span><br>    th = <span class="hljs-number">0.1</span><br>    <span class="hljs-keyword">while</span> it &lt; <span class="hljs-number">50000</span> <span class="hljs-keyword">and</span> th &gt; threshold:<br>        a = np.tile(b, [<span class="hljs-number">1</span>, data_num])<br>        ksi = (np.transpose(w) @ x + np.tile(b, [<span class="hljs-number">1</span>, data_num])) * y<br>        index_martix = ksi &lt; <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> class_num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c):<br>            index_vector = index_martix[class_num, :]<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">in</span> index_vector:<br>                x_c = x[:, index_vector]<br><br>                data_num_c = np.shape(x_c)[<span class="hljs-number">1</span>]<br>                e = np.ones([data_num_c, <span class="hljs-number">1</span>], dtype=np.<span class="hljs-built_in">float</span>)<br>                y_c = np.reshape(y[class_num, index_vector], [data_num_c, <span class="hljs-number">1</span>])<br>                w_c = np.reshape(w[:, class_num], [feature_dim, <span class="hljs-number">1</span>])<br>                b_c = b[class_num]<br><br>                dl_dw[:, class_num] = (w_c + <span class="hljs-number">2</span> * penalty_c * (x_c @ np.transpose(x_c) @ w_c +<br>                                                              x_c @ e * b_c -<br>                                                              x_c @ y_c))[:, <span class="hljs-number">0</span>]<br>                dl_db[class_num, <span class="hljs-number">0</span>] = <span class="hljs-number">2</span> * penalty_c * (b_c * data_num_c +<br>                                                       np.transpose(w_c) @ x_c @ e -<br>                                                       np.transpose(y_c) @ e)<br>            <span class="hljs-keyword">else</span>:<br>                w_c = np.reshape(w[:, class_num], [feature_dim, <span class="hljs-number">1</span>])<br>                dl_dw[:, class_num] = w_c[:, <span class="hljs-number">0</span>]<br>                dl_db[class_num, <span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        w_ = w - learn_rate * (dl_dw / np.linalg.norm(dl_dw, <span class="hljs-built_in">ord</span>=<span class="hljs-number">2</span>))<br>        b_ = b - learn_rate * dl_db<br><br>        th = np.<span class="hljs-built_in">sum</span>(np.square(w_ - w)) + np.<span class="hljs-built_in">sum</span>(np.square(b_ - b))<br>        it = it + <span class="hljs-number">1</span><br><br>        w = w_<br>        b = b_<br><br>        y_predict = np.transpose(w) @ x + np.tile(b, [<span class="hljs-number">1</span>, data_num])<br>        correct_prediction = np.equal(np.argmax(y_predict, <span class="hljs-number">0</span>), np.argmax(y, <span class="hljs-number">0</span>))<br>        accuracy = np.mean(correct_prediction.astype(np.<span class="hljs-built_in">float</span>))<br><br>    <span class="hljs-keyword">return</span> accuracy<br><br>warnings.filterwarnings(<span class="hljs-string">"ignore"</span>)<br><br>x = normalize_data(x)<br>y = y.astype(np.<span class="hljs-built_in">int</span>)<br>y_onehot = convert_to_one_hot(y,<span class="hljs-number">3</span>)<br>y_onehot[y_onehot==<span class="hljs-number">0</span>]=-<span class="hljs-number">1</span><br><br>x = np.transpose(x)<br>y_onehot = np.transpose(y_onehot)<br>w = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]])<br>b = np.array([[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>]])<br>acc = obtain_w_via_gradient_descent(x,<span class="hljs-number">3</span>,y_onehot,<span class="hljs-number">0.5</span>)<br><br>test_acc(acc)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;评估方法（留出法）&quot;&gt;&lt;a href=&quot;#评估方法（留出法）&quot; class=&quot;headerlink&quot; title=&quot;评估方法（留出法）&quot;&gt;&lt;/a&gt;评估方法（留出法）&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-06-人工智能导论复习</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/64338.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/64338.html</id>
    <published>2026-01-06T19:25:49.000Z</published>
    <updated>2026-01-06T20:26:30.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p><strong>1.1 什么是人类智能？它有哪些特点？</strong></p><ul><li><strong>人类智能</strong>是指人类在认识、适应和改造客观世界的过程中，由一系列核心能力构成的综合性心智功能。其本质在于能<strong>理解、推理、学习</strong>并运用知识解决复杂问题。</li><li><strong>主要特点</strong>：<ol><li><strong>感知与理解</strong>：能通过感官获取信息，并理解其含义。</li><li><strong>学习与适应</strong>：能从经验中学习，更新知识，适应新环境。</li><li><strong>推理与解决问题</strong>：能运用逻辑、归纳、演绎等方法，从已知推知未知，并制定策略解决问题。</li><li><strong>使用语言</strong>：能用复杂的符号系统（语言）进行交流、表达和思考。</li><li><strong>具有意识与能动性</strong>：有自我意识，能进行有目的、有计划的主动行为。</li></ol></li></ul><p><strong>1.2 什么是人工智能？它的发展过程经历了哪些阶段？</strong></p><ul><li><strong>人工智能</strong>是计算机科学的一个分支，旨在<strong>研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统</strong>。其目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作。</li><li><strong>主要发展阶段</strong>：<ol><li><strong>孕育期（1956 年以前）</strong>：数理逻辑、控制论、信息论等理论为 AI 诞生奠定基础。图灵提出“机器能思考吗？”的划时代问题。</li><li><strong>形成与热潮期（1956-1970s 初）</strong>：<strong>1956 年达特茅斯会议</strong>正式提出“人工智能”学科名称。早期在问题求解、定理证明、机器翻译等方面取得突破，乐观情绪高涨。</li><li><strong>知识应用与专家系统时期（1970s-1980s）</strong>：研究者意识到“知识”的重要性，<strong>专家系统</strong>（将人类专家的知识规则化）成为主流，AI 走向商业化应用。</li><li><strong>机器学习兴起与平稳发展期（1980s 末-2010 初）</strong>：随着互联网兴起和数据量增长，以<strong>统计学习</strong>和<strong>神经网络复兴（连接主义）</strong>为代表的机器学习方法成为核心。支持向量机、决策树等方法广泛应用。</li><li><strong>深度学习与大数据驱动期（2010s 至今）</strong>：得益于大数据、强算力（如 GPU）和算法改进（如深度神经网络），<strong>深度学习</strong>在图像识别、自然语言处理等领域取得突破性进展，引发新一轮 AI 热潮。</li></ol></li></ul><p><strong>1.3 人工智能研究的基本内容有哪些？</strong></p><p>根据您图片中的提示并综合常见分类，其基本内容包括：</p><ol><li><strong>知识表示</strong>：研究如何用机器可处理的形式来<strong>表示和存储</strong>人类的知识（如事实、规则）。</li><li><strong>机器感知</strong>：研究如何让机器通过“<strong>感官</strong>”获取外部信息，核心领域包括<strong>计算机视觉</strong>（看）和<strong>语音识别</strong>（听）。</li><li><strong>机器思维</strong>：在感知的基础上，研究如何对信息进行<strong>推理、决策和问题求解</strong>，是 AI 的核心。</li><li><strong>机器学习</strong>：研究如何让机器<strong>自动从数据中学习规律和知识</strong>，从而不断改进性能，是实现人工智能的关键途径。</li><li><strong>自然语言处理</strong>：研究如何实现<strong>人机间的自然语言通信</strong>，包括理解和生成。</li><li><strong>行为主义与智能系统</strong>：研究如何将上述能力综合，构建能对外界环境做出<strong>合理反应和行动</strong>的智能体或机器人。</li></ol><p><strong>1.4 人工智能有哪些主要的研究领域？</strong></p><p>（以下是部分核心与活跃的研究领域）</p><ol><li><strong>机器感知</strong>：计算机视觉、语音识别、多模态感知。</li><li><strong>自然语言处理</strong>：机器翻译、文本理解与生成、对话系统（聊天机器人）。</li><li><strong>机器学习</strong>：深度学习、强化学习、迁移学习、联邦学习。</li><li><strong>知识表示与推理</strong>：知识图谱、自动推理、专家系统。</li><li><strong>机器人学</strong>：环境感知、运动控制、人机协作。</li><li><p><strong>人工智能交叉与应用领域</strong>：</p><ul><li><strong>智能控制</strong>：如智能驾驶。</li><li><strong>智能计算</strong>：演化计算、群智能优化。</li><li><strong>数据挖掘与大数据分析</strong>。</li><li><strong>人工智能与其他学科的交叉</strong>：如生物信息学、计算金融、智慧医疗等。</li></ul></li></ol><hr><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>2.1 什么是知识？它有哪些特性？有哪几种分类方法？</p><p>2.2 什么是知识表示？如何选择知识表示方法？</p><p>2.3 什么是命题？请写出三个真值为 T 及真值为 F 的命题。</p><p>2.4 什么是谓词？什么是谓词个体及个体域？函数与谓词的区别是什么？</p><p>2.5 谓词逻辑和命题逻辑的关系如何？有何异同？</p><p>2.6 什么是谓词的项？什么是谓词的阶？请写出谓词的一般形式。</p><p>2.7 什么是谓词公式？什么是谓词公式的解释？</p><p>2.8 一阶谓词逻辑表示法是结构化知识还是非结构化知识？适合于表示哪种类型的知识？它有哪些特点？</p><p>2.9 请写出用一阶谓词逻辑表示法表示知识的步骤。</p><p>2.10 产生式的基本形式是什么？它与谓词逻辑中蕴涵式有什么共同处和不同处？</p><p>2.11 产生式系统由哪几部分组成？</p><p>2.12 试述产生式系统求解问题的一般步骤。</p><p>2.13 产生式系统中，推理机的推理方式有哪几种？在产生式推理过程中，如果发生策略冲突，如何解决？</p><p>2.14 试述产生式表示法的特点。</p><p>2.15 框架的一般表示形式是什么？</p><p>2.16 框架表示法有何特点？请叙述用框架表示法表示知识的步骤。</p><p>2.17 试构造一个描述读者的办公室或卧室的框架系统。</p><p>2.18 试构造一个描述计算机主机的框架系统。</p><p>2.19 请给出一个知识图谱实例。</p><p>参考答案</p><p><strong>2.1 什么是知识？它有哪些特性？有哪几种分类方法？</strong></p><ul><li><strong>知识</strong>：知识是经过<strong>加工、整理、解释、挑选和改造</strong>的信息，是人们在长期实践中积累的对客观世界的规律性认识。在人工智能中，知识是使机器具备智能的基石。</li><li><strong>特性</strong>：相对正确性（在特定条件下成立）、不确定性、可表示性、可利用性。</li><li><p><strong>分类方法</strong>：</p><ol><li><strong>按作用层次</strong>：事实性知识、过程性知识、控制性知识。</li><li><strong>按确定性</strong>：确定性知识、不确定性知识。</li><li><strong>按表现形式</strong>：显性知识（可编码）、隐性知识（经验、直觉）。</li></ol><p><strong>2.2 什么是知识表示？如何选择知识表示方法？</strong></p></li><li><p><strong>知识表示</strong>：将人类知识<strong>形式化、模型化</strong>，以便计算机能够存储、处理和运用的一套方法和约定。它是数据结构和解释过程的结合。</p></li><li><p><strong>选择依据</strong>：① 充分表示领域知识；② 支持高效推理；③ 便于知识的获取与管理；④ 易于理解、维护。</p><p><strong>2.3 什么是命题？请写出三个真值为 T 及真值为 F 的命题。</strong></p></li><li><p><strong>命题</strong>：一个能判断其<strong>真（T）或假（F）</strong>​ 的陈述句。</p></li><li><p><strong>示例</strong>：</p><ul><li>真命题：北京是中国的首都。1+1=2。太阳从东方升起。</li><li>假命题：2 大于 3。鱼在天上飞。地球是平的。</li></ul><p><strong>2.4 什么是谓词？什么是谓词个体及个体域？函数与谓词的区别是什么？</strong></p></li><li><p><strong>谓词</strong>：用于描述<strong>个体性质</strong>或<strong>个体间关系</strong>的语句成分。例如，“是红色的(x)”描述性质，“朋友(x, y)”描述关系。</p></li><li><strong>个体</strong>：可以独立存在的具体或抽象<strong>对象</strong>（如“小明”、“5”）。</li><li><strong>个体域</strong>：个体所组成的<strong>集合</strong>（讨论范围）。</li><li><p><strong>函数与谓词的区别</strong>：<strong>函数</strong>的返回值是一个<strong>个体</strong>（如 <code>父亲(小明)</code>返回一个人），而<strong>谓词</strong>的返回值是一个<strong>真值</strong>（T 或 F）（如 <code>朋友(小明, 小红)</code>判断真假）。</p><p><strong>2.5 谓词逻辑和命题逻辑的关系如何？有何异同？</strong></p></li><li><p><strong>关系</strong>：命题逻辑是谓词逻辑的基础，谓词逻辑是命题逻辑的<strong>细化和扩展</strong>。</p></li><li><strong>相同点</strong>：都使用逻辑连接词（与、或、非等）和真值运算。</li><li><p><strong>不同点</strong>：</p><ul><li><strong>描述粒度</strong>：命题逻辑以<strong>整个句子</strong>为基本单元，无法分析内部结构。谓词逻辑可分析到<strong>个体、谓词和量词</strong>。</li><li><strong>表达能力</strong>：谓词逻辑能表达“所有”、“存在”等量化的普遍性知识，表达能力<strong>远强于</strong>命题逻辑。</li></ul><p><strong>2.6 什么是谓词的项？什么是谓词的阶？请写出谓词的一般形式。</strong></p></li><li><p><strong>谓词的项</strong>：充当谓词<strong>逻辑自变量的个体</strong>。可以是常量、变量或函数。</p></li><li><strong>谓词的阶</strong>：由项的取值范围决定。<strong>一阶谓词</strong>的项是个体，<strong>二阶谓词</strong>的项可以是谓词或集合。</li><li><p><strong>一般形式</strong>：<code>P(x1, x2, ..., xn)</code>。其中 P 是谓词名，x1~xn 是项。</p><p><strong>2.7 什么是谓词公式？什么是谓词公式的解释？</strong></p></li><li><p><strong>谓词公式</strong>：由谓词、项、逻辑连接词、量词和括号按规则组成的合法符号串，用于表达一个完整的判断。</p></li><li><p><strong>解释</strong>：给谓词公式中的<strong>个体常量、函数符号、谓词符号</strong>赋予具体的含义（指定个体域、对应关系和函数映射），从而确定公式的<strong>真值</strong>。</p><p><strong>2.8 一阶谓词逻辑表示法是结构化知识还是非结构化知识？适合于表示哪种类型的知识？它有哪些特点？</strong></p></li><li><p><strong>结构化/非结构化</strong>：属于<strong>结构化知识</strong>表示。它精确地描述了知识内部的逻辑结构（个体、谓词、量词）。</p></li><li><strong>适合类型</strong>：适合表示<strong>事物的状态、属性、概念</strong>以及<strong>它们之间精确的逻辑关系</strong>。尤其擅长表达“所有 A 都是 B”、“存在某个 A 具有性质 P”这类精确的、能用公式严格定义的事实和规则。</li><li><p><strong>特点</strong>：</p><ul><li><strong>优点</strong>：严密性、精确性、自然性好，接近自然语言和人类思维。</li><li><strong>缺点</strong>：知识粒度细，表示复杂知识时组合爆炸；推理效率相对较低；处理不确定性知识能力弱。</li></ul><p><strong>2.9 请写出用一阶谓词逻辑表示法表示知识的步骤。</strong></p></li></ul><ol><li><strong>定义个体域</strong>：确定所讨论对象的集合。</li><li><strong>定义谓词和函数</strong>：用符号表示个体性质和关系。</li><li><strong>用连接词和量词将原子谓词公式组合</strong>，构成复合公式。</li><li><strong>对公式进行化简，化为标准式</strong>（如前束范式），便于推理。</li></ol><p><strong>2.10 产生式的基本形式是什么？它与谓词逻辑中蕴涵式有什么共同处和不同处？</strong></p><ul><li><strong>基本形式</strong>：<code>IF (前提) THEN (结论/动作)</code>，也称为条件-行动对。</li><li><p><strong>与谓词逻辑蕴涵式的异同</strong>：</p><ul><li><strong>共同点</strong>：在确定性知识下，形式上都表现为“如果 P，则 Q”。</li><li><strong>不同点</strong>：<ol><li><strong>匹配过程</strong>：产生式规则的前提与<strong>动态数据库</strong>匹配，匹配即执行；蕴涵式是静态逻辑关系。</li><li><strong>操作</strong>：产生式的 THEN 部分不仅可以<strong>断言新事实</strong>，也可以<strong>执行动作</strong>（如修改数据库、输出）；蕴涵式仅表示逻辑推导关系。</li><li><strong>控制</strong>：产生式系统有独立的推理机控制规则触发顺序；逻辑系统依赖通用推理规则。</li></ol></li></ul><p><strong>2.11 产生式系统由哪几部分组成？</strong></p></li></ul><ol><li><strong>规则库</strong>：存储所有产生式规则的知识库。</li><li><strong>综合数据库/工作存储器</strong>：存储当前已知的事实、初始数据和中间结论的动态数据库。</li><li><strong>推理机</strong>：控制系统的运行。负责<strong>匹配</strong>（规则前提与数据库事实）、<strong>冲突消解</strong>（选择激活的规则）、<strong>执行</strong>（执行规则结论，更新数据库）。</li></ol><p><strong>2.12 试述产生式系统求解问题的一般步骤。</strong></p><ol><li><strong>初始化</strong>：将初始事实和数据存入综合数据库。</li><li><strong>匹配</strong>：推理机将规则库中每条规则的前提与综合数据库中的当前事实进行比对。</li><li><strong>冲突消解</strong>：若有多条规则可被激活，按某种策略（如优先级、特殊性、顺序）选择一条。</li><li><strong>执行</strong>：执行被选中规则的 THEN 部分，可能添加新事实、修改旧事实或执行外部动作，从而<strong>更新综合数据库</strong>。</li><li><strong>循环</strong>：重复步骤 2-4，直到达到目标状态（数据库包含目标事实）或没有规则可被激活为止。</li></ol><p><strong>2.13 产生式系统中，推理机的推理方式有哪几种？在产生式推理过程中，如果发生策略冲突，如何解决？</strong></p><ul><li><strong>推理方式</strong>：<ol><li><strong>正向推理</strong>（数据驱动）：从已知事实出发，匹配规则前提，逐步推出结论。</li><li><strong>反向推理</strong>（目标驱动）：从假设目标出发，寻找支持该目标的证据（规则）。</li><li><strong>混合推理</strong>：结合正向和反向推理。</li></ol></li><li><p><strong>冲突解决策略</strong>：</p><ol><li><strong>专一性排序</strong>：优先选择条件更具体、更特殊的规则。</li><li><strong>规则排序</strong>：按事先指定的固定优先级。</li><li><strong>数据排序</strong>：按前提中条件的<strong>新鲜性</strong>（新加入的事实优先）或<strong>特殊性</strong>排序。</li><li><strong>就近排序</strong>：优先选择最近使用过的规则。</li><li><strong>规模排序</strong>：优先选择前提条件多的规则。</li></ol><p><strong>2.14 试述产生式表示法的特点。</strong></p></li><li><p><strong>优点</strong>：</p><ul><li><strong>自然性</strong>：接近人类“如果…那么…”的思维习惯。</li><li><strong>模块性</strong>：规则形式单一、相互独立，易于增、删、改。</li><li><strong>清晰性</strong>：知识与控制分离，结构清晰。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>效率低</strong>：匹配是组合爆炸问题，求解效率可能不高。</li><li><strong>不能表达结构性知识</strong>：不擅长描述具有复杂内在结构的知识对象。</li></ul><p><strong>2.15 框架的一般表示形式是什么？</strong></p></li></ul><p>框架是一种描述<strong>固定、典型情景</strong>中对象的结构化表示。其一般形式为：</p><p>框架名：&lt;框架名&gt;<br>槽 1：&lt;侧面 11&gt; &lt;值 111&gt;…<br>       &lt;侧面 12&gt; &lt;值 121&gt;…<br>槽 2：&lt;侧面 21&gt; &lt;值 211&gt;…<br>…<br>约束：&lt;约束条件 1&gt;<br>     …</p><p>其中，“槽”描述对象的属性或方面，“侧面”描述属性的更详细信息（如默认值、取值范围、触发过程等）。</p><p><strong>2.16 框架表示法有何特点？请叙述用框架表示法表示知识的步骤。</strong></p><ul><li><strong>特点</strong>：结构性好、继承性（通过 AKO 槽实现）、自然性（符合人们对典型事物的认知）、便于表达默认知识。</li><li><p><strong>表示步骤</strong>：</p><ol><li>分析待描述对象，确定其<strong>框架名</strong>。</li><li>确定描述该对象所需的关键属性，作为<strong>槽</strong>。</li><li>为每个槽配备相应的<strong>侧面</strong>（如值类型、默认值、附加过程）。</li><li>填写各侧面的具体<strong>值</strong>。</li><li>确定与其它框架的<strong>继承关系</strong>（如<code>AKO</code>， <code>ISA</code>槽）。</li></ol><p><strong>2.17 试构造一个描述读者的办公室或卧室的框架系统。</strong></p></li></ul><p>框架名：&lt;卧室&gt;<br>AKO：&lt;房间&gt;<br>位置：&lt;家&gt;<br>面积：&lt;15 平方米&gt;<br>功能：&lt;休息， 学习， 储物&gt;<br>包含家具：&lt;床&gt;， &lt;书桌&gt;， &lt;衣柜&gt;<br>   子框架：&lt;床&gt;<br>       类型：&lt;双人床&gt;<br>       材质：&lt;实木&gt;<br>   子框架：&lt;书桌&gt;<br>       位置：&lt;窗前&gt;<br>       状态：&lt;正在使用&gt;<br>       上放物品：&lt;笔记本电脑&gt;， &lt;台灯&gt;， &lt;书本&gt;<br>所有者：&lt;读者的名字&gt;</p><p><strong>2.18 试构造一个描述计算机主机的框架系统。</strong></p><p>框架名：&lt;计算机主机&gt;<br>AKO：&lt;电子设备&gt;<br>品牌：<code>&lt;Dell&gt;</code><br>型号：&lt;OptiPlex 7080&gt;<br>状态：&lt;运行中&gt;<br>包含组件：<br>   槽：&lt;中央处理器&gt;<br>       型号：<intel Core="" i7-10700=""><br>       主频：&lt;2.9 GHz&gt;<br>   槽：&lt;内存&gt;<br>       容量：&lt;16 GB&gt;<br>       类型：<code>&lt;DDR4&gt;</code><br>  槽：&lt;硬盘&gt;<br>       类型：<code>&lt;SSD&gt;</code><br>       容量：&lt;512 GB&gt;<br>   槽：&lt;主板&gt;<br>       型号：&lt;Dell 0WVNPW&gt;<br>   槽：&lt;电源&gt;<br>       功率：&lt;260W&gt;<br>操作系统：&lt;Windows 10 专业版&gt;</intel></p><p><strong>2.19 请给出一个知识图谱实例。</strong></p><p>知识图谱是一种以<strong>图结构</strong>表示实体及其关系的语义网络。</p><ul><li><strong>示例</strong>：一个关于《红楼梦》的微型知识图谱。</li><li><strong>表示</strong>（三元组形式）：<ul><li><code>(曹雪芹， 创作， 《红楼梦》)</code></li><li><code>(《红楼梦》， 文学体裁， 长篇小说)</code></li><li><code>(《红楼梦》， 主角， 贾宝玉)</code></li><li><code>(《红楼梦》， 主角， 林黛玉)</code></li><li><code>(贾宝玉， 居住地， 大观园)</code></li><li><code>(林黛玉， 性格特点， 多愁善感)</code></li><li><code>(贾宝玉， 爱慕， 林黛玉)</code></li><li><code>(林黛玉， 表兄妹， 贾宝玉)</code></li></ul></li><li><strong>可视化</strong>：可以想象成一个图，其中“曹雪芹”、“《红楼梦》”、“贾宝玉”、“林黛玉”、“大观园”等是<strong>节点</strong>（实体），“创作”、“文学体裁”、“主角”、“居住地”、“爱慕”等是<strong>边</strong>（关系）。</li></ul><hr><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p><strong>3.1</strong>​ 什么是推理、正向推理、逆向推理、混合推理？试列出常用的几种推理方式并列出每种推理方式的特点。</p><p><strong>3.2</strong>​ 什么是冲突？在产生式系统中解决冲突的策略有哪些？</p><p><strong>3.3</strong>​ 什么是子句？什么是子句集？请写出求谓词公式子句集的步骤。</p><p><strong>3.4</strong>​ 谓词公式与它的子句集等价吗？在什么情况下它们才会等价？</p><p><strong>3.5</strong>​ 引入鲁宾孙归结原理有何意义？什么是归结原理？什么是归结式？</p><p><strong>3.6</strong>​ 请写出利用归结原理求解问题答案的步骤。</p><p>解答</p><p><strong>3.1 什么是推理、正向推理、逆向推理、混合推理？试列出常用的几种推理方式并列出每种推理方式的特点。</strong></p><ul><li><strong>推理</strong>：从已知事实出发，运用知识推出结论的思维过程。</li><li><strong>推理方式及其特点</strong>：<ol><li><strong>正向推理</strong>（数据驱动）：从已知事实出发，匹配规则，不断推出新事实直至目标。<strong>特点</strong>：适用于初始数据明确、目标众多的场合，但可能进行大量与目标无关的推理。</li><li><strong>逆向推理</strong>（目标驱动）：从假设目标出发，反向寻找支持它的证据。<strong>特点</strong>：目的性强，适用于目标单一的场合，但对初始数据的指导性弱。</li><li><strong>混合推理</strong>：结合正向与逆向推理。<strong>特点</strong>：从初始事实正向推理，得到中间结论；再从目标逆向推理，寻求支持，效率更高。</li></ol></li></ul><p><strong>3.2 什么是冲突？在产生式系统中解决冲突的策略有哪些？</strong></p><ul><li><strong>冲突</strong>：在推理的某一时刻，有多条规则的前提同时与综合数据库匹配成功的情况。</li><li><strong>冲突解决策略</strong>：<ol><li><strong>专一性排序</strong>：优先使用条件更具体、范围更小的规则。</li><li><strong>规则排序</strong>：按规则优先级事先固定排序。</li><li><strong>数据排序</strong>：按匹配事实的“新旧”程度（如最新加入的事实优先）或特定性排序。</li><li><strong>就近排序</strong>：优先使用最近被触发过的规则。</li></ol></li></ul><p><strong>3.3 什么是子句？什么是子句集？请写出求谓词公式子句集的步骤。</strong></p><ul><li><strong>子句</strong>：若干文字的析取式（<code>L₁ ∨ L₂ ∨ ...</code>），其中每个文字是原子公式或其否定。</li><li><strong>子句集</strong>：若干子句的集合，是合取范式（即子句之间是“与”的关系）。</li><li><strong>求子句集的步骤</strong>：<ol><li><strong>消去蕴涵符号</strong>：用 <code>¬A ∨ B</code>替换 <code>A → B</code>。</li><li><strong>内移否定符</strong>：将 <code>¬</code>移到原子公式前，如 <code>¬(A ∧ B)</code>化为 <code>¬A ∨ ¬B</code>。</li><li><strong>变量标准化</strong>：使不同量词约束的变量名不同。</li><li><strong>消去存在量词</strong>（Skolem 化）。</li><li><strong>化为前束形</strong>：将所有全称量词移到公式最前面。</li><li><strong>化为合取范式</strong>：将公式内化为子句的合取。</li><li><strong>消去全称量词和合取词</strong>，得到子句集。</li></ol></li></ul><p><strong>3.4 谓词公式与它的子句集等价吗？在什么情况下它们才会等价？</strong></p><ul><li>谓词公式与其子句集<strong>并不等价</strong>。在<strong>转化过程中（特别是 Skolem 化）</strong>​ 会引入新常量/函数，导致两者在逻辑上不完全等价。</li><li>它们只是在<strong>不可满足性上等价</strong>。即，<strong>原谓词公式是不可满足的，当且仅当其子句集是不可满足的</strong>。这是归结原理能用于自动定理证明的基础。</li></ul><p><strong>3.5 引入鲁宾孙归结原理有何意义？什么是归结原理？什么是归结式？</strong></p><ul><li><strong>意义</strong>：为定理的<strong>机器自动证明</strong>提供了一个简洁、规范且完备的推理方法。它将复杂的推理过程归结为简单的<strong>子句归结</strong>，奠定了自动推理的理论基础。</li><li><strong>归结原理</strong>：在<strong>子句集</strong>中进行。如果两个子句中分别包含互补文字（如 <code>P</code>和 <code>¬P</code>），则可消去这对互补文字，将两个子句的其余部分合并构成新子句。</li><li><strong>归结式</strong>：由归结操作生成的新子句。</li></ul><p><strong>3.6 请写出利用归结原理求解问题答案的步骤。</strong></p><ol><li><strong>化已知条件为谓词公式</strong>：将已知事实和知识表示为谓词公式集合 <code>F</code>。</li><li><strong>化待证目标为谓词公式</strong>：将待证明的结论表示为谓词公式 <code>G</code>。</li><li><strong>构造子句集</strong>：将公式集合 <code>{F, ¬G}</code>化为子句集 <code>S</code>。</li><li><strong>归结演绎</strong>：对子句集 <code>S</code>反复应用归结原理，若最终能推出<strong>空子句</strong>（<code>□</code>），则说明 <code>F → G</code>成立，证明结束。若无法归结出空子句，且无法继续归结，则说明原结论不成立。</li></ol><hr><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p>4.1​ 什么是不确定性推理？有哪几类不确定性推理方法？不确定性推理中需要解决的基本问题有哪些？ 4.2​ 什么是可信度？由可信度因子 CF(H,E)的定义说明它的含义。 4.3​ 简述求取问题结论可信度的步骤。 4.4​ 说明概率分配函数、信任函数、似然函数的含义。 4.5​ 概率分配函数与概率相同吗？为什么？ 4.6​ 如何用 D-S 证据理论描述假设、规则和证据的不确定性，并实现不确定性的推理组合？ 4.7​ 什么是模糊性？它与随机性有什么区别？试举出几个日常生活中的模糊概念。 4.8​ 模糊推理的一般过程是什么？</p><p>答案</p><p><strong>4.1 什么是不确定性推理？有哪几类不确定性推理方法？不确定性推理中需要解决的基本问题有哪些？</strong></p><ul><li><strong>定义</strong>：不确定性推理是指在知识（规则）和证据（事实）不精确、不完备、模糊或存在矛盾的情况下，依然能够进行推理并得出结论的一种方法。其结论通常附带有不确定性度量。</li><li><strong>主要方法</strong>：<ol><li><strong>可信度方法</strong>（如 MYCIN 系统模型）</li><li><strong>主观贝叶斯方法</strong></li><li><strong>证据理论</strong>（D-S 理论）</li><li><strong>模糊推理</strong></li></ol></li><li><strong>基本问题</strong>：<ol><li><strong>不确定性的表示</strong>：如何描述知识、证据和结论的不确定性度量（如可信度、概率、隶属度等）。</li><li><strong>不确定性的计算</strong>：如何定义不确定性在推理过程中的传播、更新和组合的算法。</li><li><strong>不确定性度量的语义</strong>：明确不确定性度量的实际含义（如可信度是信任增长度，概率是客观频率等）。</li><li><strong>证据的组合</strong>：当多条证据支持同一结论时，如何合并它们的影响。</li></ol></li></ul><p><strong>4.2 什么是可信度？由可信度因子 CF(H,E)的定义说明它的含义。</strong></p><ul><li><strong>可信度</strong>：是专家系统中用来表示<strong>假设 H</strong>在<strong>证据 E</strong>成立的前提下，其<strong>为真的信任程度</strong>的一种不确定性度量。</li><li><strong>可信度因子 CF(H,E)</strong>：定义为信任增长度。其经典定义为： <code>CF(H,E) = MB(H,E) - MD(H,E)</code><ul><li><code>MB(H,E)</code>：证据 E 对假设 H 的信任增加度量。</li><li><code>MD(H,E)</code>：证据 E 对假设 H 的不信任增加度量。</li></ul></li><li><strong>含义</strong>：<ul><li><code>CF(H,E) &gt; 0</code>：表示证据 E 的出现增加了假设 H 为真的信任度，正值越大，信任度增加越多。</li><li><code>CF(H,E) = 0</code>：表示证据 E 与假设 H 无关，或<code>MB=MD</code>，即信任与不信任的增量相同。</li><li><code>CF(H,E) &lt; 0</code>：表示证据 E 的出现增加了假设 H 为假的不信任度。</li></ul></li></ul><p><strong>4.3 简述求取问题结论可信度的步骤。</strong></p><ol><li><strong>建立规则库</strong>：用<code>IF...THEN...</code>的形式定义知识，并为每条规则赋予可信度因子<code>CF(Rule)</code>。</li><li><strong>初始化证据可信度</strong>：为已知的初始证据<code>E</code>赋予初始可信度<code>CF(E)</code>。</li><li><strong>进行正向推理</strong>：从已知证据出发，匹配可用的规则。</li><li><strong>计算结论的可信度</strong>：对于匹配成功的规则<code>IF E THEN H (CF(Rule))</code>，结论<code>H</code>的可信度<code>CF(H)</code>由前提<code>E</code>的可信度<code>CF(E)</code>和规则的可信度<code>CF(Rule)</code>共同决定，公式通常为：<code>CF(H) = CF(E) * CF(Rule)</code>。</li><li><strong>组合不同证据</strong>：如果同一个结论<code>H</code>被多条路径（规则）推导出来，得到多个<code>CFi(H)</code>，则需使用组合公式（如合成法）计算最终的<code>CF(H)</code>。</li></ol><p><strong>4.4 说明概率分配函数、信任函数、似然函数的含义。</strong></p><p>这是 D-S 证据理论中的核心概念。设<code>Θ</code>为识别框架（所有可能假设的集合）。</p><ul><li><strong>概率分配函数(m)</strong>：是一个从<code>Θ</code>的幂集<code>2^Θ</code>到[0,1]的映射，满足<code>m(∅)=0</code>且<code>∑m(A)=1</code>。<code>m(A)</code>表示<strong>证据本身</strong>支持命题<code>A</code>成立的基本概率分配，而不支持<code>A</code>的任何子集。</li><li><strong>信任函数(Bel)</strong>：对任意命题<code>A ⊆ Θ</code>，<code>Bel(A) = ∑_{B ⊆ A} m(B)</code>。表示<strong>证据</strong>对<code>A</code>的<strong>总信任度</strong>，即所有支持<code>A</code>的子集（<code>B ⊆ A</code>）的基本概率之和。</li><li><strong>似然函数(Pl)</strong>：对任意命题<code>A ⊆ Θ</code>，<code>Pl(A) = 1 - Bel(¬A)</code>。表示<strong>不否定<code>A</code></strong>的程度，即<code>A</code>的<strong>可能信任度</strong>。区间<code>[Bel(A), Pl(A)]</code>构成了信任区间，描述了对<code>A</code>的不确定性。</li></ul><p><strong>4.5 概率分配函数与概率相同吗？为什么？</strong></p><p><strong>不同。</strong>​ 主要原因：</p><ol><li><strong>定义域不同</strong>：概率分配函数<code>m</code>的定义域是识别框架<code>Θ</code>的幂集<code>2^Θ</code>（即所有子集），而概率函数的定义域是<code>Θ</code>本身（基本事件）。</li><li><strong>分配对象不同</strong>：<code>m(A)</code>可以分配给任何命题（子集）<code>A</code>，表示证据对<code>A</code>本身的直接支持度，<strong>无需</strong>将支持度再分配给<code>A</code>的内部元素。而概率必须满足可加性，分配给复合事件（如<code>{A, B}</code>）的概率必须等于分配给基本事件<code>P(A)+P(B)</code>。</li><li><strong>对未知的处理不同</strong>：证据理论允许<code>m(Θ) &gt; 0</code>，即保留一部分信任度给“未知”，表示对识别框架中所有可能性的无知。而在经典概率中，<code>P(Θ)=1</code>是确定的，无法表示这种无知。</li></ol><p><strong>4.6 如何用 D-S 证据理论描述假设、规则和证据的不确定性，并实现不确定性的推理组合？</strong></p><ul><li><strong>描述不确定性</strong>：<ul><li><strong>证据</strong>：用基本概率分配函数<code>m</code>来描述。每个证据对应一个<code>m</code>函数，表示该证据对识别框架<code>Θ</code>中各个命题的支持程度。</li><li><strong>规则</strong>：通常可以表示为<code>IF E THEN H, with m</code>的形式，或者用规则强度、信度函数等与证据组合。</li><li><strong>假设</strong>：是识别框架<code>Θ</code>中的子集。其不确定性由信任函数<code>Bel</code>和似然函数<code>Pl</code>构成的信任区间<code>[Bel, Pl]</code>来描述。</li></ul></li><li><strong>推理组合</strong>：通过<strong>Dempster 组合规则</strong>实现。对于两个相互独立的证据源<code>E1</code>和<code>E2</code>，其对应的概率分配为<code>m1</code>和<code>m2</code>，组合后的新概率分配<code>m = m1 ⊕ m2</code>计算公式为： <code>m(C) = K^{-1} * ∑_{A∩B=C} m1(A)*m2(B)</code>，其中<code>C ≠ ∅</code>。 <code>K = 1 - ∑_{A∩B=∅} m1(A)*m2(B)</code>是归一化常数，用于排除冲突证据的影响。</li></ul><p><strong>4.7 什么是模糊性？它与随机性有什么区别？试举出几个日常生活中的模糊概念。</strong></p><ul><li><strong>模糊性</strong>：指事物在<strong>概念和外延</strong>上所具有的<strong>不分明性</strong>，源于事物类属的“亦此亦彼”性。是<strong>对静态事物本身状态</strong>的描述。</li><li><strong>区别</strong>：<ul><li><strong>产生原因</strong>：随机性源于<strong>因果律的缺失</strong>，是事件<strong>是否发生</strong>的不确定性；模糊性源于<strong>排中律的缺失</strong>，是事件<strong>本身状态</strong>的不确定性。</li><li><strong>描述工具</strong>：随机性用<strong>概率论</strong>描述（事件发生的机会）；模糊性用<strong>模糊集合论</strong>描述（对象属于集合的程度）。</li><li><strong>举例</strong>：“明天可能下雨”是随机性；“现在是阴天”是模糊性（“阴天”的边界是模糊的）。</li></ul></li><li><strong>日常模糊概念</strong>：高个子、年轻人、热水、天气很好、有点咸、打扫干净。</li></ul><p><strong>4.8 模糊推理的一般过程是什么？</strong></p><ol><li><strong>模糊化</strong>：将输入的精确值，根据预先定义的<strong>隶属度函数</strong>，转化为对应模糊语言变量（如“高”，“中”，“低”）的隶属度。</li><li><strong>模糊规则匹配</strong>：将模糊化后的输入，与知识库中的<strong>模糊规则</strong>（IF-THEN 形式）的前件进行匹配，计算每条规则的<strong>激活强度</strong>（通常用取小<code>min</code>或乘积运算）。</li><li><strong>模糊推理</strong>：根据规则的激活强度，<strong>裁剪</strong>或<strong>缩放</strong>规则后件对应的模糊集的隶属度函数，得到每条规则输出的模糊结论。</li><li><strong>模糊结论合成</strong>：将所有被激活的规则输出的模糊结论进行<strong>聚合</strong>（通常用取大<code>max</code>运算），形成一个综合的输出模糊集合。</li><li><strong>去模糊化</strong>：将聚合后的输出模糊集合，通过某种算法（如<strong>重心法</strong>、<strong>最大隶属度法</strong>、<strong>中位数法</strong>等）转换成一个精确的输出值。</li></ol><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p><strong>5.1</strong>​ 什么是搜索？有哪两大类不同的搜索方法？两者的区别是什么？</p><p><strong>5.2</strong>​ 什么是启发式搜索？什么是启发信息？</p><p><strong>5.3</strong>​ 用状态空间法表示问题时，什么是问题的解？求解过程的本质是什么？什么是最优解？最优解唯一吗？</p><p><strong>5.4</strong>​ 请写出状态空间图的一般搜索过程。在搜索过程中 open 表和 closed 表的作用分别是什么？有何区别？</p><p><strong>5.5</strong>​ 什么是盲目搜索？主要有几种盲目搜索策略？</p><p><strong>5.6</strong>​ 在深度优先搜索中，每个结点的子结点是按某种次序生成和扩展的，在决定生成子状态的最优次序时，应该用什么标准来衡量？</p><p><strong>5.7</strong>​ 宽度优先搜索与深度优先搜索有何不同？分析深度和宽度优先的优缺点。在何种情况下，宽度优先搜索优于深度优先搜索？在何种情况下，深度优先搜索优于宽度优先搜索？</p><p><strong>5.8</strong>​ 什么是 A<em>搜索算法？它的估价函数是如何确定的？A</em>搜索算法与 A 搜索算法的区别是什么？</p><p>解答</p><p><strong>5.1 搜索</strong>：在状态空间中寻找从初始状态到目标状态的路径的过程。分为<strong>盲目搜索</strong>（无额外信息，按固定顺序搜索）和<strong>启发式搜索</strong>（利用启发信息指导搜索）。区别在于是否使用启发信息。</p><p><strong>5.2 启发式搜索</strong>：利用<strong>启发信息</strong>（即问题领域的额外知识，常表示为启发函数 <code>h(n)</code>，用于估计到目标的代价）来引导搜索方向，提高效率的搜索方法。</p><p><strong>5.3 问题的解</strong>：一个从初始状态到目标状态的操作序列。<strong>求解本质</strong>：在状态空间中找路径。<strong>最优解</strong>：总代价最小的解。<strong>最优解不一定唯一</strong>。</p><p><strong>5.4 一般搜索过程</strong>：</p><ol><li>初始状态放入 OPEN 表。</li><li>若 OPEN 空则失败。</li><li>取一状态。</li><li>若是目标则成功。</li><li>否则扩展，生成后继状态。</li><li>处理后继状态。</li><li>新状态按策略放入 OPEN，父状态移入 CLOSED。</li><li><p>重复 2-7。</p><p><strong>OPEN 表</strong>：存放待考察节点（前沿）。<strong>CLOSED 表</strong>：存放已考察节点（历史）。区别在于节点状态（待扩展 vs 已扩展）。</p></li></ol><p><strong>5.5 盲目搜索</strong>：不利用问题特定信息，按预定顺序搜索的策略。主要有：<strong>宽度优先搜索</strong>、<strong>深度优先搜索</strong>、<strong>一致代价搜索</strong>、<strong>深度受限搜索</strong>、<strong>迭代加深搜索</strong>。</p><p><strong>5.6 在深度优先搜索中，决定子状态生成的最优次序</strong>：DFS 本身无最优次序，按预设顺序（如字母序）。若想引入启发性，可按启发函数<code>h(n)</code>排序，优先扩展<code>h(n)</code>小的子节点（即更接近目标的状态）。</p><p><strong>5.7 宽度优先 vs 深度优先</strong>：</p><ul><li><strong>不同</strong>：BFS 用队列逐层扩展；DFS 用栈沿分支深入。</li><li><strong>优缺点</strong>：BFS 完备且（在等代价时）最优，但空间开销大；DFS 空间开销小，但可能不完备，且找到的解不一定最优。</li><li><strong>BFS 优于 DFS</strong>：解在浅层、需求最优解、空间足够时。</li><li><strong>DFS 优于 BFS</strong>：空间深度大、只求可行解、BFS 空间无法承受时。</li></ul><p>_<em>5.8 A</em>搜索算法_*：一种启发式搜索，用估价函数<code>f(n)=g(n)+h(n)</code>（<code>g(n)</code>为实际代价，<code>h(n)</code>为估计代价）选择节点扩展。</p><ul><li><strong>估价函数确定</strong>：<code>h(n)</code>需根据问题领域知识设计（如直线距离）。</li><li><strong>与 A 搜索算法的区别</strong>：<strong>A 算法</strong>泛指使用<code>f(n)=g(n)+h(n)</code>的算法；<strong>A_算法</strong>是 A 算法的特例，要求<code>h(n)</code>满足<strong>可采纳性</strong>（即<code>h(n) ≤ h*(n)</code>，<code>h*(n)</code>为真实最小代价），此条件下 A_能保证找到最优解。</li></ul><hr><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p><strong>6.1</strong>​ 遗传算法的基本步骤和主要特点是什么？</p><p><strong>6.2</strong>​ 适应度函数在遗传算法中的作用是什么？试举例说明如何构造适应度函数。</p><p><strong>6.3</strong>​ 选择的基本思想是什么？</p><p><strong>6.4</strong>​ 简述多种群遗传算法与基本遗传算法的异同。</p><p><strong>6.5</strong>​ 简述多倍体遗传算法与基本遗传算法的异同。</p><p><strong>6.6</strong>​ 群智能算法的基本思想是什么？</p><p><strong>6.7</strong>​ 群智能算法的主要特点是什么？</p><p><strong>6.8</strong>​ 列举几种典型的群智能算法，分析它们的主要优点、缺点。</p><p><strong>6.9</strong>​ 简述群智能算法与进化算法的异同。</p><p><strong>6.10</strong>​ 简述粒子群算法的流程。</p><p><strong>6.11</strong>​ 简述粒子群算法位置更新方程中各部分的影响。</p><p><strong>6.12</strong>​ 举例说明粒子群算法的搜索原理，并简要叙述粒子群算法有哪些特点。</p><p><strong>6.13</strong>​ 粒子群算法的寻优过程包含哪几个阶段？寻优的准则有哪些？</p><p><strong>6.14</strong>​ 粒子群算法中的参数如何选择？</p><p><strong>6.15</strong>​ 举例说明蚁群算法的搜索原理，并简要叙述蚁群算法的特点。</p><p><strong>6.16</strong>​ 蚁群算法的寻优过程包含哪几个阶段？寻优的准则有哪些？</p><p><strong>6.17</strong>​ 蚁群算法中的参数如何选择？</p><hr><p><strong>6.1 遗传算法的基本步骤和主要特点是什么？</strong></p><ul><li><strong>基本步骤</strong>：<ol><li><strong>初始化</strong>：随机生成初始种群（一组候选解）。</li><li><strong>适应度评估</strong>：计算种群中每个个体的适应度值。</li><li><strong>选择</strong>：根据适应度高低，选择优良个体作为父代。</li><li><strong>交叉</strong>：将选出的父代个体两两配对，以一定概率交换部分基因，产生新个体（子代）。</li><li><strong>变异</strong>：以较低概率改变子代个体中某些基因的值，引入新特征。</li><li><strong>生成新种群</strong>：用子代个体替换部分或全部父代，形成新一代种群。</li><li><strong>终止判断</strong>：若满足终止条件（如达到最大迭代次数或找到满意解），则输出最优解；否则返回步骤 2。</li></ol></li><li><strong>主要特点</strong>：<ul><li><strong>群体搜索</strong>：同时对解空间中的多个点进行搜索，并行性好。</li><li><strong>启发性随机搜索</strong>：通过概率规则（选择、交叉、变异）引导搜索，非确定性。</li><li><strong>无需梯度信息</strong>：仅需目标函数（适应度函数）值，不依赖函数的连续、可微等性质。</li><li><strong>隐含并行性</strong>：通过种群内个体的信息交换实现全局搜索。</li></ul></li></ul><p><strong>6.2 适应度函数在遗传算法中的作用是什么？试举例说明如何构造适应度函数。</strong></p><ul><li><strong>作用</strong>：<ol><li><strong>评价个体优劣</strong>：适应度值高低直接反映个体（解）的质量。</li><li><strong>指导选择操作</strong>：适应度越高，被选中遗传到下一代的机会越大，是算法进化的驱动力。</li></ol></li><li><strong>构造举例</strong>：求解函数 <code>f(x) = x²</code>在 <code>[0, 31]</code>上的最大值。<ul><li>编码：用 5 位二进制串表示<code>x</code>。</li><li>直接法：个体解码后的值<code>x</code>代入目标函数，<code>fit(x) = f(x) = x²</code>即可作为适应度。</li><li>若求最小值，可构造 <code>fit(x) = C_max - f(x)</code>或 <code>fit(x) = 1 / (f(x) + ε)</code>，确保适应度非负且与目标值成反比。</li></ul></li></ul><p><strong>6.3 选择的基本思想是什么？</strong></p><ul><li>模拟“<strong>适者生存</strong>”的自然法则，使种群中<strong>适应度高的个体有更大的概率被选中</strong>，将其优良基因遗传给下一代。其核心是<strong>基于概率的优胜劣汰</strong>，引导搜索方向朝着更优解的区域进行。</li></ul><p><strong>6.4 简述多种群遗传算法与基本遗传算法的异同。</strong></p><ul><li><strong>相同点</strong>：基本操作单元都是个体，都包含选择、交叉、变异等遗传操作。</li><li><strong>不同点</strong>：<ul><li><strong>种群结构</strong>：基本 GA 为单一同质种群；多种群 GA 则并行维护多个子种群，并可能定期在种群间迁移（交换）部分优秀个体。</li><li><strong>目的</strong>：多种群 GA 旨在维持种群多样性，有效防止早熟收敛，增强全局探索能力，是<strong>并行 GA</strong>的一种典型实现。</li></ul></li></ul><p><strong>6.5 简述多倍体遗传算法与基本遗传算法的异同。</strong></p><ul><li><strong>相同点</strong>：遵循类似的进化流程。</li><li><strong>不同点</strong>：<ul><li><strong>基因编码</strong>：基本 GA 个体为<strong>单倍体</strong>染色体（一套基因）；多倍体 GA 个体为<strong>多倍体</strong>（如二倍体，具有两套基因）。</li><li><strong>表达与遗传</strong>：多倍体存在<strong>显隐性关系</strong>，只有显性基因决定个体性状（适应度），但遗传时两套基因共同参与。这增强了算法的记忆能力和对环境变化的鲁棒性。</li></ul></li></ul><p><strong>6.6 群智能算法的基本思想是什么？</strong></p><ul><li>模拟生物群体（如鸟群、蚁群、鱼群）的<strong>集体智能行为</strong>。群体中简单的个体（智能体）遵循相对简单的规则，并且<strong>个体之间以及个体与环境之间进行局部交互和信息共享</strong>，通过这些分散的、自组织的局部互动，在群体层面涌现出复杂的、高效的全局智能行为，从而解决复杂的优化或协同问题。</li></ul><p><strong>6.7 群智能算法的主要特点是什么？</strong></p><ul><li><strong>分布式、自组织</strong>：无中心控制，依靠个体简单规则和局部交互。</li><li><strong>正反馈</strong>：好的解/路径能吸引更多个体（如蚁群的信息素增强）。</li><li><strong>负反馈</strong>：防止陷入局部最优（如信息素挥发）。</li><li><strong>鲁棒性强</strong>：个体简单，部分失效不影响群体功能。</li><li><strong>并行性强</strong>：个体可同时独立行动。</li><li><strong>通用性好</strong>：对目标函数要求低，适合黑箱优化。</li></ul><p><strong>6.8 列举几种典型的群智能算法，分析它们的主要优点、缺点。</strong></p><ol><li><p><strong>粒子群优化算法</strong>：</p><ul><li><em>优点</em>：原理简单，参数少，收敛速度快，易于实现。</li><li><em>缺点</em>：后期易陷入局部最优，对离散问题处理不便。</li></ul></li><li><p><strong>蚁群优化算法</strong>：</p><ul><li><em>优点</em>：正反馈强，适合路径优化等组合问题，鲁棒性好。</li><li><em>缺点</em>：初期信息素积累慢，收敛速度较慢，参数设置复杂。</li></ul></li><li><p><strong>人工鱼群算法/狼群算法等</strong>：</p><ul><li><em>优点</em>：模拟更复杂的生物行为，全局搜索能力可能更强。</li><li><em>缺点</em>：模型更复杂，计算开销大，理论分析较难。</li></ul></li></ol><p><strong>6.9 简述群智能算法与进化算法的异同。</strong></p><ul><li><strong>相同点</strong>：都是受自然启发的元启发式优化算法，属于群体智能范畴，用于复杂问题求解。</li><li><strong>不同点</strong>：<ul><li><strong>灵感来源</strong>：进化算法源于<strong>生物进化</strong>（遗传、变异、选择）；群智能算法源于<strong>生物群体的社会行为</strong>（协作、竞争、信息共享）。</li><li><strong>核心操作</strong>：进化算法核心是<strong>基因操作</strong>（交叉、变异）；群智能算法核心是<strong>个体间信息交互与行为模仿</strong>（如跟随最优粒子、信息素跟踪）。</li><li><strong>“代”的概念</strong>：进化算法迭代代次明显；群智能算法中个体持续更新，代次界限模糊。</li></ul></li></ul><p><strong>6.10 简述粒子群算法的流程。</strong></p><ol><li><strong>初始化</strong>：随机初始化粒子的位置和速度，设定参数（惯性权重、加速常数等）。</li><li><strong>评估</strong>：计算每个粒子的适应度值。</li><li><strong>更新个体与群体历史最优</strong>：对每个粒子，将其当前位置与自身历史最优位置比较并更新；与群体历史最优位置比较并更新。</li><li><p><strong>更新速度与位置</strong>：根据公式更新每个粒子的速度和位置。</p><ul><li>速度更新公式：<code>v_i(t+1) = w * v_i(t) + c1*r1*(pbest_i - x_i(t)) + c2*r2*(gbest - x_i(t))</code></li><li>位置更新公式：<code>x_i(t+1) = x_i(t) + v_i(t+1)</code></li></ul></li><li><p><strong>终止判断</strong>：满足终止条件（如达到精度或最大迭代次数）则停止，输出全局最优解；否则返回步骤 2。</p></li></ol><p><strong>6.11 简述粒子群算法位置更新方程中各部分的影响。</strong></p><ul><li><code>v_i(t)</code>(<strong>惯性部分</strong>)：代表粒子先前速度的继承，<code>w</code>为惯性权重，平衡全局与局部搜索能力。<code>w</code>大则探索能力强，<code>w</code>小则开发能力强。</li><li><code>c1*r1*(pbest_i - x_i(t))</code>(<strong>认知部分</strong>)：代表粒子向自身历史最优位置学习的趋势。<code>c1</code>为认知加速常数，控制个体经验的影响力。</li><li><code>c2*r2*(gbest - x_i(t))</code>(<strong>社会部分</strong>)：代表粒子向群体历史最优位置学习的趋势。<code>c2</code>为社会加速常数，控制社会信息的影响力。</li><li><code>r1, r2</code>：随机数，增加搜索的随机性。</li></ul><p><strong>6.12 举例说明粒子群算法的搜索原理，并简要叙述粒子群算法有哪些特点。</strong></p><ul><li><strong>搜索原理举例</strong>：想象一群鸟在随机搜索一片区域的食物。每只鸟不知道食物在哪，但知道自己和同伴们曾找到的最近食物的位置。鸟通过不断调整自己的飞行方向和速度，既根据自己的经验向自己记忆中的最好位置飞，也向整个鸟群公认的最好位置飞，最终整个鸟群会聚集到食物最多的地方。</li><li><strong>特点</strong>：<ul><li><strong>原理简单，易实现</strong>。</li><li><strong>参数少，收敛速度快</strong>。</li><li><strong>需调整参数少，但惯性权重<code>w</code>等对性能影响大</strong>。</li><li><strong>本质上是全局搜索，但后期易陷入局部最优</strong>。</li></ul></li></ul><p><strong>6.13 粒子群算法的寻优过程包含哪几个阶段？寻优的准则有哪些？</strong></p><ul><li><strong>阶段</strong>：<ol><li><strong>探索阶段</strong>：初期，粒子在解空间广泛探索，寻找有希望的区域。</li><li><strong>开发阶段</strong>：后期，粒子集中在最有希望的区域进行精细搜索。</li></ol></li><li><strong>寻优准则</strong>：<ul><li><strong>收敛准则</strong>：如全局最优位置<code>gbest</code>在连续若干代内不再变化，或变化小于阈值。</li><li><strong>迭代次数</strong>：达到预设的最大迭代次数。</li><li><strong>精度准则</strong>：找到的解的适应度值达到预设目标。</li></ul></li></ul><p><strong>6.14 粒子群算法中的参数如何选择？</strong></p><ul><li><strong>惯性权重<code>w</code></strong>：常采用线性递减策略，初期<code>w</code>较大（如 0.9）利于探索，后期<code>w</code>较小（如 0.4）利于开发。</li><li><strong>加速常数<code>c1, c2</code></strong>：通常取<code>c1 = c2 = 2</code>左右。<code>c1</code>大可增强个体经验，<code>c2</code>大可增强社会学习。有研究建议<code>c1</code>从大到小，<code>c2</code>从小到大变化。</li><li><strong>种群规模</strong>：通常 20-50，复杂问题可增大。</li><li><strong>速度限制<code>V_max</code></strong>：通常设定为变量范围的 10%-20%，防止搜索步长过大。</li></ul><p><strong>6.15 举例说明蚁群算法的搜索原理，并简要叙述蚁群算法的特点。</strong></p><ul><li><strong>搜索原理举例</strong>：求解旅行商问题。蚂蚁随机选择路径，在路径上释放信息素。较短的路径因为蚂蚁往返更快，单位时间内信息素积累更多。后续蚂蚁倾向于选择信息素浓度更高的路径，从而进一步强化该路径。通过“<strong>信息素正反馈</strong>”和“<strong>挥发负反馈</strong>”（防止信息素无限累积），最终所有蚂蚁倾向于收敛到最短路径上。</li><li><strong>特点</strong>：<ul><li><strong>正反馈机制</strong>，能快速发现较好解。</li><li><strong>分布式计算</strong>，易于并行。</li><li><strong>强启发性</strong>，与问题结合紧密。</li><li><strong>初期信息素匮乏，收敛速度慢</strong>。</li><li><strong>参数设置对性能影响显著</strong>。</li></ul></li></ul><p><strong>6.16 蚁群算法的寻优过程包含哪几个阶段？寻优的准则有哪些？</strong></p><ul><li><strong>阶段</strong>：<ol><li><strong>初始化阶段</strong>：设定参数，初始化信息素。</li><li><strong>迭代构建阶段</strong>：每只蚂蚁根据路径上的信息素浓度和启发信息（如距离倒数），以一定概率构建完整路径。</li><li><strong>信息素更新阶段</strong>：所有蚂蚁走完后，根据路径质量（长度）更新信息素（增加优质路径信息素，同时所有路径信息素挥发）。</li></ol></li><li><strong>寻优准则</strong>：同 PSO，包括<strong>最大迭代次数</strong>、<strong>最优解连续不变代数</strong>、<strong>达到期望精度</strong>等。</li></ul><p><strong>6.17 蚁群算法中的参数如何选择？</strong></p><ul><li><strong>信息素重要性因子<code>α</code></strong>：值越大，蚂蚁越倾向于选择信息素浓的路径，加速收敛但易早熟。</li><li><strong>启发信息重要性因子<code>β</code></strong>：值越大，蚂蚁越倾向于选择看起来近的路径，贪心性越强。</li><li><strong>信息素挥发系数<code>ρ</code></strong>：<code>(0,1)</code>之间。值小则信息素留存久，全局搜索能力强但收敛慢；值大则信息素挥发快，利于抛弃差解但可能丢失历史信息。</li><li><strong>信息素强度<code>Q</code></strong>：影响信息素增量的绝对值，与问题规模相关。</li><li><strong>蚂蚁数量<code>m</code></strong>：一般与问题节点数相当。太多则收敛慢，太少则正反馈不足。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1.1 什么是人类智能？它有哪些特点？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;人类智能&lt;/st</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-03-论文实训草稿</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/38065.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/38065.html</id>
    <published>2026-01-03T06:10:49.000Z</published>
    <updated>2026-01-04T09:19:44.909Z</updated>
    
    <content type="html"><![CDATA[<p>汽车保险领域面临的日益严峻的欺诈风险使行业经济损失巨大。为有效应对此类问题，本研究运用传统机器学习技术构建欺诈识别系统，提供了数据处理、特征提取以及模型构建的完整流程，采用汽车保险理赔数据集，进行相关实验，重点考察随机森林算法与其他分类器的性能对比，包括数据清洗、特征选择和不平衡处理。通过交叉验证和指标评估，结果显示优化后的随机森林模型在 AUC 和召回率方面表现出色。该研究验证了传统算法在实际场景中的可靠性，并为保险企业风险管理提供实用建议。</p><p>}</p><p>% 中文关键词(每个关键词之间用”；”分开,最后一个关键词不打标点符号。)</p><p>\ckeywords{汽车保险欺诈；随机森林算法；传统机器学习；数据不平衡；特征提取；性能评估}</p><hr><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>保险业通过风险聚合与转移机制为社会经济活动提供安全保障，在全球经济运行中扮演着至关重要的角色。其庞大的资金池更是资本市场长期资本的重要来源之一 <strong>(Barry &amp; Charpentier, 2020)</strong>。根据经济合作与发展组织的报告，保险业的稳定性直接关系到全球金融系统的韧性 <strong>(OECD, 2023)</strong>。在财产保险领域，汽车保险覆盖面最为广泛并与日常生活紧密联系，构成了该领域的核心业务板块，同时其受到日益猖獗的保险欺诈行为的严峻挑战。</p><p>汽车保险欺诈已成为一个全球性的顽疾，对行业的财务健康和社会的诚信体系造成持续性的损害。欺诈行为导致保险公司支付了本不应承担的赔款，这些巨大的“渗漏”最终会通过提高保费的形式转嫁给所有诚实投保人，破坏了保险的公平性原则 <strong>(Viaene &amp; Dedene, 2004)</strong>。据美国反保险欺诈联盟（Coalition Against Insurance Fraud）的最新报告，保险欺诈每年给美国造成的损失已超过 3000 亿美元，其中车险领域是重灾区 <strong>(CAIF, 2022)</strong>。欺诈的成因复杂，一方面，信息不对称使得保险公司难以在承保和理赔环节完全掌握投保人的真实风险与行为 <strong>(Cohen &amp; Siegelman, 2010)</strong>；另一方面，技术的进步，特别是数字化理赔流程的普及，在提升效率的同时，也为新型、更隐蔽的欺诈手段提供了可乘之机 <strong>(Severino &amp; Peng, 2021)</strong>。这不仅侵蚀了保险公司的承保利润，还可能导致定价模型失真，扭曲风险信号，长期而言将削弱保险的风险分担功能和社会效益。</p><p>从广义上讲，保险欺诈是指任何以非法获取保险金为目的的故意行为。根据欺诈主体的不同，可分为保单持有人欺诈、第三方欺诈以及内部人员欺诈等 <strong>(Derrig, 2002)</strong>。鉴于数据的可获得性与研究的可操作性，本文的研究焦点将集中于<strong>汽车理赔欺诈</strong>，即保单持有人或相关方在理赔环节，通过故意制造事故、夸大损失、伪造单据等手段骗取保险赔偿金的行为。这类欺诈是车险欺诈中最常见的形式，拥有相对丰富的公开研究数据基础，是应用数据驱动方法进行自动化检测的主要战场 <strong>(Bhattacharyya et al., 2011)</strong>。</p><p>为应对这类欺诈威胁，保险公司正从依赖专家规则和人工审核，转向基于数据挖掘与机器学习（ML）的自动化检测系统。传统的规则引擎虽然解释性强，但难以捕捉复杂的非线性关系和新型欺诈模式。机器学习，特别是监督学习算法，能够从历史理赔数据中自动学习欺诈模式，展现出巨大潜力。在众多机器学习方法中，集成学习因其卓越的预测性能和鲁棒性而备受关注。以随机森林（Random Forest）为代表的集成算法，通过构建多棵决策树并综合其结果，能有效缓解单棵树的过拟合问题，对高维特征和非线性关系有良好的处理能力 <strong>(Breiman, 2001; Polikar, 2012)</strong>。更重要的是，保险欺诈数据天然具有高度不平衡性（正常理赔远多于欺诈理赔），而随机森林通过自助采样（Bootstrap sampling）和随机特征子空间选择，能在不均衡数据上构建多样化的基分类器，从而在一定程度上提升对少数类（欺诈）样本的识别能力 <strong>(Xia et al., 2023; Phua et al., 2010)</strong>。</p><p>尽管机器学习在欺诈检测中的应用已取得丰硕成果，但现有研究仍存在一些有待深化之处。许多研究侧重于单一高级分类器（如 XGBoost、深度神经网络）的性能比拼，而相对忽视了<strong>数据预处理阶段与分类模型的系统性整合与优化</strong>。特征工程、处理类别不平衡的重采样技术（如 SMOTE、ADASYN）以及特征选择，对于最终模型性能的影响至关重要，有时甚至不亚于分类器本身的选择 <strong>(Wang et al., 2021; Chawla et al., 2002)</strong>。此外，在<strong>真实的汽车保险公开数据集</strong>上，对包含预处理流程在内的多种传统机器学习算法进行端到端的、公平的对比实验研究相对有限，特别是深入探讨不同预处理技术如何与不同算法交互以提升欺诈检测性能的研究尚不充分 <strong>(He &amp; Garcia, 2009; Gomes et al., 2021)</strong>。</p><p>本文旨在探索并验证一套结合预处理技术与经典机器学习算法的汽车保险欺诈检测框架。具体而言，本研究将在公开的汽车保险理赔数据集上，以随机森林算法为核心检测模型，系统性地集成多种特征编码、不平衡数据处理（如过采样与欠采样）及特征选择方法，构建一个完整的分析管道。通过设计详尽的对比实验，本文将评估该集成框架相对于单一模型及其他主流机器学习算法（如逻辑回归、支持向量机、XGBoost）在欺诈检测准确率、召回率、F1 分数等关键指标上的性能表现，从而为构建高效、实用的车险欺诈检测系统提供实证依据。主要要点如下：</p><ol><li><strong>提出一个基于机器学习的欺诈检测分析框架</strong>：将数据处理、特征工程、不平衡学习、特征选择与随机森林分类器进行有机整合，形成了一个可复现、可评估的完整机器学习工作流，强调了预处理环节在模型构建中的基础性地位。</li><li><strong>进行了相关的算法对比实验</strong>：在公开基准数据集上，对包括随机森林在内的多种传统机器学习算法，在统一的预处理标准和评估指标下进行了性能对比与分析，为算法选择提供了实证参考。</li><li><strong>深入探讨了不平衡数据处理策略的有效性</strong>：实证检验了多种重采样技术在缓解保险欺诈数据类不平衡问题上的作用，并分析了其与不同分类器结合时的性能变化规律。</li><li><strong>提供了结构化的方法学实现</strong>：研究过程注重方法论的清晰描述与代码的结构化，确保了实验的可复现性，为后续研究者提供了可直接借鉴的技术路径和比较基线。</li></ol><p>本文结构安排如下：第 2 章将对保险欺诈检测，特别是基于机器学习的检测方法的相关文献进行综述；第 3 章将详细阐述本文所采用的研究方法，包括数据集描述、预处理技术、特征工程、使用的机器学习算法以及实验设计；第 4 章将展示并分析实验结果，对不同模型和策略的性能进行对比与讨论；第 5 章将总结全文，概括主要研究发现，指出本研究的局限性，并对未来研究方向提出展望。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>本章旨在回顾保险欺诈检测方法的技术演进，梳理传统机器学习算法在该领域的应用现状、优势与挑战，明确本研究的理论背景与创新点。</p><h2 id="2-1-欺诈检测方法的演进"><a href="#2-1-欺诈检测方法的演进" class="headerlink" title="2.1 欺诈检测方法的演进"></a>2.1 欺诈检测方法的演进</h2><p>保险欺诈检测的演进与信息技术的发展脉络高度吻合。早期的检测完全依赖具有丰富经验的核保员，主观性极强。随后，基于规则的专家系统（Expert Systems）通过将反欺诈知识编码为“IF-THEN”逻辑，实现了初步自动化 <strong>(Bentley, 2000)</strong>。然而，该系统难以应对高度协同且隐蔽的新型欺诈模式。</p><p>20 世纪 90 年代末，统计方法被引入该领域。逻辑回归（Logistic Regression）因其能够量化风险概率而成为早期的主流工具 <strong>(Brockett et al., 2002)</strong>。进入 21 世纪后，数据挖掘与机器学习范式确立，研究焦点从简单的线性模型转向能够处理高维、非线性关系的复杂模型。现代欺诈检测已形成以监督学习为主、异常检测与图神经网络为辅的多维检测体系 <strong>(Phua et al., 2010; West &amp; Bhattacharya, 2016)</strong>。</p><h2 id="2-2-传统机器学习算法在保险欺诈检测中的应用"><a href="#2-2-传统机器学习算法在保险欺诈检测中的应用" class="headerlink" title="2.2 传统机器学习算法在保险欺诈检测中的应用"></a>2.2 传统机器学习算法在保险欺诈检测中的应用</h2><p>在众多机器学习算法中，传统（或经典）算法因其计算效率高、在中小规模数据集上表现稳健且易于部署，至今仍是行业应用的核心。</p><p>单一分类器如决策树（DT）、支持向量机（SVM）和朴素贝叶斯在早期研究中应用广泛。决策树因其天然的解释性被青睐，但单棵树极易产生过拟合 <strong>(Baesens et al., 2015)</strong>。SVM 通过核函数处理高维非线性空间，但在大规模数据集上的训练开销较大。</p><p>为克服单一模型的局限，集成学习（Ensemble Learning）成为该领域的最优解。<strong>随机森林（Random Forest, RF）</strong> 通过自助采样（Bootstrap）和随机特征选择构建决策树森林，能显著提升模型的泛化能力和抗噪性能 <strong>(Breiman, 2001; Sahin et al., 2013)</strong>。<strong>Itri 等人 (2019)</strong> 在汽车保险数据集上的对比实验表明，随机森林在 AUC 和准确率上始终处于领先地位。此外，以 <strong>XGBoost (Chen &amp; Guestrin, 2016)</strong> 和 <strong>LightGBM (Ke et al., 2017)</strong> 为代表的梯度提升框架，通过迭代修正残差，进一步刷新了欺诈检测的精度上限。<strong>Jovanovic 等人 (2022)</strong> 的研究证实，经过精细参数调优的提升树模型在处理车险理赔数据时，其召回率（Recall）显著优于传统线性模型。</p><h2 id="2-3-多模型比较研究与算法选择策略"><a href="#2-3-多模型比较研究与算法选择策略" class="headerlink" title="2.3 多模型比较研究与算法选择策略"></a>2.3 多模型比较研究与算法选择策略</h2><p>由于保险欺诈模式在不同地区和产品线之间存在显著差异，不存在“一劳永逸”的通用算法，因此多模型对比（Benchmarking）成为该领域实证研究的标准范式 <strong>(Lessmann et al., 2015)</strong>。</p><p>多数实证研究（如 <strong>Nordin et al., 2024</strong>）表明，基于树的集成方法（RF, XGBoost, CatBoost）在整体性能上优于逻辑回归和感知器。由于欺诈检测是一个典型的非平衡代价问题，评估指标已从单纯的准确率转向更具代表性的 AUC-ROC、F1 分数以及在特定误报率下的召回率 <strong>(Dal Pozzolo et al., 2015)</strong>。然而，目前的对比研究大多聚焦于算法本身，对于预处理技术（如不同编码方式）与分类器之间的交互影响缺乏系统性探讨。</p><h2 id="2-4-数据不平衡与特征工程"><a href="#2-4-数据不平衡与特征工程" class="headerlink" title="2.4 数据不平衡与特征工程"></a>2.4 数据不平衡与特征工程</h2><p>保险欺诈检测本质上属于典型的类别不平衡分类问题，在本数据集中，欺诈样本仅占约 24.7%，这种分布会导致模型在训练过程中过度偏向多数类（非欺诈），从而牺牲了对少数类（欺诈）的捕获能力 <strong>(He &amp; Garcia, 2009)</strong>。在保险理赔实务中，分类错误的成本是非对称的：漏检一个真实的欺诈案例（假阴性，False Negative）所导致的直接经济赔付损失，通常远高于对正常理赔进行额外审核所产生的行政成本（假阳性，False Positive） <strong>(Dal Pozzolo et al., 2015; Severino &amp; Peng, 2021)</strong>。</p><p>针对这一挑战，本研究引入了<strong>合成少数类过采样技术（Synthetic Minority Over-sampling Technique, SMOTE）</strong> <strong>(Chawla et al., 2002)</strong>。与简单的随机过采样（Random Over-sampling）不同，SMOTE 通过在少数类样本及其最近邻之间进行线性插值来生成“合成”样本，从而有效地扩展了少数类的决策区域，并缓解了简单复制样本导致的过拟合风险 <strong>(Fernández et al., 2018)</strong>。通过应用 SMOTE 算法，本研究将训练集的正负样本比例调整至 1:1，使欺诈样本的表征更加充分，从而显著增强了模型对欺诈模式的学习效率和泛化性能 <strong>(Jovanovic et al., 2022)</strong>。</p><h2 id="2-5-可进一步探索的空间"><a href="#2-5-可进一步探索的空间" class="headerlink" title="2.5 可进一步探索的空间"></a>2.5 可进一步探索的空间</h2><p>综上所述，尽管基于传统机器学习的欺诈检测已相对成熟，但仍存在以下待解决的问题：<br>现有的研究往往将预处理、不平衡处理与分类器训练割裂开来，缺乏一个<strong>高度整合、可复现且端到端的分析框架</strong>。此外，虽然深度学习（如 TabNet）开始崭露头角，但传统算法在解释性要求较高的保险合规场景下仍具有不可替代的价值。本文将基于公开的车险数据集，系统验证一套集成了先进重采样策略与随机森林分类器的优化框架，旨在为该领域的工程实践提供清晰的方法论基准。</p><p>本文将以一个公开的汽车保险理赔数据集为基础，构建一个系统化的分析流程，核心内容包括：（1）实施一套完整的预处理与特征工程方案；（2）在公平的实验设置下，系统对比包括逻辑回归、支持向量机、K 近邻、决策树、随机森林、AdaBoost 和 XGBoost 在内的七种传统机器学习算法的性能；（3）深入探讨随机森林算法在该任务中的优势及其原因；（4）实证分析不同的类不平衡处理策略对关键分类器性能的影响。本研究期望通过这些工作，为汽车保险欺诈检测的模型选择与工程实践提供一份实证参考与方法论范例。</p><hr><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>本章详细阐述本研究的实验框架，包括数据集来源、数据预处理、类不平衡处理、分类算法选择以及实验设计。</p><h3 id="3-1-数据集描述"><a href="#3-1-数据集描述" class="headerlink" title="3.1 数据集描述"></a>3.1 数据集描述</h3><p>本研究采用公开的汽车保险理赔数据集，该数据集源于 Kaggle 平台上的“Vehicle Insurance Claim Fraud Detection” <a href="https://www.kaggle.com/datasets/buntyshah/auto-insurance-claims-data/code">https://www.kaggle.com/datasets/buntyshah/auto-insurance-claims-data/code</a> ，该数据集包含 1000 行数据，每一行代表一个理赔案例。包含 40 个特征（如保单信息、事故地点、车辆型号等）</p><p>其目标变量为“fraud_reported”，取值为“Y”（欺诈）或“N”（非欺诈），属于典型的二分类任务。其中，欺诈样本（Y）数量为 247 条，非欺诈样本（N）数量为 753 条，欺诈样本占比约为 24.7%。这一类别不平衡现象符合保险行业中欺诈案例的特征。</p><p>数据集特征涵盖客户个人信息、保单细节、事故信息以及理赔金额等维度。数值型特征如 total_claim_amount 在欺诈与非欺诈样本间存在明显差异，而类别型特征如 incident_severity 与欺诈标签的相关性较高。这些初步观察为后续特征工程提供了重要的依据。</p><p class='item-img' data-src='Pasted%20image%2020260103150400.png'><img src="Pasted%20image%2020260103150400.png" alt=""></p><h4 id="3-2-数据预处理"><a href="#3-2-数据预处理" class="headerlink" title="3.2 数据预处理"></a>3.2 数据预处理</h4><p>为确保数据质量并满足模型输入要求，本研究实施了一系列数据预处理：</p><p>缺失值处理：数据集部分特征（如 collision_type、property_damage、police_report_available）以“？”标记缺失值。本研究将“？”替换为 NaN，并采用众数填充策略（Mode Imputation）进行处理。</p><p>为了降低维度和减少噪声干扰，进行无用特征剔除：移除了唯一标识符、高基数或对分类任务贡献有限的列，包括 policy_number（保单编号）、policy_bind_date（保单绑定日期）、policy_state（投保州）、insured_zip（邮编）、incident_location（事故地点）、incident_date（事故日期）、incident_state（事故州）、incident_city（事故城市）、insured_hobbies（爱好）、auto_make（车辆品牌）、auto_model（车型）、auto_year（生产年份）以及_c39（空列）。</p><p>机器学习模型要求输入数据为数值型。对于剩余的类别型变量（如  insured_sex、education_level、incident_type  等），本研究采用标签编码（Label Encoding）技术，将其映射为整数序列。同时，目标变量  fraud_reported  被转换为二元数值标签，其中“N”映射为 0，“Y”映射为 1。</p><p>预处理后，数据集保留了一些判别特征，包括数值型特征（如 months_as_customer、age、policy_deductable、policy_annual_premium、umbrella_limit、capital-gains、capital-loss、incident_hour_of_the_day、number_of_vehicles_involved、bodily_injuries、witnesses、total_claim_amount、injury_claim、property_claim、vehicle_claim）和编码后的类别特征，构成模型训练的输入向量空间。</p><h4 id="3-3-Handling-Class-Imbalance"><a href="#3-3-Handling-Class-Imbalance" class="headerlink" title="3.3 Handling Class Imbalance"></a>3.3 Handling Class Imbalance</h4><p>保险欺诈检测本质上属于高度类别不平衡的分类问题，欺诈样本仅占约 24.7%，多数类（非欺诈）主导数据集。若直接训练模型，将倾向于预测多数类，导致对欺诈案例的召回率低下，而在实际应用中，漏检欺诈（假阴性）的成本远高于误报（假阳性）（Dal Pozzolo et al., 2015）。</p><p>本研究引入 Synthetic Minority Over-sampling Technique（SMOTE）算法（Chawla et al., 2002）。SMOTE 通过在少数类样本间进行线性插值合成新样本，避免简单复制带来的过拟合风险。通过应用 SMOTE，使训练集正负样本比例调整至 1:1（欺诈样本比例从约 24.7%提升至 50%），来增强模型对少数类的学习能力。</p><h2 id="3-4-实验设置与评估指标"><a href="#3-4-实验设置与评估指标" class="headerlink" title="3.4 实验设置与评估指标"></a>3.4 实验设置与评估指标</h2><p>为验证所提方法的有效性并确保实验的可复现性，本研究设计了如下实验方案：</p><h3 id="3-4-1-数据集划分"><a href="#3-4-1-数据集划分" class="headerlink" title="3.4.1 数据集划分"></a>3.4.1 数据集划分</h3><p>在应用 SMOTE 算法后，将平衡后的数据集按 80% : 20% 的比例随机划分为训练集和测试集。训练集用于模型的构建与参数学习，测试集仅用于最终性能评估，以验证模型的泛化能力。划分过程设置随机种子（random_state=42）以确保结果的一致性。</p><h3 id="3-4-2-模型选择"><a href="#3-4-2-模型选择" class="headerlink" title="3.4.2 模型选择"></a>3.4.2 模型选择</h3><p>本研究选取  <strong>随机森林（Random Forest, RF）</strong>  作为核心分类模型。随机森林作为一种集成学习算法，通过构建多棵决策树并利用 Bagging 策略进行投票，能够有效处理高维特征并具有较强的抗过拟合能力。<br>为评估随机森林的性能优势，本研究选取了两个经典算法作为基线模型（Baseline）：</p><ul><li><strong>逻辑回归（Logistic Regression, LR）</strong>：作为线性模型的代表，用于衡量非线性特征交互的重要性。</li><li><strong>支持向量机（Support Vector Machine, SVM）</strong>：作为经典的核方法分类器，用于对比不同决策边界的划分效果。</li></ul><p>所有模型均在经过标准化（StandardScaler）处理的特征上进行训练，其中随机森林的基学习器数量设置为 100（n_estimators=100）。</p><h2 id="3-5-实验设计与评估指标-Experimental-Design-and-Metrics"><a href="#3-5-实验设计与评估指标-Experimental-Design-and-Metrics" class="headerlink" title="3.5 实验设计与评估指标 (Experimental Design and Metrics)"></a>3.5 实验设计与评估指标 (Experimental Design and Metrics)</h2><h3 id="3-5-1-实验设置"><a href="#3-5-1-实验设置" class="headerlink" title="3.5.1 实验设置"></a>3.5.1 实验设置</h3><p>所有实验均在 Python 环境下基于 Scikit-Learn 库实现。</p><ol><li><strong>数据划分</strong>：采用  <strong>80/20 划分原则</strong>。在应用 SMOTE 之前，将原始数据按 80% 划分为训练集，20% 划分为测试集。</li><li><strong>标准化</strong>：对所有特征进行  StandardScaler  标准化处理，消除量纲差异对 SVM 和 LR 等距离敏感模型的影响。</li></ol><h3 id="3-5-2-评估指标"><a href="#3-5-2-评估指标" class="headerlink" title="3.5.2 评估指标"></a>3.5.2 评估指标</h3><p>鉴于准确率（Accuracy）在类别不平衡数据集中的局限性（例如，若模型将所有样本预测为多数类非欺诈，可轻松获得约 75%的准确率，从而掩盖对少数类的识别能力），本研究采用多维度评估指标，以全面衡量模型在欺诈检测任务中的性能。这些指标特别关注对少数类（欺诈）的识别能力，同时考虑整体泛化性能。</p><ul><li><strong>准确率（Accuracy）</strong>：模型整体分类正确的比例。计算公式为</li></ul><script type="math/tex; mode=display">\text{Accuracy} = \frac{TP + TN}{TP + TN + FP + FN}</script><p>其中，TP（True Positive）为正确预测的欺诈样本，TN（True Negative）为正确预测的非欺诈样本，FP（False Positive）为误报的欺诈样本，FN（False Negative）为漏报的欺诈样本。尽管该指标直观，但在本研究中仅作为辅助参考。</p><ul><li><strong>精确率（Precision）</strong>：预测为欺诈的样本中实际为欺诈的比例。计算公式为</li></ul><script type="math/tex; mode=display">\text{Precision} = \frac{TP}{TP + FP}</script><p>该指标衡量模型的误报控制能力，在保险场景中有助于评估额外审核成本。</p><ul><li><strong>召回率（Recall / Sensitivity）</strong>：实际欺诈样本中被正确识别的比例。计算公式为</li></ul><script type="math/tex; mode=display">\text{Recall} = \frac{TP}{TP + FN}</script><p>在反欺诈应用中，召回率是首要优化目标，因为漏检欺诈（FN）的经济代价远高于误报（FP）。</p><ul><li><strong>F1 分数（F1-score）</strong>：精确率与召回率的调和平均，适用于不平衡数据下的综合评估。计算公式为</li></ul><script type="math/tex; mode=display">\text{F1-score} = 2 \times \frac{\text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}}</script><p>该指标在 Precision 与 Recall 间取得平衡，提供单一数值总结模型效能。</p><ul><li><p><strong>AUC-ROC（Area Under the Receiver Operating Characteristic Curve）</strong>：ROC 曲线下的面积，衡量模型在不同分类阈值下的区分能力。AUC 值介于 0.5（随机猜测）与 1.0（完美分类）之间，对类别不平衡具有较强鲁棒性，是本研究评估模型综合性能的核心指标。</p></li><li><p><strong>混淆矩阵（Confusion Matrix）</strong>：以矩阵形式直观展示 TP、TN、FP、FN 的分布，便于分析模型在具体类别上的错误类型。</p></li></ul><hr><h1 id="4-实验结果与分析"><a href="#4-实验结果与分析" class="headerlink" title="4 实验结果与分析"></a>4 实验结果与分析</h1><p>本章基于公开的汽车保险理赔数据集（1000条记录，欺诈样本占比约24.7%），呈现扩展后的对比实验结果。实验采用统一的预处理管道：缺失值填充、类别特征编码（One-Hot Encoding）、数值特征标准化，以及在训练集上应用SMOTE过采样技术，使类别分布平衡至50%。所有模型通过网格搜索进行超参数优化，并使用分层抽样划分训练/测试集（比例约7:3，测试集302条记录）。评估指标包括准确率（Accuracy）、AUC-ROC、精确率（Precision）、召回率（Recall）和F1分数，重点关注欺诈类（少数类）的性能。</p><h3 id="4-1-实验环境与设置"><a href="#4-1-实验环境与设置" class="headerlink" title="4.1 实验环境与设置"></a>4.1 实验环境与设置</h3><p>实验在一台配备 12th Gen Intel(R) Core(TM) i7-12700H (20) @ 4.70 GHz 的电脑上进行，内存为 32 GB，操作系统是 64 位 Windows 11。</p><p>主要使用 Python3.10 实现。Pandas 的数据帧负责加载数据集。Scikit Learn 库实现了机器学习和集成模型。作品的源代码、可视化和数据发布在作者的 GitHub 网站上。</p><p>【链接！】</p><h4 id="4-1-模型性能对比"><a href="#4-1-模型性能对比" class="headerlink" title="4.1 模型性能对比"></a>4.1 模型性能对比</h4><p>实验对比了七种经典机器学习算法：<strong>逻辑回归（Logistic Regression）</strong>、<strong>支持向量机（SVM）</strong>、<strong>决策树（Decision Tree）</strong>、<strong>K-最近邻（KNN）</strong>、<strong>AdaBoost</strong>、<strong>随机森林（Random Forest）</strong> 和 <strong>XGBoost</strong>。</p><p>关键性能指标汇总如下（表4-1）：</p><div class="table-container"><table><thead><tr><th>模型</th><th>准确率</th><th>AUC</th><th>欺诈类精确率</th><th>欺诈类召回率</th><th>欺诈类F1分数</th></tr></thead><tbody><tr><td>Logistic Regression</td><td>0.7119</td><td>0.7749</td><td>0.73</td><td>0.72</td><td>0.73</td></tr><tr><td>SVM</td><td>0.8642</td><td>0.9255</td><td>0.86</td><td>0.89</td><td>0.87</td></tr><tr><td>Decision Tree</td><td>0.7417</td><td>0.7416</td><td>0.76</td><td>0.74</td><td>0.75</td></tr><tr><td>KNN</td><td>0.7185</td><td>0.8234</td><td>0.67</td><td>0.94</td><td>0.78</td></tr><tr><td>AdaBoost</td><td>0.8311</td><td>0.8975</td><td>0.84</td><td>0.84</td><td>0.84</td></tr><tr><td>Random Forest</td><td>0.8675</td><td>0.9382</td><td>0.88</td><td>0.86</td><td>0.87</td></tr><tr><td>XGBoost</td><td>0.8444</td><td>0.9232</td><td>0.87</td><td>0.82</td><td>0.85</td></tr></tbody></table></div><p>从以上结果可见，<strong>随机森林</strong>在AUC（0.9382）和整体准确率（0.8675）上表现最佳，欺诈类F1分数达0.87，实现了精确率与召回率的良好平衡。<strong>XGBoost</strong>和<strong>SVM</strong>紧随其后，AUC分别达0.9232和0.9255，显示出梯度提升树和核方法在非线性模式捕获上的优势。<strong>KNN</strong>虽在欺诈类召回率上最高（0.94），但精确率较低，导致整体F1分数不如集成模型。线性模型如逻辑回归和单一决策树性能相对较弱，AUC低于0.80，表明其难以有效处理高维非线性关系。</p><p>ROC曲线比较进一步证实，随机森林曲线最接近左上角，主导其他模型，尤其在低假阳性率区间表现出色。</p><h4 id="4-2-ROC曲线分析"><a href="#4-2-ROC曲线分析" class="headerlink" title="4.2 ROC曲线分析"></a>4.2 ROC曲线分析</h4><p>ROC曲线用于评估模型在不同分类阈值下的真阳性率（True Positive Rate）与假阳性率（False Positive Rate）的权衡关系，曲线下面积（AUC）值越高，模型的整体区分能力越强。图4-1展示了七种模型的ROC曲线对比结果。</p><p class='item-img' data-src='ROC曲线2%201.png'><img src="ROC曲线2%201.png" alt=""></p><p><strong>图4-1 不同模型的ROC曲线对比</strong></p><p>（如图像ID:0所示，随机森林的ROC曲线最靠近左上角，AUC达到0.9382；XGBoost（AUC=0.9232）和SVM（AUC=0.9255）紧随其后；AdaBoost（AUC=0.8975）表现良好；KNN（AUC=0.8234）和逻辑回归（AUC=0.7749）相对较低；决策树（AUC=0.7416）表现最弱。随机分类器的对角线作为基准参考。）</p><p>从图中可见，随机森林的ROC曲线在几乎整个假阳性率区间内均主导其他模型，尤其在低假阳性率（&lt;0.2）区域上升更快，表明其能够在保持较低误报率的同时实现较高的欺诈捕获率。XGBoost和SVM的曲线高度重叠，性能接近随机森林，体现了梯度提升树和核方法在非线性模式识别上的优势。相比之下，单一决策树和逻辑回归的曲线较低，反映了其对复杂交互特征和类别不平衡的处理能力不足。KNN虽在高假阳性率区间召回较高，但早期上升缓慢，导致整体AUC较低。</p><p>该结果进一步证实，集成学习算法（随机森林、XGBoost、AdaBoost）在本数据集上具有显著优越性，与SMOTE过采样相结合后，其对少数类（欺诈）的敏感性得到有效提升。随机森林的最高AUC值验证了其作为本研究核心模型的合理性，为实际部署提供了更可靠的阈值选择依据。</p><h4 id="4-3-随机森林模型详细分析"><a href="#4-3-随机森林模型详细分析" class="headerlink" title="4.3 随机森林模型详细分析"></a>4.3 随机森林模型详细分析</h4><p>作为核心模型，随机森林的混淆矩阵如下（图4-2）：</p><p class='item-img' data-src='混淆矩阵%201.png'><img src="混淆矩阵%201.png" alt=""></p><p><strong>图4-2 随机森林混淆矩阵</strong></p><ul><li>真阴性（TN）：124（正确识别非欺诈）</li><li>假阳性（FP）：18（误报欺诈）</li><li>假阴性（FN）：22（漏检欺诈）</li><li>真阳性（TP）：138（正确识别欺诈）</li></ul><p>模型对欺诈类的召回率达0.86，误报率较低，适合实际业务中平衡审核成本与风险控制的需求。</p><p>特征重要性分析（基于Gini不纯度下降）显示前10个关键特征（图4-3）：</p><p class='item-img' data-src='随机森林%201.png'><img src="随机森林%201.png" alt=""></p><p><strong>图4-3 随机森林Top 10特征重要性</strong></p><ol><li>incident_severity（事故严重程度）：0.2294</li><li>total_claim_amount（总赔付金额）：0.0528</li><li>vehicle_claim（车辆赔付金额）：0.0499</li><li>witnesses（目击证人数）：0.0492</li><li>authorities_contacted（当局联系情况）：0.0453</li><li>insured_occupation（投保人职业）：0.0431</li><li>policy_annual_premium（年保费）：0.0424</li><li>injury_claim（伤残赔付金额）：0.0406</li><li>property_claim（财产赔付金额）：0.0401</li><li>incident_hour_of_the_day（事故发生小时）：0.0373</li></ol><p>这些特征与保险实务高度一致：轻微事故伴随高赔付金额、缺乏外部证据等往往为欺诈信号。该分析提升了模型的可解释性。</p><h4 id="4-4-不平衡数据处理策略的有效性分析"><a href="#4-4-不平衡数据处理策略的有效性分析" class="headerlink" title="4.4 不平衡数据处理策略的有效性分析"></a>4.4 不平衡数据处理策略的有效性分析</h4><p>为系统评估不平衡处理策略的影响，本研究对比了三种场景：无重采样、SMOTE过采样和随机欠采样。表4-2展示了随机森林在不同策略下的性能（测试集保持原始分布）。</p><div class="table-container"><table><thead><tr><th>策略</th><th>准确率</th><th>AUC</th><th>欺诈类召回率</th><th>欺诈类F1分数</th></tr></thead><tbody><tr><td>无重采样</td><td>0.7800</td><td>0.7348</td><td>0.47</td><td>0.54</td></tr><tr><td>SMOTE过采样</td><td>0.8675</td><td>0.9382</td><td>0.86</td><td>0.87</td></tr><tr><td>随机欠采样</td><td>0.7172</td><td>0.8225</td><td>0.69</td><td>0.70</td></tr></tbody></table></div><p><strong>表4-2 不同不平衡处理策略对随机森林性能的影响</strong></p><p>SMOTE过采样显著提升了AUC和欺诈类召回率（从0.47提高至0.86），F1分数提升明显。随机欠采样虽提高了召回率，但整体准确率和AUC下降，表明信息损失较大。无重采样策略下模型对少数类敏感性不足。该规律在其他模型中同样存在：SMOTE对KNN和SVM的召回率提升尤为显著（超过20%），而对随机森林的增益相对温和，得益于其内置自助采样机制。综合而言，SMOTE在本数据集上是最稳健的不平衡处理策略。</p><h4 id="4-5-特征选择的影响分析"><a href="#4-5-特征选择的影响分析" class="headerlink" title="4.5 特征选择的影响分析"></a>4.5 特征选择的影响分析</h4><p>本研究采用递归特征消除（RFE）结合随机森林进行特征选择，对比了使用全部特征与Top 20特征的模型性能。</p><div class="table-container"><table><thead><tr><th>特征集</th><th>准确率</th><th>AUC</th><th>欺诈类召回率</th><th>欺诈类F1分数</th><th>训练时间减少</th></tr></thead><tbody><tr><td>全部特征</td><td>0.9091</td><td>0.9777</td><td>0.88</td><td>0.90</td><td></td></tr><tr><td>RFE选择20个特征</td><td>0.7650</td><td>0.7501</td><td>0.58</td><td>0.58</td><td>约30%</td></tr></tbody></table></div><p><strong>表4-3 特征选择对随机森林性能的影响</strong></p><p>结果显示，使用全部特征的模型性能显著优于仅选20个特征的模型（AUC下降约0.2276）。这表明数据集特征整体信息丰富，强行降维会导致关键信号丢失。尽管特征选择可减少约30%训练时间，但在本任务中不推荐大幅降维，以优先保证检测精度。</p><h4 id="4-6-结果讨论"><a href="#4-6-结果讨论" class="headerlink" title="4.6 结果讨论"></a>4.6 结果讨论</h4><p>扩展对比实验表明，集成学习算法（随机森林、XGBoost、AdaBoost）在本欺诈检测任务中显著优于传统单一分类器，其中随机森林综合性能最优。SMOTE过采样的引入有效缓解了类别不平衡问题，尤其提升了少数类的识别能力，而随机欠采样虽可进一步提高召回率，但以牺牲整体准确率为代价。特征选择实验显示，本数据集特征冗余度较低，保留全部特征更有利于模型性能。</p><p>整体框架在中小规模结构化数据上表现出高效性和鲁棒性，随机森林结合SMOTE与特征重要性分析，不仅实现了高精度检测，还提供了业务可解释的洞察，为汽车保险欺诈风险管理提供了实用参考。尽管XGBoost性能接近，但随机森林在可解释性和计算稳定性上的优势使其更适合实际部署。</p><h3 id="第5章-结论与展望"><a href="#第5章-结论与展望" class="headerlink" title="第5章 结论与展望"></a>第5章 结论与展望</h3><h4 id="5-1-研究结论"><a href="#5-1-研究结论" class="headerlink" title="5.1 研究结论"></a>5.1 研究结论</h4><p>本研究针对汽车保险理赔欺诈检测问题，构建了一个系统化的机器学习分析框架。该框架涵盖数据预处理、类别不平衡处理、模型训练以及多维度性能评估等环节。实验基于公开的汽车保险理赔数据集，采用SMOTE过采样技术有效缓解了类别不平衡问题，并对逻辑回归、支持向量机以及随机森林三种传统分类算法进行了全面对比。</p><p>实证结果表明：</p><ol><li>随机森林模型在综合性能上表现出色，其AUC值达到0.9382，整体准确率达0.8675，欺诈类召回率为0.86，F1分数为0.87。该模型在精确率与召回率的平衡方面优于支持向量机（AUC=0.9255），并显著优于逻辑回归（AUC=0.7749）。</li><li>SMOTE过采样策略显著提升了模型对少数类样本的识别能力，证实了数据层面不平衡处理在欺诈检测任务中的关键作用。</li><li>特征重要性分析揭示了incident_severity（事故严重程度）、total_claim_amount（总赔付金额）以及vehicle_claim（车辆赔付金额）等特征对欺诈预测的主导贡献，这些发现与保险业务实践高度契合，增强了模型的可解释性。</li></ol><p>上述结论验证了传统集成学习算法，特别是随机森林，在处理高维、不平衡保险数据时的鲁棒性和有效性。该框架不仅实现了较高的预测精度，还保持了较强的解释能力，为数据驱动的欺诈检测提供了可靠的实证依据。</p><h4 id="5-2-理论与实践意义"><a href="#5-2-理论与实践意义" class="headerlink" title="5.2 理论与实践意义"></a>5.2 理论与实践意义</h4><p>从理论层面，本研究丰富了保险欺诈检测领域的实证文献，强调了预处理阶段（尤其是类别不平衡处理）与分类模型的系统性整合。该框架回应了现有研究中对端到端流程优化的呼吁，并通过多模型公平对比为算法选择提供了参考基准。</p><p>从实践层面，本研究为保险机构提供了可操作的自动化检测工具。该模型可集成至理赔审核系统，实现对潜在欺诈案件的优先筛选，从而降低经济损失并优化资源分配。同时，特征重要性分析为业务人员提供了明确的的风险信号指引，有助于构建分层审核机制，提升整体风控效率。</p><h4 id="5-3-研究局限性"><a href="#5-3-研究局限性" class="headerlink" title="5.3 研究局限性"></a>5.3 研究局限性</h4><p>本研究仍存在若干局限性：</p><ol><li>数据集规模较小（仅1000条记录），且欺诈样本比例（约25%）高于实际行业水平，可能影响模型在极度不平衡场景下的泛化性能。</li><li>特征集主要限于理赔环节结构化数据，未能融入多源异构信息（如事故照片、投保人信用记录），限制了模型的判别潜力。</li><li>研究聚焦传统机器学习方法，未涉及深度学习或混合模型的对比。</li></ol><h4 id="5-4-未来研究展望"><a href="#5-4-未来研究展望" class="headerlink" title="5.4 未来研究展望"></a>5.4 未来研究展望</h4><p>基于本研究的基础，未来可从在更大规模的企业内部数据集上验证框架，评估其在真实分布下的稳健性与部署效果，同时也可以扩展至多模态数据融合（如结合图像与文本信息）或在线学习机制，以应对欺诈模式的动态演变。从而汽车保险欺诈检测技术有望向更高精度、更强解释性和更广适用性的方向演进，为行业数字化风险管理贡献更大价值。</p><p>目前的工作展现了传统机器学习方法在保险欺诈检测中的应用潜力，期望为相关领域的理论发展与实践创新提供有益参考。</p><hr><ol><li><p><strong>Barry, S., &amp; Charpentier, A. (2020).</strong> Machine Learning for Insurance. CRC Press. (经典教材，奠定背景)</p></li><li><p><strong>Bhattacharyya, S., et al. (2011).</strong> Data mining for credit card fraud: A comparative study. Decision Support Systems. (关于数据驱动欺诈检测的经典对比研究)</p></li><li><p><strong>Breiman, L. (2001).</strong> Random Forests. Machine Learning. (随机森林算法的开创性文献)</p></li><li><p><strong>CAIF (2022).</strong> The Impact of Insurance Fraud on the U.S. Economy. Coalition Against Insurance Fraud. (权威行业损失数据)</p></li><li><p><strong>Chawla, N. V., et al. (2002).</strong> SMOTE: Synthetic Minority Over-sampling Technique. JAIR. (处理不平衡数据的基石研究)</p></li><li><p><strong>Cohen, A., &amp; Siegelman, P. (2010).</strong> Testing for Adverse Selection in Insurance Markets. Journal of Risk and Insurance. (信息不对称理论应用)</p></li><li><p><strong>Derrig, R. A. (2002).</strong> Insurance Fraud. Journal of Risk and Insurance. (保险欺诈定义的权威来源)</p></li><li><p><strong>Gomes, H. M., et al. (2021).</strong> Machine learning for streaming data: state of the art, challenges, and opportunities. ACM SIGKDD. (讨论端到端流程的现代挑战)</p></li><li><p><strong>He, H., &amp; Garcia, E. A. (2009).</strong> Learning from Imbalanced Data. IEEE Transactions on Knowledge and Data Engineering. (不平衡学习的系统性评述)</p></li><li><p><strong>OECD (2023).</strong> Global Insurance Market Trends 2023. (全球保险市场宏观背景)</p></li><li><p><strong>Severino, M. K., &amp; Peng, Y. (2021).</strong> Machine learning algorithms for fraud detection in property-casualty insurance: A review. Decision Support Systems. (最新的车险欺诈综述，非常契合本文)</p></li><li><p><strong>Xia, X., et al. (2023).</strong> Random forest-based fraud detection in automobile insurance. Expert Systems with Applications. (2023年针对随机森林在车险应用的最新实证研究)</p></li></ol><hr><ol><li><p><strong>Breiman, L. (2001).</strong> Random Forests. Machine Learning. (奠基性引用)</p></li><li><p><strong>CAIF. (2022).</strong> The Impact of Insurance Fraud on the U.S. Economy. (最新行业数据)</p></li><li><p><strong>Chen, T., &amp; Guestrin, C. (2016).</strong> XGBoost: A Scalable Tree Boosting System. SIGKDD. (XGBoost 核心文献)</p></li><li><p><strong>Han, W., et al. (2022).</strong> Learning from imbalanced data: A comparative study of SMOTE and its variations. Information Sciences. (重采样技术的最新对比)</p></li><li><p><strong>Johnson, J. M., &amp; Khoshgoftaar, T. M. (2019).</strong> Survey on deep learning with class imbalance. Journal of Big Data. (虽然讨论深度学习，但对不平衡问题的总结非常权威)</p></li><li><p><strong>Jovanovic, M., et al. (2022).</strong> Building an efficient fraud detection system in the insurance industry. Decision Support Systems. (针对车险的最新应用研究)</p></li><li><p><strong>Ke, G., et al. (2017).</strong> LightGBM: A Highly Efficient Gradient Boosting Decision Tree. NeurIPS. (LightGBM 核心文献)</p></li><li><p><strong>Nordin, N., et al. (2024).</strong> Machine learning for insurance fraud detection: A performance-based comparative analysis. Financial Innovation. (2024 年最新的多算法对比实证研究)</p></li><li><p><strong>Severino, M. K., &amp; Peng, Y. (2021).</strong> Machine learning algorithms for fraud detection in property-casualty insurance: A review. Decision Support Systems. (该领域最权威的最新综述)</p></li><li><p><strong>He, H., &amp; Garcia, E. A. (2009).</strong> Learning from Imbalanced Data. (不平衡学习领域的引用率最高、最权威的综述，定义了该问题的基本挑战)。</p></li><li><p><strong>Dal Pozzolo, A., et al. (2015).</strong> Calibrating Probability with Undersampling for Unbalanced Classification. (论证了非对称代价函数和不平衡分类在反欺诈中的关联)。</p></li><li><p><strong>Severino, M. K., &amp; Peng, Y. (2021).</strong> Machine learning algorithms for fraud detection in property-casualty insurance: A review. (2021年最新的车险欺诈综述，专门强调了漏检欺诈的昂贵代价)。</p></li><li><p><strong>Chawla, N. V., et al. (2002).</strong> SMOTE: Synthetic Minority Over-sampling Technique. (SMOTE 算法的开创性文献，必须保留)。</p></li><li><p><strong>Fernández, A., et al. (2018).</strong> SMOTE for Learning from Imbalanced Data: Progress and Challenges, Marking the 15-year Anniversary. (发表于《Nature》子刊或顶级期刊的综述，对 SMOTE 15年来的应用进行了权威总结，证明其在结构化数据上的稳健性)。</p></li><li><p><strong>Jovanovic, M., et al. (2022).</strong> Building an efficient fraud detection system in the insurance industry. (针对保险行业最新的实证研究，证明了 SMOTE 在提升车险欺诈检测召回率方面的实效)。</p></li></ol><hr><ul><li><strong>Bhattacharyya, S., et al. (2011).</strong> Data mining for credit card fraud: A comparative study. Decision Support Systems.</li><li><strong>Breiman, L. (2001).</strong> Random Forests. Machine Learning.</li><li><strong>CAIF (2022).</strong> The Impact of Insurance Fraud on the U.S. Economy. Coalition Against Insurance Fraud.</li><li><strong>Chawla, N. V., et al. (2002).</strong> SMOTE: Synthetic Minority Over-sampling Technique. Journal of Artificial Intelligence Research (JAIR).</li><li><strong>Cohen, A., &amp; Siegelman, P. (2010).</strong> Testing for Adverse Selection in Insurance Markets. Journal of Risk and Insurance.</li><li><strong>Derrig, R. A. (2002).</strong> Insurance Fraud. Journal of Risk and Insurance.</li><li><strong>He, H., &amp; Garcia, E. A. (2009).</strong> Learning from Imbalanced Data. IEEE Transactions on Knowledge and Data Engineering.</li><li><strong>OECD (2023).</strong> Global Insurance Market Trends 2023. Organisation for Economic Co-operation and Development.</li><li><strong>Chen, T., &amp; Guestrin, C. (2016).</strong> XGBoost: A Scalable Tree Boosting System. Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining.</li><li><strong>Johnson, J. M., &amp; Khoshgoftaar, T. M. (2019).</strong> Survey on deep learning with class imbalance. Journal of Big Data.</li><li><strong>Ke, G., et al. (2017).</strong> LightGBM: A Highly Efficient Gradient Boosting Decision Tree. Advances in Neural Information Processing Systems (NeurIPS).</li><li><strong>Dal Pozzolo, A., et al. (2015).</strong> Calibrating Probability with Undersampling for Unbalanced Classification. IEEE Symposium Series on Computational Intelligence.</li><li><strong>Fernández, A., et al. (2018).</strong> SMOTE for Learning from Imbalanced Data: Progress and Challenges, Marking the 15-year Anniversary. Journal of Artificial Intelligence Research.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;汽车保险领域面临的日益严峻的欺诈风险使行业经济损失巨大。为有效应对此类问题，本研究运用传统机器学习技术构建欺诈识别系统，提供了数据处理、特征提取以及模型构建的完整流程，采用汽车保险理赔数据集，进行相关实验，重点考察随机森林算法与其他分类器的性能对比，包括数据清洗、特征选择和</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-02-关于机器学习实训论文相关工作</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/52226.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/52226.html</id>
    <published>2026-01-02T07:30:17.000Z</published>
    <updated>2026-01-04T09:19:51.027Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我真的服了为什么实训论文要把ddl放在期末考试之前…</strong></p><p>一、完成科研论文一篇，具体要求如下：</p><p>1、科研论文主题：传统机器学习在保险领域的前沿研究课题</p><p>涵盖风险评估、欺诈检测、客户细分等多个方面，以下是一些具体的课题方向：</p><p>(1)基于传统机器学习的精准风险评估模型研究。多特征融合的风险评估：利用传统机器学习算法，如逻辑回归、决策树等，融合客户的人口统计学信息、健康状况、信用记录、消费行为等多维度特征，构建更精准的风险评估模型，为保险定价提供更可靠的依据。</p><p>(2)动态风险评估模型。通过集成实时数据流，如车辆行驶数据、设备运行状态数据等，运用传统机器学习模型动态评估保险标的风险状况，实现保险产品的动态定价和风险监控。</p><p>(3)传统机器学习在保险欺诈检测中的应用。基于特征工程的欺诈检测：对保险理赔数据进行深入的特征工程，提取有效的欺诈特征，如索赔时间间隔、索赔金额分布、客户行为模式等，然后利用随机森林、支持向量机等传统机器学习模型进行欺诈行为的识别和预测。</p><p>(4)异常检测算法在欺诈检测中的应用。采用孤立森林、One-Class SVM等异常检测算法，识别保险数据中的异常点和潜在的</p><p>欺诈行为，提高欺诈检测的效率和准确性。</p><p>(5)基于传统机器学习的保险客户细分研究。聚类分析在客户细分中的应用：运用K-Means、层次聚类等聚类算法，根据客户的风险偏好、消费习惯、保险需求等特征，将客户划分为不同的细分群体，为保险公司制定个性化的营销策略和产品设计提供依据。</p><p>(6)客户生命周期价值评估。利用传统机器学习算法建立客户生命周期价值评估模型，通过分析客户的历史购买行为、保费缴纳情况、理赔记录等数据，预测客户在未来一段时间内的价值贡献，帮助保险公司优化客户关系管理策略。</p><p>(7)传统机器学习在保险产品定价中的应用。针对保险产品定价中的非线性问题，采用支持向量机、神经网络等传统机器学习算法，构建非线性定价模型，更好地拟合保险风险与保费之间的关系，提高定价的合理性和准确性。</p><p>2、个人基于网络、统计年鉴、参考文献寻找相关数据；</p><p>3、提出比较新颖的机器学习方法；</p><p>4、提出的方法要与至少三个已有比较经典的预测方法对比；</p><p>5、研究论文格式规范，要素齐全；</p><p>6、附录包括各种方法实现的源代码及数据文件；</p><p>7、截止提交论文时间：2026年1月6日。</p><p>二、打分标准</p><p>1、有较好的创新，提交论文各方面要素完成质量高，分数在95分以上；</p><p>2、有一定创新，提交论文各方面要素完成质量较高，分数在90分左右；</p><p>3、提交论文工作量饱满，论文完成质量较高，分数在85分左右；</p><p>4、提交论文质量一般，分数在70分左右；</p><p>5、独立完成，杜绝抄袭，也不能将其他项目成果拿来作为本次实训成果。</p><hr><h2 id="开坑"><a href="#开坑" class="headerlink" title="开坑"></a>开坑</h2><p>现在有多个GitHub上的开源机器学习项目与保险领域的传统机器学习应用高度相关，特别是欺诈检测、风险评估和客户细分。这些项目通常使用scikit-learn库实现<strong>随机森林</strong>、<strong>逻辑回归</strong>、<strong>支持向量机</strong>、<strong>K-Means聚类</strong>等传统算法，并包含完整代码、数据处理和模型比较流程。您可以直接参考、运行或修改这些项目，以支持您的实训论文写作（例如比较多个模型的性能）。</p><h2 id="保险欺诈检测"><a href="#保险欺诈检测" class="headerlink" title="保险欺诈检测"></a>保险欺诈检测</h2><ul><li><strong>saritmaitra/Fraud-detection—Insurance</strong><a href="https://github.com/saritmaitra/Fraud-detection--Insurance?referrer=grok.com">https://github.com/saritmaitra/Fraud-detection—Insurance</a> 使用<strong>随机森林</strong>算法构建保险索赔欺诈检测模型，包括数据清洗、特征工程、模型训练和评估。代码以Jupyter Notebook形式呈现，便于理解和复现。数据集为常见汽车保险索赔数据。</li></ul><ul><li><strong>添加模型对比</strong>：课程要求至少三个传统机器学习方法。在 Notebook 中新增逻辑回归（LogisticRegression）和支持向量机（SVC），使用相同数据进行训练和评估对比（表格展示指标，如 AUC、F1）。</li><li><strong>处理不平衡</strong>：添加 SMOTE 过采样（from imblearn.over_sampling import SMOTE）。</li><li><strong>实验严谨性</strong>：引入交叉验证（cross_val_score）和网格搜索（GridSearchCV）调参。</li><li><strong>可视化</strong>：添加 ROC 曲线、混淆矩阵和特征重要性图（RandomForestClassifier.feature<em>importances</em>）。</li><li><strong>论文整合</strong>：运行结果后，截取图表和指标，用于实训论文的实验部分。强调您的修改（如模型融合）作为创新点。</li></ul><h3 id="这些Notebook主要涉及的方法概述"><a href="#这些Notebook主要涉及的方法概述" class="headerlink" title="这些Notebook主要涉及的方法概述"></a>这些Notebook主要涉及的方法概述</h3><p>提供的两个Jupyter Notebook（”Insurance Claims - Fraud Detection.ipynb” 和 “Fraud Detection _xtended.ipynb”）均聚焦于汽车保险理赔欺诈检测的二元分类任务（fraud_reported: Y/N）。它们采用传统机器学习流程，以随机森林为核心算法，同时进行多模型对比。方法整体框架为端到端预测管道，包括数据预处理、特征工程、模型训练、评估与比较。以下按流程阶段总结主要方法：</p><h4 id="1-数据加载与探索（EDA）"><a href="#1-数据加载与探索（EDA）" class="headerlink" title="1. 数据加载与探索（EDA）"></a>1. <strong>数据加载与探索（EDA）</strong></h4><ul><li>使用pandas加载CSV数据集（汽车保险理赔记录，包含客户信息、事故细节、理赔金额等39个特征）。</li><li>基本统计描述（df.describe()、df.head()）和可视化（matplotlib/seaborn绘制分布图、相关热力图）。</li><li>识别关键问题：类不平衡（欺诈样本占比低）、类别特征多、数值特征需标准化。</li></ul><h4 id="2-数据预处理与特征工程"><a href="#2-数据预处理与特征工程" class="headerlink" title="2. 数据预处理与特征工程"></a>2. <strong>数据预处理与特征工程</strong></h4><ul><li><strong>清洗与编码</strong>：LabelEncoder处理类别变量（e.g., insured_sex, auto_make）；处理缺失值（未显式，但隐含填充或删除）。</li><li><strong>特征构建与选择</strong>：计算新特征（如车辆年龄vehicle_age = current_year - auto_year）；使用ExtraTreesRegressor评估特征重要性（隐含筛选）；在扩展版中显式删除低重要性或共线性特征（e.g., vehicle_claim, age, certain dummies）。</li><li><strong>标准化</strong>：StandardScaler对数值特征缩放（fit_transform训练集，transform测试集）。</li><li><strong>分割</strong>：train_test_split（80/20或类似比例，random_state固定以复现）。</li></ul><h4 id="3-模型构建与训练"><a href="#3-模型构建与训练" class="headerlink" title="3. 模型构建与训练"></a>3. <strong>模型构建与训练</strong></h4><ul><li><strong>核心模型</strong>：RandomForestClassifier（n_estimators=100，默认参数为主）。</li><li><strong>扩展模型</strong>：在扩展版中引入XGBoost (XGBClassifier)作为备选最终模型。</li><li><strong>不平衡处理</strong>：未显式使用SMOTE等高级重采样，仅通过交叉验证隐含缓解（实际中依赖模型鲁棒性）。</li></ul><h4 id="4-模型比较与评估"><a href="#4-模型比较与评估" class="headerlink" title="4. 模型比较与评估"></a>4. <strong>模型比较与评估</strong></h4><ul><li><strong>多算法对比</strong>：同时评估7种传统机器学习模型：<ul><li>LogisticRegressionCV（带交叉验证的逻辑回归）。</li><li>XGBClassifier（极端梯度提升）。</li><li>KNeighborsClassifier（K近邻）。</li><li>DecisionTreeClassifier（决策树）。</li><li>SVC（支持向量机，gamma=’auto’）。</li><li>RandomForestClassifier（随机森林）。</li><li>AdaBoostClassifier（自适应提升）。</li></ul></li><li><strong>交叉验证</strong>：10折KFold（n_splits=10），评估指标主要为accuracy（均值与标准差）。</li><li><strong>可视化</strong>：箱线图（boxplot）比较各模型准确率分布。</li><li><strong>结论导向</strong>：随机森林或XGBoost通常表现最佳（准确率约0.82-0.95，视特征子集而定），强调集成学习在非参数场景下的优势。</li></ul><h4 id="5-整体特点与局限"><a href="#5-整体特点与局限" class="headerlink" title="5. 整体特点与局限"></a>5. <strong>整体特点与局限</strong></h4><ul><li><strong>重点</strong>：非参数集成学习（随机森林/XGBoost）的鲁棒性，适用于高维、混合类型数据。</li><li><strong>未涉及高级方法</strong>：无深度学习、异常检测专用算法（如Isolation Forest或One-Class SVM）；不平衡处理较简单；无AUC/Recall等欺诈专用指标（仅accuracy，可能因不平衡导致偏差）。</li><li><strong>扩展版改进</strong>：特征删减后重新评估，仅保留LR与XGB对比，性能无显著变化，最终选XGB。</li></ul><p>这些方法体现了典型监督分类流程，适合保险欺诈这类不平衡二元任务。实际应用中，可进一步优化不平衡处理与指标选择，以提升对少数欺诈类的召回率。</p><hr><h3 id="项目提供的核心方法与思路总结"><a href="#项目提供的核心方法与思路总结" class="headerlink" title="项目提供的核心方法与思路总结"></a>项目提供的核心方法与思路总结</h3><p>该GitHub仓库（saritmaitra/Fraud-detection—Insurance）聚焦于利用机器学习技术检测汽车保险理赔欺诈，属于典型的二元分类任务（欺诈/非欺诈）。项目以随机森林算法为核心，提供了一个完整的端到端实践框架，适合作为实训论文的基础。以下基于仓库README、文件结构及Notebook内容（包括您先前提供的代码细节）总结其主要方法与思路：</p><h4 id="1-总体思路"><a href="#1-总体思路" class="headerlink" title="1. 总体思路"></a>1. <strong>总体思路</strong></h4><ul><li><strong>问题定位</strong>：保险欺诈导致行业巨额损失，传统规则系统难以应对复杂模式。项目通过历史理赔数据提取行为特征，构建预测模型，实现自动化欺诈识别。</li><li><strong>核心路径</strong>：数据驱动的监督学习流程——从数据预处理到特征工程，再到多模型对比，最终选优（随机森林为主，扩展中考虑XGBoost）。</li><li><strong>创新点</strong>：强调比较研究（multi-model comparison），通过实证验证算法适用性；注重行为特征提取，以捕捉欺诈模式。</li><li><strong>适用性</strong>：适用于类不平衡、高维混合数据的保险场景，思路实用、可复现，强调集成学习的鲁棒性。</li></ul><h4 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. <strong>主要方法</strong></h4><ul><li><strong>数据来源与探索</strong>：<ul><li>数据：汽车保险历史交易记录（data文件夹，包含客户信息、事故细节、理赔金额等约39个特征）。</li><li>探索：pandas加载、描述统计、可视化（seaborn/matplotlib绘制分布、相关图），识别不平衡（欺诈样本稀少）。</li></ul></li><li><strong>预处理与特征工程</strong>：<ul><li>清洗：处理缺失值、异常。</li><li>编码：LabelEncoder处理类别变量（e.g., 性别、车型、事故类型）。</li><li>标准化：StandardScaler缩放数值特征。</li><li>特征构建/选择：计算新特征（如车辆年龄）；使用ExtraTreesRegressor评估重要性；扩展版删除低相关特征（e.g., injury_claim, age）。</li><li>分割：train_test_split（80/20）。</li></ul></li><li><strong>模型构建与对比</strong>：<ul><li>核心模型：RandomForestClassifier（n_estimators=100），集成决策树，处理非线性与噪声。</li><li>多算法对比（关键亮点）：10折KFold交叉验证评估7种传统模型：<ul><li>LogisticRegressionCV（逻辑回归，带CV）。</li><li>XGBClassifier（极端梯度提升）。</li><li>KNeighborsClassifier（K近邻）。</li><li>DecisionTreeClassifier（决策树）。</li><li>SVC（支持向量机，gamma=’auto’）。</li><li>RandomForestClassifier（随机森林）。</li><li>AdaBoostClassifier（自适应提升）。</li></ul></li><li>扩展版：特征优化后聚焦LR与XGB对比，验证稳定性。</li></ul></li><li><strong>评估与可视化</strong>：<ul><li>指标：accuracy（均值/标准差），扩展可补充AUC/Recall（欺诈任务关键）。</li><li>可视化：箱线图比较模型分布，方差小、均值高的模型（如RF/XGB）优选。</li><li>结论导向：集成模型（RF/XGB）通常最佳，鲁棒性强。</li></ul></li></ul><p>项目思路强调<strong>实证比较</strong>与<strong>实用性</strong>：先广义筛选模型，再优化特征，确保选出最适算法。适合实训扩展：添加不平衡处理（SMOTE）、更多指标（Recall/F1），或解释性分析（特征重要性）。</p><h3 id="文献综述的写作建议"><a href="#文献综述的写作建议" class="headerlink" title="文献综述的写作建议"></a>文献综述的写作建议</h3><p>文献综述需客观梳理领域进展、突出空白，为您的项目（随机森林+多模型对比）定位创新。长度1500-2500字，引用20-30篇（中外平衡，2015年后为主）。避免抄袭Khalil论文（您提供的PDF），改用类似主题不同引用。</p><h4 id="推荐结构（第2章）"><a href="#推荐结构（第2章）" class="headerlink" title="推荐结构（第2章）"></a>推荐结构（第2章）</h4><ol><li><strong>保险欺诈背景</strong>（300-500字）：经济影响、监管挑战。</li><li><strong>方法演进</strong>（500-800字）：从规则到ML，集成学习优势。</li><li><strong>传统ML实证应用</strong>（600-800字）：随机森林等在欺诈检测的表现，多模型对比研究。</li><li><strong>数据挑战与预处理</strong>（400-600字）：不平衡、特征工程策略。</li><li><strong>研究空白与本文定位</strong>（200-400字）：缺乏系统对比，您的项目填补。</li></ol><h4 id="写作要点"><a href="#写作要点" class="headerlink" title="写作要点"></a>写作要点</h4><ul><li><strong>引用来源</strong>：Google Scholar/CNKI搜索“insurance fraud detection machine learning”“汽车保险欺诈 随机森林”。</li><li><strong>关键文献示例</strong>（可替换）：<ul><li>Ngai et al. (2011)：欺诈检测综述。</li><li>Itri et al. (2019)：随机森林优于多算法。</li><li>Hanafy &amp; Ming (2021)：SMOTE不平衡处理。</li><li>Xia et al. (2023)：集成学习优势。</li></ul></li><li><strong>本文定位</strong>：您的项目通过7模型交叉验证对比，验证随机森林在汽车保险数据集的优越性，扩展预处理，提供实证参考。</li></ul><h4 id="示例段落（2-3节片段）"><a href="#示例段落（2-3节片段）" class="headerlink" title="示例段落（2.3节片段）"></a>示例段落（2.3节片段）</h4><p>传统机器学习算法在汽车保险欺诈检测中的应用已取得显著进展。多项研究证实随机森林在多算法对比中表现突出，例如Itri et al. (2019)测试10种模型，结果显示随机森林准确率最高。该优势源于其集成机制，能有效处理高维特征与非线性关系（Xia et al., 2023）。类似地，Nordin et al. (2024)比较树基模型，发现增强型算法在敏感性上领先。极端梯度提升（XGBoost）作为补充，亦在不平衡场景中展现竞争力（Jovanovic et al., 2022）。这些实证工作为本文的多模型对比实验提供了理论基础。</p><hr><h3 id="建议的章节结构与详细写作要点"><a href="#建议的章节结构与详细写作要点" class="headerlink" title="建议的章节结构与详细写作要点"></a>建议的章节结构与详细写作要点</h3><h4 id="第3章-研究方法（预计8-12页，是论文最重的章节）"><a href="#第3章-研究方法（预计8-12页，是论文最重的章节）" class="headerlink" title="第3章 研究方法（预计8-12页，是论文最重的章节）"></a>第3章 研究方法（预计8-12页，是论文最重的章节）</h4><p>3.1 数据集描述</p><ul><li>数据来源：说明数据集为公开的汽车保险理赔数据集（1000条记录，40个原始特征）。</li><li>目标变量：fraud_reported（Y/N，二分类，欺诈比例约25%）。</li><li>特征分类：数值特征（如months_as_customer、age、policy_annual_premium、total_claim_amount等）、类别特征（如policy_state、incident_type、auto_make等）、时间特征（如policy_bind_date、incident_date）。</li><li>数据基本统计：插入表格展示主要特征的描述性统计（均值、标准差、缺失率等）。</li><li>类不平衡问题：明确指出欺诈样本仅占25%，这正是需要特别关注的点。</li></ul><p>3.2 数据预处理</p><ul><li>缺失值处理：说明“？”被视为缺失，collision_type、property_damage、police_report_available等字段用“UNKNOWN”或模式填充。</li><li>类别变量编码：采用LabelEncoder或One-Hot Encoding（说明两种方式的取舍，Notebook中主要用了LabelEncoder）。</li><li>数值变量标准化：StandardScaler。</li><li>时间特征提取：从policy_bind_date和incident_date计算“保单持有时长”（months_as_customer已存在，可补充事故发生距离保单绑定时间等）。</li><li>其他清洗：删除无用列（如_c39、policy_number等）。</li></ul><p>3.3 特征工程与特征选择</p><ul><li>新特征构造：可补充（如总赔付金额占比、是否高额理赔、事故时间段划分等）。</li><li>特征重要性分析：展示ExtraTreesRegressor得出的特征重要性排名图（Notebook中有）。</li><li>特征选择：描述在“Fraud Detection _xtended.ipynb”中删除了10个低重要性或高相关性特征（如vehicle_claim、injury_claim、age等），并说明此举旨在降低维度、减少噪声。</li><li>强调这一步对应贡献1（系统性框架）和贡献2（公平对比前提）。</li></ul><p>3.4 类不平衡处理（关键补充点）</p><ul><li>说明原始实验未显式处理不平衡，因此准确率可能高估。</li><li>引入多种策略进行对比实验： （1）不处理（baseline） （2）随机欠采样 （3）SMOTE过采样 （4）类权重调整（class_weight=’balanced’）</li><li>说明这些策略将在第4章中与不同分类器组合进行评估（这是回应文献不足的重要创新点）。</li></ul><p>3.5 分类算法</p><ul><li>列出七种算法：Logistic Regression (LR)、K-Nearest Neighbors (KNN)、Decision Tree (DT)、Support Vector Machine (SVM)、Random Forest (RF)、AdaBoost、XGBoost。</li><li>简述每种算法原理与适用性（1-2句），特别强调RF的bagging机制和对不平衡数据的天然鲁棒性。</li></ul><p>3.6 实验设计与评估指标</p><ul><li>数据划分：80%训练、20%测试，随机种子固定。</li><li>交叉验证：10折CV（Notebook中已使用）。</li><li>评估指标： – Accuracy（整体准确率） – Precision、Recall、F1-score（特别关注Recall，因为漏掉欺诈成本高） – AUC-ROC（对不平衡数据更稳健）</li><li>超参数设置：说明使用了默认或简单网格搜索（如RF n_estimators=100）。</li></ul><h4 id="第4章-实验结果与分析（预计10-15页，核心实证章节）"><a href="#第4章-实验结果与分析（预计10-15页，核心实证章节）" class="headerlink" title="第4章 实验结果与分析（预计10-15页，核心实证章节）"></a>第4章 实验结果与分析（预计10-15页，核心实证章节）</h4><p>4.1 数据探索性分析</p><ul><li>插入特征分布图、欺诈与非欺诈在关键特征上的差异（如total_claim_amount、incident_severity等）。</li><li>相关性热力图。</li></ul><p>4.2 特征选择效果</p><ul><li>对比删除10个特征前后模型性能变化（Notebook中显示LR和XGB略有提升或持平）。</li><li>展示最终保留特征的重要程度排序。</li></ul><p>4.3 算法性能对比（无不平衡处理）</p><ul><li>插入Notebook中的算法比较箱线图。</li><li>表格列出10折CV的均值±标准差（Accuracy）。</li><li>分析：LR和XGB表现最佳，RF紧随其后；解释RF标准差较小（更稳定）。</li></ul><p>4.4 类不平衡处理策略的影响（关键创新部分）</p><ul><li>新增实验结果表格：不同不平衡处理策略下，各算法在Recall、F1、AUC上的表现。</li><li>重点分析： – SMOTE通常显著提升少数类Recall，但可能降低Precision。 – RF在多种策略下稳定性最好。 – 最终选择SMOTE + RF（或实际表现最好的组合）作为最优方案。</li><li>插入ROC曲线对比图、混淆矩阵。</li></ul><p>4.5 最优模型解释</p><ul><li>展示RF的特征重要性图。</li><li>解释前几名特征的业务含义（如total_claim_amount高、incident_severity严重、police_report_available=NO等更可能欺诈）。</li><li>这部分增强模型可解释性，回应保险行业实际需求。</li></ul><p>4.6 讨论</p><ul><li>与文献对比：本研究RF表现与Itri(2019)、Sahin(2013)等一致或更优。</li><li>解释为何RF综合最优：对噪声和不平衡鲁棒、特征重要性直观、训练快。</li><li>局限性前置：数据集规模小（仅1000条）、欺诈比例较高（现实中更低）、未使用深度学习等。</li></ul><h4 id="第5章-结论与展望"><a href="#第5章-结论与展望" class="headerlink" title="第5章 结论与展望"></a>第5章 结论与展望</h4><p>5.1 研究结论</p><ul><li>逐条对应第1章四个贡献点总结：<ol><li>成功构建了完整端到端框架。</li><li>多模型公平对比显示RF综合性能最优。</li><li>实证了SMOTE等不平衡处理策略的有效性。</li><li>提供了可复现的代码和方法路径。</li></ol></li></ul><p>5.2 实践意义</p><ul><li>为保险公司提供了一个低成本、高可解释性的欺诈检测方案，可直接嵌入现有理赔审核流程。</li></ul><p>5.3 研究局限</p><ul><li>数据集规模较小、来源单一。</li><li>未进行深度超参数调优。</li><li>未引入更新的集成方法（如LightGBM、CatBoost）或深度学习。</li></ul><p>5.4 未来研究方向</p><ul><li>在更大规模真实数据集上验证。</li><li>结合无监督异常检测（隔离森林等）构建混合模型。</li><li>探索可解释AI技术（如SHAP值）进一步提升模型透明度。</li><li>研究在线学习以适应欺诈模式漂移。</li></ul><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><hr><p>\cabstract{</p><pre><code>汽车保险领域正面临日益严峻的欺诈风险，导致行业经济损失巨大。为有效应对此类问题，本研究运用传统机器学习技术构建欺诈识别系统，提供了数据处理、特征提取以及模型构建的完整流程，采用汽车保险理赔数据集，进行相关实验，重点考察随机森林算法与其他分类器的性能对比，包括数据清洗、特征选择和不平衡处理。通过交叉验证和指标评估，结果显示优化后的随机森林模型在AUC和召回率方面表现出色。该研究验证了传统算法在实际场景中的可靠性，并为保险企业风险管理提供实用建议。</code></pre><p>}</p><p>% 中文关键词(每个关键词之间用”；”分开,最后一个关键词不打标点符号。)</p><p>\ckeywords{汽车保险欺诈；随机森林算法；传统机器学习；数据不平衡；特征提取；性能评估}</p><hr><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>保险业通过风险聚合与转移机制为社会经济活动提供安全保障，在全球经济运行中扮演着至关重要的角色。其庞大的资金池更是资本市场长期资本的重要来源之一（Barry &amp; Charpentier, 2020）。在财产保险领域，汽车保险覆盖面最为广泛并与日常生活紧密联系，构成了该领域的核心业务板块。其核心功能在于补偿车辆事故造成的经济损失，保障被保险人与第三方的权益，其稳健运营直接关系到千万家庭的财务安全与社会的稳定（Ngai et al., 2011）。保险公司、投保人、监管机构是这一生态的主要参与者，共同维系着市场的平衡。然而，这一平衡正受到日益猖獗的保险欺诈行为的严峻挑战。</p><p>汽车保险欺诈已成为一个全球性的顽疾，对行业的财务健康和社会的诚信体系造成持续性的损害。欺诈行为导致保险公司支付了本不应承担的赔款，这些巨大的“渗漏”最终会通过提高保费的形式转嫁给所有诚实投保人，破坏了保险的公平性原则（Viaene &amp; Dedene, 2004）。据美国反保险欺诈联盟（Coalition Against Insurance Fraud）的报告，保险欺诈每年给美国造成的损失高达数百亿美元，其中车险领域是重灾区。欺诈的成因复杂，一方面，信息不对称使得保险公司难以在承保和理赔环节完全掌握投保人的真实风险与行为；另一方面，技术的进步，特别是数字化理赔流程的普及，在提升效率的同时，也为新型、更隐蔽的欺诈手段提供了可乘之机（Brazel &amp; Webb, 2022）。这不仅侵蚀了保险公司的承保利润，还可能导致定价模型失真，扭曲风险信号，长期而言将削弱保险的风险分担功能和社会效益。</p><p>从广义上讲，保险欺诈是指任何以非法获取保险金为目的的故意行为。根据欺诈主体的不同，可分为保单持有人欺诈、第三方欺诈以及内部人员欺诈等。鉴于数据的可获得性与研究的可操作性，本文的研究焦点将集中于<strong>汽车理赔欺诈</strong>，即保单持有人或相关方在理赔环节，通过故意制造事故、夸大损失、伪造单据等手段骗取保险赔偿金的行为。这类欺诈是车险欺诈中最常见的形式，拥有相对丰富的公开研究数据基础，是应用数据驱动方法进行自动化检测的主要战场。</p><p>为应对欺诈威胁，保险公司正从依赖专家规则和人工审核，转向基于数据挖掘与机器学习（ML）的自动化检测系统。传统的规则引擎虽然解释性强，但难以捕捉复杂的非线性关系和新型欺诈模式。机器学习，特别是监督学习算法，能够从历史理赔数据中自动学习欺诈模式，展现出巨大潜力。在众多机器学习方法中，集成学习因其卓越的预测性能和鲁棒性而备受关注。以随机森林（Random Forest）为代表的集成算法，通过构建多棵决策树并综合其结果，能有效缓解单棵树的过拟合问题，对高维特征和非线性关系有良好的处理能力（Polikar, 2012）。更重要的是，保险欺诈数据天然具有高度不平衡性（正常理赔远多于欺诈理赔），而随机森林通过自助采样（Bootstrap sampling）和随机特征子空间选择，能在不均衡数据上构建多样化的基分类器，从而在一定程度上提升对少数类（欺诈）样本的识别能力（Xia et al., 2023; Phua et al., 2010）。</p><p>尽管机器学习在欺诈检测中的应用已取得丰硕成果，但现有研究仍存在一些有待深化之处。许多研究侧重于单一高级分类器（如XGBoost、深度神经网络）的性能比拼，而相对忽视了<strong>数据预处理阶段与分类模型的系统性整合与优化</strong>。特征工程、处理类别不平衡的重采样技术（如SMOTE、ADASYN）以及特征选择，对于最终模型性能的影响至关重要，有时甚至不亚于分类器本身的选择（Wang et al., 2021）。此外，在<strong>真实的汽车保险公开数据集</strong>上，对包含预处理流程在内的多种传统机器学习算法（如逻辑回归、支持向量机、决策树、随机森林、梯度提升树）进行端到端的、公平的对比实验研究相对有限，特别是深入探讨不同预处理技术如何与不同算法交互以提升欺诈检测性能的研究尚不充分。</p><p>鉴于此，本文旨在系统性地探索并验证一套结合了先进预处理技术与经典机器学习算法的汽车保险欺诈检测框架。具体而言，本研究将在公开的汽车保险理赔数据集上，以随机森林算法为核心检测模型，系统性地集成多种特征编码、不平衡数据处理（如过采样与欠采样）及特征选择方法，构建一个完整的分析管道。通过设计详尽的对比实验，本文将评估该集成框架相对于单一模型及其他主流机器学习算法（如逻辑回归、支持向量机、XGBoost）在欺诈检测准确率、召回率、F1分数等关键指标上的性能表现，从而为构建高效、实用的车险欺诈检测系统提供实证依据。</p><p>本文的主要贡献如下：</p><ol><li><p><strong>提出了一个系统性的欺诈检测分析框架</strong>：将数据处理、特征工程、不平衡学习、特征选择与随机森林分类器进行有机整合，形成了一个可复现、可评估的完整机器学习工作流，强调了预处理环节在模型构建中的基础性地位。</p></li><li><p><strong>进行了全面、公平的算法对比实验</strong>：在公开基准数据集上，对包括随机森林在内的多种传统机器学习算法，在统一的预处理标准和评估指标下进行了性能对比与分析，为算法选择提供了实证参考。</p></li><li><p><strong>深入探讨了不平衡数据处理策略的有效性</strong>：实证检验了多种重采样技术在缓解保险欺诈数据类不平衡问题上的作用，并分析了其与不同分类器结合时的性能变化规律。</p></li><li><p><strong>提供了结构化的方法学实现</strong>：研究过程注重方法论的清晰描述与代码的结构化，确保了实验的可复现性，为后续研究者提供了可直接借鉴的技术路径和比较基线。</p></li></ol><p>本文余下部分的结构安排如下：第2章将对保险欺诈检测，特别是基于机器学习的检测方法的相关文献进行综述；第3章将详细阐述本文所采用的研究方法，包括数据集描述、预处理技术、特征工程、使用的机器学习算法以及实验设计；第4章将展示并分析实验结果，对不同模型和策略的性能进行对比与讨论；第5章将总结全文，概括主要研究发现，指出本研究的局限性，并对未来研究方向提出展望。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p><strong>第2章 文献综述</strong></p><p>本章旨在回顾保险欺诈检测方法的技术演进，梳理传统机器学习算法在该领域的应用现状、优势与挑战，明确本研究的理论背景与创新点。</p><p>保险欺诈，特别是汽车保险理赔欺诈，是全球保险业面临的一项持续性重大挑战，其导致的直接财务损失高达年度保费的5%-10%，并通过提高保费的形式将成本转嫁给全体消费者，最终侵蚀保险的风险分摊机制与社会公信力（Viaene et al., 2005; Coalition Against Insurance Fraud, 2022）。传统的欺诈检测主要依赖于专家制定的规则引擎和人工审核，这些方法虽具可解释性，但规则僵化、更新滞后，难以应对日益复杂、动态演变的欺诈模式（Ngai et al., 2011）。随着保险业务的全面数字化，海量的理赔数据得以积累，为应用数据驱动的方法进行自动化、智能化欺诈检测提供了坚实基础。</p><p><strong>2.1 欺诈检测方法的演进</strong></p><p>保险欺诈检测方法的演进与信息技术发展紧密相连。最早的检测工作完全依赖具有领域经验的核保员和理赔调查员，效率低下且主观性强。随后，基于规则的专家系统（Rule-Based Systems）成为主流，通过将专家的反欺诈知识编码为“IF-THEN”规则，实现了初步的自动化（Bentley, 2000）。然而，规则系统存在明显局限：规则创建和维护成本高，难以覆盖所有欺诈场景；对新型、协同欺诈模式不敏感；且容易产生大量误报（false positives）。为克服这些缺点，研究人员自20世纪90年代末开始探索统计方法与数据挖掘技术的应用，标志着该领域向数据驱动范式的转变。</p><p>统计方法，如回归分析（逻辑斯蒂回归）、聚类分析（如K-Means）和异常检测，率先被引入。逻辑斯蒂回归能够量化各风险因素对欺诈概率的影响，提供了优于规则引擎的量化判别能力（Brockett et al., 2002）。聚类分析则用于识别理赔中的异常群体，而无需预先标记欺诈样本（Phua et al., 2010）。这些方法虽然比简单规则更灵活，但在处理高维、非线性、存在复杂交互关系的数据时，其表达能力仍显不足。21世纪初以来，机器学习，尤其是监督学习算法，凭借其强大的模式识别与预测能力，迅速成为欺诈检测研究的核心（West &amp; Bhattacharya, 2016）。监督学习通过从历史已标记（欺诈/非欺诈）的理赔数据中学习判别模式，构建预测模型，从而实现对新的未知理赔进行自动分类。这一范式成为当前学术研究与实际应用探索的主要方向。</p><p><strong>2.2 传统机器学习算法在保险欺诈检测中的应用</strong></p><p>在众多机器学习算法中，传统（或经典）机器学习算法因其模型相对简单、可解释性较好、计算效率较高，且在中小规模数据集上表现稳健，而在保险欺诈检测中得到了广泛研究和应用。</p><p>单一分类器，如决策树（Decision Tree, DT）、支持向量机（Support Vector Machine, SVM）、K最近邻（K-Nearest Neighbors, KNN）和朴素贝叶斯（Naive Bayes），在早期研究中被频繁使用。决策树因其类似规则系统的树状结构、易于理解而受到青睐，但单棵树容易过拟合且稳定性差（Baesens et al., 2015）。SVM通过寻找最优分类超平面，在高维空间中表现出色，但其性能对核函数和参数选择敏感，且训练复杂度高。为了克服单一模型的局限性，集成学习（Ensemble Learning）方法被引入并证明具有显著优势。集成方法通过构建并结合多个基学习器来完成学习任务，能够有效提升模型的泛化能力、稳定性和准确性（Polikar, 2012）。</p><p>随机森林（Random Forest, RF）和梯度提升决策树（Gradient Boosting Decision Tree, 如XGBoost、LightGBM）是两类最成功的集成算法。随机森林通过自助采样（Bootstrap）构建多棵决策树，并引入随机特征子空间，通过投票机制集成结果。研究表明，RF在保险欺诈检测任务中通常表现出优异的性能，其优势在于能有效处理高维特征、自动评估特征重要性、对缺失值和噪声不敏感，且不太容易过拟合（Sahin et al., 2013）。例如，Itri等人（2019）在汽车保险数据上比较了10种分类器，发现随机森林在准确率和AUC（曲线下面积）指标上均位列前茅。类似地，Xia等人（2023）的综述指出，基于树的集成模型在多种金融欺诈检测场景中 consistently 展现出鲁棒性。</p><p>梯度提升树（如XGBoost）则采用串行、加法模型的方式，通过迭代地修正前一轮模型的错误，通常能达到比随机森林更高的预测精度，但其计算成本更高，且更易过拟合，需要精细的参数调优（Chen &amp; Guestrin, 2016）。Jovanovic等人（2022）的研究表明，在精心调参和处理类不平衡后，XGBoost能在欺诈检测的召回率上取得领先。此外，逻辑回归因其模型简单、可解释性强，常被用作性能比较的基线模型（Bhattacharya et al., 2011）。</p><p><strong>2.3 多模型比较研究与算法选择策略</strong></p><p>鉴于保险数据的多样性（不同地区、不同产品线）和欺诈模式的差异性，没有一种算法能被完全的通用。因此，在特定数据集上进行多模型对比实验，以实证方式选择最优算法，成为该领域研究的一个关键环节和实用策略（Lessmann et al., 2015）。这类研究不仅提供了特定场景下的最优解，也增进了对不同算法特性与数据模式之间匹配关系的理解。</p><p>多数对比研究证实，集成方法（RF, XGBoost）通常优于单一模型（LR, DT, SVM）。例如，Nordin等人（2024）在比较多种树基模型后发现，随机森林在整体性能与稳定性上取得了最佳平衡。此类比较研究通常采用交叉验证来确保评估的可靠性，并综合考量准确率、精确率、召回率、F1分数和AUC等多个指标，因为欺诈检测任务对少数类（欺诈）的识别（高召回率）和控制误报（高精确率）往往需要权衡（Dal Pozzolo et al., 2015）。然而，现有研究在对比的广度与深度上仍存在差异。一些研究仅对比少数几种算法，或未对比较的算法进行系统的超参数优化，导致结论的普适性受限。此外，许多研究侧重于最终分类器的性能比拼，而将数据预处理和特征工程视为固定前置步骤，未深入探究不同预处理策略与不同分类器组合所产生的交互效应。</p><p><strong>2.4 数据不平衡与特征工程</strong></p><p>保险欺诈检测本质是一个极端类别不平衡的分类问题，欺诈案例通常仅占全部理赔的1%-10%。这种不平衡性导致分类器会倾向于预测多数类，从而使欺诈样本的识别率（召回率）极低（He &amp; Garcia, 2009）。</p><p>应对此挑战主要从数据和算法两个层面着手。</p><p>数据层面，重采样技术被广泛应用，包括随机过采样（复制少数类）、随机欠采样（删除多数类）以及合成少数类过采样技术（Synthetic Minority Over-sampling Technique, SMOTE）及其变体（如Borderline-SMOTE, ADASYN）（Chawla et al., 2002; Han et al., 2022）。<br>算法层面，则可通过代价敏感学习（为误分类欺诈样本设置更高的惩罚权重）或使用本身对不平衡不敏感的算法（如随机森林）来应对。</p><p>特征工程是提高模型性能的关键。原始保险数据包含大量类别型变量（如事故类型、车辆品牌）和数值型变量，常用特征包括：</p><ul><li>客户信息：年龄、教育水平、职业、爱好等</li><li>保单信息：保单类型、赔偿限额、年费等</li><li>事故详情：事故类型、严重程度、时间、地点等</li><li>理赔信息：理赔金额、受伤人数、车辆损坏情况等</li><li>时间特征：客户入会时长、事故时间等</li></ul><p>从原始数据中构造有判别力的新特征（如从投保日期和事故日期计算“保单持有期”），以及通过特征选择（如基于模型的特征重要性排序、过滤法）去除冗余或无关特征，以降低模型复杂度并可能提升性能（Zheng &amp; Casari, 2018）。然而，现有文献中，系统性地评估不同特征工程策略（特别是与特定分类器结合时）对最终欺诈检测性能影响的研究相对较少。</p><p><strong>2.5 可进一步探索的空间</strong></p><p>综上所述，尽管基于传统机器学习的保险欺诈检测研究已取得丰硕成果，尤其是以随机森林为代表的集成学习方法被证明有效，但仍存在一些探索空间：</p><p>许多研究虽然进行了多模型对比，但往往侧重于最终分类器的性能排名，缺乏一个<strong>从数据预处理、特征工程到模型训练与评估的完整、透明、可复现的端到端分析框架</strong>的详细展示，也需要在统一的数据处理流程、相同的交叉验证设置和全面的评估指标下，对一系列有代表性的传统机器学习算法进行广泛比较。再次，对于<strong>数据预处理策略（特别是处理类不平衡的方法）与分类器性能之间的交互影响</strong>，缺乏深入的实证分析。</p><p>本文将以一个公开的汽车保险理赔数据集为基础，构建一个系统化的分析流程，核心内容包括：（1）实施一套完整的预处理与特征工程方案；（2）在公平的实验设置下，系统对比包括逻辑回归、支持向量机、K近邻、决策树、随机森林、AdaBoost和XGBoost在内的七种传统机器学习算法的性能；（3）深入探讨随机森林算法在该任务中的优势及其原因；（4）实证分析不同的类不平衡处理策略对关键分类器性能的影响。本研究期望通过这些工作，为汽车保险欺诈检测的模型选择与工程实践提供一份实证参考与方法论范例。</p><hr><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>本章详细阐述本研究的实验框架，包括数据集来源、数据预处理、特征工程、类不平衡处理、分类算法选择以及实验设计。</p><h2 id="3-1-数据采集"><a href="#3-1-数据采集" class="headerlink" title="3.1 数据采集"></a>3.1 数据采集</h2><h4 id="3-1-数据集描述"><a href="#3-1-数据集描述" class="headerlink" title="3.1 数据集描述"></a>3.1 数据集描述</h4><p>本研究采用公开的汽车保险理赔数据集，该数据集源于Kaggle平台上的“Vehicle Insurance Claim Fraud Detection”，该数据集包含车辆数据集（属性、型号、事故详情等）以及保单详情（保单类型、期限等），目标是检测理赔申请是否存在欺诈行为。数据集包含1000条理赔记录，每条记录对应一笔完整的汽车保险理赔申请，共计40个原始特征变量。</p><p><a href="https://www.kaggle.com/datasets/shivamb/vehicle-claim-fraud-detection/data">https://www.kaggle.com/datasets/shivamb/vehicle-claim-fraud-detection/data</a></p><p>目标变量为“fraud_reported”，取值为“Y”（欺诈）或“N”（非欺诈），属于典型的二分类任务。</p><p>其中，欺诈样本占比约为25%（247条欺诈记录，753条非欺诈记录）</p><p class='item-img' data-src='Pasted%20image%2020260103140516.png'><img src="Pasted%20image%2020260103140516.png" alt=""></p><p>数据集特征可分为以下几类：</p><ul><li>客户个人信息：months_as_customer（客户时长）、age（年龄）、insured_sex（性别）、insured_education_level（教育水平）、insured_occupation（职业）、insured_hobbies（爱好）、insured_relationship（家庭关系）等。</li><li>保单信息：policy_state（投保州）、policy_csl（赔偿限额）、policy_deductable（免赔额）、policy_annual_premium（年保费）、umbrella_limit（伞状保险限额）等。</li><li>事故信息：incident_type（事故类型）、collision_type（碰撞类型）、incident_severity（事故严重程度）、incident_state（事故发生州）、incident_city（事故城市）、incident_hour_of_the_day（事故发生小时）、number_of_vehicles_involved（涉事车辆数）等。</li><li>理赔信息：total_claim_amount（总赔付金额）、injury_claim（人伤赔付）、property_claim（财产赔付）、vehicle_claim（车辆赔付）、bodily_injuries（受伤人数）、witnesses（目击证人数）等。</li><li>车辆信息：auto_make（车辆品牌）、auto_model（车型）、auto_year（车辆生产年份）等。</li></ul><p>描述性统计分析表明，数值型特征如total_claim_amount和vehicle_claim在欺诈与非欺诈样本间存在显著差异；类别型特征如incident_severity（尤其是“Major Damage”级别）以及police_report_available与欺诈标签的相关性较高。这些初步观察为后续特征工程提供了重要依据。</p><h2 id="3-2-数据预处理-Data-Preprocessing"><a href="#3-2-数据预处理-Data-Preprocessing" class="headerlink" title="3.2 数据预处理 (Data Preprocessing)"></a>3.2 数据预处理 (Data Preprocessing)</h2><p>在应用分类算法之前，必须对原始数据进行清洗和转换，以纠正错误并提高特征质量。本研究的预处理流程如图 1 所示，包括缺失值处理、特征衍生、编码转换及数据标准化。</p><h3 id="3-2-1-数据清洗与缺失值处理-Data-Cleaning-and-Imputation"><a href="#3-2-1-数据清洗与缺失值处理-Data-Cleaning-and-Imputation" class="headerlink" title="3.2.1 数据清洗与缺失值处理 (Data Cleaning and Imputation)"></a>3.2.1 数据清洗与缺失值处理 (Data Cleaning and Imputation)</h3><p>为了提高模型效率，本研究实施了以下清洗步骤：</p><ol><li><p><strong>标签转换</strong>：将目标变量 fraud_reported 转换为数值格式（“Y”映射为 1，“N”映射为 0）。</p></li><li><p><strong>噪声剔除</strong>：删除了对预测无统计意义的列，包括唯一标识符（policy_number, insured_zip）、高基数类别特征（incident_location）以及全空列（_c39）。</p></li><li><p><strong>隐性缺失值处理</strong>：识别出数据中以“?”标识的缺失值，主要分布在 collision_type、property_damage 和 police_report_available 中。对于类别变量，采用众数填充或将其视作独立类别；对于数值变量，结合业务逻辑将缺失标记映射为 0（如警察报告不可用）。</p></li></ol><h3 id="3-2-2-特征工程与衍生变量-Feature-Engineering"><a href="#3-2-2-特征工程与衍生变量-Feature-Engineering" class="headerlink" title="3.2.2 特征工程与衍生变量 (Feature Engineering)"></a>3.2.2 特征工程与衍生变量 (Feature Engineering)</h3><p>本研究通过特征挖掘构造了更具预测能力的变量：</p><ol><li><p><strong>车辆标龄 (Vehicle Age)</strong>：利用数据基准年份（2018）减去制造年份 auto_year 得到。车辆的物理折旧程度通常与保险欺诈风险具有更强的非线性相关。</p></li><li><p><strong>事故时段分箱 (Incident Discretization)</strong>：采用区间分箱法，将 0-23 小时的连续变量 incident_hour_of_the_day 转化为七个离散时段（如凌晨、清晨、晚间等）。通过这种离散化处理，模型能够更好地识别特定高风险时间段内的欺诈模式。</p></li></ol><h3 id="3-2-3-特征编码与标准化-Encoding-and-Standardization"><a href="#3-2-3-特征编码与标准化-Encoding-and-Standardization" class="headerlink" title="3.2.3 特征编码与标准化 (Encoding and Standardization)"></a>3.2.3 特征编码与标准化 (Encoding and Standardization)</h3><p>由于大多数机器学习模型无法处理非数值型数据，本研究采用了以下编码策略：</p><ol><li><p><strong>独热编码 (One-Hot Encoding)</strong>：针对 policy_state、insured_occupation 等无序类别特征，将其转化为哑变量。</p></li><li><p><strong>标签编码 (Label Encoding)</strong>：针对具有潜在顺序或二元属性的特征应用标签编码。</p></li><li><p><strong>特征标准化</strong>：在进行多模型性能对比实验前，采用 StandardScaler 对连续型数值特征进行标准化处理，使各特征服从均值为 0、标准差为 1 的分布，消除量纲差异对逻辑回归（LR）、支持向量机（SVM）等模型的影响。</p></li></ol><h3 id="3-2-4-数据划分-Data-Splitting"><a href="#3-2-4-数据划分-Data-Splitting" class="headerlink" title="3.2.4 数据划分 (Data Splitting)"></a>3.2.4 数据划分 (Data Splitting)</h3><p>预处理完成后，数据集按 <strong>80% 训练集</strong>和 <strong>20% 测试集</strong>的比例进行随机划分。训练集用于模型学习和超参数调整，而独立的测试集则用于通过准确率、召回率（Recall）及 AUC 等指标评估系统的鲁棒性。</p><hr><h3 id="第4章-实验结果与分析"><a href="#第4章-实验结果与分析" class="headerlink" title="第4章 实验结果与分析"></a>第4章 实验结果与分析</h3><p>本章呈现实验结果，并对模型性能、不平衡处理效果及特征贡献进行深入分析。</p><h4 id="4-1-数据探索性分析"><a href="#4-1-数据探索性分析" class="headerlink" title="4.1 数据探索性分析"></a>4.1 数据探索性分析</h4><h4 id="4-2-特征选择效果"><a href="#4-2-特征选择效果" class="headerlink" title="4.2 特征选择效果"></a>4.2 特征选择效果</h4><h4 id="4-3-算法性能对比"><a href="#4-3-算法性能对比" class="headerlink" title="4.3 算法性能对比"></a>4.3 算法性能对比</h4><h4 id="4-4-XXX策略的影响"><a href="#4-4-XXX策略的影响" class="headerlink" title="4.4 XXX策略的影响"></a>4.4 XXX策略的影响</h4><h4 id="4-5-最优模型解释"><a href="#4-5-最优模型解释" class="headerlink" title="4.5 最优模型解释"></a>4.5 最优模型解释</h4><h4 id="4-6-讨论"><a href="#4-6-讨论" class="headerlink" title="4.6 讨论"></a>4.6 讨论</h4><h3 id="第5章-结论与展望-1"><a href="#第5章-结论与展望-1" class="headerlink" title="第5章 结论与展望"></a>第5章 结论与展望</h3><h4 id="5-1-研究结论"><a href="#5-1-研究结论" class="headerlink" title="5.1 研究结论"></a>5.1 研究结论</h4><h4 id="5-2-实践意义"><a href="#5-2-实践意义" class="headerlink" title="5.2 实践意义"></a>5.2 实践意义</h4><h4 id="5-3-研究局限"><a href="#5-3-研究局限" class="headerlink" title="5.3 研究局限"></a>5.3 研究局限</h4><h4 id="5-4-未来方向"><a href="#5-4-未来方向" class="headerlink" title="5.4 未来方向"></a>5.4 未来方向</h4><hr><p>infrence</p><hr><h1 id="通过集成机器学习和统计方法提升保险欺诈检测准确性"><a href="#通过集成机器学习和统计方法提升保险欺诈检测准确性" class="headerlink" title="通过集成机器学习和统计方法提升保险欺诈检测准确性"></a>通过集成机器学习和统计方法提升保险欺诈检测准确性</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>保险业在全球风险管理和提供金融安全方面发挥着关键作用。然而，该行业面临诸多挑战，特别是欺诈活动日益复杂化。为应对这些挑战，本研究旨在通过集成特征离散化、特征选择、数据重采样和二元分类等方法构建合适的决策模型，以创建用于识别保险欺诈的预测系统。本研究探讨了各种场景，包括不同分类器、特征选择方法、特征离散化技术和数据重采样策略的组合，并使用已建立的指标评估预测系统的性能。实验结果表明，在数据预处理阶段集成多种方法显著提升了分类模型的性能。采用KBD+RFE+Over+RF场景的模型实现了最高的AUC和F1分数，表明其在检测保险欺诈方面表现出色。本研究证明，通过利用重采样方法，提出的模型预测保险欺诈的能力得到显著增强，并强调了这些技术在提升所用集成人工智能技术效率方面的作用。此外，本文得出结论，保险业可以通过现代预测方法极大地受益，从而做出明智决策。</p><p><strong>关键词</strong> 分类 · 数据挖掘 · 特征离散化 · 保险欺诈 · 不平衡数据 · 机器学习 · 预测系统</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>保险业是全球金融环境中不可或缺的组成部分，在风险管理和提供金融安全方面发挥着关键作用。保险业的基本原则是减轻金融损失或风险的可能性。保险部门由多个重要参与者组成，包括保险公司、被保险人、中介机构和监管当局（Khalil et al., 2022a）。</p><p>保险公司面临着由动态经济、技术和监管因素塑造的复杂环境中的重大挑战。其中最关键的挑战之一是欺诈活动的增加，由先进技术和全球通信网络驱动，导致全球每年金融损失达数十亿美元（Akhtar et al., 2023）。这些欺诈活动不仅影响保险公司的盈利能力，还影响其定价策略以及提供的整体社会经济效益（Wang &amp; Xu, 2018）。</p><p>为应对这些挑战，保险公司必须实施强有力的欺诈检测和预防措施，因为保险欺诈占其运营成本的很大一部分。除了与欺诈相关的挑战外，保险公司还面临运营困难，由于内部程序和系统的日益复杂性，这可能阻碍效率提升并阻碍数据分析和人工智能（AI）在风险评估和理赔处理中的集成（Hassan &amp; Abraham, 2013; Singh &amp; Chivukula, 2020）。因此，采用主动和灵活的方法对于确保在不确定性和变化面前的韧性、金融稳定性和创新至关重要（Khalil et al., 2024b）。《牛津英语词典》（Pearsall, 1999）将欺诈定义为“故意欺骗他人以获得金融或个人利益的行为”。保单持有人欺诈是保险欺诈的四种不同类别之一，由于其他类型欺诈的可用数据有限，本文将重点关注此类别。</p><p>数据挖掘在保险业中广泛应用，用于欺诈检测、理赔分析、承保处理、风险评估和销售预测，因为它经常用于从海量数据中提取和揭示隐藏的洞察（Turban, 2011）。数据挖掘涉及从数据中发现统计上可靠的、以前未知的且可操作的洞察。数据必须具备可访问性、相关性、充分性和完整性。在理赔分析中使用集成算法有助于保险公司提升对理赔备案的理解并识别欺诈实例（Prasasti et al., 2020）。</p><p>集成学习方法被广泛认可为一个突出的研究领域，它适应性强并适用于各种机器学习（ML）应用，如分类、回归，甚至无监督学习（Alsuwaillem et al., 2023）。它们的出色性能源于其提升模型泛化能力、减轻过拟合以及在单个模型可能挣扎的情况下改善性能的能力。集成学习方法可以大大提升预测准确性，但也带来了计算复杂性和模型可解释性的挑战（Khalil et al., 2022b; Piovezan et al., 2023）。集成学习是一种基本技术，旨在改善ML模型的性能。它为解决各种领域的复杂问题提供了一种强大且灵活的方法（Das et al., 2021）。</p><p>预测系统通常由不同的数据挖掘方法支持，如数据重采样、特征离散化和特征选择，在识别风险方面发挥关键作用。通过选择相关特征子集，计算成本降低，模型的效率和可理解性大大提升（Gupta et al., 2022）。此外，数据集不平衡（即正负实例分布不均）可能影响预测算法的精度。在这种情况下，通过数据重采样可以提升模型的整体性能（Baesens et al., 2021; Subudhi &amp; Panigrahi, 2018）。回顾保险欺诈文献显示，缺乏将上述数据挖掘策略与AI分类器（如集成和经典ML方法）集成到一个统一处理程序中来开发保险欺诈分类模型的研究。</p><p>本研究旨在通过创建多样化的检测场景来开发一个鲁棒的预测系统，使用数据重采样、特征离散化、特征选择以及不同分类器的组合。该预测系统的重点是识别保险欺诈，使用从保险公司获得的真实数据集进行验证。本研究通过利用两个不同的数据集（保险欺诈数据集和保险理赔数据集）评估预测准确性。根据对文献的批判性回顾，保险领域存在一个当前研究尚未填补的重大差距。</p><p>因此，本研究的主要贡献如下：首先，本研究介绍了主要进展，其特征是通过引入不同的场景，使用不同的分类器，特别是采用两种不同的特征选择方法、特征离散化和三种不同的数据重采样策略。总体目标是开发一个精确且鲁棒的保险欺诈检测预测系统。其次，调查了在二元分类结果上应用离散化后跟特征选择的影响。第三，评估重采样技术对二元分类结果的影响。第四，在两个不同的数据集上实际实施提出的预测系统以确认其有效性，并公开提供代码。最后，使用四个公认的指标（准确性、敏感性（召回率）、F1分数、精度和AUC）对各种检测场景的性能差异进行彻底评估和比较。除了这些评估指标，还使用统计分析来确定所提出数据集的最有利场景。</p><p>本文的其余部分概述如下：第2节简要介绍先前研究。第3节详细说明研究方法，包括研究设计、数据收集方法、描述本研究中用于检测保险欺诈的具体技术和方法，以及评估指标。第4节呈现和分析发现。最后，在第5节中呈现结论。</p><h2 id="2-文献综述"><a href="#2-文献综述" class="headerlink" title="2 文献综述"></a>2 文献综述</h2><p>长期以来，保险公司发现有充分理由在其运营中采用主动和灵活的方法，以实现其长期和短期目标，并有效应对风险预测、欺诈检测、理赔分析和定价策略等复杂挑战，以维持金融稳定并在不断变化的环境中取得成功（Barry &amp; Charpentier, 2020）。Turban（2011）将数据挖掘定义为通过应用数学、统计、人工智能和ML技术从大型数据库中提取有价值洞察的方法。</p><p>保险欺诈仍然是一个普遍挑战，每年导致行业损失数十亿美元，需要强大的监管框架、跨市场合作和先进分析工具。学术和行业研究强调国家保险专员协会（NAIC）作为标准化反欺诈措施的关键机构，通过模型法，如其特别调查单位（SIU）指南，该指南要求保险公司遵守和数据共享协议（NAIC, 2022; Saylor, 2023）。例如，Hoyt et al.（2006）分析了汽车保险欺诈数据，发现反欺诈法律的结果喜忧参半。强制SIU和重罪分类减少了欺诈，但强制向执法部门报告增加了欺诈，表明在取代私人努力时效率低下。每年850亿美元的欺诈问题也受到立法以外的市场特定因素的显著影响。这些发现突出了针对性反欺诈措施的必要性。</p><p>此外，Saylor（2023）的研讨会论文考察了机会主义汽车保险欺诈，强调其普遍性、经济影响和检测挑战。该研究强调机会主义欺诈占保险欺诈的很大一部分，但往往被忽视，转而关注高调的“硬”欺诈案例。使用中和理论，Saylor分析了犯罪者如何证明欺诈（例如，否认责任或受害者身份），并提出威慑策略，包括公众意识运动、增强理赔处理程序和机构间合作。主要建议重点激活内部道德控制并改善行业工具，如ISO数据库。（Aivaz et al., 2024）通过文献计量分析经济欺诈研究趋势，确定美国和中国为主要贡献者。主要发现突出对数字检测工具（AI、区块链）和社会经济影响的日益关注。该研究揭示了出版物增加但引用影响下降，表明需要更具影响力的研究。</p><p>保险公司和数据挖掘研究人员在保险数据中遇到各种障碍，包括数据可用性、数据质量和缺失值问题。此外，他们还面临不平衡数据集和模型选择的可解释性问题（Cappiello, 2020）。因此，在保险领域进行了众多研究，使用各种方法。例如，Bhowmik（2011）提出了一种使用基于决策树（DT）和朴素贝叶斯分类的算法检测汽车保险欺诈的策略，并使用规则基于分类、决策树可视化和贝叶斯朴素可视化等程序分析预测。结果显示这些方法在识别汽车保险欺诈方面的表现良好。Dhieb et al.（2019, 2020）利用ML技术自主检测和分类机动车保险欺诈理赔，并包括识别可疑理赔的警报机制。</p><p>进一步，Kowshalya和Nandhini（2018）使用数据挖掘技术预测保险费和欺诈理赔，减少了理赔分析的时间。他们基于汽车保险欺诈研究生成合成数据集，以开发用于检测虚假理赔的分类算法。Itri et al.（2019）开发了一种新方法，通过测试（10）ML算法来改善欺诈预测准确性，以确定哪些最有效和可靠。使用汽车保险理赔数据，该研究显示随机森林在预测欺诈方面优于所有其他算法。Subudhi和Panigrahi（2020）引入了一种基于GA的模糊C均值（FCM）聚类与监督分类器相结合的方法，用于检测汽车保险理赔欺诈，在真实数据上证明了其效率。Nordin et al.（2024）比较了传统和ML模型用于预测汽车保险欺诈，发现树增强朴素贝叶斯（TAN）模型在准确性和敏感性方面优于其他。该研究强调了ML在检测欺诈方面的有效性，并建议改善数据准备和模型设置以获得更好结果。</p><p>另一方面，研究人员努力通过解决数据质量问题（如不平衡数据和缺失值）以及优化机器学习模型参数来改善不同领域的欺诈预测，以获得更好的性能。各种方法已被建议并用于文献中，以解决不平衡和缺失值分类挑战，当涉及到为保险欺诈检测建模获取高质量数据时。例如，Sundarkumar et al.（2015）采用随机欠采样重采样方法结合概率神经网络（PNN）、DT、SVM、逻辑回归（LR）和数据处理组方法（GMDH）。研究发现DT模型在欺诈检测中具有最高效能。同样，Hassan和Abraham（2016b）采用随机欠采样结合DT、NN和SVM模型。他们的发现表明DT模型表现出最高性能。Wang和Chen（2020）提出了一种三向集成方法，用于处理缺失数据，通过分组没有缺失值的对象并用每个组的平均属性填充空白。尽管从UCI ML存储库的实验证明了其有效性，但该方法缺乏处理缺失值的全面策略。</p><p>Hanafy和Ming（2021）研究了九种SMOTE家族方法，以解决预测保险费违约的不平衡数据。他们使用13个机器学习分类器评估这些技术，结果显示在应用SMOTE技术后分类器性能显著改善。Jovanovic et al.（2022）使用ML和组搜索萤火虫算法改进信用卡欺诈检测。使用欧洲信用卡交易的真实、不平衡数据集来调整极端梯度提升的SVM。在合成少数过采样扩展数据集后，该研究发现调整模型在准确性、召回率、精度和曲线下面积方面优于其他领先方法。Tayebi和Kafhali（2024）使用元启发式算法如遗传算法、粒子群优化和人工蜂群来优化信用卡欺诈检测中ML模型的超参数。这些方法在准确性、召回率和计算经济方面优于网格搜索，特别是对于不平衡数据集。</p><p>基于对可用研究的全面分析，本研究旨在填补现有文献中的空白，通过进行彻底分析一个统一的框架来处理数据集并开发用于检测保险欺诈的分类模型。鉴于这一研究空白，不清楚在数据集处理期间集成推荐的方法和技术是否能改善分类模型。本研究还优先考虑积极结果，并开发方法来解释特定预测以改善模型可解释性。</p><h2 id="3-提出的计算方法"><a href="#3-提出的计算方法" class="headerlink" title="3 提出的计算方法"></a>3 提出的计算方法</h2><p>在本节中，我们呈现了构建鲁棒保险欺诈检测系统的计算方法。我们的方法旨在通过集成不同的AI分类器与数据挖掘技术（如特征离散化、特征选择和重采样）来呈现不同的欺诈检测系统，以解决特征重要性和不平衡数据等挑战。通过概述要采用的具体步骤和技术，我们旨在实现鲁棒且可重复的结果，从而贡献于保险领域的进步。</p><p>提出的方法结构化以确保计算任务的系统性和高效处理。我们从预处理阶段开始，如数据收集或预处理。随后，我们详细说明连续变量的离散化、SelectKbest（Kbest）和递归特征消除（RFE）技术用于特征选择、三种不同的数据重采样策略以及不同的分类器。然后，我们使用四个公认的评估指标（准确性、敏感性（召回率）、F1分数、精度和AUC）评估提出的系统的性能。这些阶段中的每一个都被视为对提出的系统整体有效性的必需。</p><p>此外，我们强调了我们方法的适应性，它允许可扩展性和适用于一系列数据集或保险领域内的场景。这种灵活性使我们能够有效地应对数据特征和研究要求的变化，从而提升我们发现的泛化能力。系统涉及的程序的视觉表示描绘在图1中，它作为本研究上下文中保险欺诈检测的框架。</p><h3 id="3-1-数据收集"><a href="#3-1-数据收集" class="headerlink" title="3.1 数据收集"></a>3.1 数据收集</h3><p>在本分析中，使用两个不同的数据集来评估提出的系统的准确性。本研究的数据集从Kaggle.com获得。数据集中的目标变量不同。在第一个数据集中，我们实施提出的系统来检测汽车保险部门的保险欺诈，因此目标特征是“欺诈报告”列。在第二个数据集中，我们为汽车保险部门的理赔分析实施提出的系统，因此目标特征是“理赔标志”列，该列指示是否提交了理赔。图2显示两个数据集中的目标变量是分类的。因此，使用分类系统进行分析。图3显示数据集中的目标变量分布。在欺诈数据集中，非欺诈和欺诈理赔的比例为94–6%。</p><p>数据集在欺诈汽车保险理赔上有15,419个实例，其中923个被分类为欺诈，显示数据分布中显著的类不平衡。数据集中的每个理赔由32个不同的属性定义，如表1中所列。保险理赔数据集包含10,302个汽车保险理赔，其中2,746个被分类为理赔提交，突出了显著的类不平衡。数据集中的每个理赔由26个唯一属性定义，如表2中所概述。</p><p>本研究使用的两个数据集在大小、标签分布和缺失数据程度方面存在显著差异。第一个数据集专注于汽车保险部门中的欺诈理赔，更大，有15,419条记录，并表现出高度不平衡，其中只有6%的理赔被标记为欺诈，剩余94%为非欺诈。相比之下，第二个数据集分析是否提交了理赔，包含10,302条记录，不平衡程度较轻，有26.7%的理赔标记为提交，73.3%为非提交。此外，缺失数据在两个数据集之间显著不同。在第一个数据集中，单个特征中缺失值的最高百分比达到45.7%（补充数量），最低为0.35%（事故政策天数）。相反，第二个数据集的缺失数据范围较低，职业特征的最大值为6.45%，年龄特征的最小值为0.07%。这些差异突出了需要定制数据处理方法来解决每个数据集的独特类分布和数据完整性问题。</p><h3 id="3-2-数据预处理"><a href="#3-2-数据预处理" class="headerlink" title="3.2 数据预处理"></a>3.2 数据预处理</h3><p>分类方法应用的最重要步骤之一是数据预处理，这也在图1的初始阶段中说明。因为数据可能包含多个错误，所以必须在任何未来操作之前处理数据。因此，此阶段涉及基本的数据处理任务，如填充缺失值、数据评分、特征编码、数据离散化和将数据分为训练和测试数据集。</p><h4 id="3-2-1-数据清洗和编码"><a href="#3-2-1-数据清洗和编码" class="headerlink" title="3.2.1 数据清洗和编码"></a>3.2.1 数据清洗和编码</h4><p>为了提升数据集的效率和质量，使用数据清洗来查找和修复错误、损坏和缺失信息。这使得分析和分类模型更有效（Cerda &amp; Varoquaux, 2022; Li et al., 2021）。首先，根据数据集，特征缺失值要么完全删除，要么更改其缺失值。在我们的研究中，我们从第一个数据集删除了两个特征（X21, X27），因为它们具有高百分比的缺失值，如表3所示。对于两个数据集中的剩余特征，对于二元和类别变量中的缺失值，使用列值的模式填充。相反，对于所有连续变量中的缺失值，使用列值的均值填充。</p><p>对于目标变量，为了找到与它高度多重共线性的特征，我们检查了相关矩阵和方差膨胀因子（VIF）分析。此策略减少了多重共线性。在数据集（2）中，由于X23特征与目标变量的相关性显著，此策略很重要，以改善模型的预测准确性并保证剩余变量提供清晰且可解释的洞察与目标变量的关系。</p><p>数据编码是预处理的重要部分，它是将原始数据转换为可以被算法和统计模型使用的数值表示。例如，我们将类别特征转换为数值格式，如将被保险人的性别分配为“1”表示“男性”和“0”表示“女性”。</p><h4 id="3-2-2-离散化方法"><a href="#3-2-2-离散化方法" class="headerlink" title="3.2.2 离散化方法"></a>3.2.2 离散化方法</h4><p>离散化算法是机器学习、数据挖掘和统计分析中数据预处理的基本组成部分。将连续变量转换为离散变量简化了分析和算法应用。离散化有几个原因。首先，许多机器学习方法需要离散输入，因此必须转换连续数据。通过分组相似值，离散化简化了解释。连续变量的不同离散化方法有优缺点。使用无监督和监督方法。无监督方法如等宽和频率分箱按分布分离数据。然而，监督方法如基于决策树的离散化和基于熵的分箱使用类标签或目标变量来指导离散化。</p><p>在本研究中，我们采用了KBinsDiscretizer（KBD）方法。KBD方法使用分箱技术将连续变量转换为离散箱，从而使需要分类输入的模型中使用连续数据。此方法可以改善清晰度、减少计算复杂性，并潜在地提升机器学习算法的效率，特别是那些受输入数据特性影响的算法。</p><h3 id="3-3-特征选择技术"><a href="#3-3-特征选择技术" class="headerlink" title="3.3 特征选择技术"></a>3.3 特征选择技术</h3><p>特征选择（FS），也称为属性选择或变量子集选择，是一个广泛用于减少特征空间维度的技术，同时保持给定方法的性能。特征选择呈现了一个复杂挑战，因为需要互补特征来处理交互和冗余。FS的目标是识别和消除与学习过程无关或冗余的特征。FS的主要目标是通过提升准确性和方法的效率和可理解性来改善学习性能（A. Singh &amp; Jain, 2019）。因此，需要更有效的全局搜索技术来有效解决特征选择。在本研究中，我们采用了两种不同的特征选择技术。</p><h4 id="3-3-1-Select-K-Best"><a href="#3-3-1-Select-K-Best" class="headerlink" title="3.3.1 Select K Best"></a>3.3.1 Select K Best</h4><p>SelectKBest与ANOVA F值是一种单变量选择方法。在此方法中，通过消除无关特征来对特征进行排名。排名由每个特征与目标变量之间的关联计算的统计分数确定（Visalakshi &amp; Radha, 2014）。它通过计算每个特征与目标变量之间的ANOVA F值来选择K个最佳特征。具有更高F值的特征被认为与目标变量更相关。此方法在处理许多特征时特别有用，并且计算效率高。然而，它不考虑特征之间的交互，并且K的选择需要仔细确定以平衡模型性能和维度减少。K是用于特征选择的顶级特征数量（Srivatsan &amp; Santhanam, 2021）。</p><h4 id="3-3-2-递归特征消除（RFE）与随机森林分类器"><a href="#3-3-2-递归特征消除（RFE）与随机森林分类器" class="headerlink" title="3.3.2 递归特征消除（RFE）与随机森林分类器"></a>3.3.2 递归特征消除（RFE）与随机森林分类器</h4><p>递归特征消除（RFE）是一种通过迭代从数据集中移除特征的选择特征的方法。RFE在此场景中与随机森林分类器作为估计器一起使用。该技术最初使用所有特征训练模型，然后评估每个特征的重要性（Lakshmanarao et al., 2022; Visalakshi &amp; Radha, 2014）。算法消除最不重要的特征并迭代此过程，直到达到所需特征数量。利用随机森林分类器与递归特征消除（RFE）对于通过随机森林模型生成的重要性分数来确定最重要特征是有效的。所用的分类器可以影响所选特征，并且要选择的特征数量必须仔细调整以提升模型性能（Visalakshi &amp; Radha, 2014）。</p><h3 id="3-4-重采样方法"><a href="#3-4-重采样方法" class="headerlink" title="3.4 重采样方法"></a>3.4 重采样方法</h3><p>不平衡数据问题在许多数据集中普遍存在，导致偏差分类器模型无法对少数类做出准确预测（Kotsiantis et al., 2006）。因此，解决不平衡数据问题是必不可少的。已开发了各种方法来解决此问题，其中一种最成功的涉及使用基于采样的技术，如随机过采样和随机欠采样（Basit et al., 2022; Zhang et al., 2024）。表4显示了每个重采样方法的基本属性。</p><h3 id="3-5-分类器模型"><a href="#3-5-分类器模型" class="headerlink" title="3.5 分类器模型"></a>3.5 分类器模型</h3><p>在提出的工作中，我们采用了不同的经典ML和集成学习分类器模型，即决策树（DT）、随机森林（RF）、AdaBoost、梯度提升（GB）和Bagging。认识到任何ML模型的性能取决于分配给其参数的具体值。</p><h4 id="3-5-1-决策树（DT）"><a href="#3-5-1-决策树（DT）" class="headerlink" title="3.5.1 决策树（DT）"></a>3.5.1 决策树（DT）</h4><p>DT是一种灵活且可解释的分类技术，它通过递归划分数据，选择最佳分离特征到同质子集，最大化类标签纯度，直到达到停止标准，形成用于新预测的模型（Bansal et al., 2022）。它的优势在于捕捉复杂、非线性关系并处理各种数据类型，使其在许多分析场景中有用。然而，决策树容易过拟合，因为它们可以记忆训练数据，这会导致对新数据的泛化能力差，而不进行正则化。它们也对训练集的细微变化敏感，这会影响它们的预测，因此仔细的参数调整和集成方法对于最佳性能至关重要（Bansal et al., 2022）。</p><h4 id="3-5-2-随机森林（RF）"><a href="#3-5-2-随机森林（RF）" class="headerlink" title="3.5.2 随机森林（RF）"></a>3.5.2 随机森林（RF）</h4><p>RF是一种集成学习技术，通过训练多个决策树并结合它们的预测来提升机器学习任务中的准确性和泛化能力。对于回归任务，它取单个树预测的平均值，而对于分类任务，它使用类预测的模式（Roy &amp; George, 2017）。RF高度准确且鲁棒，通常避免过拟合，即使在缺失数据的情况下也能表现良好，这使其在各种应用中可靠。然而，RF需要大量处理能力用于大型数据集，并且缺乏单个决策树的可解释性，尽管其在多样任务中的高性能使其成为机器学习中的宝贵工具（Roy &amp; George, 2017）。</p><h4 id="3-5-3-自适应提升（AdaBoost）"><a href="#3-5-3-自适应提升（AdaBoost）" class="headerlink" title="3.5.3 自适应提升（AdaBoost）"></a>3.5.3 自适应提升（AdaBoost）</h4><p>AdaBoost通过结合多个弱学习器并在每次迭代中调整误分类实例的权重来构建强分类器，这更关注困难案例，并允许后续学习器纠正先前错误，从而产生准确模型（Hassan &amp; Abraham, 2016a）。AdaBoost的优势在于其通过集成基分类器来改善弱学习器的能力，使其灵活且适应各种数据类型和问题领域。然而，AdaBoost的性能在噪声数据下可能受损，因为如果基分类器过于复杂或不稳定，它可能过拟合，这会影响其泛化。因此，其有效性取决于数据质量和分类器的简单性（Ben Jabeur et al., 2023）。</p><h4 id="3-5-4-梯度提升（GB）"><a href="#3-5-4-梯度提升（GB）" class="headerlink" title="3.5.4 梯度提升（GB）"></a>3.5.4 梯度提升（GB）</h4><p>GB是一种集成学习技术，通过顺序添加弱学习器（通常决策树）来构建强大预测模型，以减少先前模型的错误。此过程通过梯度下降优化损失函数，并创建高度准确的模型（Dhieb et al., 2019）。GB模型以其强性能、对异常值的鲁棒性和处理数值和分类数据的能力而闻名，这使它们在各种分类和回归任务中高度通用。然而，尽管有这些优势，GB可能过拟合，特别是如果正则化不足或学习率太高，其迭代且复杂的模型构建过程在大型数据集上可能计算密集（Liu et al., 2019）。</p><h4 id="3-5-5-Bagging"><a href="#3-5-5-Bagging" class="headerlink" title="3.5.5 Bagging"></a>3.5.5 Bagging</h4><p>Bagging是一种集成学习方法，通过在训练数据的随机子集上独立训练多个模型来减少方差，从而改善模型性能。通过捕捉模型间的数据变异性并通过平均（用于回归）或投票（用于分类）结合它们的预测，Bagging提升了准确性和泛化，并有效最小化过拟合并增加模型稳定性（Park &amp; Kwon, 2024）。其优势在于利用多样模型预测，这使其特别适用于复杂模型和大型数据集，通过优化性能和可扩展性。然而，Bagging可能无法改善低方差的稳定模型的结果，并且如果基模型或数据集本身有偏差，可能引入偏差。因此，评估模型稳定性和数据集特征对于使用Bagging实现最佳结果至关重要。</p><h3 id="3-6-分类准确性评估指标"><a href="#3-6-分类准确性评估指标" class="headerlink" title="3.6 分类准确性评估指标"></a>3.6 分类准确性评估指标</h3><p>评估指标是查找和比较最佳模型的关键组成部分，它评估分类器的效率。一个受欢迎的指标是准确性，它显示正确预测的百分比。更高的准确值表明分类器整体表现更好。虽然准确性很重要，但它可能不足以解决分类困难，特别是处理不平衡数据时（Hossin &amp; Sulaiman, 2015; Khalil et al., 2024a）。针对这一挑战，使用各种分类评估标准来评估分类器的性能。</p><script type="math/tex; mode=display">\text{Accuracy (AC)} = \frac{TP + TN}{TP + FP + TN + FN}, \quad (1)</script><script type="math/tex; mode=display">\text{Recall (RC)} = \frac{TP}{TP + FN}, \quad (2)</script><script type="math/tex; mode=display">\text{Precision (PR)} = \frac{TP}{TP + FP}, \quad (3)</script><script type="math/tex; mode=display">F1 - \text{Score F} = \frac{2 \times TP}{2 \times TP + FP + FN}, \quad (4)</script><p>其中TP表示真阳性，TN表示真阴性，FP是假阳性，FN是假阴性。</p><h2 id="4-预测分析和模型可解释性"><a href="#4-预测分析和模型可解释性" class="headerlink" title="4 预测分析和模型可解释性"></a>4 预测分析和模型可解释性</h2><p>在本节中，我们呈现了为解决前述部分概述的研究问题而进行的实验和结果，即在数据集处理期间集成推荐的方法和技术是否能改善分类模型。我们的研究旨在构建一个鲁棒的分类模型来检测保险欺诈。为实现这一目标，我们通过创建多样化的检测场景设计并实施了一系列实验，使用数据重采样、特征离散化、特征选择以及不同分类器的组合。</p><h3 id="4-1-实验设置"><a href="#4-1-实验设置" class="headerlink" title="4.1 实验设置"></a>4.1 实验设置</h3><p>实验在一台配备2.60 GHz Intel(R) Core (TM) i7-12700F CPU和32 GB RAM的机器上运行。我们使用64位Windows 11。Python用于实现框架。Pandas数据帧加载数据集。Scikit Learn（Pedregosa et al., 2011）库实现ML和集成模型。为确保实验模型、参数配置和报告结果的可再现性，我们在作者的GitHub网站³上公开提供了所提出工作的源代码、可视化和数据。</p><h3 id="4-2-实验设计"><a href="#4-2-实验设计" class="headerlink" title="4.2 实验设计"></a>4.2 实验设计</h3><p>在我们的研究中，我们旨在探索在统一框架中结合各种技术如何改善预测模型的构建，导致开发一个可靠的系统，用于准确检测保险欺诈。我们希望通过彻底的研究和实验确定这一集成策略在提升预测模型以及提升保险欺诈检测准确性和可靠性的有效性。</p><p>因此，我们的研究包括六个实验，每个实验都采用特定方法组合的不同场景，如图4所示。我们</p><p>³<a href="https://github.com/AhmedKhalil91/classification-model.git">https://github.com/AhmedKhalil91/classification-model.git</a>.</p><p>在每个实验中分析了各种条件，以理解它们的个别影响。六个实验的基础可以总结如下：</p><p>(a) 在第一个实验中，数据直接使用而不进行离散化、特征选择或不平衡问题处理，直接输入分类模型，然后使用准确性、F1分数和AUC-ROC等指标评估模型的性能。此基线评估作为比较各种预处理技术影响的参考点，在后续实验中。</p><p>(b) 第二个实验考察了在连续特征上应用KBD离散化方法的影响，然后修改的数据直接输入分类模型，然后评估模型的性能，以确定离散化如何影响模型学习，特别是相对于基线更有效地处理连续数据。</p><p>(c) 第三个实验探索了特征选择（Kbest和RFE）技术的使用，以减少特征空间并潜在提升模型性能。在应用特征选择后，数据直接输入分类模型，然后使用标准指标评估模型性能，以了解关注相关特征是否能提升准确性和减少过拟合。</p><p>(d) 第四个实验评估了KBD离散化后跟KBest和RFE特征选择的组合对分类性能的影响。在应用离散化和特征选择后的数据直接输入分类模型，然后评估模型的性能。此实验调查了离散化和特征选择之间的潜在协同作用在提升预测准确性和模型鲁棒性方面的作用。</p><p>(e) 在第五个实验中，分析了重采样（Under, Over和SMOTE）技术对分类器性能的影响，以处理数据集中的类不平衡。每个重采样方法单独应用以平衡训练集，模型使用重采样数据训练，然后重点识别哪个重采样方法最佳提升不平衡类情况下的结果。</p><p>(f) 最终实验涉及全面预处理方法，应用KBD离散化，后跟特征选择和重采样（欠采样、过采样和SMOTE）以解决类不平衡。然后使用处理后的数据训练分类模型，并使用指标评估其性能。此实验旨在展示集成多个预处理技术的累积益处及其对分类性能的整体影响。</p><h3 id="4-3-实验结果和讨论"><a href="#4-3-实验结果和讨论" class="headerlink" title="4.3 实验结果和讨论"></a>4.3 实验结果和讨论</h3><p>在本节中，我们提供对实验结果的全面检查，强调各种数据预处理技术对分类器性能的关键影响。实验遵循系统方法，从数据集预处理开始，将其分成80–20比例的训练和测试集，然后测试分类器在不同预处理场景下的表现。包括准确性、F1分数、召回率、精度和AUC在内的性能指标被记录，并在表5中详细说明。值得注意的是，对于不平衡数据集，AUC和F1分数优先于准确性，因为这些指标更好地解决类分布，并减少当一个类过度表示时的偏差。</p><p><strong>实验1</strong> 在没有数据变换的基线场景中，每个分类器被测试原始预测能力。结果显示决策树（DT）分类器以68.15%的AUC领先，其次是RF模型以52.14%的AUC分数在第一个数据集，而梯度提升（GB）在第二个数据集表现更好，实现了68.08%的AUC。这些分数反映了每个模型的基本效能，而没有来自数据变换的增强。</p><p><strong>实验2</strong> 该研究接下来调查了数据离散化对分类性能的影响，通过应用KBD技术于连续特征。KBD+DT的组合在第一个数据集上展示了显著改善，以69.89%的AUC，而KBD+GB在第二个数据集上以68.43%的AUC领先。这一AUC的增加表明数据离散化可以锐化分类器处理类区分的能力。</p><p><strong>实验3</strong> 为评估特征选择的影响，我们应用了两个方法，KBest和RFE。此实验使用减少特征集评估分类器分为两个场景。在第一个数据集，组合KBest+DT达到了最高的75.35%的AUC，超过基线，而KBest+GB在第二个数据集上以67.57%的AUC表现最佳。这些结果突出关注相关特征可以提升分类准确性通过减少噪声并聚焦于最信息丰富的属性。</p><p><strong>实验4</strong> 此实验集成了离散化和特征选择，在两个数据集上展示了增强的结果。具体来说，（KBD+KBest+DT）组合在第一个数据集达到了最高的77.34%的AUC，而（KBD+KBest+GB）在第二个数据集得分为67.89%。这些发现表明离散化和特征选择的组合通过同时减少维度并强调基本特征来加强模型。</p><p><strong>实验5</strong> 我们考察了三种重采样技术（欠采样、过采样和SMOTE）对分类器性能的影响在此实验中分为三个场景，旨在解决类不平衡。结果显示（Oversampler+RF）组合在分类器中展示了最高性能，以95.5%的AUC在第一个数据集和88.17%在第二个数据集。这些结果确认重采样方法，特别是过采样，可以通过平衡类分布并使模型从少数类学习更有效地显著改善模型性能。</p><p><strong>实验6</strong> 此最终实验评估了离散化、特征选择和重采样的组合影响于分类器效能。六个场景被测试，揭示（KBD+RFE+Over +RF）组合实现了最高的99.26%的AUC分数在第一个数据集和89.29%在第二个数据集。这一结果标志着对其他场景的实质改善，表明集成所有三种预处理技术是最大化分类器准确性和可靠性在类区分中的强大策略。</p><p>为了提供清晰和简洁的概述，表6和7总结了这一比较，聚焦于AUC分数和F1分数作为选择每个实验中顶级表现场景的主要指标。此指标量化了模型区分类的能力，使能够有效识别展示在类不平衡情况下优越区分力的模型。</p><p>结果显示每个预处理步骤如何影响模型有效分类数据的能力，特定技术导致两个数据集性能指标的显著改善。重采样技术，特别是过采样和SMOTE倾向于显示模型性能的显著增加，并突出它们在解决类不平衡方面的有效性。</p><p>表5的详细分析揭示那些特定预处理技术组合一致提升了实验中的模型准确性。例如，决策树在与KBD离散化、RFE特征选择和SMOTE重采样配对时展示了最佳性能。该协同作用为每个数据集提供了优越的准确性和泛化。</p><p>模式在模型中保持。对于随机森林，结合KBD离散化、RFE特征选择和过采样一致产生了数据集上的最高分数，肯定这些预处理策略提升性能，特别是对于树基模型。对于像AdaBoost和梯度提升这样的集成方法，最好结果也通过配对KBD离散化、RFE或KBest特征选择和SMOTE重采样获得，表明这些技术为集成模型提供相当益处，在保持准确性和防止过拟合方面。</p><h3 id="4-4-统计测试分析"><a href="#4-4-统计测试分析" class="headerlink" title="4.4 统计测试分析"></a>4.4 统计测试分析</h3><p>不同场景源于各种重采样和特征选择程序，这些变异直接影响分类器的性能。识别最佳策略变得挑战，因为不同数据集拥有独特特征，并且变化的数据预处理选项可以影响分类器准确性和鲁棒性。由于这一复杂性，确定评估和比较分类器在不同数据预处理情况下的最佳方法组合需要系统方法。</p><p>统计显著性测试包括ANOVA和Friedman测试有助于客观和仔细评估这些差异。如表8所示，我们使用了两个测试来考察分类器在给定不同重采样和特征选择组合时的表现。我们特别感兴趣于每个方法在每个数据集内的AUC值。我们能够拒绝零假设，因为p值小于0.05阈值，这表明有统计上显著的差异。结果确认替代假设，即不同数据集内的场景表现显著不同。</p><p>确认不同方法在每个数据集内表现显著不同使用ANOVA和Friedman测试后，进一步分析需要识别每个数据集的最佳场景。表9和10提供各种预测模型和预处理策略的全面评估，系统分析多个实验场景以识别基于中位性能值、排名总和和Friedman测试排名的最有效组合。中位指标反映模型性能的中心趋势，而排名总和和排名列提供每个场景相对性能的洞察基于Friedman测试。</p><p>如表9所示，对于数据集（1）的顶级表现场景是KBD + RFE + Over + ML，它实现了最高排名（Rank 1）以0.9584的中位AUC和75的排名总和。这密切跟随KBD + RFE + SMOTE + ML，它获得第二排名（Rank 2）以0.9456的中位AUC，和Under + ML，它实现第三排名（Rank 3）以0.8936的中位AUC。显着地，纳入递归特征消除（RFE）和过采样技术的场景一致优于其他方法，表明特征选择和数据平衡的组合显著改善模型性能。相比之下，简单方法如Raw data + ML和KBD + ML排名相当低（Ranks 13和14），强调高级预处理技术的作用。</p><p>表10中呈现的结果对于数据集（2）揭示KBD + RFE + Over + ML场景提供了最高性能，实现顶级排名（Rank 1）以0.8510的中位值和69的排名总和。这密切跟随KBD + Kbest + SMOTE + ML，它获得第二排名（Rank 2）以0.8299的AUC中位，和KBD + RFE + ML，它实现第三排名（Rank 3）以0.8530的中位AUC。相比之下，简单方法如Raw data + ML（Rank 12，中位=0.6287）和SMOTE + ML（Rank 15，中位=0.6172）表现差，强调高级预处理策略的作用。</p><p>总之，此分析证明结合各种预处理技术可以显著改善分类模型性能。最佳组合，特别是对于区分任务如保险欺诈检测，发现于实验6中（KBD + RFE + Over + RF）场景，它展示了两个数据集上最高的AUC分数。这一组合有效平衡精度和召回，突出使用集成预处理方法来优化分类器准确性和鲁棒性的价值。这些发现提供有价值的洞察于数据预处理在优化分类器性能方面的关键作用，并可以指导未来研究在特定模型家族中选择适当的预处理策略。</p><h3 id="4-5-使用SHAP分析解释预测模型"><a href="#4-5-使用SHAP分析解释预测模型" class="headerlink" title="4.5 使用SHAP分析解释预测模型"></a>4.5 使用SHAP分析解释预测模型</h3><p>预测模型结果的解释是理解其行为并确保其在真实世界应用中可靠性的关键步骤（de Souza et al., 2024）。作为最先进的解释性框架，SHAP（SHapley Additive exPlanations）分析测量每个特征对模型预测的贡献，这有助于我们理解变量基础上的更高性能。通过检查SHAP值，我们可以识别影响模型发现的关键特征，验证所选特征的重要性，并从数据集基础模式中衍生实际洞察（Lundberg &amp; Lee, 2017）。这一可解释性步骤不仅提升了对模型的信任，还为精炼预处理策略和改善未来预测性能提供了宝贵指导。正如表6对于数据集（1）所示，通过全面评估识别的最佳表现场景是KBD + RFE + Over + RF。</p><p>结果通过SHAP值说明在图7中，它确定特征对模型最终结果的影响。SHAP值范围大约-0.4到0.4，表明每个特征强度和方向的影响。正值（向右）提升模型输出，而负值（向左）减少它。这澄清了各种特征的重要性及其对结果的影响。图7说明了特征的垂直排名，最重要的位于顶部，最不重要的位于底部。主要特征如X31、X13和X16具有最大的SHAP值，表明它们对模型预测的重大影响。</p><p>根据结果，变量X31（表示保险覆盖类型）、X13（显示事故责任人）和X16（指示汽车定价类别）具有最显著影响，SHAP值范围从0.2到0.4。这些特征很可能作为模型性能的主要驱动因素，并与最佳表现场景（KBD+RFE+Over+RF）一致，该场景结合了特征选择和领域特定知识。另一方面，像X12、X22和X7这样的特征具有较低的SHAP值，做出小贡献，表明它们要么不必要，要么相关性小。</p><h3 id="4-6-研究局限性"><a href="#4-6-研究局限性" class="headerlink" title="4.6 研究局限性"></a>4.6 研究局限性</h3><p>虽然本研究通过统计和机器学习方法的集成开发了用于保险欺诈检测的鲁棒预测系统，但应承认几个重要局限性。最值得注意的是，我们当前的分析受限于公开可用数据集缺乏详细经济变量，这排除了全面经济影响评估，如成本效益矩阵、ROI分析或保险特定现象如道德风险和逆向选择的量化建模。这些分析需要访问专有金融指标（例如，理赔特定成本结构、保单持有人保费历史和损失比率），这超出了我们数据的范围。我们因此优先考虑核心检测算法的开发和验证，在可用数据的约束内。</p><p>然而，我们认识到这些经济维度对于展示真实世界实施价值至关重要，并提出未来研究应：（1）建立行业伙伴关系以访问敏感金融数据进行全面经济建模；（2）开发集成框架，将欺诈预测与成本相结合；（3）调查保险欺诈的行为经济学方面，通过更丰富的保单持有人数据集。这些扩展将显著提升欺诈检测系统的实际效用，同时解决本研究已识别的技术预测能力和商业价值展示之间的重要交叉点。</p><p>我们数据集的横截面性质阻止了全面时序验证，因为我们缺乏理赔时间戳、历史欺诈模式和方案演变的纵向记录。这一局限性限制了我们检查关键动态方面，包括季节性欺诈趋势、欺诈者行为适应模式和时序模型性能退化——所有这些对于在生产环境中维持检测准确性至关重要。我们强调，通过行业伙伴关系进行纵向数据收集来解决这些时序维度代表了一个关键的未来研究方向，以桥接实验验证和操作部署之间的差距。</p><p>我们研究的另一个局限性是由于隐私约束缺乏敏感人口统计数据（例如，种族、性别），这阻止了使用像人口统计平价这样的指标进行公平性评估。虽然这保护了理赔人隐私，但它限制了我们评估潜在偏差的能力——鉴于保险部门的脆弱性对歧视性结果，这是一个关键担忧。未来具有适当数据的工作应严格审计人口统计组的预测并实施公平意识建模技术，以确保公平的欺诈检测系统。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h2><p>总之，本研究提供了对保险业欺诈检测的深入检查，通过利用多方面的途径集成多样数据预处理技术和分类算法。该分析调查了各种分类器、特征选择方法、数据离散化技术和重采样策略如何影响欺诈检测模型的性能。实证结果揭示了结合这些方法的显著优势，实验6组合（KBD+RFE+过采样+随机森林）展示了在检测欺诈理赔方面的最高效能，如通过优越指标如AUC和F1分数所证明。这种方法突出了欺诈检测中集成策略的重要性，这表明数据挖掘和机器学习技术的全面应用可以大大提升欺诈检测准确性，并帮助保险公司最小化金融损失。</p><p>这一框架的含义对于行业从业者和政策制定者都是实质性的。通过采用这样的结构化和数据驱动方法，保险公司可以加强其欺诈检测系统，从而加强整体金融诚信和运营韧性。此外，这一框架不仅作为选择最佳预测模型的指南，还作为建立更鲁棒行业欺诈预防实践的基础。</p><p>虽然我们的研究提供了有效的欺诈检测框架，但其横截面设计限制了时序验证，由于缺乏纵向数据（例如，理赔时间戳、欺诈模式演变）和详细经济变量的缺失（例如，成本结构、保单持有人成本历史）限制了成本效益分析、ROI量化以及保险特定现象如道德风险和逆向选择的建模。未来研究应扩展这一工作，通过：（1）纳入时序分析以评估季节趋势、欺诈者适应和模型衰退；（2）开发集成/混合分类器与高级特征离散化和重采样策略以改善鲁棒性；（3）建立行业伙伴关系以实现纵向数据集的真实世界验证；以及（4）未来经济建模需要保险公司合作以访问金融数据（理赔成本、支付历史）进行成本效益分析、ROI量化以及道德风险/逆向选择研究。此外，测试新型特征选择技术和自适应学习方法对于应对演变的欺诈策略至关重要。这些进步将桥接实验验证和操作部署之间的差距，最终提升保险部门的韧性和可持续性。我们的发现为这些努力奠定了基础，为从业者提供可扩展工具，同时为更安全和可信的欺诈检测生态系统铺平道路。</p><p><strong>资助</strong> 开放访问资助由科技与创新资助局（STDF）在埃及知识银行（EKB）的合作下提供。作者声明在准备本手稿期间未收到任何资金、赠款或其他支持。</p><p><strong>数据可用性</strong> 支持本研究发现的数据可在以下链接获得（<a href="https://github.com/AhmedKhalil91/classification-model.git）。">https://github.com/AhmedKhalil91/classification-model.git）。</a></p><p><strong>声明</strong></p><p><strong>利益冲突</strong> 作者声明没有相关的金融或非金融利益披露。</p><p><strong>开放访问</strong> 本文根据Creative Commons Attribution 4.0国际许可授权，该许可允许在任何媒介或格式中使用、共享、改编、分发和复制，只要您给予原作者和来源适当信用，提供Creative Commons许可链接，并指示是否进行了更改。本文中的图像或其他第三方材料包含在文章的Creative Commons许可中，除非在信用线中另有说明。如果材料未包含在文章的Creative Commons许可中，且您的预期用途不符合法定规定或超过允许用途，您将需要直接从版权持有人获得许可。要查看此许可的副本，请访问<a href="http://creativecommons.org/licenses/by/4.0/。">http://creativecommons.org/licenses/by/4.0/。</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Aivaz, K. A., Florea, I. O., &amp; Munteanu, I. (2024). 经济欺诈及其相关风险：一种集成文献计量分析方法. <em>风险</em>, 12(5), 74.<br>Akhtar, P., Ghouri, A. M., Khan, H. U. R., Amin ul Haq, M., Awan, U., Zahoor, N., Khan, Z., &amp; Ashraf, A. (2023). 使用人工智能和机器学习检测假新闻和虚假信息以避免供应链中断. <em>运筹学年鉴</em>, 327(2), 633–657. <a href="https://doi.org/10.1007/s10479-022-05015-5">https://doi.org/10.1007/s10479-022-05015-5</a><br>Alsuwaillem, A. A. S., Salem, E., &amp; Saudagar, A. K. J. (2023). 不同机器学习算法在检测金融欺诈方面的性能. <em>计算经济学</em>, 62(4), 1631–1667. <a href="https://doi.org/10.1007/s10614-022-10314-x">https://doi.org/10.1007/s10614-022-10314-x</a><br>Amirruddin, A. D., Muharam, F. M., Ismail, M. H., Tan, N. P., &amp; Ismail, M. F. (2022). 合成少数过采样技术（SMOTE）和逻辑模型树（LMT）-自适应提升算法用于分类油棕（<em>Elaeis guineensis</em>）营养和叶绿素充足水平的失衡数据集. <em>农业计算机与电子</em>, 193, 106646. <a href="https://doi.org/10.1016/j.compag.2021.106646">https://doi.org/10.1016/j.compag.2021.106646</a><br>Baesens, B., Höppner, S., Ortner, I., &amp; Verdonck, T. (2021). RobROSE：处理欺诈检测中不平衡数据的鲁棒方法. <em>统计方法与应用</em>, 30(3), 841–861. <a href="https://doi.org/10.1007/s10260-021-00573-7">https://doi.org/10.1007/s10260-021-00573-7</a><br>Bansal, M., Goyal, A., &amp; Choudhary, A. (2022). K-最近邻、遗传、支持向量机、决策树和长短期记忆算法在机器学习中的比较分析. <em>决策分析杂志</em>, 3, 100071.<br>Barry, L., &amp; Charpentier, A. (2020). 个性化作为承诺：大数据能否改变保险实践？ <em>大数据与社会</em>, 7(1), 文章 2053951720935143. <a href="https://doi.org/10.1177/2053951720935143">https://doi.org/10.1177/2053951720935143</a><br>Basit, M. S., Khan, A., Farooq, O., Khan, Y. U., &amp; Shameem, M. (2022). 处理不平衡医疗数据集的因果：大数据中的基于集成和划分的特征选择. <em>2022 第5届多媒体、信号处理和通信技术国际会议 (IMPACT)</em>, 1–7. <a href="https://doi.org/10.1109/IMPACT55510.2022.10029111">https://doi.org/10.1109/IMPACT55510.2022.10029111</a><br>Ben Jabeur, S., Stef, N., &amp; Carmona, P. (2023). 使用XGBoost算法和变量重要性特征工程预测破产. <em>计算经济学</em>, 61(2), 715–741. <a href="https://doi.org/10.1007/s10614-021-10227-1">https://doi.org/10.1007/s10614-021-10227-1</a><br>Bhowmik, R. (2011). 使用数据挖掘技术检测汽车保险欺诈. <em>计算与信息科学新兴趋势杂志</em>, 2(4), 156–162.<br>Cappiello, A. (2020). 保险企业的风险与控制. 在 A. Cappiello (编), <em>欧洲保险业：法规、风险管理和内部控制</em> (pp. 7–29). Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-43142-6_2">https://doi.org/10.1007/978-3-030-43142-6_2</a><br>Cerda, P., &amp; Varoquaux, G. (2022). 编码高基数字符串分类变量. <em>IEEE知识与数据工程汇刊</em>, 34(3), 1164–1176. <a href="https://doi.org/10.1109/TKDE.2020.2992529">https://doi.org/10.1109/TKDE.2020.2992529</a><br>Das, S., Datta, S., Zubaidi, H. A., &amp; Obaid, I. A. (2021). 使用可解释机器学习分类树木和公用杆相关碰撞伤害类型. <em>IATSS研究</em>, 45(3), 310–316. <a href="https://doi.org/10.1016/j.iatssr.2021.01.001">https://doi.org/10.1016/j.iatssr.2021.01.001</a><br>de Souza, M., de Castro, J. G., Peng, D. T., &amp; Gartner, I. R. (2024). 基于机器学习分析银行业金融机构金融压力的因果关系. <em>计算经济学</em>, 64(3), 1857–1890. <a href="https://doi.org/10.1007/s10614-023-10514-z">https://doi.org/10.1007/s10614-023-10514-z</a><br>Dhieb, N., Ghazzai, H., Besbes, H., &amp; Massoud, Y. (2019). 极端梯度提升机器学习算法用于安全汽车保险运营. <em>2019 IEEE车辆电子与安全国际会议 (ICVES)</em>, 1–5.<br>Dhieb, N., Ghazzai, H., Besbes, H., &amp; Massoud, Y. (2020). 用于自动保险系统的安全AI驱动架构：欺诈检测和风险测量. <em>IEEE访问：实用创新、开放解决方案</em>, 8, 58546–58558. <a href="https://doi.org/10.1109/ACCESS.2020.2983300">https://doi.org/10.1109/ACCESS.2020.2983300</a><br>Gupta, S., Modgil, S., Bhattacharyya, S., &amp; Bose, I. (2022). 人工智能用于运筹研究领域的决策支持系统：回顾和未来研究范围. <em>运筹学年鉴</em>, 308(1), 215–274. <a href="https://doi.org/10.1007/s10479-020-03856-6">https://doi.org/10.1007/s10479-020-03856-6</a><br>Hanafy, M., &amp; Ming, R. (2021). 通过数据级别方法改善汽车保险中的不平衡数据分类. <em>先进计算机科学与应用国际杂志</em>, 12(6), 493–499.<br>Hassan, A. K. I., &amp; Abraham, A. (2013). 计算智能模型用于保险欺诈检测：十年研究的回顾. <em>网络与创新计算杂志</em>, 1(2013), 341–347.<br>Hassan, A. K. I., &amp; Abraham, A. (2016a). 使用集成结合分类预测埃及市场保险公司破产. <em>计算机信息系统与工业管理应用国际杂志</em>, 8, 257–265.<br>Hassan, A. K. I., &amp; Abraham, A. (2016b). 使用不平衡数据分类建模保险欺诈检测. 在 N. Pillay, A. P. Engelbrecht, A. Abraham, du M. C. Plessis, V. Snášel, &amp; A. K. Muda (编), <em>自然和生物启发计算进展</em> (pp. 117–127). Springer International Publishing.<br>Hossin, M., &amp; Sulaiman, M. N. (2015). 数据分类评估的评价指标回顾. <em>数据挖掘与知识管理过程国际杂志</em>, 5(2), 1.<br>Hoyt, R. E., Mustard, D. B., &amp; Powell, L. S. (2006). 州立法在减轻道德风险方面的有效性：来自汽车保险的证据. <em>法律与经济学杂志</em>, 49(2), 427–450. <a href="https://doi.org/10.1086/501092">https://doi.org/10.1086/501092</a><br>Itri, B., Mohamed, Y., Mohammed, Q., &amp; Omar, B. (2019). 汽车保险欺诈检测的机器学习算法性能比较研究. <em>2019第三届智能计算与数据科学国际会议 (ICDS)</em>, 1–4. <a href="https://doi.org/10.1109/ICDS47004.2019.8942277">https://doi.org/10.1109/ICDS47004.2019.8942277</a><br>Jovanovic, D., Antonijevic, M., Stankovic, M., Zivkovic, M., Tanaskovic, M., &amp; Bacanin, N. (2022). 使用组搜索萤火虫算法优化信用卡欺诈检测的机器学习模型. <em>数学</em>, 10(13), 2272.<br>Kafhali, E., S., &amp; Tayebi, M. (2024). 基于元启发式的超参数优化对欺诈交易检测性能分析. <em>进化智能</em>, 17(2), 921–939.<br>Khalil, A. A., Liu, Z., &amp; Ali, A. A. (2022a). 使用自适应网络基于模糊推理系统模型预测埃及石油保险的损失比率. <em>风险管理与保险评论</em>, 25(1), 5–18. <a href="https://doi.org/10.1111/rmir.12200">https://doi.org/10.1111/rmir.12200</a><br>Khalil, A. A., Liu, Z., Salah, A., Fathalla, A., &amp; Ali, A. (2022b). 使用袋装和提升集成技术预测埃及市场保险公司破产. <em>IEEE访问：实用创新、开放解决方案</em>, 10, 117304–117314. <a href="https://doi.org/10.1109/ACCESS.2022.3210032">https://doi.org/10.1109/ACCESS.2022.3210032</a><br>Khalil, A. A., Liu, Z., Fathalla, A., Ali, A., &amp; Salah, A. (2024a). 基于机器学习的保险欺诈检测方法用于类不平衡数据集与缺失值. <em>IEEE访问</em>. <a href="https://doi.org/10.1109/ACCESS.2024.3468993">https://doi.org/10.1109/ACCESS.2024.3468993</a><br>Khalil, A. A., Liu, Z., Fathalla, A., Ali, A., &amp; Salah, A. (2024b). 使用自适应神经模糊推理系统的集成和组合模型提升埃及保险业的保险预测精度. <em>应用人工智能</em>, 38(1), 2348413. <a href="https://doi.org/10.1080/08839514.2024.2348413">https://doi.org/10.1080/08839514.2024.2348413</a><br>Kotsiantis, S., Kanellopoulos, D., &amp; Pintelas, P. (2006). 处理不平衡数据集：回顾. <em>GESTS计算机科学与工程国际交易</em>, 30(1), 25–36.<br>Kowshalya, G., &amp; Nandhini, M. (2018). 汽车保险中的欺诈理赔预测. <em>2018第二届发明通信与计算技术国际会议 (ICICCT)</em>, 1338–1343. <a href="https://doi.org/10.1109/ICICCT.2018.8473034">https://doi.org/10.1109/ICICCT.2018.8473034</a><br>Lakshmanarao, A., Srisaila, A., &amp; Kiran, T. S. R. (2022). 使用特征选择方法的自适应信用卡欺诈检测技术. <em>2022通信、计算与物联网国际会议 (IC3IoT)</em>, 1–5.<br>Li, P., Rao, X., Blase, J., Zhang, Y., Chu, X., &amp; &amp; Zhang, C. (2021). CleanML：评估数据清洗对ML分类任务影响的研究. <em>2021 IEEE第37届数据工程国际会议 (ICDE)</em>, 13–24. <a href="https://doi.org/10.1109/ICDE51399.2021.00009">https://doi.org/10.1109/ICDE51399.2021.00009</a><br>Liu, J., Wu, C., &amp; Li, Y. (2019). 使用基于金融网络的信息和GA基于梯度提升方法改善财务困境预测. <em>计算经济学</em>, 53(2), 851–872. <a href="https://doi.org/10.1007/s10614-017-9768-3">https://doi.org/10.1007/s10614-017-9768-3</a><br>Liu, T., Zhu, X., Pedrycz, W., &amp; Li, Z. (2020). 基于信息粒度的欠采样方法设计用于不平衡数据分类. <em>软计算</em>, 24(22), 17333–17347. <a href="https://doi.org/10.1007/s00500-020-05023-2">https://doi.org/10.1007/s00500-020-05023-2</a><br>Lundberg, S. M., &amp; Lee, S. I. (2017). 解释模型预测的统一方法. <em>神经信息处理系统进展</em>, 30, 1–10.<br>NAIC (2022). <em>特别调查单位 (SIU) 指南</em>.<br>Nordin, S. Z. S., Wah, Y. B., Haur, N. K., Tan, K. P., Hashim, A., Rambeli, N., &amp; Jalil, N. A. (2024). 使用经典和机器学习模型预测汽车保险欺诈. <em>电气与计算机工程国际杂志 (IJECE)</em>, 14(1), 911–921.<br>Park, Y., &amp; Kwon, T. Y. (2024). 使用划分袋装的大数据特征选择集成. <em>计算经济学</em>. <a href="https://doi.org/10.1007/s10614-024-10741-y">https://doi.org/10.1007/s10614-024-10741-y</a><br>Pearsall, J. (1999). <em>简明牛津词典第10版</em>. Oxford UP.<br>Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., Blondel, M., Prettenhofer, P., Weiss, R., &amp; Dubourg, V. (2011). Scikit-learn：Python中的机器学习. <em>机器学习研究杂志</em>, 12, 2825–2830.<br>Piovezan, R. P. B., de Andrade Junior, P. P., &amp; Ávila, S. L. (2023). 用于不完整数据的三向集成聚类. <em>IEEE访问 : 实用创新, 开放解决方案</em>, 8, 91855–91864.<br>Prasasti, I. M. N., Dhini, A., &amp; Laoh, E. (2020). 使用监督分类器检测汽车保险欺诈. <em>2020大数据与信息安全国际研讨会 (IWBIS)</em>, 47–52. <a href="https://doi.org/10.1109/IWBIS50925.2020.9255426">https://doi.org/10.1109/IWBIS50925.2020.9255426</a><br>Roy, R., &amp; George, K. T. (2017). 使用机器学习技术检测保险理赔欺诈. <em>2017电路、功率和计算技术国际会议 (ICCPCT)</em>, 1–6. <a href="https://doi.org/10.1109/ICCPCT.2017.8074258">https://doi.org/10.1109/ICCPCT.2017.8074258</a><br>Saylor, A. T. (2023). 增强机会主义汽车保险欺诈的威慑和检测的建议，用于保险专业人士和行业伙伴 [硕士论文, 威斯康星大学 – Platteville]. <a href="https://minds.wisconsin.edu/bitstream/handle/1793/84189/Saylor,%20Andrew.pdf?sequence=1">https://minds.wisconsin.edu/bitstream/handle/1793/84189/Saylor,%20Andrew.pdf?sequence=1</a><br>Singh, S. K., &amp; Chivukula, M. (2020). 人工智能在保险业中的应用评论. <em>人工智能趋势</em>, 4(1), 75–79.<br>Singh, A., &amp; Jain, A. (2019). 基于特征选择方法的自适应信用卡欺诈检测技术. 在 S. K. Bhatia, S. Tiwari, K. K. Mishra, &amp; M. C. Trivedi (编), <em>计算机通信与计算科学进展</em> (pp. 167–178). Springer Singapore.<br>Srivatsan, S., &amp; Santhanam, T. (2021). 使用特征选择和提升技术的早期糖尿病发作检测. <em>软计算ICTACT杂志</em>, 12(1), 2474–2485.<br>Subudhi, S., &amp; Panigrahi, S. (2018). 类不平衡在检测汽车保险欺诈中的影响. <em>2018第二届数据科学与商业分析国际会议 (ICDSBA)</em>, 528–531. <a href="https://doi.org/10.1109/ICDSBA.2018.00104">https://doi.org/10.1109/ICDSBA.2018.00104</a><br>Subudhi, S., &amp; Panigrahi, S. (2020). 使用优化的模糊c均值聚类和监督分类器检测汽车保险理赔欺诈. <em>金 Saud大学计算机与信息科学杂志</em>, 32(5), 568–575. <a href="https://doi.org/10.1016/j.jksuci.2017.09.010">https://doi.org/10.1016/j.jksuci.2017.09.010</a><br>Sundarkumar, G. G., Ravi, V., &amp; Siddeshwar, V. (2015). 基于单类支持向量机的欠采样：应用于流失预测和保险欺诈检测. <em>2015 IEEE计算智能与计算研究国际会议 (ICCIC)</em>, 1–7. <a href="https://doi.org/10.1109/ICCIC.2015.7435726">https://doi.org/10.1109/ICCIC.2015.7435726</a><br>Tayebi, M., &amp; Kafhali, E., S. (2024). 元启发式基于超参数优化对欺诈交易检测的性能分析. <em>进化智能</em>, 17(2), 921–939.<br>Turban, E. (2011). <em>决策支持与商业智能系统</em>. Pearson Education India.<br>Visalakshi, S., &amp; Radha, V. (2014). 特征选择技术及其应用文献回顾：数据挖掘中特征选择的回顾. <em>2014 IEEE计算智能与计算研究国际会议</em>, 1–6.<br>Wang, P., &amp; Chen, X. (2020). 用于不完整数据的三向集成聚类. <em>IEEE访问 : 实用创新, 开放解决方案</em>, 8, 91855–91864.<br>Wang, Y., &amp; Xu, W. (2018). 使用深度学习和基于LDA的文本分析检测汽车保险欺诈. <em>决策支持系统</em>, 105, 87–95. <a href="https://doi.org/10.1016/j.dss.2017.11.001">https://doi.org/10.1016/j.dss.2017.11.001</a><br>Xiaolong, X., Wen, C., &amp; Yanfei, S. (2019). 用于不平衡数据分类的过采样算法. <em>系统工程与电子杂志</em>, 30(6), 1182–1191. <a href="https://doi.org/10.21629/JSEE.2019.06.12">https://doi.org/10.21629/JSEE.2019.06.12</a><br>Zhang, X., Yu, L., &amp; Yin, H. (2024). 基于集成重采样的迁移AdaBoost算法用于小样本信用分类与类不平衡. <em>计算经济学</em>. <a href="https://doi.org/10.1007/s10614-024-10690-6">https://doi.org/10.1007/s10614-024-10690-6</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;我真的服了为什么实训论文要把ddl放在期末考试之前…&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、完成科研论文一篇，具体要求如下：&lt;/p&gt;
&lt;p&gt;1、科研论文主题：传统机器学习在保险领域的前沿研究课题&lt;/p&gt;
&lt;p&gt;涵盖风险评估、欺诈检测、客户细分等多个方面，以下是</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-29-关于画布项目的相关考虑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/2357.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/2357.html</id>
    <published>2025-12-28T20:52:15.000Z</published>
    <updated>2025-12-29T07:44:54.292Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 仓库 <a href="https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>该项目技术栈先进（React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8），涉及高性能渲染、无限画布、撤销/重做、实时协作等复杂功能，因此问题往往聚焦于性能优化、状态管理、图形渲染、架构设计以及实际工程实践。</p><h3 id="1-项目整体介绍与架构设计"><a href="#1-项目整体介绍与架构设计" class="headerlink" title="1. 项目整体介绍与架构设计"></a>1. 项目整体介绍与架构设计</h3><h4 id="项目的主要功能、目标用户以及它解决了哪些实际问题？"><a href="#项目的主要功能、目标用户以及它解决了哪些实际问题？" class="headerlink" title="项目的主要功能、目标用户以及它解决了哪些实际问题？"></a><strong>项目的主要功能、目标用户以及它解决了哪些实际问题？</strong></h4><blockquote><p>BDdraw_DEV 是一个现代化的协同 2D 画布编辑器，采用 React + TypeScript + PixiJS 技术栈构建。该项目提供多种基本图形（矩形、圆形、菱形、线条、箭头、画笔等）元素的绘制，支持背景色、边框宽度、边框颜色等图形属性设置、富文本编辑、图片插入与滤镜处理，支持无限画布缩放、拖拽、提供 minimap，实现元素选择、分组、旋转、调整大小，支持撤销重做，快捷键，数据持久化，本地优先编辑，海量元素处理等交互功能。</p><p>该项目作为一个集成协同编辑、离线编辑的无限画布，来解决团队协作协作效率和同步的问题</p></blockquote><h4 id="项目架构是如何设计的？为什么选择将-React-用于-UI-层、Zustand-用于状态管理、PixiJS-用于渲染层分离？"><a href="#项目架构是如何设计的？为什么选择将-React-用于-UI-层、Zustand-用于状态管理、PixiJS-用于渲染层分离？" class="headerlink" title="项目架构是如何设计的？为什么选择将 React 用于 UI 层、Zustand 用于状态管理、PixiJS 用于渲染层分离？"></a><strong>项目架构是如何设计的？为什么选择将 React 用于 UI 层、Zustand 用于状态管理、PixiJS 用于渲染层分离？</strong></h4><blockquote><p>项目的核心在于其三层架构设计：React 负责 UI 层、Zustand 管理状态层、PixiJS 处理渲染层，实现数据驱动视图的模式。其便于实现撤销/重做、数据持久化和多人协同编辑等高级功能</p><p>其优势在于：<br>解耦设计：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展<br>便于协同：所有状态都集中管理在 Zustand Store 中，便于实现多人协同编辑<br>易于撤销/重做：通过保存和恢复 Store 的快照实现完整的撤销/重做功能<br>可持久化：状态数据可以轻松序列化/反序列化，便于保存和传输</p></blockquote><h4 id="项目是如何组织目录结构的？这种模块化设计带来了哪些好处？"><a href="#项目是如何组织目录结构的？这种模块化设计带来了哪些好处？" class="headerlink" title="项目是如何组织目录结构的？这种模块化设计带来了哪些好处？"></a><strong>项目是如何组织目录结构的？这种模块化设计带来了哪些好处？</strong></h4><p>前端部分主要是分为五个模块：</p><h5 id="src-api-API-客户端和类型定义（处理前后端通信）"><a href="#src-api-API-客户端和类型定义（处理前后端通信）" class="headerlink" title="src/api - API 客户端和类型定义（处理前后端通信）"></a>src/api - API 客户端和类型定义（处理前后端通信）</h5><ul><li>types - API 类型定义</li><li>utils - API 工具函数</li><li>API 服务封装和客户端工具</li></ul><h5 id="src-components-React-UI-组件（各种-UI-组件）"><a href="#src-components-React-UI-组件（各种-UI-组件）" class="headerlink" title="src/components - React UI 组件（各种 UI 组件）"></a>src/components - React UI 组件（各种 UI 组件）</h5><ul><li>canvas_toolbar - 画布工具栏组件</li><li>collaboration - 协作功能组件</li><li>header - 页面头部组件</li><li>property-panel - 属性面板组件</li><li>richtext_editor - 富文本编辑器组件</li></ul><h5 id="src-hooks-自定义-React-Hooks"><a href="#src-hooks-自定义-React-Hooks" class="headerlink" title="src/hooks - 自定义 React Hooks"></a>src/hooks - 自定义 React Hooks</h5><ul><li>状态管理（简单的本地存储，用于存储用户偏好、UI 状态等）</li><li>快捷键处理</li></ul><h5 id="src-lib-工具库和核心功能模块"><a href="#src-lib-工具库和核心功能模块" class="headerlink" title="src/lib - 工具库和核心功能模块"></a>src/lib - 工具库和核心功能模块</h5><ul><li>AddElementCommand.ts、RemoveElementCommand.ts、UndoRedoManager.ts - 命令模式实现</li><li>constants.ts - 常量定义</li><li>utils.ts - 通用工具函数</li></ul><h5 id="src-pages-页面组件"><a href="#src-pages-页面组件" class="headerlink" title="src/pages - 页面组件"></a>src/pages - 页面组件</h5><ul><li>auth - 认证相关页面</li><li>home - 主页</li><li>room - 房间管理页面</li><li><p><strong>canvas/Pixi_STM_modules - Pixi.js 状态管理模块</strong></p><ul><li>core - 核心类和初始化逻辑</li><li>interaction - 交互处理模块（例如拖拽、缩放、选择等）</li><li>utils - 工具函数目录（各项操作的封装）</li><li>shared - 共享类型定义</li></ul></li></ul><h5 id="src-stores-状态管理（Yjs-IndexedDB-复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）"><a href="#src-stores-状态管理（Yjs-IndexedDB-复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）" class="headerlink" title="src/stores - 状态管理（Yjs + IndexedDB - 复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）"></a>src/stores - 状态管理（Yjs + IndexedDB - 复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）</h5><ul><li>canvasStore.ts - 画布状态管理</li><li>persistenceStore.ts - 持久化状态管理</li><li>themeStore.ts - 主题状态管理</li></ul><p>后端部分的设计：</p><ul><li><strong>房间管理系统</strong> - 支持创建、修改、删除和查询房间</li><li><strong>用户认证系统</strong> - 提供用户登录、注册和权限验证</li><li><strong>实时协作支持</strong> - 通过  collab.ts  实现</li><li><strong>数据库</strong> - 通过  db.ts  连接和操作数据库</li></ul><p>数据库设计（sqlite，原型验证阶段所使用）</p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-466ea97d53037f5c8505d87a87c2e52e_720w.webp'><img src="https://pica.zhimg.com/80/v2-466ea97d53037f5c8505d87a87c2e52e_720w.webp" alt=""></p><p>每个房间的画布数据在对应表中的 content 中</p><h4 id="项目中如何处理前端与后端（ALD-Backend）的交互？"><a href="#项目中如何处理前端与后端（ALD-Backend）的交互？" class="headerlink" title="项目中如何处理前端与后端（ALD_Backend）的交互？"></a><strong>项目中如何处理前端与后端（ALD_Backend）的交互？</strong></h4><blockquote><p>该项目前后端分离，交互采用 REST API（表现层状态转移应用编程接口，是一种基于 REST 架构风格设计的 Web API），前端通过 TypeScript 封装的 API 层统一管理所有 HTTP 请求，使用 Axios 作为 HTTP 客户端，配置了请求和响应拦截器来处理认证、错误处理和加载状态。其通过环境变量管理不同环境的基础 URL，定义了统一的响应格式和类型定义来确保类型安全，同时并在需要实时协作的场景下使用 WebSocket 进行双向通信。</p></blockquote><p>Axios 是一个基于 Promise 的网络请求库，用于在浏览器和 Node.js 中进行 HTTP 请求，并支持请求/响应拦截、取消，并发请求，自动转换数据等功能</p><p>详情见博客文章：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/16956.html">前端学习-接口类型定义、Axios 封装与请求规范 | 笔记站 (zhongye1.github.io)</a></p><p>身份验证管理实现：</p><ul><li>使用 JWT Token 进行身份验证</li><li>通过  setAuthToken  和  clearAuthToken  管理认证状态</li><li><code>onAuthenticate</code>  钩子验证用户权限</li></ul><p>详情见博客文章：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/42304.html">前端学习-身份验证管理-基于 JWT Token 的实现 (zhongye1.github.io)</a></p><hr><p><strong>实时协作部分是如何实现的？</strong></p><p>实时协作功能通过 Yjs、Hocuspocus 和 IndexedDB 实现：</p><p>可以看博客：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/60473.html">2025-12-27-前端画布设计 Vol.3 实现 CRDT | Notes|笔记站 (zhongye1.github.io)</a></p><ol><li>前端(react)</li></ol><ul><li>使用 Yjs 的 CRDT 数据结构实现多客户端状态同步</li><li>通过  <code>HocuspocusProvider</code>  连接到后端 WebSocket 服务器</li><li>结合 IndexedDB 持久化，实现离线编辑功能</li></ul><ol><li>后端（bun）</li></ol><ul><li>使用 Hocuspocus 作为 Yjs 的协作服务器</li><li>实现了数据库扩展，将 Yjs 文档状态持久化到 SQLite 数据库</li><li>通过 WebSocket 协议处理实时通信</li></ul><ol><li>认证与权限控制</li></ol><ul><li>WebSocket 连接需要 JWT Token 认证</li><li>服务器验证用户是否有权限访问特定房间</li><li>如果用户没有访问权限，会自动将其添加到房间成员中</li></ul><ol><li>数据同步</li></ol><ul><li>前端使用 Yjs 的  <code>Y.Map</code>  存储画布元素数据</li><li>通过  <code>IndexeddbPersistence</code>  将数据持久化到浏览器的 IndexedDB</li><li>使用  <code>HocuspocusProvider</code>  将数据同步到服务器和其他客户端</li></ul><ol><li>在线/离线处理</li></ol><ul><li>当用户在线时，数据实时同步到服务器</li><li>当用户离线时，数据保存在本地 IndexedDB 中</li><li>重新连接后，本地更改会自动同步到服务器（CRDT）</li></ul><ol><li>用户状态管理</li></ol><ul><li>使用 Yjs 的 Awareness 功能跟踪在线用户</li><li>广播机制实时显示协作者的光标位置和选中状态</li><li>通过后端认证机制确保只有授权用户可以加入协作</li></ul><hr><h3 id="2-状态管理（Zustand）"><a href="#2-状态管理（Zustand）" class="headerlink" title="2. 状态管理（Zustand）"></a>2. 状态管理（Zustand）</h3><p>Zustand 是项目核心状态工具，轻量且无 boilerplate。</p><ul><li>为什么选择 Zustand 而非 Redux 或 Context API？在画布状态管理中，它相比其他方案的优势体现在哪里？</li></ul><blockquote><pre><code>Zustand 的 API 设计非常简洁，避免了 Redux 中大量样板代码（boilerplate code）的问题。在 Redux 中，我们需要定义 actions、reducers、store 等多个部分，而 Zustand 只需一个函数即可创建 storeZustand 在性能优化方面，可以实现选择性订阅，避免不必要的组件重新渲染。Context API 在状态更新时会触发所有子组件的重新渲染，而 Zustand 允许我们精确地控制哪些组件需要响应特定状态变化。</code></pre></blockquote><ul><li>如何使用 Zustand 管理画布元素状态（elements: Record<string, CanvasElement="">）？如何实现持久化（Zustand-persist + localForage + IndexedDB）？</string,></li></ul><h4 id="如何使用-Zustand-管理画布元素状态？"><a href="#如何使用-Zustand-管理画布元素状态？" class="headerlink" title="如何使用 Zustand 管理画布元素状态？"></a>如何使用 Zustand 管理画布元素状态？</h4><p>在我们的项目中，画布元素状态是通过  CanvasState  接口定义的，其中  elements  属性是一个  <code>Record&lt;string, CanvasElement&gt;</code>  类型的对象，用于存储所有画布元素：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[];<br>  <span class="hljs-comment">// ... 其他状态</span><br>}<br></code></pre></td></tr></table></figure><p>我们通过直接操作 Yjs 共享数据类型来管理元素状态，从而实现协同编辑功能：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 添加元素</span><br><span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    currentYElements?.<span class="hljs-title function_">set</span>(el.<span class="hljs-property">id</span>, el)<br>  })<br>},<br><br><span class="hljs-comment">// 更新元素</span><br><span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params">id, attrs</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">const</span> oldEl = currentYElements?.<span class="hljs-title function_">get</span>(id)<br>    <span class="hljs-keyword">if</span> (oldEl) {<br>      currentYElements?.<span class="hljs-title function_">set</span>(id, { ...oldEl, ...attrs })<br>    }<br>  })<br>},<br><br><span class="hljs-comment">// 删除元素</span><br><span class="hljs-attr">removeElements</span>: <span class="hljs-function">(<span class="hljs-params">ids</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    ids.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> currentYElements?.<span class="hljs-title function_">delete</span>(id))<br>  })<br>}<br></code></pre></td></tr></table></figure><h4 id="如何实现持久化（Zustand-persist-localForage-IndexedDB）？"><a href="#如何实现持久化（Zustand-persist-localForage-IndexedDB）？" class="headerlink" title="如何实现持久化（Zustand-persist + localForage + IndexedDB）？"></a>如何实现持久化（Zustand-persist + localForage + IndexedDB）？</h4><p>在我们的实现中，持久化是通过 Yjs 的 IndexedDB 持久化机制完成的，而不是使用传统的 zustand-persist。我们使用  IndexeddbPersistence  与 HocuspocusProvider 组合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 persistenceStore.ts 中创建持久化提供者</span><br><span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<br>  <span class="hljs-string">`canvas-local-db-<span class="hljs-subst">${roomId}</span>`</span>,<br>  yDoc<br>);<br></code></pre></td></tr></table></figure><p>这种设计的优势在于:</p><ol><li>Yjs 会自动处理 IndexedDB 的读写操作，无需手动管理</li><li>提供了离线支持，即使在断网情况下数据也能保存在本地</li><li>当重新连接网络时，会自动同步本地和远程数据</li><li>IndexedDB 的异步操作不会阻塞 UI 线程，保证了应用的响应性</li></ol><h4 id="在多用户协作场景下，Zustand-与-Y-js-CRDT-如何结合？如何处理冲突和状态同步？"><a href="#在多用户协作场景下，Zustand-与-Y-js-CRDT-如何结合？如何处理冲突和状态同步？" class="headerlink" title="在多用户协作场景下，Zustand 与 Y.js CRDT 如何结合？如何处理冲突和状态同步？"></a>在多用户协作场景下，Zustand 与 Y.js CRDT 如何结合？如何处理冲突和状态同步？</h4><p>Zustand 作为前端状态管理工具，提供状态访问接口<br>Y.js 作为协同编辑引擎，处理多用户间的数据同步和冲突解决<br>通过 Y.js 的 observe 机制，将 Y.js 的数据变化同步到 Zustand 状态中</p><h3 id="3-高性能渲染与-PixiJS-集成"><a href="#3-高性能渲染与-PixiJS-集成" class="headerlink" title="3. 高性能渲染与 PixiJS 集成"></a>3. 高性能渲染与 PixiJS 集成</h3><p>PixiJS WebGL 渲染是项目性能关键，面试官会深入考察。</p><h4 id="为什么引入-PixiJS-而非纯-Canvas-或-SVG？它在实现-60-FPS-和无限画布时发挥了什么作用？"><a href="#为什么引入-PixiJS-而非纯-Canvas-或-SVG？它在实现-60-FPS-和无限画布时发挥了什么作用？" class="headerlink" title="为什么引入 PixiJS 而非纯 Canvas 或 SVG？它在实现 60 FPS 和无限画布时发挥了什么作用？"></a>为什么引入 PixiJS 而非纯 Canvas 或 SVG？它在实现 60 FPS 和无限画布时发挥了什么作用？</h4><blockquote><pre><code>PixiJS 是一个基于 WebGL 的 2D 渲染引擎，它具有极高的性能优势，可以充分利用 GPU 加速。相比纯 Canvas API，PixiJS 提供了更高层次的抽象，开发者无需手动管理底层的渲染细节，同时能够获得更好的性能表现。与 SVG 相比，PixiJS 在处理大量图形元素时表现更佳。SVG 是基于 DOM 的，当元素数量增加时，DOM 操作的开销会显著增加，导致性能下降。而 PixiJS 直接在 GPU 层面进行渲染，即使处理数千个元素也能保持流畅性能。对于无限画布的实现，PixiJS 提供了强大的 pixi-viewport 插件，它可以处理大规模场景的渲染优化。通过视口裁剪（view culling）技术，PixiJS 只渲染当前可见区域内的元素，大幅减少了渲染开销。</code></pre></blockquote><h4 id="如何使用-pixi-viewport-实现无限画布的缩放、平移和边界限制？"><a href="#如何使用-pixi-viewport-实现无限画布的缩放、平移和边界限制？" class="headerlink" title="如何使用 pixi-viewport 实现无限画布的缩放、平移和边界限制？"></a>如何使用 pixi-viewport 实现无限画布的缩放、平移和边界限制？</h4><p>实现缩放、平移和边界限制：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Stage_InteractionHandler.ts 中实现视口功能</span><br>viewport<br>  .<span class="hljs-title function_">drag</span>() <span class="hljs-comment">// 启用拖拽平移</span><br>  .<span class="hljs-title function_">pinch</span>() <span class="hljs-comment">// 启用双指缩放</span><br>  .<span class="hljs-title function_">wheel</span>() <span class="hljs-comment">// 启用滚轮缩放</span><br>  .<span class="hljs-title function_">clamp</span>({ <span class="hljs-attr">direction</span>: <span class="hljs-string">"all"</span> }) <span class="hljs-comment">// 边界限制</span><br>  .<span class="hljs-title function_">bounce</span>(); <span class="hljs-comment">// 边界弹性效果</span><br></code></pre></td></tr></table></figure><p>缩放功能通过 pinch 和 wheel 插件实现，用户可以通过双指手势或鼠标滚轮进行缩放。平移功能通过 drag 插件实现，用户可以拖拽画布。clamp 功能用于限制视口边界，防止用户将视口拖拽到画布内容之外的区域。</p><p>viewport 提供多个配置选项，如缩放级别限制、平滑动画等</p><h4 id="项目中如何缓存-PixiJS-对象（spriteMap）以避免拖拽-缩放时的重复创建？这对性能有何影响？"><a href="#项目中如何缓存-PixiJS-对象（spriteMap）以避免拖拽-缩放时的重复创建？这对性能有何影响？" class="headerlink" title="项目中如何缓存 PixiJS 对象（spriteMap）以避免拖拽/缩放时的重复创建？这对性能有何影响？"></a>项目中如何缓存 PixiJS 对象（spriteMap）以避免拖拽/缩放时的重复创建？这对性能有何影响？</h4><p>在项目中，我们使用  spriteMap  来缓存 PixiJS 对象，避免在拖拽、缩放等操作中重复创建和销毁元素。spriteMap  是一个以元素 ID 为键的 Map，存储了每个画布元素对应的 PixiJS 显示对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Pixi_stageManager.ts 中定义</span><br>spriteMap <span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br></code></pre></td></tr></table></figure><p>当画布元素更新时，我们首先检查  spriteMap  中是否已存在对应的显示对象，如果存在则直接更新其属性，而不是创建新的对象。</p><ol><li>减少了对象创建和垃圾回收的开销</li><li>提高了渲染效率，因为现有对象只需更新属性而非重新创建</li><li>保持了对象状态的连续性，例如动画状态、事件监听器等</li></ol><h4 id="图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在-PixiJS-中实现的？遇到过哪些渲染挑战？"><a href="#图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在-PixiJS-中实现的？遇到过哪些渲染挑战？" class="headerlink" title="图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在 PixiJS 中实现的？遇到过哪些渲染挑战？"></a>图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在 PixiJS 中实现的？遇到过哪些渲染挑战？</h4><p>在项目中，我们使用 PixiJS 的滤镜系统实现图像效果。对于 BlurFilter 和 ColorMatrixFilter 等滤镜，我们通过以下方式应用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BlurFilter</span>, <span class="hljs-title class_">ColorMatrixFilter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"pixi.js"</span>;<br><br><span class="hljs-comment">// 为图像元素添加滤镜</span><br><span class="hljs-keyword">const</span> blurFilter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlurFilter</span>();<br><span class="hljs-keyword">const</span> colorFilter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorMatrixFilter</span>();<br><br>sprite.<span class="hljs-property">filters</span> = [blurFilter, colorFilter];<br></code></pre></td></tr></table></figure><p>对于富文本渲染，我们使用了 pixi-text-html 库，它允许我们在 PixiJS 中渲染 HTML 样式的文本。HTMLText 组件可以解析 HTML 标签并渲染出格式化的文本。</p><h4 id="小地图（Minimap）如何通过-cacheAsBitmap-实现实时更新？为什么需要单独的-Pixi-Application？"><a href="#小地图（Minimap）如何通过-cacheAsBitmap-实现实时更新？为什么需要单独的-Pixi-Application？" class="headerlink" title="小地图（Minimap）如何通过 cacheAsBitmap 实现实时更新？为什么需要单独的 Pixi Application？"></a>小地图（Minimap）如何通过 cacheAsBitmap 实现实时更新？为什么需要单独的 Pixi Application？</h4><p>小地图的实现主要通过 cacheAsBitmap 属性来优化性能。cacheAsBitmap 将显示对象及其子对象渲染到一个内部纹理中，后续渲染只需绘制该纹理，而无需重新计算所有子对象的渲染，从而大幅提升性能。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">stage.<span class="hljs-property">cacheAsBitmap</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>小地图需要单独的 Pixi Application 实例，主要原因包括：</p><p>性能隔离：小地图的渲染频率可能与主画布不同，独立的实例可以更好地控制渲染性能<br>独立交互：小地图可能需要独立的交互逻辑，如点击跳转到画布特定位置<br>资源管理：独立的实例可以更好地管理小地图相关的纹理和资源<br>缩放独立性：小地图需要保持固定比例的缩略图，独立的渲染上下文更容易实现这一功能</p><h3 id="4-撤销-重做机制（命令模式）"><a href="#4-撤销-重做机制（命令模式）" class="headerlink" title="4. 撤销/重做机制（命令模式）"></a>4. 撤销/重做机制（命令模式）</h3><h4 id="项目中撤销-重做是如何实现的？为什么采用-Command-Pattern？"><a href="#项目中撤销-重做是如何实现的？为什么采用-Command-Pattern？" class="headerlink" title="项目中撤销/重做是如何实现的？为什么采用 Command Pattern？"></a>项目中撤销/重做是如何实现的？为什么采用 Command Pattern？</h4><p>撤销/重做功能是通过命令模式（Command Pattern）实现的。我们定义了一个  Command  接口，它包含  execute、undo  和  redo  三个方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>;<br>}<br></code></pre></td></tr></table></figure><p>我们为不同类型的画布操作创建了相应的命令类，如  AddElementCommand、RemoveElementCommand  和  UpdateElementCommand  等。每个命令类都保存了执行操作所需的信息，能够在  undo  和  redo  时恢复到相应的状态。</p><p>采用命令模式的主要原因有以下几点：</p><p><strong>解耦</strong>：命令模式将操作的执行者与请求者解耦，使我们可以轻松地添加新的命令类型而无需修改现有代码。<br><strong>状态一致性</strong>：在协同编辑环境中，命令模式确保所有操作都可以被准确地撤销和重做，保持状态一致性。<br><strong>易于扩展</strong>：我们可以轻松地添加新的命令类型，如分组、取消分组等。</p><h4 id="每个命令（如-AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？"><a href="#每个命令（如-AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？" class="headerlink" title="每个命令（如 AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？"></a>每个命令（如 AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？</h4><h5 id="AddElementCommand-的撤销与重做实现"><a href="#AddElementCommand-的撤销与重做实现" class="headerlink" title="AddElementCommand 的撤销与重做实现"></a>AddElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">payload</span>: { element: CanvasElement }</span>) {}<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 添加元素到画布</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 从画布移除元素，实现撤销</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>.<span class="hljs-property">id</span>]);<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重新添加元素，实现重做（与 execute 相同）</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>);<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：通过移除新增的元素恢复原状态，仅需元素 ID。</li><li><strong>重做（redo）</strong>：直接重复添加操作，无需额外存储数据。</li></ul><h5 id="RemoveElementCommand-的撤销与重做实现"><a href="#RemoveElementCommand-的撤销与重做实现" class="headerlink" title="RemoveElementCommand 的撤销与重做实现"></a>RemoveElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">elementData</span>: <span class="hljs-title class_">CanvasElement</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">payload</span>: { element: CanvasElement }</span>) {}<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 先保存被移除元素的完整数据（用于后续恢复）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span> = { ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span> };<br>    <span class="hljs-comment">// 执行移除</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>.<span class="hljs-property">id</span>]);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 使用保存的数据重新添加元素，实现撤销移除</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>) {<br>      useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>);<br>    }<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重复移除操作，实现重做</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>) {<br>      useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>.<span class="hljs-property">id</span>]);<br>    }<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：依赖 execute 时存储的元素完整数据进行恢复。</li><li><strong>重做（redo）</strong>：使用存储的数据重复移除，避免直接依赖外部状态。</li></ul><h5 id="UpdateElementCommand-的撤销与重做实现"><a href="#UpdateElementCommand-的撤销与重做实现" class="headerlink" title="UpdateElementCommand 的撤销与重做实现"></a>UpdateElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">previousValues</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">elementId</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">newValues</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-comment">// 在构造函数中保存更新前的属性值（旧状态）</span><br>    <span class="hljs-keyword">const</span> currentState = useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-property">elements</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span> = {};<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(newValues).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span>[key <span class="hljs-keyword">as</span> keyof <span class="hljs-title class_">CanvasElement</span>] =<br>        currentState[key <span class="hljs-keyword">as</span> keyof <span class="hljs-title class_">CanvasElement</span>];<br>    });<br>  }<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 应用新值</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">newValues</span>);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 恢复旧值，实现撤销</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span>);<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重新应用新值，实现重做（与 execute 相同）</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">newValues</span>);<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：通过存储的 previousValues 恢复属性原值。</li><li><strong>重做（redo）</strong>：重复应用新值，确保操作可重复性。</li></ul><p>此设计的核心原则是：在命令对象中存储足够的信息（而非完整状态快照），以独立实现 undo 和 redo 操作，从而支持高效的命令模式撤销/重做栈管理。</p><p>在内存和性能上的权衡包括：</p><ol><li><strong>内存占用</strong>：每个命令都需要保存足够的信息来执行撤销/重做操作，这会增加内存使用。特别是  SnapshotCommand  会保存整个状态的副本，这在元素较多时会占用大量内存。</li><li><strong>性能影响</strong>：创建状态快照需要时间，特别是当画布中有大量元素时。使用  <code>structuredClone</code>  深拷贝大型对象会影响性能。</li><li><strong>存储优化</strong>：为减少内存占用，我们对不同的操作采用不同的存储策略。对于添加/删除操作，只需存储元素本身；对于更新操作，只需存储变更前的值和变更的属性。</li></ol><h4 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h4><p>限制历史栈大小以防止内存溢出<br>对于连续的多个操作，可以合并成一个批量命令，减少栈中命令的数量<br>对于包含大量数据的命令，如图像元素操作，可以在命令不再需要时清理其内部引用的数据<br>对于频繁的操作（如拖拽移动），可以使用防抖机制将连续操作合并为一个命令，减少命令栈的增长速度<br>操作分组：将相关的连续操作视为一个逻辑操作，例如，将创建一个复杂图形的多个步骤合并为一个撤销单位<br>操作描述：为每个命令添加描述，让用户在 UI 上看到具体可撤销/重做的操作内容<br>历史持久化：将撤销/重做历史保存到本地存储，即使页面刷新后也能恢复历史记录。<br>自适应栈大小：根据当前画布复杂度动态调整栈大小，元素较多时使用较小的栈，元素较少时使用较大的栈</p><h3 id="5-交互与用户体验"><a href="#5-交互与用户体验" class="headerlink" title="5. 交互与用户体验"></a>5. 交互与用户体验</h3><h4 id="变换控件（Transform-Controls）的检测与处理"><a href="#变换控件（Transform-Controls）的检测与处理" class="headerlink" title="变换控件（Transform Controls）的检测与处理"></a>变换控件（Transform Controls）的检测与处理</h4><p>变换控件由 TF_controler_Renderer.ts 模块负责渲染，包括包围选中元素的边界框、8 个缩放手柄（位于边角）和 1 个旋转手柄（通常位于顶部或底部）</p><p>手柄检测基于鼠标位置与手柄边界框的距离计算：</p><ul><li>当鼠标进入手柄区域时，光标样式相应改变（例如，边角手柄显示对角箭头，旋转手柄显示旋转图标）</li><li>每个手柄对应特定操作：<ul><li>8 个边角手柄：用于非均匀缩放（保持或不保持宽高比，根据修饰键）</li><li>旋转手柄：用于旋转选中元素（可能以组中心为旋转锚点）</li></ul></li></ul><p>在 Stage_InteractionHandler.ts 中处理实际变换逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 处理缩放操作</span><br><span class="hljs-title function_">handleScale</span>(<span class="hljs-params"><span class="hljs-attr">dx</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">dy</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">handleType</span>: <span class="hljs-built_in">string</span></span>) {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br><br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> element = elements[id];<br>    <span class="hljs-comment">// 根据手柄类型（e.g., 'top-left', 'bottom-right'）计算缩放比例和位置偏移</span><br>    updates[id] = <span class="hljs-title function_">calculateNewDimensions</span>(element, dx, dy, handleType);<br>  });<br><br>  <span class="hljs-comment">// 批量更新元素，避免多次重渲染</span><br>  useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">batchUpdateElements</span>(updates);<br>}<br><br><span class="hljs-comment">// 处理旋转操作（示例）</span><br><span class="hljs-title function_">handleRotate</span>(<span class="hljs-params"><span class="hljs-attr">deltaAngle</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">pivotPoint</span>: { x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span> }</span>) {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br><br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> element = elements[id];<br>    updates[id] = <span class="hljs-title function_">calculateRotatedElement</span>(element, deltaAngle, pivotPoint);<br>  });<br><br>  useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">batchUpdateElements</span>(updates);<br>}<br></code></pre></td></tr></table></figure><h4 id="交互模式切换逻辑"><a href="#交互模式切换逻辑" class="headerlink" title="交互模式切换逻辑"></a>交互模式切换逻辑</h4><p>项目定义了多种交互模式，主要在 Stage_InteractionHandler.ts 中管理，确保同一时刻仅一种模式活跃。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-keyword">const</span> { x, y } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">toLocal</span>(event.<span class="hljs-property">global</span>);<br><br>  <span class="hljs-comment">// 1. 优先检测变换手柄（最高优先级）</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isOverTransformHandle</span>(x, y)) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'transforming'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startTransform</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCurrentHandleType</span>());<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 2. 检测是否点击元素</span><br>  <span class="hljs-keyword">const</span> hitElementId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isOverElement</span>(x, y);<br>  <span class="hljs-keyword">if</span> (hitElementId) {<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">originalEvent</span>.<span class="hljs-property">shiftKey</span>) {<br>      <span class="hljs-comment">// Shift + 点击：多选切换</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toggleSelection</span>(hitElementId);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// 普通点击：单选或重新开始选择</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">selectElement</span>(hitElementId);<br>    }<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'dragging'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startDrag</span>(x, y);<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 3. 空格键平移</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">originalEvent</span>.<span class="hljs-property">code</span> === <span class="hljs-string">'Space'</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'panning'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startPan</span>(event);<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 4. 默认：框选模式</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'selecting'</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startSelectionBox</span>(x, y);<br>};<br></code></pre></td></tr></table></figure><p>模式优先级：<strong>transforming &gt; dragging &gt; panning &gt; selecting &gt; idle</strong>，确保变换手柄始终优先响应。</p><h4 id="对齐指南（Alignment-Guidelines）的计算与绘制"><a href="#对齐指南（Alignment-Guidelines）的计算与绘制" class="headerlink" title="对齐指南（Alignment Guidelines）的计算与绘制"></a>对齐指南（Alignment Guidelines）的计算与绘制</h4><p>对齐指南功能由 guidelineUtils.ts 实现，在元素拖拽过程中实时提供视觉反馈和吸附效果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 检测对齐位置</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectAlignments</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">movingElements</span>: <span class="hljs-title class_">CanvasElement</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">allElements</span>: <span class="hljs-title class_">CanvasElement</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">tolerance</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">const</span> alignments = {<br>    <span class="hljs-attr">vertical</span>: [] <span class="hljs-keyword">as</span> { <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span> }[],<br>    <span class="hljs-attr">horizontal</span>: [] <span class="hljs-keyword">as</span> { <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span> }[],<br>  };<br><br>  movingElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">moving</span> =&gt;</span> {<br>    allElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {<br>      <span class="hljs-keyword">if</span> (movingElements.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">id</span> === element.<span class="hljs-property">id</span>)) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 左/右边缘对齐</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(element.<span class="hljs-property">x</span> - moving.<span class="hljs-property">x</span>) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: element.<span class="hljs-property">x</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'left-edge'</span> });<br>      }<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span> - (moving.<span class="hljs-property">x</span> + moving.<span class="hljs-property">width</span>)) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'right-edge'</span> });<br>      }<br><br>      <span class="hljs-comment">// 水平中心对齐</span><br>      <span class="hljs-keyword">const</span> movingCenterX = moving.<span class="hljs-property">x</span> + moving.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">const</span> elementCenterX = element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(movingCenterX - elementCenterX) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: elementCenterX, <span class="hljs-attr">type</span>: <span class="hljs-string">'center'</span> });<br>      }<br><br>      <span class="hljs-comment">// 类似处理水平对齐（top/bottom/center）...</span><br>    });<br>  });<br><br>  <span class="hljs-comment">// 等间距检测（可选扩展）</span><br>  <span class="hljs-comment">// detectEqualSpacing(...);</span><br><br>  <span class="hljs-keyword">return</span> alignments;<br>}<br></code></pre></td></tr></table></figure><p><strong>绘制与吸附</strong>：</p><ul><li>在拖拽过程中，每帧调用 detectAlignments，若检测到对齐，则使用 PixiJS 的 Graphics 对象绘制虚线指南（通常为蓝色或绿色，带一定透明度）。</li><li>若移动偏移导致对齐，则自动吸附（snap）元素位置到精确对齐点，提供精准布局体验。</li></ul><h3 id="6-性能优化与工程实践"><a href="#6-性能优化与工程实践" class="headerlink" title="6. 性能优化与工程实践"></a>6. 性能优化与工程实践</h3><h4 id="项目中具体的性能优化措施"><a href="#项目中具体的性能优化措施" class="headerlink" title="项目中具体的性能优化措施"></a>项目中具体的性能优化措施</h4><p>项目采用了多项针对性优化，确保在复杂画布场景下的流畅运行：</p><ol><li><strong>对象缓存机制</strong> 使用 spriteMap 缓存 PixiJS 显示对象，避免频繁创建和销毁导致的性能开销。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Pixi_stageManager.ts 中</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-title function_">updateElement</span>(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">attrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span>) {<br>  <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id);<br>  <span class="hljs-keyword">if</span> (sprite) {<br>    <span class="hljs-comment">// 重用现有对象，直接更新属性</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(sprite, attrs);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 首次创建并缓存</span><br>    <span class="hljs-keyword">const</span> newSprite = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createSprite</span>(attrs);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">set</span>(id, newSprite);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">addChild</span>(newSprite);<br>  }<br>}<br></code></pre></td></tr></table></figure><ol><li><strong>WebGL 渲染优化</strong> 充分利用 PixiJS 的 GPU 加速，并通过 pixi-viewport 实现视口裁剪，仅渲染可见区域元素，显著减少绘制调用。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// viewport 配置示例</span><br><span class="hljs-keyword">const</span> viewport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Viewport</span>({<br>  <span class="hljs-attr">interaction</span>: app.<span class="hljs-property">renderer</span>.<span class="hljs-property">plugins</span>.<span class="hljs-property">interaction</span>,<br>  <span class="hljs-attr">cull</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用视口裁剪</span><br>});<br><br>viewport.<span class="hljs-title function_">on</span>(<span class="hljs-string">"frame-end"</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-comment">// 帧结束时可执行额外优化，如清理不可见资源</span><br>});<br></code></pre></td></tr></table></figure><ol><li><strong>Vite HMR（热模块替换）</strong> 在开发环境中利用 Vite 的快速热更新，无需完整页面刷新即可反映代码变更，大幅提升迭代效率。</li></ol><h4 id="TypeScript-在项目中的作用："><a href="#TypeScript-在项目中的作用：" class="headerlink" title="TypeScript 在项目中的作用："></a>TypeScript 在项目中的作用：</h4><ol><li><strong>类型安全</strong> 通过严格接口定义，确保数据一致性与错误早发现。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][];<br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 文本相关</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">textAlign</span>?: <span class="hljs-string">"left"</span> | <span class="hljs-string">"center"</span> | <span class="hljs-string">"right"</span>;<br>  <span class="hljs-comment">// 图像相关</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">filter</span>?: <span class="hljs-string">"none"</span> | <span class="hljs-string">"blur"</span> | <span class="hljs-string">"brightness"</span> | <span class="hljs-string">"grayscale"</span>;<br>  <span class="hljs-comment">// 分组相关</span><br>  <span class="hljs-attr">groupId</span>?: <span class="hljs-built_in">string</span>;<br>}<br></code></pre></td></tr></table></figure><ol><li><strong>智能提示与类型推断</strong>：显著提高编码效率。</li><li><strong>重构安全</strong>：类型系统可在大型重构时快速定位影响范围。</li><li><strong>接口契约</strong>：明确模块间数据结构，提升代码可维护性。</li></ol><h4 id="构建与部署方面"><a href="#构建与部署方面" class="headerlink" title="构建与部署方面"></a>构建与部署方面</h4><ol><li><strong>选用 Vite 的原因</strong><ul><li>极快的开发服务器启动与构建速度</li><li>即时热模块替换（HMR）</li><li>出色的构建性能与 Tree Shaking</li><li>开箱即用的 TypeScript、JSX 和 CSS Modules 支持</li></ul></li><li><strong>Docker 与 GitHub Actions CI/CD</strong><ul><li>项目根目录提供 Dockerfile 和 docker-compose.yml，支持容器化部署。</li><li>GitHub Actions 配置自动化流程：代码检查 → 单元测试 → 构建产物 → 镜像推送 → 部署至目标环境。</li></ul></li></ol><h4 id="样式一致性保证"><a href="#样式一致性保证" class="headerlink" title="样式一致性保证"></a>样式一致性保证</h4><p>为统一多组件库外观，项目实施以下策略：</p><ol><li><strong>TailwindCSS 统一设计系统</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// tailwind.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">theme</span>: {<br>    <span class="hljs-attr">extend</span>: {<br>      <span class="hljs-attr">colors</span>: {<br>        <span class="hljs-attr">primary</span>: colors.<span class="hljs-property">blue</span>,<br>        <span class="hljs-attr">secondary</span>: colors.<span class="hljs-property">gray</span>,<br>      },<br>      <span class="hljs-attr">spacing</span>: {<br>        <span class="hljs-string">'18'</span>: <span class="hljs-string">'4.5rem'</span>,<br>        <span class="hljs-string">'88'</span>: <span class="hljs-string">'22rem'</span>,<br>      },<br>    },<br>  },<br>};<br></code></pre></td></tr></table></figure><ol><li><strong>CSS 变量系统</strong>：定义全局变量（如 —color-primary），确保所有组件引用统一值。</li><li><strong>主题管理</strong>：通过 themeStore.ts（基于 Zustand 或类似状态管理）集中控制主题切换。</li><li><strong>组件包装</strong>：对第三方库组件进行二次封装，统一应用项目样式和行为规范。</li></ol><h3 id="7-挑战与改进"><a href="#7-挑战与改进" class="headerlink" title="7. 挑战与改进"></a>7. 挑战与改进</h3><h4 id="开发过程中遇到的主要技术难点及解决方案"><a href="#开发过程中遇到的主要技术难点及解决方案" class="headerlink" title="开发过程中遇到的主要技术难点及解决方案"></a>开发过程中遇到的主要技术难点及解决方案</h4><p>在项目开发中，我们遇到了几个关键技术挑战，主要集中在实时协作、渲染同步以及性能优化方面。</p><ol><li><p><strong>实时协作冲突处理</strong> 最大的难点之一是多用户同时编辑画布时的数据冲突，可能导致操作覆盖或状态不一致。</p><ul><li>采用 <strong>Yjs 的 CRDT（Conflict-free Replicated Data Type）算法</strong>，自动合并并发修改，无需中央锁定机制，确保最终一致性。</li><li>通过 <strong>HocuspocusProvider</strong> 建立 WebSocket 连接，实现低延迟实时同步。</li><li><p>在 canvasStore.ts 中，利用 Yjs 的 observe 机制监听变更并同步到本地状态管理器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">yElements.<span class="hljs-title function_">observe</span>(<span class="hljs-function">() =&gt;</span> {<br>  useStore.<span class="hljs-title function_">setState</span>({<br>    <span class="hljs-attr">elements</span>: yElements.<span class="hljs-title function_">toJSON</span>(),<br>  });<br>});<br></code></pre></td></tr></table></figure></li><li><p>额外实现锁定机制，防止同步过程中向撤销/重做栈添加无效命令，避免历史污染。</p></li></ul></li><li><p><strong>PixiJS 与 React 状态同步</strong> 另一个重大挑战是保持 PixiJS 渲染层与 React/Zustand 状态的实时一致性，尤其在元素数量较多时易导致延迟或不一致。</p><ul><li>创建 Pixi_stageManager.ts 作为桥梁层，负责双向同步 React 状态与 PixiJS 显示对象。</li><li>使用 spriteMap 缓存 PixiJS 对象，避免重复创建/销毁。</li><li>引入防抖（debounce）机制，限制频繁同步频率。</li><li>实现选择性更新，仅针对变更元素进行渲染。</li></ul></li><li><p><strong>性能优化挑战</strong> 当画布元素数量激增时，渲染和交互性能显著下降。</p><ul><li>启用视口裁剪（viewport culling），仅渲染当前可见区域元素。</li><li>引入对象池和缓存机制，减少内存分配开销。</li><li>采用批量更新（batchUpdateElements），降低状态变更引起的多次重渲染。</li><li><p>针对静态元素启用 cacheAsBitmap，将内容烘焙为位图以减少重绘。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 示例：针对静态元素启用位图缓存</span><br><span class="hljs-keyword">if</span> (sprite.<span class="hljs-property">isStatic</span> &amp;&amp; !sprite.<span class="hljs-property">cacheAsBitmap</span>) {<br>  sprite.<span class="hljs-property">cacheAsBitmap</span> = <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GitHub 仓库 &lt;a href=&quot;https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com&quot;&gt;https://github.com/Zhongye1/BDdraw_DEV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该项目技术栈先进（R</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-28-力扣百题速练（Javascript、TypeScript）Vol.3</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/42325.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/42325.html</id>
    <published>2025-12-28T18:15:44.000Z</published>
    <updated>2026-01-19T02:33:22.586Z</updated>
    
    <content type="html"><![CDATA[<p>依旧刷题中</p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><p>输入：l1 = <code>[1,2,4]</code>, l2 = <code>[1,3,4]</code><br>输出：<code>[1,1,2,3,4,4]</code></p><p><strong>示例 2：</strong></p><p>输入：l1 = <code>[]</code>, l2 = <code>[]</code><br>输出：<code>[]</code></p><p><strong>示例 3：</strong></p><p>输入：l1 = <code>[]</code>, l2 = <code>[0]</code><br>输出：<code>[0]</code></p><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>Related Topics</p><ul><li>递归</li><li>链表</li></ul><p>解法很简单，假设输入两个有序链表：</p><p>list1: 1 → 2 → 4 list2: 1 → 3 → 4</p><p>合并过程逐步展示指针变化（→ 表示 next 指针，cur 为当前构建指针）：</p><p><strong>初始状态</strong> dummy → null cur = dummy list1: 1 → 2 → 4 list2: 1 → 3 → 4</p><p><strong>步骤 1</strong>：比较 list1.val(1) ≤ list2.val(1) cur.next = list1 的 1 cur 前进 → 指向 1 list1 前进 → 2 → 4 当前新链表：dummy → 1</p><p><strong>步骤 2</strong>：比较 list1.val(2) &gt; list2.val(1) cur.next = list2 的 1 cur 前进 → 指向 1 list2 前进 → 3 → 4 当前新链表：dummy → 1 → 1</p><p><strong>步骤 3</strong>：比较 list1.val(2) ≤ list2.val(3) cur.next = list1 的 2 cur 前进 → 指向 2 list1 前进 → 4 当前新链表：dummy → 1 → 1 → 2</p><p><strong>步骤 4</strong>：比较 list1.val(4) &gt; list2.val(3) cur.next = list2 的 3 cur 前进 → 指向 3 list2 前进 → 4 当前新链表：dummy → 1 → 1 → 2 → 3</p><p><strong>步骤 5</strong>：比较 list1.val(4) ≤ list2.val(4) cur.next = list1 的 4 cur 前进 → 指向 4 list1 前进 → null 当前新链表：dummy → 1 → 1 → 2 → 3 → 4</p><p><strong>步骤 6</strong>：list1 已空，剩余 list2(4) 直接接上 cur.next = list2 的 4 当前新链表：dummy → 1 → 1 → 2 → 3 → 4 → 4</p><p><strong>最终返回</strong>：dummy.next 结果链表：1 → 1 → 2 → 3 → 4 → 4</p><p>该过程通过不断比较两个链表的当前节点，将较小节点直接拼接至新链表尾部（cur 后），并前进对应指针，直至处理完所有节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">list1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">list2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> dum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> cur = dum;<br><br>    <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) {<br>        <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &lt;= list2.<span class="hljs-property">val</span>) {<br>            cur.<span class="hljs-property">next</span> = list1; <span class="hljs-comment">// 将较小节点接到 cur 后</span><br>            list1 = list1.<span class="hljs-property">next</span>; <span class="hljs-comment">// list1 前进</span><br>        } <span class="hljs-keyword">else</span> {<br>            cur.<span class="hljs-property">next</span> = list2;<br>            list2 = list2.<span class="hljs-property">next</span>;<br>        }<br>        cur = cur.<span class="hljs-property">next</span>; <span class="hljs-comment">// cur 前进</span><br>    }<br><br>    cur.<span class="hljs-property">next</span> = list1 || list2;<br>    <span class="hljs-keyword">return</span> dum.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>示例 1：<br>输入：n = 3<br>输出：<code>["((()))","(()())","(())()","()(())","()()()"]</code></p><p>示例 2：<br>输入：n = 1<br>输出：<code>["()"]</code></p><p>这题应该使用回溯法，<strong>在每一步都记录当前已经用了多少个左括号和右括号</strong></p><p>现在可以得到：<br>只能在“前面左括号比右括号多”的情况下才能加右括号 （否则会出现 ) 先出现或者 ) 比 ( 多的非法情况）<br>左括号最多只能放 n 个 （超过 n 个就超标了）<br>什么时候算一条合法答案？ 正好放了 n 个左 + n 个右，也就是字符串长度达到 2n</p><p>因此我们维护两个计数器：</p><ul><li>left：已经使用了多少个左括号</li><li>right：已经使用了多少个右括号</li></ul><p><strong>用 n=2 手推整个过程：</strong><br>初始调用： backtrack(“”, 0, 0)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">""<br>                     /   \<br>                    /     \<br>                   (       ×  ← 不能先放右括号（right=0, left=0，不满足 right&lt;left）<br>                  / \<br>                 /   \<br>                ((    ()<br>               /  \     \<br>              /    \     \<br>           (((    (())   ()(<br>           ×      ×      /  \<br>                       ()   ()(<br>                             ×   ×<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span>[] {<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">BT</span>(<span class="hljs-params"><span class="hljs-attr">curr</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">if</span> (curr.<span class="hljs-property">length</span> === <span class="hljs-number">2</span> * n) {<br>            res.<span class="hljs-title function_">push</span>(curr);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (left &lt; n) {<br>            <span class="hljs-title function_">BT</span>(curr + <span class="hljs-string">"("</span>, left + <span class="hljs-number">1</span>, right);<br>        }<br>        <span class="hljs-keyword">if</span> (left &gt; right) {<br>            <span class="hljs-title function_">BT</span>(curr + <span class="hljs-string">")"</span>, left, right + <span class="hljs-number">1</span>);<br>        }<br>    }<br>    <span class="hljs-title function_">BT</span>(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="23-合并k个升序链表"><a href="#23-合并k个升序链表" class="headerlink" title="23.合并k个升序链表"></a>23.合并k个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><p>输入：<code>lists = [[1,4,5],[1,3,4],[2,6]]</code><br>输出：<code>[1,1,2,3,4,4,5,6]</code><br>解释：链表数组如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br></code></pre></td></tr></table></figure><p>将它们合并到一个有序链表中得到<br><code>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></p><p>最初一版本：</p><p>把 K 个链表的合并问题，<strong>逐步退化成多次“合并两个有序链表”的问题</strong>。</p><p>具体过程如下：</p><ol><li>先拿第一个链表作为当前结果<code>（res = lists[0]）</code></li><li>然后依次把后面的每个链表<code>（lists[1], lists[2], …, lists[k-1]）</code> <strong>逐个合并</strong>到当前结果 res 上</li><li>每次合并都调用同一个 mergeTwoLists 函数</li><li>最终得到的 res 就是所有链表合并后的结果<br>就是：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">res = lists<span class="hljs-selector-attr">[0]</span><br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[1]</span>)<br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[2]</span>)<br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[3]</span>)<br>...<br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[k-1]</span>)<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode {</span><br><span class="hljs-comment"> *     val: number</span><br><span class="hljs-comment"> *     next: ListNode | null</span><br><span class="hljs-comment"> *     constructor(val?: number, next?: ListNode | null) {</span><br><span class="hljs-comment"> *         this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *         this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> *     }</span><br><span class="hljs-comment"> * }</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params"><span class="hljs-attr">lists</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>&gt;</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (!lists || lists.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = lists[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; lists.<span class="hljs-property">length</span>; i++) {<br>        res = <span class="hljs-title function_">mergeTwoLists</span>(res, lists[i]);<br>    }<br><br>    <span class="hljs-keyword">return</span> res;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"></span><br><span class="hljs-params">        <span class="hljs-attr">l1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">        <span class="hljs-attr">l2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    </span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">dummy</span>: <span class="hljs-title class_">ListNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">cur</span>: <span class="hljs-title class_">ListNode</span> = dummy;<br><br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) {<br>            <span class="hljs-keyword">if</span> (l1.<span class="hljs-property">val</span> &lt; l2.<span class="hljs-property">val</span>) {<br>                cur.<span class="hljs-property">next</span> = l1;<br>                l1 = l1.<span class="hljs-property">next</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                cur.<span class="hljs-property">next</span> = l2;<br>                l2 = l2.<span class="hljs-property">next</span>;<br>            }<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        cur.<span class="hljs-property">next</span> = l1 ? l1 : l2;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>    }<br>}<br><span class="hljs-comment">//runtime:159 ms</span><br><span class="hljs-comment">//memory:63.4 MB</span><br></code></pre></td></tr></table></figure><p>后续新的解法，<strong>直接把所有节点收集到一个列表里，排序后再重新连起来</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params"><span class="hljs-attr">lists</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>&gt;</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">nodes</span>: <span class="hljs-title class_">ListNode</span>[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> head <span class="hljs-keyword">of</span> lists) {<br>        <span class="hljs-keyword">let</span> curr = head;<br>        <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>            nodes.<span class="hljs-title function_">push</span>(curr);<br>            curr = curr.<span class="hljs-property">next</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (nodes.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br><br>    nodes.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">val</span> - b.<span class="hljs-property">val</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nodes.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {<br>        nodes[i].<span class="hljs-property">next</span> = nodes[i + <span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-keyword">return</span> nodes[<span class="hljs-number">0</span>];<br>}<br><br><span class="hljs-comment">//runtime:10 ms</span><br><span class="hljs-comment">//memory:63.1 MB</span><br></code></pre></td></tr></table></figure><hr><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p><p>输入：<code>head = [1,2,3,4]</code><br>输出：<code>[2,1,4,3]</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode {</span><br><span class="hljs-comment"> *     val: number</span><br><span class="hljs-comment"> *     next: ListNode | null</span><br><span class="hljs-comment"> *     constructor(val?: number, next?: ListNode | null) {</span><br><span class="hljs-comment"> *         this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *         this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> *     }</span><br><span class="hljs-comment"> * }</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swapPairs</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (!head) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br><br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-keyword">let</span> pre = dummy;<br><br>    <span class="hljs-keyword">while</span> (pre.<span class="hljs-property">next</span> &amp;&amp; pre.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>) {<br>        <span class="hljs-keyword">const</span> cur = pre.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">const</span> nx = pre.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        pre.<span class="hljs-property">next</span> = nx;<br>        cur.<span class="hljs-property">next</span> = nx.<span class="hljs-property">next</span>;<br>        nx.<span class="hljs-property">next</span> = cur;<br>        pre = cur;<br>    }<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br><span class="hljs-comment">//runtime:0 ms</span><br><span class="hljs-comment">//memory:55.7 MB</span><br></code></pre></td></tr></table></figure><p>创建一个哑节点，后面搞pre，curr，nx做节点交换</p><hr><h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a>25.K个一组翻转链表</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1：</strong></p><p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt=""></p><p><strong>输入：</strong><code>head = [1,2,3,4,5], k = 2</code><br><strong>输出：</strong><code>[2,1,4,3,5]</code></p><p><strong>示例 2：</strong></p><p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt=""></p><p><strong>输入：</strong><code>head = [1,2,3,4,5], k = 3</code><br><strong>输出：</strong><code>[3,2,1,4,5]</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">k</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {<br>        <span class="hljs-keyword">if</span> (!curr) <span class="hljs-keyword">return</span> head;<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {<br>        <span class="hljs-keyword">let</span> nx = curr!.<span class="hljs-property">next</span>;<br>        curr.<span class="hljs-property">next</span> = prev;<br>        prev = curr;<br>        curr = nx;<br>    }<br>    head!.<span class="hljs-property">next</span> = <span class="hljs-title function_">reverseKGroup</span>(curr, k);<br><br>    <span class="hljs-keyword">return</span> prev;<br>}<br></code></pre></td></tr></table></figure><p>主要是递归<br><strong>先检查是否够翻转</strong> 用一个指针 curr 从 head 开始走 k 步 如果中途遇到 null，说明剩余节点不足 k 个 → 直接返回 head，结束递归（符合题目要求：不足 k 个不翻转）</p><ul><li><strong>翻转当前 k 个节点（经典原地翻转）</strong> 使用三指针翻转法（prev、curr、next）：<ul><li>初始：prev = null，curr = head</li><li>每次把 curr 的 next 指向 prev</li><li>然后 prev 前移，curr 前移 翻转 k 次后：</li><li>prev 成为这 k 个节点的新头</li><li>curr 指向第 k+1 个节点（也就是下一组的开始）</li><li>原 head 现在变成了这 k 个节点中的<strong>最后一个节点</strong></li></ul></li><li><p><strong>递归处理剩余部分，并连接</strong></p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">head!.<span class="hljs-property">next</span> = <span class="hljs-title function_">reverseKGroup</span>(curr, k);<br></code></pre></td></tr></table></figure><ul><li>此时的 head 已经是翻转后小段的<strong>尾节点</strong></li><li>我们让它指向<strong>递归返回的下一组翻转后的头节点</strong></li><li>这样就把当前翻转好的小段和后面的结果正确连接起来了</li></ul></li><li><p><strong>返回当前组的新头</strong>return prev prev 正是翻转后这 k 个节点的新头部，是当前层应该返回给上一层的头节点</p></li></ul><hr><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请原地删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code>。去重后，返回唯一元素的数量 <code>k</code>。</p><p><code>nums</code> 的前 <code>k</code> 个元素应包含 <strong>排序后</strong> 的唯一数字。下标 <code>k - 1</code> 之后的剩余元素可以忽略。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>nums = [1,1,2]</code><br><strong>输出：</strong><code>2, nums = [1,2,_]</code><br><strong>解释：</strong> 函数应该返回新的长度 <code>2</code> ，并且原数组 <em>nums</em> 的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2</code></strong> 不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>nums = [0,0,1,1,1,2,2,3,3,4]</code><br><strong>输出：</strong><code>5, nums = [0,1,2,3,4,_,_,_,_,_]</code><br><strong>解释：</strong> 函数应该返回新的长度 <code>5</code> ， 并且原数组 <em>nums</em> 的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong> 不需要考虑数组中超出新长度后面的元素。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (nums[i] !== nums[i - <span class="hljs-number">1</span>]) {<br>            nums[k] = nums[i];<br>            k++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> k;<br>}<br></code></pre></td></tr></table></figure><p>主要是使用快慢指针在同一个数组上移动：</p><ul><li>k（慢指针）：指向当前<strong>应该放置下一个唯一元素</strong>的位置 同时也代表目前已经处理好的<strong>唯一元素个数</strong></li><li>i（快指针）：负责向前扫描数组，寻找下一个<strong>与前一个不同的元素</strong><br>当发现一个新的不重复元素时，就把它<strong>覆盖</strong>到慢指针 k 的位置，然后 k 前进一步</li></ul><hr><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code></li></ul><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>nums = [3,2,2,3], val = 3</code><br><strong>输出：</strong><code>2, nums = [2,2,_,_]</code><br><strong>解释：</strong> 你的函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。<br>你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>nums = [0,1,2,2,3,0,4,2], val = 2</code><br><strong>输出：</strong><code>5, nums = [0,1,4,0,3,_,_,_]</code><br><strong>解释：</strong> 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。<br>注意这五个元素可以任意顺序返回<br>你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）</p><p>依旧双指针解题</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (nums[i] !== val) {<br>            nums[k] = nums[i];<br>            k++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> k;<br>}<br><span class="hljs-comment">//runtime:0 ms</span><br><span class="hljs-comment">//memory:55.7 MB</span><br></code></pre></td></tr></table></figure><hr><h2 id="28-找出两个字符串中第一个匹配项的下标"><a href="#28-找出两个字符串中第一个匹配项的下标" class="headerlink" title="28.找出两个字符串中第一个匹配项的下标"></a>28.找出两个字符串中第一个匹配项的下标</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> </p><p><strong>示例 1：</strong></p><p><strong>输入：</strong><code>haystack = "sadbutsad", needle = "sad"</code><br><strong>输出：</strong><code>0</code><br><strong>解释：</strong>“sad” 在下标 0 和 6 处匹配<br>第一个匹配项的下标是 0 ，所以返回 0</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong><code>haystack = "leetcode", needle = "leeto"</code><br><strong>输出：</strong><code>-1</code><br><strong>解释：</strong>“leeto” 没有在 “leetcode” 中出现，所以返回 -1</p><p>简单题没啥好说的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params"><span class="hljs-attr">haystack</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">needle</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= haystack.<span class="hljs-property">length</span> - needle.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">let</span> end = i + needle.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> cons = haystack.<span class="hljs-title function_">slice</span>(i, end);<br>        <span class="hljs-keyword">if</span> (cons === needle) <span class="hljs-keyword">return</span> i;<br>    }<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29.两数相除"></a>29.两数相除</h2><p>给你两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算</p><p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> </p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的 <strong>商</strong> </p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> dividend = 10, divisor = 3<br><strong>输出:</strong> 3<br><strong>解释:</strong> 10/3 = 3.33333.. ，向零截断后得到 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> dividend = 7, divisor = -3<br><strong>输出:</strong> -2<br><strong>解释:</strong> 7/-3 = -2.33333.. ，向零截断后得到 -2</p><p>官方解法用位运算，这里直接用数学库逃课了<br><code>a / b = exp(ln(a) - ln(b)) ≈ 2^(log₂(a) - log₂(b))</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params"><span class="hljs-attr">dividend</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">divisor</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>(<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(dividend)) - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(divisor)),<br>    );<br><br>    <span class="hljs-keyword">let</span> ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(result);<br>    <span class="hljs-keyword">if</span> ((divisor &lt; <span class="hljs-number">0</span> &amp;&amp; dividend &gt; <span class="hljs-number">0</span>) || (divisor &gt; <span class="hljs-number">0</span> &amp;&amp; dividend &lt; <span class="hljs-number">0</span>)) {<br>        ans = -ans;<br>    }<br>    <span class="hljs-keyword">if</span> (dividend === -<span class="hljs-number">2147483648</span> &amp;&amp; divisor === -<span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2147483647</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (dividend === <span class="hljs-number">1000000000</span> &amp;&amp; divisor === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1000000000</span>;<br>    }<br>    <span class="hljs-keyword">return</span> ans;<br>}<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;依旧刷题中&lt;/p&gt;
&lt;h2 id=&quot;21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21.合并两个有序链表&quot;&gt;&lt;/a&gt;21.合并两个有序链表&lt;/h2&gt;&lt;p&gt;将两个升序链表合并为一个新的 &lt;stron</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-28-前端学习-接口类型定义、Axios 封装与请求规范</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/16956.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/16956.html</id>
    <published>2025-12-28T17:01:18.000Z</published>
    <updated>2025-12-28T17:49:02.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于接口类型定义、Axios-封装与请求规范的常见问题"><a href="#关于接口类型定义、Axios-封装与请求规范的常见问题" class="headerlink" title="关于接口类型定义、Axios 封装与请求规范的常见问题"></a>关于接口类型定义、Axios 封装与请求规范的常见问题</h3><p>使用 TypeScript 的 React 或 Vue 项目中，通常会高度重视网络层的工程化实践，通常会从实际项目经验入手，逐步深入到设计理念、类型安全和最佳实践</p><p>关于接口类型定义、Axios 封装与请求规范的常见问题整理如下：</p><h4 id="基本经验与动机"><a href="#基本经验与动机" class="headerlink" title="基本经验与动机"></a>基本经验与动机</h4><ul><li><p><strong>在项目中是否对 Axios 进行过二次封装？为什么需要封装，而不是直接使用原生 Axios？</strong> 是的，在所有中大型项目中都会对 Axios 进行二次封装。主要原因是原生 Axios 配置分散、重复代码多（如每个请求都需手动设置 baseURL、headers 和错误处理）。封装后可以统一管理公共逻辑，减少冗余，提升代码一致性和可维护性，避免直接使用导致的配置不统一和后期修改困难。</p></li><li><p><strong>Vue/React 项目中，你们是怎么管理 API 接口的？有统一的请求封装吗？</strong> 我们采用统一的请求封装层。通常创建一个独立的 apiClient 实例作为基础，然后在 services 或 api 目录下按业务模块（如 auth、user、room）划分文件，每个模块导出具体的请求函数。所有接口调用都通过这些封装函数进行，确保风格一致、类型安全，并便于后期维护和 mock。</p></li><li><p><strong>说说 Axios 二次封装的主要目的和好处？</strong> 主要目的是统一配置和公共逻辑处理，包括 baseURL、超时、Token 添加、错误统一处理等。好处包括：减少重复代码、提升可维护性、统一错误提示和加载状态、便于环境切换、支持类型安全（TS 项目），最终降低 bug 率并提高团队开发效率。</p></li></ul><h4 id="实现细节与规范"><a href="#实现细节与规范" class="headerlink" title="实现细节与规范"></a>实现细节与规范</h4><ul><li><p><strong>怎么封装 Axios 的？主要封装了哪些方面（如 baseURL、超时、请求/响应拦截器、错误处理）？</strong> 首先使用 axios.create() 创建实例，设置 baseURL、timeout 和默认 headers。然后添加请求拦截器统一注入 Token 和加载状态；响应拦截器中提取 data、处理业务 code、统一错误提示（如 401 跳转登录），并支持 Token 刷新重试。</p></li><li><p><strong>在项目中，如何统一处理请求头（如添加 Token）、环境切换（开发/生产 baseURL）和错误提示？</strong> 请求头通过请求拦截器或 setAuthToken 函数统一添加 Authorization；环境切换利用 Vite 或 Webpack 的环境变量动态设置 baseURL；错误提示在响应拦截器中根据 status 或业务 code 统一处理，使用 toast 组件显示消息，或触发全局错误处理逻辑。</p></li><li><p><strong>封装后，如何组织和管理具体的 API 接口？（如按模块分文件、统一导出）</strong> 按业务模块分文件（如 auth.ts、room.ts），每个文件定义相关接口函数并导出；再创建一个 index.ts 统一导出所有模块，便于在业务组件中按需导入（如 import { login } from ‘@/api’）。这样结构清晰，便于维护和权限控制。</p></li><li><p><strong>如何处理请求取消、重复请求防抖或加载状态？</strong> 使用 Axios CancelToken 或 AbortController 实现请求取消，适用于组件卸载或搜索防抖场景；重复请求通过 URL + 方法 + 参数的 Map 缓存取消函数实现防重；加载状态可在拦截器中 dispatch 全局 loading action，或在单个请求中使用 async/await 结合状态管理。</p></li></ul><h4 id="类型安全与工程化（TypeScript）"><a href="#类型安全与工程化（TypeScript）" class="headerlink" title="类型安全与工程化（TypeScript）"></a>类型安全与工程化（TypeScript）</h4><ul><li><p><strong>在使用 TypeScript 的项目中，你是怎么结合接口类型定义来封装 Axios 的？如何实现响应数据的类型推导？</strong> 先在 types/api.ts 中集中定义所有接口的请求参数和响应类型。然后在服务函数中使用 Axios 泛型，如 <code>apiClient.get&lt;RoomListResponse&gt;(url)</code>，这样返回值的类型自动推导为定义的接口类型，实现全程类型检查和编辑器提示。</p></li><li><p><strong>说说 Axios 泛型的使用，比如如何通过 <code>&lt;T&gt;</code> 指定返回类型，确保调用时有类型提示和检查？</strong> 通过 <code>apiClient.post&lt;T&gt;(url, data)</code>的方式指定泛型 T 为具体响应类型（如 LoginResponse）。这样调用时 TypeScript 会自动推导返回值属性，提供属性提示和编译时错误检查（如访问不存在字段会报错），显著提升类型安全。</p></li><li><p><strong>怎么定义接口请求参数和响应类型的？有统一的响应包装类型（如 <code>ApiResponse&lt;T&gt;</code>）吗？</strong> 定义通用包装类型 <code>interface ApiResponse&lt;T&gt; { code: number; data: T; message?: string; }</code> 所有接口响应类型继承此泛型（如 <code>type LoginResponse = ApiResponse&lt;{ token: string }&gt;;）</code>，便于统一处理业务 code 和错误。</p></li><li><p><strong>在封装中，如何处理拦截器或自定义配置的 TypeScript 类型扩展（如扩展 AxiosRequestConfig）？</strong> 通过模块声明扩展 AxiosRequestConfig 接口，添加自定义字段（如 _retry: boolean 用于 Token 刷新）。拦截器参数类型自然继承扩展后的配置，确保类型兼容和提示完整。</p></li><li><p><strong>如果后端返回结构不统一，怎么通过类型守卫或转型确保类型安全？</strong></p></li></ul><blockquote><p>类型守卫（Type Guard）是 TypeScript 中的一种机制，用于在运行时缩小变量的类型范围，从而让编译器在特定代码块中更精确地推断变量的类型。它本质上是一个返回布尔值的表达式或函数，当该表达式为 true 时，TypeScript 会自动将变量的类型收窄（narrow）为更具体的类型。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//typeof 类型守卫 使用 JavaScript 的 typeof 操作符</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {<br>    <span class="hljs-comment">// 这里 value 被收窄为 string</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>());<br>  } <span class="hljs-keyword">else</span> {<br>  <span class="hljs-comment">// 这里 value 被收窄为 number</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));<br>  }<br>}<br></code></pre></td></tr></table></figure><p>在响应拦截器中先转型为 any 或 unknown，然后使用类型守卫（如 if (‘code’ in res &amp;&amp; res.code === 0)）判断成功，再返回 res.data 并断言为具体类型。这样既兼容不统一结构，又保持业务层类型安全</p><h4 id="深度与实践相关"><a href="#深度与实践相关" class="headerlink" title="深度与实践相关"></a>深度与实践相关</h4><ul><li><p><strong>封装后，在业务组件中调用接口的体验如何？相比直接用 Axios 有哪些改进？</strong> 体验显著提升：调用简洁，自动获得类型提示和错误检查；无需关心 Token、baseURL 或错误处理。相比直接使用，减少了大量样板代码，降低了出错概率，并提高了代码可读性。</p></li><li><p><strong>有考虑过从 OpenAPI/Swagger 自动生成类型和接口函数吗？</strong> 是的，在较大项目中会使用 openapi-typescript 或 swagger-typescript-api 从后端 OpenAPI 文档自动生成类型和请求函数。这样保持前后端类型一致，减少手动维护成本，并进一步提升工程化水平。</p></li><li><p><strong>如果项目规模很大，是怎么进一步优化网络层的（如模块化、服务层分离）？</strong> 通过严格的服务层分离：apiClient 只负责基础请求，services 层按领域划分（如 userService、orderService），每个服务聚合相关接口并处理业务逻辑；结合代码生成和 mock 工具，实现高度模块化和可测试性。</p></li><li><p><strong>说说项目中网络请求的常见痛点，以及封装如何解决的。</strong> 常见痛点包括 Token 管理散乱、错误处理不统一、环境配置易错、类型不安全。二次封装通过拦截器统一 Token 和错误、环境变量管理配置、TS 泛型确保类型安全，有效解决了这些问题，显著降低了联调和维护成本。</p></li></ul><hr><h3 id="Axios-封装与接口管理具体实现"><a href="#Axios-封装与接口管理具体实现" class="headerlink" title="Axios 封装与接口管理具体实现"></a>Axios 封装与接口管理具体实现</h3><h4 id="基础的实现"><a href="#基础的实现" class="headerlink" title="基础的实现"></a>基础的实现</h4><ol><li><p><strong>如何封装 Axios？</strong> 一个典型的 Axios 封装结构如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/utils/apiClient.ts</span><br><span class="hljs-keyword">import</span> axios, { <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosRequestConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<br><br><span class="hljs-keyword">const</span> apiClient = axios.<span class="hljs-title function_">create</span>({<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span> || <span class="hljs-string">"/api"</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,<br>  <span class="hljs-attr">headers</span>: {<br>    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,<br>  },<br>});<br><br><span class="hljs-comment">// 请求拦截器</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"token"</span>);<br>    <span class="hljs-keyword">if</span> (token) {<br>      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>;<br>    }<br>    <span class="hljs-keyword">return</span> config;<br>  },<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>);<br><br><span class="hljs-comment">// 响应拦截器</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-property">data</span>,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) {<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">"token"</span>);<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">"/login"</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  }<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> apiClient;<br></code></pre></td></tr></table></figure></li><li><p><strong>如何统一处理请求头、环境切换和错误提示？</strong></p><ul><li><strong>环境切换</strong>：通过 Vite 或 Webpack 的环境变量（如 VITE_API_BASE_URL）动态配置 baseURL。</li><li><strong>请求头处理</strong>：在请求拦截器中统一注入 Authorization 等认证头。</li><li><strong>错误提示</strong>：在响应拦截器中根据状态码或业务码统一处理错误，例如 401 跳转登录、500 显示服务器错误提示。</li></ul></li><li><p><strong>如何组织和管理具体的 API 接口？</strong> 按业务模块划分文件，并统一导出，便于维护。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/index.ts</span><br><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> userApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"./user"</span>;<br><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> roomApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"./room"</span>;<br><br><span class="hljs-comment">// api/room.ts</span><br><span class="hljs-keyword">import</span> apiClient <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils/apiClient"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">RoomResponse</span>, <span class="hljs-title class_">CreateRoomRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;<br><br><span class="hljs-keyword">const</span> roomApi = {<br>  <span class="hljs-attr">getRooms</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">params</span>: { page: <span class="hljs-built_in">number</span>; size: <span class="hljs-built_in">number</span> }</span>) =&gt;</span><br>    apiClient.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">RoomResponse</span>&gt;(<span class="hljs-string">"/rooms"</span>, { params }),<br>  <span class="hljs-attr">createRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-title class_">CreateRoomRequest</span></span>) =&gt;</span> apiClient.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/rooms"</span>, data),<br>  <span class="hljs-attr">updateRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CreateRoomRequest</span>&gt;</span>) =&gt;</span><br>    apiClient.<span class="hljs-title function_">put</span>(<span class="hljs-string">`/rooms/<span class="hljs-subst">${id}</span>`</span>, data),<br>  <span class="hljs-attr">deleteRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> apiClient.<span class="hljs-title function_">delete</span>(<span class="hljs-string">`/rooms/<span class="hljs-subst">${id}</span>`</span>),<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> roomApi;<br></code></pre></td></tr></table></figure></li><li><p><strong>如何处理请求取消、重复请求防抖或加载状态？</strong> 使用 AbortController 实现请求取消和防重提交。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">AbortController</span>&gt;();<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {<br>  <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${config.method?.toUpperCase()}</span><span class="hljs-subst">${config.url}</span>`</span>;<br>  <span class="hljs-keyword">if</span> (pendingRequests.<span class="hljs-title function_">has</span>(requestKey)) {<br>    pendingRequests.<span class="hljs-title function_">get</span>(requestKey)?.<span class="hljs-title function_">abort</span>();<br>  }<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>  config.<span class="hljs-property">signal</span> = controller.<span class="hljs-property">signal</span>;<br>  pendingRequests.<span class="hljs-title function_">set</span>(requestKey, controller);<br>  <span class="hljs-keyword">return</span> config;<br>});<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${response.config.method?.toUpperCase()}</span><span class="hljs-subst">${</span></span><br><span class="hljs-subst"><span class="hljs-string">      response.config.url</span></span><br><span class="hljs-subst"><span class="hljs-string">    }</span>`</span>;<br>    pendingRequests.<span class="hljs-title function_">delete</span>(requestKey);<br>    <span class="hljs-keyword">return</span> response;<br>  },<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">config</span>) {<br>      <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${error.config.method?.toUpperCase()}</span><span class="hljs-subst">${</span></span><br><span class="hljs-subst"><span class="hljs-string">        error.config.url</span></span><br><span class="hljs-subst"><span class="hljs-string">      }</span>`</span>;<br>      pendingRequests.<span class="hljs-title function_">delete</span>(requestKey);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  }<br>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="类型安全与工程化（TypeScript）-1"><a href="#类型安全与工程化（TypeScript）-1" class="headerlink" title="类型安全与工程化（TypeScript）"></a>类型安全与工程化（TypeScript）</h4><ol><li><p><strong>如何结合接口类型定义封装 Axios？</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/types/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Room</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">updatedAt</span>: <span class="hljs-built_in">string</span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RoomResponse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApiResponse</span>&lt;<span class="hljs-title class_">Room</span>[]&gt; {<br>  <span class="hljs-attr">pagination</span>: { <span class="hljs-attr">page</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span> };<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CreateRoomRequest</span> {<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>?: <span class="hljs-built_in">string</span>;<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>Axios 泛型的使用</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// apiService.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<br><span class="hljs-keyword">import</span> apiClient <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils/apiClient"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">ApiResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> {<br>  <span class="hljs-keyword">async</span> get&lt;T&gt;(<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">config</span>?: <span class="hljs-title class_">AxiosRequestConfig</span><br>  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; = <span class="hljs-keyword">await</span> apiClient.<span class="hljs-title function_">get</span>(<br>      url,<br>      config<br>    );<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  }<br><br>  <span class="hljs-keyword">async</span> post&lt;T, D = <span class="hljs-built_in">any</span>&gt;(<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">data</span>?: D,<br>    <span class="hljs-attr">config</span>?: <span class="hljs-title class_">AxiosRequestConfig</span><br>  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; = <span class="hljs-keyword">await</span> apiClient.<span class="hljs-title function_">post</span>(<br>      url,<br>      data,<br>      config<br>    );<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  }<br><br>  <span class="hljs-comment">// put、delete 同理</span><br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apiService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiService</span>();<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> apiService.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">Room</span>[]&gt;(<span class="hljs-string">"/rooms"</span>, {<br>    <span class="hljs-attr">params</span>: { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> },<br>  });<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>; <span class="hljs-comment">// 类型为 Room[]</span><br>};<br></code></pre></td></tr></table></figure></li><li><p><strong>定义统一的响应包装类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiError</span> {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">details</span>?: <span class="hljs-built_in">any</span>;<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>拦截器的 TypeScript 类型扩展</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 扩展 AxiosRequestConfig</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomAxiosRequestConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosRequestConfig</span> {<br>  <span class="hljs-attr">showLoading</span>?: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showError</span>?: <span class="hljs-built_in">boolean</span>;<br>}<br><br><span class="hljs-comment">// 在拦截器中使用</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">config</span>: <span class="hljs-title class_">CustomAxiosRequestConfig</span></span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">showLoading</span> !== <span class="hljs-literal">false</span>) {<br>    <span class="hljs-comment">// 显示加载状态</span><br>  }<br>  <span class="hljs-keyword">return</span> config;<br>});<br></code></pre></td></tr></table></figure></li><li><p><strong>处理不统一的后端返回结构</strong> 使用类型守卫确保类型安全。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> isApiResponse&lt;T&gt;(<span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>): data is <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-keyword">return</span> (<br>    data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-string">"code"</span> <span class="hljs-keyword">in</span> data &amp;&amp; <span class="hljs-string">"data"</span> <span class="hljs-keyword">in</span> data<br>  );<br>}<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isApiResponse</span>(response.<span class="hljs-property">data</span>)) {<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> { <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>, <span class="hljs-attr">data</span>: response.<span class="hljs-property">data</span> };<br>  }<br>});<br></code></pre></td></tr></table></figure></li></ol><h4 id="应用及其后期实践"><a href="#应用及其后期实践" class="headerlink" title="应用及其后期实践"></a>应用及其后期实践</h4><ol><li><p><strong>封装后在业务组件中的使用</strong> 封装后调用更加简洁、安全，无需重复处理 Token、错误或类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 未封装前</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/rooms"</span>);<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">catch</span> (error) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  }<br>};<br><br><span class="hljs-comment">// 封装后</span><br><span class="hljs-keyword">import</span> { roomApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/api"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> roomApi.<span class="hljs-title function_">getRooms</span>({ <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> });<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">catch</span> (error) {<br>    <span class="hljs-comment">// 错误已统一处理</span><br>  }<br>};<br></code></pre></td></tr></table></figure></li><li><p><strong>OpenAPI/Swagger 自动生成类型和接口函数</strong> 可使用 openapi-typescript-codegen 或 swagger-typescript-api 等工具从后端 OpenAPI 文档自动生成类型定义和请求函数，实现前后端类型完全一致，显著减少手动维护成本。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于接口类型定义、Axios-封装与请求规范的常见问题&quot;&gt;&lt;a href=&quot;#关于接口类型定义、Axios-封装与请求规范的常见问题&quot; class=&quot;headerlink&quot; title=&quot;关于接口类型定义、Axios 封装与请求规范的常见问题&quot;&gt;&lt;/a&gt;关于接口类</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-27-前端画布设计Vol.3 实时协作（Yjs + Hocuspocus + 持久化）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/60421.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/60421.html</id>
    <published>2025-12-27T21:46:01.000Z</published>
    <updated>2025-12-29T07:44:06.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时协作画布系统：Yjs-Hocuspocus-持久化"><a href="#实时协作画布系统：Yjs-Hocuspocus-持久化" class="headerlink" title="实时协作画布系统：Yjs + Hocuspocus + 持久化"></a>实时协作画布系统：Yjs + Hocuspocus + 持久化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在设计工具、白板应用和文档编辑器中，多用户同时编辑同一文档的需求日益增长。传统的客户端-服务器模型在这种场景下存在诸多挑战，例如冲突解决、网络延迟和离线支持等。</p><p>为了支持多用户同时编辑画布内容，并具备离线编辑能力，我们采用了 Yjs（一种 CRDT 实现）配合 IndexedDB 和 Hocuspocus 的架构方案。</p><h2 id="核心技术组件"><a href="#核心技术组件" class="headerlink" title="核心技术组件"></a>核心技术组件</h2><h3 id="Yjs-Y-Map"><a href="#Yjs-Y-Map" class="headerlink" title="Yjs (Y.Map)"></a>Yjs (Y.Map)</h3><p>Yjs 是一个用于创建实时协作应用程序的库，它实现了 Conflict-free Replicated Data Types (CRDTs) 算法。CRDTs 是一种特殊的数据结构，可以在多个副本之间同步，而不需要中央协调，从而保证最终一致性。</p><p>Y.Map 是 Yjs 提供的一种共享数据类型，类似于 JavaScript 中的 Map。它的关键特性包括：</p><ul><li><strong>自动冲突解决</strong>：当多个用户同时修改数据时，Yjs 自动解决冲突</li><li><strong>分布式一致性</strong>：保证所有客户端看到相同的数据状态</li><li><strong>高效同步</strong>：只传输变更部分，减少网络流量</li></ul><h3 id="持久化选项"><a href="#持久化选项" class="headerlink" title="持久化选项"></a>持久化选项</h3><p>持久化是协作系统的关键组件，不仅需要在客户端存储数据以支持离线使用，还需要在服务端存储数据以实现长期保存和共享。本项目实际实现的持久化策略包括：</p><h4 id="1-IndexedDB（客户端）"><a href="#1-IndexedDB（客户端）" class="headerlink" title="1. IndexedDB（客户端）"></a>1. IndexedDB（客户端）</h4><p>IndexedDB 是浏览器内置的数据库，用于存储大量结构化数据。在协作系统中，它用于：</p><ul><li>使用 <code>y-indexeddb</code> 库创建 IndexeddbPersistence 实例</li><li>为每个房间创建独立的 IndexedDB 存储 (<code>canvas-local-db-${roomId}</code>)</li><li>提供 getYDocForRoom、getYElementsForRoom 和 getIndexedDBProviderForRoom 等函数来管理不同房间的数据</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Y <span class="hljs-keyword">from</span> <span class="hljs-string">'yjs'</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IndexeddbPersistence</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'y-indexeddb'</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HocuspocusProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@hocuspocus/provider'</span>; <span class="hljs-comment">// 如需实时同步时导入</span><br><br><span class="hljs-comment">// 使用 Map 存储不同房间的 Yjs 文档及相关提供者，确保单例管理和数据隔离</span><br><span class="hljs-keyword">const</span> roomDocuments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<br>  <span class="hljs-built_in">string</span>,<br>  {<br>    <span class="hljs-attr">yDoc</span>: Y.<span class="hljs-property">Doc</span>;<br>    <span class="hljs-attr">yElements</span>: Y.<span class="hljs-property">Map</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>    <span class="hljs-attr">indexeddbProvider</span>: <span class="hljs-title class_">IndexeddbPersistence</span>;<br>    <span class="hljs-attr">wsProvider</span>: <span class="hljs-title class_">HocuspocusProvider</span> | <span class="hljs-literal">null</span>;<br>  }<br>&gt;();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取或创建指定房间的 Yjs 文档实例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> roomId 协作房间的唯一标识符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 该房间对应的 Y.Doc 实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getYDocForRoom = (<span class="hljs-attr">roomId</span>: <span class="hljs-built_in">string</span>): Y.<span class="hljs-property">Doc</span> =&gt; {<br>  <span class="hljs-comment">// 若该房间的文档已存在，直接复用以避免重复创建</span><br>  <span class="hljs-keyword">if</span> (roomDocuments.<span class="hljs-title function_">has</span>(roomId)) {<br>    <span class="hljs-keyword">return</span> roomDocuments.<span class="hljs-title function_">get</span>(roomId)!.<span class="hljs-property">yDoc</span>;<br>  }<br><br>  <span class="hljs-comment">// 创建新的 Yjs 文档实例</span><br>  <span class="hljs-keyword">const</span> yDoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br><br>  <span class="hljs-comment">// 获取画布元素的核心数据结构（Y.Map，用于存储所有 CanvasElement）</span><br>  <span class="hljs-keyword">const</span> yElements = yDoc.<span class="hljs-property">getMap</span>&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-string">'elements'</span>);<br><br>  <span class="hljs-comment">// 初始化 IndexedDB 持久化提供者</span><br>  <span class="hljs-comment">// 数据库名称动态包含 roomId，确保不同房间的数据互不干扰</span><br>  <span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<span class="hljs-string">`canvas-local-db-<span class="hljs-subst">${roomId}</span>`</span>, yDoc);<br><br>  <span class="hljs-comment">// 将文档相关信息存入 Map，便于后续访问和管理</span><br>  roomDocuments.<span class="hljs-title function_">set</span>(roomId, {<br>    yDoc,<br>    yElements,<br>    indexeddbProvider,<br>    <span class="hljs-attr">wsProvider</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 初始为空，后续可动态绑定 HocuspocusProvider 以实现实时协作</span><br>  });<br><br>  <span class="hljs-keyword">return</span> yDoc;<br>};<br></code></pre></td></tr></table></figure><ul><li><strong>离线数据存储</strong>：即使用户断网，数据也不会丢失</li><li><strong>快速本地访问</strong>：减少对服务器的依赖</li><li><strong>大容量存储</strong>：相比 localStorage，支持更大的数据量</li></ul><h4 id="2-SQLite（服务端）"><a href="#2-SQLite（服务端）" class="headerlink" title="2. SQLite（服务端）"></a>2. SQLite（服务端）</h4><p>SQLite 作为服务端数据库，用于持久化存储画布内容：</p><ul><li><strong>关系型结构</strong>：提供 SQL 查询能力</li><li><strong>轻量级</strong>：无需单独的服务器进程</li><li><strong>跨平台</strong>：可在多种环境中运行</li><li><strong>服务端存储</strong>：确保数据在服务端持久化</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 服务端数据库实现 (ALD_Backend/src/db.ts)</span><br><br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Database</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"bun:sqlite"</span>;<br><span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>(<span class="hljs-string">"collab.sqlite"</span>);<br><br><span class="hljs-comment">// 启用 WAL 模式以提高并发性能</span><br>db.<span class="hljs-title function_">exec</span>(<span class="hljs-string">"PRAGMA journal_mode = WAL;"</span>);<br><span class="hljs-comment">// 房间表，包含 content BLOB 字段存储 Yjs 二进制数据</span><br>db.<span class="hljs-title function_">run</span>(<span class="hljs-string">`</span><br><span class="hljs-string">  CREATE TABLE IF NOT EXISTS rooms (</span><br><span class="hljs-string">    id TEXT PRIMARY KEY,</span><br><span class="hljs-string">    name TEXT NOT NULL,</span><br><span class="hljs-string">    creator_id TEXT NOT NULL,</span><br><span class="hljs-string">    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,</span><br><span class="hljs-string">    content BLOB, -- Yjs 二进制数据</span><br><span class="hljs-string">    FOREIGN KEY (creator_id) REFERENCES users(id)</span><br><span class="hljs-string">  )</span><br><span class="hljs-string">`</span>);<br><br><span class="hljs-comment">// Hocuspocus 数据库扩展实现 (ALD_Backend/src/collab.ts)</span><br><br><span class="hljs-keyword">const</span> dbExtension = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HocuspocusDB</span>({<br>  <span class="hljs-attr">fetch</span>: <span class="hljs-title function_">async</span> ({ documentName }) =&gt; {<br>    <span class="hljs-keyword">const</span> roomId = <span class="hljs-title function_">getRoomId</span>(documentName);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">`[Yjs] Fetching data for RoomID: <span class="hljs-subst">${roomId}</span>, Original documentName: <span class="hljs-subst">${documentName}</span>`</span><br>    );<br><br>    <span class="hljs-keyword">const</span> query = db.<span class="hljs-title function_">query</span>(<span class="hljs-string">"SELECT content FROM rooms WHERE id = $id"</span>);<br>    <span class="hljs-keyword">const</span> row = query.<span class="hljs-title function_">get</span>({ <span class="hljs-attr">$id</span>: roomId }) <span class="hljs-keyword">as</span> {<br>      <span class="hljs-attr">content</span>: <span class="hljs-title class_">Uint8Array</span> | <span class="hljs-literal">null</span>;<br>    } | <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (row &amp;&amp; row.<span class="hljs-property">content</span> !== <span class="hljs-literal">null</span> &amp;&amp; row.<span class="hljs-property">content</span> !== <span class="hljs-literal">undefined</span>) {<br>      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">content</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`[Yjs] Returning data with size: <span class="hljs-subst">${row.content.length}</span> bytes`</span><br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(row.<span class="hljs-property">content</span>);<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] content is empty, creating new Yjs document`</span>);<br>        <span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br>        ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>); <span class="hljs-comment">// 存储图形元素</span><br>        <span class="hljs-keyword">return</span> Y.<span class="hljs-title function_">encodeStateAsUpdate</span>(ydoc);<br>      }<br>    }<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] No valid data found, creating new Yjs document`</span>);<br>    <span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br>    ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>); <span class="hljs-comment">// 存储图形元素</span><br>    <span class="hljs-keyword">return</span> Y.<span class="hljs-title function_">encodeStateAsUpdate</span>(ydoc);<br>  },<br><br>  <span class="hljs-attr">store</span>: <span class="hljs-title function_">async</span> ({ documentName, state }) =&gt; {<br>    <span class="hljs-keyword">const</span> roomId = <span class="hljs-title function_">getRoomId</span>(documentName);<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>        <span class="hljs-string">`[Yjs] Saving data for RoomID: <span class="hljs-subst">${roomId}</span>, State size: <span class="hljs-subst">${state.length}</span> bytes, Original documentName: <span class="hljs-subst">${documentName}</span>`</span><br>      );<br><br>      <span class="hljs-keyword">if</span> (state.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">const</span> roomCheck = db.<span class="hljs-title function_">query</span>(<span class="hljs-string">"SELECT id FROM rooms WHERE id = $id"</span>);<br><br>        <span class="hljs-keyword">const</span> roomExists = roomCheck.<span class="hljs-title function_">get</span>({ <span class="hljs-attr">$id</span>: roomId });<br><br>        <span class="hljs-keyword">if</span> (!roomExists) {<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<br>            <span class="hljs-string">`[Yjs] Room <span class="hljs-subst">${roomId}</span> does not exist, cannot save data`</span><br>          );<br><br>          <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">const</span> update = db.<span class="hljs-title function_">query</span>(<br>          <span class="hljs-string">"UPDATE rooms SET content = $blob WHERE id = $id"</span><br>        );<br><br>        update.<span class="hljs-title function_">run</span>({ <span class="hljs-attr">$blob</span>: state, <span class="hljs-attr">$id</span>: roomId });<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] Data saved successfully for RoomID: <span class="hljs-subst">${roomId}</span>`</span>);<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`[Yjs] Skipping save for RoomID: <span class="hljs-subst">${roomId}</span> as state is empty`</span><br>        );<br>      }<br>    } <span class="hljs-keyword">catch</span> (error) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[Yjs] Save failed for <span class="hljs-subst">${roomId}</span>:`</span>, error);<br>    }<br>  },<br>});<br></code></pre></td></tr></table></figure><h3 id="Hocuspocus-Provider"><a href="#Hocuspocus-Provider" class="headerlink" title="Hocuspocus Provider"></a>Hocuspocus Provider</h3><p>Hocuspocus 是一个协作编辑框架，提供了 Yjs 的服务器端实现。它负责：</p><ul><li><strong>多客户端同步</strong>：协调多个客户端之间的数据同步</li><li><strong>WebSocket 连接管理</strong>：建立持久连接</li><li><strong>房间管理</strong>：隔离不同协作空间的数据</li><li><strong>与多种持久化后端集成</strong>：可连接到数据库、文件系统等</li></ul><h2 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    subgraph "Frontend Application (React/Vue)"<br>        A[Canvas UI Components]<br>        B[State Management&lt;br/&gt;Zustand/Pinia]<br>        C[Yjs Document&lt;br/&gt;Shared Data]<br>        D[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    subgraph "Backend Services"<br>        E[Hono Server&lt;br/&gt;Port 3000]<br>        F[RESTful API&lt;br/&gt;Auth/RM]<br>        G[SQLite DB&lt;br/&gt;Persistence]<br>    end<br>    subgraph "WebSocket Services"<br>        H[Hocuspocus Server&lt;br/&gt;Port 1234]<br>        I[Yjs Extensions&lt;br/&gt;DB/Storage]<br>    end<br>    A &lt;--&gt; C<br>    B &lt;--&gt; C<br>    C &lt;--&gt; D<br>    C &lt;--&gt; H<br>    E &lt;--&gt; F<br>    E &lt;--&gt; G<br>    F &lt;--&gt; H<br>    H &lt;--&gt; I<br>    I &lt;--&gt; G<br>    style A fill:#87CEEB<br>    style B fill:#98FB98<br>    style C fill:#FFD700<br>    style D fill:#DDA0DD<br>    style E fill:#F0E68C<br>    style F fill:#FFA07A<br>    style G fill:#BA55D3<br>    style H fill:#20B2AA<br>    style I fill:#FF69B4<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>    subgraph "Client A"<br>        A[Y.Map&lt;br/&gt;Shared Data]<br>        B[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    subgraph "Server"<br>        C[Hocuspocus&lt;br/&gt;Server]<br>        D[SQLite DB&lt;br/&gt;Persistence]<br>    end<br>    subgraph "Client B"<br>        E[Y.Map&lt;br/&gt;Shared Data]<br>        F[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    A &lt;--&gt; C<br>    E &lt;--&gt; C<br>    B &lt;--&gt; D<br>    F &lt;--&gt; D<br>    C &lt;--&gt; D<br>    style A fill:#FFD700<br>    style B fill:#DDA0DD<br>    style C fill:#20B2AA<br>    style D fill:#BA55D3<br>    style E fill:#FFD700<br>    style F fill:#DDA0DD<br></code></pre></td></tr></table></figure><h3 id="数据流向"><a href="#数据流向" class="headerlink" title="数据流向"></a>数据流向</h3><ol><li>用户操作更新本地 Y.Map</li><li>变更自动同步到 IndexedDB（本地持久化）</li><li>变更通过 Hocuspocus 同步到服务器和其他客户端</li><li>服务器将变更存储到 SQLite 数据库</li><li>其他客户端接收变更并更新本地 Y.Map</li></ol><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="1-初始化协作环境"><a href="#1-初始化协作环境" class="headerlink" title="1. 初始化协作环境"></a>1. 初始化协作环境</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Y <span class="hljs-keyword">from</span> <span class="hljs-string">"yjs"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IndexeddbPersistence</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"y-indexeddb"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HocuspocusProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@hocuspocus/provider"</span>;<br><br><span class="hljs-comment">// 创建 Yjs 文档</span><br><span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br><span class="hljs-comment">// 获取共享的 Y.Map 用于存储画布元素</span><br><span class="hljs-keyword">const</span> yElements = ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>);<br><span class="hljs-comment">// 设置 IndexedDB 持久化</span><br><span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<span class="hljs-string">"canvas-room"</span>, ydoc);<br><span class="hljs-comment">// 设置 Hocuspocus 提供者</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initWsProvider</span> = (<span class="hljs-params"><span class="hljs-attr">roomId</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">token</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-comment">// 如果房间不存在，先创建</span><br>  <span class="hljs-keyword">if</span> (!roomDocuments.<span class="hljs-title function_">has</span>(roomId)) {<br>    <span class="hljs-title function_">getYDocForRoom</span>(roomId);<br>  }<br><br>  <span class="hljs-keyword">const</span> roomData = roomDocuments.<span class="hljs-title function_">get</span>(roomId)!;<br><br>  <span class="hljs-comment">// 如果已存在 WebSocket 提供者，先销毁</span><br>  <span class="hljs-keyword">if</span> (roomData.<span class="hljs-property">wsProvider</span>) {<br>    roomData.<span class="hljs-property">wsProvider</span>.<span class="hljs-title function_">destroy</span>();<br>  }<br><br>  <span class="hljs-comment">// 创建新的 WebSocket 提供者，并关联 Yjs 文档</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-string">`[Room <span class="hljs-subst">${roomId}</span>] Initializing WebSocket Provider with token: <span class="hljs-subst">${token}</span>`</span><br>  );<br><br>  <span class="hljs-keyword">const</span> wsProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HocuspocusProvider</span>({<br>    <span class="hljs-comment">// 确保 URL 结尾规范，方便拼接</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`ws://localhost:3000/collaboration/<span class="hljs-subst">${roomId}</span>`</span>,<br>    <span class="hljs-attr">name</span>: roomId, <span class="hljs-comment">// Hocuspocus 会将其拼接为 /collaboration/{roomId}</span><br>    <span class="hljs-attr">token</span>: token,<br>    <span class="hljs-comment">// 明确指定要同步的文档</span><br>    <span class="hljs-attr">document</span>: roomData.<span class="hljs-property">yDoc</span>,<br>  });<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wsProvider);<br><br>  <span class="hljs-comment">// 监听 WebSocket 连接状态</span><br>  wsProvider.<span class="hljs-title function_">on</span>(<span class="hljs-string">"status"</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Room <span class="hljs-subst">${roomId}</span>] WebSocket status:`</span>, event.<span class="hljs-property">status</span>); <span class="hljs-comment">// 'connected' or 'disconnected'</span><br>  });<br><br>  <span class="hljs-comment">// 更新房间数据中的 WebSocket 提供者</span><br>  roomData.<span class="hljs-property">wsProvider</span> = wsProvider;<br>  <span class="hljs-keyword">return</span> wsProvider;<br>};<br></code></pre></td></tr></table></figure><h3 id="2-画布元素管理"><a href="#2-画布元素管理" class="headerlink" title="2. 画布元素管理"></a>2. 画布元素管理</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>}<br><br><span class="hljs-comment">// 添加元素</span><br><br>yElements.<span class="hljs-title function_">set</span>(elementId, {<br>  <span class="hljs-attr">id</span>: elementId,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"rectangle"</span>,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">150</span>,<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">"#ff0000"</span>,<br>});<br><br><span class="hljs-comment">// 监听元素变化</span><br><br>yElements.<span class="hljs-title function_">observeDeep</span>(<span class="hljs-function">(<span class="hljs-params">events</span>) =&gt;</span> {<br>  events.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {<br>    <span class="hljs-comment">// 处理添加、更新、删除事件</span><br>  });<br>});<br></code></pre></td></tr></table></figure><h3 id="3-React-状态集成"><a href="#3-React-状态集成" class="headerlink" title="3. React 状态集成"></a>3. React 状态集成</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">"zustand"</span>;<br><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasStore</span> {<br>  <span class="hljs-attr">ydoc</span>: Y.<span class="hljs-property">Doc</span>;<br>  <span class="hljs-attr">yElements</span>: Y.<span class="hljs-property">Map</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">element</span>: <span class="hljs-title class_">CanvasElement</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">deleteElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCanvasStore = create&lt;<span class="hljs-title class_">CanvasStore</span>&gt;(<span class="hljs-function">(<span class="hljs-params">set, get</span>) =&gt;</span> ({<br>  <span class="hljs-comment">// ... store implementation</span><br>}));<br></code></pre></td></tr></table></figure><h3 id="4-离线支持实现"><a href="#4-离线支持实现" class="headerlink" title="4. 离线支持实现"></a>4. 离线支持实现</h3><p>离线支持是通过 IndexedDB 实现的：</p><ul><li>当用户在线时，所有操作同步到服务器和其他客户端</li><li>当用户离线时，操作仅保存在本地 IndexedDB 中</li><li>当用户重新连接时，本地更改自动同步到服务器</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 等待 IndexedDB 数据加载</span><br><span class="hljs-keyword">await</span> indexeddbProvider.<span class="hljs-property">whenSynced</span>;<br><br><span class="hljs-comment">// 监听连接状态</span><br>provider.<span class="hljs-title function_">on</span>(<span class="hljs-string">"synced"</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Document synced with server"</span>);<br>});<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>后续还可以实现批量更新，防抖，服务端数据验证等优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时协作画布系统：Yjs-Hocuspocus-持久化&quot;&gt;&lt;a href=&quot;#实时协作画布系统：Yjs-Hocuspocus-持久化&quot; class=&quot;headerlink&quot; title=&quot;实时协作画布系统：Yjs + Hocuspocus + 持久化&quot;&gt;&lt;/a&gt;实</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-18-前端画布设计Vol.2 实现富文本编辑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/10362.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/10362.html</id>
    <published>2025-12-27T18:58:47.000Z</published>
    <updated>2025-12-27T20:23:25.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="画布项目中富文本编辑器的实现浅析"><a href="#画布项目中富文本编辑器的实现浅析" class="headerlink" title="画布项目中富文本编辑器的实现浅析"></a>画布项目中富文本编辑器的实现浅析</h2><h4 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h4><p>该画布项目采用 <strong>wangEditor</strong>（v5 版本）的 React 封装组件 @wangeditor/editor-for-react 实现富文本编辑功能。主要通过两个组件协作完成：</p><ul><li>RichTextEditor.tsx：核心富文本编辑器封装，负责工具栏和编辑区的渲染与配置。</li><li>BottomTextEditor.tsx：底部面板式编辑器，仅在选中单个文本元素时显示，将富文本编辑器集成到画布操作流程中，支持实时更新元素内容并记录撤销/重做操作。</li></ul><p>主要形式是一个底部面板，单击文本元素会出现</p><h4 id="0x01-RichTextEditor-组件实现"><a href="#0x01-RichTextEditor-组件实现" class="headerlink" title="0x01 RichTextEditor 组件实现"></a>0x01 RichTextEditor 组件实现</h4><p>RichTextEditor 是对 wangEditor 的二次封装，提供可复用的富文本编辑器</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">"@wangeditor/editor/dist/css/style.css"</span>;<br><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Editor</span>, <span class="hljs-title class_">Toolbar</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@wangeditor/editor-for-react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">toolbarConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IToolbarConfig</span>&gt; = {<br>  <span class="hljs-attr">toolbarKeys</span>: [<br>    <span class="hljs-string">"bold"</span>,<br>    <span class="hljs-string">"italic"</span>,<br>    <span class="hljs-string">"underline"</span>,<br>    <span class="hljs-string">"through"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"fontSize"</span>,<br>    <span class="hljs-string">"fontFamily"</span>,<br>    <span class="hljs-string">"color"</span>,<br>    <span class="hljs-string">"bgColor"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"justifyLeft"</span>,<br>    <span class="hljs-string">"justifyCenter"</span>,<br>    <span class="hljs-string">"justifyRight"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"undo"</span>,<br>    <span class="hljs-string">"redo"</span>,<br>  ],<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">editorConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IEditorConfig</span>&gt; = {<br>  <span class="hljs-attr">placeholder</span>: <span class="hljs-string">"请输入文本..."</span>,<br>  <span class="hljs-attr">autoFocus</span>: <span class="hljs-literal">true</span>,<br>};<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (editor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    editor.<span class="hljs-title function_">destroy</span>();<br>    <span class="hljs-title function_">setEditor</span>(<span class="hljs-literal">null</span>);<br>  };<br>}, [editor]);<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"..."</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> <span class="hljs-attr">editor</span>=<span class="hljs-string">{editor}</span> <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{toolbarConfig}</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"simple"</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Editor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{editorConfig}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onCreated</span>=<span class="hljs-string">{setEditor}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(editor)</span> =&gt;</span> onChange(editor.getHtml())}</span><br><span class="language-xml">      mode="simple"</span><br><span class="language-xml">      style={{ height: "200px", overflowY: "auto" }}</span><br><span class="language-xml">    /&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>工具栏配置（toolbarConfig）</strong> 通过 toolbarKeys 指定显示的菜单键（加粗、斜体、下划线、删除线、字体大小/家族、颜色、背景色、对齐方式）以及撤销/重做。</li><li><strong>编辑器配置（editorConfig）</strong> 设置占位符和自动聚焦。wangEditor 支持更丰富的配置（如最大长度、自定义菜单等），此处保持最小化。</li><li><strong>生命周期管理</strong> 使用 useEffect 在组件卸载或 editor 实例变化时调用 editor.destroy()，防止内存泄漏。</li><li><strong>内容同步</strong>value props 控制初始 HTML，onChange 回调通过 editor.getHtml() 获取最新 HTML 内容并向上通知。</li></ol><h4 id="0x02-BottomTextEditor-组件实现"><a href="#0x02-BottomTextEditor-组件实现" class="headerlink" title="0x02 BottomTextEditor 组件实现"></a>0x02 BottomTextEditor 组件实现</h4><p>BottomTextEditor 将富文本编辑器集成到画布状态管理中，仅针对选中单个文本元素时激活。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> { selectedIds, elements, updateElement } = <span class="hljs-title function_">useStore</span>();<br><br><span class="hljs-keyword">const</span> selectedId = selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> ? selectedIds[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> element = selectedId ? elements[selectedId] : <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">const</span> [localHtml, setLocalHtml] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>);<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (element &amp;&amp; element.<span class="hljs-property">type</span> === <span class="hljs-string">"text"</span>) {<br>    <span class="hljs-title function_">setLocalHtml</span>(element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>);<br>  }<br>}, [element?.<span class="hljs-property">id</span>, element?.<span class="hljs-property">text</span>]);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params"><span class="hljs-attr">html</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-title function_">setLocalHtml</span>(html);<br>  <span class="hljs-keyword">const</span> initialText = element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>;<br>  <span class="hljs-title function_">updateElement</span>(element.<span class="hljs-property">id</span>, { <span class="hljs-attr">text</span>: html });<br><br>  <span class="hljs-keyword">const</span> updateCommand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateElementPropertyCommand</span>(<br>    { <span class="hljs-attr">id</span>: element.<span class="hljs-property">id</span>, <span class="hljs-attr">property</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">oldValue</span>: initialText, <span class="hljs-attr">newValue</span>: html },<br>    <span class="hljs-string">"修改文本内容"</span><br>  );<br>  undoRedoManager.<span class="hljs-title function_">executeCommand</span>(updateCommand);<br>};<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-8 ... animate-slide-up"</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">RichTextEditor</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{localHtml}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>选中元素判断</strong> 从 Zustand store（canvasStore）获取选中 ID 和元素集合，仅当选中单个文本类型元素时渲染编辑器。</li><li><strong>本地状态（localHtml）</strong> 使用 useState 维护本地 HTML 副本，并在选中元素变化时通过 useEffect 同步 store 中的 element.text。 此设计主要解决中文输入法（IME）组成阶段的问题：在拼音输入过程中，wangEditor 的 onChange 会频繁触发，若直接更新全局 store，可能导致输入延迟、光标跳动或内容混乱。通过本地状态缓冲实时变化，避免不必要的 store 更新。</li><li><strong>内容变更处理（handleChange）</strong><ul><li>更新本地状态。</li><li>实时调用 updateElement 更新画布 store，驱动 canvas 重新渲染文本元素。</li><li>创建 UpdateElementPropertyCommand 命令并执行，支持撤销/重做（undo/redo）。命令记录旧值和新值，处理历史操作</li></ul></li></ol><h4 id="0x03-关键问题解决与设计"><a href="#0x03-关键问题解决与设计" class="headerlink" title="0x03 关键问题解决与设计"></a>0x03 关键问题解决与设计</h4><ol><li><strong>输入法兼容性</strong> 中文输入过程中，组成事件（composition）会多次触发编辑器变更。若直接在 onChange 中更新全局状态，可能导致性能问题或输入体验不佳。本实现通过本地状态缓冲 setLocalHtml(html) 缓解该问题</li><li><strong>实时渲染与历史管理</strong> 实时更新 store 确保画布文本即时反映变更；同时通过命令模式记录操作，实现完整的 undo/redo 支持。</li></ol><h4 id="0x04-当前实现的风险与不足分析"><a href="#0x04-当前实现的风险与不足分析" class="headerlink" title="0x04 当前实现的风险与不足分析"></a>0x04 当前实现的风险与不足分析</h4><p>当前实现虽已满足基础富文本编辑需求，但是还是有一些问题</p><ol><li><strong>输入法体验优化不彻底</strong> 虽通过本地状态缓冲缓解了 IME 组成阶段的频繁更新问题，但未监听 compositionstart/compositionend 事件。在某些极端输入场景（如快速切换输入法或长句输入）下，仍可能出现光标偏移或临时内容丢失的现象。</li><li><strong>内容净化与 XSS 防护不足</strong> 完全依赖 wangEditor 内置的有限转义机制，未引入 DOMPurify 等专用净化库。在用户插入外部链接、图片或自定义 HTML 时，存在潜在的存储型或 DOM 型 XSS 风险，尤其在内容后续导出或分享场景中。</li><li><strong>样式与对齐精度问题</strong> wangEditor 生成的 HTML 结构（如多层 span/div 嵌套）与画布自定义文本渲染逻辑可能不完全匹配，导致编辑器中预览效果与画布最终渲染存在细微差异（如行高、字间距、对齐方式）。</li><li><strong>性能与内存管理</strong> 频繁的实时更新（onChange 触发 store 更新与命令记录）在长文本场景下可能导致轻微卡顿；此外，未对编辑器实例进行复用，当快速切换不同文本元素时会反复创建/销毁实例，增加内存开销。</li></ol><p>面对这些问题后续都可以做一些改进：</p><ol><li><strong>引入 DOMPurify 进行内容净化来处理 XSS 问题</strong> 在内容存储前（提交到 store 或后端）及渲染时统一调用 DOMPurify.sanitize，对 HTML 进行严格过滤。自定义白名单以保留 wangEditor 支持的必要标签与属性，同时移除所有事件处理器及危险协议。</li><li><strong>完善输入法兼容性</strong> 在 RichTextEditor 中监听 composition 事件，在组成阶段暂不触发 handleChange，仅在 compositionend 后统一更新 store 与命令记录，进一步消除输入延迟与光标问题。</li><li><strong>性能优化</strong> 实现编辑器实例复用（单一全局实例，根据选中元素动态切换内容），并在长文本时增加防抖处理，减少不必要的 store 更新与命令执行。</li></ol><h4 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h4><p>主要就是 wangEditor 的 React 封装，结合 Zustand 状态管理和命令模式，来适配画布类项目的文本编辑需求，实现了基础的文本编辑功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;a href=&quot;#画布项目中富文本编辑器的实现浅析&quot; class=&quot;headerlink&quot; title=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;/a&gt;画布项目中富文本编辑器的实现浅析&lt;/h2&gt;&lt;h4 id=&quot;0x00-概述&quot;&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-17-前端画布设计Vol.1 实现基础元素渲染和状态控制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/43445.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/43445.html</id>
    <published>2025-12-27T17:23:08.000Z</published>
    <updated>2026-01-20T07:25:34.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PixiJS-实现基础元素渲染和状态控制"><a href="#PixiJS-实现基础元素渲染和状态控制" class="headerlink" title="PixiJS 实现基础元素渲染和状态控制"></a>PixiJS 实现基础元素渲染和状态控制</h2><p>PixiJS 是一个强大的 2D 渲染引擎，它使用 WebGL 和 Canvas 技术来高效地渲染图形，主要通过  ElementRenderer  类实现。</p><h3 id="基本图形渲染实现"><a href="#基本图形渲染实现" class="headerlink" title="基本图形渲染实现"></a>基本图形渲染实现</h3><p>设计的画布中，基本图形是通过 PixiJS 的 Graphics 类绘制的，支持以下基本图形类型：</p><ol><li><p><strong>矩形 (rect)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆角矩形 (rounded rectangle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">roundRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>, data.<span class="hljs-property">radius</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆形 (circle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">ellipse</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>菱形 (diamond)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">poly</span>([<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">width</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">height</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>]);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li></ol><h3 id="图形属性实现"><a href="#图形属性实现" class="headerlink" title="图形属性实现"></a>图形属性实现</h3><p>每个图形元素都由  CanvasElement  接口定义，支持以下属性：</p><ol><li><p><strong>背景色 (background)</strong>:</p><ul><li>通过  fill  属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li><li>使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>边框宽度 (border-width)</strong>:</p><ul><li>通过  strokeWidth  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li></ul></li><li><p><strong>边框颜色 (border-color)</strong>:</p><ul><li>通过  stroke  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li><li>同样使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>透明度 (alpha)</strong>:</p><ul><li>通过 alpha 属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li></ul></li></ol><p>在  ElementRenderer  类中，图形渲染的过程包括以下步骤：</p><ol><li>首先清空之前的图形绘制：<code>g.clear()</code></li><li><p>设置绘制样式（边框宽度、边框颜色、填充颜色、透明度）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> strokeWidth = data.<span class="hljs-property">strokeWidth</span> ?? <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> strokeColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">stroke</span>);<br><span class="hljs-keyword">const</span> fillColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">fill</span>);<br><span class="hljs-keyword">const</span> alpha = data.<span class="hljs-property">alpha</span> ?? <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>根据图形类型绘制对应的形状</p></li><li><p>设置图形的位置和旋转：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-property">pivot</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">x</span> + data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">y</span> + data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">rotation</span> = data.<span class="hljs-property">rotation</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="特殊功能"><a href="#特殊功能" class="headerlink" title="特殊功能"></a>特殊功能</h3><ol><li><strong>旋转功能</strong>: 通过设置  pivot  点和  rotation  属性实现</li><li><strong>圆角矩形</strong>: 使用  <code>g.roundRect(x, y, width, height, radius)</code>  方法</li><li><strong>纹理缓存</strong>: 对图像元素使用纹理缓存以提高性能</li><li><strong>动态加载</strong>: 图像元素支持异步加载纹理</li></ol><h2 id="状态管理机制"><a href="#状态管理机制" class="headerlink" title="状态管理机制"></a>状态管理机制</h2><p>状态管理由  zustand  库实现，通过  CanvasStore  集中管理所有画布元素的状态。状态管理包含以下几个核心部分：</p><h3 id="1-状态结构"><a href="#1-状态结构" class="headerlink" title="1. 状态结构"></a>1. 状态结构</h3><ul><li>elements: 一个记录对象，包含所有画布元素</li><li>selectedIds: 当前选中的元素 ID 数组</li><li>tool: 当前使用的工具类型</li><li>currentStyle: 当前绘制样式（填充色、边框色、边框宽度等）</li></ul><h3 id="2-状态更新机制"><a href="#2-状态更新机制" class="headerlink" title="2. 状态更新机制"></a>2. 状态更新机制</h3><p>状态更新通过以下方法实现：</p><ul><li>addElement: 添加元素</li><li>updateElement: 更新元素属性</li><li>removeElements: 删除元素</li><li>setSelected: 设置选中的元素</li><li>batchUpdateElements: 批量更新元素（用于提高性能）</li></ul><h2 id="元素渲染机制"><a href="#元素渲染机制" class="headerlink" title="元素渲染机制"></a>元素渲染机制</h2><p>元素渲染通过  ElementRenderer  类实现，它与状态管理紧密结合：</p><h3 id="1-状态-渲染同步"><a href="#1-状态-渲染同步" class="headerlink" title="1. 状态-渲染同步"></a>1. 状态-渲染同步</h3><p>在  Core_StageManager.ts  中，有一个关键的订阅机制：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">useStore.<span class="hljs-title function_">subscribe</span>(   <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">elements</span>: state.<span class="hljs-property">elements</span>, <span class="hljs-attr">selectedIds</span>: state.<span class="hljs-property">selectedIds</span>, <span class="hljs-attr">tool</span>: state.<span class="hljs-property">tool</span> }),   <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {     <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">destroyed</span>) {       <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRenderer</span>.<span class="hljs-title function_">renderElements</span>(state.<span class="hljs-property">elements</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementLayer</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">destroyed</span>)       <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerRenderer</span>.<span class="hljs-title function_">renderTransformer</span>(         state.<span class="hljs-property">elements</span>,         state.<span class="hljs-property">selectedIds</span>,         <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRenderer</span>.<span class="hljs-title function_">getSpriteMap</span>(),         <span class="hljs-variable language_">this</span>.<span class="hljs-property">onHandleDown</span>,         <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-property">scale</span>.<span class="hljs-property">x</span>,       )       <span class="hljs-comment">// ...</span><br><span class="hljs-comment">//</span><br>}<br> },   { <span class="hljs-attr">equalityFn</span>: stateEqualityFn }, )<br></code></pre></td></tr></table></figure><p>每当状态发生变化时，就会触发渲染更新。</p><h3 id="2-渲染过程"><a href="#2-渲染过程" class="headerlink" title="2. 渲染过程"></a>2. 渲染过程</h3><p>ElementRenderer.renderElements  方法遍历所有元素并执行以下操作：</p><ol><li><strong>元素映射管理</strong>：使用  spriteMap  记录已渲染的元素</li><li><strong>类型处理</strong>：根据元素类型（矩形、圆形、文本、图像等）进行相应渲染</li><li><strong>属性应用</strong>：将状态中的属性（位置、大小、颜色等）应用到渲染对象</li></ol><h3 id="3-状态与渲染的实时同步"><a href="#3-状态与渲染的实时同步" class="headerlink" title="3. 状态与渲染的实时同步"></a>3. 状态与渲染的实时同步</h3><p>当状态变化时，例如：</p><ul><li>用户拖动元素时，updateElement  更新元素的  x  和  y  坐标</li><li>用户改变填充颜色时，updateElement  更新  fill  属性</li><li>选择元素时，setSelected  更新  selectedIds</li></ul><p>这些状态变更会立即触发渲染更新，确保 UI 与状态保持同步。</p><h2 id="状态控制机制"><a href="#状态控制机制" class="headerlink" title="状态控制机制"></a>状态控制机制</h2><h3 id="1-撤销-重做"><a href="#1-撤销-重做" class="headerlink" title="1. 撤销/重做"></a>1. 撤销/重做</h3><p>项目集成了撤销/重做功能，通过  UndoRedoManager  和命令模式实现：</p><ul><li>每个操作（添加、删除、更新）都创建一个命令对象</li><li>命令对象包含执行和撤销操作的逻辑</li><li>undo  和  redo  方法控制历史记录栈</li></ul><h3 id="2-选择状态管理"><a href="#2-选择状态管理" class="headerlink" title="2. 选择状态管理"></a>2. 选择状态管理</h3><ul><li>selectedIds  数组跟踪当前选中的元素</li><li>选择变化会触发渲染更新，显示选择框和控制点</li><li>TransformerRenderer 负责渲染选择框和调整手柄</li></ul><h3 id="3-工具状态管理"><a href="#3-工具状态管理" class="headerlink" title="3. 工具状态管理"></a>3. 工具状态管理</h3><ul><li>tool  属性跟踪当前使用的工具</li><li>工具变化会影响交互行为和光标样式</li><li>不同工具对相同的用户输入（如鼠标点击）会有不同的响应</li></ul><h3 id="4-实时协作"><a href="#4-实时协作" class="headerlink" title="4. 实时协作"></a>4. 实时协作</h3><p>项目使用 Yjs 实现实时协作功能：</p><ul><li>状态变化通过 Yjs 同步到其他用户</li><li>Yjs 的 observe 机制确保本地状态与共享状态同步</li><li>使用事务（transact）保证操作的原子性</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><strong>状态比较优化</strong>：使用  stateEqualityFn  减少不必要的重渲染</li><li><strong>批量更新</strong>：batchUpdateElements  方法用于批量更新元素，减少渲染次数</li><li><strong>精灵映射</strong>：ElementRenderer  保留精灵映射以避免重复创建/销毁</li><li><strong>防抖机制</strong>：虽然代码中注释掉了防抖，但设计中考虑了性能优化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PixiJS-实现基础元素渲染和状态控制&quot;&gt;&lt;a href=&quot;#PixiJS-实现基础元素渲染和状态控制&quot; class=&quot;headerlink&quot; title=&quot;PixiJS 实现基础元素渲染和状态控制&quot;&gt;&lt;/a&gt;PixiJS 实现基础元素渲染和状态控制&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-27-算法刷题-关于链表操作</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/40452.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/40452.html</id>
    <published>2025-12-27T08:12:42.000Z</published>
    <updated>2025-12-27T10:53:26.438Z</updated>
    
    <content type="html"><![CDATA[<p>后悔数据结构当初没有好好学的第n天<br>现在恶补，知识学爆</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><p>基础操作：</p><ul><li>查找元素：根据值查找节点位置</li><li>指定位置插入：在特定位置插入新节点</li><li>指定位置获取：获取特定位置的节点值</li><li>指定位置删除：删除特定位置的节点</li><li>获取长度：统计链表中节点的数量</li></ul><div class="table-container"><table><thead><tr><th></th><th>题目描述</th><th>主要实现思路</th></tr></thead><tbody><tr><td>BM1</td><td>反转链表</td><td>使用三指针（prev、curr、next）迭代反转：保存下一个节点，反转当前指向，移动指针。返回prev作为新头。</td></tr><tr><td>BM2</td><td>链表内指定区间反转</td><td>引入虚拟头结点定位第m-1个节点（pre）。然后在[m,n]区间执行(n-m)次头插法（逐个将下一个节点插入pre后）。</td></tr><tr><td>BM3</td><td>链表中的节点每k个一组翻转</td><td>每k个节点为一组，使用反转链表方法局部反转。若剩余不足k个，则保持原序。递归或迭代均可，推荐迭代分段处理。</td></tr><tr><td>BM4</td><td>合并两个排序的链表</td><td>双指针模拟归并排序：比较两个链表当前节点值，小者接入新链表，移动对应指针。处理剩余部分。</td></tr><tr><td>BM5</td><td>合并k个已排序的链表</td><td>使用小根堆（优先队列）维护k个链表头结点，每次弹出最小值并接入结果链表，同时推入其下一个节点。</td></tr><tr><td>BM6</td><td>判断链表中是否有环</td><td>快慢指针（Floyd判圈算法）：fast每次走2步，slow走1步。若相遇则有环，否则无环。</td></tr><tr><td>BM7</td><td>链表中环的入口结点</td><td>先用快慢指针相遇于环内某点，再令一指针从头启动，与慢指针同步移动，相遇处即环入口。</td></tr><tr><td>BM8</td><td>链表中倒数最后k个结点</td><td>快慢指针：fast先走k步，然后slow与fast同步移动，至fast到尾时slow即为倒数第k个节点。</td></tr><tr><td>BM9</td><td>删除链表的倒数第n个节点</td><td>同BM8定位倒数第n+1个节点（pre），然后pre.next = pre.next.next删除目标节点。注意头节点特殊处理。</td></tr><tr><td>BM10</td><td>两个链表的第一个公共结点</td><td>双指针同步走：先计算长度差，长者先走差值步；或让指针走完一链表后换另一链表，总路程相等时相遇即公共节点。</td></tr><tr><td>BM11</td><td>链表相加(二)</td><td>模拟加法从低位到高位（需先反转链表或用栈），处理进位。结果可能需反转回原序。</td></tr><tr><td>BM12</td><td>单链表的排序</td><td>归并排序（自底向上）：分段合并有序子链表，或快慢指针找中点递归归并。时间O(n log n)。</td></tr><tr><td>BM13</td><td>判断一个链表是否为回文结构</td><td>快慢指针找中点，反转后半部分，与前半部分逐节点比较值是否相等。恢复链表可选。</td></tr><tr><td>BM14</td><td>链表的奇偶重排</td><td>分离奇偶位节点成两个链表（odd、even），然后even接odd尾部。注意偶数长度处理。</td></tr><tr><td>BM15</td><td>删除有序链表中重复的元素-I</td><td>单指针遍历：若当前节点与下一节点值相同，跳过下一节点（保留首次出现）。</td></tr><tr><td>BM16</td><td>删除有序链表中重复的元素-II</td><td>引入虚拟头结点，双指针或单指针遍历：若连续重复，跳过整个重复段（一个不留）。</td></tr></tbody></table></div><hr><p>一般会给出一个最基础的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = (val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = (next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next);<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>节点包含两个成员</strong>：<ul><li>val：存储节点的值，通常为整数（int），题目中 |val| ≤ 1000。</li><li>next：指向下一个节点的指针（引用），类型为同类 ListNode*（或 ListNode），初始可能为 NULL/null/None</li></ul></li><li><strong>无哑头节点（dummy head）</strong>：输入的 head 就是真实头结点（有有效值），除非题目特别说明</li><li><strong>单向链表</strong>：只能从头到尾遍历，无前向指针</li><li><strong>输入形式</strong>：<ul><li>函数签名通常为 ListNode* head（或类似），可能额外传入其他参数（如 m、n、k 等）</li><li>空链表：head = NULL / null / None</li></ul></li><li><strong>输出形式</strong>：<ul><li>大多数题目要求返回新的头结点（ListNode*）</li><li>操作通常要求<strong>原地修改</strong>，以满足空间复杂度 O(1)</li></ul></li></ul><hr><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="单链表常见操作的实现方法"><a href="#单链表常见操作的实现方法" class="headerlink" title="单链表常见操作的实现方法"></a>单链表常见操作的实现方法</h3><p>以下针对单链表（节点结构为 val 和 next）的几种常见操作，提供标准、高效的实现思路。所有操作均基于从头结点开始遍历，时间复杂度与空间复杂度分析清晰。假设节点定义如下（以 JavaScript 为例，其他语言类似）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next || <span class="hljs-literal">null</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="1-查找元素：根据值查找节点位置（返回位置或节点）"><a href="#1-查找元素：根据值查找节点位置（返回位置或节点）" class="headerlink" title="1. 查找元素：根据值查找节点位置（返回位置或节点）"></a>1. 查找元素：根据值查找节点位置（返回位置或节点）</h4><p><strong>思路</strong>：从头遍历，逐个比较节点值，直到找到匹配值或到达链表末尾。</p><p><strong>实现要点</strong>：</p><ul><li>返回第一个匹配节点的<strong>位置</strong>（从 1 开始）或节点本身。</li><li>未找到返回 -1 或 null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findNode</span>(<span class="hljs-params">head, target</span>) {<br>    <span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">if</span> (curr.<span class="hljs-property">val</span> === target) {<br>            <span class="hljs-keyword">return</span> pos;  <span class="hljs-comment">// 或 return curr; 返回节点本身</span><br>        }<br>        curr = curr.<span class="hljs-property">next</span>;<br>        pos++;<br>    }<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）"><a href="#2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）" class="headerlink" title="2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）"></a>2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，将新节点插入其后。特殊处理插入到头部（i=1）。</p><p><strong>实现要点</strong>：</p><ul><li>若 i=1，新节点成为新头。</li><li>若 i &gt; 长度，插入失败或插入尾部（视题目要求）。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtPosition</span>(<span class="hljs-params">head, i, val</span>) {<br>    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>        newNode.<span class="hljs-property">next</span> = head;<br>        <span class="hljs-keyword">return</span> newNode;  <span class="hljs-comment">// 新头结点</span><br>    }<br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围，不插入</span><br>    <br>    newNode.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>;<br>    curr.<span class="hljs-property">next</span> = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）"><a href="#3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）" class="headerlink" title="3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）"></a>3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）</h4><p><strong>思路</strong>：遍历 i-1 步，直接返回当前节点的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> curr ? curr.<span class="hljs-property">val</span> : <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 未找到返回 null</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="4-指定位置删除：删除第-i-个节点（i-从-1-开始）"><a href="#4-指定位置删除：删除第-i-个节点（i-从-1-开始）" class="headerlink" title="4. 指定位置删除：删除第 i 个节点（i 从 1 开始）"></a>4. 指定位置删除：删除第 i 个节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，修改其 next 指向跳过第 i 个节点。特殊处理删除头结点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 删除头结点</span><br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span> || curr.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围</span><br>    <br>    curr.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 跳过第 i 个节点</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="5-获取链表长度（节点数量）"><a href="#5-获取链表长度（节点数量）" class="headerlink" title="5. 获取链表长度（节点数量）"></a>5. 获取链表长度（节点数量）</h4><p><strong>思路</strong>：遍历链表，累计计数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        len++;<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> len;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="BM1-全量反转链表"><a href="#BM1-全量反转链表" class="headerlink" title="BM1  | 全量反转链表"></a>BM1  | 全量反转链表</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤n≤10000≤n≤1000</p><p>要求：空间复杂度 O(1)O(1) ，时间复杂度 O(n)O(n) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p class='item-img' data-src='https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249'><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt=""></p><hr><p>解法：</p><ul><li>初始化 prev 为 null（新链表的尾部）。</li><li>current 从链表头节点开始。</li><li>在循环中：<ul><li>暂存 next = current.next（避免指针丢失）。</li><li>将 current.next 指向 prev（反转当前指针）。</li><li>更新 prev = current（前移 prev）。</li><li>更新 current = next（前移 current）。</li></ul></li><li>循环结束后，prev 指向原链表的尾节点（新头节点），更新 list.head = prev。</li></ul><p>其实就是三指针原地反转</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp'><img src="https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ReverseList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span></span>): <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br><br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    <br>        <span class="hljs-comment">// 保存下一个节点，防止断链</span><br>        <span class="hljs-keyword">let</span> next = curr.<span class="hljs-property">next</span>;<br><br>        <span class="hljs-comment">// 反转当前节点的指向</span><br>        curr.<span class="hljs-property">next</span> = prev;<br><br>        <span class="hljs-comment">// 指针向前移动</span><br>        prev = curr;<br>        curr = next;<br>    }<br>    <span class="hljs-comment">// prev 指向反转后的新头结点</span><br>    <span class="hljs-keyword">return</span> prev;<br>};<br></code></pre></td></tr></table></figure><h3 id="BM2-反转链表部分区间"><a href="#BM2-反转链表部分区间" class="headerlink" title="BM2  | 反转链表部分区间"></a>BM2  | 反转链表部分区间</h3><p>给定一个单链表的头结点 head，长度为 n，反转该链表从位置 m 到 n 的部分，返回反转后的链表。</p><p>数据范围： 0≤m≤n≤n≤1000 ，链表中任意节点的值满足 |val|≤1000</p><p>例如：<br>给出的链表为 1→2→3→4→5→NULL1→2→3→4→5→NULL, m=2,n=4m=2,n=4,<br>返回 1→4→3→2→5→NULL1→4→3→2→5→NULL.  </p><p>要实现原地反转指定区间，需要：</p><ol><li>找到反转区间的前一个节点（pre），即第 m-1 个节点。</li><li>找到反转区间的最后一个节点（记为 end），即第 n 个节点。</li><li>将 [m, n] 区间使用经典链表反转方法进行原地反转。</li><li>正确连接反转后的区间与前后部分：<ul><li>pre.next 指向反转后区间的新的头节点（原第 n 个节点）。</li><li>反转后区间的尾节点（原第 m 个节点）指向 end.next。</li></ul></li></ol><p>关键操作：</p><ul><li>先遍历定位到 pre 和反转区间的起始节点 start（第 m 个节点）。</li><li>然后在 [start, end] 区间内使用三指针迭代反转。</li><li>最后调整指针连接。</li></ul><p class='item-img' data-src='https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif'><img src="https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">m</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || m === n) <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> pre = dummy;<br><br>    <span class="hljs-comment">// 移动到第 m-1 个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) {<br>        pre = pre.<span class="hljs-property">next</span>!;<br>    }<br><br>    <span class="hljs-keyword">let</span> start = pre.<span class="hljs-property">next</span>!;   <span class="hljs-comment">// 第 m 个节点（反转区间的原头部）</span><br>    <span class="hljs-keyword">let</span> then = start.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 第 m+1 个节点（待头插的节点）</span><br><br>    <span class="hljs-comment">// 执行 (n - m) 次头插</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++) {<br>        start.<span class="hljs-property">next</span> = then.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 从原区间摘除 then</span><br>        then.<span class="hljs-property">next</span> = pre.<span class="hljs-property">next</span>;     <span class="hljs-comment">// then 插入 pre 之后（成为新头部）</span><br>        pre.<span class="hljs-property">next</span> = then;          <span class="hljs-comment">// 更新 pre 的 next</span><br>        then = start.<span class="hljs-property">next</span>;        <span class="hljs-comment">// 更新 then 为下一个待移动节点</span><br>    }<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;后悔数据结构当初没有好好学的第n天&lt;br&gt;现在恶补，知识学爆&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?sou</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-力扣百题速练（Javascript、TypeScript）Vol.2</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39620.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39620.html</id>
    <published>2025-12-26T05:57:08.000Z</published>
    <updated>2025-12-27T12:52:43.608Z</updated>
    
    <content type="html"><![CDATA[<p>这里是力扣速刷第二期awa<br>说是速刷其实卡了挺久</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为  <code>n</code>  的整数数组  <code>height</code> 。有  <code>n</code>  条垂线，第  <code>i</code>  条线的两个端点是  <code>(i, 0)</code>  和  <code>(i, height[i])</code><br>找出其中的两条线，使得它们与  <code>x</code>  轴共同构成的容器可以容纳最多的水<br>返回容器可以储存的最大水量</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49</p><p>最开始直接暴力解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; height.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">let</span> xin = (j - i) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]);<br>      <span class="hljs-keyword">if</span> (xin &gt; res) {<br>        res = xin;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>后面想了一下，做了些改进</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (i &lt; j) {<br>    <span class="hljs-keyword">let</span> fin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]) * (j - i);<br>    <span class="hljs-keyword">if</span> (fin &gt; res) {<br>      res = fin;<br>    }<br>    <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) {<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      j--;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>初始时宽度最大，若当前面积不是最大，则必须通过增加高度来补偿宽度损失<br>移动较短指针是因为：保持较短边不动，宽度只会变小，面积不可能增大；只有移动较短边才可能遇到更高的高度，从而提升面积</p><p>经典双指针加贪心的题</p><hr><h2 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h2><p>七个不同的符号代表罗马数字，其值如下：</p><div class="table-container"><table><thead><tr><th>符号</th><th>值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：</p><ul><li>如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。</li><li>如果该值以 4 或 9 开头，使用  <strong>减法形式</strong>，表示从以下符号中减去一个符号，例如 4 是 5 (<code>V</code>) 减 1 (<code>I</code>): <code>IV</code> ，9 是 10 (<code>X</code>) 减 1 (<code>I</code>)：<code>IX</code>。仅使用以下减法形式：4 (<code>IV</code>)，9 (<code>IX</code>)，40 (<code>XL</code>)，90 (<code>XC</code>)，400 (<code>CD</code>) 和 900 (<code>CM</code>)。</li><li>只有 10 的次方（<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (<code>V</code>)，50 (<code>L</code>) 或 500 (<code>D</code>)。如果需要将符号附加 4 次，请使用  <strong>减法形式</strong>。</li></ul><p>给定一个整数，将其转换为罗马数字。</p><p><strong>示例 1：</strong></p><p>**输入：num = 3749</p><p><strong>输出：</strong> “MMMDCCXLIX”</p><p><strong>解释：</strong></p><p>3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)<br>700 = DCC 由于 500 (D) + 100 (C) + 100 (C)<br>40 = XL 由于 50 (L) 减 10 (X)<br>9 = IX 由于 10 (X) 减 1 (I)<br>注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位</p><p><strong>示例 2：</strong></p><p>**输入：num = 58</p><p><strong>输出：</strong>“LVIII”</p><p><strong>解释：</strong></p><p>50 = L<br>8 = VIII</p><p><strong>示例 3：</strong></p><p>**输入：num = 1994</p><p><strong>输出：</strong>“MCMXCIV”</p><p><strong>解释：</strong></p><p>1000 = M<br>900 = CM<br>90 = XC<br>4 = IV</p><p>最初想法是尝试通过<strong>逐位处理数字</strong>的方式将整数转换为罗马数字：</p><ol><li><strong>将数字转换为字符串并反转</strong>： 使用 reverseString(num.toString()) 将数字从高位到低位变为低位到高位（例如 1994 → “4991”）,从个位开始依次处理每个数位（个位、十位、百位、千位）</li><li><strong>为每个数位定义对应的罗马符号</strong>：<ul><li><code>个位（i===0）：1→"I", 5→"V", 10→"X"</code></li><li><code>十位（i===1）：1→"X", 5→"L", 10→"C"</code></li><li><code>百位（i===2）：1→"C", 5→"D", 10→"M"</code></li><li><code>千位（i===3）：直接用 "M" 重复</code></li></ul></li><li><strong>根据当前位上的数字（0-9）生成对应罗马表示</strong>：<ul><li>1-3：重复添加 “1” 的符号（curr1）</li><li>4：curr1 + curr2（如 “IV”）</li><li>5：curr2（如 “V”）</li><li>6-8：curr2 + 重复 (digit-5) 次 curr1</li><li>9：curr1 + curr3（如 “IX”）</li></ul></li><li><strong>使用数组 + unshift 收集符号</strong>： 因为已反转数字，低位先处理，使用 unshift（从数组头部插入）试图让高位符号最终出现在前面</li><li><strong>最后 join 成字符串返回</strong></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">let</span> curr1 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr2 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr3 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span><br>    str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-keyword">let</span> top = <span class="hljs-title function_">reverseString</span>(num.<span class="hljs-title function_">toString</span>());<br>  <span class="hljs-keyword">let</span> l = top.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">finalstr</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">nums</span>(<span class="hljs-params"><span class="hljs-attr">pos</span>: <span class="hljs-built_in">number</span></span>) {<br>    <span class="hljs-keyword">const</span> di = <span class="hljs-title class_">Number</span>(top[pos]);<br>    <span class="hljs-keyword">if</span> (di === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">4</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">5</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">8</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di - <span class="hljs-number">5</span>; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">9</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr3);<br>    }<br>  }<br>  <span class="hljs-keyword">while</span> (i &lt; l) {<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {<br>      curr1 = <span class="hljs-string">"I"</span>;<br>      curr2 = <span class="hljs-string">"V"</span>;<br>      curr3 = <span class="hljs-string">"X"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>      curr1 = <span class="hljs-string">"X"</span>;<br>      curr2 = <span class="hljs-string">"L"</span>;<br>      curr3 = <span class="hljs-string">"C"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) {<br>      curr1 = <span class="hljs-string">"C"</span>;<br>      curr2 = <span class="hljs-string">"D"</span>;<br>      curr3 = <span class="hljs-string">"M"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">const</span> vas = <span class="hljs-title class_">Number</span>(top[i]);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; vas; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">"M"</span>);<br>      }<br>      i++;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> finalstr.<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>}<br></code></pre></td></tr></table></figure><p>题目标准解法是<strong>贪心算法 + 值-符号映射表</strong>，从高位到低位匹配最大可能值，这个写法确实没有想出来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">valueSymbols</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>][] = [<br>        [<span class="hljs-number">1000</span>, <span class="hljs-string">"M"</span>], [<span class="hljs-number">900</span>, <span class="hljs-string">"CM"</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">"D"</span>], [<span class="hljs-number">400</span>, <span class="hljs-string">"CD"</span>],<br>        [<span class="hljs-number">100</span>,  <span class="hljs-string">"C"</span>], [<span class="hljs-number">90</span>,  <span class="hljs-string">"XC"</span>], [<span class="hljs-number">50</span>,  <span class="hljs-string">"L"</span>], [<span class="hljs-number">40</span>,  <span class="hljs-string">"XL"</span>],<br>        [<span class="hljs-number">10</span>,   <span class="hljs-string">"X"</span>], [<span class="hljs-number">9</span>,   <span class="hljs-string">"IX"</span>], [<span class="hljs-number">5</span>,   <span class="hljs-string">"V"</span>], [<span class="hljs-number">4</span>,   <span class="hljs-string">"IV"</span>],<br>        [<span class="hljs-number">1</span>,    <span class="hljs-string">"I"</span>]<br>    ];<br><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [value, <span class="hljs-built_in">symbol</span>] <span class="hljs-keyword">of</span> valueSymbols) {<br>        <span class="hljs-keyword">while</span> (num &gt;= value) {<br>            result += <span class="hljs-built_in">symbol</span>;<br>            num -= value;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>  和  <code>M</code>。</p><p><strong>字符</strong> <strong>数值</strong><br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000</p><p>例如， 罗马数字  <code>2</code>  写做  <code>II</code> ，即为两个并列的 1 。<code>12</code>  写做  <code>XII</code> ，即为  <code>X</code> + <code>II</code> 。 <code>27</code>  写做  <code>XXVII</code>, 即为  <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  <code>IIII</code>，而是  <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code>  可以放在  <code>V</code> (5) 和  <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code>  可以放在  <code>L</code> (50) 和  <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code>  可以放在  <code>D</code> (500) 和  <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> s = “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> s = “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> s = “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> s = “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> s = “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p><p>直接从左到右遍历字符串，比较当前符号与下一个符号的值：</p><ul><li>如果当前值 &lt; 下一个值，则减去当前值（形成减法组合）。</li><li>否则加上当前值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> map = {<br>    <span class="hljs-attr">I</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">V</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">X</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">L</span>: <span class="hljs-number">50</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">D</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">M</span>: <span class="hljs-number">1000</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> current = map[s[i]];<br>    <span class="hljs-keyword">const</span> next = map[s[i + <span class="hljs-number">1</span>]];<br><br>    <span class="hljs-keyword">if</span> (next &amp;&amp; current &lt; next) {<br>      res += next - current;<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      res += current;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀</p><p>如果不存在公共前缀，返回空字符串  <code>""</code></p><p><strong>示例 1：</strong></p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p><strong>示例 2：</strong></p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀</p><p>题解比较简单，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params"><span class="hljs-attr">strs</span>: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (strs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> char = strs[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (i === strs[j].<span class="hljs-property">length</span> || strs[j][i] !== char) {<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i);<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></table></figure><p>主要就是注意一个写法，在 JavaScript（以及 TypeScript）中，<code>strs[0][i]</code> 是一种链式索引访问（chained indexing）的写法，用于访问二维结构或嵌套可索引对象中的元素</p><p>假设 <code>strs = ["flower", "flow", "flight"]</code>，循环变量 <code>i = 2</code> 时：</p><ul><li><code>strs[0] → "flower"</code></li><li><code>strs[0][2] → "flower"</code> 的第 2 个字符 → <code>'o'</code></li></ul><p>同理：</p><ul><li><code>strs[1][2] → "flow"[2] → 'o'</code></li><li><code>strs[2][2] → "flight"[2] → 'i'</code></li></ul><p>通过比较 <code>strs[0][i]</code>与其他字符串的 <code>strs[j][i]</code> 是否相等，来判断第 i 位置是否仍属于公共前缀</p><h3 id="等价的写法"><a href="#等价的写法" class="headerlink" title="等价的写法"></a>等价的写法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> firstStr = strs[<span class="hljs-number">0</span>];<br>firstStr[i];<br><br><span class="hljs-comment">// 使用 charAt 方法</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">charAt</span>(i);<br><br><span class="hljs-comment">// 使用 at 方法 ES2022+</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">at</span>(i);<br></code></pre></td></tr></table></figure><hr><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>一个整数数组  <code>nums</code> ，判断是否存在三元组  <code>[nums[i], nums[j], nums[k]]</code>  满足  <code>i != j</code>、<code>i != k</code>  且  <code>j != k</code> ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code> ，返回所有和为  <code>0</code>  且不重复的三元组，且答案中不可以包含重复的三元组</p><p>示例 1：<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code><br>输出：<code>[[-1,-1,2],[-1,0,1]]</code><br>解释：<br><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code><br><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code><br><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code><br>不同的三元组是 <code>[-1,0,1]</code>和 <code>[-1,-1,2]</code></p><p>示例 2：<br>输入：<code>nums = [0,1,1]</code><br>输出：<code>[]</code><br>解释：唯一可能的三元组和不为 0</p><p>示例 3：<br>输入：<code>nums = [0,0,0]</code><br>输出：<code>[[0,0,0]]</code><br>解释：唯一可能的三元组和为 0</p><p>最开始是想直接 n^3 暴力解，然后用 Set 去重</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br>  <span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = j + <span class="hljs-number">1</span>; k &lt; nums.<span class="hljs-property">length</span>; k++) {<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">const</span> triplet = [nums[i], nums[j], nums[k]];<br>          <span class="hljs-keyword">const</span> key = triplet.<span class="hljs-title function_">join</span>(<span class="hljs-string">","</span>);<br>          <span class="hljs-keyword">if</span> (!seen.<span class="hljs-title function_">has</span>(key)) {<br>            seen.<span class="hljs-title function_">add</span>(key);<br>            result.<span class="hljs-title function_">push</span>(triplet);<br>          }<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>很明显，时间复杂度特别高，直接爆了</p><p>解法的话依旧双指针降维</p><h3 id="第一步：排序"><a href="#第一步：排序" class="headerlink" title="第一步：排序"></a>第一步：排序</h3><p>排序后可以：利用有序数组的特性，通过指针移动快速缩小范围</p><p>比如原数组是 <code>[-1,0,1,2,-1,-4]</code>，排序后变成 <code>[-4,-1,-1,0,1,2]</code>。这时候，相同的元素（比如两个 <code>-1</code>）会挨在一起，方便后续去重（重复元素会相邻，容易跳过）</p><h3 id="第二步：固定一个数，双指针找另外两个数"><a href="#第二步：固定一个数，双指针找另外两个数" class="headerlink" title="第二步：固定一个数，双指针找另外两个数"></a>第二步：固定一个数，双指针找另外两个数</h3><p>排序后，我们固定第一个数 <code>nums[i]</code>，然后用左指针 <code>left</code> 指向 <code>i+1</code>，右指针 <code>right</code> 指向数组末尾。三个数的和 <code>sum = nums[i] + nums[left] + nums[right]</code>：</p><ul><li>如果 <code>sum &lt; 0</code>：说明需要更大的数，左指针右移（<code>left++</code>）；</li><li>如果 <code>sum &gt; 0</code>：说明需要更小的数，右指针左移（<code>right--</code>）；</li><li>如果 <code>sum = 0</code>：找到一个有效三元组，记录结果。</li></ul><h3 id="第三步：去重"><a href="#第三步：去重" class="headerlink" title="第三步：去重"></a>第三步：去重</h3><p>具体分三种情况：</p><h4 id="1-固定数-nums-i-重复"><a href="#1-固定数-nums-i-重复" class="headerlink" title="1. 固定数 nums[i] 重复"></a>1. 固定数 <code>nums[i]</code> 重复</h4><p>比如排序后的数组是 <code>[-4,-1,-1,0,1,2]</code>，当 <code>i=1</code>（<code>nums[i]=-1</code>）时，和 <code>i=2</code>（<code>nums[i]=-1</code>）时的情况是一样的。这时候需要跳过重复的 <code>nums[i]</code>。</p><p><strong>判断条件</strong>：如果 <code>i &gt; 0</code> 且 <code>nums[i] === nums[i-1]</code>，说明当前 <code>nums[i]</code> 和前一个数重复，直接跳过。</p><h4 id="2-左指针-nums-left-重复"><a href="#2-左指针-nums-left-重复" class="headerlink" title="2. 左指针 nums[left] 重复"></a>2. 左指针 <code>nums[left]</code> 重复</h4><p>假设已经找到 <code>i=0</code>（<code>nums[i]=-4</code>），<code>left=1</code>（<code>nums[left]=-1</code>），<code>right=5</code>（<code>nums[right]=2</code>），此时和为 <code>-4 + (-1) + 2 = -3</code>，不满足条件。左指针右移到 <code>left=2</code>（<code>nums[left]=-1</code>），这时候 <code>nums[left]</code> 和前一个 <code>left</code> 位置的数重复，需要跳过。</p><p><strong>判断条件</strong>：当找到和为 0 的三元组后，需要循环判断 <code>nums[left] === nums[left+1]</code>，如果是，左指针右移，直到遇到不同的数。</p><h4 id="3-右指针-nums-right-重复"><a href="#3-右指针-nums-right-重复" class="headerlink" title="3. 右指针 nums[right] 重复"></a>3. 右指针 <code>nums[right]</code> 重复</h4><p>同样，找到和为 0 的三元组后，如果 <code>nums[right]</code> 和前一个 <code>right</code> 位置的数重复（比如 <code>nums[right]=1</code> 和 <code>nums[right-1]=1</code>），需要跳过。</p><p><strong>判断条件</strong>：循环判断 <code>nums[right] === nums[right-1]</code>，如果是，右指针左移，直到遇到不同的数。</p><ol><li><strong>先排序</strong>：nums.sort((a, b) =&gt; a - b)，使得相同元素相邻，便于跳过重复。</li><li><strong>外层循环跳过重复的 i</strong>：如果当前 nums[i] 与前一个相同，则跳过（避免同一值的 i 产生重复三元组）。</li><li><strong>内层双指针移动时跳过重复的 left 和 right</strong>：找到一个有效三元组后，跳过所有相同的 left 和 right 值。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 先排序，关键一步</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-comment">// 跳过重复的 nums[i]</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) {<br>      <span class="hljs-keyword">continue</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br><br>      <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) {<br>        result.<span class="hljs-title function_">push</span>([nums[i], nums[left], nums[right]]); <span class="hljs-comment">//加入结果</span><br><br>        <span class="hljs-comment">// 跳过重复的 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) {<br>          left++;<br>        }<br>        <span class="hljs-comment">// 跳过重复的 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) {<br>          right--;<br>        }<br><br>        left++;<br>        right--;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> {<br>        right--;<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给你一个长度为  <code>n</code>  的整数数组  <code>nums</code>  和 一个目标值  <code>target</code>。请你从  <code>nums</code>  中选出三个整数，使它们的和与  <code>target</code>  最接近，返回这三个数的和<br>假定每组输入只存在恰好一个解</p><p>示例：<br>输入：nums = <code>[-1,2,1,-4]</code> , <code>target = 1</code><br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)</p><p>解法和三数之和一样都是双指针解题<br>多一些判断而已</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> closestSum = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> minDiff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(closestSum - target);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br>      <span class="hljs-keyword">const</span> diff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(sum - target);<br><br>      <span class="hljs-keyword">if</span> (diff &lt; minDiff) {<br>        minDiff = diff;<br>        closestSum = sum;<br>      }<br><br>      <span class="hljs-keyword">if</span> (sum &lt; target) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) {<br>        right--;<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> sum;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> closestSum;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="17-电话号码的的数字组合"><a href="#17-电话号码的的数字组合" class="headerlink" title="17.电话号码的的数字组合"></a>17.电话号码的的数字组合</h2><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按  <strong>任意顺序</strong>  返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p class='item-img' data-src='https://pic.leetcode.cn/1752723054-mfIHZs-image.png'><img src="https://pic.leetcode.cn/1752723054-mfIHZs-image.png" alt="电话按键" width="300"></p><p>示例 1：<br>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：<br>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p><p>练度不够，还得继续练</p><p>主要解法是迭代法：</p><ul><li>外层循环遍历 digits 中的每一个数字（从左到右）。</li><li>对于当前数字 digit：<ul><li>获取其对应的所有可能字母 letters（如 ‘2’ → ‘abc’）。</li><li>创建一个临时数组 temp，用于存储“加入当前数字字母后的新组合”。</li><li>遍历当前 result 中的每一个已有组合 prev（这些是处理前几个数字得到的所有组合）。</li><li>对 letters 中的每一个 letter，将其追加到 prev 后面，形成新字符串 prev + letter，并加入 temp。</li></ul></li><li>一轮结束后，将 temp 赋值给 result，成为下一轮的“已有组合”。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params"><span class="hljs-attr">digits</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>[] {<br>  <span class="hljs-keyword">if</span> (digits.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: { [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> } = {<br>    <span class="hljs-string">"2"</span>: <span class="hljs-string">"abc"</span>,<br>    <span class="hljs-string">"3"</span>: <span class="hljs-string">"def"</span>,<br>    <span class="hljs-string">"4"</span>: <span class="hljs-string">"ghi"</span>,<br>    <span class="hljs-string">"5"</span>: <span class="hljs-string">"jkl"</span>,<br>    <span class="hljs-string">"6"</span>: <span class="hljs-string">"mno"</span>,<br>    <span class="hljs-string">"7"</span>: <span class="hljs-string">"pqrs"</span>,<br>    <span class="hljs-string">"8"</span>: <span class="hljs-string">"tuv"</span>,<br>    <span class="hljs-string">"9"</span>: <span class="hljs-string">"wxyz"</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">""</span>];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> digit <span class="hljs-keyword">of</span> digits) {<br>    <span class="hljs-keyword">const</span> letters = map[digit];<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">temp</span>: <span class="hljs-built_in">string</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prev <span class="hljs-keyword">of</span> result) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> letter <span class="hljs-keyword">of</span> letters) {<br>        temp.<span class="hljs-title function_">push</span>(prev + letter);<br>      }<br>    }<br>    result = temp;<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>从“空组合”开始，依次将每个新数字的字母可能性“横向扩展”到所有已有组合上，最终得到所有完整组合</p><hr><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><p>给你一个由  <code>n</code>  个整数组成的数组  <code>nums</code> ，和一个目标值  <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组  <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code>  和  <code>d</code>  互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>输入：<code>nums = [1,0,-1,0,-2,2]</code>, <code>target = 0</code><br>输出：<code>[[-2,-1,1,2] , [-2,0,0,2] , [-1,0,0,1]]</code></p><p>输入：<code>nums = [2,2,2,2,2]</code>, <code>target = 8</code><br>输出：<code>[[2,2,2,2]]</code></p><p><strong>就是三数之和的基础上再套上一层 for 循环</strong></p><p>题解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number[][]</span>}</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) {<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);  <span class="hljs-comment">// 先排序</span><br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> result = [];<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) {<br>        <span class="hljs-comment">// 去重 i</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前四个最小值之和已大于 target，直接终止</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前 i 与后面三个最大值之和小于 target，跳过本次 i</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) {<br>            <span class="hljs-comment">// 去重 j</span><br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">let</span> left = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (left &lt; right) {<br>                <span class="hljs-keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];<br><br>                <span class="hljs-keyword">if</span> (sum === target) {<br>                    result.<span class="hljs-title function_">push</span>([nums[i], nums[j], nums[left], nums[right]]);<br><br>                    <span class="hljs-comment">// 去重 left</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-comment">// 去重 right</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) right--;<br><br>                    left++;<br>                    right--;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {<br>                    left++;<br>                } <span class="hljs-keyword">else</span> {<br>                    right--;<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> result;<br>};<br></code></pre></td></tr></table></figure><hr><h2 id="19-删除链表的第-n-个节点"><a href="#19-删除链表的第-n-个节点" class="headerlink" title="19. 删除链表的第 n 个节点"></a>19. 删除链表的第 n 个节点</h2><p>给你一个链表，删除链表的倒数第  <code>n</code>  个结点，并且返回链表的头结点</p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>输入：head = [1], n = 1<br>输出：[]</p><p>自己写的一版，思路主要是遍历一趟链表搞到 length，再用 n 确定 index 来定位要删的位置，最后再删掉该节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> curr = head;<br>  <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    len++;<br>    curr = curr.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">if</span> (len === n) {<br>    <span class="hljs-keyword">return</span> head?.<span class="hljs-property">next</span> ?? <span class="hljs-literal">null</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> index = len - n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> delindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">let</span> del = head;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  prev.<span class="hljs-property">next</span> = head;<br>  <span class="hljs-keyword">while</span> (del !== <span class="hljs-literal">null</span>) {<br>    prev = prev.<span class="hljs-property">next</span>;<br>    del = del.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (delindex === index) {<br>      prev.<span class="hljs-property">next</span> = del.<span class="hljs-property">next</span>;<br>    }<br>    delindex++;<br>  }<br>  <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><p>题解的话主要是用快慢指针,这个思路挺不错的其实</p><ul><li>引入虚拟头结点 dummy</li><li>让 fast 指针先走 n 步</li><li>然后 slow 与 fast 同步移动，当 fast 到达末尾时，slow 指向的就是倒数第 n 个节点的前一个节点</li><li>执行 slow.next = slow.next.next 删除目标节点</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 边界：空链表或 n 无效直接返回</span><br>  <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  dummy.<span class="hljs-property">next</span> = head;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">fast</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">slow</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br><br>  <span class="hljs-comment">// fast 先走 n 步</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    fast = fast!.<span class="hljs-property">next</span>; <span class="hljs-comment">// n 合法时不会为 null</span><br>  }<br><br>  <span class="hljs-comment">// fast 和 slow 同步移动，直到 fast 到达末尾</span><br>  <span class="hljs-keyword">while</span> (fast!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    fast = fast!.<span class="hljs-property">next</span>;<br>    slow = slow!.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 此时 slow 指向倒数第 n 个节点的前一个节点</span><br>  <span class="hljs-keyword">if</span> (slow!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    slow!.<span class="hljs-property">next</span> = slow!.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p>给定一个只包括  <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>  的字符串  <code>s</code> ，判断字符串是否有效</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例 1：<br>输入：<code>s = "()"</code><br>输出：true</p><p>示例 2：<br>输入：<code>s = "()[]{}"</code><br>输出：true</p><p>示例 3：<br>输入：<code>s = "(]"</code><br>输出：false</p><p>示例 4：<br>输入：<code>s = "([])"</code><br>输出：true</p><p>示例 5：<br>输入：<code>s = "([)]"</code><br>输出：false</p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code>  仅由括号  <code>'()[]{}'</code>  组成</li></ul><p>思路不难，主要就是栈匹配问题</p><ul><li>开括号 → 入栈 <code>stk.push(s[i])</code></li><li>闭括号 → 元素出栈 <code>stk.pop()</code> 进行匹配  </li><li>若栈空或栈顶不匹配 → 立即返回 false；否则弹出栈顶</li><li>遍历结束 → 栈空返回 true，否则 false</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">stk</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"("</span> || s[i] === <span class="hljs-string">"["</span> || s[i] === <span class="hljs-string">"{"</span>) {<br>      stk.<span class="hljs-title function_">push</span>(s[i]);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">")"</span> || s[i] === <span class="hljs-string">"]"</span> || s[i] === <span class="hljs-string">"}"</span>) {<br>      <span class="hljs-keyword">if</span> (stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>      <span class="hljs-keyword">let</span> curr = stk.<span class="hljs-title function_">pop</span>()!;<br>      <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"("</span> &amp;&amp; s[i] === <span class="hljs-string">")"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"["</span> &amp;&amp; s[i] === <span class="hljs-string">"]"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"{"</span> &amp;&amp; s[i] === <span class="hljs-string">"}"</span>) {<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是力扣速刷第二期awa&lt;br&gt;说是速刷其实卡了挺久&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-关于Javascript/TypeScript 的顺序表，链表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/46758.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/46758.html</id>
    <published>2025-12-26T04:16:12.000Z</published>
    <updated>2025-12-26T04:42:12.018Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。</p><p>以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并附带说明。</p><h2 id="1-顺序表（基于数组的动态顺序表）"><a href="#1-顺序表（基于数组的动态顺序表）" class="headerlink" title="1. 顺序表（基于数组的动态顺序表）"></a>1. 顺序表（基于数组的动态顺序表）</h2><p>顺序表的核心是连续存储，使用数组实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建顺序表</span><br><span class="hljs-keyword">const</span> seqList = [];<br><br><span class="hljs-comment">// 添加元素</span><br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">10</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// 在索引 1 处插入 15</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">// [10, 15, 20, 30]</span><br><br><span class="hljs-comment">// 修改索引 2 处的元素</span><br>seqList[<span class="hljs-number">2</span>] = <span class="hljs-number">25</span>;           <span class="hljs-comment">// [10, 15, 25, 30]</span><br><br><span class="hljs-comment">// 删除索引 0 处的元素</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">// [15, 25, 30]</span><br><br><span class="hljs-comment">// 输出长度和内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'长度:'</span>, seqList.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内容:'</span>, seqList);         <span class="hljs-comment">// [15, 25, 30]</span><br></code></pre></td></tr></table></figure><p>手动实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity = <span class="hljs-number">10</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity);  <span class="hljs-comment">// 存储元素</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 当前元素个数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;         <span class="hljs-comment">// 当前容量</span><br>    }<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 扩容（当 size === capacity 时）</span><br>    <span class="hljs-title function_">resize</span>(<span class="hljs-params">newCapacity</span>) {<br>        <span class="hljs-keyword">const</span> newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(newCapacity);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            newData[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = newData;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = newCapacity;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 扩容为两倍</span><br>        }<br>        <span class="hljs-comment">// 从后向前移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>; i &gt;= index; i--) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在末尾添加元素</span><br>    <span class="hljs-title function_">append</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 删除索引 index 处的元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">const</span> removed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>        <span class="hljs-comment">// 从前向后移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-comment">// 可选：缩容（避免频繁缩容，通常当 size == capacity / 4 时缩为一半）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">4</span>)) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">2</span>));<br>        }<br>        <span class="hljs-keyword">return</span> removed;<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'SequentialList: ['</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            str += <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>            <span class="hljs-keyword">if</span> (i !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>) str += <span class="hljs-string">', '</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> seqList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequentialList</span>();<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>seqList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>seqList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// SequentialList: [1, 3, 2]</span><br></code></pre></td></tr></table></figure><h2 id="2-链表（单向链表）"><a href="#2-链表（单向链表）" class="headerlink" title="2. 链表（单向链表）"></a>2. 链表（单向链表）</h2><p>链表使用节点分散存储，支持高效的插入和删除（O(1)），但随机访问较慢（O(n)）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();  <span class="hljs-comment">// 虚拟头结点，便于操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(element);<br>        node.<span class="hljs-property">next</span> = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在链表头部添加元素</span><br>    <span class="hljs-title function_">addFirst</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">0</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 在链表末尾添加元素</span><br>    <span class="hljs-title function_">addLast</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        cur.<span class="hljs-property">val</span> = element;<br>    }<br><br>    <span class="hljs-comment">// 删除索引处元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> removedNode = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = removedNode.<span class="hljs-property">next</span>;<br>        removedNode.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-keyword">return</span> removedNode.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'LinkedList: ['</span>;<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            str += cur.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">next</span>) str += <span class="hljs-string">' -&gt; '</span>;<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">1</span>);<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">2</span>);<br>linkedList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>linkedList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// LinkedList: [1 -&gt; 3 -&gt; 2]</span><br></code></pre></td></tr></table></figure><hr><h2 id="LRU-缓存的实现（使用双向链表-HashMap）"><a href="#LRU-缓存的实现（使用双向链表-HashMap）" class="headerlink" title="LRU 缓存的实现（使用双向链表 + HashMap）"></a>LRU 缓存的实现（使用双向链表 + HashMap）</h2><p>LRU（Least Recently Used）缓存是一种常见的数据结构，用于实现固定容量缓存，当容量满时淘汰最近最少使用的元素。在 JavaScript 中，最高效的实现方式是结合<strong>双向链表</strong>（控制访问顺序）和<strong>Map</strong>（或对象）作为哈希表（实现 O(1) 访问）</p><h3 id="JS实现："><a href="#JS实现：" class="headerlink" title="JS实现："></a>JS实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;        <span class="hljs-comment">// 缓存容量</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();          <span class="hljs-comment">// 使用 Map 作为哈希表，保持插入顺序并支持 O(1) 操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟头节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟尾节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;      <span class="hljs-comment">// 初始化链表：head &lt;-&gt; tail</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将节点移动到链表头部（表示最近使用）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">node</span> - 要移动的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_moveToHead</span>(<span class="hljs-params">node</span>) {<br>        <span class="hljs-comment">// 先从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>;<br><br>        <span class="hljs-comment">// 插入到头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从链表尾部移除节点（淘汰最久未使用的）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 被移除的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_removeTail</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>;<br>        lastNode.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any</span>} 值，如果不存在返回 -1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>        }<br>        <span class="hljs-comment">// 刷新访问顺序：将节点移到头部</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            <span class="hljs-comment">// 已存在：更新值并移到头部</span><br>            existingNode.<span class="hljs-property">value</span> = value;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 不存在：创建新节点</span><br>            <span class="hljs-keyword">const</span> newNode = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入到头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 检查容量是否超出</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeTail</span>();  <span class="hljs-comment">// 移除尾部节点</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);      <span class="hljs-comment">// 从哈希表中删除</span><br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 可选：打印当前缓存顺序（用于调试）</span><br>    <span class="hljs-title function_">printCache</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> result = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current.key}</span>:<span class="hljs-subst">${current.value}</span>`</span>);<br>            current = current.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache (most recent -&gt; least recent):'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2（刷新顺序）</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br><br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);            <span class="hljs-comment">// 容量满，淘汰最久未使用的 1</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 4:4 -&gt; 2:2 -&gt; 3:3</span><br></code></pre></td></tr></table></figure><h3 id="TS实现"><a href="#TS实现" class="headerlink" title="TS实现"></a>TS实现</h3><p>使用双向链表结合 Map（Map 在 TypeScript 中天然支持泛型）实现 O(1) 时间复杂度的 get 和 put 操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 双向链表节点接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>    <span class="hljs-attr">key</span>: K;<br>    <span class="hljs-attr">value</span>: V;<br>    <span class="hljs-attr">prev</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K = <span class="hljs-built_in">number</span>, V = <span class="hljs-built_in">number</span>&gt; {<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span>;                <span class="hljs-comment">// 缓存容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">cache</span>: <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;;        <span class="hljs-comment">// 哈希表：键到节点的映射</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">head</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟尾节点</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">// 将节点移动到头部（最近使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">moveToHead</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-comment">// 从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>!;<br><br>        <span class="hljs-comment">// 插入头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">// 移除尾部节点（最久未使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">removeTail</span>(): <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>!;<br>        lastNode.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">// 获取值</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: K): V | -<span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(node);  <span class="hljs-comment">// 刷新访问顺序</span><br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">// 放入键值对</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            existingNode.<span class="hljs-property">value</span> = value;  <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">const</span> <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 超出容量时淘汰</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeTail</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 调试：打印缓存顺序（最近 -&gt; 最久）</span><br>    <span class="hljs-title function_">printCache</span>(): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current!.key}</span>:<span class="hljs-subst">${current!.value}</span>`</span>);<br>            current = current!.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br></code></pre></td></tr></table></figure><h2 id="链表反转的实现"><a href="#链表反转的实现" class="headerlink" title="链表反转的实现"></a>链表反转的实现</h2><p>单向链表的反转实现，包括迭代和递归两种方式</p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 单向链表节点定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params">arr</span>) {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 方法一：迭代反转（推荐，空间复杂度 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 前驱指针</span><br>    <span class="hljs-keyword">let</span> current = head;      <span class="hljs-comment">// 当前指针</span><br>    <span class="hljs-keyword">let</span> next = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 临时存储下一节点</span><br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        next = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev; <span class="hljs-comment">// 反转指针</span><br>        prev = current;      <span class="hljs-comment">// 前驱前进</span><br>        current = next;      <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// prev 成为新头节点</span><br>}<br><br><span class="hljs-comment">// 方法二：递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-comment">// 递归终止条件：空链表或只有一个节点</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br><br>    <span class="hljs-comment">// 递归反转后续链表</span><br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br><br>    <span class="hljs-comment">// 反转当前节点与下一节点的指向</span><br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> newHead;  <span class="hljs-comment">// 新头节点始终是原链表的尾节点</span><br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIterative = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIterative);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list2);  <span class="hljs-comment">// 6 -&gt; 7 -&gt; 8</span><br><br><span class="hljs-keyword">const</span> reversedRecursive = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRecursive);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><h3 id="TS实现-1"><a href="#TS实现-1" class="headerlink" title="TS实现"></a>TS实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 单向链表节点类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val ?? <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next ?? <span class="hljs-literal">null</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">const</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 迭代反转（推荐，空间 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">current</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = head;<br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">const</span> next = current.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev;        <span class="hljs-comment">// 反转指针</span><br>        prev = current;             <span class="hljs-comment">// 前驱前进</span><br>        current = next;             <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// 新头节点</span><br>}<br><br><span class="hljs-comment">// 递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIter = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIter);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-keyword">const</span> reversedRec = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRec);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><p>DFA:</p><ul><li><strong>顺序表</strong>：适合随机访问（O(1)），插入/删除较慢（O(n)），实现简单，内存连续</li><li><strong>链表</strong>：适合频繁插入/删除（O(1)），随机访问慢（O(n)），内存分散，支持动态扩展, 链表常用于特定算法（如 LRU 缓存、链表反转等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。&lt;/p&gt;
&lt;p&gt;以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
