<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes|笔记站</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2025-12-27T21:46:12.965Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025-12-27-前端画布设计Vol.3 实现CRDT</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/60473.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/60473.html</id>
    <published>2025-12-27T21:46:01.000Z</published>
    <updated>2025-12-27T21:46:12.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CRDT机制处理并发修改"><a href="#CRDT机制处理并发修改" class="headerlink" title="CRDT机制处理并发修改"></a>CRDT机制处理并发修改</h2><p>Yjs使用CRDT数据结构，这是一种能自动解决冲突的数据结构，即使在多人离线状态下也能处理数据冲突：</p><ol><li><strong>自动冲突解决</strong>：Yjs使用偏序和唯一标识符来解决并发修改，无需中心服务器即可处理冲突</li><li><strong>操作合并</strong>：当多个用户同时修改同一文档时，Yjs能够自动合并这些更改</li></ol><h2 id="离线和重新连接处理"><a href="#离线和重新连接处理" class="headerlink" title="离线和重新连接处理"></a>离线和重新连接处理</h2><p>当多个用户同时掉线时，项目采用以下策略处理：</p><ol><li><strong>本地优先架构</strong>：每个客户端都维护完整的Yjs文档，离线时所有更改保存在本地</li><li><strong>重新连接同步</strong>：当用户重新连接时，Hocuspocus会处理：<ul><li>将本地更改发送到服务器</li><li>接收其他用户在此期间的更改</li><li>自动合并所有更改</li></ul></li></ol><h2 id="后端同步逻辑"><a href="#后端同步逻辑" class="headerlink" title="后端同步逻辑"></a>后端同步逻辑</h2><p>在ALD_Backend/src/collab.ts中，Hocuspocus服务器处理多个客户端的同步：</p><ol><li><strong>文档状态管理</strong>：服务器维护房间的最新状态</li><li><strong>更新合并</strong>：使用<code>Y.applyUpdate</code>和<code>Y.encodeStateAsUpdate</code>来合并来自不同客户端的更新</li><li><strong>状态持久化</strong>：使用数据库扩展将合并后的状态持久化到数据库</li></ol><h2 id="潜在问题与解决方案"><a href="#潜在问题与解决方案" class="headerlink" title="潜在问题与解决方案"></a>潜在问题与解决方案</h2><p>虽然Yjs和Hocuspocus能处理大部分情况，但多个用户同时离线并进行大量修改后重新连接时，仍可能遇到一些挑战：</p><ol><li><strong>合并策略</strong>：对于同一元素的冲突修改，Yjs会根据内部算法进行合并，如文本编辑通常会保留所有更改</li><li><strong>一致性保证</strong>：最终所有客户端都会达到一致状态，但中间状态可能不同</li></ol><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>为了更好地处理多人同时掉线的情况，可以考虑：</p><ol><li><strong>添加版本信息</strong>：在用户界面显示最后同步时间，让用户了解文档状态</li><li><strong>冲突可视化</strong>：在特定情况下高亮显示可能的冲突区域</li><li><strong>通知机制</strong>：当多个用户同时修改相同元素时，提供通知或确认</li></ol><p>这种基于CRDT的设计确保了即使在多个用户同时离线的情况下，当他们重新连接时，系统仍然能够自动同步所有更改并达到一致状态，这是Yjs作为协同编辑框架的核心优势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CRDT机制处理并发修改&quot;&gt;&lt;a href=&quot;#CRDT机制处理并发修改&quot; class=&quot;headerlink&quot; title=&quot;CRDT机制处理并发修改&quot;&gt;&lt;/a&gt;CRDT机制处理并发修改&lt;/h2&gt;&lt;p&gt;Yjs使用CRDT数据结构，这是一种能自动解决冲突的数据结构</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-27-关于画布项目的相关考虑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/2357.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/2357.html</id>
    <published>2025-12-27T20:52:15.000Z</published>
    <updated>2025-12-28T09:26:34.103Z</updated>
    
    <content type="html"><![CDATA[<p>当候选人向面试官展示 GitHub 仓库 <a href="https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com">https://github.com/Zhongye1/BDdraw_DEV</a>（一个现代协作式 2D 画布编辑器）时，面试官通常会以此项目为切入点，进行针对性较强的技术深度考察。该项目技术栈先进（React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8），涉及高性能渲染、无限画布、撤销/重做、实时协作等复杂功能，因此问题往往聚焦于性能优化、状态管理、图形渲染、架构设计以及实际工程实践。</p><h3 id="1-项目整体介绍与架构设计"><a href="#1-项目整体介绍与架构设计" class="headerlink" title="1. 项目整体介绍与架构设计"></a>1. 项目整体介绍与架构设计</h3><p><strong>请整体介绍一下 BDdraw_DEV 项目的主要功能、目标用户以及它解决了哪些实际问题？</strong></p><blockquote><p>BDdraw_DEV 是一个现代化的协同 2D 画布编辑器，采用 React + TypeScript + PixiJS 技术栈构建。该项目提供多种基本图形（矩形、圆形、菱形、线条、箭头、画笔等）元素的绘制，支持背景色、边框宽度、边框颜色等图形属性设置、富文本编辑、图片插入与滤镜处理，支持无限画布缩放、拖拽、提供 minimap，实现元素选择、分组、旋转、调整大小，支持撤销重做，快捷键，数据持久化，本地优先编辑，海量元素处理等交互功能。</p><p>该项目作为一个集成协同编辑、离线编辑的无限画布，来解决团队协作协作效率和同步的问题</p></blockquote><p><strong>项目架构是如何设计的？为什么选择将 React 用于 UI 层、Zustand 用于状态管理、PixiJS 用于渲染层分离？</strong></p><blockquote><p>项目的核心在于其三层架构设计：React 负责 UI 层、Zustand 管理状态层、PixiJS 处理渲染层，实现数据驱动视图的模式。其便于实现撤销/重做、数据持久化和多人协同编辑等高级功能</p><p>其优势在于：<br>解耦设计：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展<br>便于协同：所有状态都集中管理在 Zustand Store 中，便于实现多人协同编辑<br>易于撤销/重做：通过保存和恢复 Store 的快照实现完整的撤销/重做功能<br>可持久化：状态数据可以轻松序列化/反序列化，便于保存和传输</p></blockquote><p><strong>项目是如何组织目录结构的（例如 src/lib、src/stores、src/Pixi_STM_modules）？这种模块化设计带来了哪些好处？</strong></p><p><em>主要是分为五个模块：</em></p><ol><li><p><strong>*src/api</strong> - API 客户端和类型定义（处理前后端通信）*</p><ul><li><em>types - API 类型定义</em></li><li><em>utils - API 工具函数</em></li><li><em>API 服务封装和客户端工具</em></li></ul></li><li><p><strong>*src/components</strong> - React UI 组件（各种 UI 组件）*</p><ul><li><em>canvas_toolbar - 画布工具栏组件</em></li><li><em>collaboration - 协作功能组件</em></li><li><em>header - 页面头部组件</em></li><li><em>property-panel - 属性面板组件</em></li><li><em>richtext_editor - 富文本编辑器组件</em></li></ul></li><li><p><strong>*src/hooks</strong> - 自定义 React Hooks*</p><ul><li><em>状态管理（简单的本地存储，用于存储用户偏好、UI 状态等）</em></li><li><em>快捷键处理</em></li></ul></li><li><p><strong>*src/lib</strong> - 工具库和核心功能模块*</p><ul><li><em>AddElementCommand.ts、RemoveElementCommand.ts、UndoRedoManager.ts - 命令模式实现</em></li><li><em>constants.ts - 常量定义</em></li><li><em>utils.ts - 通用工具函数</em></li></ul></li><li><p><strong>*src/pages</strong> - 页面组件*</p><ul><li><em>auth - 认证相关页面</em></li><li><em>home - 主页</em></li><li><em>room - 房间管理页面</em></li></ul><p><strong>*src/pages/canvas/Pixi_STM_modules</strong> - Pixi.js 状态管理模块*<br><em>- core - 核心类和初始化逻辑()</em><br><em>- interaction - 交互处理模块(例如拖拽、缩放、选择等)</em><br><em>- utils - 工具函数目录(各项操作的封装)</em><br><em>- shared - 共享类型定义</em></p></li><li><p><strong>*src/stores</strong> - 状态管理（<strong>Yjs + IndexedDB</strong> - 复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）*</p><ul><li><em>canvasStore.ts - 画布状态管理</em></li><li><em>persistenceStore.ts - 持久化状态管理</em></li><li><em>themeStore.ts - 主题状态管理</em></li></ul></li></ol><p>**项目中如何处理前端与后端（ALD_Backend）的交互？</p><blockquote><p>该项目前后端分离,前后端交互采用 REST API，前端通过 Axios 客户端与后端进行通信。</p></blockquote><ol><li><p>API 客户端设计</p><p> 主要使用axios来实现<br> Axios 是一个基于 Promise 的网络请求库，用于在浏览器和 Node.js 中进行 HTTP 请求，并支持请求/响应拦截、取消，并发请求，自动转换数据等功能</p></li><li><p>API 服务层</p></li></ol><ul><li>apiService.ts  提供了封装好的 API 调用方法</li><li>包括用户认证（注册、登录）、房间管理（创建、列出、搜索、删除房间）等功能</li><li>每个 API 调用都使用  makeCancelableRequest  包装，支持请求取消</li></ul><ol><li>认证机制</li></ol><ul><li>使用 JWT Token 进行身份验证</li><li>通过  setAuthToken  和  clearAuthToken  管理认证状态</li><li>后端通过  <code>onAuthenticate</code>  钩子验证用户权限</li></ul><hr><p><strong>实时协作部分是如何实现的？</strong></p><p>实时协作功能通过 Yjs、Hocuspocus 和 IndexedDB 实现，为离线优先架构：</p><ol><li>前端协作层</li></ol><ul><li>使用 Yjs 的 CRDT 数据结构实现多客户端状态同步</li><li>通过  <code>HocuspocusProvider</code>  连接到后端 WebSocket 服务器</li><li>结合 IndexedDB 持久化，实现离线编辑功能</li></ul><ol><li>后端协作服务器</li></ol><ul><li>使用 Hocuspocus 作为 Yjs 的协作服务器</li><li>实现了数据库扩展，将 Yjs 文档状态持久化到 SQLite 数据库</li><li>通过 WebSocket 协议处理实时通信</li></ul><ol><li>认证与权限控制</li></ol><ul><li>WebSocket 连接需要 JWT Token 认证</li><li>服务器验证用户是否有权限访问特定房间</li><li>如果用户没有访问权限，会自动将其添加到房间成员中</li></ul><ol><li>数据同步机制</li></ol><ul><li>前端使用 Yjs 的  <code>Y.Map</code>  存储画布元素数据</li><li>通过  <code>IndexeddbPersistence</code>  将数据持久化到浏览器的 IndexedDB</li><li>使用  <code>HocuspocusProvider</code>  将数据同步到服务器和其他客户端</li></ul><ol><li>在线/离线处理</li></ol><ul><li>当用户在线时，数据实时同步到服务器</li><li>当用户离线时，数据保存在本地 IndexedDB 中</li><li>重新连接后，本地更改会自动同步到服务器（CRDT）</li></ul><ol><li>用户状态管理</li></ol><ul><li>使用 Yjs 的 Awareness 功能跟踪在线用户</li><li>广播机制实时显示协作者的光标位置和选中状态</li><li>通过后端认证机制确保只有授权用户可以加入协作</li></ul><hr><h3 id="2-状态管理（Zustand-相关，高频考点）"><a href="#2-状态管理（Zustand-相关，高频考点）" class="headerlink" title="2. 状态管理（Zustand 相关，高频考点）"></a>2. 状态管理（Zustand 相关，高频考点）</h3><p>Zustand 是项目核心状态工具，轻量且无 boilerplate。</p><ul><li>为什么选择 Zustand 而非 Redux 或 Context API？在画布状态管理中，它相比其他方案的优势体现在哪里？</li><li>如何使用 Zustand 管理画布元素状态（elements: Record<string, CanvasElement="">）？如何实现持久化（Zustand-persist + localForage + IndexedDB）？</string,></li><li>在多用户协作场景下，Zustand 与 Y.js CRDT 如何结合？如何处理冲突和状态同步？</li></ul><h3 id="3-高性能渲染与-PixiJS-集成（核心亮点）"><a href="#3-高性能渲染与-PixiJS-集成（核心亮点）" class="headerlink" title="3. 高性能渲染与 PixiJS 集成（核心亮点）"></a>3. 高性能渲染与 PixiJS 集成（核心亮点）</h3><p>PixiJS WebGL 渲染是项目性能关键，面试官会深入考察。</p><ul><li>为什么引入 PixiJS 而非纯 Canvas 或 SVG？它在实现 60 FPS 和无限画布时发挥了什么作用？</li><li>如何使用 pixi-viewport 实现无限画布的缩放、平移和边界限制（clamp）？</li><li>项目中如何缓存 PixiJS 对象（spriteMap）以避免拖拽/缩放时的重复创建？这对性能有何影响？</li><li>图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在 PixiJS 中实现的？遇到过哪些渲染挑战？</li><li>小地图（Minimap）如何通过 cacheAsBitmap 实现实时更新？为什么需要单独的 Pixi Application？</li></ul><h3 id="4-撤销-重做机制（命令模式）"><a href="#4-撤销-重做机制（命令模式）" class="headerlink" title="4. 撤销/重做机制（命令模式）"></a>4. 撤销/重做机制（命令模式）</h3><p>这部分体现了设计模式应用，常被作为算法/架构题考察。</p><ul><li>项目中撤销/重做是如何实现的？为什么采用 Command Pattern？</li><li>每个命令（如 AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？</li><li>UndoRedoManager 的实现细节是什么？如何限制历史栈大小以防止内存溢出？</li></ul><h3 id="5-交互与用户体验"><a href="#5-交互与用户体验" class="headerlink" title="5. 交互与用户体验"></a>5. 交互与用户体验</h3><p>涉及多选、变换控件、对齐指南等。</p><ul><li>如何实现多元素选择、组合/嵌套/解组功能？</li><li>变换控件（8 个缩放手柄 + 旋转）是如何检测和处理的？交互模式（idle、panning、dragging 等）切换逻辑是什么？</li><li>对齐指南（水平/垂直/等间距）是如何计算和绘制的？</li></ul><h3 id="6-性能优化与工程实践"><a href="#6-性能优化与工程实践" class="headerlink" title="6. 性能优化与工程实践"></a>6. 性能优化与工程实践</h3><ul><li>项目中做了哪些具体的性能优化措施（例如对象缓存、WebGL 渲染、Vite HMR）？</li><li>如何处理富文本编辑（WangEditor 输出 HTML 到 PixiJS HTMLText）的性能问题？</li><li>TypeScript 在项目中发挥了什么作用？如何定义 CanvasElement 等复杂类型的接口？</li><li>构建与部署方面：为什么使用 Vite？Docker 和 GitHub Actions 的 CI/CD 流程是如何配置的？</li><li>项目中使用了 shadcn/ui 和 Arco Design 等组件库，如何确保样式一致性（TailwindCSS 配置）？</li></ul><h3 id="7-挑战与改进"><a href="#7-挑战与改进" class="headerlink" title="7. 挑战与改进"></a>7. 挑战与改进</h3><p>面试官常问开放性问题，以考察反思能力。</p><ul><li>开发过程中遇到最大的技术难点是什么（例如实时协作冲突、PixiJS 与 React 同步）？如何解决？</li><li>如果要进一步优化或扩展（如支持更多元素类型或移动端适配），你会如何规划？</li><li>项目中是否有考虑可访问性（a11y）或国际化（i18n）？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当候选人向面试官展示 GitHub 仓库 &lt;a href=&quot;https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com&quot;&gt;https://github.com/Zhongye1/BDdraw_DEV&lt;/a&gt;（一个现代协作</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-17-前端画布设计Vol.1 实现基础元素渲染和状态控制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/43445.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/43445.html</id>
    <published>2025-12-27T20:23:08.000Z</published>
    <updated>2025-12-27T20:51:02.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PixiJS-实现基础元素渲染和状态控制"><a href="#PixiJS-实现基础元素渲染和状态控制" class="headerlink" title="PixiJS 实现基础元素渲染和状态控制"></a>PixiJS 实现基础元素渲染和状态控制</h2><p>PixiJS 是一个强大的 2D 渲染引擎，它使用 WebGL 和 Canvas 技术来高效地渲染图形，主要通过  ElementRenderer  类实现。</p><h3 id="基本图形渲染实现"><a href="#基本图形渲染实现" class="headerlink" title="基本图形渲染实现"></a>基本图形渲染实现</h3><p>设计的画布中，基本图形是通过 PixiJS 的 Graphics 类绘制的，支持以下基本图形类型：</p><ol><li><p><strong>矩形 (rect)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆角矩形 (rounded rectangle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">roundRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>, data.<span class="hljs-property">radius</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆形 (circle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">ellipse</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>菱形 (diamond)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">poly</span>([<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">width</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">height</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>]);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li></ol><h3 id="图形属性实现"><a href="#图形属性实现" class="headerlink" title="图形属性实现"></a>图形属性实现</h3><p>每个图形元素都由  CanvasElement  接口定义，支持以下属性：</p><ol><li><p><strong>背景色 (background)</strong>:</p><ul><li>通过  fill  属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li><li>使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>边框宽度 (border-width)</strong>:</p><ul><li>通过  strokeWidth  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li></ul></li><li><p><strong>边框颜色 (border-color)</strong>:</p><ul><li>通过  stroke  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li><li>同样使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>透明度 (alpha)</strong>:</p><ul><li>通过 alpha 属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li></ul></li></ol><p>在  ElementRenderer  类中，图形渲染的过程包括以下步骤：</p><ol><li>首先清空之前的图形绘制：<code>g.clear()</code></li><li><p>设置绘制样式（边框宽度、边框颜色、填充颜色、透明度）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> strokeWidth = data.<span class="hljs-property">strokeWidth</span> ?? <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> strokeColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">stroke</span>);<br><span class="hljs-keyword">const</span> fillColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">fill</span>);<br><span class="hljs-keyword">const</span> alpha = data.<span class="hljs-property">alpha</span> ?? <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>根据图形类型绘制对应的形状</p></li><li><p>设置图形的位置和旋转：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-property">pivot</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">x</span> + data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">y</span> + data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">rotation</span> = data.<span class="hljs-property">rotation</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="特殊功能"><a href="#特殊功能" class="headerlink" title="特殊功能"></a>特殊功能</h3><ol><li><strong>旋转功能</strong>: 通过设置  pivot  点和  rotation  属性实现</li><li><strong>圆角矩形</strong>: 使用  <code>g.roundRect(x, y, width, height, radius)</code>  方法</li><li><strong>纹理缓存</strong>: 对图像元素使用纹理缓存以提高性能</li><li><strong>动态加载</strong>: 图像元素支持异步加载纹理</li></ol><h2 id="状态管理机制"><a href="#状态管理机制" class="headerlink" title="状态管理机制"></a>状态管理机制</h2><p>在您的项目中，状态管理由  zustand  库实现，通过  CanvasStore  集中管理所有画布元素的状态。状态管理包含以下几个核心部分：</p><h3 id="1-状态结构"><a href="#1-状态结构" class="headerlink" title="1. 状态结构"></a>1. 状态结构</h3><ul><li>elements: 一个记录对象，包含所有画布元素</li><li>selectedIds: 当前选中的元素 ID 数组</li><li>tool: 当前使用的工具类型</li><li>currentStyle: 当前绘制样式（填充色、边框色、边框宽度等）</li></ul><h3 id="2-状态更新机制"><a href="#2-状态更新机制" class="headerlink" title="2. 状态更新机制"></a>2. 状态更新机制</h3><p>状态更新通过以下方法实现：</p><ul><li>addElement: 添加元素</li><li>updateElement: 更新元素属性</li><li>removeElements: 删除元素</li><li>setSelected: 设置选中的元素</li><li>batchUpdateElements: 批量更新元素（用于提高性能）</li></ul><h2 id="元素渲染机制"><a href="#元素渲染机制" class="headerlink" title="元素渲染机制"></a>元素渲染机制</h2><p>元素渲染通过  ElementRenderer  类实现，它与状态管理紧密结合：</p><h3 id="1-状态-渲染同步"><a href="#1-状态-渲染同步" class="headerlink" title="1. 状态-渲染同步"></a>1. 状态-渲染同步</h3><p>在  Core_StageManager.ts  中，有一个关键的订阅机制：</p><p>typescript</p><p><code>useStore.subscribe(   (state) =&gt; ({ elements: state.elements, selectedIds: state.selectedIds, tool: state.tool }),   (state) =&gt; {     if (!this.state.destroyed) {       this.elementRenderer.renderElements(state.elements, this.elementLayer, this.state.destroyed)       this.transformerRenderer.renderTransformer(         state.elements,         state.selectedIds,         this.elementRenderer.getSpriteMap(),         this.onHandleDown,         this.viewport.scale.x,       )       // ...     }   },   { equalityFn: stateEqualityFn }, )</code></p><p>每当状态发生变化时，就会触发渲染更新。</p><h3 id="2-渲染过程"><a href="#2-渲染过程" class="headerlink" title="2. 渲染过程"></a>2. 渲染过程</h3><p>ElementRenderer.renderElements  方法遍历所有元素并执行以下操作：</p><ol><li><strong>元素映射管理</strong>：使用  spriteMap  记录已渲染的元素</li><li><strong>类型处理</strong>：根据元素类型（矩形、圆形、文本、图像等）进行相应渲染</li><li><strong>属性应用</strong>：将状态中的属性（位置、大小、颜色等）应用到渲染对象</li></ol><h3 id="3-状态与渲染的实时同步"><a href="#3-状态与渲染的实时同步" class="headerlink" title="3. 状态与渲染的实时同步"></a>3. 状态与渲染的实时同步</h3><p>当状态变化时，例如：</p><ul><li>用户拖动元素时，updateElement  更新元素的  x  和  y  坐标</li><li>用户改变填充颜色时，updateElement  更新  fill  属性</li><li>选择元素时，setSelected  更新  selectedIds</li></ul><p>这些状态变更会立即触发渲染更新，确保 UI 与状态保持同步。</p><h2 id="状态控制机制"><a href="#状态控制机制" class="headerlink" title="状态控制机制"></a>状态控制机制</h2><h3 id="1-撤销-重做"><a href="#1-撤销-重做" class="headerlink" title="1. 撤销/重做"></a>1. 撤销/重做</h3><p>项目集成了撤销/重做功能，通过  UndoRedoManager  和命令模式实现：</p><ul><li>每个操作（添加、删除、更新）都创建一个命令对象</li><li>命令对象包含执行和撤销操作的逻辑</li><li>undo  和  redo  方法控制历史记录栈</li></ul><h3 id="2-选择状态管理"><a href="#2-选择状态管理" class="headerlink" title="2. 选择状态管理"></a>2. 选择状态管理</h3><ul><li>selectedIds  数组跟踪当前选中的元素</li><li>选择变化会触发渲染更新，显示选择框和控制点</li><li>TransformerRenderer 负责渲染选择框和调整手柄</li></ul><h3 id="3-工具状态管理"><a href="#3-工具状态管理" class="headerlink" title="3. 工具状态管理"></a>3. 工具状态管理</h3><ul><li>tool  属性跟踪当前使用的工具</li><li>工具变化会影响交互行为和光标样式</li><li>不同工具对相同的用户输入（如鼠标点击）会有不同的响应</li></ul><h3 id="4-实时协作"><a href="#4-实时协作" class="headerlink" title="4. 实时协作"></a>4. 实时协作</h3><p>项目使用 Yjs 实现实时协作功能：</p><ul><li>状态变化通过 Yjs 同步到其他用户</li><li>Yjs 的 observe 机制确保本地状态与共享状态同步</li><li>使用事务（transact）保证操作的原子性</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><strong>状态比较优化</strong>：使用  stateEqualityFn  减少不必要的重渲染</li><li><strong>批量更新</strong>：batchUpdateElements  方法用于批量更新元素，减少渲染次数</li><li><strong>精灵映射</strong>：ElementRenderer  保留精灵映射以避免重复创建/销毁</li><li><strong>防抖机制</strong>：虽然代码中注释掉了防抖，但设计中考虑了性能优化</li></ol><p>这种架构确保了状态与渲染之间的紧密同步，同时保持了良好的性能和可扩展性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PixiJS-实现基础元素渲染和状态控制&quot;&gt;&lt;a href=&quot;#PixiJS-实现基础元素渲染和状态控制&quot; class=&quot;headerlink&quot; title=&quot;PixiJS 实现基础元素渲染和状态控制&quot;&gt;&lt;/a&gt;PixiJS 实现基础元素渲染和状态控制&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18-前端画布设计Vol.2 实现富文本编辑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/10362.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/10362.html</id>
    <published>2025-12-27T18:58:47.000Z</published>
    <updated>2025-12-27T20:23:25.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="画布项目中富文本编辑器的实现浅析"><a href="#画布项目中富文本编辑器的实现浅析" class="headerlink" title="画布项目中富文本编辑器的实现浅析"></a>画布项目中富文本编辑器的实现浅析</h2><h4 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h4><p>该画布项目采用 <strong>wangEditor</strong>（v5 版本）的 React 封装组件 @wangeditor/editor-for-react 实现富文本编辑功能。主要通过两个组件协作完成：</p><ul><li>RichTextEditor.tsx：核心富文本编辑器封装，负责工具栏和编辑区的渲染与配置。</li><li>BottomTextEditor.tsx：底部面板式编辑器，仅在选中单个文本元素时显示，将富文本编辑器集成到画布操作流程中，支持实时更新元素内容并记录撤销/重做操作。</li></ul><p>主要形式是一个底部面板，单击文本元素会出现</p><h4 id="0x01-RichTextEditor-组件实现"><a href="#0x01-RichTextEditor-组件实现" class="headerlink" title="0x01 RichTextEditor 组件实现"></a>0x01 RichTextEditor 组件实现</h4><p>RichTextEditor 是对 wangEditor 的二次封装，提供可复用的富文本编辑器</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">"@wangeditor/editor/dist/css/style.css"</span>;<br><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Editor</span>, <span class="hljs-title class_">Toolbar</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@wangeditor/editor-for-react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">toolbarConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IToolbarConfig</span>&gt; = {<br>  <span class="hljs-attr">toolbarKeys</span>: [<br>    <span class="hljs-string">"bold"</span>,<br>    <span class="hljs-string">"italic"</span>,<br>    <span class="hljs-string">"underline"</span>,<br>    <span class="hljs-string">"through"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"fontSize"</span>,<br>    <span class="hljs-string">"fontFamily"</span>,<br>    <span class="hljs-string">"color"</span>,<br>    <span class="hljs-string">"bgColor"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"justifyLeft"</span>,<br>    <span class="hljs-string">"justifyCenter"</span>,<br>    <span class="hljs-string">"justifyRight"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"undo"</span>,<br>    <span class="hljs-string">"redo"</span>,<br>  ],<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">editorConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IEditorConfig</span>&gt; = {<br>  <span class="hljs-attr">placeholder</span>: <span class="hljs-string">"请输入文本..."</span>,<br>  <span class="hljs-attr">autoFocus</span>: <span class="hljs-literal">true</span>,<br>};<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (editor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    editor.<span class="hljs-title function_">destroy</span>();<br>    <span class="hljs-title function_">setEditor</span>(<span class="hljs-literal">null</span>);<br>  };<br>}, [editor]);<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"..."</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> <span class="hljs-attr">editor</span>=<span class="hljs-string">{editor}</span> <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{toolbarConfig}</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"simple"</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Editor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{editorConfig}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onCreated</span>=<span class="hljs-string">{setEditor}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(editor)</span> =&gt;</span> onChange(editor.getHtml())}</span><br><span class="language-xml">      mode="simple"</span><br><span class="language-xml">      style={{ height: "200px", overflowY: "auto" }}</span><br><span class="language-xml">    /&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>工具栏配置（toolbarConfig）</strong> 通过 toolbarKeys 指定显示的菜单键（加粗、斜体、下划线、删除线、字体大小/家族、颜色、背景色、对齐方式）以及撤销/重做。</li><li><strong>编辑器配置（editorConfig）</strong> 设置占位符和自动聚焦。wangEditor 支持更丰富的配置（如最大长度、自定义菜单等），此处保持最小化。</li><li><strong>生命周期管理</strong> 使用 useEffect 在组件卸载或 editor 实例变化时调用 editor.destroy()，防止内存泄漏。</li><li><strong>内容同步</strong>value props 控制初始 HTML，onChange 回调通过 editor.getHtml() 获取最新 HTML 内容并向上通知。</li></ol><h4 id="0x02-BottomTextEditor-组件实现"><a href="#0x02-BottomTextEditor-组件实现" class="headerlink" title="0x02 BottomTextEditor 组件实现"></a>0x02 BottomTextEditor 组件实现</h4><p>BottomTextEditor 将富文本编辑器集成到画布状态管理中，仅针对选中单个文本元素时激活。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> { selectedIds, elements, updateElement } = <span class="hljs-title function_">useStore</span>();<br><br><span class="hljs-keyword">const</span> selectedId = selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> ? selectedIds[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> element = selectedId ? elements[selectedId] : <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">const</span> [localHtml, setLocalHtml] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>);<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (element &amp;&amp; element.<span class="hljs-property">type</span> === <span class="hljs-string">"text"</span>) {<br>    <span class="hljs-title function_">setLocalHtml</span>(element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>);<br>  }<br>}, [element?.<span class="hljs-property">id</span>, element?.<span class="hljs-property">text</span>]);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params"><span class="hljs-attr">html</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-title function_">setLocalHtml</span>(html);<br>  <span class="hljs-keyword">const</span> initialText = element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>;<br>  <span class="hljs-title function_">updateElement</span>(element.<span class="hljs-property">id</span>, { <span class="hljs-attr">text</span>: html });<br><br>  <span class="hljs-keyword">const</span> updateCommand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateElementPropertyCommand</span>(<br>    { <span class="hljs-attr">id</span>: element.<span class="hljs-property">id</span>, <span class="hljs-attr">property</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">oldValue</span>: initialText, <span class="hljs-attr">newValue</span>: html },<br>    <span class="hljs-string">"修改文本内容"</span><br>  );<br>  undoRedoManager.<span class="hljs-title function_">executeCommand</span>(updateCommand);<br>};<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-8 ... animate-slide-up"</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">RichTextEditor</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{localHtml}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>选中元素判断</strong> 从 Zustand store（canvasStore）获取选中 ID 和元素集合，仅当选中单个文本类型元素时渲染编辑器。</li><li><strong>本地状态（localHtml）</strong> 使用 useState 维护本地 HTML 副本，并在选中元素变化时通过 useEffect 同步 store 中的 element.text。 此设计主要解决中文输入法（IME）组成阶段的问题：在拼音输入过程中，wangEditor 的 onChange 会频繁触发，若直接更新全局 store，可能导致输入延迟、光标跳动或内容混乱。通过本地状态缓冲实时变化，避免不必要的 store 更新。</li><li><strong>内容变更处理（handleChange）</strong><ul><li>更新本地状态。</li><li>实时调用 updateElement 更新画布 store，驱动 canvas 重新渲染文本元素。</li><li>创建 UpdateElementPropertyCommand 命令并执行，支持撤销/重做（undo/redo）。命令记录旧值和新值，处理历史操作</li></ul></li></ol><h4 id="0x03-关键问题解决与设计"><a href="#0x03-关键问题解决与设计" class="headerlink" title="0x03 关键问题解决与设计"></a>0x03 关键问题解决与设计</h4><ol><li><strong>输入法兼容性</strong> 中文输入过程中，组成事件（composition）会多次触发编辑器变更。若直接在 onChange 中更新全局状态，可能导致性能问题或输入体验不佳。本实现通过本地状态缓冲 setLocalHtml(html) 缓解该问题</li><li><strong>实时渲染与历史管理</strong> 实时更新 store 确保画布文本即时反映变更；同时通过命令模式记录操作，实现完整的 undo/redo 支持。</li></ol><h4 id="0x04-当前实现的风险与不足分析"><a href="#0x04-当前实现的风险与不足分析" class="headerlink" title="0x04 当前实现的风险与不足分析"></a>0x04 当前实现的风险与不足分析</h4><p>当前实现虽已满足基础富文本编辑需求，但是还是有一些问题</p><ol><li><strong>输入法体验优化不彻底</strong> 虽通过本地状态缓冲缓解了 IME 组成阶段的频繁更新问题，但未监听 compositionstart/compositionend 事件。在某些极端输入场景（如快速切换输入法或长句输入）下，仍可能出现光标偏移或临时内容丢失的现象。</li><li><strong>内容净化与 XSS 防护不足</strong> 完全依赖 wangEditor 内置的有限转义机制，未引入 DOMPurify 等专用净化库。在用户插入外部链接、图片或自定义 HTML 时，存在潜在的存储型或 DOM 型 XSS 风险，尤其在内容后续导出或分享场景中。</li><li><strong>样式与对齐精度问题</strong> wangEditor 生成的 HTML 结构（如多层 span/div 嵌套）与画布自定义文本渲染逻辑可能不完全匹配，导致编辑器中预览效果与画布最终渲染存在细微差异（如行高、字间距、对齐方式）。</li><li><strong>性能与内存管理</strong> 频繁的实时更新（onChange 触发 store 更新与命令记录）在长文本场景下可能导致轻微卡顿；此外，未对编辑器实例进行复用，当快速切换不同文本元素时会反复创建/销毁实例，增加内存开销。</li></ol><p>面对这些问题后续都可以做一些改进：</p><ol><li><strong>引入 DOMPurify 进行内容净化来处理 XSS 问题</strong> 在内容存储前（提交到 store 或后端）及渲染时统一调用 DOMPurify.sanitize，对 HTML 进行严格过滤。自定义白名单以保留 wangEditor 支持的必要标签与属性，同时移除所有事件处理器及危险协议。</li><li><strong>完善输入法兼容性</strong> 在 RichTextEditor 中监听 composition 事件，在组成阶段暂不触发 handleChange，仅在 compositionend 后统一更新 store 与命令记录，进一步消除输入延迟与光标问题。</li><li><strong>性能优化</strong> 实现编辑器实例复用（单一全局实例，根据选中元素动态切换内容），并在长文本时增加防抖处理，减少不必要的 store 更新与命令执行。</li></ol><h4 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h4><p>主要就是 wangEditor 的 React 封装，结合 Zustand 状态管理和命令模式，来适配画布类项目的文本编辑需求，实现了基础的文本编辑功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;a href=&quot;#画布项目中富文本编辑器的实现浅析&quot; class=&quot;headerlink&quot; title=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;/a&gt;画布项目中富文本编辑器的实现浅析&lt;/h2&gt;&lt;h4 id=&quot;0x00-概述&quot;&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-27-算法刷题-关于链表操作</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/40452.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/40452.html</id>
    <published>2025-12-27T08:12:42.000Z</published>
    <updated>2025-12-27T10:53:26.438Z</updated>
    
    <content type="html"><![CDATA[<p>后悔数据结构当初没有好好学的第n天<br>现在恶补，知识学爆</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><p>基础操作：</p><ul><li>查找元素：根据值查找节点位置</li><li>指定位置插入：在特定位置插入新节点</li><li>指定位置获取：获取特定位置的节点值</li><li>指定位置删除：删除特定位置的节点</li><li>获取长度：统计链表中节点的数量</li></ul><div class="table-container"><table><thead><tr><th></th><th>题目描述</th><th>主要实现思路</th></tr></thead><tbody><tr><td>BM1</td><td>反转链表</td><td>使用三指针（prev、curr、next）迭代反转：保存下一个节点，反转当前指向，移动指针。返回prev作为新头。</td></tr><tr><td>BM2</td><td>链表内指定区间反转</td><td>引入虚拟头结点定位第m-1个节点（pre）。然后在[m,n]区间执行(n-m)次头插法（逐个将下一个节点插入pre后）。</td></tr><tr><td>BM3</td><td>链表中的节点每k个一组翻转</td><td>每k个节点为一组，使用反转链表方法局部反转。若剩余不足k个，则保持原序。递归或迭代均可，推荐迭代分段处理。</td></tr><tr><td>BM4</td><td>合并两个排序的链表</td><td>双指针模拟归并排序：比较两个链表当前节点值，小者接入新链表，移动对应指针。处理剩余部分。</td></tr><tr><td>BM5</td><td>合并k个已排序的链表</td><td>使用小根堆（优先队列）维护k个链表头结点，每次弹出最小值并接入结果链表，同时推入其下一个节点。</td></tr><tr><td>BM6</td><td>判断链表中是否有环</td><td>快慢指针（Floyd判圈算法）：fast每次走2步，slow走1步。若相遇则有环，否则无环。</td></tr><tr><td>BM7</td><td>链表中环的入口结点</td><td>先用快慢指针相遇于环内某点，再令一指针从头启动，与慢指针同步移动，相遇处即环入口。</td></tr><tr><td>BM8</td><td>链表中倒数最后k个结点</td><td>快慢指针：fast先走k步，然后slow与fast同步移动，至fast到尾时slow即为倒数第k个节点。</td></tr><tr><td>BM9</td><td>删除链表的倒数第n个节点</td><td>同BM8定位倒数第n+1个节点（pre），然后pre.next = pre.next.next删除目标节点。注意头节点特殊处理。</td></tr><tr><td>BM10</td><td>两个链表的第一个公共结点</td><td>双指针同步走：先计算长度差，长者先走差值步；或让指针走完一链表后换另一链表，总路程相等时相遇即公共节点。</td></tr><tr><td>BM11</td><td>链表相加(二)</td><td>模拟加法从低位到高位（需先反转链表或用栈），处理进位。结果可能需反转回原序。</td></tr><tr><td>BM12</td><td>单链表的排序</td><td>归并排序（自底向上）：分段合并有序子链表，或快慢指针找中点递归归并。时间O(n log n)。</td></tr><tr><td>BM13</td><td>判断一个链表是否为回文结构</td><td>快慢指针找中点，反转后半部分，与前半部分逐节点比较值是否相等。恢复链表可选。</td></tr><tr><td>BM14</td><td>链表的奇偶重排</td><td>分离奇偶位节点成两个链表（odd、even），然后even接odd尾部。注意偶数长度处理。</td></tr><tr><td>BM15</td><td>删除有序链表中重复的元素-I</td><td>单指针遍历：若当前节点与下一节点值相同，跳过下一节点（保留首次出现）。</td></tr><tr><td>BM16</td><td>删除有序链表中重复的元素-II</td><td>引入虚拟头结点，双指针或单指针遍历：若连续重复，跳过整个重复段（一个不留）。</td></tr></tbody></table></div><hr><p>一般会给出一个最基础的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = (val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = (next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next);<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>节点包含两个成员</strong>：<ul><li>val：存储节点的值，通常为整数（int），题目中 |val| ≤ 1000。</li><li>next：指向下一个节点的指针（引用），类型为同类 ListNode*（或 ListNode），初始可能为 NULL/null/None</li></ul></li><li><strong>无哑头节点（dummy head）</strong>：输入的 head 就是真实头结点（有有效值），除非题目特别说明</li><li><strong>单向链表</strong>：只能从头到尾遍历，无前向指针</li><li><strong>输入形式</strong>：<ul><li>函数签名通常为 ListNode* head（或类似），可能额外传入其他参数（如 m、n、k 等）</li><li>空链表：head = NULL / null / None</li></ul></li><li><strong>输出形式</strong>：<ul><li>大多数题目要求返回新的头结点（ListNode*）</li><li>操作通常要求<strong>原地修改</strong>，以满足空间复杂度 O(1)</li></ul></li></ul><hr><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="单链表常见操作的实现方法"><a href="#单链表常见操作的实现方法" class="headerlink" title="单链表常见操作的实现方法"></a>单链表常见操作的实现方法</h3><p>以下针对单链表（节点结构为 val 和 next）的几种常见操作，提供标准、高效的实现思路。所有操作均基于从头结点开始遍历，时间复杂度与空间复杂度分析清晰。假设节点定义如下（以 JavaScript 为例，其他语言类似）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next || <span class="hljs-literal">null</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="1-查找元素：根据值查找节点位置（返回位置或节点）"><a href="#1-查找元素：根据值查找节点位置（返回位置或节点）" class="headerlink" title="1. 查找元素：根据值查找节点位置（返回位置或节点）"></a>1. 查找元素：根据值查找节点位置（返回位置或节点）</h4><p><strong>思路</strong>：从头遍历，逐个比较节点值，直到找到匹配值或到达链表末尾。</p><p><strong>实现要点</strong>：</p><ul><li>返回第一个匹配节点的<strong>位置</strong>（从 1 开始）或节点本身。</li><li>未找到返回 -1 或 null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findNode</span>(<span class="hljs-params">head, target</span>) {<br>    <span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">if</span> (curr.<span class="hljs-property">val</span> === target) {<br>            <span class="hljs-keyword">return</span> pos;  <span class="hljs-comment">// 或 return curr; 返回节点本身</span><br>        }<br>        curr = curr.<span class="hljs-property">next</span>;<br>        pos++;<br>    }<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）"><a href="#2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）" class="headerlink" title="2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）"></a>2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，将新节点插入其后。特殊处理插入到头部（i=1）。</p><p><strong>实现要点</strong>：</p><ul><li>若 i=1，新节点成为新头。</li><li>若 i &gt; 长度，插入失败或插入尾部（视题目要求）。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtPosition</span>(<span class="hljs-params">head, i, val</span>) {<br>    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>        newNode.<span class="hljs-property">next</span> = head;<br>        <span class="hljs-keyword">return</span> newNode;  <span class="hljs-comment">// 新头结点</span><br>    }<br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围，不插入</span><br>    <br>    newNode.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>;<br>    curr.<span class="hljs-property">next</span> = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）"><a href="#3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）" class="headerlink" title="3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）"></a>3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）</h4><p><strong>思路</strong>：遍历 i-1 步，直接返回当前节点的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> curr ? curr.<span class="hljs-property">val</span> : <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 未找到返回 null</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="4-指定位置删除：删除第-i-个节点（i-从-1-开始）"><a href="#4-指定位置删除：删除第-i-个节点（i-从-1-开始）" class="headerlink" title="4. 指定位置删除：删除第 i 个节点（i 从 1 开始）"></a>4. 指定位置删除：删除第 i 个节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，修改其 next 指向跳过第 i 个节点。特殊处理删除头结点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 删除头结点</span><br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span> || curr.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围</span><br>    <br>    curr.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 跳过第 i 个节点</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="5-获取链表长度（节点数量）"><a href="#5-获取链表长度（节点数量）" class="headerlink" title="5. 获取链表长度（节点数量）"></a>5. 获取链表长度（节点数量）</h4><p><strong>思路</strong>：遍历链表，累计计数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        len++;<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> len;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="BM1-全量反转链表"><a href="#BM1-全量反转链表" class="headerlink" title="BM1  | 全量反转链表"></a>BM1  | 全量反转链表</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤n≤10000≤n≤1000</p><p>要求：空间复杂度 O(1)O(1) ，时间复杂度 O(n)O(n) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p class='item-img' data-src='https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249'><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt=""></p><hr><p>解法：</p><ul><li>初始化 prev 为 null（新链表的尾部）。</li><li>current 从链表头节点开始。</li><li>在循环中：<ul><li>暂存 next = current.next（避免指针丢失）。</li><li>将 current.next 指向 prev（反转当前指针）。</li><li>更新 prev = current（前移 prev）。</li><li>更新 current = next（前移 current）。</li></ul></li><li>循环结束后，prev 指向原链表的尾节点（新头节点），更新 list.head = prev。</li></ul><p>其实就是三指针原地反转</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp'><img src="https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ReverseList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span></span>): <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br><br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    <br>        <span class="hljs-comment">// 保存下一个节点，防止断链</span><br>        <span class="hljs-keyword">let</span> next = curr.<span class="hljs-property">next</span>;<br><br>        <span class="hljs-comment">// 反转当前节点的指向</span><br>        curr.<span class="hljs-property">next</span> = prev;<br><br>        <span class="hljs-comment">// 指针向前移动</span><br>        prev = curr;<br>        curr = next;<br>    }<br>    <span class="hljs-comment">// prev 指向反转后的新头结点</span><br>    <span class="hljs-keyword">return</span> prev;<br>};<br></code></pre></td></tr></table></figure><h3 id="BM2-反转链表部分区间"><a href="#BM2-反转链表部分区间" class="headerlink" title="BM2  | 反转链表部分区间"></a>BM2  | 反转链表部分区间</h3><p>给定一个单链表的头结点 head，长度为 n，反转该链表从位置 m 到 n 的部分，返回反转后的链表。</p><p>数据范围： 0≤m≤n≤n≤1000 ，链表中任意节点的值满足 |val|≤1000</p><p>例如：<br>给出的链表为 1→2→3→4→5→NULL1→2→3→4→5→NULL, m=2,n=4m=2,n=4,<br>返回 1→4→3→2→5→NULL1→4→3→2→5→NULL.  </p><p>要实现原地反转指定区间，需要：</p><ol><li>找到反转区间的前一个节点（pre），即第 m-1 个节点。</li><li>找到反转区间的最后一个节点（记为 end），即第 n 个节点。</li><li>将 [m, n] 区间使用经典链表反转方法进行原地反转。</li><li>正确连接反转后的区间与前后部分：<ul><li>pre.next 指向反转后区间的新的头节点（原第 n 个节点）。</li><li>反转后区间的尾节点（原第 m 个节点）指向 end.next。</li></ul></li></ol><p>关键操作：</p><ul><li>先遍历定位到 pre 和反转区间的起始节点 start（第 m 个节点）。</li><li>然后在 [start, end] 区间内使用三指针迭代反转。</li><li>最后调整指针连接。</li></ul><p class='item-img' data-src='https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif'><img src="https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">m</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || m === n) <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> pre = dummy;<br><br>    <span class="hljs-comment">// 移动到第 m-1 个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) {<br>        pre = pre.<span class="hljs-property">next</span>!;<br>    }<br><br>    <span class="hljs-keyword">let</span> start = pre.<span class="hljs-property">next</span>!;   <span class="hljs-comment">// 第 m 个节点（反转区间的原头部）</span><br>    <span class="hljs-keyword">let</span> then = start.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 第 m+1 个节点（待头插的节点）</span><br><br>    <span class="hljs-comment">// 执行 (n - m) 次头插</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++) {<br>        start.<span class="hljs-property">next</span> = then.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 从原区间摘除 then</span><br>        then.<span class="hljs-property">next</span> = pre.<span class="hljs-property">next</span>;     <span class="hljs-comment">// then 插入 pre 之后（成为新头部）</span><br>        pre.<span class="hljs-property">next</span> = then;          <span class="hljs-comment">// 更新 pre 的 next</span><br>        then = start.<span class="hljs-property">next</span>;        <span class="hljs-comment">// 更新 then 为下一个待移动节点</span><br>    }<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;后悔数据结构当初没有好好学的第n天&lt;br&gt;现在恶补，知识学爆&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?sou</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-力扣百题速练（Javascript、TypeScript）Vol.2</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39620.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39620.html</id>
    <published>2025-12-26T05:57:08.000Z</published>
    <updated>2025-12-27T12:52:43.608Z</updated>
    
    <content type="html"><![CDATA[<p>这里是力扣速刷第二期awa<br>说是速刷其实卡了挺久</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为  <code>n</code>  的整数数组  <code>height</code> 。有  <code>n</code>  条垂线，第  <code>i</code>  条线的两个端点是  <code>(i, 0)</code>  和  <code>(i, height[i])</code><br>找出其中的两条线，使得它们与  <code>x</code>  轴共同构成的容器可以容纳最多的水<br>返回容器可以储存的最大水量</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49</p><p>最开始直接暴力解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; height.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">let</span> xin = (j - i) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]);<br>      <span class="hljs-keyword">if</span> (xin &gt; res) {<br>        res = xin;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>后面想了一下，做了些改进</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (i &lt; j) {<br>    <span class="hljs-keyword">let</span> fin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]) * (j - i);<br>    <span class="hljs-keyword">if</span> (fin &gt; res) {<br>      res = fin;<br>    }<br>    <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) {<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      j--;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>初始时宽度最大，若当前面积不是最大，则必须通过增加高度来补偿宽度损失<br>移动较短指针是因为：保持较短边不动，宽度只会变小，面积不可能增大；只有移动较短边才可能遇到更高的高度，从而提升面积</p><p>经典双指针加贪心的题</p><hr><h2 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h2><p>七个不同的符号代表罗马数字，其值如下：</p><div class="table-container"><table><thead><tr><th>符号</th><th>值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：</p><ul><li>如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。</li><li>如果该值以 4 或 9 开头，使用  <strong>减法形式</strong>，表示从以下符号中减去一个符号，例如 4 是 5 (<code>V</code>) 减 1 (<code>I</code>): <code>IV</code> ，9 是 10 (<code>X</code>) 减 1 (<code>I</code>)：<code>IX</code>。仅使用以下减法形式：4 (<code>IV</code>)，9 (<code>IX</code>)，40 (<code>XL</code>)，90 (<code>XC</code>)，400 (<code>CD</code>) 和 900 (<code>CM</code>)。</li><li>只有 10 的次方（<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (<code>V</code>)，50 (<code>L</code>) 或 500 (<code>D</code>)。如果需要将符号附加 4 次，请使用  <strong>减法形式</strong>。</li></ul><p>给定一个整数，将其转换为罗马数字。</p><p><strong>示例 1：</strong></p><p>**输入：num = 3749</p><p><strong>输出：</strong> “MMMDCCXLIX”</p><p><strong>解释：</strong></p><p>3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)<br>700 = DCC 由于 500 (D) + 100 (C) + 100 (C)<br>40 = XL 由于 50 (L) 减 10 (X)<br>9 = IX 由于 10 (X) 减 1 (I)<br>注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位</p><p><strong>示例 2：</strong></p><p>**输入：num = 58</p><p><strong>输出：</strong>“LVIII”</p><p><strong>解释：</strong></p><p>50 = L<br>8 = VIII</p><p><strong>示例 3：</strong></p><p>**输入：num = 1994</p><p><strong>输出：</strong>“MCMXCIV”</p><p><strong>解释：</strong></p><p>1000 = M<br>900 = CM<br>90 = XC<br>4 = IV</p><p>最初想法是尝试通过<strong>逐位处理数字</strong>的方式将整数转换为罗马数字：</p><ol><li><strong>将数字转换为字符串并反转</strong>： 使用 reverseString(num.toString()) 将数字从高位到低位变为低位到高位（例如 1994 → “4991”）,从个位开始依次处理每个数位（个位、十位、百位、千位）</li><li><strong>为每个数位定义对应的罗马符号</strong>：<ul><li><code>个位（i===0）：1→"I", 5→"V", 10→"X"</code></li><li><code>十位（i===1）：1→"X", 5→"L", 10→"C"</code></li><li><code>百位（i===2）：1→"C", 5→"D", 10→"M"</code></li><li><code>千位（i===3）：直接用 "M" 重复</code></li></ul></li><li><strong>根据当前位上的数字（0-9）生成对应罗马表示</strong>：<ul><li>1-3：重复添加 “1” 的符号（curr1）</li><li>4：curr1 + curr2（如 “IV”）</li><li>5：curr2（如 “V”）</li><li>6-8：curr2 + 重复 (digit-5) 次 curr1</li><li>9：curr1 + curr3（如 “IX”）</li></ul></li><li><strong>使用数组 + unshift 收集符号</strong>： 因为已反转数字，低位先处理，使用 unshift（从数组头部插入）试图让高位符号最终出现在前面</li><li><strong>最后 join 成字符串返回</strong></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">let</span> curr1 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr2 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr3 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span><br>    str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-keyword">let</span> top = <span class="hljs-title function_">reverseString</span>(num.<span class="hljs-title function_">toString</span>());<br>  <span class="hljs-keyword">let</span> l = top.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">finalstr</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">nums</span>(<span class="hljs-params"><span class="hljs-attr">pos</span>: <span class="hljs-built_in">number</span></span>) {<br>    <span class="hljs-keyword">const</span> di = <span class="hljs-title class_">Number</span>(top[pos]);<br>    <span class="hljs-keyword">if</span> (di === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">4</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">5</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">8</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di - <span class="hljs-number">5</span>; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">9</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr3);<br>    }<br>  }<br>  <span class="hljs-keyword">while</span> (i &lt; l) {<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {<br>      curr1 = <span class="hljs-string">"I"</span>;<br>      curr2 = <span class="hljs-string">"V"</span>;<br>      curr3 = <span class="hljs-string">"X"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>      curr1 = <span class="hljs-string">"X"</span>;<br>      curr2 = <span class="hljs-string">"L"</span>;<br>      curr3 = <span class="hljs-string">"C"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) {<br>      curr1 = <span class="hljs-string">"C"</span>;<br>      curr2 = <span class="hljs-string">"D"</span>;<br>      curr3 = <span class="hljs-string">"M"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">const</span> vas = <span class="hljs-title class_">Number</span>(top[i]);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; vas; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">"M"</span>);<br>      }<br>      i++;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> finalstr.<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>}<br></code></pre></td></tr></table></figure><p>题目标准解法是<strong>贪心算法 + 值-符号映射表</strong>，从高位到低位匹配最大可能值，这个写法确实没有想出来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">valueSymbols</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>][] = [<br>        [<span class="hljs-number">1000</span>, <span class="hljs-string">"M"</span>], [<span class="hljs-number">900</span>, <span class="hljs-string">"CM"</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">"D"</span>], [<span class="hljs-number">400</span>, <span class="hljs-string">"CD"</span>],<br>        [<span class="hljs-number">100</span>,  <span class="hljs-string">"C"</span>], [<span class="hljs-number">90</span>,  <span class="hljs-string">"XC"</span>], [<span class="hljs-number">50</span>,  <span class="hljs-string">"L"</span>], [<span class="hljs-number">40</span>,  <span class="hljs-string">"XL"</span>],<br>        [<span class="hljs-number">10</span>,   <span class="hljs-string">"X"</span>], [<span class="hljs-number">9</span>,   <span class="hljs-string">"IX"</span>], [<span class="hljs-number">5</span>,   <span class="hljs-string">"V"</span>], [<span class="hljs-number">4</span>,   <span class="hljs-string">"IV"</span>],<br>        [<span class="hljs-number">1</span>,    <span class="hljs-string">"I"</span>]<br>    ];<br><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [value, <span class="hljs-built_in">symbol</span>] <span class="hljs-keyword">of</span> valueSymbols) {<br>        <span class="hljs-keyword">while</span> (num &gt;= value) {<br>            result += <span class="hljs-built_in">symbol</span>;<br>            num -= value;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>  和  <code>M</code>。</p><p><strong>字符</strong> <strong>数值</strong><br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000</p><p>例如， 罗马数字  <code>2</code>  写做  <code>II</code> ，即为两个并列的 1 。<code>12</code>  写做  <code>XII</code> ，即为  <code>X</code> + <code>II</code> 。 <code>27</code>  写做  <code>XXVII</code>, 即为  <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  <code>IIII</code>，而是  <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code>  可以放在  <code>V</code> (5) 和  <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code>  可以放在  <code>L</code> (50) 和  <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code>  可以放在  <code>D</code> (500) 和  <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> s = “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> s = “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> s = “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> s = “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> s = “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p><p>直接从左到右遍历字符串，比较当前符号与下一个符号的值：</p><ul><li>如果当前值 &lt; 下一个值，则减去当前值（形成减法组合）。</li><li>否则加上当前值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> map = {<br>    <span class="hljs-attr">I</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">V</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">X</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">L</span>: <span class="hljs-number">50</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">D</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">M</span>: <span class="hljs-number">1000</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> current = map[s[i]];<br>    <span class="hljs-keyword">const</span> next = map[s[i + <span class="hljs-number">1</span>]];<br><br>    <span class="hljs-keyword">if</span> (next &amp;&amp; current &lt; next) {<br>      res += next - current;<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      res += current;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀</p><p>如果不存在公共前缀，返回空字符串  <code>""</code></p><p><strong>示例 1：</strong></p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p><strong>示例 2：</strong></p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀</p><p>题解比较简单，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params"><span class="hljs-attr">strs</span>: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (strs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> char = strs[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (i === strs[j].<span class="hljs-property">length</span> || strs[j][i] !== char) {<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i);<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></table></figure><p>主要就是注意一个写法，在 JavaScript（以及 TypeScript）中，<code>strs[0][i]</code> 是一种链式索引访问（chained indexing）的写法，用于访问二维结构或嵌套可索引对象中的元素</p><p>假设 <code>strs = ["flower", "flow", "flight"]</code>，循环变量 <code>i = 2</code> 时：</p><ul><li><code>strs[0] → "flower"</code></li><li><code>strs[0][2] → "flower"</code> 的第 2 个字符 → <code>'o'</code></li></ul><p>同理：</p><ul><li><code>strs[1][2] → "flow"[2] → 'o'</code></li><li><code>strs[2][2] → "flight"[2] → 'i'</code></li></ul><p>通过比较 <code>strs[0][i]</code>与其他字符串的 <code>strs[j][i]</code> 是否相等，来判断第 i 位置是否仍属于公共前缀</p><h3 id="等价的写法"><a href="#等价的写法" class="headerlink" title="等价的写法"></a>等价的写法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> firstStr = strs[<span class="hljs-number">0</span>];<br>firstStr[i];<br><br><span class="hljs-comment">// 使用 charAt 方法</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">charAt</span>(i);<br><br><span class="hljs-comment">// 使用 at 方法 ES2022+</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">at</span>(i);<br></code></pre></td></tr></table></figure><hr><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>一个整数数组  <code>nums</code> ，判断是否存在三元组  <code>[nums[i], nums[j], nums[k]]</code>  满足  <code>i != j</code>、<code>i != k</code>  且  <code>j != k</code> ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code> ，返回所有和为  <code>0</code>  且不重复的三元组，且答案中不可以包含重复的三元组</p><p>示例 1：<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code><br>输出：<code>[[-1,-1,2],[-1,0,1]]</code><br>解释：<br><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code><br><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code><br><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code><br>不同的三元组是 <code>[-1,0,1]</code>和 <code>[-1,-1,2]</code></p><p>示例 2：<br>输入：<code>nums = [0,1,1]</code><br>输出：<code>[]</code><br>解释：唯一可能的三元组和不为 0</p><p>示例 3：<br>输入：<code>nums = [0,0,0]</code><br>输出：<code>[[0,0,0]]</code><br>解释：唯一可能的三元组和为 0</p><p>最开始是想直接 n^3 暴力解，然后用 Set 去重</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br>  <span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = j + <span class="hljs-number">1</span>; k &lt; nums.<span class="hljs-property">length</span>; k++) {<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">const</span> triplet = [nums[i], nums[j], nums[k]];<br>          <span class="hljs-keyword">const</span> key = triplet.<span class="hljs-title function_">join</span>(<span class="hljs-string">","</span>);<br>          <span class="hljs-keyword">if</span> (!seen.<span class="hljs-title function_">has</span>(key)) {<br>            seen.<span class="hljs-title function_">add</span>(key);<br>            result.<span class="hljs-title function_">push</span>(triplet);<br>          }<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>很明显，时间复杂度特别高，直接爆了</p><p>解法的话依旧双指针降维</p><h3 id="第一步：排序"><a href="#第一步：排序" class="headerlink" title="第一步：排序"></a>第一步：排序</h3><p>排序后可以：利用有序数组的特性，通过指针移动快速缩小范围</p><p>比如原数组是 <code>[-1,0,1,2,-1,-4]</code>，排序后变成 <code>[-4,-1,-1,0,1,2]</code>。这时候，相同的元素（比如两个 <code>-1</code>）会挨在一起，方便后续去重（重复元素会相邻，容易跳过）</p><h3 id="第二步：固定一个数，双指针找另外两个数"><a href="#第二步：固定一个数，双指针找另外两个数" class="headerlink" title="第二步：固定一个数，双指针找另外两个数"></a>第二步：固定一个数，双指针找另外两个数</h3><p>排序后，我们固定第一个数 <code>nums[i]</code>，然后用左指针 <code>left</code> 指向 <code>i+1</code>，右指针 <code>right</code> 指向数组末尾。三个数的和 <code>sum = nums[i] + nums[left] + nums[right]</code>：</p><ul><li>如果 <code>sum &lt; 0</code>：说明需要更大的数，左指针右移（<code>left++</code>）；</li><li>如果 <code>sum &gt; 0</code>：说明需要更小的数，右指针左移（<code>right--</code>）；</li><li>如果 <code>sum = 0</code>：找到一个有效三元组，记录结果。</li></ul><h3 id="第三步：去重"><a href="#第三步：去重" class="headerlink" title="第三步：去重"></a>第三步：去重</h3><p>具体分三种情况：</p><h4 id="1-固定数-nums-i-重复"><a href="#1-固定数-nums-i-重复" class="headerlink" title="1. 固定数 nums[i] 重复"></a>1. 固定数 <code>nums[i]</code> 重复</h4><p>比如排序后的数组是 <code>[-4,-1,-1,0,1,2]</code>，当 <code>i=1</code>（<code>nums[i]=-1</code>）时，和 <code>i=2</code>（<code>nums[i]=-1</code>）时的情况是一样的。这时候需要跳过重复的 <code>nums[i]</code>。</p><p><strong>判断条件</strong>：如果 <code>i &gt; 0</code> 且 <code>nums[i] === nums[i-1]</code>，说明当前 <code>nums[i]</code> 和前一个数重复，直接跳过。</p><h4 id="2-左指针-nums-left-重复"><a href="#2-左指针-nums-left-重复" class="headerlink" title="2. 左指针 nums[left] 重复"></a>2. 左指针 <code>nums[left]</code> 重复</h4><p>假设已经找到 <code>i=0</code>（<code>nums[i]=-4</code>），<code>left=1</code>（<code>nums[left]=-1</code>），<code>right=5</code>（<code>nums[right]=2</code>），此时和为 <code>-4 + (-1) + 2 = -3</code>，不满足条件。左指针右移到 <code>left=2</code>（<code>nums[left]=-1</code>），这时候 <code>nums[left]</code> 和前一个 <code>left</code> 位置的数重复，需要跳过。</p><p><strong>判断条件</strong>：当找到和为 0 的三元组后，需要循环判断 <code>nums[left] === nums[left+1]</code>，如果是，左指针右移，直到遇到不同的数。</p><h4 id="3-右指针-nums-right-重复"><a href="#3-右指针-nums-right-重复" class="headerlink" title="3. 右指针 nums[right] 重复"></a>3. 右指针 <code>nums[right]</code> 重复</h4><p>同样，找到和为 0 的三元组后，如果 <code>nums[right]</code> 和前一个 <code>right</code> 位置的数重复（比如 <code>nums[right]=1</code> 和 <code>nums[right-1]=1</code>），需要跳过。</p><p><strong>判断条件</strong>：循环判断 <code>nums[right] === nums[right-1]</code>，如果是，右指针左移，直到遇到不同的数。</p><ol><li><strong>先排序</strong>：nums.sort((a, b) =&gt; a - b)，使得相同元素相邻，便于跳过重复。</li><li><strong>外层循环跳过重复的 i</strong>：如果当前 nums[i] 与前一个相同，则跳过（避免同一值的 i 产生重复三元组）。</li><li><strong>内层双指针移动时跳过重复的 left 和 right</strong>：找到一个有效三元组后，跳过所有相同的 left 和 right 值。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 先排序，关键一步</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-comment">// 跳过重复的 nums[i]</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) {<br>      <span class="hljs-keyword">continue</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br><br>      <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) {<br>        result.<span class="hljs-title function_">push</span>([nums[i], nums[left], nums[right]]); <span class="hljs-comment">//加入结果</span><br><br>        <span class="hljs-comment">// 跳过重复的 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) {<br>          left++;<br>        }<br>        <span class="hljs-comment">// 跳过重复的 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) {<br>          right--;<br>        }<br><br>        left++;<br>        right--;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> {<br>        right--;<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给你一个长度为  <code>n</code>  的整数数组  <code>nums</code>  和 一个目标值  <code>target</code>。请你从  <code>nums</code>  中选出三个整数，使它们的和与  <code>target</code>  最接近，返回这三个数的和<br>假定每组输入只存在恰好一个解</p><p>示例：<br>输入：nums = <code>[-1,2,1,-4]</code> , <code>target = 1</code><br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)</p><p>解法和三数之和一样都是双指针解题<br>多一些判断而已</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> closestSum = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> minDiff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(closestSum - target);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br>      <span class="hljs-keyword">const</span> diff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(sum - target);<br><br>      <span class="hljs-keyword">if</span> (diff &lt; minDiff) {<br>        minDiff = diff;<br>        closestSum = sum;<br>      }<br><br>      <span class="hljs-keyword">if</span> (sum &lt; target) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) {<br>        right--;<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> sum;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> closestSum;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="17-电话号码的的数字组合"><a href="#17-电话号码的的数字组合" class="headerlink" title="17.电话号码的的数字组合"></a>17.电话号码的的数字组合</h2><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按  <strong>任意顺序</strong>  返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p class='item-img' data-src='https://pic.leetcode.cn/1752723054-mfIHZs-image.png'><img src="https://pic.leetcode.cn/1752723054-mfIHZs-image.png" alt="电话按键" width="300"></p><p>示例 1：<br>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：<br>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p><p>练度不够，还得继续练</p><p>主要解法是迭代法：</p><ul><li>外层循环遍历 digits 中的每一个数字（从左到右）。</li><li>对于当前数字 digit：<ul><li>获取其对应的所有可能字母 letters（如 ‘2’ → ‘abc’）。</li><li>创建一个临时数组 temp，用于存储“加入当前数字字母后的新组合”。</li><li>遍历当前 result 中的每一个已有组合 prev（这些是处理前几个数字得到的所有组合）。</li><li>对 letters 中的每一个 letter，将其追加到 prev 后面，形成新字符串 prev + letter，并加入 temp。</li></ul></li><li>一轮结束后，将 temp 赋值给 result，成为下一轮的“已有组合”。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params"><span class="hljs-attr">digits</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>[] {<br>  <span class="hljs-keyword">if</span> (digits.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: { [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> } = {<br>    <span class="hljs-string">"2"</span>: <span class="hljs-string">"abc"</span>,<br>    <span class="hljs-string">"3"</span>: <span class="hljs-string">"def"</span>,<br>    <span class="hljs-string">"4"</span>: <span class="hljs-string">"ghi"</span>,<br>    <span class="hljs-string">"5"</span>: <span class="hljs-string">"jkl"</span>,<br>    <span class="hljs-string">"6"</span>: <span class="hljs-string">"mno"</span>,<br>    <span class="hljs-string">"7"</span>: <span class="hljs-string">"pqrs"</span>,<br>    <span class="hljs-string">"8"</span>: <span class="hljs-string">"tuv"</span>,<br>    <span class="hljs-string">"9"</span>: <span class="hljs-string">"wxyz"</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">""</span>];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> digit <span class="hljs-keyword">of</span> digits) {<br>    <span class="hljs-keyword">const</span> letters = map[digit];<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">temp</span>: <span class="hljs-built_in">string</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prev <span class="hljs-keyword">of</span> result) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> letter <span class="hljs-keyword">of</span> letters) {<br>        temp.<span class="hljs-title function_">push</span>(prev + letter);<br>      }<br>    }<br>    result = temp;<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>从“空组合”开始，依次将每个新数字的字母可能性“横向扩展”到所有已有组合上，最终得到所有完整组合</p><hr><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><p>给你一个由  <code>n</code>  个整数组成的数组  <code>nums</code> ，和一个目标值  <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组  <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code>  和  <code>d</code>  互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>输入：<code>nums = [1,0,-1,0,-2,2]</code>, <code>target = 0</code><br>输出：<code>[[-2,-1,1,2] , [-2,0,0,2] , [-1,0,0,1]]</code></p><p>输入：<code>nums = [2,2,2,2,2]</code>, <code>target = 8</code><br>输出：<code>[[2,2,2,2]]</code></p><p><strong>就是三数之和的基础上再套上一层 for 循环</strong></p><p>题解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number[][]</span>}</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) {<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);  <span class="hljs-comment">// 先排序</span><br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> result = [];<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) {<br>        <span class="hljs-comment">// 去重 i</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前四个最小值之和已大于 target，直接终止</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前 i 与后面三个最大值之和小于 target，跳过本次 i</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) {<br>            <span class="hljs-comment">// 去重 j</span><br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">let</span> left = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (left &lt; right) {<br>                <span class="hljs-keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];<br><br>                <span class="hljs-keyword">if</span> (sum === target) {<br>                    result.<span class="hljs-title function_">push</span>([nums[i], nums[j], nums[left], nums[right]]);<br><br>                    <span class="hljs-comment">// 去重 left</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-comment">// 去重 right</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) right--;<br><br>                    left++;<br>                    right--;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {<br>                    left++;<br>                } <span class="hljs-keyword">else</span> {<br>                    right--;<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> result;<br>};<br></code></pre></td></tr></table></figure><hr><h2 id="19-删除链表的第-n-个节点"><a href="#19-删除链表的第-n-个节点" class="headerlink" title="19. 删除链表的第 n 个节点"></a>19. 删除链表的第 n 个节点</h2><p>给你一个链表，删除链表的倒数第  <code>n</code>  个结点，并且返回链表的头结点</p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>输入：head = [1], n = 1<br>输出：[]</p><p>自己写的一版，思路主要是遍历一趟链表搞到 length，再用 n 确定 index 来定位要删的位置，最后再删掉该节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> curr = head;<br>  <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    len++;<br>    curr = curr.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">if</span> (len === n) {<br>    <span class="hljs-keyword">return</span> head?.<span class="hljs-property">next</span> ?? <span class="hljs-literal">null</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> index = len - n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> delindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">let</span> del = head;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  prev.<span class="hljs-property">next</span> = head;<br>  <span class="hljs-keyword">while</span> (del !== <span class="hljs-literal">null</span>) {<br>    prev = prev.<span class="hljs-property">next</span>;<br>    del = del.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (delindex === index) {<br>      prev.<span class="hljs-property">next</span> = del.<span class="hljs-property">next</span>;<br>    }<br>    delindex++;<br>  }<br>  <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><p>题解的话主要是用快慢指针,这个思路挺不错的其实</p><ul><li>引入虚拟头结点 dummy</li><li>让 fast 指针先走 n 步</li><li>然后 slow 与 fast 同步移动，当 fast 到达末尾时，slow 指向的就是倒数第 n 个节点的前一个节点</li><li>执行 slow.next = slow.next.next 删除目标节点</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 边界：空链表或 n 无效直接返回</span><br>  <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  dummy.<span class="hljs-property">next</span> = head;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">fast</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">slow</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br><br>  <span class="hljs-comment">// fast 先走 n 步</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    fast = fast!.<span class="hljs-property">next</span>; <span class="hljs-comment">// n 合法时不会为 null</span><br>  }<br><br>  <span class="hljs-comment">// fast 和 slow 同步移动，直到 fast 到达末尾</span><br>  <span class="hljs-keyword">while</span> (fast!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    fast = fast!.<span class="hljs-property">next</span>;<br>    slow = slow!.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 此时 slow 指向倒数第 n 个节点的前一个节点</span><br>  <span class="hljs-keyword">if</span> (slow!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    slow!.<span class="hljs-property">next</span> = slow!.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p>给定一个只包括  <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>  的字符串  <code>s</code> ，判断字符串是否有效</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例 1：<br>输入：<code>s = "()"</code><br>输出：true</p><p>示例 2：<br>输入：<code>s = "()[]{}"</code><br>输出：true</p><p>示例 3：<br>输入：<code>s = "(]"</code><br>输出：false</p><p>示例 4：<br>输入：<code>s = "([])"</code><br>输出：true</p><p>示例 5：<br>输入：<code>s = "([)]"</code><br>输出：false</p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code>  仅由括号  <code>'()[]{}'</code>  组成</li></ul><p>思路不难，主要就是栈匹配问题</p><ul><li>开括号 → 入栈 <code>stk.push(s[i])</code></li><li>闭括号 → 元素出栈 <code>stk.pop()</code> 进行匹配  </li><li>若栈空或栈顶不匹配 → 立即返回 false；否则弹出栈顶</li><li>遍历结束 → 栈空返回 true，否则 false</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">stk</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"("</span> || s[i] === <span class="hljs-string">"["</span> || s[i] === <span class="hljs-string">"{"</span>) {<br>      stk.<span class="hljs-title function_">push</span>(s[i]);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">")"</span> || s[i] === <span class="hljs-string">"]"</span> || s[i] === <span class="hljs-string">"}"</span>) {<br>      <span class="hljs-keyword">if</span> (stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>      <span class="hljs-keyword">let</span> curr = stk.<span class="hljs-title function_">pop</span>()!;<br>      <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"("</span> &amp;&amp; s[i] === <span class="hljs-string">")"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"["</span> &amp;&amp; s[i] === <span class="hljs-string">"]"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"{"</span> &amp;&amp; s[i] === <span class="hljs-string">"}"</span>) {<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是力扣速刷第二期awa&lt;br&gt;说是速刷其实卡了挺久&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-关于Javascript/TypeScript 的顺序表，链表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/46758.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/46758.html</id>
    <published>2025-12-26T04:16:12.000Z</published>
    <updated>2025-12-26T04:42:12.018Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。</p><p>以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并附带说明。</p><h2 id="1-顺序表（基于数组的动态顺序表）"><a href="#1-顺序表（基于数组的动态顺序表）" class="headerlink" title="1. 顺序表（基于数组的动态顺序表）"></a>1. 顺序表（基于数组的动态顺序表）</h2><p>顺序表的核心是连续存储，使用数组实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建顺序表</span><br><span class="hljs-keyword">const</span> seqList = [];<br><br><span class="hljs-comment">// 添加元素</span><br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">10</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// 在索引 1 处插入 15</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">// [10, 15, 20, 30]</span><br><br><span class="hljs-comment">// 修改索引 2 处的元素</span><br>seqList[<span class="hljs-number">2</span>] = <span class="hljs-number">25</span>;           <span class="hljs-comment">// [10, 15, 25, 30]</span><br><br><span class="hljs-comment">// 删除索引 0 处的元素</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">// [15, 25, 30]</span><br><br><span class="hljs-comment">// 输出长度和内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'长度:'</span>, seqList.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内容:'</span>, seqList);         <span class="hljs-comment">// [15, 25, 30]</span><br></code></pre></td></tr></table></figure><p>手动实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity = <span class="hljs-number">10</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity);  <span class="hljs-comment">// 存储元素</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 当前元素个数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;         <span class="hljs-comment">// 当前容量</span><br>    }<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 扩容（当 size === capacity 时）</span><br>    <span class="hljs-title function_">resize</span>(<span class="hljs-params">newCapacity</span>) {<br>        <span class="hljs-keyword">const</span> newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(newCapacity);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            newData[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = newData;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = newCapacity;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 扩容为两倍</span><br>        }<br>        <span class="hljs-comment">// 从后向前移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>; i &gt;= index; i--) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在末尾添加元素</span><br>    <span class="hljs-title function_">append</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 删除索引 index 处的元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">const</span> removed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>        <span class="hljs-comment">// 从前向后移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-comment">// 可选：缩容（避免频繁缩容，通常当 size == capacity / 4 时缩为一半）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">4</span>)) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">2</span>));<br>        }<br>        <span class="hljs-keyword">return</span> removed;<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'SequentialList: ['</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            str += <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>            <span class="hljs-keyword">if</span> (i !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>) str += <span class="hljs-string">', '</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> seqList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequentialList</span>();<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>seqList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>seqList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// SequentialList: [1, 3, 2]</span><br></code></pre></td></tr></table></figure><h2 id="2-链表（单向链表）"><a href="#2-链表（单向链表）" class="headerlink" title="2. 链表（单向链表）"></a>2. 链表（单向链表）</h2><p>链表使用节点分散存储，支持高效的插入和删除（O(1)），但随机访问较慢（O(n)）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();  <span class="hljs-comment">// 虚拟头结点，便于操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(element);<br>        node.<span class="hljs-property">next</span> = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在链表头部添加元素</span><br>    <span class="hljs-title function_">addFirst</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">0</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 在链表末尾添加元素</span><br>    <span class="hljs-title function_">addLast</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        cur.<span class="hljs-property">val</span> = element;<br>    }<br><br>    <span class="hljs-comment">// 删除索引处元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> removedNode = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = removedNode.<span class="hljs-property">next</span>;<br>        removedNode.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-keyword">return</span> removedNode.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'LinkedList: ['</span>;<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            str += cur.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">next</span>) str += <span class="hljs-string">' -&gt; '</span>;<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">1</span>);<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">2</span>);<br>linkedList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>linkedList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// LinkedList: [1 -&gt; 3 -&gt; 2]</span><br></code></pre></td></tr></table></figure><hr><h2 id="LRU-缓存的实现（使用双向链表-HashMap）"><a href="#LRU-缓存的实现（使用双向链表-HashMap）" class="headerlink" title="LRU 缓存的实现（使用双向链表 + HashMap）"></a>LRU 缓存的实现（使用双向链表 + HashMap）</h2><p>LRU（Least Recently Used）缓存是一种常见的数据结构，用于实现固定容量缓存，当容量满时淘汰最近最少使用的元素。在 JavaScript 中，最高效的实现方式是结合<strong>双向链表</strong>（控制访问顺序）和<strong>Map</strong>（或对象）作为哈希表（实现 O(1) 访问）</p><h3 id="JS实现："><a href="#JS实现：" class="headerlink" title="JS实现："></a>JS实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;        <span class="hljs-comment">// 缓存容量</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();          <span class="hljs-comment">// 使用 Map 作为哈希表，保持插入顺序并支持 O(1) 操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟头节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟尾节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;      <span class="hljs-comment">// 初始化链表：head &lt;-&gt; tail</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将节点移动到链表头部（表示最近使用）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">node</span> - 要移动的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_moveToHead</span>(<span class="hljs-params">node</span>) {<br>        <span class="hljs-comment">// 先从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>;<br><br>        <span class="hljs-comment">// 插入到头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从链表尾部移除节点（淘汰最久未使用的）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 被移除的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_removeTail</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>;<br>        lastNode.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any</span>} 值，如果不存在返回 -1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>        }<br>        <span class="hljs-comment">// 刷新访问顺序：将节点移到头部</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            <span class="hljs-comment">// 已存在：更新值并移到头部</span><br>            existingNode.<span class="hljs-property">value</span> = value;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 不存在：创建新节点</span><br>            <span class="hljs-keyword">const</span> newNode = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入到头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 检查容量是否超出</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeTail</span>();  <span class="hljs-comment">// 移除尾部节点</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);      <span class="hljs-comment">// 从哈希表中删除</span><br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 可选：打印当前缓存顺序（用于调试）</span><br>    <span class="hljs-title function_">printCache</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> result = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current.key}</span>:<span class="hljs-subst">${current.value}</span>`</span>);<br>            current = current.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache (most recent -&gt; least recent):'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2（刷新顺序）</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br><br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);            <span class="hljs-comment">// 容量满，淘汰最久未使用的 1</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 4:4 -&gt; 2:2 -&gt; 3:3</span><br></code></pre></td></tr></table></figure><h3 id="TS实现"><a href="#TS实现" class="headerlink" title="TS实现"></a>TS实现</h3><p>使用双向链表结合 Map（Map 在 TypeScript 中天然支持泛型）实现 O(1) 时间复杂度的 get 和 put 操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 双向链表节点接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>    <span class="hljs-attr">key</span>: K;<br>    <span class="hljs-attr">value</span>: V;<br>    <span class="hljs-attr">prev</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K = <span class="hljs-built_in">number</span>, V = <span class="hljs-built_in">number</span>&gt; {<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span>;                <span class="hljs-comment">// 缓存容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">cache</span>: <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;;        <span class="hljs-comment">// 哈希表：键到节点的映射</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">head</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟尾节点</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">// 将节点移动到头部（最近使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">moveToHead</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-comment">// 从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>!;<br><br>        <span class="hljs-comment">// 插入头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">// 移除尾部节点（最久未使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">removeTail</span>(): <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>!;<br>        lastNode.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">// 获取值</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: K): V | -<span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(node);  <span class="hljs-comment">// 刷新访问顺序</span><br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">// 放入键值对</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            existingNode.<span class="hljs-property">value</span> = value;  <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">const</span> <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 超出容量时淘汰</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeTail</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 调试：打印缓存顺序（最近 -&gt; 最久）</span><br>    <span class="hljs-title function_">printCache</span>(): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current!.key}</span>:<span class="hljs-subst">${current!.value}</span>`</span>);<br>            current = current!.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br></code></pre></td></tr></table></figure><h2 id="链表反转的实现"><a href="#链表反转的实现" class="headerlink" title="链表反转的实现"></a>链表反转的实现</h2><p>单向链表的反转实现，包括迭代和递归两种方式</p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 单向链表节点定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params">arr</span>) {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 方法一：迭代反转（推荐，空间复杂度 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 前驱指针</span><br>    <span class="hljs-keyword">let</span> current = head;      <span class="hljs-comment">// 当前指针</span><br>    <span class="hljs-keyword">let</span> next = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 临时存储下一节点</span><br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        next = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev; <span class="hljs-comment">// 反转指针</span><br>        prev = current;      <span class="hljs-comment">// 前驱前进</span><br>        current = next;      <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// prev 成为新头节点</span><br>}<br><br><span class="hljs-comment">// 方法二：递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-comment">// 递归终止条件：空链表或只有一个节点</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br><br>    <span class="hljs-comment">// 递归反转后续链表</span><br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br><br>    <span class="hljs-comment">// 反转当前节点与下一节点的指向</span><br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> newHead;  <span class="hljs-comment">// 新头节点始终是原链表的尾节点</span><br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIterative = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIterative);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list2);  <span class="hljs-comment">// 6 -&gt; 7 -&gt; 8</span><br><br><span class="hljs-keyword">const</span> reversedRecursive = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRecursive);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><h3 id="TS实现-1"><a href="#TS实现-1" class="headerlink" title="TS实现"></a>TS实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 单向链表节点类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val ?? <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next ?? <span class="hljs-literal">null</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">const</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 迭代反转（推荐，空间 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">current</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = head;<br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">const</span> next = current.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev;        <span class="hljs-comment">// 反转指针</span><br>        prev = current;             <span class="hljs-comment">// 前驱前进</span><br>        current = next;             <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// 新头节点</span><br>}<br><br><span class="hljs-comment">// 递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIter = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIter);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-keyword">const</span> reversedRec = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRec);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><p>DFA:</p><ul><li><strong>顺序表</strong>：适合随机访问（O(1)），插入/删除较慢（O(n)），实现简单，内存连续</li><li><strong>链表</strong>：适合频繁插入/删除（O(1)），随机访问慢（O(n)），内存分散，支持动态扩展, 链表常用于特定算法（如 LRU 缓存、链表反转等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。&lt;/p&gt;
&lt;p&gt;以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-关于JavaScript面试算法：字符串，数组，数字反转和转换</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/47427.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/47427.html</id>
    <published>2025-12-26T03:20:25.000Z</published>
    <updated>2025-12-27T04:41:06.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串，数组，数字的转换"><a href="#字符串，数组，数字的转换" class="headerlink" title="字符串，数组，数字的转换"></a>字符串，数组，数字的转换</h2><p><strong>数字（Number）</strong>、<strong>字符串（String）</strong> 和 <strong>数组（Array）</strong> 之间的相互转换算是常见操作了，常见转换方向、推荐方法、示例代码及说明如下：</p><div class="table-container"><table><thead><tr><th>从 → 到</th><th>方法</th><th>示例代码</th><th>说明</th></tr></thead><tbody><tr><td>Number → String</td><td>String(num) 或 num.toString()</td><td>let str = String(123); // “123” let str = (123).toString(); // “123”</td><td>最可靠方式。toString() 可指定进制，如 (10).toString(2) // “1010”。</td></tr><tr><td>Number → Array</td><td>String(num).split(‘’)</td><td>let arr = String(123).split(‘’); // [“1”, “2”, “3”]</td><td>先转为字符串，再按字符拆分成数组（适用于单个数字的位拆分）。</td></tr><tr><td>String → Number</td><td>Number(str) 或 +str 或 parseInt(str, 10)</td><td>let num = Number(“123”); // 123 let num = +”123”; // 123 let num = parseInt(“123”, 10); // 123</td><td>+str 最简洁；parseInt 适合提取整数部分（忽略后缀非数字）。</td></tr><tr><td>String → Array</td><td>str.split(separator)</td><td>let arr = “1,2,3”.split(‘,’); // [“1”, “2”, “3”] let arr = “123”.split(‘’); // [“1”, “2”, “3”]</td><td>split(‘’) 按单个字符拆分；split(‘,’) 按逗号等分隔符拆分。</td></tr><tr><td>Array → String</td><td>arr.toString() 或 arr.join(separator)</td><td>let str = [1,2,3].toString(); // “1,2,3” let str = [1,2,3].join(‘’); // “123” let str = [1,2,3].join(‘-‘); // “1-2-3”</td><td>join() 更灵活，可自定义分隔符（默认逗号）。</td></tr><tr><td>Array → Number</td><td>先转为字符串，再转为数字（如 Number(arr.join(‘’))）</td><td>let num = Number([1,2,3].join(‘’)); // 123</td><td>适用于纯数字数组；若数组含非数字，返回 NaN。</td></tr><tr><td>Array(Number) → Array(String)</td><td>arr.map(String) 或 arr.map(num =&gt; num.toString())</td><td>let strArr = [1,2,3].map(String); // [“1”, “2”, “3”]</td><td>逐元素转换为字符串，最常用方法。</td></tr><tr><td>Array(String) → Array(Number)</td><td>arr.map(Number) 或 arr.map(str =&gt; parseInt(str, 10))</td><td>let numArr = [“1”,”2”,”3”].map(Number); // [1, 2, 3]</td><td>逐元素转换为数字；parseInt 更安全处理可能含非纯数字字符串。</td></tr></tbody></table></div><p>数组转数字本质是拼接字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'2'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'22'</span>, <span class="hljs-string">'23'</span>];<br><br><span class="hljs-comment">// 步骤1: 使用 join('') 无分隔符拼接成字符串 const str = arr.join(''); // "212223"</span><br><br><span class="hljs-comment">// 步骤2: 转换为数字 const num = Number(str); // 212223 // 或等价简写：const num = +arr.join('');</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 212223（number 类型）</span><br></code></pre></td></tr></table></figure><p>数组转连续字符串本质也是拼接字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TS"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">'X'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'W'</span>];<br><br><span class="hljs-comment">// 使用 join('')（最常用） </span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>); <span class="hljs-comment">// "XWW"</span><br><br><span class="hljs-comment">// 使用 join() 无参数（默认逗号，但空字符串等价） </span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str2</span>: <span class="hljs-built_in">string</span> = arr.<span class="hljs-title function_">join</span>(); <span class="hljs-comment">// 注意：默认会得到 "X,W,W"，必须传空字符串</span><br></code></pre></td></tr></table></figure><h2 id="字符串反转："><a href="#字符串反转：" class="headerlink" title="字符串反转："></a>字符串反转：</h2><p><strong>ES6:</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);<br><br><span class="hljs-comment">// 使用示例 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverseString</span>(<span class="hljs-string">'hello'</span>)); <span class="hljs-comment">// 'olleh'</span><br></code></pre></td></tr></table></figure><p><strong>手动循环</strong>（不依赖内置方法）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">str</span>) {<br>  <span class="hljs-keyword">let</span> reversed = <span class="hljs-string">''</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    reversed += str[i];<br>  }<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure><h2 id="数组反转（Array-Reverse）"><a href="#数组反转（Array-Reverse）" class="headerlink" title="数组反转（Array Reverse）:"></a>数组反转（Array Reverse）:</h2><p><strong>原地反转</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">reverse</span>();  <span class="hljs-comment">// arr 变为 [4, 3, 2, 1]</span><br></code></pre></td></tr></table></figure><p><strong>手动实现</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) {<br>    [arr[left], arr[right]] = [arr[right], arr[left]];<br>    left++;<br>    right--;<br>  }<br>  <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></table></figure><h2 id="数字反转（leetcode-7）"><a href="#数字反转（leetcode-7）" class="headerlink" title="数字反转（leetcode # 7）"></a>数字反转（leetcode # 7）</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseInt</span>(<span class="hljs-params">x</span>) {<br>  <span class="hljs-keyword">const</span> sign = x &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> reversed = sign * <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>), <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>数组排序</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串，数组，数字的转换&quot;&gt;&lt;a href=&quot;#字符串，数组，数字的转换&quot; class=&quot;headerlink&quot; title=&quot;字符串，数组，数字的转换&quot;&gt;&lt;/a&gt;字符串，数组，数字的转换&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数字（Number）&lt;/strong&gt;、&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-面试算法ACM模式构建构建输入输出模板（Javascript）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/31996.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/31996.html</id>
    <published>2025-12-25T15:09:45.000Z</published>
    <updated>2025-12-26T07:14:53.570Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞<br>上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板</p><h2 id="一、基础模板"><a href="#一、基础模板" class="headerlink" title="一、基础模板"></a>一、基础模板</h2><p>我们先来看一个基础模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello Nowcoder!"</span>);<br>})();<br></code></pre></td></tr></table></figure><p>我们接下来逐行解析下每行代码的作用</p><h5 id="1-引入-readline-模块并创建接口"><a href="#1-引入-readline-模块并创建接口" class="headerlink" title="1. 引入 readline 模块并创建接口"></a>1. 引入 readline 模块并创建接口</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br></code></pre></td></tr></table></figure><ul><li><code>require("readline")</code>：引入 Node.js 内置的<code>readline</code>模块，这个模块用于从命令行（标准输入）读取一行一行的输入。</li><li><code>createInterface({ input: process.stdin })</code>：创建一个输入接口，指定输入源为<code>process.stdin</code>（标准输入，也就是用户在控制台输入的内容）。</li><li>变量<code>rl</code>就是这个输入接口的实例，后续通过它来控制输入的读取。</li></ul><h5 id="2-创建异步迭代器"><a href="#2-创建异步迭代器" class="headerlink" title="2. 创建异步迭代器"></a>2. 创建异步迭代器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br></code></pre></td></tr></table></figure><ul><li><code>Symbol.asyncIterator</code>是 Javascript 的一个内置符号，用于定义对象的异步迭代器</li><li>这里通过<code>rl[Symbol.asyncIterator]()</code>获取 rl 接口的异步迭代器，赋值给<code>iter</code>。</li><li>异步迭代器的作用是：可以通过<code>next()</code>方法<strong>异步地获取下一行输入</strong>（因为输入是用户手动输入的，属于异步操作）。</li></ul><h5 id="3-定义读取一行输入的函数"><a href="#3-定义读取一行输入的函数" class="headerlink" title="3. 定义读取一行输入的函数"></a>3. 定义读取一行输入的函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br></code></pre></td></tr></table></figure><ul><li>这是一个异步函数（<code>async</code>标记），作用是读取一行输入。</li><li>调用<code>iter.next()</code>会返回一个 Promise，<code>await</code>会等待这个 Promise 完成，获取下一行输入的结果。</li><li>结果的<code>value</code>属性就是读取到的一行字符串（如果没有更多输入，<code>value</code>会是<code>undefined</code>）。</li><li>简单说：调用<code>readline()</code>就可以得到一行输入的内容（字符串类型）</li></ul><h5 id="4-立即执行的异步函数（核心逻辑区）"><a href="#4-立即执行的异步函数（核心逻辑区）" class="headerlink" title="4. 立即执行的异步函数（核心逻辑区）"></a>4. 立即执行的异步函数（核心逻辑区）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here 👉 你的核心代码写在这里</span><br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入 console.log("Hello Nowcoder!");</span><br>})();<br></code></pre></td></tr></table></figure><p>这是整个代码的<strong>执行入口</strong>，也就是你需要编写核心逻辑的地方，我们拆解一下：</p><ul><li><code>void async function (){...}()</code>:这是一个<strong>立即执行的异步函数表达式</strong> (IIFE)。<ul><li><code>async</code>标记：允许函数内部使用 await 关键字（因为读取输入输出是异步操作）。</li><li><code>void</code>：避免函数执行后返回值可能导致的语法问题，单纯让函数执行。</li><li>最后的<code>()</code>：表示定义后立即执行这个函数。</li></ul></li></ul><h4 id="核心代码写在哪里？"><a href="#核心代码写在哪里？" class="headerlink" title="核心代码写在哪里？"></a>核心代码写在哪里？</h4><p>答案是：写在<code>void async function () { ... }</code>这个函数内部（也就是注释<code>// Write your code here</code>的位置）。根据题目的输入格式不同，你需要修改这个区域的代码。具体常见的输入格式见我第二部分详细讲解。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个模板的作用是标准化输入读取流程：</p><ol><li>准备好读取输入的工具（<code>rl</code>接口，<code>iter</code>迭代器，<code>readline</code>函数）。</li><li>在立即执行的异步函数中，通过<code>await readline()</code>获取输入。</li><li>在函数内部编写你的核心逻辑（处理输入、计算、输出结果）。</li></ol><h2 id="二、常见出题形式"><a href="#二、常见出题形式" class="headerlink" title="二、常见出题形式"></a>二、常见出题形式</h2><h4 id="1-单组-A-B"><a href="#1-单组-A-B" class="headerlink" title="1.单组 A+B"></a>1.单组 A+B</h4><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>给定两个整数<code>a</code>和<code>b</code>，请你求出<code>a + b</code>的值。</p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>第一行有两个整数<code>a</code>和<code>b</code></p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输入一个整数，代表<code>a + b</code>的值。</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h6 id="核心逻辑解析"><a href="#核心逻辑解析" class="headerlink" title="核心逻辑解析"></a>核心逻辑解析</h6><p>函数内部的<code>while</code>循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span>(line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>()) { ... }<br></code></pre></td></tr></table></figure><ul><li>作用：<strong>持续读取每一行输入</strong> ，直到没有更多输入(<code>readline()</code>返回<code>undefined</code>，循环终止)。</li><li><code>line = await readline()</code>：先调用<code>readline()</code>读取每一行输入，赋值给<code>line</code>。</li><li>当没有输入时，<code>readline()</code>先返回<code>undefined</code>，循环条件为<code>false</code>，退出循环。</li></ul><p>循环内部的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>); <span class="hljs-comment">// 将一行输入按空格分割成数组（比如输入"1 2"，得到["1", "2"]）</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 将第一个元素转为整数</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 将第二个元素转为整数 console.log(a + b); // 输出结果</span><br></code></pre></td></tr></table></figure><h4 id="2-多组-A-B-EOF-形式"><a href="#2-多组-A-B-EOF-形式" class="headerlink" title="2.多组_A+B_EOF 形式"></a>2.多组_A+B_EOF 形式</h4><h6 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，读取至文件末尾为止，每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，读取至文件末尾为止</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入，直到没有更多输入（EOF）</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 将一行输入按空格分割成数组（例如"1 2"分割为["1", "2"]）</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-comment">// 将分割后的字符串转为整数</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出两数之和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="3-多组-A-B-T-组形式"><a href="#3-多组-A-B-T-组形式" class="headerlink" title="3.多组_A+B_T 组形式"></a>3.多组_A+B_T 组形式</h4><h6 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h6><p>给定 t 组测试数据。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数 t，每行有两个整数 a 和 b</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取测试用例数量T</span><br>  <span class="hljs-keyword">let</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：循环T次，处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取一行输入</span><br>    <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>    <span class="hljs-comment">// 分割成两个数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="4-多组A-B零尾模式"><a href="#4-多组A-B零尾模式" class="headerlink" title="4.多组A+B零尾模式"></a>4.多组<em>A+B</em>零尾模式</h4><h6 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，最后一组数据为 0 0，作为输入的结尾。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，最后一组数据为 0 0，作为输入的结尾。</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 分割并转换为数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 关键：判断是否为0 0，是则终止循环</span><br>    <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 退出循环，不再处理后续输入</span><br>    }<br><br>    <span class="hljs-comment">// 不是终止条件则输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="5-单组-一维数组"><a href="#5-单组-一维数组" class="headerlink" title="5.单组_一维数组"></a>5.单组_一维数组</h4><h6 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br>输出：<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取数字的个数n</span><br>  <span class="hljs-keyword">let</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：读取第二行，获取包含n个数字的字符串</span><br>  <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 第三步：对字符串进行处理，转化为数字数组</span><br>  <span class="hljs-keyword">let</span> nums = line<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 用空格分割，过滤空值</span><br><br>  <span class="hljs-comment">// 第四步：计算数组中所有数字的总和</span><br>  <span class="hljs-keyword">let</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 第五步：输出总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="6-多组-一维数组-T-组形式"><a href="#6-多组-一维数组-T-组形式" class="headerlink" title="6.多组_一维数组_T 组形式"></a>6.多组_一维数组_T 组形式</h4><h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">12</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 循环处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取当前组的元素个数n</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 读取当前组的数组元素行</span><br>    <span class="hljs-keyword">const</span> arrayLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 将字符串分割为数字数组</span><br>    <span class="hljs-keyword">const</span> numbers = arrayLine<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-comment">// 计算数组总和（使用reduce累加，初始值为0）</span><br>    <span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, current</span>) =&gt;</span> acc + current, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="7-单组-二维数组"><a href="#7-单组-二维数组" class="headerlink" title="7.单组_二维数组"></a>7.单组_二维数组</h4><h6 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>输出：<br><span class="hljs-number">78</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">let</span> firstLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>  <span class="hljs-keyword">let</span> [m, n] = firstLine.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// m=3, n=4（对应示例输入）</span><br><br>  <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储总和</span><br><br>  <span class="hljs-comment">// 2. 循环读取m行数据（二维数组的每一行）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    <span class="hljs-keyword">let</span> row = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>(); <span class="hljs-comment">// 读取一行数据（如"1 2 3 4"）</span><br>    <span class="hljs-keyword">let</span> nums = row<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 转为数字数组（如[1,2,3,4]）</span><br><br>    <span class="hljs-comment">// 3. 累加当前行的所有元素到总和</span><br>    <span class="hljs-keyword">let</span> rowSum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>    totalSum += rowSum;<br>  }<br><br>  <span class="hljs-comment">// 4. 输出二维数组所有元素的总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="8-多组-二维数组-T-组形式"><a href="#8-多组-二维数组-T-组形式" class="headerlink" title="8.多组_二维数组_T 组形式"></a>8.多组_二维数组_T 组形式</h4><h6 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br>输出：<br><span class="hljs-number">78</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组二维数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的行数m和列数n</span><br>    <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储当前组的总和</span><br><br>    <span class="hljs-comment">// 2.2 读取m行数据（二维数组的每一行）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>      <span class="hljs-keyword">const</span> row = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>        .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>      <span class="hljs-comment">// 累加当前行的所有元素</span><br>      <span class="hljs-keyword">const</span> rowSum = row.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>      totalSum += rowSum;<br>    }<br><br>    <span class="hljs-comment">// 2.3 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="9-单组-字符串"><a href="#9-单组-字符串" class="headerlink" title="9.单组_字符串"></a>9.单组_字符串</h4><h6 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h6><p>给定一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>n</code>，第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">5</span><br>abcde<br>输出：<br>edcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行：字符串的长度n（本题中可忽略具体值，仅用于匹配输入格式）</span><br>  <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 读取第二行：需要反转的字符串</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 3. 反转字符串：</span><br>  <span class="hljs-comment">//    - split('') 将字符串转为字符数组（如"abcde" → ['a','b','c','d','e']）</span><br>  <span class="hljs-comment">//    - reverse() 反转数组（→ ['e','d','c','b','a']）</span><br>  <span class="hljs-comment">//    - join('') 将数组转回字符串（→ "edcba"）</span><br>  <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-comment">// 4. 输出反转后的字符串</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>})();<br></code></pre></td></tr></table></figure><h4 id="10-多组-字符串-T-组形式"><a href="#10-多组-字符串-T-组形式" class="headerlink" title="10.多组_字符串_T 组形式"></a>10.多组_字符串_T 组形式</h4><h6 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次只给出一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后<code>t</code>组数据。每组的第一行有一个整数<code>n</code>,每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出<code>t</code>行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br>abcde<br><span class="hljs-number">8</span><br>redocwon<br><span class="hljs-number">9</span><br>tfarcenim<br>输出：<br>edcba<br>nowcoder<br>minecraft<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串长度n（仅用于匹配输入格式，反转逻辑不依赖此值）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取当前组需要反转的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 反转字符串：拆分为字符数组 → 反转数组 → 拼接为字符串</span><br>    <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>    <span class="hljs-comment">// 2.4 输出反转后的字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="11-单组-二维字符数组"><a href="#11-单组-二维字符数组" class="headerlink" title="11.单组_二维字符数组"></a>11.单组_二维字符数组</h4><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有两个整数<code>n</code>和<code>m</code>，随后<code>n</code>行，每行有<code>m</code>个字符，仅包含小写英文字符。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个二维字符数组。</p><h6 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>abcd<br>efgh<br>ijkl<br>输出：<br>lkji<br>hgfe<br>dcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>  <span class="hljs-comment">// 2. 读取m行字符串，存储到数组中</span><br>  <span class="hljs-keyword">const</span> rows = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    rows.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br>  }<br><br>  <span class="hljs-comment">// 3. 处理逻辑：</span><br>  <span class="hljs-comment">//    a. 先将每行字符串反转（如"abcd" → "dcba"）</span><br>  <span class="hljs-comment">//    b. 再将所有行的顺序反转（如[行1, 行2, 行3] → [行3, 行2, 行1]）</span><br>  <span class="hljs-keyword">const</span> reversedRows = rows<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>)) <span class="hljs-comment">// 每行字符反转</span><br>    .<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// 行顺序反转</span><br><br>  <span class="hljs-comment">// 4. 逐行输出处理后的结果</span><br>  reversedRows.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(row));<br>})();<br></code></pre></td></tr></table></figure><h4 id="12-多组-带空格的字符串-T-组形式"><a href="#12-多组-带空格的字符串-T-组形式" class="headerlink" title="12.多组_带空格的字符串_T 组形式"></a>12.多组_带空格的字符串_T 组形式</h4><h6 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次给出一个长度为<code>n</code>的带空格的字符串<code>s</code>，请你去掉空格之后，将其倒置，然后输出。</p><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后有<code>t</code>组数据。每组的第一行有一个整数<code>n</code>，每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符和空格，保证字符串首尾都不是空格。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">9</span><br>one space<br><span class="hljs-number">11</span><br>two  spaces<br><span class="hljs-number">14</span><br>three   spaces<br>输出：<br>ecapseno<br>secapsowt<br>secapseerht<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串总长度n（用于匹配输入格式）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取带空格的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 处理逻辑：</span><br>    <span class="hljs-comment">//    a. 先将字符串所有字符（包括空格）反转</span><br>    <span class="hljs-comment">//    b. 再去除反转后字符串中的所有空格</span><br>    <span class="hljs-keyword">const</span> processed = str<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拆分为字符数组（含空格）</span><br>      .<span class="hljs-title function_">reverse</span>() <span class="hljs-comment">// 反转所有字符（包括空格）</span><br>      .<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拼接回字符串</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// 去除所有空格（\s+匹配任意空白字符）</span><br><br>    <span class="hljs-comment">// 2.4 输出处理结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processed);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="13-单组-保留小数位数"><a href="#13-单组-保留小数位数" class="headerlink" title="13.单组_保留小数位数"></a>13.单组_保留小数位数</h4><h6 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h6><p>给定一个小数 n ，请你保留 3 位小数后输出。</p><p>如果原来的小数位数少于 3 ，需要补充 0 。</p><p>如果原来的小数位数多于 3 ，需要四舍五入到 3 位。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1.23</span><br>输出：<br><span class="hljs-number">1.230</span><br><br>输入：<br><span class="hljs-number">114.514</span><br>输出：<br><span class="hljs-number">114.514</span><br><br>输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">123.000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的小数（单组输入，只需读一次）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 将字符串转换为浮点数</span><br>  <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">parseFloat</span>(numStr);<br><br>  <span class="hljs-comment">// 3. 保留3位小数：toFixed(3)会自动补零，确保结果是3位小数</span><br>  <span class="hljs-keyword">const</span> result = num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">// 4. 输出格式化后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h4 id="14-单组-补充前导零"><a href="#14-单组-补充前导零" class="headerlink" title="14.单组_补充前导零"></a>14.单组_补充前导零</h4><h6 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h6><p>给定一个正整数 n ，请你保留 9 个数位，然后输出。</p><p>如果数位少于 9 个，那么需要补充前导零。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">000000123</span><br><br>输入：<br><span class="hljs-number">123456789</span><br>输出：<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的数字（单组输入，读取一行即可）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 补充前导零至9位：</span><br>  <span class="hljs-comment">//    - padStart(9, '0') 表示如果字符串长度不足9位，在前面补'0'直到长度为9</span><br>  <span class="hljs-keyword">const</span> result = numStr.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">9</span>, <span class="hljs-string">"0"</span>);<br><br>  <span class="hljs-comment">// 3. 输出处理后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>parseInt()</code>：将字符串转化为整数。</li><li><code>parseFloat()</code>：将字符串转化为浮点数。</li><li><code>split()</code>：将字符串按指定分隔符分割成数组。</li><li><code>reverse()</code>：反转数组。</li><li><code>join()</code>：将数组元素按指定分隔符拼接成字符串。</li><li><p><code>padStart()</code>：在字符串前面补充指定字符，直到字符串长度达到指定长度。</p></li><li><p><code>line = await readline()</code>：要注意 await readline()获取的是一段字符串，后面我们还要自己将它分割或者转化为其他数据类型。</p></li><li><code>let tokens = line.split(' ')</code>：这段代码作用是，将一行输入按空格分割成数组（例如”1 2”分割为[“1”, “2”]）。</li><li><code>let a = parseInt(tokens[0])</code>：这段代码的作用是，将分割的字符转化为数字。</li></ul><p>再配合<code>while</code>和<code>for</code>语句差不多可以应对各种题型了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞&lt;br&gt;上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板&lt;/p&gt;
&lt;h2 id=&quot;一、基础模板&quot;&gt;&lt;a href=&quot;#一、基础模板&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-ES6-关于JavaScript的Set 方法</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/27040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/27040.html</id>
    <published>2025-12-25T07:26:18.000Z</published>
    <updated>2025-12-26T05:45:01.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Set-方法详解"><a href="#JavaScript-Set-方法详解" class="headerlink" title="JavaScript Set 方法详解"></a>JavaScript Set 方法详解</h1><h2 id="1-Set-是什么？"><a href="#1-Set-是什么？" class="headerlink" title="1. Set 是什么？"></a>1. Set 是什么？</h2><p><strong>Set</strong>​ 是 ES6 引入的一种新的数据结构，它类似于数组，但<strong>成员的值都是唯一的</strong>，没有重复的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 创建一个 Set</span><br><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 或者从数组创建</span><br><span class="hljs-keyword">const</span> setFromArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// 会自动去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setFromArray); <span class="hljs-comment">// Set(4) {1, 2, 3, 4}</span><br></code></pre></td></tr></table></figure><h2 id="2-Set-的基本方法"><a href="#2-Set-的基本方法" class="headerlink" title="2. Set 的基本方法"></a>2. Set 的基本方法</h2><h3 id="2-1-添加元素：add"><a href="#2-1-添加元素：add" class="headerlink" title="2.1 添加元素：add()"></a>2.1 添加元素：<code>add()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 添加单个元素</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复添加，不会被添加进去</span><br><br><span class="hljs-comment">// 链式调用</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 可以添加任意类型的值</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"hello"</span>);<br>set.<span class="hljs-title function_">add</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> });<br>set.<span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// NaN 在 Set 中也是唯一的</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// 不会添加第二个 NaN</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 查看大小</span><br></code></pre></td></tr></table></figure><h3 id="2-2-删除元素：delete"><a href="#2-2-删除元素：delete" class="headerlink" title="2.2 删除元素：delete()"></a>2.2 删除元素：<code>delete()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-comment">// 删除指定值</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(4) {1, 2, 4, 5}</span><br><br><span class="hljs-comment">// 删除不存在的值返回 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 删除对象引用需要相同的引用</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> })); <span class="hljs-comment">// false，因为不是同一个引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(obj)); <span class="hljs-comment">// true，删除成功</span><br></code></pre></td></tr></table></figure><h3 id="2-3-检查存在：has"><a href="#2-3-检查存在：has" class="headerlink" title="2.3 检查存在：has()"></a>2.3 检查存在：<code>has()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 对于 NaN，Set 能正确处理</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="2-4-清空-Set：clear"><a href="#2-4-清空-Set：clear" class="headerlink" title="2.4 清空 Set：clear()"></a>2.4 清空 Set：<code>clear()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 5</span><br><br>set.<span class="hljs-title function_">clear</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(0) {}</span><br></code></pre></td></tr></table></figure><h2 id="3-Set-的遍历方法"><a href="#3-Set-的遍历方法" class="headerlink" title="3. Set 的遍历方法"></a>3. Set 的遍历方法</h2><h3 id="3-1-forEach"><a href="#3-1-forEach" class="headerlink" title="3.1 forEach()"></a>3.1 <code>forEach()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>]);<br><br><span class="hljs-comment">// 遍历每个元素</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key, set</span>) =&gt;</span> {<br>  <span class="hljs-comment">// Set 的 key 和 value 相同</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);<br>});<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// apple: apple</span><br><span class="hljs-comment">// banana: banana</span><br><span class="hljs-comment">// orange: orange</span><br></code></pre></td></tr></table></figure><h3 id="3-2-keys-、values-、entries"><a href="#3-2-keys-、values-、entries" class="headerlink" title="3.2 keys()、values()、entries()"></a>3.2 <code>keys()</code>、<code>values()</code>、<code>entries()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]);<br><br><span class="hljs-comment">// keys() - 返回键名的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">keys</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// values() - 返回键值的遍历器（Set 的键和值相同）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// entries() - 返回键值对的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">entries</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry); <span class="hljs-comment">// ['a', 'a'], ['b', 'b'], ['c', 'c']</span><br>}<br></code></pre></td></tr></table></figure><h2 id="4-Set-的特性"><a href="#4-Set-的特性" class="headerlink" title="4. Set 的特性"></a>4. Set 的特性</h2><h3 id="4-1-唯一性"><a href="#4-1-唯一性" class="headerlink" title="4.1 唯一性"></a>4.1 唯一性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 自动去重</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> uniqueSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...uniqueSet]); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 对象引用不同，不算重复</span><br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> objSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([obj1, obj2, obj1]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objSet.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，obj1 和 obj2 被认为是不同的</span><br></code></pre></td></tr></table></figure><h3 id="4-2-与数组的对比"><a href="#4-2-与数组的对比" class="headerlink" title="4.2 与数组的对比"></a>4.2 与数组的对比</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 查找元素</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><br><span class="hljs-comment">// 数组查找是 O(n)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，需要遍历</span><br><br><span class="hljs-comment">// Set 查找是 O(1)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，哈希查找，更快</span><br><br><span class="hljs-comment">// 判断是否重复</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicates</span> = (<span class="hljs-params">array</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array).<span class="hljs-property">size</span> !== array.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="4-3-迭代顺序"><a href="#4-3-迭代顺序" class="headerlink" title="4.3 迭代顺序"></a>4.3 迭代顺序</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 的遍历顺序就是插入顺序</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 3, 1, 2（插入顺序）</span><br>}<br><br><span class="hljs-comment">// 与对象不同，对象的键顺序不保证</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-number">3</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>: <span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>: <span class="hljs-string">"c"</span> };<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)); <span class="hljs-comment">// ['1', '2', '3']（数字键会排序）</span><br></code></pre></td></tr></table></figure><h2 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h2><h3 id="5-1-数组去重（最常用）"><a href="#5-1-数组去重（最常用）" class="headerlink" title="5.1 数组去重（最常用）"></a>5.1 数组去重（最常用）</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传统方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniqueArray</span>(numbers)); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 字符串去重</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"hello world"</span>;<br><span class="hljs-keyword">const</span> uniqueChars = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueChars); <span class="hljs-comment">// 'helo wrd'</span><br></code></pre></td></tr></table></figure><h3 id="5-2-求交集、并集、差集"><a href="#5-2-求交集、并集、差集" class="headerlink" title="5.2 求交集、并集、差集"></a>5.2 求交集、并集、差集</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> setA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">const</span> setB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">const</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...union]); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">const</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...intersection]); <span class="hljs-comment">// [3, 4]</span><br><br><span class="hljs-comment">// 差集（A 有 B 没有）</span><br><span class="hljs-keyword">const</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...difference]); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="5-3-数据筛选"><a href="#5-3-数据筛选" class="headerlink" title="5.3 数据筛选"></a>5.3 数据筛选</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 从数组中过滤出唯一的元素</span><br><span class="hljs-keyword">const</span> data = [<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Bob"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> }, <span class="hljs-comment">// 重复</span><br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Charlie"</span> },<br>];<br><br><span class="hljs-comment">// 基于 id 去重</span><br><span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> uniqueData = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(item.<span class="hljs-property">id</span>)) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    seen.<span class="hljs-title function_">add</span>(item.<span class="hljs-property">id</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>});<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueData);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//     { id: 1, name: 'Alice' },</span><br><span class="hljs-comment">//     { id: 2, name: 'Bob' },</span><br><span class="hljs-comment">//     { id: 3, name: 'Charlie' }</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h3 id="5-4-标签-分类系统"><a href="#5-4-标签-分类系统" class="headerlink" title="5.4 标签/分类系统"></a>5.4 标签/分类系统</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TagSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-title function_">addTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">removeTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">delete</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">hasTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">has</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>  }<br><br>  <span class="hljs-title function_">getAllTags</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>];<br>  }<br><br>  <span class="hljs-title function_">merge</span>(<span class="hljs-params">otherTagSystem</span>) {<br>    otherTagSystem.<span class="hljs-property">tags</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">tag</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> articleTags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagSystem</span>();<br>articleTags.<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"Tutorial"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>); <span class="hljs-comment">// 不会重复添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(articleTags.<span class="hljs-title function_">getAllTags</span>()); <span class="hljs-comment">// ['javascript', 'tutorial']</span><br></code></pre></td></tr></table></figure><h2 id="6-Set-性能优势"><a href="#6-Set-性能优势" class="headerlink" title="6. Set 性能优势"></a>6. Set 性能优势</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 测试查找性能</span><br><span class="hljs-keyword">const</span> largeArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);<br><span class="hljs-keyword">const</span> largeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(largeArray);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Array查找"</span>);<br>largeArray.<span class="hljs-title function_">includes</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Array查找"</span>); <span class="hljs-comment">// 约 0.5-1ms</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set查找"</span>);<br>largeSet.<span class="hljs-title function_">has</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set查找"</span>); <span class="hljs-comment">// 约 0.01ms</span><br><br><span class="hljs-comment">// 测试重复检查性能</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesArray</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (arr[i] === arr[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesSet</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-keyword">const</span> testArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">() =&gt;</span><br>  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)<br>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"数组检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesArray</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"数组检查重复"</span>); <span class="hljs-comment">// 慢</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesSet</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set检查重复"</span>); <span class="hljs-comment">// 快</span><br></code></pre></td></tr></table></figure><h2 id="7-WeakSet"><a href="#7-WeakSet" class="headerlink" title="7. WeakSet"></a>7. WeakSet</h2><h3 id="7-1-与-Set-的区别"><a href="#7-1-与-Set-的区别" class="headerlink" title="7.1 与 Set 的区别"></a>7.1 与 Set 的区别</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 可以存储任何类型的值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// WeakSet 只能存储对象引用</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>weakSet.<span class="hljs-title function_">add</span>(obj); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// weakSet.add(1); // TypeError: Invalid value used in weak set</span><br><br><span class="hljs-comment">// WeakSet 的引用是弱引用，不会阻止垃圾回收</span><br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除引用</span><br><span class="hljs-comment">// 等待垃圾回收后，weakSet 中的对应项会自动被移除</span><br></code></pre></td></tr></table></figure><h3 id="7-2-WeakSet-的方法"><a href="#7-2-WeakSet-的方法" class="headerlink" title="7.2 WeakSet 的方法"></a>7.2 WeakSet 的方法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><span class="hljs-keyword">const</span> obj1 = {};<br><span class="hljs-keyword">const</span> obj2 = {};<br><br>weakSet.<span class="hljs-title function_">add</span>(obj1);<br>weakSet.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// true</span><br>weakSet.<span class="hljs-title function_">delete</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// WeakSet 没有 size 属性，不能遍历</span><br><span class="hljs-comment">// console.log(weakSet.size); // undefined</span><br><span class="hljs-comment">// weakSet.forEach(...) // 没有 forEach 方法</span><br></code></pre></td></tr></table></figure><h3 id="7-3-WeakSet-的应用场景"><a href="#7-3-WeakSet-的应用场景" class="headerlink" title="7.3 WeakSet 的应用场景"></a>7.3 WeakSet 的应用场景</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 1. 存储 DOM 节点，避免内存泄漏</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">"button"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button</span>) =&gt;</span> {<br>  weakSet.<span class="hljs-title function_">add</span>(button);<br>  button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (weakSet.<span class="hljs-title function_">has</span>(button)) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"按钮在集合中"</span>);<br>    }<br>  });<br>});<br><br><span class="hljs-comment">// 当按钮从 DOM 中移除时，会被自动垃圾回收</span><br><span class="hljs-comment">// weakSet 中的引用也会自动移除</span><br><br><span class="hljs-comment">// 2. 私有属性模拟</span><br><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    privateData.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 标记为"初始化"</span><br>  }<br><br>  <span class="hljs-title function_">isInitialized</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">has</span>(<span class="hljs-variable language_">this</span>);<br>  }<br>}<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Alice"</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-title function_">isInitialized</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="8-常见的一些陷阱和注意事项"><a href="#8-常见的一些陷阱和注意事项" class="headerlink" title="8. 常见的一些陷阱和注意事项"></a>8. 常见的一些陷阱和注意事项</h2><h3 id="8-1-NaN-的处理"><a href="#8-1-NaN-的处理" class="headerlink" title="8.1 NaN 的处理"></a>8.1 NaN 的处理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 注意：NaN === NaN 为 false，但 Set 认为 NaN 等于自身</span><br></code></pre></td></tr></table></figure><h3 id="8-2-对象引用"><a href="#8-2-对象引用" class="headerlink" title="8.2 对象引用"></a>8.2 对象引用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><br>set.<span class="hljs-title function_">add</span>(obj1);<br>set.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，因为 obj1 和 obj2 是不同的对象引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> })); <span class="hljs-comment">// false，新对象不是同一个引用</span><br></code></pre></td></tr></table></figure><h3 id="8-3-类型转换"><a href="#8-3-类型转换" class="headerlink" title="8.3 类型转换"></a>8.3 类型转换</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"1"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，1 和 '1' 类型不同，不会去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">"1"</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="8-4-遍历时修改"><a href="#8-4-遍历时修改" class="headerlink" title="8.4 遍历时修改"></a>8.4 遍历时修改</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 在遍历时删除元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">2</span>) {<br>    set.<span class="hljs-title function_">delete</span>(item); <span class="hljs-comment">// 当前正在遍历的元素可以安全删除</span><br>  }<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 1, 2, 3（会正常遍历完）</span><br>}<br><br><span class="hljs-comment">// 在遍历时添加元素可能有问题</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">1</span>) {<br>    set.<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加的元素在本次遍历中可能不会被访问</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="9-与其它数据结构的转换"><a href="#9-与其它数据结构的转换" class="headerlink" title="9. 与其它数据结构的转换"></a>9. 与其它数据结构的转换</h2><h3 id="9-1-Set-与-Array"><a href="#9-1-Set-与-Array" class="headerlink" title="9.1 Set 与 Array"></a>9.1 Set 与 Array</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set → Array</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> arr1 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set);<br><span class="hljs-keyword">const</span> arr2 = [...set];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1, arr2); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// Array → Set</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...newSet]); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="9-2-Set-与-String"><a href="#9-2-Set-与-String" class="headerlink" title="9.2 Set 与 String"></a>9.2 Set 与 String</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 字符串去重并排序</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"javascript"</span>;<br><span class="hljs-keyword">const</span> uniqueSorted = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueSorted); <span class="hljs-comment">// 'aijprstv'</span><br></code></pre></td></tr></table></figure><h3 id="9-3-Set-与-Map"><a href="#9-3-Set-与-Map" class="headerlink" title="9.3 Set 与 Map"></a>9.3 Set 与 Map</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用 Set 存储 Map 的键</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>],<br>]);<br><br><span class="hljs-keyword">const</span> keysSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(map.<span class="hljs-title function_">keys</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...keysSet]); <span class="hljs-comment">// ['a', 'b', 'c']</span><br></code></pre></td></tr></table></figure><h2 id="10-综合示例"><a href="#10-综合示例" class="headerlink" title="10. 综合示例"></a>10. 综合示例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实现一个简单的权限系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-comment">// 添加权限</span><br>  <span class="hljs-title function_">addPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 批量添加权限</span><br>  <span class="hljs-title function_">addPermissions</span>(<span class="hljs-params">permissionsArray</span>) {<br>    permissionsArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 检查是否有某个权限</span><br>  <span class="hljs-title function_">hasPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(permission);<br>  }<br><br>  <span class="hljs-comment">// 检查是否有所有指定权限</span><br>  <span class="hljs-title function_">hasAllPermissions</span>(<span class="hljs-params">requiredPermissions</span>) {<br>    <span class="hljs-keyword">return</span> requiredPermissions.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 检查是否有任一指定权限</span><br>  <span class="hljs-title function_">hasAnyPermission</span>(<span class="hljs-params">permissions</span>) {<br>    <span class="hljs-keyword">return</span> permissions.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 获取所有权限</span><br>  <span class="hljs-title function_">getAllPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>];<br>  }<br><br>  <span class="hljs-comment">// 移除权限</span><br>  <span class="hljs-title function_">removePermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">delete</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 清空所有权限</span><br>  <span class="hljs-title function_">clearPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">clear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> userPermissions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionSystem</span>();<br>userPermissions<br>  .<span class="hljs-title function_">addPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>, <span class="hljs-string">"delete"</span>])<br>  .<span class="hljs-title function_">addPermission</span>(<span class="hljs-string">"execute"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasPermission</span>(<span class="hljs-string">"write"</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasAllPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">getAllPermissions</span>()); <span class="hljs-comment">// ['read', 'write', 'delete', 'execute']</span><br></code></pre></td></tr></table></figure><hr><p>总之</p><ul><li>高效查找：<code>has()</code>方法的时间复杂度是 O(1)</li><li>遍历时按插入顺序输出</li><li>需要去重时，优先考虑 Set</li><li>需要快速查找元素是否存在时，用 Set 代替数组</li><li>存储唯一值集合时，Set 是最佳选择</li><li>需要存储对象引用并自动清理时，考虑 WeakSet</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-Set-方法详解&quot;&gt;&lt;a href=&quot;#JavaScript-Set-方法详解&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Set 方法详解&quot;&gt;&lt;/a&gt;JavaScript Set 方法详解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-力扣百题速练（Javascript/TypeScript）Vol.1</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39687.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39687.html</id>
    <published>2025-12-25T05:57:08.000Z</published>
    <updated>2025-12-27T03:55:34.755Z</updated>
    
    <content type="html"><![CDATA[<p>简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都</p><hr><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target<br>在该数组中找出 <strong>和为目标值 target</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标<br>你可以假设每种输入只会对应一个答案，并且同一个元素不能重复使用</p><p><strong>示例</strong>：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1] 解释：因为 nums[0] + nums[1] = 2 + 7 = 9。</p><p>直接用双重循环解，优化的话其实可以上哈希表</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) {<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) {<br>                <span class="hljs-keyword">return</span> [i, j];<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> [];<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p>给定两个非空单向链表，表示两个非负整数<br>每个节点存储一位数字，数字以逆序存储（个位在头部），要求返回一个新链表表示它们的和（同样逆序存储）<br>不允许修改原链表</p><p><strong>示例：</strong><br>输入：l1 = 2 → 4 → 3（表示 342），l2 = 5 → 6 → 4（表示 465）<br>输出：7 → 0 → 8（表示 807）</p><p>本质上是模拟竖式加法，从低位到高位逐位相加。由于链表逆序存储，正好从个位开始遍历</p><ol><li><strong>逐位相加并处理进位</strong>：<ul><li>同时遍历两个链表的节点，取当前节点值相加，加上上一位的进位（初始进位为 0）。</li><li>当前位结果 = (val1 + val2 + carry) % 10</li><li>新进位 carry = Math.floor((val1 + val2 + carry) / 10)</li></ul></li><li><strong>使用哑节点（dummy head）简化代码</strong>：<ul><li>创建一个哑节点，尾指针指向它，便于统一处理头部节点，避免单独处理第一个节点。</li></ul></li><li><strong>处理链表长度不等和最终进位</strong>：<ul><li>当一个链表遍历完时，将另一个链表的剩余节点视为 val = 0 继续相加。</li><li>遍历结束后，若仍有进位（carry = 1），需添加一个新节点值为 1。</li></ul></li></ol><p>提供以下 ListNode 类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params"><span class="hljs-attr">l1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">l2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dummy</span>: <span class="hljs-title class_">ListNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 哑节点，没有 dummy，直接从第一个节点开始构建，结果链表的头节点会在循环中不断变化</span><br>  <span class="hljs-comment">//需要额外判断是否是第一个节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">ListNode</span> = dummy;<br>  <span class="hljs-comment">//始终指向结果链表的“当前最后一个节点”。</span><br>  <span class="hljs-comment">//每次计算出一位新数字后，直接在 tail 后面添加新节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">carry</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 进位，当前这一位加完后，是否需要给下一位（更高位）额外加 1</span><br><br>  <span class="hljs-keyword">while</span> (l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span> || carry !== <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val1</span>: <span class="hljs-built_in">number</span> = l1 ? l1.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val2</span>: <span class="hljs-built_in">number</span> = l2 ? l2.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">sum</span>: <span class="hljs-built_in">number</span> = val1 + val2 + carry;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">digit</span>: <span class="hljs-built_in">number</span> = sum % <span class="hljs-number">10</span>;<br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br><br>    tail.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(digit);<br>    tail = tail.<span class="hljs-property">next</span>;<br><br>    <span class="hljs-keyword">if</span> (l1) l1 = l1.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (l2) l2 = l2.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p>要求给定一个字符串 s，找出其中不含有重复字符的最长<strong>子串</strong>的长度<br>（而非子序列）</p><p><strong>示例：</strong></p><ul><li>输入：”abcabcbb” → 输出：3（子串 “abc”）</li><li>输入：”bbbbb” → 输出：1</li><li>输入：”pwwkew” → 输出：3（子串 “wke”）</li></ul><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp" alt="Longest Substring Without Repeating Characters - GeeksforGeeks"></p><p>直接上滑动窗口，结合哈希集合（Set）或映射</p><ul><li>使用左指针 left 和右指针 right 维护一个窗口 (left, right)</li><li>扩展右指针，若遇到重复字符，则收缩左指针直到无重复</li><li>每次更新最大长度 maxLength = Math.max(maxLength, right - left)</li></ul><p class='item-img' data-src='https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png'><img src="https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png" alt=""></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// 记录窗口内字符</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 左指针</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-property">length</span>; right++) {<br>        <span class="hljs-comment">// 若当前字符已存在，收缩左指针</span><br>        <span class="hljs-keyword">while</span> (charSet.<span class="hljs-title function_">has</span>(s[right])) {<br>            charSet.<span class="hljs-title function_">delete</span>(s[left]);<br>            left++;<br>        }<br>        charSet.<span class="hljs-title function_">add</span>(s[right]);<br>        maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLength, right - left + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> maxLength;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><p>要求在两个已排序数组 nums1 和 nums2 中找到合并后的中位数，且时间复杂度必须为 O(log(m + n))，其中 m 和 n 分别为数组长度</p><p><strong>示例</strong>：</p><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><h3 id="最初思路"><a href="#最初思路" class="headerlink" title="最初思路"></a>最初思路</h3><p>最开始打算做双指针合并，使用两个指针 i 和 j 分别指向 nums1 和 nums2 的当前待比较位置（初始为 0），每次比较 nums1[i] 和 nums2[j]，将较小的元素放入结果数组 merged，并将对应指针后移，当某个数组遍历完后，将另一个数组剩余元素全部追加到 merged，合并完成后，merged 就是一个完整有序数组</p><p>然后就可以根据总长度奇偶性计算中位数：<br>奇数直接取第 (total+1)/2 个元素（索引 mid）<br>偶数取第 total/2 和第 total/2 + 1 个元素的平均（索引 mid-1 和 mid）</p><p>想了 40 分钟，但是复杂度 m * n，直接寄了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; nums2.<span class="hljs-property">length</span>; j++) {<br>        <span class="hljs-keyword">while</span>(nums2[j] &lt;= nums1[i]);<br>            merged.<span class="hljs-title function_">push</span>(nums2[j]);<br>        }<br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; nums2.<span class="hljs-property">length</span>; k++) {<br>        merged.<span class="hljs-title function_">push</span>(nums2[k]);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> ? merged[mid] : (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li><strong>外层 for</strong>：遍历 nums1 的每一个元素 nums1[i]。</li><li><strong>内层 while</strong>（代替 for，避免重复遍历）：在放入 nums1[i] 之前，先检查 nums2 的头部元素（nums2[0]）。<ul><li>只要 nums2[0] &lt;= nums1[i]，就说明这个元素应该排在 nums1[i] 前面，先放入 merged，并从 nums2 中移除（使用 shift()）。</li><li>这样保证了顺序正确。</li></ul></li><li>放入当前 nums1[i]。</li><li>外层循环结束后，如果 nums2 还有剩余元素（说明它们都大于 nums1 所有元素），直接全部追加。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>  <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>      merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!); <span class="hljs-comment">// 取出 nums2 头部元素</span><br>    }<br>    <span class="hljs-comment">// 放入当前 nums1[i]</span><br>    merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>  }<br>  <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>  <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>    merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>  }<br><br>  <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-keyword">return</span> merged[mid];<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>暴力合并为 O(m + n)，但题目要求对数复杂度，因此需避免完整合并。核心思路是将问题转化为<strong>在较短数组上二分查找一个分区点</strong>，使左右部分满足中位数条件：</p><ul><li>总元素数 total = m + n。</li><li>中位数位置：若 total 奇数，为第 (total + 1)/2 个元素；若偶数，为第 total/2 和第 total/2 + 1 个元素的平均。</li><li>我们需要在合并数组的“左侧”选取 total/2 个元素（使用 (total + 1)/2 以统一奇偶处理）。</li><li>在较短数组 A 上二分查找左侧元素个数 i（0 ≤ i ≤ m），则较长数组 B 左侧元素个数 j = (total + 1)/2 - i。</li><li>分区条件：<ul><li>左侧最大值 ≤ 右侧最小值：max(A[i-1], B[j-1]) ≤ min(A[i], B[j])。</li></ul></li><li>处理边界：使用 -∞ 和 +∞ 填充空侧。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>确保 nums1 为较短数组（若不是，交换）。</li><li>二分范围：low = 0, high = nums1.length。</li><li>计算分区：i = (low + high) / 2, j = (m + n + 1) / 2 - i。</li><li>检查分区：<ul><li>若 A[i-1] &gt; B[j]，则 i 太大，high = i - 1。</li><li>若 B[j-1] &gt; A[i]，则 i 太小，low = i + 1。</li><li>否则，分区正确。</li></ul></li><li>计算中位数：<ul><li>左侧最大：max(A[i-1], B[j-1])。</li><li>右侧最小：min(A[i], B[j])。</li><li>若 total 奇数，返回左侧最大；偶数，返回平均。</li></ul></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入 merged</span><br>        <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>            merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);  <span class="hljs-comment">// 取出 nums2 头部元素</span><br>        }<br><br>        <span class="hljs-comment">// 放入当前 nums1[i]</span><br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> merged[mid];<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="5-最长的回文子串"><a href="#5-最长的回文子串" class="headerlink" title="5.最长的回文子串"></a>5.最长的回文子串</h2><p>要求给定一个字符串 s，返回其中最长的回文子串（回文指正读反读相同的连续子串）<br>示例：</p><ul><li>输入：”babad” → 输出：”bab” 或 “aba”（长度 3）</li><li>输入：”cbbd” → 输出：”bb”（长度 2）</li></ul><p class='item-img' data-src='https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png'><img src="https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png" alt="Leetcode 5. Longest Palindromic Substring | Nick Li"></p><h3 id="中心扩展法（Expand-Around-Center）"><a href="#中心扩展法（Expand-Around-Center）" class="headerlink" title="中心扩展法（Expand Around Center）"></a>中心扩展法（Expand Around Center）</h3><p>时间复杂度 O(n²)，空间复杂度 O(1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回文串以中心对称。中心可能为单个字符（奇数长度回文）或两个相同字符间（偶数长度回文）。 对于字符串每个可能中心（共 2n-1 个），向两侧扩展比较字符，直至不对称。记录扩展中最长回文。</p><p>步骤：</p><ol><li>遍历字符串索引 i 从 0 到 n-1。</li><li>以 i 为中心扩展奇数长度回文。</li><li>以 i 和 i+1 为中心扩展偶数长度回文。</li><li>每次扩展更新最长回文起点和长度。</li><li>返回对应子串。</li></ol><p class='item-img' data-src='https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg'><img src="https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg" alt="Longest Palindromic Substring (With Visualization)"></p><h3 id="TypeScript-实现"><a href="#TypeScript-实现" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 最长回文起点</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最长回文长度（初始至少 1）</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">expandAroundCenter</span>(<span class="hljs-params"><span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-property">length</span> &amp;&amp; s[left] === s[right]) {<br>            <span class="hljs-keyword">const</span> currentLength = right - left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (currentLength &gt; maxLength) {<br>                start = left;<br>                maxLength = currentLength;<br>            }<br>            left--;<br>            right++;<br>        }<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 奇数长度回文（中心为 i）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i);<br>        <span class="hljs-comment">// 偶数长度回文（中心为 i 和 i+1）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(start, start + maxLength);<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="6-Z-字变换"><a href="#6-Z-字变换" class="headerlink" title="6. Z 字变换"></a>6. Z 字变换</h2><p>将一个给定字符串  <code>s</code>  根据给定的行数  <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列<br>比如输入字符串为  <code>"PAYPALISHIRING"</code>  行数为  <code>3</code>  时，排列如下：</p><p>P A H N<br>A P L S I I G<br>Y I R</p><p>之后输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>"PAHNAPLSIIGYIR"</code></p><p>实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><p>输入：s = “PAYPALISHIRING”, numRows = 3<br>输出：”PAHNAPLSIIGYIR”</p><p>示例 2：</p><p>输入：s = “PAYPALISHIRING”, numRows = 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br>P I N<br>A L S I G<br>Y A H R<br>P I</p><h3 id="TypeScript-实现-1"><a href="#TypeScript-实现-1" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><p>直接计算位置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">numRows</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (numRows === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> cycle = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; numRows; row++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i + row &lt; s.<span class="hljs-property">length</span>; i += cycle) {<br>      result += s[i + row];<br>      <span class="hljs-keyword">if</span> (row !== <span class="hljs-number">0</span> &amp;&amp; row !== numRows - <span class="hljs-number">1</span> &amp;&amp; i + cycle - row &lt; s.<span class="hljs-property">length</span>) {<br>        result += s[i + cycle - row];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><p>给你一个 32 位的有符号整数  <code>x</code> ，返回将  <code>x</code>  中的数字部分反转后的结果<br>如果反转后整数超过 32 位的有符号整数的范围  <code>[−231, 231 − 1]</code> ，就返回 0<br>假设环境不允许存储 64 位整数（有符号或无符号</p><p>示例 1：<br>输入：x = 123<br>输出：321</p><p>示例 2：<br>输入：x = -123<br>输出：-321</p><p>没啥好讲的，转字符串反转再转回去，处理一下负号和边界情况就成</p><p>反转字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">return</span> x;<br>  }<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX</span> = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN</span> = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> mid = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">LI</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (mid[<span class="hljs-number">0</span>] === <span class="hljs-string">"-"</span>) {<br>    <span class="hljs-variable constant_">LI</span> = <span class="hljs-literal">false</span>;<br>  }<br>  <span class="hljs-keyword">const</span> reverseString = mid.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">true</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(reverseString) &lt; <span class="hljs-variable constant_">MIN</span> || <span class="hljs-built_in">parseInt</span>(reverseString) &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(reverseString);<br>  }<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">false</span>) {<br>    <span class="hljs-keyword">let</span> fin = reverseString.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, reverseString.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> fin2 = -<span class="hljs-built_in">parseInt</span>(fin);<br>    <span class="hljs-keyword">if</span> (fin2 &lt; <span class="hljs-variable constant_">MIN</span> || fin2 &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> fin2;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8.字符串转换整数"></a>8.字符串转换整数</h2><p>实现一个  <code>myAtoi(string s)</code>  函数，使其能将字符串转换成一个 32 位有符号整数。</p><p>函数  <code>myAtoi(string s)</code>  的算法如下：</p><ol><li>空格：读入字符串并丢弃无用的前导空格（<code>" "</code>）</li><li>符号：检查下一个字符（假设还未到字符末尾）为  <code>'-'</code>  还是  <code>'+'</code>如果两者都不存在，则假定结果为正</li><li>转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾，如果没有读取数字，则结果为 0</li><li>舍入：如果整数数超过 32 位有符号整数范围  <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于  <code>−231</code>  的整数应该被舍入为  <code>−231</code> ，大于  <code>231 − 1</code>  的整数应该被舍入为  <code>231 − 1</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myAtoi</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> min = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">sign</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> fin = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> clac = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (i &lt;= s.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">" "</span>) {<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">"-"</span> || s[i] === <span class="hljs-string">"+"</span>) {<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"-"</span>) {<br>        sign = -<span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"+"</span>) {<br>        sign = <span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (clac === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      }<br>      clac = <span class="hljs-number">1</span>;<br>      i++;<br>    }<br>    <span class="hljs-keyword">while</span> (s[i] &lt;= <span class="hljs-string">"9"</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">"0"</span>) {<br>      fin = fin + s[i];<br>      i++;<br>    }<br>    <span class="hljs-keyword">if</span> (fin === <span class="hljs-string">""</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sign === <span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(fin);<br>    }<br>    <span class="hljs-keyword">if</span> (sign === -<span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> -fin;<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure><p>没啥好说的，处理一下转换和条件判断的事情</p><hr><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h2><p>给一个整数  <code>x</code> ，如果  <code>x</code>  是一个回文整数，返回  <code>true</code> ；否则，返回  <code>false</code><br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数<br>例如，<code>121</code>  是回文，而  <code>123</code>  不是</p><p>智斗程度堪比两数之和，转字符串逆序比较秒了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> arr = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> brr = arr.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (arr === brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">if</span> (arr !== brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.正则表达式匹配</h2><p>给你一个字符串  <code>s</code>  和一个字符规律  <code>p</code>，请你来实现一个支持  <code>'.'</code>  和  <code>'*'</code>  的正则表达式匹配。</p><ul><li><code>'.'</code>  匹配任意单个字符</li><li><code>'*'</code>  匹配零个或多个前面的那一个元素</li></ul><p>匹配是要涵盖  <strong>整个</strong>  字符串  <code>s</code>  的，而不是部分字符串。</p><p>示例 1：</p><p>输入：s = “aa”, p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:</p><p>输入：s = “aa”, p = “a<em>“<br>输出：true<br>解释：因为 ‘</em>‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p>示例 3：</p><p>输入：s = “ab”, p = “.<em>“<br>输出：true<br>解释：”.</em>“ 表示可匹配零个或多个（’*‘）任意字符（’.’）</p><p>这道题最开始是想要用纯同步双指针来解，没解出来</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">if</span> (s == p) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">let</span> sindex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> pindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (sindex &lt; s.<span class="hljs-property">length</span> &amp;&amp; pindex &lt; p.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">if</span> (s[sindex] === p[pindex] || p[pindex] === <span class="hljs-string">"."</span>) {<br>      sindex++;<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (p[pindex] === <span class="hljs-string">"*"</span>) {<br>      <span class="hljs-keyword">while</span> (s[sindex] === s[sindex + <span class="hljs-number">1</span>]) {<br>        sindex++;<br>      }<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (s[sindex] !== p[pindex]) {<br>      <span class="hljs-keyword">if</span> (p[pindex] !== <span class="hljs-string">"*"</span> &amp;&amp; p[pindex] !== <span class="hljs-string">"."</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>↑ 错误答案</p><p>主要是该问题具有<strong>非确定性</strong>：同一个 “x*“ 可以有多种匹配方式（0 次、1 次、多次），需要尝试不同分支。纯同步双指针（单路径贪婪）无法处理回溯需求，会在某些案例中错误消耗字符，导致后续失败。</p><p>比如说在 s = “aaa”, p = “ab<em>a” 里贪婪匹配可能错误使用 “b</em>“，而实际应跳过 “b*“（匹配 0 次）</p><p>因此<strong>不能用简单 while 循环同步双指针线性解决</strong>，必须引入分支或状态记录</p><p>然后题解就是使用 dp 解决：</p><p><code>定义二维布尔数组 dp[i][j] 表示：s 的前 i 个字符（s[0..i-1]）是否能被 p 的前 j 个字符（p[0..j-1]）匹配，最终答案为 dp[m][n]，其中 m = s.length，n = p.length</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">const</span> m = s.<span class="hljs-property">length</span>,<br>    n = p.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> dp = <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));<br><br>  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>      dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>    }<br>  }<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>      <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>        dp[i][j] =<br>          dp[i][j - <span class="hljs-number">2</span>] ||<br>          ((s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">2</span>] || p[j - <span class="hljs-number">2</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j]);<br>      } <span class="hljs-keyword">else</span> {<br>        dp[i][j] =<br>          (s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> dp[m][n];<br>}<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p><strong>空串与空模式</strong><code>dp[0][0] = true</code>：空字符串可以被空模式匹配。<br><strong>空字符串与非空模式</strong> 只有当模式中某些 “x*” 可以匹配 0 次字符时，才可能匹配空字符串。 因此从左向右扫描模式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'*'</span>) {<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">2</span>];  <span class="hljs-comment">// 直接继承“跳过当前 x*”的状态</span><br>    }<br>}<br></code></pre></td></tr></table></figure><p>示例：p = “a<em>b</em>c*“ 可以匹配空字符串，故 dp[0][2]、dp[0][4]、dp[0][6] 均为 true。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>遍历 <code>i = 1..m</code> 和 <code>j = 1..n</code>，根据 <code>p[j-1]</code> 的类型分为两种情况：</p><ol><li><p><strong>当前模式字符不是 ‘*‘</strong>（普通字符或 ‘.’） 只能进行单字符匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = (s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">1</span>] || p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>含义：当前字符匹配且前一个子问题也匹配，则当前子问题成立。</p></li><li><p><strong>当前模式字符是 ‘*‘</strong>（与前一个字符组成 “x<em>”） ‘</em>‘ 提供了两种选择：</p><ul><li>匹配 0 次：直接跳过整个 “x*”，状态等同于 dp[i][j-2]。</li><li>匹配 1 次或多次：前提是当前 <code>s[i-1]</code> 能与 “x” 匹配（<code>s[i-1] === p[j-2]</code> 或 <code>p[j-2] === '.'</code>），且在上一个字符已匹配的基础上继续使用 “x*” 匹配当前字符，即 <code>dp[i-1][j]</code></li></ul><p>两者任一成立即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] ||<br>          ((s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">2</span>] || p[j-<span class="hljs-number">2</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j]);<br></code></pre></td></tr></table></figure></li></ol><h3 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h3><ul><li>时间复杂度：O(mn)，每个状态只计算一次。</li><li>空间复杂度：O(mn)，可进一步优化为 O(n)（仅使用两行或一行滚动数组）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-15-杂谈-系统问题</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/48096.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/48096.html</id>
    <published>2025-12-15T03:51:13.000Z</published>
    <updated>2025-12-25T03:23:33.852Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="请联系站长。WXID:Zhong_ye1" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">      <script id="hbeData" type="hbeData" data-hmacdigest="b8fcd18a080f1cf047c8ee1822e314d7165d4b09142fd7a7054ef368b3988afa" data-keysalt="1cfdb7dcab8674a88c79c4a30479cb8f6532bec6c41040c7b28064798b9dc469" data-ivsalt="69855e72c8fedfc42104220c0a0e6332da1461abe56a79d718ec537c9914620a">        8c0d99e05f3cc987b62b1c22be8802eff474d974c8a7667afb5eff59a45dcfe468893e968bb98b69deba7c15ed35c2b67fa654b21fcaae49faa5374469ad5d5c84bf006261bd00c005704d82407b8fa3c1d7311a1ad47912cd1565beb1efd98d107778a5da7b7fdefcb63bfaf38cf43b39933ac8c27492b3fe5d046e8df6a79c93e3f2c8ec134823f6633fb46c1158f06e80dde630c649c73aa83d38e9bdb617384426f667c71dd8570e09f9716dec96fa70153144cda3d991e0e5651f3496f95cdccadac1d2a8eccb039c5c839c56198f2f88c6bdbfbd469208ad4100f27a5b28e6763f1db1f91b755aa24baafaf24678fd85377cdb950545e19f51699aefc843193bd5ff9c47b6291b06114e89567b8e2d77527a2314b11240ecdc8f7c38d682601b07279bbac8de5a80bc99f9018c08a89749171747f24724b878734e198278d951a1b2ebba7d57961130f562d687876a9951254349038f23850a3c2279950e94f9edad342db6f9ae82650dc405afef638cff2c23c86f08fae2ee6aa767e5946454aae0065541bd37612c1c1bab45b899f8c229fb6a8223d3c1cba7065ff1107079f38a97f10f64f4a9a77f26d25acc319790bc9941bd47a694873425ded3cfb96107186f4e48d16878914ccde8eba4cefa250785ed8a4d8379b98a8d006d1f5a26aef07084600c219c28171b910cfa5b9fa727f734ad7fd0a9696e53428a898667d03989d4675ab8985fc620cc14fea0936ef6805499d34b4c16b04a904f8769a520b2850c307c1650b88a57a33a02e02486cffcf3c4984dc1abb7c8cd180d5102b725b3d889e8f7aad772184385622042d884c6f286a92054d0c28f777af82ceec3757bfef870db4f2462b91fd7522efac0c232d6ab4fe6fc8553662950c2396248424a624f242c0832234ac80bd67b055e4cc4f8bd485c475279845aff71a8c9c07078d823477120a54c4db912284fee738d0357a862a64a81835c6fe77b74afbd05f0081380a42bfe5a25c04b6af3802df61a33453c4af35b09c6fb25320292b9ddb47a67770ff31aa8b4e7c014e63d2eb59c23b5b73b7ceb9efcb4917d7ff8ee9208ee00f8eca8d1a35226d44a07e06af8e9deffe110d8f4c3659e70403981ba333bd4004bd82e4e8ae35fcc042a165fe4393add09ce6c830bf706055fba4fd67a3cffb1404fd6a2ef00f87ff84af59772e275cf4b355c9dacf711f07ad478bf155f63c3037e6d78069f757419b21415f0bbc04d4258541e861d4ac7821957cc724287e0a21b264f9dbae02a86c0281aa03266d00671796da623a76bcffa28c445c0e495ded5b55129a2c37f6deb964747488427de1999ea087fdb12177f637d42ddd03e87de929a0c2cbf0db0d40c71da2f41d9e2ba16441aa9d70c1079ba1f107362f0fc54520408dfd01dd4fcf0792fd9b7571ed48f7a4bb89bec570984a56d139c31c54f5242cef0eff3050ea6691d3d19d7988712afd4d49c8a9ab9f0bf15bdd417d60106604f19aa0fe8d7efcacfa2f3c51959494d9a9abfef765aa168a56b52861efeaebd0443b504b0b7615f2f7dfa1ce3f0c4e321aff41228c73496b56f274c5a43aec17a91bdc7f49d8cba8ba87a82be822d7e77a19631054b96b6cc3d8767a9307371205d6feac4155a641d0b0a69c062581428d84a3ef60458d6f61c11315c2f410962872bccf80157c690c01d1c37e58e7126c2c49c571b82169da4fbdde158ee20deb48b71a4cb86b3965f5d2b242532dcf7d59895dd604c0ace84984b19cae44f932073cc6cea1519ed9149fcf76cd9ff8b0bddc6a9fb0af9b8ac8154c10591b89c60f961fcbe6a5ce8bb5d4040720523a42f2be58519ad5e3d77a09c67677eae08581a3cdbce9a9af180da179123e1e5e1445519fd8b37b425817ffbcee2b25da7f6565851f4c81342f916098dc6dfdd46206eaba664bf9e13d47a7fec6a191d63f777f4b84378e42de92d29d16d40e0b4b77d2d57a82ae01f766218d450411a591b42b7b85b3f7f44696fb42bc6cccb49ef5c061230ee9c963ae369e47ab0c43f40f51862aedd3770a146ed02a3a53d936be8988940fb0b851ecdf8229e4e642a66a13fb298169ee1b8ad5f628307c8eee458381b676c05a8ef8ac6293c378edf3173da596c37a434232c1a78bdb50332ec9678f2441a69057350fe1adabe9aa639a392624e59cd70431415de1e865a895e6c71395c9e83705dc5779c0fe7d2b3f48a0549b71fe296f9b7a02e436007be22a830ccdc0f2ab37cc6e6c50efa24dec259f8c3c8a0e812020b9a0f5b9c56bc6147b585eb06dff6a12380675c7258b912ea231b7e410eacf8ebc833a98dd528f3cdc8f84639f20a23910bfd73d3549eac47eddf4ddf01913180a65fc11d7c959dea2fdef007f2761aa1e3596e7c5a30b40404f90979224a5d85c2423578d364ff1bc6dcd5f55d9010a72a32e95852b6309ad490bb1194e095e9896d1398b5791d6c04e47d9eb0c3df8b3c220275c6fb2034227276b123edeed9dec017a5492b28865fab75c1c556bc02ffdb9559e79e7ff12b560e9165b91e4642433cc609e672a3bd992ea8771c95b3191293a4cab4fa61dd923b887369b0eecfb03fde137e20fa4792786fac788e125f9e9c0c50837045ee923be4e1054db55e86796f61521168985b32e66519d5e970bf1b8957b1be6b6cc53c8a26fc1db67aae2c7f723a8457e2529f5677314b3b42d17ffde9f78d5ef503cc571671b1ea0f91d2516f000eba57b17c6123d1219c642f4420c9e16902a454b0825d00035323404b5a8bf6be5c8b88d02cd3ae85f13cfb47d5ceae3f1eabf2f2fe67f03fd1153ae68bf7e4e1f49eabdd3491241e448215babfba818fee171b396c8268386882a2ea001c48772b84d44f3f1ae4bafb197b36bbfaeadd97d0c2195fbde88b27e12738b95d31af7609296d8c737310eec1f561db716902708ba18c5cc0856b658373d94be0497a876a7b2a2937c059f1a6b866021d3a72fc18475c075c577262a9c4430105467c8852138434f901264bd5a53557f888e4c618bca172f43ea9b0608eaf0c58b0d3e073e9c07430f6e42280f461bae8de2237182867014ad4ef75e013b425c0856ecec746c6ad1762d1e8b31febd66af232af911934fce4319e5b01a057a83afb27babd3270b365da93c1a437da0c4aaf84008ca4b1d02cc01621a7e3d04d22fa3f50678e07136f8f628cbae3523351af29f78e11d3e0018842c645589faad465ec3a9cf7524444edfe29616041101bd72c680a2597d17ef2e620abee7703e668344bebf0229be7aba2efe83a3ca745e6f1c6189c7e0a445ee8f614f3df959443dc82b48ac8966e481b8b66aae8db3a6fc1186e55c11fe7ab60d83ab8f96e6b1c75e7a00f1f9926ecadd0027a727d1bd1c539ceb07366f5e7bf66eb629fe807d3dc60846ec7d26716fa164faee39616b55619616e71b19df2925e2a03863503cf4d46a8ca4596be7cd72bb653e5e773d7acdb1db2b811c3ca0f1a162bda5517d1e60b7ff9f77ffc03e9b84cb562b2cf114b61188630dfd7287b27a9d3378a06bce1ac358b37f4b7d035563ce60be64e4835cfec6357482113d539b1260d11d2977b732d39e87657eb617cd20d48e0e545beaac2d5f1cbb7dd8c4ca83ffb1a6b7a71ae187d1b5d4099c7872db6534d3dd440b49e052a26e6835a9a7bb43cf354870f4282cd76f0dcd45a0c791374b721f04cf4c33c9eda820dc0b0f5b831522357ff15745a5eef35efad5daae6b895fe692802a071c2e65448506f49d57f8aa3eb99afafb74a3419d3333432f6e85557f9f9f6ab41ebc4b6f8b9d8f0ed340f7047e70200e3a8b2404b4708f71c8251cd1913598167cafebec2d351cf7e97be20e80c2af70333acc5c71d3224b45df0fca2eb35861d3e6ef761bce302d006743dee21ce4e03439a57eb0bcb710819f1cc78b075ca9519140b22fb94306fbc515ad9e8af54e3bb2494dfc810b5f49ca51667126b95870d69587f293b580e942c14fa661059e4b42c81998e440ec07867294b332f72b840926512495eb7363083aea409305b5d37823ae7c46018409ce6cc80d0a790dcb4a175eb9867054023d573618ee0be9c01247559317c9c8fb2a7b63ff8f6c5046eb1c63c6e2cef8792b65f10ae3597aa8b95ad30c46e855841914f0aaa873c1f8e4e2c75edbc68c90793889652e08479d695d68046c51d6d0ca81a25793fe6e8d8e73073de5b38e213c4cf4f668a38960021739f197ab202aefb758f452ce9fb15c5232f2d124a602f18e4a10f1563facbca08385e05b6b683b79d6fc83cf4e3a47824b6496a16cdc5308b50e2a5e38901a1cd446edc208e5b3037a3ab4963563400e918a3d616a84f0f507ee084dcfe66f97074acc8dc5acbb29b707af682abf07df2b638037698a01e1614cf876c4395e049c7435b033fab59315fff32f19b62d41742d909902da4c89432cd93354c996b33c29bbe05a011f423cdb500b941657df4dc2f333ac5469e4999c2fe4ed820a458add8c67164aec0b3275434f83e23bd0a5b9b25dbbc9163b406ecef834b54091f3cdba04939ee05e33492e6b59824135e01e8637b8bf1344eec4cb2385e2878c7a32324e63fc38b2b9df1c7a198028d8bb15e51c106c5930d44183015b09ad3b50041688080d37e669c881dc0768a725e8b793a613bedc4f8065d934c5e68525f9a9306de693d1ff568a899c4294a091ab74f1b68e6eb366e3262b98b324ab27dd731ec2b06d45e39b4c16860fd08bab055c4ddc8d3776a5ef72dc7839eb9a9bf058991d0484f749ba24eb6e1af3947f2134cbba11dd5c3a4cb480c7e3f2451bd48b365fd48231069933555f8c9f121151d7d85292f1b47f242d01c9b22a88ec8ec0c788761022eeb20d582508f7149c0a3fe70d1f1dd02f369172ca201bbabe4c4cc62a868ba1202914a1b2b20c6389302bb3a07ecaed7175dab929f68a4b8f1ebbfa521e45f8a5dae3f588c7c52d0f9135aa711c30ee413fb099b6f81da45da0985949fc10718921d429407c80832ba80dd1f5bb07c8674a9cf845699ebe334a51d0430b92be6bb90d16528ab8e5438a1c8e8a56cb7693ed31da8aadd306190b6b8de909d244dae4b0c8e7d8e5ccceadabdbef3f6b54c52638442009db998479b22fc137acb05edd6b76d0b9c688aa9861ef94252f53f9951f239bc85ca9905efbb3f055a0a621cbfe7532fb3b1bf5b50ecaa4aa746dda6fd9469a0eb84672a35cf2b5a9f5cd906f801fce76d70a6d22bebd335c1bdd51874b1de873f9fb43be84e4ace0e4147d7f69397b6acba218b6ec8ae830573483af14f2801e66fbfdfa58190a7968a44a30681c44dbe5768f54c9bdc57dfe93bc3962cea43b29f6441ada3f73698f2be4d0b706c5c51095e651d72f0aeff76402883afbad2d2a2cc69e2f18d6472da8218b6bf4468306f5737d31e93a91312d2375685f2de2167a686c25f16cdc23752bf9842abe933b752287bd8888d2ee1c285db5637242e1d3eca5eb0118f8eedf62e36b0b8e1a63df469a6ec86d1b41b98030e86202ce7197d9c6fec043e781f9f3cd822b320f4536e2ce2d7248467d8ad9931d21fe4365ad49385dc4bf58ed5df273db518a4635bbc3a526f4cdf948c56d4cb1cc48af838aafa2b82d7e4c1fc8cb03a43fb29d3961fea27ea575db361aacba2c7538e0834fd7d66df139d53784b7fbc5dd5a2e2319a6b9c7c8089ec17e4039d93178664ed926c655095e4c3265035b86b14cb27e770e8f2774ed58318e980628d82c8726cf422504e650207dbf3eab41acfb2e78008f2b0678cee9d85dec978f4a62a25f52017a4780e6023a4988f1820b6dfa056757fe40a6b02512fa8bef12527980d8f3f4b669ecb7ed5007b6f973acf0c41337f41693574d516d5590461a1e775a3d70bb2a1939d2bf94b6f1514f3520301920c8729d0451790fa13e4799f916b64ed09c0635d695e01c17a96aa7ad9c3b3b01a539e9b68fd24111bf82011adfab1ce8eb633da71c3759dad21db903b50dcbec902a03a30f31129f84b678b427d324fcd21313b3e00dbe664f09b2761207b94c0f7e075c87da1b472fccf1f58ae54074e95180429b7b2e955e44988750dd7f4aaf68c53252ef4f8c8a8425411000dfe76d74fbc7db3145c5e79a044aa51b5254e4924e79e6820c0d940465dca65f5d0b8272a6ed91a75bc59744840141094934e03ada698f3ec6905bee2b78dec4f410cd27ce83c3defcd58b368912b961252772eb510a4713b301ddce2cc1adda17319b9e2e5ff05909bd9c71f835666a97b5bb95330b9a88652f6f06c7c4a0dddc6424ea844d4a5647bc0671f710196c1dedddec7eb4f73156cda6a8182b1ce9a064784a566d384330512d06082c2188a24d8ff876a451193ee8e16985e576d42cf35ae2ab9bfc5614f3d8381126c2281f67735b28c30018bbf0550f810722bc7f3db6b6f6af1bae9cd42883c9ebcb09aa8c756ae34af4116cf99468b9efd21a9b5950be8a5c30255d947778dd55e0a779dc808ef7f324bf6904f67ec27d3808c66a47605c8d44b9241b3386273d2bf945072c3dc4fa27cfa4182ad38c9e9af98efb2dc710fbb8537d3db026576d9a01ec6d419f1087a9a3297ef374e2d5dc41871d07a640e9ce7078fa71ec72683842cea71546972ed1a70fbc6a7273ad39355c029547a11832ca93c00a8728e3a0a0e23a655f17f1d1e353d1f0d23127f06d344944c8df40c8f97dd5cf5b37650a4190d95cda963e12749327f5d9d2089c3fbba3e92c640d364c0d84f1719e3f156ccfaed1862a87e1b743656824328aa082ab13be2866528be780f2f7312275fd4458c027a04b7b0d94a42167631a672d2064747727a8aa57bd01f97ff5e73160574421b54e1156ad6eb28a59125c2ac731a21ecb1ccf47bc94cd7a156ebe63e5b17ca7f507aca541db1786378f0e94fe89709e501ecfba06d9beceb6231c7a9f46e256df3c40c5bc14ae21d2709aad916252ca6a49e05986a2b083282f607fb6c4233018dd676c146b02b11383607b43004bf97f9bf9c61c8a1c906794d36e408ffa3dacaa93fc04663dd850eeb8c26b376177792d2e08bddd19c56389ca335d2c80929d5d395e4d5ae25be115afac88839e60f721a5f5372f645b38ac715476c9218a36d2dd2aa3ffad9e534a84a6e8f5b195acaf934ea5cbabf7bdfbe5fe4e3f409219bca53e5e73a9f9dc5cf7452ba507b3d45f2eb46f70ef986cbef888207c10aad828327b731f11eddc9cf3368336a532527fb79718037871d7c682830039f331c2f73fdd55fe8989b52bf2bcb6aae487ff059d0471c2aa933724e415fc2d2cbb2492ce97162e46ffb6cd8164c89f1437f26d28f210c3b89dfcb34f8e71f1888683b691b5afde9126a9dded093f81d4dd3da832fa567dca68f8c590d22821d6dd4b34c78b7965ae0122e6a53fc8bd216c62fce1d53b8627e492b8418ffa3660c32eb7b2d59f87769880b9b7c53933e08a2c4e6617000695639eb71517d05d38965cf8d8d8f7fcbc5f5906194b7e2a5d5552b2b2e6a1b20dc18e8b528e4f99a824be61d349a3b1aa3ccc3a2b886131ccc34d4534b887120aef6400e4d439549e5f1519c4229e3d0a85ce7631f1b55ddf3e6d1e4cf6e14a1b7dc05a2830a8fed88a1099b55eb53ce2058819baa90be72cc74b7a83b150b5aabded9c198c71efcf77de6cbe2a542be37d615be12310bec7412db558003da02529b13f6c301162be7a71cdbfb19ea4d3084e0c9f767630fb3bad8a4e8f853367cab9abfbf5bfbefd32ef0ad2050a7129f0e470eaf091678b9c9699b188aa6eb677d57e9d8df3dc2fd7a95fb5530d1246dbc4dd0f108da19f714f3c0f8023eb35fa35ac0b2902126f3075f42e6c9423157cc0a98545b3395a56dd5de4e2038973f0667bd8834d7afe6df7d1bc17f64b3b8b34565f07b42d68c5119a471a68ff3d418747cde3f4feea1d7323dbc68932afaa32dfbec1454f772b881ff48223e9152d626421dc3b8864565dce772d74082c533cdf440ab7a382468c65a88752e45191b1ecb2023139cb7cddc51cfc05e606ab6af515cedc3632121b48a39575f6416c4e19fe8f0a6d170ab62ae2f1fb84b1fdbb460d38c2e04f0fcb517cd1763aab2f077588411b12acf11de2b315318baf69d5bc9f62b67808d6b7848f99292c453e11e760ce5d372f7b89151ea3b773a55ce17f49d80638848c9280d942ab533326e814a98db9ec5e75152d24635fda79689e40868f48cb69a7f1c5799eba15cba623ebd6aa67654acf8da0da2e7c70f69bf66ab90667f189aeb0b58bd42c497b2f925fe4e697d6cd27964fdc67d7cd1f30f692bc643e4af2c32116128a2e3f9d75b82b54bff225917fdcdf3e719df6e1caace10ed7603985235d8cc68133040999c12fd07b449851e6dedde5cea864b554838b91e3834827c1809cdd37aad943a3222c4dd6c3ce86daf093d418c47ad733132b5376001e4d303a5236b3ed906f14bff33d068db9fc506970a33016c5d6944f02fdb50838f2082d4ea4456df7e0dd5030e75f28d4749215a73d66e2df46b5050a26bcc74f98eb9e10fd71b986bf09095e9c550babcfab78704018ae20b095b79f9c9f456e6b8396d60e11bdc9e0fc5ca02fb850a0944f3e4cb978ab7749b3997e4b95b0a625f4cc1b8e569f51836063035bbe6fd6c018f07f49c6e2afb0b4176c06a01f9017c99cd31d281ce9112939c935a1c0c337414b8d78335570de0be1dbd8b38848a2b690e55b34a29096dda9d70d2c6d18fe08d0c20fd2b82088fc1977d989cfbc32ff59a32c3f8bea7103bc16138ec3e95f85fef41762ea3942c5f9163219904b67074d82866dca1a49ba68d1bfcf8a93182af516942fc7e1326ce304b01c3f5670f0843dc488154eb7d53d18dac23062dd9e0e18b7d73f7f65f09574f984bcb1346648486020f5a165e09b12a30e2f390762ddcc42f208add86d72f1c041d0e997bffd84c120cf1ef4747dd40d9fe0cbbf3a3332c3b914401fa643e421841768502674bb515520352082ba765535bce323afcca4cc54f008e840deaec051cfaae2eda30a7cba89041575824b59fcb8597ed45c2c5ff23b669b70cc13ac83ce67e568d0502ef4fc9246b9449de4c818f4419a0c45e36f441e6942d58e6b12a77b863101099961716a5b0152903291b4bb75d34eeef095874d6c44a479ce3b39dcdf0acb07cf4f6e92c3a88b850b0a1a0ba851dc38d608bc8d097cf841cbfe1a9635e84d9f41f29671bd8f889a62ab0599125e4dbbfa438078b47b5e158f0087cf92252a04a96249df3485ce365b860109abc365ad4f84fa354c0e78116a37e86dbfed7b12eb0c090870164d7e4c067b36be9c9103cf5f239beea1caad43d3a6fd3d1b1ffb1b58b62916556dddc49d2b0acca405bc942f688f540b2b55fec80381ef5c343e6a718c642809bb4002b4d997b6b372caac97272dd145bca7137be446a4bb5c3f828613be9dc72d3b1d8e19df4e5def160297d48a899d70f7d208aa431a2c3d153defba3109e71f1da7cd6ca1808ed6be2b56edbbf155397038f92bc4107caf0a8bcc0411f3d6a143d028dfa0f8823d1db96eb405b6c171107d6cb7cf004aff52471959897706d298b8cd7763bd0e0dedcd2eb98ea7f73cbe8e270f2ec2b170a9fdd717fb0c68b508c088261fcd4938435516cb3e46911146f2ea4604026928af0de23fad0ee160ae6b91c48d195bcd2f42d8f72fdc715a5ac49b8822b9bb9c5a2b3ad62431f63f79ec79a5bd629d7a4b6d71125f610182ea2c07e8fe8ee3a3d41d5aa090e8b5d9ec4d5c6188bfa4aab0b6c2e15a288c316a0e1eae0cd37dbd09811087f30915131858613190e6d0d0286ee83174892b128929276c38605e63d13cf17931637f0b07f0b326f9d6e4b48f4c095ef521bf4c6a14c819417cbfa5024642ced18b696fd8a8a73b8b05bf61c05652e4de15ec276634af82693855d09dbc15ca0712b9afbba9d1280fe0020eecb21a850035c1098e63685eeebf046f4277a340fe3e26d592aa35f84536cf179ef8138e9402503ffc8a6ede8411e6164e6c35e64bb8636e30755613d2db72ae8e3a1b8a76512665cc41d8770b7616bf3289145d59057ff5bd1668f80e18f8eddbe5b60a27cea1af09208d66b693e0d86a7617d5586f62c875e91ece65c163b5ea9e3c37d7f39dfb8f0e2c2b9c9371d15066486b288f0699961d24f35ac078c144c4c0a7c19a96435177d92a11dbdd98b6045ba33fa920bd15c628b090beead3a58fc491d36efaf6b7404522bc251777b4cbf863c6b492373dc4c398b4d85a1bd1677e8d97fa57866805bd2599d361d3d637067691cf36c4dfc7df94899c77feca48598b7997df39e56ae2b625581ef0a34ddb6833788f63e3f697e3e5d8c58c0cad530d163f8f8d6fd78cd3e0c8344d18cb92567ccee9b61cfdb3a3d0aad16b23e6d518a491cefd0def9fc7940f2ad6c1c3a6a3104ab79a6c89c0793de203755d8eed9b3419c9bd45385d4d6a04cfb1e8cb317a072ead6fae861dee9074340d30af778b9c5c5133bd7a4d06a02e0dfcaa405e8071469707c5dcf42117c2d7c5f029fa7a6b47bad5167ff61a051113ca63fe57f222fbd7290f0525740e86dbb950adaa22ec4425be99eae7103988288057028646aaec2c59213ac1dc56bd86586ad67c3dff3771057720444cef54f49c697e6314402fe8c0a30bfceda5ffa3633c60be0d83ff34cd4540fa5f684a81b1ec7af24ea4bab74a31d6d21851f03d497c058749886a271c51f1da97fbe5e5b47c60bc9e942dab051280280a14aab5c47057348bc6e95176e432403979f6df8fdc956ad9e8f86dad0e5b8f2825850c71a25f41b1388b52bf13ab5a8eef2e4a4133a2676367a040f6549b5b9c0e470b390de899e72445b3bf52a3fc909f5621e64d7cdb5f1f65a43930912736c9ed7b6d756377966c842c192c925f6da800959ec4bc36d5569f748122cd3c43465cd1d6eb02e64a61c73b6932a5fb85fd9d47740ee2f73e6401836be805ff3b02a6c6c40f388a1d155f634fae1b052fb068e21ba0ec344284008a2a43a60eff538518f3d0370f6bf545b7afb8163ed837c63a1c184e6187e7fdea92c1812c65608861991f178d3b11b934522b2a28fe9cb3ae89f5bce8524dc6a547270a639f4bf263219ed1fc6ef1363dde340290abbc05a634a0a98fbae2fec1fa5937fd3a3a538545ac4a25e2d32f7f13de5c3008108e529da59347e0a11759e1064d7f4f16bdc212efd62ec6621092bf659d947d39764b8ccdb95f35720f9039add72f8945eb63ca432773456f8b2f4b006d27250d36c5724df4665c13d93c0a62819a786b53eb84909e9c8227ca1c4dcad42ebcce59edd038864b83f5c91624d25f8b79fec8af41b1abfdaf30599b15ced6bcfa64fdb7b7354413cfe03d7e55ad72c15b5283c49f9ccc4c658104802fbf41aa98b2bef35406ef4a3c754305a1ce4acc0da4826dd40186c81a781998545ea9f7ec0f4352f679e1b53545ac297d8564a875f47f8e57990835d47bf1adcb56045b7cbcebcdfa251c8093900739cfe68f1f926ea575bf231a10868b705f6de30931b841933ed3721716b4a4c24b9183b7a15447ef5bb4f3035d3d88e98e45e3d6058587b59b7c490da8dfe2afafa67aab26d4a3772b8f27e62f603c78eb2dff647be623b7ce0abd1dc8faf10bb785875dbe4584a97981f70f1037be69c516f24f2c1c03b342afde3a427354e181aa717ef42540ad37f4fb02be767a157646391c7ddc048b241a57e476c1999d07fd80dad5512443b48a5e95ccc2b7b9627c602c0f6d1d33679fd4f8c16a2128fdb79e26fed6778d2711e2e0383f97987c0eefaef23b0ffde5872969ce65de6cc02a7ca16809609fb434e13b5ee4e19c09ff425826e051f12090e1b5d02acbc63251b14e87b5fae9d8ea7f830e052011e5b0cd14294d383ecf2979dfb7aecb23ca4e45b8383da3088b0c13e76d12a47814da3f3315830922ef97747726946bc498a6c8aedc943a92a25aceb596975e574fc817bea2d9ca6c5aad7a90d71f0b85e00d45c8795e65de0b1766c865c0dffbcf1a5b9fca160d091c75544d576a4776c9f797d2e0a328926b4f510ffd1486e89c648012bf49d17747ae10969642422bf60909063d8aab647a36bc037d8d6bf70b9d2bc9943eca0238127f1f1029d92efe87961884f37b1bbbce949ed2bcfa321cb3ed0401a16abcdbe62c0ab0b1bd0d836584d1406e55233d18800fd44b6a40f5557cfb77f355f46618f77208d1f798851bf44a740682e1f01d1d4cc2db65b84ada411518716374e8489a046f335cdb69c28ecced45abf7f8bbd0db8e73c0d9f883744ab54ad06c2a02c9aa6775ef72c0aced43208596ff2e3b5c4abff260f8e9974b3f7226dc469cc9c4e39671c0d6f5dadba9bfe72a4fb44d447b4f206e645e2722d9bd7b7f6b24d1aba3cc9a3a1554f13e375104df35c0cc2eaa67fb8fd297349d063ea6c1caf0b4754faba40de5e0af9aaa5f14e93cfcc34593f39b146c06bf84e7b51542dabfb2167cd8910c8c8f1abccb2d4b8971eb69bd85cc272e67da2dc9c058479ba429fc94a39eab40bbc66258708bd8e2b58bb87d41bbed2c27d6ad6028846bece3c5c00aeb217ce41599c36d21d6dd2f6650612ad2be55e26b4828061a53cf24973753011be355454388aa6273db17b6ae8453fd783beb909e2d6cc078e335808a9c21521a29003abb2daf81f393494c800d8670334fd2658452fb99d6b0ca8e646ee36cf0b97a5b684f6d4b5194e65dc9e4b99177523581040050aac86cb129e410b3d09ee26d1159cdce89c333e0236d81a01ddbac114ddafc72ef96d6c5b2e616f51dddd39cd5a8599e1a6eb50e19bc8f575886ee54271cc662f9b1e2ba879fbd78ec8728c11276d7e35590ecc0d20c8b6b580315ffe69fd4d084d7d8366115e1c5d3669c15837905dcbc551774b28c061f113753792fd720ea92ea7a3782caf1ef6bca4b17d03c8c886f9340a70d06d57229b3b6af1a5b7b63ea26f6e161ca8d9338d3cc692807d4065bf9666f2bb4d78b1138a609920bf93cba808c00c25bf0f89ef70ac470fcfc4ef570332dab280bb3279232b2013f3bdaec6d9f731ee26731014f63538da291696914009eb96302937ea6b9cab46c82d22cce459ae295c37af4fd41e9dc730db136e7f0db126fa229bdd79a8ba26280e7e6c18bf89e400211073498857c685dd5b6e9976cefe98bd3c3b0c02dc7ea2f6166631412b6e920f0820f478b50a65908df8c05be77090d250afa333038d27cf36107948b99de5bb6d0fa2566d3c19e708e5f5d9aed155997eb240df700abc9e738d9dddbe513dfa9d8fd711c8c5d3cab9c26b6cfdc7ad6625eb1ae1889d10cacf4c0bbf1aac1e490249e3db63fa15aa6b570bbb59788ec75f6818bc3144d1ea4d85974f326957c213560b8253300b321fa37354c2387a4d2fb6bb9ac84dabfcc3c109f4c3da54addf3cb6a4a2709b614370619aeef672dcda1decd66371d0cbaa28be0b5569c47a4d19ad09151c8bad34ec74d75bf851c54908d5e7e54b59571c77081276864657209295f4739e64d227e2ff19d87310a402784a4a2301636da1aff670eb049ec25a932a7e102560920d006eadecc247d0da8595dea80c9acea1b1a141ca6c09be9e99b922f2715c11760df53ca2b5f01aeb6fa9140dcabb057abb9440480658b092f70431f29ed26b68bc175df73c90ca969307013ecd0eb28f0af878999205053f567598c2e0b3297c7ad0bb99b5bc61f1bf0e250a66d5578501163400d2321caf456014f9373a443ba5f60b5e054db7d59d39874e972763e1a6160f39fb84a0ba73422d0744712da01c5c0e9fec871f0b6710990235f7713a955f23509b2326a106e1c954ba11357bb12d2dee29592bc4e4050e92fd5c7b4eb0dfdcaa4a312d199e3b9863f6aa935a571e6626f6e37204a766d01570efe8e8028f6133a60be9c136b5328be61a9a644e925c8c6fbccb9e64e09d87024a200dd935a345c309114f5442695c04d74fa10660875d763227b876a05b54b505ec7ad145b8f3f7cb0a180ade9819164d8299e80855e646474bfc2b04d773ed729134d4e93517a3b0044319c61f8b72e03374cc6ed9161f291b8fa1e61694fc65c70124ebad1575b8194e0a1e3fb9bf5e3d349ef5bdb75edd4f0b30340bc61fe9b3a449a7a030cd9edd507e1b6cbc4f53b3cdfcbf68e1b45c75fb41a51cedcaf096fad08ebac4cc6ce1562d37e20fa63b2b5aa4afe7e851fa29419aa1298f08d6bac46e029e50def4e9f9a200099623d651d8b3434076040cee579ed9cb373f46e880fba556f8c473f81a8df5b3e31dab70a909c318f49b39e598caa39f1f6509cc9d7f36437bc4569f007a48a30acd8f85e1aba803e56b41c3ea0c330bc3a3a19e46f3cf193b3051fce20312588ecab6880f483244091ae0100b5cef55764863dac44458756c03a9ad3d7021dfd13683997c42f5ce33ff5aa164e031759c3f1282c82112d605a4a7b2bce845278d6f701d6a4d146d853beaa1695a1d7866a73f4e85e8eb215b09dc2e116c6acfc369bfceaee35ffa21678c50b49e55ac573a6f5ae1ba9929e6cbd88489140669e34c205a52f0629e9f0837394b1e9ce2e361cc1dcd0235603d45db51c4c91009f7c1c738e495dfe57a794c281c3fdd85652c09697bc0ca2363767c10ce861c55f565b403ae6bf24de1f40278deb0e89a579598e191b2c3e91b40efca69e55de53a28523f9933c41bcaa931f7952f666ecc9fe7a9bfb6393f840c1e24f9694b79eec8be43c02af2e9307416ff82161c0a78aff2dc138b99d2eb0692fa8b7fc09ff06f55ed3ac424983b231556c52e25623c0a59bf92651f3c77363ce84fc653adffe5efcfb8037244f249357713e85d9b44a9b8f73a7b929fb88d2652e07603fc1dc96b13742de6ad7b3875150aab977e443fea301bcbb5e08a74b8816f85426cfbe4fcefb9d78d90d72a72875236b0ca52a6287b09c679f97906632304d42519ccc0d5f642c92a94399c103a25d5f8e65518594e9c2a4d8f64ed092c011a8731e15ae78de28b67865572a35859004ce327d8e0cf7e800cf6e751251c6ef8207f1b13b9004da27991ec80a3d3378ec349e63fff418afee2d294a8f4c598269826188d46021846620181e0fd42886bcc4b547ef10b7937cf24828d228860ef6d2feffcd97aff378902d3da22097e2edb8a2d03468d60b4d63959af34cb1ce44d0411fd2b1294077d9825e1ad754fb82b56b96d57a0079b4ba5a183aa4802ac397609d9b0f746899591c4421dd49a5291ba3575b42deb09c84167a0d9d003415a962cfb362e7290b6517e59c11695dbd90dcd51cb4c520194ba8b6f6ad5ac8e0de0db8031550342a14080c11ac49b065df63ceb9f30d7ae8327f2047477a119d5e4aff96e455469a75c01285104eef66794cd5104ae360bb811df49ea372968783ccd00f976a6025b1d569ddd7ff8070f44520f66be61754cfc477effaa035d6ec5953f1d00ece9c28b3adaaf6cf0f7952b312266a88bb3613da55a88694b35a6843cdd277327b8a0677fc261025c650f56b7cec1832521b110492222cd6a9bd1d3ad1a1e9ac1f0a9a993e9abcbc93c89199e542b85b63667b16ec4f38b7705c9c927021f8841796a6e34e477b370518f4a15d1bfbf04212a1eabf35f74a66de1729a2401cef8a54a1c9515209ef9b80e18184f5de4ce6360a61cc71fa83fa33f192f74505f3064ef1eec32d77c3bbe081fce64e8ce4c4c403655eddd0244d52a05fae7c0d5f756545d1c9ca4a5b73b876f814705106291a17277f97072577b83c0d5869d622884479e8bdb09c5a5736dc45a779c50d345a6a304812e5439af934495aece6d2dfac8c87d4c1247fa37609a56815428ddc09ce58f0ab0c1526e1b6bb3cafbc9026fd23eacf16d06e52f70bf9f2934bc13387d4f140fa9336482e0b8e045f60bced79f183e9290d20595f01a52a085c1f3fdf3b5c6866aca35dd606fb69608cd7beb92da4a06987f6245f632b491cdef5a04b878fa590919340b1d4d59f9705300a8290c55198d701ace6f3bab2ce148221b392ef28eb0ef828ebb0d3c67a2f7869287c508fe2ff72fda7db07bec911f38303b8b06dc7958a3cdbd94679920871bc8704544040ec80b702a104aac29be55ff6fc3f76717d48fbed3601f1b7654e64542ff398a2ff76a0466ed4202261422d00461f41224f2d9b154735a8ba8b40b49d9d718ecc89a2eec041fc99b1a1169a5e6d4ea46b6cdad300b7e918114289fa60733e91cefc87e053ef514fa790b34d7c644d178867dae61196e996a4bd15ae9be5318c506358c361ca2f423e3967de4dd6949b41b8c56c63fb7b5f3be4b1f1b00fd359b95d2bc118dcc6c0ca23211208ce8b258a0c8272c7bdb527c548e939cedc6820b19a71e88b0929a61fb388b14a41690429ca64d1964e4062a7ea5e9b6c73df3a0761919b59deaad452e561aea2ba711b68077de78a80a86873d52a556b7d06448513e85c9813a22dc39d6f0fc5dbac573ee2c2132e56cd9948e605bd67e374b9109b36837542da9d812825047a41857f635a2ceab2eff3b4b75af985d51fbf9ffc68408b6bab3764caddbdf3e1e92ac15c710ecb753cdff59b5db57efc8fcb50a911df945a0670bd2b1a1a6ce3127e4ecfce2fa98d6067fc5e4e642e6562b5d0a64a57f439968d3b0f47135e28c095aef26b50b54228b04612ce5bfda274410be8e39ccb674aa37ad644a43f65f663ee21e2c4894812b106ddcee9a68d56d51538344861a6f937bceff72905724934209ffe763a0881e34379783f9559feff552c64dbaffb31a81c77575c57e0dbc93ece17bde0d84be92f912686ff0d8291b5e60301475c68aa9a74dd5a808edc2d9767310785824b21bbcca82f28c9e4e6be97e5ef75835e1383db4040a305a715a88088329076a7a46af628886608aac9989b3db86c22b977a669d2b9e5c03a25e50cadc16e212c97b346311157d8ef0d2aa65641e1eeaaaf2b145c1af77f12e01ac4d495d7f987d5ae6f4d3d4cd9ae01c3be634157b2ba2bacd6260b78e85603887113762dc3d553e44e1978d26f380d859ecb43d1a81eee711963b47980ca3b98efe03744546c66e7bcfd872d4ae80d8db2bde364d9b69a723f49f45e83cf1dfa0670a06285df379e50bda9ad575221314d764f513c16e1614babfa37c8d8364db3505b87198fc9623667a625db656aaa3f9e3028213e51af804ec333d00cb9f7af2bc1af5513531a81c5162feda8d83a221997e6b0820d887ec351b134b4fe8a30d640015ab7305ce0c3dd88c4df57880258dc182d8c2eb645e70471ef8fc3d7f4d6eedb67fd772b05193e334e6e9cf670359370f6a5afc223347db082f48f758e99cc27eca9dbc34a92e051e0b2bb9736d1f1723e0e295a43e1573bb58989ad9c80105f8f26708ee2e96343c0262f7432cccfc96bbf7d6225c005207b15ad09cbb5de20dd051af6e93af1d80e6bc673ce069fdc3d6e69943fae34d5bd223e85b74da157ea6d334a669d14c476b602715be1ddd8bf4eba8d1d30d0b5912feb0bbea4a9f250fef496432912f416795686871d46cd27fb5b9d8845385994ac12af0147feae73c8bfcbcf9fe360de25b7d0a45efdd21c43d90b629f2c3285597ee8ca6eabe53a6fe2d2fe13a2cb092146f6682409fd1ee9bc3cbaabba3503af8d1a03dddf488077bacafff840758a3586dbcda3549ba878840f572e02c331b9f6b8c21846202a14453832f3acd051217fdf87681b15b10d533b62b9d25f601ab7f509ccfb1731fc6ba3996dcb09e65c7a7c52693f98873b4efb4bf1fbe3b5f7fb9366e6f9d1cd7f7ac0f1acb3506cf6f51a9cfe1cccc8ac3251e585c722903149ce57e31972334a96643380271ced0e47a9b12a9c1f37a46eb76cc402b2dc6ef986111a1db875b94430500dbcc16c3193817b1daa3660385fc0697789ee0633d3a41ed4f80351831728641a64afa524f7f0194cb1bd708a02228ccd7c2e47a93f76dfd51a38e52e676b67681e98948d5696272307a30c52a2b2c0d7161e9e2cf250e87fc3c11693283b9ef49d93a62be31b98587fd1b7e7006de3b7786d47364c148bd8ca6fad6d6606df25dbd67514e1c20b9e964194fe1b5b345286dfa2329a33bff839839de0d699c7b1ee311a42b6969db9f980b8243141f721e06d511ea04cf16696d0b1f069b4fa5fc9b4b99c19714fa81daa887d4d914f1a8a7d4e266f213c67eb5a5ae942770eaa2d320ffe3899274e33c058522ea4d5ed386e927c985653ce5366d6b70bdf83cb5fdcdd3930f14029b265113324917e6ad2cef301539317b9d4d8098c153ed457995e13c2a3b22030d001f605fe6ca1c1977aa0a501791a076e811fbc0e01b3c04dd723ee7d7cf20e298d817d5fd5aafd63fc555fdf5072d2e21a27509449233d6d127a52463cf2f5b3f4dc40443202c0ae9d64958b32d72f5cc43037586e81690b81eac85ed2835457b2206488e9d11c7346d2d324e56fa3363ef3c550ecc92a98f282a78e6db75699994ee47d3a15f55237ada649876857c7e1443019a2a59cf7bc44c3da360f4731b07a7d85e414480ce6191ab03450f931aa2d2486490119f5b22feffa85fafb495870ca809bd65c1a26c49441b01abcc446f1ef5c5199a96e3bcbe801eb2d811ee8f52e48d34b48c47381277c65f010a33ba0aaa62ca1af956ff50f2cbcb952a4bf360d04de24b31307b7b445207ab81106a01eda5bc764574dc5b829ad9f8bc8c7584853ca7f12a546d4e0133d12bfce7b0c25ebe52b7b6b98b0f46387aa1c17f61d7a2d570274bc6b1ca204571e4c41fcebef6de6949a603231d6a41c04332f121cb5ae28a3790c441a01bd78c39c77086c33f19f6538d066b90ef8d157778061ab81aacd452c9f3f3016b20b7a2eb2cd3edeb1c3284e061f8a6d659a9ba74d057b3fae07b916ed9892729e39c0d507e3a412533d7fe1dd899c4461062ad9e241455bf01eff50cf2df042128bde9b1bad80d73bd720758aad8dad913da469234272b39d144e7bb4f1f547d24870171e7757c55d589700224c5329160901af3d88a834c78bb9c99c5c3e628529414dfb17ea66ac160c94b417937624901bf18abb4fcca688f438e51d0ddb18acd4e97d5a31a106c62805fbf2c5b13b043e8c42a095d65d3a3dabcfa9b2eefc734dad3692ac60c50ae2a7145a4f6d7130fcdbd96ea92f109acb1a18e2338650343ad846913567200679a8271a2fa48bd892d0cfd603a30ec5e056f7e0cf1e36e5fd3c6a1e2213b60d7542722fa85997407b8b5ae8efb33069d54d2f3c6fb562e0265bf76e0994f247289e6fc4bdba801af7f9607bfeb7900df65edf587e2c783f50280eced54135d65b06492eb60734e59de78f9490544210313d3e9edccd0716817037ff7e062e9ebf13ead1776fafbd367b598bac4119cae6925fbda680d8aa2e8942e5a5ea1c2f993d26f9103822a455cd0506ce66a4f957847ccfcf4dabb642c1f1e95d178c97ea4bd39f8f33662eaa135f8bdfc7b608ed926e3517fce2fc406e60bd3a21ae3bbd00ea968c05339344fc9243d62ed3c5682c7672537deb04870a2c1dd3055aa0f5955b9dbbcc4f1310763ababe74a7a11f94fa4dcd8fb1e1705bba249babbee5c3744d62fee41eb980ca8d018a201a97a146b135127464eee69be1ea823a06048a5ce5fac17803323af6b371f4ac2cfe312f85063e4821ef08dd563fda153319939a175318637d12ce8bc27136f36199582896771cc5e1ecea6278a2610bef59730798ef71897eae4963a5a0b0fbf0d25bec6cd128b631b587a9cb4b445400aa254b50702e3e8f131bdd027ba94b1c1202850da7d62492a0c08e3976ea1adce57222e613a1c8c29bafd40a99599ba23a0fad9c567cf5b3299eace99c4878a150aa1851748c3bcab58afab986c7b0eefe07cd9e558905bd62768c01068fcee8e1d4488973b8ea591af1d04d789d264c0a599868ade254299ba8adefc37220ccae7b82163312e307743aec50dbd3e0ac9249addc1c65b87a53d0f782dffb5d5dbb8e8346503d440fa690876103252d4d89101cfe8720fe8ca047453d88bdc9fcfe7afe0b90342a0760ef60bb5d481ff1f67e8908f2389ef9be72d60323c91fb4fde9a7ce43bf8b3ede164e526526847a4050c8d2a817902a126a9524afc1822a2d8b5ed64e8a5b85fe06f8dcc19f6b3ffbf405b699c7341a3b5f1c6432fc381f2a4fc0720d5df657479bb8928886ddd844e3b284e639360ecc59520f3c262327d929732f010bb599d2225db08aa4e4bbe72ae160cbbf12a3a63bfe05449479e405c04c0d28f8e638145e77e49005f4d68f2ca0406586bac1e27550f370a82c74f87b4c9fecacc541d6f4e82342dbd2ea116c8e464e4152ade3d470b909c60717fb29776bd45aca919f673764d28afd911eee121bb190ea4bd83ca96b3ca19864221b26a5676ba4970aa4c84bc99526008372578692da701a3fe539d4bb58a4fb795bc505d4c3c8d30e22118bfc778d0d1d248849c3a0753910df5d782f9dca9dd4cadf6cd501cbb8d7d888bcc2ddb657f56e5eb70aa794d76b61bf191efcebd55a22729643365fd0f8958fd2c8e17bcb2017e9e1d6016da8508799acd02e27aa60bb628fccaeabacb31201b23f1ed94c09b8373f85a3f4b08d5283777ded73dd1b4c16ddd201efdb76ae8e73f3ba15c3d49aa774e64cbe040651ab374a6e3dad34146b7ac4b798431      </script>      <div class="hbe hbe-content">        <div class="hbe hbe-input hbe-input-default">          <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">          <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">            <span class="hbe hbe-input-label-content hbe-input-label-content-default" data-content="联系站长以查看密码">联系站长以查看密码</span>          </label>        </div>        <button class="hbe hbe-confirm"></button>      </div>    </div>    ]]></content>
    
    
    <summary type="html">联系站长以查看密码</summary>
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-07-杂谈-复杂异构系统监控与可视化项目设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/51477.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/51477.html</id>
    <published>2025-12-07T13:09:33.000Z</published>
    <updated>2025-12-27T18:41:58.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复杂异构系统监控与可视化项目设计"><a href="#复杂异构系统监控与可视化项目设计" class="headerlink" title="复杂异构系统监控与可视化项目设计"></a><strong>复杂异构系统监控与可视化</strong>项目设计</h2><h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><p>现在需要设计一个系统，使用 py 的 fastapi 作为后端</p><p>目前有一个使用 Docker Compose 编排的复杂容器化环境，基于 SeedEmu（SEED Internet Emulator）框架构建。该框架专用于模拟大规模互联网基础设施，常用于网络安全研究、教育和实验，特别是区块链网络的安全性测试。<br>此 docker-compose.yml 定义了一个模拟的互联网环境，其中部署了一个完整的 Ethereum Proof-of-Stake (PoS) 区块链网络，分布在多个自治系统（Autonomous Systems, AS）中，并通过互联网交换点（Internet Exchange Points, IXP）和路由器实现互联。该环境的主要目的是模拟真实互联网拓扑下的区块链网络行为，支持研究区块链在复杂网络环境下的安全性、性能、攻击与防御（如 Eclipse 攻击、分区攻击、路由攻击等），并提供可视化监控、数据采集和分析工具。</p><p>主要组件与功能有：数据库与辅助服务，包括用于存储区块链监控数据的 postgresql（数据库名为 ethereum_monitor），作为缓存或消息队列的 redis，以及用于存储和分析网络拓扑、区块链节点关系等复杂关系数据的图数据库 neo4j。</p><p>Ethereum 区块链网络在 AS 101–112（共 12 个自治系统）中部署了大量 Ethereum PoS 节点。每个 AS 内部包含 3 个本地网络（inet0、inet1、inet2），每个网络内有 3 个 Ethereum 节点（共 9 个节点/AS）。总计约 108 个 Ethereum validator/miner 节点（节点 ID 从 2 到 108），加上一个 BootNode 和 BeaconSetup 节点。所有节点运行在自定义的链上（chain_id: 1337, chain_name: posCurrentEnhancedNet）。部分节点（如 AS101 的 host0）暴露了 JSON-RPC (8545)、WebSocket (8546) 和 Web 界面 (8000) 端口，便于外部交互。</p><p>网络路由基础设施基于 SeedEmu，AS 2 作为一个骨干/中转 AS，包含四个边界路由器（r51–r54），通过点对点链路（net_2_net_51_52 等）连接。IXP（互联网交换点）包括四个全球 IXP（ix51–ix54），每个有 Route Server（路由服务器），用于多边对等互联。AS 21–24 作为 IXP 的参与者（peering AS），每个连接一个 IXP。AS 101–112 每个 AS 有一个边界路由器连接到对应的 IXP（例如 AS101 连接 ix51），实现与外部互联网的连通。所有路由器运行真实路由协议（如 BGP），支持模拟路由攻击、劫持等。</p><p>可视化与监控工具包括运行 SeedEmu 的互联网拓扑可视化界面的 seedemu-internet-client，映射端口 8080，提供整个网络拓扑的图形化视图，以及运行 Ethereum 网络专用可视化界面的 seedemu-ether-client，映射端口 5000，用于查看区块链节点状态、同步情况、交易等。eth_node_cleaner 是自定义服务，暴露端口 8888，可能用于中央数据收集、节点状态清理或监控指标聚合，连接 PostgreSQL、Redis 和 Neo4j。</p><p>其他特性包括大量自定义网络（local 和 global 类型），精确分配 IP 地址段，节点标签丰富（org.seedsecuritylabs.seedemu.meta.*），便于 SeedEmu 工具识别和渲染，部分服务使用 privileged 模式和 cap_add: ALL，以支持模拟路由所需的网络权限。</p><p>现在需要实现一系列功能，提供基于 FastAPI 框架的 RESTful API 路由模块（topology_router），专用于提供区块链仿真环境（特别是结合 SeedEmu 和 Ethereum PoS 网络）的完整拓扑数据访问接口如下：GET /overview 获取整个仿真环境的拓扑概览信息（如节点总数、层级结构等）；GET /statistics 获取拓扑统计数据（如节点、链路数量等汇总指标）；GET /health 检查拓扑服务的健康状态，返回组件运行状况。</p><p>GET /ethereum 获取完整的以太坊网络拓扑数据（节点与 P2P 连接）；GET /ethereum/nodes 获取所有以太坊节点列表，支持按层级过滤（execution 或 consensus）；GET /ethereum/nodes/{node_id}获取指定以太坊节点（执行层或共识层）的详细信息；GET /ethereum/validators/{validator_id}根据验证者公钥获取单个验证者节点的详细状态和信息。</p><p>GET /physical 获取纯物理拓扑结构（不包含容器运行时监控数据）；GET /physical/devices 获取物理设备列表（路由器、主机等），支持按设备类型过滤；GET /physical/links 获取物理链路（网络连接）列表，支持按连接类型过滤；GET /physical/networks 获取所有物理网络的配置信息（网络 ID、名称、子网、网关等）。</p><p>GET /contract 获取智能合约相关的拓扑视图（合约部署、调用关系等）；GET /contract/statistics 获取合约层面的统计信息（如合约数量、调用频率等）。</p><p>GET /transaction 获取交易拓扑数据，支持通过时间范围（start_time 和 end_time）过滤；GET /transaction/statistics 获取交易层面的统计信息；GET /transaction/address/{address}/analysis 分析特定以太坊地址的资金/交易流向（流入流出关系图）。</p><p>GET /layer/{layer}根据指定拓扑层（枚举值，如 ethereum、physical 等）获取对应层级的完整拓扑数据；POST /combined 支持组合多个拓扑层（如以太坊层+物理层）生成统一的拓扑视图，可指定渲染格式。</p><p>POST /render 接收任意拓扑数据和渲染请求（格式如 cytoscape、graphviz 等），返回经过布局算法处理的可直接用于前端可视化的数据。</p><p>GET /nodes/{node_id}获取任意节点（跨层级）的详细信息，支持指定层级；GET /analysis/{layer}对指定层级进行网络分析（如连通性、中心性、社区检测等指标）。</p><p>POST /cache/clear 清空服务内部所有缓存（用于强制刷新数据）；GET /debug/info 获取详细的调试信息，包括服务组件状态、各处理器缓存大小、支持的层级与渲染格式等，便于开发与运维排查。</p><hr><h2 id="针对该环境和需求的系统设计方案"><a href="#针对该环境和需求的系统设计方案" class="headerlink" title="针对该环境和需求的系统设计方案"></a>针对该环境和需求的<strong>系统设计方案</strong></h2><p>需要设计一个 FastAPI 后端，它充当一个”中间层（Middleware）”或”聚合层（Aggregator）”，将底层分散的基础设施（Docker）、网络拓扑（SeedEmu/Neo4j）和应用状态（Ethereum/PostgreSQL）整合成统一的 API 暴露给前端</p><h3 id="1-系统架构概览"><a href="#1-系统架构概览" class="headerlink" title="1. 系统架构概览"></a>1. 系统架构概览</h3><p>由于涉及 140+ 容器和多种数据源，系统的核心挑战在于数据聚合和性能优化。建议采用分层架构，包括前端/可视化大屏与 FastAPI 网关的交互，以及 FastAPI 后端应用内的 Redis 缓存层、业务逻辑层 TopologyService，和各种适配器（Docker Adapter、Neo4j Adapter、Ethereum Adapter Web3.py、DB Adapter SQLAlchemy）的协作，最终与基础设施 Docker Compose 中的 Docker Socket、Neo4j 图数据库、JSON-RPC AS101 Host0 和 PostgreSQL ethereum_monitor 进行交互。</p><h3 id="2-核心模块设计"><a href="#2-核心模块设计" class="headerlink" title="2. 核心模块设计"></a>2. 核心模块设计</h3><p>我们需要将代码组织为清晰的模块，以应对你列出的 9 大类接口。</p><h4 id="2-1-数据模型层-Models-Schemas"><a href="#2-1-数据模型层-Models-Schemas" class="headerlink" title="2.1 数据模型层 (Models/Schemas)"></a>2.1 数据模型层 (Models/Schemas)</h4><p>使用 Pydantic 定义统一的拓扑数据结构，这是所有接口返回的基础。网络拓扑系统采用了分层架构设计，主要包括以下几个层级：API 层 - topology_api.py 提供 RESTful 接口，服务层 - topology_service.py 协调各种拓扑功能，数据层 - real_topology_service.py 处理真实数据获取，专门处理器层 - 处理合约、交易等特定类型的拓扑，管理与渲染层 - 负责生命周期管理和数据渲染。</p><p>用户通过 API 请求拓扑数据（如 /topology/ethereum），API 调用 TopologyService 的 get_ethereum_topology() 方法，TopologyService 委托给 _real_data_service（即 RealTopologyService），RealTopologyService 从 Neo4j 数据库获取真实的以太坊 P2P 网络拓扑数据，数据经过处理和格式化后返回给用户。</p><p>对于以太坊拓扑，从 Neo4j 数据库查询执行层和共识层节点及其连接关系，查询验证者节点并与共识节点关联，将原始数据转换为前端友好的拓扑格式，通过 Docker 客户端获取容器信息，建立 IP 地址与容器名称的映射。对于物理拓扑，通过 Docker 客户端获取所有容器的详细信息，根据容器名称识别设备类型（路由器、主机等），根据容器连接的网络建立设备间连接关系，使用共享网络原则确定设备连接。</p><p>在 topology_interfaces.py 中定义了核心抽象类：TopologyNode 作为拓扑节点基类，包含 id（节点唯一标识）、name（节点名称）、node_type（节点类型，执行层、共识层、验证者等）、ip_address（IP 地址）、layer（所属层级）、status（状态）、metadata（元数据）等属性；TopologyLink 作为拓扑连接基类，包含 source（源节点 ID）、target（目标节点 ID）、link_type（连接类型）、layer（所属层级）、direction（连接方向）、metadata（元数据）等属性。</p><p>不同类型的拓扑节点包括以太坊节点（执行层节点、共识层节点、验证者节点）和物理节点（路由器、主机、交换机）。拓扑数据最终以 nodes（节点列表，每个节点包含 id、name、type、ip_address、status 等属性）、links（连接列表，每个连接包含 source、target、type 等属性）、元数据（时间戳、数据源、统计信息等）的格式组织。</p><p>这是与底层交互的关键。InfrastructureAdapter (Docker &amp; SeedEmu) 作用是获取物理拓扑，实现方式是使用 docker Python 库读取容器列表，解析 com.docker.compose.service 和 org.seedsecuritylabs.seedemu.meta.<em> 标签来识别节点角色（AS、路由器、主机）；对应接口是 /physical/</em>。</p><p>GraphDBAdapter (Neo4j) 作用是获取网络静态拓扑和关联关系，实现方式是使用 neo4j Python 驱动，SeedEmu 通常会将生成的拓扑导入 Neo4j，查询 Cypher 语句来获取节点间的连接；对应接口是 /overview, /analysis/{layer}。</p><p>BlockchainAdapter (Web3.py &amp; Postgres) 作用是获取链上实时状态，实现方式是使用 web3.py (AsyncHTTPProvider) 连接开放 RPC 端口的节点（如 AS101 的 8545）获取 Block Height, Peer Count，以及连接 PostgreSQL (ethereum<em>monitor) 查询交易历史、合约调用统计；对应接口是 /ethereum/</em>, /contract/_, /transaction/*。</p><h4 id="2-3-业务服务层-Services"><a href="#2-3-业务服务层-Services" class="headerlink" title="2.3 业务服务层 (Services)"></a>2.3 业务服务层 (Services)</h4><p>这是实现 RealTopologyService 的地方，负责组装数据。TopologyService 能够根据请求的 layer (physical, ethereum) 调用不同的 Adapter，实现 /combined 接口，将 Docker 的运行状态（Up/Down）注入到 Neo4j 查出的静态拓扑中，并将 Ethereum 节点的逻辑 ID（Validator ID）映射到物理容器 IP。非常重要的是使用 Redis 缓存完整的拓扑 JSON，并设置后台定时任务（FastAPI lifespan 或 APScheduler）每 5-10 秒刷新一次缓存。</p><p>AnalysisService 将拓扑数据加载到 Python 的 networkx 库中，计算中心性（Centrality）、最短路径（用于分析攻击传播）、社区发现等算法；对应接口是 /analysis/*。</p><h3 id="3-具体接口实现策略"><a href="#3-具体接口实现策略" class="headerlink" title="3. 具体接口实现策略"></a>3. 具体接口实现策略</h3><p>针对你提供的文档，以下是具体实现建议：</p><p>物理层 (Physical Layer) 的挑战是如何知道哪个容器连接哪个。方案是 SeedEmu 通常会在生成容器时将连接信息写入 Neo4j 或生成的 metadata 文件。优先从 Neo4j 读取链路关系，从 Docker API 读取节点存活状态（Status: Running/Exited）。</p><p>以太坊层 (Ethereum Layer) 的挑战是 108 个节点，如何获取所有节点状态。方案是使用信标链数据 (Consensus)，连接 Beacon Node API (如果环境中有) 获取验证者状态 (Active/Slashed)；使用 P2P 拓扑，使用 admin_peers RPC 方法（需要节点开启该 API）查询节点的连接对象。由于无法轮询所有 108 个节点，可以只轮询几个关键 Bootnode 和 AS 网关节点，构建局部图；使用 Postgres 补充，从数据库中读取已知的节点列表和 Validator ID 映射。</p><p>交易与合约 (Transaction &amp; Contract) 的挑战是实时分析交易流向。方案是不要直接扫描链，而是利用环境中的 postgresql (ethereum_monitor)。SeedEmu 的监控器应该已经将区块和交易写入库中。接口 /transaction/address/{address}/analysis 直接执行 SQL 聚合查询（Group by to/from），返回资金流向图。</p><p>可视化渲染 (Rendering) 的接口是 POST /render，逻辑是前端可能只需传递原始数据，后端使用 networkx 计算布局（如 ForceAtlas2 或层级布局），计算出每个节点的 (x, y) 坐标，返回给前端直接绘制。这能减轻前端浏览器处理 140+ 节点布局的压力。</p><h3 id="4-代码结构示例"><a href="#4-代码结构示例" class="headerlink" title="4. 代码结构示例"></a>4. 代码结构示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/topology.py</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">from</span> app.schemas.topology <span class="hljs-keyword">import</span> TopologyGraph<br><br>router = APIRouter(prefix=<span class="hljs-string">"/topology"</span>, tags=[<span class="hljs-string">"Topology"</span>])<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/overview"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_overview</span>(<span class="hljs-params">service: TopologyService = Depends(<span class="hljs-params">get_topology_service</span>)</span>):<br>    <span class="hljs-comment"># 从缓存获取，如果无则计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.get_system_overview()<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/ethereum/nodes/{node_id}"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eth_node_detail</span>(<span class="hljs-params">node_id: <span class="hljs-built_in">str</span>, service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 1. 查 Neo4j 获取节点基础信息</span><br>    <span class="hljs-comment"># 2. 查 Docker 确认容器是否在线</span><br>    <span class="hljs-comment"># 3. 查 Web3/DB 获取链上余额和状态</span><br>    data = <span class="hljs-keyword">await</span> service.get_node_composite_info(node_id, layer=<span class="hljs-string">"ethereum"</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"Node not found"</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">"/combined"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_combined_view</span>(<span class="hljs-params">layers: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 融合物理层和区块链层</span><br>    <span class="hljs-comment"># 例如：展示 区块链P2P连线 覆盖在 物理AS拓扑 上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.generate_combined_topology(layers)<br></code></pre></td></tr></table></figure><h3 id="5-关键技术难点与解决方案"><a href="#5-关键技术难点与解决方案" class="headerlink" title="5. 关键技术难点与解决方案"></a>5. 关键技术难点与解决方案</h3><p>Docker 网络访问方面，FastAPI 容器需要挂载 /var/run/docker.sock 才能查询兄弟容器的状态。docker-compose.yml 配置中需要添加 volumes: - /var/run/docker.sock:/var/run/docker.sock。</p><p>跨容器数据库连接方面，连接 Neo4j 和 Postgres 时，Host 应使用 Docker Compose 服务名（如 neo4j, postgresql），而不是 localhost。</p><p>性能瓶颈方面，问题在于/ethereum 接口如果实时调用 100+ 次 RPC 会超时。解决方法是使用”后台采集 + 前端读取”模式，编写一个后台 Task (使用 asyncio 或 Celery) 每 10 秒扫描一次网络状态存入 Redis。API 接口只读 Redis。</p><p>IP 地址管理方面，SeedEmu 的自定义网络（inet0, net_2_net_51_52）非常复杂。在返回 /physical 拓扑时，务必解析 Docker inspect 结果中的 NetworkSettings，将特定网段 IP 映射给前端，否则前端无法理解路由关系。</p><h3 id="6-总结建议"><a href="#6-总结建议" class="headerlink" title="6. 总结建议"></a>6. 总结建议</h3><p>设计这个系统时，请遵循以下步骤：首先打通 Neo4j，它是拓扑的真理来源（Source of Truth），确保能查询出 AS、Router 和 Host 的关系；其次实现缓存机制，复杂的 Docker 集群状态获取很慢，不要让 API 直接穿透到 Docker Daemon；定义清晰的 ID 映射，最大的坑在于关联 “Docker Container Name” (e.g., as101_host0) 和 “Ethereum Node ID” (e.g., Validator-3)，需要在服务启动时建立这个映射表；按层开发，先做 Physical（最简单，只读 Docker），再做 Ethereum（读 DB），最后做高级的 Contract/Transaction 分析。</p><p>实现”实时更新”并”高亮变化”的核心在于结合 FastAPI 的 WebSocket 推送机制与 D3.js 的 General Update Pattern（通用更新模式）。这里有三个关键点：后端推送，只推送最新的全量/增量状态；前端数据绑定，D3 必须通过 Key Function 识别哪些是新节点、哪些是旧节点，而不是每次清空画布重绘；视觉反馈，利用 CSS 动画或 D3 Transition 让变化的节点产生”闪烁”或”颜色渐变”。</p><h3 id="1-整体架构设计"><a href="#1-整体架构设计" class="headerlink" title="1. 整体架构设计"></a>1. 整体架构设计</h3><p>后端 (FastAPI) 运行一个后台任务（Background Task），每隔几秒扫描一次 Docker/Ethereum 状态，通过 WebSocket 广播给前端；前端 (D3.js) 维护一个长连接，收到数据后，执行 updateGraph(newData)。</p><h3 id="2-后端：FastAPI-WebSocket-实现"><a href="#2-后端：FastAPI-WebSocket-实现" class="headerlink" title="2. 后端：FastAPI WebSocket 实现"></a>2. 后端：FastAPI WebSocket 实现</h3><p>我们需要一个 ConnectionManager 来管理前端连接，并推送拓扑数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/ws_topology.py</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, WebSocket, WebSocketDisconnect<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><br>router = APIRouter()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections: <span class="hljs-built_in">list</span>[WebSocket] = []<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-keyword">await</span> websocket.accept()<br>        <span class="hljs-variable language_">self</span>.active_connections.append(websocket)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections.remove(websocket)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">self, message: <span class="hljs-built_in">dict</span></span>):<br>        <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.active_connections:<br>            <span class="hljs-keyword">await</span> connection.send_json(message)<br><br>manager = ConnectionManager()<br><br><span class="hljs-comment"># 模拟后台数据推送任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">topology_broadcaster</span>(<span class="hljs-params">service: TopologyService</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    这个函数需要在 main.py 的 @app.on_event("startup") 中启动</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 获取最新拓扑（包含 Docker 状态 + Geth 连接）</span><br>        topology_data = <span class="hljs-keyword">await</span> service.get_full_topology_snapshot()<br><br>        <span class="hljs-comment"># 广播数据</span><br>        <span class="hljs-keyword">if</span> manager.active_connections:<br>            <span class="hljs-keyword">await</span> manager.broadcast(topology_data)<br><br>        <span class="hljs-comment"># 每 5 秒推送一次，避免前端渲染压力过大</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-meta">@router.websocket(<span class="hljs-params"><span class="hljs-string">"/ws/topology"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">websocket_endpoint</span>(<span class="hljs-params">websocket: WebSocket</span>):<br>    <span class="hljs-keyword">await</span> manager.connect(websocket)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 保持连接活跃，也可以接收前端的控制指令（比如点击了某个节点）</span><br>            data = <span class="hljs-keyword">await</span> websocket.receive_text()<br>    <span class="hljs-keyword">except</span> WebSocketDisconnect:<br>        manager.disconnect(websocket)<br></code></pre></td></tr></table></figure><h3 id="3-前端：D3-js-实时更新与高亮逻辑"><a href="#3-前端：D3-js-实时更新与高亮逻辑" class="headerlink" title="3. 前端：D3.js 实时更新与高亮逻辑"></a>3. 前端：D3.js 实时更新与高亮逻辑</h3><p>这是最关键的部分。不要清空 SVG！使用 D3 的 Enter (新增), Update (更新), Exit (删除) 模式。</p><p>核心策略包括 ID 绑定，告诉 D3 如何通过 ID（如 enode_id 或 container_name）区分节点，而不是数组索引；平滑模拟，数据更新时，不要将 alpha 重置为 1（会导致整个图剧烈爆炸），而是重置为 0.3 左右（轻微调整）；样式 Diff，比对新旧数据，如果状态变化（如 IP 变了，Peer 数变了），添加 CSS 类名触发动画。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;a href=&quot;#复杂异构系统监控与可视化项目设计&quot; class=&quot;headerlink&quot; title=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;复杂异构系统监控与可视化&lt;/strong&gt;项目设计&lt;/h2&gt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-06-杂记-前端图拓扑渲染优化</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/7900.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/7900.html</id>
    <published>2025-12-06T03:25:47.000Z</published>
    <updated>2025-12-14T17:56:13.795Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>性能优化 (Web Workers)</strong>: 目前的数据获取、解析和Diff算法都在<strong>主线程</strong>运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 <strong>Web Worker</strong>。</p></li><li><p><strong>D3 渲染优化</strong>: 目前的设计倾向于每次更新都全量替换 filteredNodes，这会导致 D3 力导向图重新初始化或位置抖动。应该利用 Diff 结果进行<strong>增量渲染 (Enter/Update/Exit)</strong>。</p></li><li><p><strong>状态管理解耦</strong>: useTopologyData 承担了太多职责（数据存储、UI状态、标签逻辑）。应该拆分为“数据层”和“视觉层”。</p></li><li><p><strong>数据结构优化</strong>: 数组查找（.find）效率低，应更多使用 Map/Set 索引。</p></li></ol><h3 id="优化后文件结构"><a href="#优化后文件结构" class="headerlink" title="优化后文件结构"></a>优化后文件结构</h3><p>采用了 <strong>Core (数据核心) + Visual (视觉逻辑) + Worker (后台计算)</strong> 的分层结构。</p><p>codeText</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span>/<br>  ├── types/<br>  │   └── topology<span class="hljs-selector-class">.ts</span>           <span class="hljs-comment">// (保持不变) 类型定义</span><br>  ├── workers/<br>  │   └── topology<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [新] 负责Fetch、解析数据、计算Diff</span><br>  ├── composables/<br>  │   ├── useTopologyCore<span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [优化] 负责与Worker通信，持有原始数据</span><br>  │   ├── useTopologyVisual<span class="hljs-selector-class">.ts</span>  <span class="hljs-comment">// [拆分] 负责过滤、标签、高亮等UI逻辑</span><br>  │   └── useD3Renderer<span class="hljs-selector-class">.ts</span>      <span class="hljs-comment">// [新] 封装D3的具体操作，接受Diff指令</span><br>  └── components/<br>      └── EthereumTopology<span class="hljs-selector-class">.vue</span>  <span class="hljs-comment">// [优化] 变得很薄，只负责组装</span><br></code></pre></td></tr></table></figure><p>现在的以太坊拓扑渲染架构采用了 <strong>“分层响应式架构” (Layered Reactive Architecture)</strong>，结合了 <strong>Web Worker 多线程计算</strong> 和 <strong>D3 增量渲染</strong> 技术。</p><p>这是一种高性能、低耦合的现代前端架构，专门为了处理大量节点（数千级）的实时动态拓扑而设计。</p><p>以下是该架构的详细层级解析：</p><h3 id="1-架构总览图"><a href="#1-架构总览图" class="headerlink" title="1. 架构总览图"></a>1. 架构总览图</h3><p>数据流向是单向的，状态管理是响应式的：</p><p>codeMermaid</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">graph TD<br>    BackEnd[FastAPI 后端] --&gt;|<span class="hljs-type">JSON</span> Stream| <span class="hljs-type">Worker</span>[Web Worker (后台线程)]<br>    <br>    subgraph <span class="hljs-string">"Main Thread (主线程)"</span><br>        Worker --&gt;|<span class="hljs-type">Diff</span> Update (增量/全量)| <span class="hljs-type">Store</span>[useTopologyCore (数据层)]<br>        Store --&gt;|<span class="hljs-type">Raw</span> Data| <span class="hljs-type">Visual</span>[useTopologyVisual (视觉层)]<br>        <br>        subgraph <span class="hljs-string">"UI Components (视图层)"</span><br>            Visual --&gt;|<span class="hljs-type">Filtered</span> Data| <span class="hljs-type">Renderer</span>[useD3Renderer (渲染层)]<br>            Visual --&gt;|<span class="hljs-type">Filters</span>/<span class="hljs-keyword">Mode</span>| <span class="hljs-type">Controls</span>[TopologyVisualization (控制面板)]<br>            Renderer --&gt;|<span class="hljs-type">Click</span> Event| <span class="hljs-type">Details</span>[PhysicalTopology (详情抽屉)]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br>    Renderer --&gt;|<span class="hljs-type">Draw</span>| <span class="hljs-type">DOM</span>[SVG/Canvas]<br></code></pre></td></tr></table></figure><hr><h3 id="2-核心层级详细解析"><a href="#2-核心层级详细解析" class="headerlink" title="2. 核心层级详细解析"></a>2. 核心层级详细解析</h3><h4 id="第一层：数据处理层-Worker-Thread"><a href="#第一层：数据处理层-Worker-Thread" class="headerlink" title="第一层：数据处理层 (Worker Thread)"></a>第一层：数据处理层 (Worker Thread)</h4><p><strong>文件</strong>: workers/topology.worker.ts<br>这是架构的“发动机”，完全脱离主线程运行。</p><ul><li><p><strong>职责</strong>：</p><ol><li><p><strong>数据拉取</strong>：直接发起 Fetch 请求，不占用主线程网络资源。</p></li><li><p><strong>数据清洗</strong>：解析复杂的 JSON 结构，标准化为 TopologyNode 和 TopologyLink。</p></li><li><p><strong>智能 Diff (差异计算)</strong>：</p><ul><li><p>这是性能优化的关键。它对比新旧数据，计算出新增、删除和更新的节点。</p></li><li><p><strong>坐标继承</strong>：在 Worker 中将旧节点的 x, y 坐标赋值给新节点，防止 D3 在数据更新时重新计算布局导致视图“爆炸”或闪烁。</p></li></ul></li></ol></li></ul><h4 id="第二层：状态管理层-Composables"><a href="#第二层：状态管理层-Composables" class="headerlink" title="第二层：状态管理层 (Composables)"></a>第二层：状态管理层 (Composables)</h4><p>这一层利用 Vue 3 的 Composition API 将业务逻辑拆分为独立的模块。</p><ul><li><p><strong>数据持有 (useTopologyCore.ts)</strong>：</p><ul><li><p>与 Worker 通信的桥梁。</p></li><li><p>使用 shallowRef 存储庞大的拓扑数据。<strong>优化点</strong>：shallowRef 不会深度监听节点内部属性的变化（如 x, y 坐标），这极大减轻了 Vue 响应式系统的负担，因为 D3 会直接操作这些原生对象。</p></li></ul></li><li><p><strong>视觉逻辑 (useTopologyVisual.ts)</strong>：</p><ul><li><p><strong>纯粹的计算层</strong>。它不关心数据怎么来的，只关心怎么显示。</p></li><li><p><strong>动态过滤</strong>：利用 computed 属性，根据 filters（如隐藏共识节点）实时生成 filteredNodes。</p></li><li><p><strong>样式映射</strong>：集中管理颜色 (getNodeColor) 和标签 (getNodeLabel) 逻辑，实现逻辑与渲染分离。</p></li></ul></li></ul><h4 id="第三层：渲染驱动层-Render-Engine"><a href="#第三层：渲染驱动层-Render-Engine" class="headerlink" title="第三层：渲染驱动层 (Render Engine)"></a>第三层：渲染驱动层 (Render Engine)</h4><p><strong>文件</strong>: useD3Renderer.ts<br>这是 D3.js 与 Vue 的结合点。</p><ul><li><p><strong>生命周期接管</strong>：它在 onMounted 时初始化 D3 仿真器。</p></li><li><p><strong>增量渲染 (Incremental Rendering)</strong>：</p><ul><li><p>使用 Vue 的 watch 监听过滤后的数据。</p></li><li><p>利用 D3 的 enter(), update(), exit() 模式。</p></li><li><p><strong>Enter</strong>: 新节点淡入。</p></li><li><p><strong>Exit</strong>: 被过滤或删除的节点淡出移除。</p></li><li><p><strong>Update</strong>: 现有节点平滑移动到新位置。</p></li></ul></li><li><p><strong>事件桥接</strong>：将 D3 的 click、drag 事件转换为 Vue 的回调函数，传递给上层组件。</p></li></ul><h4 id="第四层：视图组装层-View-Integration"><a href="#第四层：视图组装层-View-Integration" class="headerlink" title="第四层：视图组装层 (View Integration)"></a>第四层：视图组装层 (View Integration)</h4><p><strong>文件</strong>: EthereumTopology.vue (父组件)<br>这是架构的“容器”和“胶水”。</p><ul><li><p><strong>依赖注入 (Dependency Injection)</strong>：</p><ul><li><p>父组件通过 provide(‘topology-state’, …) 将 mode、filters 等状态下发。</p></li><li><p>子组件 TopologyVisualization 通过 inject 直接获取并修改这些状态。避免了深层 Prop 传递（Prop Drilling）。</p></li></ul></li><li><p><strong>组件编排</strong>：</p><ul><li><p>负责布局：左上角悬浮控制面板、中间 D3 画布、右侧详情抽屉。</p></li><li><p>负责联动：当 D3 点击节点时，控制 showPhysicalDetails 变量来弹出侧边栏。</p></li></ul></li></ul><hr><h3 id="3-关键性能优化点总结"><a href="#3-关键性能优化点总结" class="headerlink" title="3. 关键性能优化点总结"></a>3. 关键性能优化点总结</h3><ol><li><p><strong>非阻塞主线程 (Off-Main-Thread)</strong>:</p><ul><li><p><strong>旧架构</strong>：在组件内 fetch 数据 -&gt; 解析 -&gt; 赋值。数据量大时 UI 会卡顿。</p></li><li><p><strong>新架构</strong>：所有数据处理都在 Worker 中完成，主线程只负责接收“准备好渲染”的数据。</p></li></ul></li><li><p><strong>浅层响应式 (Shallow Reactivity)</strong>:</p><ul><li>使用 shallowRef 代替 ref 存储节点数组。D3 内部高频修改 node.x 和 node.y 时，不会触发 Vue 的依赖更新系统，显著提升动画帧率。</li></ul></li><li><p><strong>状态保持 (State Preservation)</strong>:</p><ul><li>Worker 在处理新数据时，会查找旧数据的 ID，并将 x, y, vx, vy (速度向量) 复制给新数据。这保证了在轮询更新时，节点不会重置位置，实现了“流式”的平滑更新效果。</li></ul></li><li><p><strong>按需计算 (Computed Filtering)</strong>:</p><ul><li>连接 (links) 的过滤依赖于节点 (nodes) 的过滤结果。新架构使用了 Set 来建立索引，将连接过滤的时间复杂度从 O(N*M) 降低到 O(M)（其中 N 是节点数，M 是连接数）。</li></ul></li></ol><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>现在的架构是一个 <strong>“重后台、轻前台、数据驱动视图”</strong> 的专业可视化架构。</p><ul><li><p><strong>Worker</strong> 负责“脏活累活”（数据处理）。</p></li><li><p><strong>D3</strong> 负责“精细活”（物理仿真和绘图）。</p></li><li><p><strong>Vue</strong> 负责“指挥”（状态管理和组件通信）。</p></li></ul><p>这种架构非常适合需要长时间运行、实时监控网络状态的生产级系统。</p><hr><p>根据提供的代码（EthereumTopologyHandler 和 RealTopologyService），以太坊网络拓扑的处理流程是一个<strong>分层获取、数据融合、格式化输出</strong>的过程。核心逻辑依赖于 <strong>Neo4j 图数据库</strong>（存储P2P关系）和 <strong>Docker 守护进程</strong>（提供容器运行时信息）。</p><p>以下是详细的处理步骤解析：</p><h3 id="1-数据源获取-Data-Acquisition"><a href="#1-数据源获取-Data-Acquisition" class="headerlink" title="1. 数据源获取 (Data Acquisition)"></a>1. 数据源获取 (Data Acquisition)</h3><p>系统主要通过两个渠道获取数据：</p><ul><li><p><strong>Neo4j 数据库 (核心数据源)</strong>：存储了爬虫或客户端上报的节点发现数据，包含节点ID、IP、以及节点间的 P2P 连接关系。</p></li><li><p><strong>Docker Client (辅助数据源)</strong>：用于获取运行中容器的实时状态、名称映射和网络设置。</p></li></ul><h3 id="2-核心处理流程"><a href="#2-核心处理流程" class="headerlink" title="2. 核心处理流程"></a>2. 核心处理流程</h3><p>整个拓扑生成的逻辑主要集中在 _get_real_topology_from_neo4j 和 _convert_topology_format 方法中。</p><h4 id="步骤-A：从-Neo4j-提取原始拓扑结构"><a href="#步骤-A：从-Neo4j-提取原始拓扑结构" class="headerlink" title="步骤 A：从 Neo4j 提取原始拓扑结构"></a>步骤 A：从 Neo4j 提取原始拓扑结构</h4><p>代码通过 Cypher 查询语句分三步提取数据：</p><ol><li><p><strong>查询执行层 (Execution Layer)</strong>：</p><ul><li><p>查找所有 ExecNode 标签的节点。</p></li><li><p>查找 EXEC_PEERS_WITH 关系，获取该节点的对等节点（Peers）。</p></li></ul></li><li><p><strong>查询共识层 (Consensus Layer)</strong>：</p><ul><li><p>查找所有 ConsNode 标签的节点。</p></li><li><p>查找 CONS_PEERS_WITH 关系。</p></li></ul></li><li><p><strong>查询验证者 (Validators)</strong>：</p><ul><li><p>查找与共识节点通过 MANAGES_VALIDATOR 关系连接的 Validator 节点。</p></li><li><p>这反映了哪个信标节点（Beacon Node）管理着哪些验证者客户端。</p></li></ul></li></ol><h4 id="步骤-B：容器身份映射-Container-Mapping"><a href="#步骤-B：容器身份映射-Container-Mapping" class="headerlink" title="步骤 B：容器身份映射 (Container Mapping)"></a>步骤 B：容器身份映射 (Container Mapping)</h4><ul><li><p><strong>目的</strong>：数据库中只有 IP 地址，但在前端展示时，最好能显示具体的 Docker 容器名称（如 geth-node-1）。</p></li><li><p><strong>实现</strong>：_create_ip_to_container_mapping 方法遍历所有 Docker 容器，提取其网络设置中的 IP 地址，建立 IP -&gt; ContainerName 的映射表。</p></li></ul><h4 id="步骤-C：构建拓扑对象-Topology-Construction"><a href="#步骤-C：构建拓扑对象-Topology-Construction" class="headerlink" title="步骤 C：构建拓扑对象 (Topology Construction)"></a>步骤 C：构建拓扑对象 (Topology Construction)</h4><p>系统将原始数据转换为前端可视化的 JSON 格式，包含 nodes 和 links。</p><p><strong>1. 节点生成 (Nodes):</strong><br>代码根据逻辑自动计算节点的坐标 (x, y) 以便可视化布局：</p><ul><li><p><strong>执行层节点</strong>：</p><ul><li><p>type: execution</p></li><li><p>位置：固定在 Y=150 的水平线上。</p></li></ul></li><li><p><strong>共识层节点</strong>：</p><ul><li><p>type: consensus</p></li><li><p>位置：固定在 Y=350 的水平线上（位于执行层下方）。</p></li></ul></li><li><p><strong>验证者节点</strong>：</p><ul><li><p>type: validator</p></li><li><p>位置：簇拥在所属共识节点的下方 (y + 60)，通过计算偏移量排成小方阵。</p></li></ul></li></ul><p><strong>2. 连接生成 (Links):</strong><br>系统构建了四种类型的连接：</p><ul><li><p><strong>执行层 P2P (exec_peer)</strong>：基于 Neo4j 中的 EXEC_PEERS_WITH 关系，表示 Geth/Nethermind 节点间的 Gossip 协议连接。</p></li><li><p><strong>共识层 P2P (cons_peer)</strong>：基于 CONS_PEERS_WITH 关系，表示 Lighthouse/Prysm 节点间的连接。</p></li><li><p><strong>管理关系 (manages_validator)</strong>：连接共识节点和它管理的验证者节点。</p></li><li><p><strong>跨层连接 (cross_layer)</strong>：<strong>关键逻辑</strong>。代码会自动匹配 IP 地址相同的执行层节点和共识层节点，并创建一个垂直连接。这代表了以太坊客户端组合（Engine API 通信，例如 Geth &lt;-&gt; Lighthouse 在同一台机器/Pod内）。</p></li></ul><h3 id="3-容错与缓存机制"><a href="#3-容错与缓存机制" class="headerlink" title="3. 容错与缓存机制"></a>3. 容错与缓存机制</h3><p>为了保证性能和稳定性，代码中包含了以下机制：</p><ul><li><p><strong>缓存 (Caching)</strong>：</p><ul><li><p>使用 self.cache 存储计算好的拓扑。</p></li><li><p>设置 cache_ttl (20-30秒)，防止频繁查询 Neo4j 导致数据库过载。</p></li></ul></li><li><p><strong>降级模式 (Fallback - 仅在 Service 中)</strong>：</p><ul><li><p>如果 Neo4j 连接失败或返回空数据，RealTopologyService 会调用 _get_container_based_topology。</p></li><li><p><strong>Fallback 逻辑</strong>：直接扫描 Docker 容器，如果发现名为 ethereum 的容器，就根据容器数量“伪造”一个链式的拓扑结构（非网状），以确保界面上至少能看到节点存在，而不是一片空白。</p></li></ul></li></ul><h3 id="4-统计与验证-Statistics-amp-Validation"><a href="#4-统计与验证-Statistics-amp-Validation" class="headerlink" title="4. 统计与验证 (Statistics & Validation)"></a>4. 统计与验证 (Statistics &amp; Validation)</h3><p>EthereumTopologyHandler 还提供了额外的高级功能：</p><ul><li><p><strong>独立查询</strong>：get_nodes 和 get_links 可以不依赖完整拓扑逻辑，直接查询特定层的数据，提高效率。</p></li><li><p><strong>拓扑验证</strong>：validate_topology 检查数据一致性：</p><ul><li><p>节点 ID 是否唯一。</p></li><li><p>连接的源/目标节点是否存在。</p></li><li><p>是否存在孤立节点。</p></li><li><p>IP 地址分布是否异常（例如一个 IP 运行了超过2个主要节点）。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该系统处理以太坊拓扑的核心思想是：<strong>“数据库定义逻辑关系，Docker 定义物理属性，代码负责视觉组装”</strong>。</p><ol><li><p><strong>逻辑层</strong>：谁连谁？由 Neo4j 决定。</p></li><li><p><strong>物理层</strong>：你是谁？由 Docker IP 映射决定。</p></li><li><p><strong>视觉层</strong>：你在哪？由代码中的分层坐标计算逻辑决定（执行层在上，共识层在中，验证者在下）。</p></li></ol><hr><p>目前的实现逻辑虽然功能完整，但在性能上存在几个显著的<strong>瓶颈</strong>，特别是在节点数量增多或 Docker 容器较多时，响应速度会明显下降。</p><p>以下是针对代码的具体性能优化方案，按<strong>提升幅度从大到小</strong>排序：</p><h3 id="1-痛点分析：目前的性能瓶颈在哪里？"><a href="#1-痛点分析：目前的性能瓶颈在哪里？" class="headerlink" title="1. 痛点分析：目前的性能瓶颈在哪里？"></a>1. 痛点分析：目前的性能瓶颈在哪里？</h3><ol><li><p><strong>Docker API 调用过于频繁 (主要瓶颈)</strong>：</p><ul><li><p>_create_ip_to_container_mapping 每次生成拓扑都会被调用。它会遍历<strong>所有</strong>容器并检查网络设置。Docker API 的响应通常是毫秒级到秒级的，如果不缓存，这会严重阻塞主线程。</p></li><li><p>在物理拓扑中，_get_link_bandwidth 会对每个连接进入容器执行 tc 命令。如果有 50 个连接，就要串行执行 50 次 docker exec，这是极慢的 IO 操作。</p></li></ul></li><li><p><strong>串行数据库查询</strong>：</p><ul><li>在 _get_real_topology_from_neo4j 中，执行层查询及处理完之后，才开始共识层的查询。这两者没有依赖关系，完全可以并行。</li></ul></li><li><p><strong>计算密集型的重复操作</strong>：</p><ul><li>每次请求都重新计算所有节点的坐标和映射关系，即使数据没有变化。</li></ul></li></ol><hr><h3 id="2-优化方案一：Docker-数据的独立缓存与后台更新"><a href="#2-优化方案一：Docker-数据的独立缓存与后台更新" class="headerlink" title="2. 优化方案一：Docker 数据的独立缓存与后台更新"></a>2. 优化方案一：Docker 数据的独立缓存与后台更新</h3><p>Docker 的元数据（IP、容器名）变化频率远低于 P2P 网络连接的变化频率。<strong>不要在每次请求拓扑时都去查询 Docker。</strong></p><p><strong>优化策略：</strong> 使用“读写分离”的策略，后台任务更新 Docker 映射，前台请求只读内存变量。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 原有初始化 ...</span><br>        <span class="hljs-variable language_">self</span>.ip_container_map_cache = {}<br>        <span class="hljs-variable language_">self</span>.map_last_update = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.map_update_lock = asyncio.Lock()<br>        <br>        <span class="hljs-comment"># 启动时预热</span><br>        <span class="hljs-comment"># 注意：实际代码中建议使用 apscheduler 或 asyncio.create_task 在后台循环运行</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_ip_to_container_map_optimized</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化后的获取映射方法：</span><br><span class="hljs-string">        1. 优先返回内存缓存</span><br><span class="hljs-string">        2. 缓存过期（如5分钟）才异步更新</span><br><span class="hljs-string">        """</span><br>        current_time = time.time()<br>        <span class="hljs-comment"># 缓存有效期设为 300秒 (Docker容器IP不会频繁变动)</span><br>        <span class="hljs-keyword">if</span> current_time - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br><br>        <span class="hljs-comment"># 如果需要更新，且未被锁定</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.map_update_lock.locked():<br>             <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.map_update_lock:<br>                 <span class="hljs-comment"># 二次检查</span><br>                 <span class="hljs-keyword">if</span> time.time() - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span>: <br>                     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br>                 <br>                 <span class="hljs-comment"># 执行耗时的 Docker 查询</span><br>                 <span class="hljs-comment"># 建议：在一个线程池中运行同步的 docker client 操作，避免阻塞事件循环</span><br>                 loop = asyncio.get_running_loop()<br>                 <span class="hljs-variable language_">self</span>.ip_container_map_cache = <span class="hljs-keyword">await</span> loop.run_in_executor(<br>                     <span class="hljs-literal">None</span>, <span class="hljs-variable language_">self</span>._create_ip_to_container_mapping<br>                 )<br>                 <span class="hljs-variable language_">self</span>.map_last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br></code></pre></td></tr></table></figure><h3 id="3-优化方案二：物理拓扑带宽检测的“非阻塞化”"><a href="#3-优化方案二：物理拓扑带宽检测的“非阻塞化”" class="headerlink" title="3. 优化方案二：物理拓扑带宽检测的“非阻塞化”"></a>3. 优化方案二：物理拓扑带宽检测的“非阻塞化”</h3><p>在 RealTopologyService 中，物理连接的带宽检测（tc 命令）是极其耗时的。绝对不能在用户请求 API 时实时去跑 tc 命令。</p><p><strong>优化策略：</strong> 将带宽数据设为“最终一致性”。主接口只返回拓扑结构，带宽字段先返回缓存值或 “Checking…”，后台任务专门负责轮询更新带宽。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealTopologyService</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-variable language_">self</span>.bandwidth_cache = {} <span class="hljs-comment"># Key: "container_ip", Value: "100Mbit"</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_dynamic_physical_topology_from_containers</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 前面生成 nodes 和 links 的逻辑保持不变 ...</span><br>        <br>        <span class="hljs-comment"># --- 优化点：移除实时 await _get_link_bandwidth ---</span><br>        <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>            target_id = link[<span class="hljs-string">'target'</span>]<br>            target_node = nodes_by_id[target_id]<br>            container_name = target_node[<span class="hljs-string">'container_name'</span>]<br>            link_ip = target_node[<span class="hljs-string">'networks'</span>].get(link[<span class="hljs-string">'shared_network'</span>])<br>            <br>            <span class="hljs-comment"># 1. 尝试从缓存获取</span><br>            cache_key = <span class="hljs-string">f"<span class="hljs-subst">{container_name}</span>::<span class="hljs-subst">{link_ip}</span>"</span><br>            cached_bw = <span class="hljs-variable language_">self</span>.bandwidth_cache.get(cache_key)<br>            <br>            <span class="hljs-keyword">if</span> cached_bw:<br>                link[<span class="hljs-string">'bandwidth'</span>] = cached_bw<br>            <span class="hljs-keyword">else</span>:<br>                link[<span class="hljs-string">'bandwidth'</span>] = <span class="hljs-string">"Querying..."</span><br>                <span class="hljs-comment"># 2. 触发后台更新任务 (Fire and Forget)</span><br>                asyncio.create_task(<span class="hljs-variable language_">self</span>._update_bandwidth_cache(container_name, link_ip, cache_key))<br>                <br>        <span class="hljs-keyword">return</span> nodes, links<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bandwidth_cache</span>(<span class="hljs-params">self, container_name, link_ip, cache_key</span>):<br>        <span class="hljs-string">"""后台单独更新带宽"""</span><br>        bw = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>._get_link_bandwidth(container_name, link_ip)<br>        <span class="hljs-variable language_">self</span>.bandwidth_cache[cache_key] = bw<br></code></pre></td></tr></table></figure><h3 id="4-优化方案三：Neo4j-并发查询"><a href="#4-优化方案三：Neo4j-并发查询" class="headerlink" title="4. 优化方案三：Neo4j 并发查询"></a>4. 优化方案三：Neo4j 并发查询</h3><p>Neo4j 的 Python Driver (尤其是 Bolt 协议) 支持并发。执行层和共识层的查询是独立的，可以使用 asyncio.gather 同时发起查询。</p><p><strong>注意</strong>：这需要你的 database_manager 支持异步操作。如果底层是同步驱动，可以用 run_in_executor 包装。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 EthereumTopologyHandler 中</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_real_topology_from_neo4j</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Dict</span>, <span class="hljs-type">Dict</span>]:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># ... 连接检查 ...</span><br><br>            <span class="hljs-comment"># 定义查询函数</span><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_exec</span>():<br>                <span class="hljs-comment"># 这里假设 database_manager 提供了某种异步执行方式，</span><br>                <span class="hljs-comment"># 或者我们将同步的 session.run 放入线程池</span><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        result = session.run(<span class="hljs-string">"MATCH (n:ExecNode)..."</span>) <span class="hljs-comment"># 填入完整的 Cypher</span><br>                        <span class="hljs-keyword">return</span> {r[<span class="hljs-string">'node_id'</span>]: ... <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result} <span class="hljs-comment"># 处理结果</span><br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_cons_and_validators</span>():<br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        <span class="hljs-comment"># 合并共识节点和验证者的查询逻辑，减少一次 session 创建开销</span><br>                        cons_result = session.run(<span class="hljs-string">"MATCH (n:ConsNode)..."</span>) <br>                        <span class="hljs-comment"># ... 处理共识 ...</span><br>                        validator_result = session.run(<span class="hljs-string">"MATCH ... validators ..."</span>)<br>                        <span class="hljs-comment"># ... 处理验证者 ...</span><br>                        <span class="hljs-keyword">return</span> cons_data<br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-comment"># 并发执行</span><br>            exec_nodes_data, cons_nodes_data = <span class="hljs-keyword">await</span> asyncio.gather(<br>                fetch_exec(), <br>                fetch_cons_and_validators()<br>            )<br><br>            <span class="hljs-keyword">return</span> exec_nodes_data, cons_nodes_data<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># ... Error handling</span><br></code></pre></td></tr></table></figure><h3 id="5-优化方案四：Cypher-查询语句优化"><a href="#5-优化方案四：Cypher-查询语句优化" class="headerlink" title="5. 优化方案四：Cypher 查询语句优化"></a>5. 优化方案四：Cypher 查询语句优化</h3><p>目前的 Cypher 使用了 OPTIONAL MATCH 和 collect，这在数据量大时比较慢。</p><p><strong>原查询：</strong></p><p>codeCypher</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">MATCH (n:ExecNode)<br>OPTIONAL MATCH (n)-<span class="hljs-selector-attr">[r:EXEC_PEERS_WITH]</span>-&gt;(p:ExecNode)<br>RETURN ... <span class="hljs-built_in">collect</span>(...)<br></code></pre></td></tr></table></figure><p>如果在节点很多的情况下，这个查询会扫描整个图。</p><p><strong>优化建议：</strong></p><ol><li><p><strong>分批次</strong>：如果节点超过 1000 个，不要一次性 collect 所有 Peers。前端通常不需要展示所有几千条连线（会卡死浏览器）。可以限制返回的 Peer 数量，例如 LIMIT 10。</p></li><li><p><strong>索引</strong>：确保 node_id, ip 在 Neo4j 中建立了索引 (CREATE INDEX ON :ExecNode(node_id)).</p></li><li><p><strong>只查 ID</strong>：先查出所有 Node 的基础信息，再查 Relation 表（Links），在内存中组装，通常比 Graph DB 做复杂的聚合（Map/Collect）要快。</p></li></ol><h3 id="6-综合改进后的代码结构建议"><a href="#6-综合改进后的代码结构建议" class="headerlink" title="6. 综合改进后的代码结构建议"></a>6. 综合改进后的代码结构建议</h3><p>这里给出一个集成优化思路的 EthereumTopologyHandler 核心方法重构示例：</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-comment"># ... init ...</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_topology</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        <span class="hljs-string">"""获取完整的以太坊拓扑 (优化版)"""</span><br>        <span class="hljs-comment"># 1. 检查拓扑缓存 (Short TTL: e.g., 5s)</span><br>        <span class="hljs-comment"># 拓扑结构变化很快，缓存时间短一点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._is_cache_valid(<span class="hljs-string">"full_ethereum_topology"</span>, ttl=<span class="hljs-number">5</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>]<br><br>        <span class="hljs-comment"># 2. 并行获取数据</span><br>        <span class="hljs-comment"># A. 获取 Docker 映射 (从长效缓存或后台任务获取，极快)</span><br>        <span class="hljs-comment"># B. 获取 Neo4j 数据 (并发查询)</span><br>        <br>        task_docker = <span class="hljs-variable language_">self</span>._get_ip_to_container_map_optimized() <span class="hljs-comment"># 优化点1</span><br>        task_neo4j = <span class="hljs-variable language_">self</span>._get_real_topology_from_neo4j()       <span class="hljs-comment"># 优化点3 (并发内部实现)</span><br>        <br>        ip_map, (exec_data, cons_data) = <span class="hljs-keyword">await</span> asyncio.gather(task_docker, task_neo4j)<br><br>        <span class="hljs-comment"># 3. 转换数据 (CPU 密集型)</span><br>        <span class="hljs-comment"># 如果节点数非常多 (&gt;5000)，可以考虑放入 ProcessPoolExecutor</span><br>        nodes, links = <span class="hljs-variable language_">self</span>._convert_topology_format_optimized(exec_data, cons_data, ip_map)<br><br>        topology_data = {<br>            <span class="hljs-string">'nodes'</span>: nodes, <span class="hljs-string">'links'</span>: links, <span class="hljs-string">'timestamp'</span>: time.time(),<br>            <span class="hljs-comment"># ...</span><br>        }<br><br>        <span class="hljs-comment"># 更新缓存</span><br>        <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>] = topology_data<br>        <span class="hljs-variable language_">self</span>.last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> topology_data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_convert_topology_format_optimized</span>(<span class="hljs-params">self, exec_data, cons_data, ip_map</span>):<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化点：</span><br><span class="hljs-string">        1. 使用 ip_map.get 避免重复循环</span><br><span class="hljs-string">        2. 预计算 positions 字典，避免列表遍历查找</span><br><span class="hljs-string">        """</span><br>        nodes = []<br>        links = []<br>        <span class="hljs-comment"># 使用字典加速查找: key=node_id, value={idx, type, ...}</span><br>        node_lookup = {} <br>        <br>        <span class="hljs-comment"># ... 处理 Exec 节点 ...</span><br>        <span class="hljs-keyword">for</span> i, (nid, data) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exec_data.items()):<br>            <span class="hljs-comment"># 直接查预热好的 Map，O(1)</span><br>            container = ip_map.get(data[<span class="hljs-string">'ip'</span>], <span class="hljs-string">f"exec-<span class="hljs-subst">{data[<span class="hljs-string">'ip'</span>]}</span>"</span>)<br>            <span class="hljs-comment"># ... 创建 node ...</span><br>            node_lookup[nid] = {<span class="hljs-string">'type'</span>: <span class="hljs-string">'execution'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-string">f'<span class="hljs-subst">{nid}</span>-exec'</span>}<br>            <br>        <span class="hljs-comment"># ... 处理 Cons 节点 ...</span><br>        <br>        <span class="hljs-comment"># ... 处理连接 ...</span><br>        <span class="hljs-comment"># 只需要遍历一次 exec_data 的 peers，利用 node_lookup 快速验证</span><br>        <span class="hljs-keyword">for</span> nid, data <span class="hljs-keyword">in</span> exec_data.items():<br>             source_full_id = <span class="hljs-string">f"<span class="hljs-subst">{nid}</span>-exec"</span><br>             <span class="hljs-keyword">for</span> peer <span class="hljs-keyword">in</span> data.get(<span class="hljs-string">'peers'</span>, []):<br>                 target_nid = peer[<span class="hljs-string">'peer_id'</span>]<br>                 <span class="hljs-comment"># O(1) 检查目标是否存在</span><br>                 <span class="hljs-keyword">if</span> target_nid <span class="hljs-keyword">in</span> node_lookup <span class="hljs-keyword">and</span> node_lookup[target_nid][<span class="hljs-string">'type'</span>] == <span class="hljs-string">'execution'</span>:<br>                     links.append({<br>                         <span class="hljs-string">'source'</span>: source_full_id,<br>                         <span class="hljs-string">'target'</span>: <span class="hljs-string">f"<span class="hljs-subst">{target_nid}</span>-exec"</span>,<br>                         <span class="hljs-comment"># ...</span><br>                     })<br>                     <br>        <span class="hljs-keyword">return</span> nodes, links<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>要进行性能优化，最关键的修改是：</p><ol><li><p><strong>Docker 映射</strong>：改为后台定时更新或长缓存，不要每秒都去 inspect 容器。</p></li><li><p><strong>物理带宽 (tc)</strong>：改为异步/后台获取，不要阻塞 API 响应。</p></li><li><p><strong>Neo4j</strong>：使用并发查询，并限制 Cypher 复杂度。</p></li></ol><hr><h2 id="攻击方式（Attack-Strategies）"><a href="#攻击方式（Attack-Strategies）" class="headerlink" title="攻击方式（Attack Strategies）"></a>攻击方式（Attack Strategies）</h2><p>系统目前支持以下6种攻击方式：</p><h3 id="1-节点断网攻击（Node-Disconnection-Attack）"><a href="#1-节点断网攻击（Node-Disconnection-Attack）" class="headerlink" title="1. 节点断网攻击（Node Disconnection Attack）"></a>1. 节点断网攻击（Node Disconnection Attack）</h3><p>通过网络隔离手段切断目标节点与其他节点的连接。支持的方法包括：</p><ul><li><code>interface_down</code>: 禁用网络接口</li><li><code>route_flush</code>: 清除路由表</li><li><code>firewall_block</code>: 防火墙阻断</li><li><code>p2p_block</code>: P2P连接阻断</li></ul><h3 id="2-通信干扰攻击（Communication-Interference-Attack）"><a href="#2-通信干扰攻击（Communication-Interference-Attack）" class="headerlink" title="2. 通信干扰攻击（Communication Interference Attack）"></a>2. 通信干扰攻击（Communication Interference Attack）</h3><p>通过大量无效通信干扰目标节点正常通信。支持的方法包括：</p><ul><li><code>json_rpc_flood</code>: JSON-RPC请求泛洪</li><li><code>p2p_flood</code>: P2P消息泛洪</li><li><code>memory_exhaustion</code>: 内存耗尽攻击</li></ul><h3 id="3-时间攻击（Timestamp-Attack）"><a href="#3-时间攻击（Timestamp-Attack）" class="headerlink" title="3. 时间攻击（Timestamp Attack）"></a>3. 时间攻击（Timestamp Attack）</h3><p>针对共识机制的时间同步进行攻击。支持的方法包括：</p><ul><li>time_shift: 时间偏移</li><li><code>ntp_block</code>: 阻断NTP时间同步</li><li><code>time_drift</code>: 时间漂移</li></ul><h3 id="4-简化Sybil攻击（Simplified-Sybil-Attack）"><a href="#4-简化Sybil攻击（Simplified-Sybil-Attack）" class="headerlink" title="4. 简化Sybil攻击（Simplified Sybil Attack）"></a>4. 简化Sybil攻击（Simplified Sybil Attack）</h3><p>创建虚假节点来影响网络。可以配置：</p><ul><li>虚假节点数量（1-20）</li><li>节点类型（轻节点、全节点、验证者节点）</li><li>网络环境（主网、测试网、开发网）</li><li>连接真实节点选项</li></ul><h3 id="5-存储攻击（Storage-Attack）"><a href="#5-存储攻击（Storage-Attack）" class="headerlink" title="5. 存储攻击（Storage Attack）"></a>5. 存储攻击（Storage Attack）</h3><p>针对节点存储系统的攻击。支持的方法包括：</p><ul><li><code>disk_fill</code>: 磁盘空间填充</li><li><code>database_corruption</code>: 数据库损坏</li><li><code>state_pollution</code>: 状态污染</li><li><code>chain_data_spam</code>: 链上数据垃圾信息</li></ul><h3 id="6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）"><a href="#6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）" class="headerlink" title="6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）"></a>6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）</h3><p>针对特定以太坊客户端的攻击。支持的方法包括：</p><ul><li><code>process_kill</code>: 终止进程</li><li><code>db_corruption</code>: 数据库损坏</li><li><code>port_blocking</code>: 端口阻断</li><li><code>config_modification</code>: 配置文件修改</li></ul><h2 id="攻击模式（Execution-Modes）"><a href="#攻击模式（Execution-Modes）" class="headerlink" title="攻击模式（Execution Modes）"></a>攻击模式（Execution Modes）</h2><p>系统支持三种攻击执行模式：</p><h3 id="1-一次性攻击（One-shot）"><a href="#1-一次性攻击（One-shot）" class="headerlink" title="1. 一次性攻击（One-shot）"></a>1. 一次性攻击（One-shot）</h3><p>执行一次攻击，持续指定时间后自动清理恢复。 配置参数：</p><ul><li>duration_seconds: 攻击持续时间（秒）</li></ul><h3 id="2-重复攻击（Repeated）"><a href="#2-重复攻击（Repeated）" class="headerlink" title="2. 重复攻击（Repeated）"></a>2. 重复攻击（Repeated）</h3><p>按指定间隔重复执行多次攻击。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>repeat_count: 重复次数</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h3 id="3-持续攻击（Continuous）"><a href="#3-持续攻击（Continuous）" class="headerlink" title="3. 持续攻击（Continuous）"></a>3. 持续攻击（Continuous）</h3><p>持续不断地执行攻击，直到手动停止。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h2 id="动态目标攻击"><a href="#动态目标攻击" class="headerlink" title="动态目标攻击"></a>动态目标攻击</h2><p>系统还支持一种特殊的动态目标攻击功能，可以根据网络拓扑分析结果自动选择攻击目标。支持的中心性指标包括：</p><ul><li>度中心性（Degree Centrality）</li><li>介数中心性（Betweenness Centrality）</li><li>接近中心性（Closeness Centrality）</li><li>特征向量中心性（Eigenvector Centrality）</li></ul><p>通过这些攻击方式和模式的组合，系统可以模拟各种真实的以太坊网络攻击场景，帮助评估网络的安全性和鲁棒性。</p><hr><h3 id="1-发起普通攻击-Standard-Attack"><a href="#1-发起普通攻击-Standard-Attack" class="headerlink" title="1. 发起普通攻击 (Standard Attack)"></a>1. 发起普通攻击 (Standard Attack)</h3><p>此接口用于对<strong>明确指定的静态 IP 列表</strong>发起攻击。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate</p></li><li><p><strong>功能</strong>: 发起针对特定静态目标（IP/ID列表）的攻击模拟。</p></li><li><p><strong>逻辑约束</strong>:</p><ol><li><p>parameters.target_nodes 必须是字符串数组 [“ip1”, “ip2”]。</p></li><li><p>支持所有三种执行模式 (one_shot, repeated, continuous)。</p></li></ol></li><li><p><strong>请求体构建规则</strong>:</p><ul><li><p><strong>Level 1 (执行配置)</strong>: 决定攻击的时间维度。</p><ul><li><p>若是 one_shot: 仅需 duration_seconds。</p></li><li><p>若是 repeated: 需额外提供 interval_seconds 和 repeat_count。</p></li></ul></li><li><p><strong>Level 2 (策略参数)</strong>: 决定攻击的具体手段。</p><ul><li><p>必须包含 strategy 字段（枚举值）。</p></li><li><p>其余字段根据 strategy 变化（如 storage_attack 需要 size_mb，而 node_disconnection 不需要）。</p></li></ul></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 场景：对两个节点进行重复的 P2P 洪水攻击</span><br>{<br>  <span class="hljs-string">"execution_config"</span>: {<br>    <span class="hljs-string">"mode"</span>: <span class="hljs-string">"repeated"</span>,<br>    <span class="hljs-string">"duration_seconds"</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">"interval_seconds"</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">"repeat_count"</span>: <span class="hljs-number">5</span><br>  },<br>  <span class="hljs-string">"parameters"</span>: {<br>    <span class="hljs-string">"strategy"</span>: <span class="hljs-string">"communication_interference"</span>,<br>    <span class="hljs-string">"method"</span>: <span class="hljs-string">"p2p_flood"</span>,<br>    <span class="hljs-string">"intensity"</span>: <span class="hljs-string">"high"</span>,<br>    <span class="hljs-string">"target_nodes"</span>: <span class="hljs-selector-attr">[<span class="hljs-string">"192.168.1.10"</span>, <span class="hljs-string">"192.168.1.11"</span>]</span><br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h3 id="2-发起自适应攻击-Adaptive-Attack"><a href="#2-发起自适应攻击-Adaptive-Attack" class="headerlink" title="2. 发起自适应攻击 (Adaptive Attack)"></a>2. 发起自适应攻击 (Adaptive Attack)</h3><p>此接口用于<strong>动态目标</strong>攻击，系统会在每一轮攻击开始前重新计算受害者（例如：总是攻击网络中连接数最多的节点）。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>功能</strong>: 发起自适应攻击，目标由后端实时计算。</p></li><li><p><strong>关键区别</strong>:</p><ol><li><p><strong>不支持</strong> one_shot 模式（因为一次性攻击不需要”自适应”变化）。必须是 repeated 或 continuous。</p></li><li><p>parameters.target_nodes <strong>必须</strong>是特定格式的字符串指令，以 dynamic: 开头。</p></li></ol></li><li><p><strong>目标指令语法</strong>: dynamic:{指标}:{选择策略}</p><ul><li><p>示例: dynamic:degree:top:5 (度中心性最高的前5个)</p></li><li><p>示例: dynamic:betweenness:highest (介数中心性最高的1个)</p></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 场景：持续攻击网络中度中心性最高的前5个节点</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"execution_config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"continuous"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"duration_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"interval_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"strategy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_disconnection"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"firewall_block"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"target_nodes"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dynamic:degree:top:5"</span> <span class="hljs-comment">// 注意这里是字符串</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-前端分流逻辑-Frontend-Logic"><a href="#3-前端分流逻辑-Frontend-Logic" class="headerlink" title="3. 前端分流逻辑 (Frontend Logic)"></a>3. 前端分流逻辑 (Frontend Logic)</h3><p>这是前端 Vue 组件如何决定调用哪个接口的核心逻辑说明。</p><p><strong>Prompt / 逻辑说明:</strong></p><p>前端在点击”发起攻击”按钮时，必须执行以下判断逻辑：</p><ol><li><p><strong>检查目标类型</strong>:</p><ul><li><p>获取用户在表单中输入的目标配置。</p></li><li><p>如果目标是<strong>字符串指令</strong>且以 dynamic: 开头 -&gt; 标记为 isDynamic。</p></li><li><p>如果目标是<strong>手动输入的 IP 列表</strong> -&gt; 标记为 isStatic。</p></li></ul></li><li><p><strong>检查执行模式</strong>:</p><ul><li>获取用户选择的模式 (one_shot, repeated, continuous)。</li></ul></li><li><p><strong>路由决策树</strong>:</p><ul><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode == one_shot):</p><ul><li>❌ <strong>报错</strong>: 自适应攻击不支持一次性模式。</li></ul></li><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode != one_shot):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段发送字符串。</p></li></ul></li><li><p><strong>ELSE</strong> (即静态目标，无论什么模式):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段必须转换为数组 [] 发送。</p></li></ul></li></ul></li></ol><hr><h3 id="4-停止攻击-Stop-Attack"><a href="#4-停止攻击-Stop-Attack" class="headerlink" title="4. 停止攻击 (Stop Attack)"></a>4. 停止攻击 (Stop Attack)</h3><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: DELETE /api/simulations/{attack_id}</p></li><li><p><strong>功能</strong>: 立即终止一个正在运行 (running) 或挂起 (pending) 的攻击任务。</p></li><li><p><strong>适用场景</strong>:</p><ul><li><p>用户点击”紧急停止”按钮。</p></li><li><p>用于中断 continuous (无限持续) 类型的攻击。</p></li><li><p>用于中断剩余轮次尚未执行的 repeated 攻击。</p></li></ul></li><li><p><strong>后端行为</strong>:</p><ul><li><p>取消对应的 asyncio.Task。</p></li><li><p>执行清理逻辑（如恢复防火墙规则、删除垃圾文件）。</p></li><li><p>将数据库中的状态更新为 stopped。</p></li></ul></li></ul><hr><h3 id="5-状态轮询与监控-Monitoring"><a href="#5-状态轮询与监控-Monitoring" class="headerlink" title="5. 状态轮询与监控 (Monitoring)"></a>5. 状态轮询与监控 (Monitoring)</h3><p><strong>Prompt / 接口说明:</strong></p><p>为了在前端展示”实时状态”和”系统日志”，需要配合使用以下两个接口：</p><ol><li><p><strong>获取活跃列表</strong>: GET /api/simulations/active</p><ul><li><p><strong>用途</strong>: 判断当前是否有攻击在跑 (isRunning 状态)。</p></li><li><p><strong>频率</strong>: 建议每 3-5 秒轮询一次。</p></li><li><p><strong>返回</strong>: 包含 progress (进度百分比) 和 current_round (当前轮次)。</p></li></ul></li><li><p><strong>获取详情/日志</strong>: GET /api/simulations/{attack_id}</p><ul><li><p><strong>用途</strong>: 获取特定攻击的详细日志流。</p></li><li><p><strong>返回</strong>: 包含 logs 数组 ([“Attack started”, “Round 1 finished”])。</p></li><li><p><strong>前端展示</strong>: 将 logs 渲染到控制台面板中。</p></li></ul></li></ol><hr><h3 id="总结：数据结构对照表-Type-Mapping"><a href="#总结：数据结构对照表-Type-Mapping" class="headerlink" title="总结：数据结构对照表 (Type Mapping)"></a>总结：数据结构对照表 (Type Mapping)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>参数字段</td><td>描述</td><td>类型限制</td></tr><tr><td><strong>execution_config</strong></td><td></td><td></td></tr><tr><td>mode</td><td>执行模式</td><td>“one_shot” \</td><td>“repeated” \</td><td>“continuous”</td></tr><tr><td>duration_seconds</td><td>单次持续时长</td><td>Integer (秒)</td></tr><tr><td>interval_seconds</td><td>轮次间隔</td><td>Integer (秒), 仅 repeated/continuous 有效</td></tr><tr><td>repeat_count</td><td>重复次数</td><td>Integer, 仅 repeated 有效</td></tr><tr><td><strong>parameters</strong></td><td></td><td></td></tr><tr><td>strategy</td><td>攻击策略</td><td>“node_disconnection” \</td><td>“storage_attack” …</td></tr><tr><td>target_nodes</td><td>攻击目标</td><td>Array [str] (普通) <strong>OR</strong> String dynamic:… (自适应)</td></tr><tr><td>method</td><td>具体手段</td><td>依赖于 strategy (如 firewall_block, disk_fill)</td></tr><tr><td>…</td><td>其他参数</td><td>依赖于 strategy (如 size_mb, intensity)</td></tr></tbody></table></div><hr><h3 id="1-全局枚举定义-Global-Enums"><a href="#1-全局枚举定义-Global-Enums" class="headerlink" title="1. 全局枚举定义 (Global Enums)"></a>1. 全局枚举定义 (Global Enums)</h3><p>这些枚举值用于填充请求体中的特定字段。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>枚举类型</td><td>字段名</td><td>可选值 (Value)</td><td>说明</td></tr><tr><td><strong>执行模式</strong></td><td>mode</td><td>one_shot</td><td><strong>一次性</strong>：执行一次，持续指定时间后恢复。</td></tr><tr><td></td><td></td><td>repeated</td><td><strong>重复执行</strong>：按间隔重复执行多次。</td></tr><tr><td></td><td></td><td>continuous</td><td><strong>持续执行</strong>：按间隔无限执行，直到手动停止。</td></tr><tr><td><strong>攻击策略</strong></td><td>strategy</td><td>node_disconnection</td><td>节点断连攻击</td></tr><tr><td></td><td></td><td>communication_interference</td><td>通信干扰攻击</td></tr><tr><td></td><td></td><td>storage_attack</td><td>存储耗尽攻击</td></tr><tr><td></td><td></td><td>timestamp_attack</td><td>时间/NTP攻击</td></tr><tr><td></td><td></td><td>simplified_sybil_attack</td><td>简化版女巫攻击</td></tr><tr><td></td><td></td><td>geth_lighthouse_attack</td><td>客户端特定攻击 (Geth/Lighthouse)</td></tr></tbody></table></div><hr><h3 id="2-执行配置-execution-config"><a href="#2-执行配置-execution-config" class="headerlink" title="2. 执行配置 (execution_config)"></a>2. 执行配置 (execution_config)</h3><p>根据 mode 的不同，所需字段不同。<strong>注意：自适应攻击接口 (/simulate/adaptive) 不支持 one_shot。</strong></p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>模式 (Mode)</td><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>约束/说明</td></tr><tr><td><strong>通用</strong></td><td>duration_seconds</td><td>Int</td><td>✅</td><td>30</td><td>攻击生效持续时间 (秒)，&gt;=1</td></tr><tr><td><strong>Repeated</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr><tr><td>(重复)</td><td>repeat_count</td><td>Int</td><td>✅</td><td>-</td><td>重复执行的总轮数，&gt;=1</td></tr><tr><td><strong>Continuous</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr></tbody></table></div><hr><h3 id="3-策略参数详情-parameters"><a href="#3-策略参数详情-parameters" class="headerlink" title="3. 策略参数详情 (parameters)"></a>3. 策略参数详情 (parameters)</h3><p>此部分为多态结构，根据 strategy 字段的值，JSON 结构发生变化。</p><h4 id="3-1-节点断连-node-disconnection"><a href="#3-1-节点断连-node-disconnection" class="headerlink" title="3.1 节点断连 (node_disconnection)"></a>3.1 节点断连 (node_disconnection)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>interface_down (网卡下线), route_flush (清空路由), firewall_block (防火墙), p2p_block (P2P阻断)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令 (见第4节)</td></tr></tbody></table></div><h4 id="3-2-通信干扰-communication-interference"><a href="#3-2-通信干扰-communication-interference" class="headerlink" title="3.2 通信干扰 (communication_interference)"></a>3.2 通信干扰 (communication_interference)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>json_rpc_flood (RPC泛洪), p2p_flood (P2P泛洪), memory_exhaustion (内存耗尽)</td></tr><tr><td>intensity</td><td>String</td><td>❌</td><td>medium</td><td>low, medium, high, extreme</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h4 id="3-3-存储攻击-storage-attack"><a href="#3-3-存储攻击-storage-attack" class="headerlink" title="3.3 存储攻击 (storage_attack)"></a>3.3 存储攻击 (storage_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>disk_fill (填充), database_corruption (脏数据), state_pollution (状态污染), chain_data_spam (链上垃圾)</td></tr><tr><td>size_mb</td><td>Int</td><td>❌</td><td>1000</td><td>填充大小 (MB)，100 - 10000</td></tr><tr><td>file_count</td><td>Int</td><td>❌</td><td>100</td><td>生成文件数量，10 - 1000</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-4-时间攻击-timestamp-attack"><a href="#3-4-时间攻击-timestamp-attack" class="headerlink" title="3.4 时间攻击 (timestamp_attack)"></a>3.4 时间攻击 (timestamp_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>time_shift (平移), ntp_block (NTP阻断), time_drift (漂移)</td></tr><tr><td>time_shift</td><td>String</td><td>❌</td><td>+1 hour</td><td>偏移量 (如 +1 hour, -30 minutes)，仅 time_shift 方法有效</td></tr><tr><td>drift_seconds</td><td>Int</td><td>❌</td><td>3600</td><td>漂移秒数，-86400 到 86400，仅 time_drift 方法有效</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-5-女巫攻击-simplified-sybil-attack"><a href="#3-5-女巫攻击-simplified-sybil-attack" class="headerlink" title="3.5 女巫攻击 (simplified_sybil_attack)"></a>3.5 女巫攻击 (simplified_sybil_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>fake_node_count</td><td>Int</td><td>❌</td><td>5</td><td>虚假节点数量 (1-20)</td></tr><tr><td>node_type</td><td>String</td><td>❌</td><td>light</td><td>light (轻节点), full (全节点), validator (验证者)</td></tr><tr><td>network</td><td>String</td><td>❌</td><td>testnet</td><td>mainnet, testnet, devnet</td></tr><tr><td>connect_to_real</td><td>Bool</td><td>❌</td><td>True</td><td>是否连接真实节点</td></tr><tr><td>min_connections</td><td>Int</td><td>❌</td><td>3</td><td>最小连接数 (0-10)</td></tr><tr><td>target_nodes</td><td>-</td><td>-</td><td>-</td><td><strong>注意：此策略通常不需要指定具体目标节点</strong></td></tr></tbody></table></div><h4 id="3-6-客户端攻击-geth-lighthouse-attack"><a href="#3-6-客户端攻击-geth-lighthouse-attack" class="headerlink" title="3.6 客户端攻击 (geth_lighthouse_attack)"></a>3.6 客户端攻击 (geth_lighthouse_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>process_kill, db_corruption, port_blocking, config_modification</td></tr><tr><td>attack_type</td><td>String</td><td>✅</td><td>-</td><td>geth, lighthouse (指定攻击的客户端类型)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><hr><h3 id="4-目标节点配置-target-nodes"><a href="#4-目标节点配置-target-nodes" class="headerlink" title="4. 目标节点配置 (target_nodes)"></a>4. 目标节点配置 (target_nodes)</h3><p>target_nodes 字段在不同接口下有严格的格式要求。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>接口端点</td><td>格式类型</td><td>数据结构示例</td><td>说明</td></tr><tr><td>/api/simulate</td><td><strong>静态列表</strong></td><td>[“192.168.1.10”, “node_id_123”]</td><td>明确指定要攻击的节点列表。</td></tr><tr><td>/api/simulate/adaptive</td><td><strong>动态指令</strong></td><td>“dynamic:degree:top:5”</td><td>字符串格式，后端自动计算目标。</td></tr></tbody></table></div><p><strong>动态指令语法:</strong> dynamic:{指标}:{选择器}</p><ol><li><p><strong>指标 (Metric)</strong>:</p><ul><li><p>degree (度中心性)</p></li><li><p>betweenness (介数中心性)</p></li><li><p>closeness (接近中心性)</p></li><li><p>eigenvector (特征向量中心性)</p></li></ul></li><li><p><strong>选择器 (Selector)</strong>:</p><ul><li><p>highest (选最高的1个)</p></li><li><p>top:N (选前 N 个，N为数字)</p></li></ul></li></ol><hr><h3 id="5-防护配置-defense-enable"><a href="#5-防护配置-defense-enable" class="headerlink" title="5. 防护配置 (/defense/enable)"></a>5. 防护配置 (/defense/enable)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>示例</td><td>说明</td></tr><tr><td>enabled</td><td>Bool</td><td>❌</td><td>true</td><td>是否启用防护</td></tr><tr><td>rules</td><td>Object</td><td>✅</td><td>{“rate_limit”: 100}</td><td>防护规则字典，具体Key由后端逻辑决定</td></tr></tbody></table></div><hr><h3 id="6-响应结构概览"><a href="#6-响应结构概览" class="headerlink" title="6. 响应结构概览"></a>6. 响应结构概览</h3><p>所有接口通常遵循统一的响应格式：</p><p>codeJSON</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">{<br>  <span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>,  <span class="hljs-string">//</span> 或 <span class="hljs-string">"error"</span><br>  <span class="hljs-string">"message"</span>: <span class="hljs-string">"操作描述"</span>,<br>  <span class="hljs-string">"data"</span>: { <span class="hljs-string">...</span> }       <span class="hljs-string">//</span> 具体业务数据<br>}<br></code></pre></td></tr></table></figure><p><strong>关键数据字段 (data)</strong>:</p><ul><li><p>attack_id: (String) 攻击任务的唯一标识符。</p></li><li><p>status: (Enum) pending, running, completed, failed, stopped, cancelled。</p></li><li><p>logs: (Array[Str]) 攻击日志列表。</p></li></ul><p>{<br>  “nodes”: [<br>    {<br>      “id”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”,<br>      “name”: “Tether USD (USDT)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 5<br>    },<br>    {<br>      “id”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”,<br>      “name”: “USD Coin (USDC)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 3<br>    },<br>    {<br>      “id”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”,<br>      “name”: “Uniswap V3: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 8<br>    },<br>    {<br>      “id”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”,<br>      “name”: “Uniswap V3: SwapRouter02”,<br>      “type”: “SwapRouter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 6<br>    },<br>    {<br>      “id”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”,<br>      “name”: “Uniswap V3: Quoter”,<br>      “type”: “Quoter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”,<br>      “name”: “Uniswap V2: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 7<br>    },<br>    {<br>      “id”: “0x881D40237659C251811CEC9c364ef91dC08D300C”,<br>      “name”: “Curve: 3pool Controller”,<br>      “type”: “CurvePool”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”,<br>      “name”: “Curve: 3pool Gauge”,<br>      “type”: “Gauge”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 2<br>    }<br>  ],<br>  “links”: [<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “type”: “transfer_approve” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap_out” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “type”: “swap_in” },<br>    { “source”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “target”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “type”: “call” },<br>    { “source”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “target”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”, “type”: “quote” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “type”: “approve” },<br>    { “source”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “type”: “deposit” },<br>    { “source”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “target”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”, “type”: “stake” }<br>  ],<br>  “timestamp”: 1765095677.891234,<br>  “data_source”: “real_web3”,<br>  “topology_type”: “contract”<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[ETH前端] --&gt; B[src]<br>    A --&gt; C[package.json]<br>    A --&gt; D[index.html]<br>    A --&gt; E[vite.config.ts]<br>    A --&gt; F[README.md]<br>    A --&gt; G[public]<br>    <br>    B --&gt; H[__tests__]<br>    B --&gt; I[api]<br>    B --&gt; J[assets]<br>    B --&gt; K[components]<br>    B --&gt; L[composables]<br>    B --&gt; M[router]<br>    B --&gt; N[services]<br>    B --&gt; O[types]<br>    B --&gt; P[utils]<br>    B --&gt; Q[views]<br>    B --&gt; R[App.vue]<br>    B --&gt; S[main.ts]<br>    <br>    I --&gt; T[api_docs]<br>    I --&gt; U[attack]<br>    <br>    J --&gt; V[styles]<br>    V --&gt; W[global.css]<br>    V --&gt; X[tailwind.css]<br>    <br>    K --&gt; Y[blockchain]<br>    K --&gt; Z[common]<br>    K --&gt; AA[layout]<br>    K --&gt; AB[tabs]<br>    K --&gt; AC[topology]<br>    <br>    Y --&gt; AD[BlockchainCanvas.vue]<br>    Y --&gt; AE[BlockchainInfoPanel.vue]<br>    Y --&gt; AF[BlockchainModal.vue]<br>    Y --&gt; AG[BlockchainVisualization.vue]<br>    Y --&gt; AH[composables]<br>    Y --&gt; AI[types]<br>    <br>    AH --&gt; AJ[useBlockchainAPI.ts]<br>    AH --&gt; AK[useBlockchainAnimations.ts]<br>    AH --&gt; AL[useBlockchainData.ts]<br>    AH --&gt; AM[useBlockchainEvents.ts]<br>    AH --&gt; AN[useBlockchainRenderer.ts]<br>    AH --&gt; AO[useBlockchainScrolling.ts]<br>    <br>    Z --&gt; AP[ContainerTerminal.vue]<br>    Z --&gt; AQ[DEP-TERM.vue]<br>    Z --&gt; AR[StandaloneTerminal.vue]<br>    Z --&gt; AS[Terminal.vue]<br>    Z --&gt; AT[websocket_terminal8080.vue]<br>    <br>    AA --&gt; AU[DashboardHeader.vue]<br>    AA --&gt; AV[LeftPanel.vue]<br>    AA --&gt; AW[PanelSplitter.vue]<br>    AA --&gt; AX[RightPanel.vue]<br>    <br>    AB --&gt; AY[AttackMonitoringTab.vue]<br>    AB --&gt; AZ[Attack_sys]<br>    AB --&gt; BA[BlockchainBrowserTab.css]<br>    AB --&gt; BB[BlockchainBrowserTab.vue]<br>    AB --&gt; BC[ContainerListTab.vue]<br>    AB --&gt; BD[NetworkTopologyTab.vue]<br>    AB --&gt; BE[sections]<br>    AB --&gt; BF[tabstyle.css]<br>    <br>    AZ --&gt; BG[AttackSystemTab.vue]<br>    BE --&gt; BH[Network-analysis.vue]<br>    BE --&gt; BI[NodeInfoPanel.vue]<br>    BE --&gt; BJ[RealTimeMonitoring.vue]<br>    <br>    AC --&gt; BK[ContractTopology.vue]<br>    AC --&gt; BL[Ethereum_Topology]<br>    AC --&gt; BM[Physical_Topology]<br>    AC --&gt; BN[TopologyVisualization.vue]<br>    AC --&gt; BO[TransactionTopology.vue]<br>    AC --&gt; BP[composables]<br>    AC --&gt; BQ[types]<br>    <br>    BL --&gt; BR[types]<br>    BL --&gt; BS[workers]<br>    BL --&gt; BT[EthereumTopology_new.vue]<br>    BL --&gt; BU[useD3Renderer.ts]<br>    BL --&gt; BV[use_topology_core.ts]<br>    BL --&gt; BW[use_topology_visuals.ts]<br>    <br>    BM --&gt; BX[composables]<br>    BM --&gt; BY[PhysicalTopology.vue]<br>    <br>    BP --&gt; BZ[index.ts]<br>    BP --&gt; CA[topology.css]<br>    BP --&gt; CB[useTopologyAPI.ts]<br>    BP --&gt; CC[useTopologyData.ts]<br>    BP --&gt; CD[useTopologyRendererBase.ts]<br>    <br>    L --&gt; CE[useDashboardData.ts]<br>    L --&gt; CF[useDashboardLayout.ts]<br>    L --&gt; CG[useDashboardTabs.ts]<br>    <br>    M --&gt; CH[index.ts]<br>    <br>    N --&gt; CI[analysis.ts]<br>    N --&gt; CJ[api.ts]<br>    N --&gt; CK[apiService.ts]<br>    N --&gt; CL[attack.ts]<br>    N --&gt; CM[blockchain.ts]<br>    N --&gt; CN[daily-operations.ts]<br>    N --&gt; CO[device-monitoring.ts]<br>    N --&gt; CP[execution.ts]<br>    N --&gt; CQ[foundation.ts]<br>    N --&gt; CR[monitoring.ts]<br>    N --&gt; CS[readme.md]<br>    N --&gt; CT[root-api.ts]<br>    N --&gt; CU[security.ts]<br>    N --&gt; CV[temporal.ts]<br>    N --&gt; CW[topology.ts]<br>    <br>    O --&gt; CX[topology.ts]<br>    <br>    P --&gt; CY[http.ts]<br>    P --&gt; CZ[index.ts]<br>    P --&gt; DA[types.ts]<br>    <br>    Q --&gt; DB[BlockchainTest.vue]<br>    Q --&gt; DC[Dashboard.vue]<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;性能优化 (Web Workers)&lt;/strong&gt;: 目前的数据获取、解析和Diff算法都在&lt;strong&gt;主线程&lt;/strong&gt;运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 &lt;strong&gt;Web Worker&lt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-05-字节工训营画布项目相关设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/17798.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/17798.html</id>
    <published>2025-12-04T18:00:16.000Z</published>
    <updated>2025-12-25T03:23:33.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BDdraw-DEV"><a href="#BDdraw-DEV" class="headerlink" title="BDdraw_DEV"></a>BDdraw_DEV</h1><p>代码仓库：<br><a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>现代协同 2D 画布编辑器 · React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8</p><h4 id="技术栈-·-Tech-Stack"><a href="#技术栈-·-Tech-Stack" class="headerlink" title="技术栈 · Tech Stack"></a>技术栈 · Tech Stack</h4><p class='item-img' data-src='https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white'><img src="https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white" alt="React 18"> <img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5" class='item-img' data-src='https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white'><img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5"> <img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6" class='item-img' data-src='https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white'><img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6"> <img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate" class='item-img' data-src='https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4'><img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate"> <img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design" class='item-img' data-src='https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white'><img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design"> <img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide" class='item-img' data-src='https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white'><img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide"> <img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer" class='item-img' data-src='https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white'><img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer"> <img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8" class='item-img' data-src='https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white'><img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8"> <img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3" class='item-img' data-src='https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white'><img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3"> <img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12" class='item-img' data-src='https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white'><img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12"> <img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid" class='item-img' data-src='https://img.shields.io/badge/nanoid-5.1.6-000000'><img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid"> <img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint" class='item-img' data-src='https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white'><img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint"> <img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky" class='item-img' data-src='https://img.shields.io/badge/Husky-8.0.3-7711A4'><img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky"> <img src="https://img.shields.io/badge/Deploy-GitHub_Pages-222222?logo=githubpages&logoColor=white" alt="GitHub Pages"></p><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p><strong>frontend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:Zhongye1/BDdraw_DEV.git<br><br><span class="hljs-built_in">cd</span> BDdraw_DEV (进入项目)<br>bun install (安装依赖包)<br>bun start (启动服务)<br></code></pre></td></tr></table></figure><p><strong>backend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> BDdraw_DEV/ALD_Backend/<br>bun install <span class="hljs-comment">#安装依赖</span><br>bun index.ts  <span class="hljs-comment">#启动后端服务</span><br></code></pre></td></tr></table></figure><p>推荐使用 bun 包管理器，见个人博客</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/15722.html">关于包管理器 npm,pnpm,yarn 和 bun 以及我为何选择后者</a></p><h4 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h4><p>项目支持通过 Docker 进行容器化部署，使用 Node 22 和 Bun 包管理器。</p><p><strong>开发环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><strong>生产环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -f docker-compose.prod.yml up -d<br></code></pre></td></tr></table></figure><p>部署完成后，可以通过以下地址访问：</p><ul><li>前端应用: <a href="http://localhost:5000/BDdraw_DEV/">http://localhost:5000/BDdraw_DEV/</a></li><li>后端 API 文档: <a href="http://localhost:3000/swagger-ui">http://localhost:3000/swagger-ui</a></li></ul><h4 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h4><p>项目采用了模块化的架构设计，将不同的功能划分为独立的模块，以方便后续维护和扩展</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>60 FPS 渲染（得益于 PixiJS WebGL）</li><li>完整撤销/重做（Command Pattern + 防抖快照）</li><li>多元素选择与群组操作</li><li>画布元素变换控制器</li><li>富文本所见即所得编辑（WanngEditor + PIXI.HTMLText）</li><li>图片插入 + 内置滤镜（模糊、亮度、灰度等）</li><li>插件式元素系统</li><li>插件式元素系统</li><li>完整的 TypeScript 类型支持</li><li>现代开发体验（Vite + ESLint + Prettier + Husky）</li><li>集成 GitHub-Actions 支持， 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</li></ul><hr><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>这时候需要简单做一个技术选型分析，根据任务拆解，选择了如下技术栈</p><p><strong>【框架】</strong>【技术方案：采用 React 18 + TypeScript 5 构建应用，React 提供完整的 UI 生态，TypeScript 提供更清晰可靠的类型安全，相比 JavaScript 更易于维护】</p><p><strong>【构建工具】</strong>【技术方案：使用 Vite 5 作为构建工具，其开发服务器启动和热模块替换（HMR）速度明显快于 Webpack】</p><p><strong>【路由】</strong>【技术方案：采用 React Router DOM 6 实现路由管理，API 稳定且文档完善】</p><p><strong>【样式】</strong>【技术方案：使用 Tailwind CSS 3 + PostCSS 处理样式，开发时编写样式更快，生产环境会自动进行 tree-shaking 优化，相比 CSS Modules 和 styled-components 更高效且原子化更直观，对 AI 工具友好】</p><p><strong>【样式扩展】</strong>【技术方案：少量使用 Less 覆盖 Tailwind 主题变量，保持兼容性】</p><p><strong>【SVG 处理】</strong>【技术方案：使用 SVGR 1.5 处理 SVG，Vite 原生支持，可以将 SVG 作为 React 组件使用，比直接使用 SVG 或 SVG sprite 更灵活】</p><p><strong>【UI 组件库】</strong>【技术方案：采用 shadcn/ui（latest）和 Arco Design 2 实现 UI 组件，易于使用，符合字节项目使用字节组件库的习惯】</p><p><strong>【全局状态】</strong>【技术方案：采用 Zustand 4 管理全局状态，API 简洁、性能良好且无样板代码，相比 Redux Toolkit、Pinia、Jotai 代码量更少且配有 Devtools】</p><p><strong>【图形/画布】</strong>【技术方案：使用 PixiJS 8 + pixi-viewport 实现图形和画布功能，基于 WebGL 渲染，适合处理大量精灵元素，相比其他可选方案性能更高】</p><p><strong>【富文本编辑器】</strong>【技术方案：采用 WangEditor 5 作为富文本编辑器，轻量且文档和社区均为中文，相比 Slate/TipTap 等编辑器，默认输出的 HTML 可直接给 PixiJS HTMLText 进行渲染】</p><p><strong>【图标】</strong>【技术方案：使用 Lucide React 图标库，图标数量多、风格统一且支持 Tree-shaking】</p><p><strong>【工具库】</strong>【技术方案：采用 nanoid 3 为画布元素生成唯一标识符等操作，轻量实用】</p><p><strong>【代码质量】</strong>【技术方案：使用 ESLint + Stylelint + Prettier + Husky + lint-staged + commitlint 保证团队代码风格一致，这是中大型项目的基本配置，有利于多人协作开发】</p><p>此外，还配置了 react 开发者工具 react-dev-inspector，配置了一下，开发环境下 ctrl+q 可以实现点击页面上的组件，在 VSCode 中自动跳转到对应文件，并定位到对应行号，方便调试（先前写 vue 也用过类似的）</p><p>项目 <a href="https://react-dev-inspector.zthxxx.me/docs">https://react-dev-inspector.zthxxx.me/docs</a></p><h3 id="功能要素和方案"><a href="#功能要素和方案" class="headerlink" title="功能要素和方案"></a>功能要素和方案</h3><p>分析以上需求，查阅相关资料后，进行各个核心模块的技术方案选型，确定初步实现方案</p><p><strong>【基础渲染引擎】</strong>【技术方案：PixiJS v8（WebGL）提供高性能 2D 渲染，根据不同元素类型创建对应的 Pixi 对象（图形、文本、图像），通过 pixi-viewport 实现无限画布的视口控制，支持缩放、拖拽等交互】</p><p><strong>【无限画布视口】</strong>【技术方案：pixi-viewport（内置 zoom、drag、decelerate、clampZoom）库创建无限画布，在 StageManagerCore.ts 中初始化 viewport，并添加拖拽、缩放等交互功能，支持鼠标中键拖拽画布、滚轮缩放等常见操作】</p><p><strong>【富文本编辑】</strong>【技术方案：WangEditor 5 作为富文本编辑器，提供完整的文本编辑功能，编辑结果以 HTML 格式存储在元素的 text/string 属性中，元素使用 PixiJS 内置的 HTMLText 进行渲染实现富文本效果】</p><p><strong>【状态管理与数据结构】</strong>【技术方案：Zustand 作为全局状态管理库，通过 structuredClone 函数手动创建状态快照，管理画布元素、选中状态、工具类型等，通过中间件监听状态变化并触发重渲染，在特定的 ts 中定义所有状态和操作方法】</p><p><strong>【图片上传显示与滤镜】</strong>【技术方案：PixiJS 内置 Filter 系统包括 BlurFilter、ColorMatrixFilter（黑白、对比度、饱和度）实现图像处理效果，支持模糊、亮度调整、灰度等多种滤镜效果，在 ElementRenderer.ts 中根据元素的 filter 属性应用相应滤镜，支持 blur（模糊）、brightness（亮度）、grayscale（灰度）等滤镜类型】</p><p><strong>【选中与变换系统】</strong>【技术方案：SelectionManager + TransformOverlay（8 个把手 + 旋转把手）实现变换控件渲染，支持单个元素选中和多个元素群组选中，提供 8 个控制点和 1 个旋转点进行变换操作，根据不同元素类型提供不同的控制方式】</p><p><strong>【旋转与组合嵌套】</strong>【技术方案：每个元素维护自己的 matrix（局部矩阵），组合后父容器统一应用矩阵变换，支持多层级嵌套和复杂变换】</p><p><strong>【Minimap】</strong>【技术方案：单独一个小的 Pixi.Application（共享 texture 缓存）实现缩略图功能，主画布所有容器使用 cacheAsBitmap 后生成低分辨率 texture，实时更新到小画布，视口框用一个半透明矩形表示在主画布中的位置】</p><p><strong>【元素永久缓存】</strong>【技术方案：使用 spriteMap 来存储 PIXI 对象，元素更新时只修改属性并设置 container.dirty = true，而不是销毁重建，来解决拖拽中断、光标丢失、闪烁等问题】</p><p><strong>【辅助对齐线】</strong>【技术方案：拖拽时实时遍历所有元素 bounds，计算对齐情况（水平/垂直/间距相等），差值&lt;6px 就吸附并画蓝线，支持水平、垂直对齐以及等间距对齐等多种对齐方式，当距离小于阈值时自动吸附并对齐】</p><p><strong>【Undo/Redo】</strong>【技术方案：Command Pattern + structuredClone 完整快照（每步 before/after）实现撤销/重做功能，通过管理命令栈（undo，redo 栈），使用 structuredClone 创建状态快照，记录操作前后的完整状态，来支持添加元素、删除元素、修改元素属性等操作的撤销/重做，针对拖拽和调整大小操作的命令生成逻辑可能还要具体再处理一套】</p><p><strong>【数据持久化与离线】</strong>【技术方案：Zustand-persist + localForage（IndexedDB）实现数据持久化和离线使用，使用 Zustand 的持久化中间件保存状态，通过 localForage 将数据存储到 IndexedDB 中，实现数据的自动保存和恢复功能】</p><p><strong>【实时协同】</strong>【技术方案：Y.js + y-websocket（或自己写 CRDT）+ Operation Transform 合并策略实现无冲突的实时协同编辑，通过 y-websocket 插件实现服务端同步（问的 AI），有个思路是把操作打给时间 tag，然后然后按时间合并】</p><hr><h4 id="项目架构树"><a href="#项目架构树" class="headerlink" title="项目架构树"></a>项目架构树</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs sh">BDdraw_DEV/<br>├── ALD_Backend/                    <span class="hljs-comment"># 后端服务目录</span><br>│   ├── src/                        <span class="hljs-comment"># 后端源代码</span><br>│   │   ├── api/                    <span class="hljs-comment"># API接口目录</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关API</span><br>│   │   │   │   ├── types/          <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   │   ├── CORE.ts         <span class="hljs-comment"># 核心房间管理逻辑</span><br>│   │   │   │   ├── Room_CRUD.ts    <span class="hljs-comment"># 房间增删改查操作实现</span><br>│   │   │   │   ├── Room_List.ts    <span class="hljs-comment"># 房间列表管理实现</span><br>│   │   │   │   └── Room_users.ts   <span class="hljs-comment"># 房间用户管理实现</span><br>│   │   │   ├── USER_management/    <span class="hljs-comment"># 用户管理相关API</span><br>│   │   │   │   ├── auth_API.ts     <span class="hljs-comment"># 用户认证API实现</span><br>│   │   │   │   └── auth_API_types.ts  <span class="hljs-comment"># 用户认证类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API索引文件</span><br>│   │   ├── auth.ts                 <span class="hljs-comment"># 认证模块实现</span><br>│   │   ├── collab.ts               <span class="hljs-comment"># 协作功能模块实现</span><br>│   │   └── db.ts                   <span class="hljs-comment"># 数据库连接和操作实现</span><br>│   ├── ARCHITECTURE.md             <span class="hljs-comment"># 后端架构说明文档</span><br>│   ├── README.md                   <span class="hljs-comment"># 后端说明文档</span><br>│   ├── index.ts                    <span class="hljs-comment"># 后端服务入口文件</span><br>│   ├── package.json                <span class="hljs-comment"># 后端依赖配置文件</span><br>│   └── tsconfig.json               <span class="hljs-comment"># 后端TypeScript配置</span><br>├── src/                            <span class="hljs-comment"># 前端源代码目录</span><br>│   ├── api/                        <span class="hljs-comment"># 前端API客户端</span><br>│   │   ├── types/                  <span class="hljs-comment"># API类型定义</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   ├── auth_API_types.ts   <span class="hljs-comment"># 认证相关类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API类型索引文件</span><br>│   │   ├── utils/                  <span class="hljs-comment"># API工具函数</span><br>│   │   │   └── apiClient.ts        <span class="hljs-comment"># API客户端工具</span><br>│   │   ├── apiService.ts           <span class="hljs-comment"># API服务封装实现</span><br>│   │   └── index.ts                <span class="hljs-comment"># API索引文件</span><br>│   ├── components/                 <span class="hljs-comment"># React组件目录</span><br>│   │   ├── Richtext_editor/        <span class="hljs-comment"># 富文本编辑器组件</span><br>│   │   │   ├── BottomTextEditor.tsx    <span class="hljs-comment"># 底部文本编辑器实现</span><br>│   │   │   └── Richtext_editor.tsx     <span class="hljs-comment"># 富文本编辑器主组件</span><br>│   │   ├── canvas_toolbar/         <span class="hljs-comment"># 画布工具栏组件</span><br>│   │   │   ├── ContextMenu.tsx     <span class="hljs-comment"># 上下文菜单实现</span><br>│   │   │   └── TopToolbar.tsx      <span class="hljs-comment"># 顶部工具栏实现</span><br>│   │   ├── collaboration/          <span class="hljs-comment"># 协作功能组件</span><br>│   │   │   ├── CollaboratorCursors.tsx <span class="hljs-comment"># 协作者光标显示组件</span><br>│   │   │   └── RemoteSelectionLayer.tsx <span class="hljs-comment"># 远程选择层组件</span><br>│   │   ├── error-page/             <span class="hljs-comment"># 错误页面组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 错误页面实现</span><br>│   │   ├── header/                 <span class="hljs-comment"># 页面头部组件</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 头部内容组件</span><br>│   │   │   │   ├── ExportCanvasModal.tsx   <span class="hljs-comment"># 导出画布模态框</span><br>│   │   │   │   └── StageManagerContext.tsx <span class="hljs-comment"># 舞台管理上下文</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 头部组件入口</span><br>│   │   ├── image-insert-modal/     <span class="hljs-comment"># 图片插入模态框组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 图片插入模态框实现</span><br>│   │   ├── layout/                 <span class="hljs-comment"># 布局组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 布局组件实现</span><br>│   │   ├── minimap/                <span class="hljs-comment"># 小地图组件</span><br>│   │   │   └── Minimap.tsx         <span class="hljs-comment"># 小地图实现</span><br>│   │   ├── property-panel/         <span class="hljs-comment"># 属性面板组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 属性面板实现</span><br>│   │   ├── settings/               <span class="hljs-comment"># 设置组件</span><br>│   │   │   └── setting.tsx         <span class="hljs-comment"># 设置组件实现</span><br>│   │   ├── ui/                     <span class="hljs-comment"># 基础UI组件</span><br>│   │   │   ├── blackwhitebutton.tsx    <span class="hljs-comment"># 黑白按钮组件</span><br>│   │   │   ├── button.tsx          <span class="hljs-comment"># 按钮组件</span><br>│   │   │   ├── icon-circle.tsx     <span class="hljs-comment"># 圆形图标组件</span><br>│   │   │   ├── icon-clear.tsx      <span class="hljs-comment"># 清除图标组件</span><br>│   │   │   ├── icon-rect.tsx       <span class="hljs-comment"># 矩形图标组件</span><br>│   │   │   ├── icon-select.tsx     <span class="hljs-comment"># 选择图标组件</span><br>│   │   │   └── icon-triangle.tsx   <span class="hljs-comment"># 三角形图标组件</span><br>│   │   ├── AnimatedRoutes.tsx      <span class="hljs-comment"># 动画路由组件</span><br>│   │   ├── ParallaxBackground.tsx  <span class="hljs-comment"># 视差背景组件</span><br>│   │   └── WipeTransition.tsx      <span class="hljs-comment"># 擦除过渡动画组件</span><br>│   ├── hooks/                      <span class="hljs-comment"># 自定义React Hooks</span><br>│   │   ├── use-localstorage-state.ts   <span class="hljs-comment"># localStorage状态管理Hook</span><br>│   │   └── use_React_hotkeys_management.ts <span class="hljs-comment"># 快捷键管理Hook</span><br>│   ├── lib/                        <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   │   ├── AddElementCommand.ts    <span class="hljs-comment"># 添加元素命令实现</span><br>│   │   ├── RemoveElementCommand.ts <span class="hljs-comment"># 删除元素命令实现</span><br>│   │   ├── UndoRedoManager.ts      <span class="hljs-comment"># 撤销重做管理器实现</span><br>│   │   ├── UpdateElementCommand.ts <span class="hljs-comment"># 更新元素命令实现</span><br>│   │   ├── UpdateElementPropertyCommand.ts <span class="hljs-comment"># 更新元素属性命令实现</span><br>│   │   ├── constants.ts            <span class="hljs-comment"># 常量定义文件</span><br>│   │   ├── env.ts                  <span class="hljs-comment"># 环境变量配置</span><br>│   │   ├── minimapUtils.ts         <span class="hljs-comment"># 小地图工具函数</span><br>│   │   └── utils.ts                <span class="hljs-comment"># 通用工具函数</span><br>│   ├── pages/                      <span class="hljs-comment"># 页面组件目录</span><br>│   │   ├── auth/                   <span class="hljs-comment"># 认证相关页面</span><br>│   │   │   ├── Login.tsx           <span class="hljs-comment"># 登录页面实现</span><br>│   │   │   └── Register.tsx        <span class="hljs-comment"># 注册页面实现</span><br>│   │   ├── canvas/                 <span class="hljs-comment"># 画布主页面</span><br>│   │   │   ├── Pixi_STM_modules/   <span class="hljs-comment"># Pixi.js状态管理模块</span><br>│   │   │   │   ├── core/           <span class="hljs-comment"># 核心类和初始化逻辑</span><br>│   │   │   │   │   ├── Core_StageManager.ts    <span class="hljs-comment"># 核心舞台管理器</span><br>│   │   │   │   │   ├── ElementRender.ts        <span class="hljs-comment"># 元素渲染器</span><br>│   │   │   │   │   ├── TF_controler_Renderer.ts <span class="hljs-comment"># 变换控制器渲染器</span><br>│   │   │   │   │   └── types.ts                <span class="hljs-comment"># 核心类型定义</span><br>│   │   │   │   ├── interaction/    <span class="hljs-comment"># 交互处理模块</span><br>│   │   │   │   │   ├── Base_InteractionHandler.ts   <span class="hljs-comment"># 基础交互处理器</span><br>│   │   │   │   │   └── Stage_InteractionHandler.ts  <span class="hljs-comment"># 舞台交互处理器</span><br>│   │   │   │   ├── shared/         <span class="hljs-comment"># 共享类型定义</span><br>│   │   │   │   │   └── types.ts    <span class="hljs-comment"># 共享类型定义文件</span><br>│   │   │   │   ├── utils/          <span class="hljs-comment"># 工具函数目录</span><br>│   │   │   │   │   ├── commandUtils.ts      <span class="hljs-comment"># 命令工具函数</span><br>│   │   │   │   │   ├── cursorUtils.ts       <span class="hljs-comment"># 光标工具函数</span><br>│   │   │   │   │   ├── destroyUtils.ts      <span class="hljs-comment"># 销毁工具函数</span><br>│   │   │   │   │   ├── dragUtils.ts         <span class="hljs-comment"># 拖拽工具函数</span><br>│   │   │   │   │   ├── drawingUtils.ts      <span class="hljs-comment"># 绘图工具函数</span><br>│   │   │   │   │   ├── eraserUtils.ts       <span class="hljs-comment"># 橡皮擦工具函数</span><br>│   │   │   │   │   ├── geometryUtils.ts     <span class="hljs-comment"># 几何工具函数</span><br>│   │   │   │   │   ├── guidelineUtils.ts    <span class="hljs-comment"># 辅助线工具函数</span><br>│   │   │   │   │   ├── interactionUtils.ts  <span class="hljs-comment"># 交互工具函数</span><br>│   │   │   │   │   ├── renderUtils.ts       <span class="hljs-comment"># 渲染工具函数</span><br>│   │   │   │   │   ├── resizeUtils.ts       <span class="hljs-comment"># 调整大小工具函数</span><br>│   │   │   │   │   ├── rotationUtils.ts     <span class="hljs-comment"># 旋转工具函数</span><br>│   │   │   │   │   ├── scaleUtils.ts        <span class="hljs-comment"># 缩放工具函数</span><br>│   │   │   │   │   ├── selectionUtils.ts    <span class="hljs-comment"># 选择工具函数</span><br>│   │   │   │   │   └── stateUtils.ts        <span class="hljs-comment"># 状态工具函数</span><br>│   │   │   │   └── STM_modules.md  <span class="hljs-comment"># 状态管理模块说明文档</span><br>│   │   │   ├── Pixi_stageManager.ts    <span class="hljs-comment"># Pixi舞台管理器入口</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 画布页面入口文件</span><br>│   │   ├── home/                   <span class="hljs-comment"># 主页</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 主页内容组件</span><br>│   │   │   │   └── AKN.tsx         <span class="hljs-comment"># AKN内容组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 主页入口文件</span><br>│   │   ├── intro/                  <span class="hljs-comment"># 介绍页面</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 介绍页面实现</span><br>│   │   └── room/                   <span class="hljs-comment"># 房间管理页面</span><br>│   │       └── RoomManagement.tsx  <span class="hljs-comment"># 房间管理页面实现</span><br>│   ├── router/                     <span class="hljs-comment"># 路由配置目录</span><br>│   │   └── router.tsx              <span class="hljs-comment"># 路由配置实现</span><br>│   ├── stores/                     <span class="hljs-comment"># 状态存储目录(Zustand)</span><br>│   │   ├── canvasStore.ts          <span class="hljs-comment"># 画布状态存储</span><br>│   │   ├── persistenceStore.ts     <span class="hljs-comment"># 持久化状态存储</span><br>│   │   └── themeStore.ts           <span class="hljs-comment"># 主题状态存储</span><br>│   ├── app.tsx                     <span class="hljs-comment"># 应用根组件</span><br>│   ├── main.tsx                    <span class="hljs-comment"># 应用入口文件</span><br>│   └── vite-env.d.ts               <span class="hljs-comment"># Vite环境声明文件</span><br>├── README.md                       <span class="hljs-comment"># 项目说明文档</span><br>├── components.json                 <span class="hljs-comment"># 组件配置文件</span><br>├── index.html                      <span class="hljs-comment"># HTML入口文件</span><br>├── lint-staged.config.js           <span class="hljs-comment"># Lint-staged配置</span><br>├── package.json                    <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js               <span class="hljs-comment"># PostCSS配置</span><br>├── tailwind.config.js              <span class="hljs-comment"># Tailwind CSS配置</span><br>├── transmart.config.ts             <span class="hljs-comment"># Transmart配置</span><br>├── tsconfig.json                   <span class="hljs-comment"># TypeScript配置</span><br>├── tsconfig.node.json              <span class="hljs-comment"># Node.js TypeScript配置</span><br>└── vite.config.ts                  <span class="hljs-comment"># Vite构建配置</span><br></code></pre></td></tr></table></figure><h3 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h3><p>项目采用数据驱动视图（Data-Driven View）模式，使用<strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>的三层架构</p><p>React 只负责 UI 和事件入口<br>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）<br>PixiJS 层只做”渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建<br>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</p><p>项目主要划分为三个层次：渲染层、状态管理层和逻辑层，来实现关注点分离，提高代码的可维护性和可扩展性。</p><h4 id="渲染层"><a href="#渲染层" class="headerlink" title="渲染层"></a><strong>渲染层</strong></h4><p>主要由 PixiJS (WebGL) 负责处理图形渲染，包括创建、更新和删除图形对象。这一层负责将状态管理层的数据转换为可视化的图形元素，并处理用户的交互操作，如拖拽、缩放和旋转等</p><h4 id="状态管理层"><a href="#状态管理层" class="headerlink" title="状态管理层"></a><strong>状态管理层</strong></h4><p>采用 Zustand 管理 JSON 画布数据。<br>先定义一个 CanvasState 接口（JSON 数据结构，包含 id, type, x, y, width, height 等属性）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span> <span class="hljs-comment">// 当前工具类型</span><br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt; <span class="hljs-comment">// 画布元素集合</span><br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[] <span class="hljs-comment">// 选中元素ID列表</span><br>  <span class="hljs-attr">editingId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 正在编辑的元素ID</span><br>  <span class="hljs-attr">clipboard</span>: <span class="hljs-title class_">CanvasElement</span>[] | <span class="hljs-literal">null</span> <span class="hljs-comment">// 剪贴板数据</span><br>  <span class="hljs-attr">pasteOffset</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 粘贴偏移计数</span><br>  <span class="hljs-attr">currentStyle</span>: {<br>    <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-comment">// ... 其他样式属性</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p>使用 Zustand 状态管理库，其中 elements 被定义为 Record<string, CanvasElement="">类型，表示一个以 id 为键，CanvasElement 为值的对象，用于存储画布上的所有元素。更新元素时使用 structuredClone 函数来克隆状态数据。后续持久化存储和撤销重做机制也是基于这一套状态管理来实现。这一层作为数据核心，主要维护画布上所有元素的状态信息，通过集中管理状态，确保了数据的一致性，便于后续的协同编辑和撤销重做功能的开发。</string,></p><h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a><strong>逻辑层</strong></h4><p>核心是 StageManagerCore 类，通过 StageManagerState 接口管理交互状态，包括当前交互模式、起始位置、当前元素 ID、初始元素状态等，处理多种交互模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">idle - 空闲状态<br>panning - 画布平移<br>selecting - 选择元素<br>dragging - 拖拽元素<br>resizing - 调整元素大小<br>drawing - 绘制元素<br>texting - 文本编辑<br>erasing - 擦除元素<br></code></pre></td></tr></table></figure><p>处理多种元素操作逻辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建元素 - 根据不同工具类型创建相应元素<br>选择元素 - 支持单选和多选<br>拖拽元素 - 记录初始状态，计算偏移量<br>调整大小 - 通过控制手柄调整元素尺寸<br>删除元素 - 通过橡皮擦工具删除元素<br></code></pre></td></tr></table></figure><p>通过这种方式来实现面向对象编程并封装业务逻辑，提高代码的可维护性，利用后续拓展</p><hr><h3 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h3><p class='item-img' data-src='./assets/image-20251123121234358.png'><img src="./assets/image-20251123121234358.png" alt="image-20251123121234358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互类型}<br>    B --&gt;|创建元素| C[StageManagerCore.onPointerDown]<br>    B --&gt;|拖拽元素| D[StageManagerCore.onPointerMove]<br>    B --&gt;|调整大小| E[StageManagerCore.onHandleDown]<br>    B --&gt;|选择元素| F[StageManagerCore.onPointerUp]<br><br>    C --&gt; G[Zustand Store.addElement]<br>    D --&gt; H[Zustand Store.updateElement]<br>    E --&gt; I[Zustand Store.updateElement]<br>    F --&gt; J[Zustand Store.setSelected]<br><br>    G --&gt; K[Zustand 状态更新]<br>    H --&gt; K<br>    I --&gt; K<br>    J --&gt; K<br><br>    K --&gt; L{状态变化}<br>    L --&gt;|元素变化| M[ElementRenderer.renderElements]<br>    L --&gt;|选择变化| N[TransformerRenderer.renderTransformer]<br><br>    M --&gt; O[PixiJS 图形渲染]<br>    N --&gt; O<br><br>    O --&gt; P[用户看到更新结果]<br><br>    K --&gt; Q[Zustand 持久化]<br>    Q --&gt; R[本地存储/IndexedDB]<br><br>    K --&gt; S[撤销/重做管理]<br>    S --&gt; T[命令栈管理]<br><br>    style A fill:#e1f5fe<br>    style O fill:#e8f5e8<br>    style K fill:#fff3e0<br>    style Q fill:#fce4ec<br></code></pre></td></tr></table></figure><p>流程如下：</p><h4 id="用户交互输入"><a href="#用户交互输入" class="headerlink" title="用户交互输入"></a>用户交互输入</h4><p>所有用户交互事件由 StageManagerCore 处理<br>用户通过鼠标、键盘等方式与画布进行交互：</p><ul><li>创建新元素（点击工具栏选择图形类型后在画布上绘制）</li><li>拖拽元素（选中元素后拖动）</li><li>调整元素大小（拖拽元素控制点）</li><li>选择元素（点击或框选元素）</li></ul><h4 id="创建元素流程"><a href="#创建元素流程" class="headerlink" title="创建元素流程"></a>创建元素流程</h4><ol><li>用户在画布上按下鼠标开始绘制</li><li><a href="">onPointerDown</a>捕获事件，创建新元素</li><li>调用 Zustand store 的<a href="">addElement</a>方法添加元素</li></ol><blockquote><p>创建元素时的中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="拖拽元素流程"><a href="#拖拽元素流程" class="headerlink" title="拖拽元素流程"></a>拖拽元素流程</h4><ol><li>用户按下并拖动已选中的元素</li><li><a href="">onPointerMove</a>持续捕获鼠标移动事件</li><li>实时调用 Zustand store 的<a href="">updateElement</a>更新元素位置</li></ol><blockquote><p>拖拽元素时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="调整大小流程"><a href="#调整大小流程" class="headerlink" title="调整大小流程"></a>调整大小流程</h4><ol><li>用户拖拽元素的控制点（resize handle）</li><li><a href="">onHandleDown</a>捕获控制点拖拽事件</li><li><a href="">onPointerMove</a>计算缩放比例并更新元素大小</li><li>调用 Zustand store 的<a href="">updateElement</a>更新元素属性</li></ol><blockquote><p>调整元素大小时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="交互结束处理"><a href="#交互结束处理" class="headerlink" title="交互结束处理"></a>交互结束处理</h4><ol><li>用户释放鼠标按键，<a href="">onPointerUp</a>处理交互结束,解锁撤销/重做管理器</li><li>创建相应的命令（<a href="">UpdateElementCommand</a>并添加到命令栈中</li><li>清理临时状态</li></ol><h4 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h4><p>Zustand 作为全局状态管理器，处理所有状态更新：</p><ol><li><strong>状态更新</strong>：自定义一套<a href="">originalSet</a>方法更新状态</li><li><strong>撤销/重做处理</strong>：创建状态快照并生成命令对象</li><li><strong>状态订阅</strong>：通知所有订阅者状态变化</li></ol><h4 id="渲染更新"><a href="#渲染更新" class="headerlink" title="渲染更新"></a>渲染更新</h4><p>Zustand 状态变化触发 StageManagerCore 的订阅回调：</p><ol><li><a href="">ElementRenderer.renderElements</a> 根据元素数据更新 PixiJS 图形对象</li><li><a href="">TransformerRenderer.renderTransformer</a> 更新选中元素的变换控制器</li><li>PixiJS 自动进行渲染</li></ol><h4 id="撤销-重做管理"><a href="#撤销-重做管理" class="headerlink" title="撤销/重做管理"></a>撤销/重做管理</h4><p>通过命令模式实现撤销/重做功能：</p><ol><li>每个操作生成对应的命令对象（<a href="">UpdateElementCommand</a>、<a href="">SnapshotCommand</a>等）</li><li>命令对象保存操作前后的状态快照</li><li>通过<a href="">UndoRedoManager</a>管理命令栈，实现撤销和重做功能</li></ol><h4 id="数据持久化阶段"><a href="#数据持久化阶段" class="headerlink" title="数据持久化阶段"></a>数据持久化阶段</h4><p>Zustand 状态变化同时触发数据持久化：</p><ol><li>状态通过<a href="">persist</a>中间件自动保存到本地存储</li><li>数据存储在 IndexedDB 中，来支持离线使用</li></ol><blockquote><p>这一块还在写</p></blockquote><hr><h3 id="设计的相关考虑"><a href="#设计的相关考虑" class="headerlink" title="设计的相关考虑"></a>设计的相关考虑</h3><p><strong>解耦</strong>：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展</p><p><strong>便于后续的协同编辑</strong>：实现多人协同，要监听 WebSocket 消息，然后更新 Zustand Store。StageManager 可以去监听到 Store 的变化，并作出相应的渲染更新</p><p><strong>对撤销/重做的实现</strong>：因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照</p><p><strong>序列化/反序列化</strong>：保存项目只需 JSON.stringify(store.elements)</p><h4 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h4><p>【待补充】</p><h2 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h2><p>部署地址：<a href="https://zhongye1.github.io/BDdraw_DEV/">https://zhongye1.github.io/BDdraw_DEV/</a></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h4 id="【P0】基础渲染"><a href="#【P0】基础渲染" class="headerlink" title="【P0】基础渲染"></a><del>【P0】基础渲染</del></h4><ul><li><del>支持图形渲染，需要支持至少 3 种不同图形，比如矩形、圆角矩形、圆形、三角形等。需要支持以下图形属性：</del><ul><li><del>背景色（background）</del></li><li><del>边框宽度（border-width）</del></li><li><del>边框颜色（border-color）</del></li></ul></li><li><del>支持图片渲染，需要支持 png、jpeg 格式，支持设置三种简单滤镜</del></li><li><del>支持富文本文字渲染，需要支持以下文本属性：</del><ul><li><del>字体（font-family）</del></li><li><del>字号（font-size）</del></li><li><del>颜色（color）</del></li><li><del>背景色（background）</del></li><li><del>BIUS（加粗、斜体、下划线、删除线）</del></li></ul></li></ul><h4 id="【P0】画布交互"><a href="#【P0】画布交互" class="headerlink" title="【P0】画布交互"></a><del>【P0】画布交互</del></h4><ul><li><del>支持无限画布的缩放、滚动、拖拽</del><ul><li><del>支持无限画布滚动条</del></li><li><del>支持无限画布的 minimap 功能</del></li></ul></li><li><del>支持选区功能：</del><ul><li><del>点击选中单个元素</del></li><li><del>框选选中多个元素</del></li></ul></li><li><del>支持数据持久化，每次操作后自动保存数据，刷新页面数据仍然存在</del></li><li><del>快捷键复制选中元素</del></li><li><del>支持辅助线功能</del></li></ul><h4 id="【P0】调参工具栏"><a href="#【P0】调参工具栏" class="headerlink" title="【P0】调参工具栏"></a><del>【P0】调参工具栏</del></h4><ul><li><del>浮动工具栏</del><ul><li><del>当选中文本元素时出现在上方，支持设置不同文本属性</del>（做了个编辑器）</li><li><del>当选中图形元素时出现在上方，支持设置不同图形属性</del></li><li><del>选中文本元素的部分文字时也能够出现，支持设置局部文本的文本属性</del>（编辑器内编辑可实现）</li></ul></li></ul><h4 id="【P0】元素编辑"><a href="#【P0】元素编辑" class="headerlink" title="【P0】元素编辑"></a><del>【P0】元素编辑</del></h4><ul><li><del>支持双击文本进入编辑，可以输入/删除文本内容</del></li><li><del>支持对选中元素（单个或多个）删除</del></li><li><del>支持对选中元素（单个或多个）拖拽</del></li><li><del>支持对选中元素（单个或多个）缩放</del></li><li><del>支持对选中元素（单个或多个）旋转</del></li><li><del>支持对多个元素进行组合操作，组合可以嵌套</del></li><li><del>支持对多个元素进行打组、解组</del><del>(组操作 bug 复现了，目前在修)</del>（已修复）</li></ul><h4 id="【P0】性能优化"><a href="#【P0】性能优化" class="headerlink" title="【P0】性能优化"></a><del>【P0】性能优化</del></h4><ul><li><del>画布存在 100 个元素，打开页面到渲染完成 &lt; 3s</del></li><li><del>同时操作 100 个元素，FPS 50+</del></li></ul><h4 id="【P1】协同"><a href="#【P1】协同" class="headerlink" title="【P1】协同"></a><del>【P1】协同</del></h4><ul><li><del>支持 undo &amp; redo 操作</del> <del>（大体实现了，可能要修一下 undo，redo 栈，有个不能稳定复现的 bug）</del>（已实现）</li><li><del>支持协同编辑，多人打开同一个画布可以协同编辑</del> (写了个 Node.js 后端)</li><li><del>支持离线编辑，断网后仍然可以对画布编辑，恢复网络后自动提交数据</del>（IndexedDB）</li></ul><blockquote><p>各模块的技术文档补充中<br>此文档最后编辑于 2025.11.27<br>项目开发中，欢迎提 issue 和 pr</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BDdraw-DEV&quot;&gt;&lt;a href=&quot;#BDdraw-DEV&quot; class=&quot;headerlink&quot; title=&quot;BDdraw_DEV&quot;&gt;&lt;/a&gt;BDdraw_DEV&lt;/h1&gt;&lt;p&gt;代码仓库：&lt;br&gt;&lt;a href=&quot;https://github.com/Z</summary>
      
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="excalidraw" scheme="https://zhongye1.github.io/Arknight-notes/tags/excalidraw/"/>
    
    <category term="github" scheme="https://zhongye1.github.io/Arknight-notes/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-29-JavaScript中的数组方法与栈（Stack）和队列（Queue）的实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/28254.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/28254.html</id>
    <published>2025-11-29T08:58:15.000Z</published>
    <updated>2025-12-27T07:27:06.557Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能</p><p>这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在<strong>两端</strong>高效操作的能力</p><p>先简单回顾一下这四种数组方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>操作位置</th><th>操作类型</th><th>返回值</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>push()</code></td><td>尾部</td><td>添加</td><td>新长度</td><td>O(1)</td></tr><tr><td><code>pop()</code></td><td>尾部</td><td>删除</td><td>被删除元素</td><td>O(1)</td></tr><tr><td><code>unshift()</code></td><td>头部</td><td>添加</td><td>新长度</td><td>O(n)</td></tr><tr><td><code>shift()</code></td><td>头部</td><td>删除</td><td>被删除元素</td><td>O(n)</td></tr></tbody></table></div><h3 id="1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）"><a href="#1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）" class="headerlink" title="1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）"></a>1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）</h3><p>主要使用数组的<strong>末尾</strong>操作实现：</p><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入栈（push）</td><td>array.push(item)</td><td>stack.push(1)</td><td>O(1)</td></tr><tr><td>出栈（pop）</td><td>array.pop()</td><td>const item = stack.pop()</td><td>O(1)</td></tr></tbody></table></div><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> stack = [];<br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// [1]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// [1, 2]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack);        <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><h3 id="2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）"><a href="#2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）" class="headerlink" title="2. 实现队列（Queue）——先进先出（FIFO，First In First Out）"></a>2. 实现队列（Queue）——先进先出（FIFO，First In First Out）</h3><h4 id="方式一：头部删除-尾部插入"><a href="#方式一：头部删除-尾部插入" class="headerlink" title="方式一：头部删除 + 尾部插入"></a>方式一：<strong>头部删除 + 尾部插入</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队（enqueue）</td><td>array.push(item)</td><td>queue.push(1)</td><td>O(1)</td></tr><tr><td>出队（dequeue）</td><td>array.shift()</td><td>const item = queue.shift()</td><td>O(n)</td></tr></tbody></table></div><p>问题：shift() 会导致数组所有元素向前移动，时间复杂度为 O(n)，频繁操作时性能很差</p><h4 id="方式二：尾部插入-头部删除"><a href="#方式二：尾部插入-头部删除" class="headerlink" title="方式二：尾部插入 + 头部删除"></a>方式二：<strong>尾部插入 + 头部删除</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队</td><td>array.unshift(item)</td><td>queue.unshift(1)</td><td>O(n)</td></tr><tr><td>出队</td><td>array.pop()</td><td>const item = queue.pop()</td><td>O(1)</td></tr></tbody></table></div><p>同样存在 O(n) 操作</p><p>如果需要高效队列，可以使用<strong>双端队列</strong>实现或第三方库，有几种方式</p><ol><li><strong>使用两个数组模拟</strong>（常见面试实现）：<ul><li>一个栈用于入队，一个栈用于出队，需要时倒腾</li></ul></li><li><strong>使用 JavaScript 的 Deque（双端队列）库</strong>：<ul><li>如 js-deque 或其他库，支持 O(1) 的头尾操作</li></ul></li><li><strong>ES6+ 原生替代</strong>：虽然没有内置 Queue，但可以用 Array + 手动索引模拟环形队列（较复杂）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能&lt;/p&gt;
&lt;p&gt;这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在&lt;strong&gt;两端&lt;/str</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-27-前端安全Vol.1-关于XSS与CRSF及其相关对策</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33361.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33361.html</id>
    <published>2025-11-27T18:05:25.000Z</published>
    <updated>2025-12-27T18:49:21.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跨站脚本攻击（XSS）和跨站请求伪造（CSRF）"><a href="#跨站脚本攻击（XSS）和跨站请求伪造（CSRF）" class="headerlink" title="跨站脚本攻击（XSS）和跨站请求伪造（CSRF）"></a>跨站脚本攻击（XSS）和跨站请求伪造（CSRF）</h3><p>跨站脚本攻击（Cross-Site Scripting，简称 XSS）和跨站请求伪造（Cross-Site Request Forgery，简称 CSRF 或 XSRF）是 Web 应用中最常见的两种安全漏洞。尽管名称相似，但攻击原理、影响和防御方式完全不同。</p><h4 id="1-跨站脚本攻击（XSS）"><a href="#1-跨站脚本攻击（XSS）" class="headerlink" title="1. 跨站脚本攻击（XSS）"></a>1. 跨站脚本攻击（XSS）</h4><p><strong>定义</strong>：XSS 是一种代码注入攻击，攻击者将恶意客户端脚本（通常为 JavaScript）注入到网页中，当受害者访问该页面时，恶意脚本在受害者的浏览器中执行，从而窃取信息或执行恶意操作。</p><p><strong>分类</strong>：XSS 攻击主要分为三种类型。首先是反射型 XSS（Reflected XSS），恶意脚本通过 URL 参数、表单提交等反射回响应页面，常用于钓鱼攻击，例如用户点击含有<script>alert(document.cookie)</script>的链接。其次是存储型 XSS（Stored/Persistent XSS），恶意脚本被永久存储在服务器（如数据库中的评论、帖子），所有访问该内容的用户均受影响，危害最大。最后是基于 DOM 的 XSS（DOM-based XSS），恶意脚本通过客户端 JavaScript 操作 DOM 注入，通常不涉及服务器反射。</p><p><strong>攻击后果</strong>：XSS 攻击可能导致多种严重后果。攻击者可以窃取 Cookie、Session Token，导致会话劫持；伪造请求、钓鱼、键盘记录；还可以对页面进行篡改（Defacement）。</p><p><strong>防御措施</strong>：针对 XSS 攻击有多种防御措施。输出编码（Output Encoding）是在 HTML、JavaScript、CSS、URL 等上下文中对用户输入进行适当转义（如使用 DOMPurify 净化 HTML）；内容安全策略（Content Security Policy, CSP）通过 HTTP 头限制脚本来源；输入验证则是严格验证和过滤用户输入；HttpOnly Cookie 可以防止 JavaScript 访问 Cookie；使用安全库如 DOMPurify、OWASP Java Encoder 等也是有效手段。</p><p><strong>详细防御策略</strong>：在具体实施中，HTML 编码将特殊字符（&lt;、&gt;、&amp;、”、’）转换为 HTML 实体，防止浏览器将其解释为标签。JavaScript 编码在 JavaScript 上下文中使用用户输入前，将特殊字符转义为 JavaScript 字符串或正则表达式格式。CSS 编码在 CSS 上下文中使用用户输入时，需要转义特殊字符。URL 编码则对 URL 参数进行编码，确保 URL 安全。</p><p>CSP 实施示例可以通过 HTTP 头设置：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>default-src 'self';<br>script-src 'self' 'unsafe-inline' https://trusted-cdn.example.com;<br>object-src 'none'; frame-ancestors 'none';<br></code></pre></td></tr></table></figure><p>也可以在 HTML 中设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><br><span class="hljs-tag">  <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Security-Policy"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">content</span>=<span class="hljs-string">"default-src 'self'; script-src 'self' 'unsafe-inline';"</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure><p>使用模板引擎的安全特性也很重要，如 Jinja2、Handlebars 等模板引擎通常内置 XSS 防护，使用时避免使用”raw”或”unsafe”过滤器。同时需要进行严格的输入验证，不仅在服务端验证输入，也要在客户端进行验证（虽然客户端验证可被绕过，但可以改善用户体验）。</p><h4 id="2-跨站请求伪造（CSRF）"><a href="#2-跨站请求伪造（CSRF）" class="headerlink" title="2. 跨站请求伪造（CSRF）"></a>2. 跨站请求伪造（CSRF）</h4><p><strong>定义</strong>：CSRF 是一种利用用户已认证身份的攻击。攻击者诱导已登录的用户在不知情情况下向目标网站发送恶意请求，利用浏览器自动携带 Cookie 的特性执行敏感操作。</p><p><strong>攻击原理</strong>：首先，用户已登录目标网站（如银行网站），浏览器保存了认证 Cookie。然后，攻击者通过钓鱼邮件、恶意网站诱导用户访问含有恶意表单或图像的页面，例如 HTML 中的<code>&lt;img src="https://bank.com/transfer?amount=1000&amp;to=attacker"&gt;</code><br>最后，浏览器自动携带 Cookie 发送请求，完成转账等操作</p><p><strong>攻击后果</strong>：CSRF 攻击可能导致未经授权执行敏感操作（如转账、修改密码、删除账户）。虽然它不直接窃取数据，但可利用用户权限造成破坏。</p><p><strong>防御措施</strong>：针对 CSRF 有多种防御措施。CSRF Token（同步器令牌）是在表单或请求中加入服务器生成的随机 Token，服务器验证 Token 是否匹配且有效，主流框架（如 Django、Spring、Rails）内置支持。SameSite Cookie 是设置 Cookie 的 SameSite 属性（Lax 或 Strict），限制跨站请求携带 Cookie，其中 SameSite=Lax 允许顶级导航（如 GET 链接），阻止大多数 CSRF；SameSite=Strict 完全阻止跨站请求携带 Cookie。双重提交 Cookie（Double Submit Cookie）是将 Token 同时存入 Cookie 和表单，服务器比对两者（适用于无状态应用）。验证 Referer/Origin 头是检查请求来源是否合法（可被伪造或禁用，不推荐单独使用）。使用安全的 HTTP 方法是敏感操作仅允许 POST、PUT、DELETE 等非幂等方法。</p><p><strong>详细防御策略</strong>：CSRF Token 的实现包括几个步骤：服务器生成随机的 CSRF Token（如使用加密安全的随机数生成器）；将 Token 放入表单隐藏字段或 HTTP 头中；用户提交请求时，服务器验证 Token 是否匹配且未过期；Token 应在每次会话或关键操作后更新。</p><p>SameSite Cookie 设置示例包括设置 SameSite 属性：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123;<br>Path=/;<br>HttpOnly;<br>SameSite=Strict<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; Path=/; HttpOnly; SameSite=Lax<br></code></pre></td></tr></table></figure><p>自定义请求头验证要求所有 API 请求包含自定义头部（如 X-Requested-With 或 X-CSRF-Token），因为浏览器在跨站请求中不会自动添加这些头部。验证码机制对高风险操作（如修改密码、转账）要求用户输入验证码或进行二次确认。登出确认在登出页面添加确认步骤，防止攻击者诱导用户登出。</p><h4 id="XSS-与-CSRF-的对比总结"><a href="#XSS-与-CSRF-的对比总结" class="headerlink" title="XSS 与 CSRF 的对比总结"></a>XSS 与 CSRF 的对比总结</h4><div class="table-container"><table><thead><tr><th>项目</th><th>XSS</th><th>CSRF</th></tr></thead><tbody><tr><td>攻击目标</td><td>浏览器中的信任（执行恶意脚本）</td><td>网站对用户的信任（利用已认证会话）</td></tr><tr><td>是否需要注入代码</td><td>是（注入 JavaScript）</td><td>否（仅诱导发送请求）</td></tr><tr><td>主要危害</td><td>窃取数据、会话劫持、页面篡改</td><td>伪造用户操作（如转账、改密）</td></tr><tr><td>典型场景</td><td>用户输入未过滤的评论、搜索框</td><td>登录后访问恶意网站</td></tr><tr><td>核心防御</td><td>输出编码、CSP、输入验证</td><td>CSRF Token、SameSite Cookie</td></tr><tr><td>是否可相互利用</td><td>XSS 可绕过 CSRF 防御（直接读 Token）</td><td>CSRF 无法直接引发 XSS</td></tr></tbody></table></div><p><strong>综合防御策略</strong>：在实际安全防护中，需要采用多种策略。分层防御是结合多种防御措施，而不是依赖单一方法。安全默认值是在系统设计时就考虑安全因素，而不是事后补救。定期安全审计使用自动化工具和手动测试来识别潜在的安全漏洞。开发者培训提高团队对安全问题的认识和防范能力。监控和日志记录可疑活动，及时发现攻击尝试。</p><p><strong>实际应用示例</strong>：在实际开发中，我们通常会组合使用多种防御策略。例如 JavaScript 代码示例中，createSecureForm 函数首先验证输入数据，然后对输出进行编码，最后添加 CSRF Token，这样就结合了多种安全措施。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 一个安全的表单处理示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSecureForm</span>(<span class="hljs-params">data</span>) {<br>  <span class="hljs-comment">// 1. 验证输入数据</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidInput</span>(data)) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Invalid input"</span>);<br>  }<br><br>  <span class="hljs-comment">// 2. 输出编码</span><br>  <span class="hljs-keyword">const</span> safeData = <span class="hljs-title function_">encodeForHTML</span>(data);<br><br>  <span class="hljs-comment">// 3. 添加 CSRF Token</span><br>  <span class="hljs-keyword">const</span> csrfToken = <span class="hljs-title function_">getCSRFToken</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;form method="POST" action="/submit"&gt;</span><br><span class="hljs-string">      &lt;input type="hidden" name="csrf_token" value="<span class="hljs-subst">${csrfToken}</span>"&gt;</span><br><span class="hljs-string">      &lt;div&gt;<span class="hljs-subst">${safeData}</span>&lt;/div&gt;</span><br><span class="hljs-string">      &lt;button type="submit"&gt;提交&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/form&gt;</span><br><span class="hljs-string">  `</span>;<br>}<br><br><span class="hljs-comment">// 通过 CSP 策略进一步保护</span><br><span class="hljs-comment">// Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';</span><br></code></pre></td></tr></table></figure><p>攻击者若成功执行 XSS，可轻松绕过 CSRF Token（通过脚本读取并发送 Token），因此，在 Web 安全开发中，必须同时防御这两种漏洞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;跨站脚本攻击（XSS）和跨站请求伪造（CSRF）&quot;&gt;&lt;a href=&quot;#跨站脚本攻击（XSS）和跨站请求伪造（CSRF）&quot; class=&quot;headerlink&quot; title=&quot;跨站脚本攻击（XSS）和跨站请求伪造（CSRF）&quot;&gt;&lt;/a&gt;跨站脚本攻击（XSS）和跨站</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-27-前端学习-关于JavaScript 实现哈希表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39960.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39960.html</id>
    <published>2025-11-27T03:31:39.000Z</published>
    <updated>2025-12-26T09:09:52.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-实现哈希表"><a href="#JavaScript-实现哈希表" class="headerlink" title="JavaScript 实现哈希表"></a>JavaScript 实现哈希表</h1><p><strong>哈希表</strong>（Hash Table，散列表）是一种通过键（Key）直接访问值（Value）的数据结构，通过哈希函数将键映射到表中的位置</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 简单的哈希函数示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashString</span>(<span class="hljs-params">key, tableSize</span>) {<br>  <span class="hljs-keyword">let</span> hash = <span class="hljs-number">17</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-property">length</span>; i++) {<br>    hash = (<span class="hljs-number">13</span> * hash * key.<span class="hljs-title function_">charCodeAt</span>(i)) % tableSize;<br>  }<br>  <span class="hljs-keyword">return</span> hash;<br>}<br></code></pre></td></tr></table></figure><h2 id="用-JavaScript-实现哈希表"><a href="#用-JavaScript-实现哈希表" class="headerlink" title="用 JavaScript 实现哈希表"></a>用 JavaScript 实现哈希表</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 哈希函数</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX_LENGTH</span> = <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(key.<span class="hljs-property">length</span>, <span class="hljs-variable constant_">MAX_LENGTH</span>); i++) {<br>      <span class="hljs-keyword">const</span> char = key[i];<br>      <span class="hljs-keyword">const</span> value = char.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">96</span>; <span class="hljs-comment">// a=1, b=2...</span><br>      total = (total * <span class="hljs-variable constant_">PRIME</span> + value) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>;<br>    }<br>    <span class="hljs-keyword">return</span> total;<br>  }<br><br>  <span class="hljs-comment">// 插入键值对</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index] = [];<br>    }<br>    <br>    <span class="hljs-comment">// 检查键是否已存在，存在则更新</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>  }<br><br>  <span class="hljs-comment">// 获取值</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>];<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-comment">// 删除键值对</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取所有键</span><br>  <span class="hljs-title function_">keys</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> keysArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!keysArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>])) {<br>            keysArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> keysArr;<br>  }<br><br>  <span class="hljs-comment">// 获取所有值</span><br>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> valuesArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!valuesArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>])) {<br>            valuesArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> valuesArr;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialCapacity = <span class="hljs-number">8</span>, loadFactor = <span class="hljs-number">0.75</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = initialCapacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span> = loadFactor;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>  }<br><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> hashCode = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <br>    <span class="hljs-comment">// 处理不同类型的键</span><br>    <span class="hljs-keyword">const</span> keyStr = <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span> ? key : <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keyStr.<span class="hljs-property">length</span>; i++) {<br>      hashCode = (<span class="hljs-variable constant_">PRIME</span> * hashCode + keyStr.<span class="hljs-title function_">charCodeAt</span>(i)) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>    }<br>    <span class="hljs-keyword">return</span> hashCode;<br>  }<br><br>  <span class="hljs-title function_">_resize</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> oldBuckets = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> *= <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bucket <span class="hljs-keyword">of</span> oldBuckets) {<br>      <span class="hljs-keyword">if</span> (bucket) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> bucket) {<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">set</span>(key, value);<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-comment">// 检查是否需要扩容</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_resize</span>();<br>    }<br><br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index] = [];<br>    }<br><br>    <span class="hljs-comment">// 更新或添加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">const</span> bucket = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index];<br>    <br>    <span class="hljs-keyword">if</span> (bucket) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> bucket) {<br>        <span class="hljs-keyword">if</span> (k === key) <span class="hljs-keyword">return</span> v;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(key) !== <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取负载因子</span><br>  <span class="hljs-title function_">getLoadFactor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="支持任何类型键的通用哈希表"><a href="#支持任何类型键的通用哈希表" class="headerlink" title="支持任何类型键的通用哈希表"></a>支持任何类型键的通用哈希表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniversalHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 通用哈希函数，支持多种类型</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'number'</span>) {<br>      <span class="hljs-keyword">return</span> key % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span>) {<br>      <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-property">length</span>; i++) {<br>        hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + key.<span class="hljs-title function_">charCodeAt</span>(i);<br>        hash = hash &amp; hash; <span class="hljs-comment">// 转为32位整数</span><br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'object'</span> &amp;&amp; key !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 对象使用JSON字符串化</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key));<br>    }<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希解决冲突</span><br>  <span class="hljs-title function_">_hash2</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key) % <span class="hljs-number">7</span>);<br>  }<br><br>  <span class="hljs-comment">// 使用线性探测开放寻址</span><br>  <span class="hljs-title function_">_findSlot</span>(<span class="hljs-params">key, forInsert = <span class="hljs-literal">false</span></span>) {<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">let</span> step = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">undefined</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到键</span><br>      }<br>      <br>      <span class="hljs-keyword">if</span> (forInsert &amp;&amp; (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">undefined</span>)) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到可插入的空槽</span><br>      }<br>      <br>      <span class="hljs-comment">// 线性探测</span><br>      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>      step++;<br>      <br>      <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Hash table is full'</span>);<br>      }<br>    }<br>    <br>    <span class="hljs-keyword">return</span> forInsert ? index : -<span class="hljs-number">1</span>;<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">true</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = { key, value };<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> index !== -<span class="hljs-number">1</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">value</span> : <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 标记为删除</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="使用-JavaScript-内置结构"><a href="#使用-JavaScript-内置结构" class="headerlink" title="使用 JavaScript 内置结构"></a>使用 JavaScript 内置结构</h2><p>使用 Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 最简单的哈希表实现</span><br><span class="hljs-keyword">const</span> hashTable = {};<br>hashTable[<span class="hljs-string">'key1'</span>] = <span class="hljs-string">'value1'</span>;<br>hashTable[<span class="hljs-string">'key2'</span>] = <span class="hljs-string">'value2'</span>;<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-keyword">const</span> value = hashTable[<span class="hljs-string">'key1'</span>];<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> hashTable[<span class="hljs-string">'key1'</span>];<br></code></pre></td></tr></table></figure><p>使用 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 Map 是更好的哈希表实现</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 设置键值对</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'name'</span>, <span class="hljs-string">'Alice'</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">42</span>, <span class="hljs-string">'The Answer'</span>);<br>map.<span class="hljs-title function_">set</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }, <span class="hljs-string">'Object Key'</span>);<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'name'</span>)); <span class="hljs-comment">// Alice</span><br><br><span class="hljs-comment">// 检查是否存在</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br>map.<span class="hljs-title function_">delete</span>(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// 大小</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>);<br><br><span class="hljs-comment">// 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>});<br><br><span class="hljs-comment">// 清空</span><br>map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>使用 Set（类似哈希集合）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用于存储唯一值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复，不会被添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>);   <span class="hljs-comment">// 2</span><br><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>选择合适的哈希函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 更好的字符串哈希函数（djb2算法）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashDJB2</span>(<span class="hljs-params">str, tableSize</span>) {<br>  <span class="hljs-keyword">let</span> hash = <span class="hljs-number">5381</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) {<br>    hash = (hash * <span class="hljs-number">33</span>) ^ str.<span class="hljs-title function_">charCodeAt</span>(i);<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % tableSize;<br>}<br></code></pre></td></tr></table></figure><p>优化冲突处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleted</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'deleted'</span>); <span class="hljs-comment">// 特殊标记删除</span><br>  }<br><br>  <span class="hljs-comment">// 二次探测</span><br>  <span class="hljs-title function_">_probe</span>(<span class="hljs-params">index, i, tableSize</span>) {<br>    <span class="hljs-keyword">return</span> (index + i * i) % tableSize;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希</span><br>  <span class="hljs-title function_">_doubleHash</span>(<span class="hljs-params">index, i, tableSize, key</span>) {<br>    <span class="hljs-keyword">const</span> hash2 = <span class="hljs-number">1</span> + (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash2</span>(key) % (tableSize - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> (index + i * hash2) % tableSize;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>频率计数器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">frequencyCounter</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">const</span> frequency = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) {<br>    frequency.<span class="hljs-title function_">set</span>(item, (frequency.<span class="hljs-title function_">get</span>(item) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> frequency;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'banana'</span>];<br><span class="hljs-keyword">const</span> freq = <span class="hljs-title function_">frequencyCounter</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(freq.<span class="hljs-title function_">get</span>(<span class="hljs-string">'banana'</span>)); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>缓存实现（LRU Cache）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 哈希表 + 维护顺序</span><br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value); <span class="hljs-comment">// 更新为最近使用</span><br>    <br>    <span class="hljs-keyword">return</span> value;<br>  }<br><br>  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>      <span class="hljs-comment">// 删除最久未使用的</span><br>      <span class="hljs-keyword">const</span> oldestKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(oldestKey);<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value);<br>  }<br>}<br></code></pre></td></tr></table></figure><p>分组算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">groupBy</span>(<span class="hljs-params">array, keyFn</span>) {<br>  <span class="hljs-keyword">const</span> groups = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) {<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">typeof</span> keyFn === <span class="hljs-string">'function'</span> <br>      ? <span class="hljs-title function_">keyFn</span>(item) <br>      : item[keyFn];<br>    <br>    <span class="hljs-keyword">if</span> (!groups.<span class="hljs-title function_">has</span>(key)) {<br>      groups.<span class="hljs-title function_">set</span>(key, []);<br>    }<br>    <br>    groups.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">push</span>(item);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> groups;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> people = [<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> }<br>];<br><br><span class="hljs-keyword">const</span> groupedByAge = <span class="hljs-title function_">groupBy</span>(people, <span class="hljs-string">'age'</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(groupedByAge.<span class="hljs-title function_">get</span>(<span class="hljs-number">25</span>));<br><span class="hljs-comment">// [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }]</span><br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><div class="table-container"><table><thead><tr><th>操作</th><th>Object</th><th>Map</th><th>自定义哈希表</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>遍历键</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div><p>最坏情况（所有键冲突）会退化为 O(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-实现哈希表&quot;&gt;&lt;a href=&quot;#JavaScript-实现哈希表&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 实现哈希表&quot;&gt;&lt;/a&gt;JavaScript 实现哈希表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;哈希表&lt;/s</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-25 关于链表(Javascript)</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33314.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33314.html</id>
    <published>2025-11-25T05:00:48.000Z</published>
    <updated>2025-12-27T09:10:09.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于链表-Javascript"><a href="#关于链表-Javascript" class="headerlink" title="关于链表(Javascript)"></a>关于链表(Javascript)</h2><p>链表是一种常见的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用，在 JavaScript 中广泛应用于算法问题和实际开发</p><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><h5 id="1-单向链表的实现"><a href="#1-单向链表的实现" class="headerlink" title="1. 单向链表的实现"></a>1. 单向链表的实现</h5><p>下面是一个简单的单向链表的实现，包括节点定义和基本操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value; <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向下一个节点的指针，初始为 null</span><br>  }<br>}<br><br><span class="hljs-comment">// 定义单向链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表头节点，初始为 null</span><br>  }<br><br>  <span class="hljs-comment">// 在链表末尾添加节点</span><br>  <span class="hljs-title function_">append</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 如果链表为空，新的节点作为头节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>      <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-comment">// 遍历链表找到最后一个节点</span><br>        current = current.<span class="hljs-property">next</span>;<br>      }<br>      current.<span class="hljs-property">next</span> = newNode; <span class="hljs-comment">// 将新的节点添加到最后一个节点的 next</span><br>    }<br>  }<br><br>  <span class="hljs-comment">// 在链表头部添加节点</span><br>  <span class="hljs-title function_">prepend</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>; <span class="hljs-comment">// 新节点的 next 指向当前的头节点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode; <span class="hljs-comment">// 新节点作为头节点</span><br>  }<br><br>  <span class="hljs-comment">// 删除指定值的节点</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果链表为空，直接返回</span><br><br>    <span class="hljs-comment">// 如果头节点就是要删除的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">value</span> === value) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>      <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">next</span>.<span class="hljs-property">value</span> === value) {<br>        <span class="hljs-comment">// 找到要删除的节点</span><br>        current.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>; <span class="hljs-comment">// 将要删除的节点移出链表</span><br>        <span class="hljs-keyword">return</span>;<br>      }<br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>  }<br><br>  <span class="hljs-comment">// 打印链表</span><br>  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>      process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">${current.value}</span> -&gt; `</span>); <span class="hljs-comment">// 输出当前节点的值</span><br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"null"</span>); <span class="hljs-comment">// 表示链表结束</span><br>  }<br>}<br><br><span class="hljs-comment">// 示例：使用单向链表</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>list.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>list.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>list.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>list.<span class="hljs-title function_">prepend</span>(<span class="hljs-number">0</span>);<br>list.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; null</span><br>list.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);<br>list.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 -&gt; 1 -&gt; 3 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="2-双向链表的实现"><a href="#2-双向链表的实现" class="headerlink" title="2. 双向链表的实现"></a>2. 双向链表的实现</h5><p>下面是一个简单的双向链表的实现，包括节点定义和基本操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义双向节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyListNode</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value; <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向下一个节点的指针，初始为 null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向前一个节点的指针，初始为 null</span><br>  }<br>}<br><br><span class="hljs-comment">// 定义双向链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表头节点，初始为 null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表尾节点，初始为 null</span><br>  }<br><br>  <span class="hljs-comment">// 在链表末尾添加节点</span><br>  <span class="hljs-title function_">append</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> === <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 如果链表为空，新的节点作为头和尾节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">next</span> = newNode; <span class="hljs-comment">// 将新的节点添加到尾节点的 next</span><br>      newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>; <span class="hljs-comment">// 新节点的 prev 指向当前的尾节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode; <span class="hljs-comment">// 新节点作为新的尾节点</span><br>    }<br>  }<br><br>  <span class="hljs-comment">// 在链表头部添加节点</span><br>  <span class="hljs-title function_">prepend</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyListNode</span>(value); <span class="hljs-comment">// 创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 如果链表为空，新的节点作为头和尾节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span> = newNode; <span class="hljs-comment">// 头节点的 prev 指向新的节点</span><br>      newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>; <span class="hljs-comment">// 新节点的 next 指向当前的头节点</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode; <span class="hljs-comment">// 新节点作为新的头节点</span><br>    }<br>  }<br><br>  <span class="hljs-comment">// 删除指定值的节点</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果链表为空，直接返回</span><br><br>    <span class="hljs-comment">// 如果头节点就是要删除的节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">value</span> === value) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>;<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 如果链表为空，更新尾节点</span><br>      }<br>      <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">value</span> === value) {<br>        <span class="hljs-comment">// 找到要删除的节点</span><br>        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>          current.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = current.<span class="hljs-property">prev</span>;<br>        } <span class="hljs-keyword">else</span> {<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = current.<span class="hljs-property">prev</span>; <span class="hljs-comment">// 更新尾节点</span><br>        }<br>        current.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>  }<br><br>  <span class="hljs-comment">// 打印链表</span><br>  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>      process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">${current.value}</span> &lt;-&gt; `</span>); <span class="hljs-comment">// 输出当前节点的值</span><br>      current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"null"</span>); <span class="hljs-comment">// 表示链表结束</span><br>  }<br>}<br><br><span class="hljs-comment">// 示例：使用双向链表</span><br><span class="hljs-keyword">const</span> dList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyLinkedList</span>();<br>dList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>dList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>dList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>dList.<span class="hljs-title function_">prepend</span>(<span class="hljs-number">0</span>);<br>dList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; null</span><br>dList.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);<br>dList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 &lt;-&gt; 1 &lt;-&gt; 3 &lt;-&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="查找某个元素"><a href="#查找某个元素" class="headerlink" title="查找某个元素"></a>查找某个元素</h5><p><strong>问题描述</strong>：在链表中查找指定值的节点，并返回其位置索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查找指定值的节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 要查找的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 节点的位置索引，如果未找到返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findElement</span>(<span class="hljs-params">list, value</span>) {<br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">if</span> (current.<span class="hljs-property">value</span> === value) {<br>      <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到值，返回索引</span><br>    }<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到，返回-1</span><br>}<br><br><span class="hljs-comment">// 示例：查找元素</span><br><span class="hljs-keyword">const</span> searchList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>searchList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findElement</span>(searchList, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findElement</span>(searchList, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 -1</span><br></code></pre></td></tr></table></figure><h5 id="2-在指定位置插入元素"><a href="#2-在指定位置插入元素" class="headerlink" title="2. 在指定位置插入元素"></a>2. 在指定位置插入元素</h5><p><strong>问题描述</strong>：在链表的指定位置插入新节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在指定位置插入节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">position</span> - 插入位置（从0开始）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 要插入的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 插入成功返回true，否则返回false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtPosition</span>(<span class="hljs-params">list, position, value</span>) {<br>  <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 位置无效</span><br>  }<br><br>  <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 在头部插入</span><br>    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value);<br>    newNode.<span class="hljs-property">next</span> = list.<span class="hljs-property">head</span>;<br>    list.<span class="hljs-property">head</span> = newNode;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 找到指定位置的前一个节点</span><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; index &lt; position - <span class="hljs-number">1</span>) {<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-comment">// 如果位置超出链表长度</span><br>  <span class="hljs-keyword">if</span> (index !== position - <span class="hljs-number">1</span> &amp;&amp; current === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 插入新节点</span><br>  <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value);<br>  newNode.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;<br>  current.<span class="hljs-property">next</span> = newNode;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 示例：在指定位置插入元素</span><br><span class="hljs-keyword">const</span> insertList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>insertList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>insertList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>insertList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><br>insertList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">insertAtPosition</span>(insertList, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 在索引2的位置插入3</span><br>insertList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">insertAtPosition</span>(insertList, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 在开头插入0</span><br>insertList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="3-查找指定位置的元素"><a href="#3-查找指定位置的元素" class="headerlink" title="3. 查找指定位置的元素"></a>3. 查找指定位置的元素</h5><p><strong>问题描述</strong>：获取链表中指定位置的元素值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取指定位置的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">position</span> - 位置索引（从0开始）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any|undefined</span>} - 位置上的值，如果位置无效返回undefined</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getElementAtPosition</span>(<span class="hljs-params">list, position</span>) {<br>  <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || list.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 位置无效或链表为空</span><br>  }<br><br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; index &lt; position) {<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-keyword">if</span> (index === position &amp;&amp; current !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> current.<span class="hljs-property">value</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 位置超出链表长度</span><br>}<br><br><span class="hljs-comment">// 示例：获取指定位置的元素</span><br><span class="hljs-keyword">const</span> positionList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>positionList.<span class="hljs-title function_">append</span>(<span class="hljs-number">10</span>);<br>positionList.<span class="hljs-title function_">append</span>(<span class="hljs-number">20</span>);<br>positionList.<span class="hljs-title function_">append</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getElementAtPosition</span>(positionList, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getElementAtPosition</span>(positionList, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getElementAtPosition</span>(positionList, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 undefined</span><br></code></pre></td></tr></table></figure><h5 id="4-删除指定位置的元素"><a href="#4-删除指定位置的元素" class="headerlink" title="4. 删除指定位置的元素"></a>4. 删除指定位置的元素</h5><p><strong>问题描述</strong>：删除链表中指定位置的节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除指定位置的节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">position</span> - 要删除的位置（从0开始）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 删除成功返回true，否则返回false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAtPosition</span>(<span class="hljs-params">list, position</span>) {<br>  <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || list.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 位置无效或链表为空</span><br>  }<br><br>  <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 删除头节点</span><br>    list.<span class="hljs-property">head</span> = list.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 找到指定位置的前一个节点</span><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; index &lt; position - <span class="hljs-number">1</span>) {<br>    current = current.<span class="hljs-property">next</span>;<br>    index++;<br>  }<br><br>  <span class="hljs-comment">// 如果位置超出链表长度</span><br>  <span class="hljs-keyword">if</span> (index !== position - <span class="hljs-number">1</span> || current.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 删除节点</span><br>  current.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 示例：删除指定位置的元素</span><br><span class="hljs-keyword">const</span> deleteList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>deleteList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><br>deleteList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">deleteAtPosition</span>(deleteList, <span class="hljs-number">2</span>); <span class="hljs-comment">// 删除索引2的位置（值为3）</span><br>deleteList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 4 -&gt; null</span><br><span class="hljs-title function_">deleteAtPosition</span>(deleteList, <span class="hljs-number">0</span>); <span class="hljs-comment">// 删除索引0的位置（值为1）</span><br>deleteList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 2 -&gt; 4 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="5-获取链表长度"><a href="#5-获取链表长度" class="headerlink" title="5. 获取链表长度"></a>5. 获取链表长度</h5><p><strong>问题描述</strong>：计算链表中节点的数量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取链表长度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 链表长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getListLength</span>(<span class="hljs-params">list</span>) {<br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>    length++;<br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> length;<br>}<br><br><span class="hljs-comment">// 示例：获取链表长度</span><br><span class="hljs-keyword">const</span> lengthList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getListLength</span>(lengthList)); <span class="hljs-comment">// 输出 3</span><br>lengthList.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getListLength</span>(lengthList)); <span class="hljs-comment">// 输出 4</span><br></code></pre></td></tr></table></figure><hr><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul><li>查找元素：根据值查找节点位置</li><li>指定位置插入：在特定位置插入新节点</li><li>指定位置获取：获取特定位置的节点值</li><li>指定位置删除：删除特定位置的节点</li><li>递归反转：使用递归方式反转链表</li><li>获取长度：统计链表中节点的数量<h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h5></li></ul><p><strong>问题描述</strong>：反转一个单向链表</p><ul><li>初始化 prev 为 null（新链表的尾部）。</li><li>current 从链表头节点开始。</li><li>在循环中：<ul><li>暂存 next = current.next（避免指针丢失）。</li><li>将 current.next 指向 prev（反转当前指针）。</li><li>更新 prev = current（前移 prev）。</li><li>更新 current = next（前移 current）。</li></ul></li><li>循环结束后，prev 指向原链表的尾节点（新头节点），更新 list.head = prev。</li></ul><p>其实就是三指针原地反转</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp'><img src="https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp" alt="alt text"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反转单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">list</span> - 单向链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">LinkedList</span>} - 反转后的链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseLinkedList</span>(<span class="hljs-params">list</span>) {<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> current = list.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">let</span> next = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 暂存下一个节点</span><br>    current.<span class="hljs-property">next</span> = prev; <span class="hljs-comment">// 将当前节点的 next 指向前一个节点</span><br>    prev = current; <span class="hljs-comment">// 更新前一个节点为当前节点</span><br>    current = next; <span class="hljs-comment">// 继续遍历下一个节点</span><br>  }<br>  list.<span class="hljs-property">head</span> = prev; <span class="hljs-comment">// 更新头节点为最后一个非空节点</span><br>  <span class="hljs-keyword">return</span> list;<br>}<br><br><span class="hljs-comment">// 示例：反转链表</span><br><span class="hljs-keyword">const</span> rList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>rList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>rList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>rList.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>rList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; null</span><br><span class="hljs-title function_">reverseLinkedList</span>(rList);<br>rList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 3 -&gt; 2 -&gt; 1 -&gt; null</span><br></code></pre></td></tr></table></figure><h5 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h5><p><strong>问题描述</strong>：合并两个有序链表，使结果链表仍然有序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 合并两个有序链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">l1</span> - 第一个有序链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">LinkedList</span>} <span class="hljs-variable">l2</span> - 第二个有序链表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">LinkedList</span>} - 合并后的有序链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">l1, l2</span>) {<br>  <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 创建一个哨兵节点</span><br>  <span class="hljs-keyword">let</span> current = dummy;<br><br>  <span class="hljs-keyword">let</span> p1 = l1.<span class="hljs-property">head</span>;<br>  <span class="hljs-keyword">let</span> p2 = l2.<span class="hljs-property">head</span>;<br><br>  <span class="hljs-comment">// 遍历两个链表</span><br>  <span class="hljs-keyword">while</span> (p1 !== <span class="hljs-literal">null</span> &amp;&amp; p2 !== <span class="hljs-literal">null</span>) {<br>    <span class="hljs-keyword">if</span> (p1.<span class="hljs-property">value</span> &lt; p2.<span class="hljs-property">value</span>) {<br>      current.<span class="hljs-property">next</span> = p1; <span class="hljs-comment">// 将较小值的节点添加到结果链表中</span><br>      p1 = p1.<span class="hljs-property">next</span>;<br>    } <span class="hljs-keyword">else</span> {<br>      current.<span class="hljs-property">next</span> = p2;<br>      p2 = p2.<span class="hljs-property">next</span>;<br>    }<br>    current = current.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 将剩余的节点连接到结果链表中</span><br>  <span class="hljs-keyword">if</span> (p1 !== <span class="hljs-literal">null</span>) {<br>    current.<span class="hljs-property">next</span> = p1;<br>  }<br>  <span class="hljs-keyword">if</span> (p2 !== <span class="hljs-literal">null</span>) {<br>    current.<span class="hljs-property">next</span> = p2;<br>  }<br><br>  <span class="hljs-keyword">let</span> mergedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>  mergedList.<span class="hljs-property">head</span> = dummy.<span class="hljs-property">next</span>; <span class="hljs-comment">// 哨兵节点的 next 为合并后的头节点</span><br>  <span class="hljs-keyword">return</span> mergedList;<br>}<br><br><span class="hljs-comment">// 示例：合并两个有序链表</span><br><span class="hljs-keyword">const</span> list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>list1.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>list1.<span class="hljs-title function_">append</span>(<span class="hljs-number">3</span>);<br>list1.<span class="hljs-title function_">append</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">const</span> list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>list2.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>list2.<span class="hljs-title function_">append</span>(<span class="hljs-number">4</span>);<br>list2.<span class="hljs-title function_">append</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-keyword">const</span> mergedList = <span class="hljs-title function_">mergeTwoLists</span>(list1, list2);<br>mergedList.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 输出 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</span><br></code></pre></td></tr></table></figure><hr><p>更新中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于链表-Javascript&quot;&gt;&lt;a href=&quot;#关于链表-Javascript&quot; class=&quot;headerlink&quot; title=&quot;关于链表(Javascript)&quot;&gt;&lt;/a&gt;关于链表(Javascript)&lt;/h2&gt;&lt;p&gt;链表是一种常见的数据结构，由一系</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="链表" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-23-Undo/Redo机制具体实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/52695.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/52695.html</id>
    <published>2025-11-23T11:15:00.000Z</published>
    <updated>2025-11-23T16:03:47.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模块摘要-Executive-Summary"><a href="#1-模块摘要-Executive-Summary" class="headerlink" title="1. 模块摘要 (Executive Summary)"></a>1. 模块摘要 (Executive Summary)</h3><p>Undo/Redo 机制是画布应用中实现操作撤销和重做的核心功能模块。它基于命令模式（Command Pattern）实现来，管理操作历史、执行撤销/重做操作和防止操作冲突，通过维护撤销栈和重做栈来管理用户的操作历史。</p><ul><li><p><strong>项目结构树</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>├── lib/<br>│   ├── UndoRedoManager.ts        <span class="hljs-comment"># 撤销重做管理器核心实现</span><br>│   └── UpdateElementCommand.ts   <span class="hljs-comment"># 元素更新命令实现</span><br>└── stores/<br>    └── canvasStore.ts            <span class="hljs-comment"># 状态存储，命令操作的目标</span><br></code></pre></td></tr></table></figure><ul><li><code>Command Pattern</code>：设计模式，用于封装操作命令</li><li><code>Zustand</code>：状态管理库，作为命令操作的目标</li><li><code>TypeScript</code>：提供类型安全和代码可维护性</li></ul></li></ul><h3 id="2-Props-和相关类型定义"><a href="#2-Props-和相关类型定义" class="headerlink" title="2. Props 和相关类型定义"></a>2. Props 和相关类型定义</h3><h4 id="2-1-UndoRedoManager-核心方法"><a href="#2-1-UndoRedoManager-核心方法" class="headerlink" title="2.1 UndoRedoManager 核心方法"></a>2.1 UndoRedoManager 核心方法</h4><p>撤销重做管理器提供了一系列核心方法用于管理操作命令。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>参数</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>executeCommand</td><td>command: Command</td><td>void</td><td>执行并记录命令</td></tr><tr><td>undo</td><td>无</td><td>void</td><td>执行撤销操作</td></tr><tr><td>redo</td><td>无</td><td>void</td><td>执行重做操作</td></tr><tr><td>lock</td><td>无</td><td>void</td><td>锁定管理器，防止记录新命令</td></tr><tr><td>unlock</td><td>无</td><td>void</td><td>解锁管理器</td></tr><tr><td>isLocked</td><td>无</td><td>boolean</td><td>检查管理器是否被锁定</td></tr><tr><td>canUndo</td><td>无</td><td>boolean</td><td>检查是否可以撤销</td></tr><tr><td>canRedo</td><td>无</td><td>boolean</td><td>检查是否可以重做</td></tr></tbody></table></div><h4 id="2-2-核心类型定义"><a href="#2-2-核心类型定义" class="headerlink" title="2.2 核心类型定义"></a>2.2 核心类型定义</h4><p><strong><a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口</strong>：<br>定义了命令对象必须实现的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><p><strong>UpdateOperation 接口</strong>：<br>定义了元素更新操作的数据结构。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 元素ID</span><br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br></code></pre></td></tr></table></figure><h3 id="3-核心状态管理-State-Architecture"><a href="#3-核心状态管理-State-Architecture" class="headerlink" title="3. 核心状态管理 (State Architecture)"></a>3. 核心状态管理 (State Architecture)</h3><blockquote><p>⚠️ 为防止在执行撤销/重做操作时记录新的命令，系统实现了锁定机制。在执行命令时会先锁定管理器，执行完成后再解锁，确保操作的原子性。</p></blockquote><h4 id="3-1-内部状态-Local-State"><a href="#3-1-内部状态-Local-State" class="headerlink" title="3.1 内部状态 (Local State)"></a>3.1 内部状态 (Local State)</h4><p>UndoRedoManager 维护以下内部状态用于管理操作历史：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>undoStack</td><td>Command[]</td><td>撤销命令栈，存储可以撤销的命令</td></tr><tr><td>redoStack</td><td>Command[]</td><td>重做命令栈，存储可以重做的命令</td></tr><tr><td>locked</td><td>boolean</td><td>锁定状态，防止在执行命令时记录新命令</td></tr></tbody></table></div><h4 id="3-2-外部状态-Global-Server-State"><a href="#3-2-外部状态-Global-Server-State" class="headerlink" title="3.2 外部状态 (Global/Server State)"></a>3.2 外部状态 (Global/Server State)</h4><p>Undo/Redo 机制通过 Zustand 状态管理库操作外部状态：</p><div class="table-container"><table><thead><tr><th>状态名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>elements</td><td>Record<string, CanvasElement=""></string,></td><td>所有画布元素数据，命令操作的目标</td></tr></tbody></table></div><h4 id="3-3-状态同步机制"><a href="#3-3-状态同步机制" class="headerlink" title="3.3 状态同步机制"></a>3.3 状态同步机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户操作] --&gt; B{StageManager}<br>    B --&gt; C[创建命令对象]<br>    C --&gt; D[UndoRedoManager.executeCommand]<br>    D --&gt; E{管理器锁定?}<br>    E --&gt;|是| F[忽略命令]<br>    E --&gt;|否| G[执行命令]<br>    G --&gt; H[命令入撤销栈]<br>    H --&gt; I[清空重做栈]<br>    I --&gt; J[Zustand 状态更新]<br>    <br>    subgraph 撤销操作<br>      K[UndoRedoManager.undo]<br>      K --&gt; L{撤销栈空?}<br>      L --&gt;|是| M[无法撤销]<br>      L --&gt;|否| N[弹出命令]<br>      N --&gt; O[执行命令.undo]<br>      O --&gt; P[命令入重做栈]<br>      P --&gt; Q[Zustand 状态更新]<br>    end<br>    <br>    subgraph 重做操作<br>      R[UndoRedoManager.redo]<br>      R --&gt; S{重做栈空?}<br>      S --&gt;|是| T[无法重做]<br>      S --&gt;|否| U[弹出命令]<br>      U --&gt; V[执行命令.redo]<br>      V --&gt; W[命令入撤销栈]<br>      W --&gt; X[Zustand 状态更新]<br>    end<br>    <br>    style A fill:#e1f5fe<br>    style J fill:#e8f5e8<br>    style Q fill:#e8f5e8<br>    style X fill:#e8f5e8<br>    style F fill:#ffebee<br></code></pre></td></tr></table></figure><h3 id="4-命令管理机制"><a href="#4-命令管理机制" class="headerlink" title="4. 命令管理机制"></a>4. 命令管理机制</h3><p>Undo/Redo 机制采用命令模式（Command Pattern）来管理操作命令，通过定义统一的接口和不同的实现类来处理各种操作。</p><h4 id="4-1-命令类型"><a href="#4-1-命令类型" class="headerlink" title="4.1 命令类型"></a>4.1 命令类型</h4><p>系统中主要有两种命令类型：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：用于记录整个画布状态的变化，通常用于添加元素、删除元素等较大范围的操作，保存完整的状态快照</p></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：用于记录特定元素的属性变化，主要用于拖拽移动和调整大小操作，只保存相关元素的特定属性变化</p></li></ol><h4 id="4-2-命令接口定义"><a href="#4-2-命令接口定义" class="headerlink" title="4.2 命令接口定义"></a>4.2 命令接口定义</h4><p>所有命令都实现统一的 <a href="/src/lib/UndoRedoManager.ts#L3-L7">Command</a> 接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 撤销命令</span><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重做命令</span><br>}<br></code></pre></td></tr></table></figure><h4 id="4-3-快照命令（SnapshotCommand）"><a href="#4-3-快照命令（SnapshotCommand）" class="headerlink" title="4.3 快照命令（SnapshotCommand）"></a>4.3 快照命令（SnapshotCommand）</h4><p>快照命令用于记录整个画布状态的变化，适用于影响范围较大的操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">prevState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">nextState</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">any</span></span>) {<br>    <span class="hljs-comment">// 使用 structuredClone 进行深拷贝，确保状态隔离</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span> = <span class="hljs-title function_">structuredClone</span>(prevState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span> = <span class="hljs-title function_">structuredClone</span>(nextState);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>    <span class="hljs-comment">// 生成唯一的命令ID用于调试</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() % <span class="hljs-number">1000000</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// execute在添加到命令栈之前已经执行了</span><br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之前的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">prevState</span>);<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 恢复到之后的状态</span><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nextState</span>);<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-4-更新元素命令（UpdateElementCommand）"><a href="#4-4-更新元素命令（UpdateElementCommand）" class="headerlink" title="4.4 更新元素命令（UpdateElementCommand）"></a>4.4 更新元素命令（UpdateElementCommand）</h4><p>更新元素命令用于记录特定元素的属性变化，适用于影响范围较小的精细操作。</p><p><strong>核心实现</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UpdateOperation</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">initialAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改前的属性</span><br>  <span class="hljs-attr">finalAttrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;; <span class="hljs-comment">// 修改后的属性</span><br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">commandId</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operations</span>: <span class="hljs-title class_">UpdateOperation</span>[],</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">operationType</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"更新元素"</span></span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-comment">// 生成唯一命令ID</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandId</span> = <span class="hljs-string">`UpdateElementCommand-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random()</span></span><br><span class="hljs-subst"><span class="hljs-string">      .toString(<span class="hljs-number">36</span>)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .slice(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)}</span>`</span>;<br>  }<br><br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 应用最终状态</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 撤销：恢复到 initialAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">initialAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br><br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-comment">// 重做：恢复到 finalAttrs</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {<br>      updates[op.<span class="hljs-property">id</span>] = op.<span class="hljs-property">finalAttrs</span>;<br>    });<br><br>    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {<br>      <span class="hljs-keyword">const</span> newElements = { ...state.<span class="hljs-property">elements</span> };<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(updates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[id, attrs]</span>) =&gt;</span> {<br>        <span class="hljs-keyword">if</span> (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };<br>      });<br>      <span class="hljs-keyword">return</span> { <span class="hljs-attr">elements</span>: newElements };<br>    });<br>  }<br>}<br></code></pre></td></tr></table></figure><h4 id="4-5-命令生命周期"><a href="#4-5-命令生命周期" class="headerlink" title="4.5 命令生命周期"></a>4.5 命令生命周期</h4><p>命令的生命周期包括创建、执行、撤销和重做四个阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[命令创建] --&gt; B[命令执行]<br>    B --&gt; C{用户操作}<br>    C --&gt;|撤销| D[执行undo方法]<br>    C --&gt;|重做| E[执行redo方法]<br>    D --&gt; F[命令状态切换]<br>    E --&gt; F<br>    F --&gt; G[状态更新完成]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style D fill:#fff3e0<br>    style E fill:#fff3e0<br>    style G fill:#e8f5e8<br></code></pre></td></tr></table></figure><h3 id="5-命令栈管理机制"><a href="#5-命令栈管理机制" class="headerlink" title="5. 命令栈管理机制"></a>5. 命令栈管理机制</h3><p>撤销/重做机制使用两个栈来管理命令历史：</p><ol><li><strong>撤销栈（Undo Stack）</strong>：</li></ol><p>存储用户可以撤销的操作命令，栈顶是最近执行的命令，执行新命令时，命令被推入此栈，执行撤销操作时，命令从此栈弹出并推入重做栈</p><ol><li><strong>重做栈（Redo Stack）</strong>：</li></ol><p>存储用户可以重做的操作命令，在执行撤销操作时，被撤销的命令被推入此栈，执行重做操作时，命令从此栈弹出并推入撤销栈，执行新命令时，此栈被清空</p><h4 id="5-1-命令栈操作流程"><a href="#5-1-命令栈操作流程" class="headerlink" title="5.1 命令栈操作流程"></a>5.1 命令栈操作流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[执行新命令] --&gt; B[命令入撤销栈]<br>    B --&gt; C[清空重做栈]<br>    <br>    D[执行撤销] --&gt; E{撤销栈空?}<br>    E --&gt;|是| F[无操作]<br>    E --&gt;|否| G[弹出命令]<br>    G --&gt; H[执行命令.undo]<br>    H --&gt; I[命令入重做栈]<br>    <br>    J[执行重做] --&gt; K{重做栈空?}<br>    K --&gt;|是| L[无操作]<br>    K --&gt;|否| M[弹出命令]<br>    M --&gt; N[执行命令.redo]<br>    N --&gt; O[命令入撤销栈]<br>    <br>    style A fill:#e1f5fe<br>    style B fill:#f3e5f5<br>    style C fill:#f3e5f5<br>    style D fill:#e1f5fe<br>    style H fill:#fff3e0<br>    style I fill:#fff3e0<br>    style J fill:#e1f5fe<br>    style N fill:#e8f5e8<br>    style O fill:#e8f5e8<br></code></pre></td></tr></table></figure><h4 id="5-2-不同类型的命令"><a href="#5-2-不同类型的命令" class="headerlink" title="5.2 不同类型的命令"></a>5.2 不同类型的命令</h4><p>撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：</p><ol><li><p><strong>快照命令（SnapshotCommand）</strong>：</p><ul><li>用于记录整个画布状态的变化</li><li>通常用于添加元素、删除元素等较大范围的操作</li><li>保存完整的状态快照</li></ul></li><li><p><strong>更新元素命令（UpdateElementCommand）</strong>：</p><ul><li>用于记录特定元素的属性变化</li><li>主要用于拖拽移动和调整大小操作</li><li>只保存相关元素的特定属性变化</li></ul></li></ol><h4 id="5-3-操作序列和撤销栈状态变化示例"><a href="#5-3-操作序列和撤销栈状态变化示例" class="headerlink" title="5.3 操作序列和撤销栈状态变化示例"></a>5.3 操作序列和撤销栈状态变化示例</h4><h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><p>撤销栈：空<br>重做栈：空</p><h5 id="1-创建元素-A"><a href="#1-创建元素-A" class="headerlink" title="1. 创建元素 A"></a>1. 创建元素 A</h5><p>当创建元素 A 时，系统会生成一个快照命令，记录整个画布状态的变化。<br>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：空</p><h5 id="2-移动-A-到一个位置"><a href="#2-移动-A-到一个位置" class="headerlink" title="2. 移动 A 到一个位置"></a>2. 移动 A 到一个位置</h5><p>当移动元素 A 时，系统会生成一个更新元素命令（UpdateElementCommand），只记录 A 元素位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：空</p><h5 id="3-创建元素-B"><a href="#3-创建元素-B" class="headerlink" title="3. 创建元素 B"></a>3. 创建元素 B</h5><p>当创建元素 B 时，系统会生成另一个快照命令，记录添加 B 元素后的状态。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：空</p><h5 id="4-缩放-B-到一个位置"><a href="#4-缩放-B-到一个位置" class="headerlink" title="4. 缩放 B 到一个位置"></a>4. 缩放 B 到一个位置</h5><p>当缩放元素 B 时，系统会生成一个更新元素命令，记录 B 元素尺寸和位置的变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：空</p><h5 id="5-移动-B-到一个位置"><a href="#5-移动-B-到一个位置" class="headerlink" title="5. 移动 B 到一个位置"></a>5. 移动 B 到一个位置</h5><p>当再次移动元素 B 时，系统会生成另一个更新元素命令，记录 B 元素位置的新变化。<br>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5)<br>重做栈：空</p><h4 id="5-4-执行撤销操作时的状态变化"><a href="#5-4-执行撤销操作时的状态变化" class="headerlink" title="5.4 执行撤销操作时的状态变化"></a>5.4 执行撤销操作时的状态变化</h4><h5 id="第一次撤销（移动-B-操作）"><a href="#第一次撤销（移动-B-操作）" class="headerlink" title="第一次撤销（移动 B 操作）"></a>第一次撤销（移动 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB</li><li>执行该命令的 undo()方法，将 B 元素恢复到缩放后的位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)<br>重做栈：[UpdateElementCommand_MoveB] (大小: 1)</p><h5 id="第二次撤销（缩放-B-操作）"><a href="#第二次撤销（缩放-B-操作）" class="headerlink" title="第二次撤销（缩放 B 操作）"></a>第二次撤销（缩放 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB</li><li>执行该命令的 undo()方法，将 B 元素恢复到刚创建时的尺寸和位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)</p><h5 id="第三次撤销（创建-B-操作）"><a href="#第三次撤销（创建-B-操作）" class="headerlink" title="第三次撤销（创建 B 操作）"></a>第三次撤销（创建 B 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_B</li><li>执行该命令的 undo()方法，将整个画布状态恢复到创建 B 之前的状态（即只包含 A 元素的状态）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)</p><h5 id="第四次撤销（移动-A-操作）"><a href="#第四次撤销（移动-A-操作）" class="headerlink" title="第四次撤销（移动 A 操作）"></a>第四次撤销（移动 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA</li><li>执行该命令的 undo()方法，将 A 元素恢复到初始位置</li><li>将该命令推入重做栈</li></ol><p>撤销栈：[SnapshotCommand_A] (大小: 1)<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)</p><h5 id="第五次撤销（创建-A-操作）"><a href="#第五次撤销（创建-A-操作）" class="headerlink" title="第五次撤销（创建 A 操作）"></a>第五次撤销（创建 A 操作）</h5><ol><li>从撤销栈弹出最后一个命令：SnapshotCommand_A</li><li>执行该命令的 undo()方法，将整个画布状态恢复到初始状态（空画布）</li><li>将该命令推入重做栈</li></ol><p>撤销栈：空<br>重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)</p><h3 id="6-逻辑流程-Logic-Flow"><a href="#6-逻辑流程-Logic-Flow" class="headerlink" title="6. 逻辑流程 (Logic Flow)"></a>6. 逻辑流程 (Logic Flow)</h3><h4 id="6-1-交互时序图-Mermaid"><a href="#6-1-交互时序图-Mermaid" class="headerlink" title="6.1 交互时序图 (Mermaid)"></a>6.1 交互时序图 (Mermaid)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    participant U as 用户<br>    participant SM as StageManager<br>    participant URM as UndoRedoManager<br>    participant C as Command<br>    participant ZS as Zustand Store<br>    <br>    U-&gt;&gt;SM: 执行操作（如拖拽元素）<br>    SM-&gt;&gt;SM: 记录操作初始状态<br>    SM-&gt;&gt;ZS: 更新元素状态<br>    SM-&gt;&gt;C: 创建 UpdateElementCommand<br>    SM-&gt;&gt;URM: executeCommand(command)<br>    URM-&gt;&gt;C: command.execute()<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 清空重做栈<br>    <br>    U-&gt;&gt;URM: 执行撤销 (Ctrl+Z)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.undo()<br>    C-&gt;&gt;ZS: 恢复初始状态<br>    C-&gt;&gt;URM: 命令入重做栈<br>    URM-&gt;&gt;URM: 解锁管理器<br>    <br>    U-&gt;&gt;URM: 执行重做 (Ctrl+Y)<br>    URM-&gt;&gt;URM: 锁定管理器<br>    URM-&gt;&gt;C: command.redo()<br>    C-&gt;&gt;ZS: 恢复最终状态<br>    C-&gt;&gt;URM: 命令入撤销栈<br>    URM-&gt;&gt;URM: 解锁管理器<br></code></pre></td></tr></table></figure><h4 id="6-2-核心函数解析"><a href="#6-2-核心函数解析" class="headerlink" title="6.2 核心函数解析"></a>6.2 核心函数解析</h4><p><strong>executeCommand 函数</strong>：当用户完成一个操作（如创建、更新、删除元素）时触发，执行命令并将命令添加到撤销栈，同时清空重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">executeCommand</span>(<span class="hljs-params"><span class="hljs-attr">command</span>: <span class="hljs-title class_">Command</span></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">locked</span>) {<br>    <span class="hljs-comment">// 如果管理器被锁定，忽略命令</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-comment">// 执行命令</span><br>  command.<span class="hljs-title function_">execute</span>()<br><br>  <span class="hljs-comment">// 将命令添加到撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)<br><br>  <span class="hljs-comment">// 清空重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span> = []<br>}<br></code></pre></td></tr></table></figure><p><strong>undo 函数</strong>：当用户执行撤销操作（如按 Ctrl+Z）时触发，从撤销栈弹出命令，执行命令的 undo 方法，并将命令放入重做栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">undo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 撤销栈为空，无法撤销</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">undo</span>()  <span class="hljs-comment">// 执行撤销</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入重做栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><p><strong>redo 函数</strong>：当用户执行重做操作（如按 Ctrl+Y）时触发，从重做栈弹出命令，执行命令的 redo 方法，并将命令放入撤销栈</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">redo</span>(<span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 重做栈为空，无法重做</span><br>    <span class="hljs-keyword">return</span><br>  }<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">lock</span>()  <span class="hljs-comment">// 锁定管理器</span><br>  <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">redoStack</span>.<span class="hljs-title function_">pop</span>()!  <span class="hljs-comment">// 弹出命令</span><br>  command.<span class="hljs-title function_">redo</span>()  <span class="hljs-comment">// 执行重做</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">undoStack</span>.<span class="hljs-title function_">push</span>(command)  <span class="hljs-comment">// 命令入撤销栈</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unlock</span>()  <span class="hljs-comment">// 解锁管理器</span><br>}<br></code></pre></td></tr></table></figure><h3 id="7-UI-与样式实现-UI-Implementation"><a href="#7-UI-与样式实现-UI-Implementation" class="headerlink" title="7. UI 与样式实现 (UI Implementation)"></a>7. UI 与样式实现 (UI Implementation)</h3><p>Undo/Redo 机制通过快捷键和控制台界面与用户交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互方式}<br>    B --&gt; C[键盘快捷键]<br>    B --&gt; D[控制台界面]<br>    C --&gt; E[Ctrl+Z 撤销]<br>    C --&gt; F[Ctrl+Y 重做]<br>    D --&gt; G[命令栈控制台]<br>    G --&gt; H[撤销按钮]<br>    G --&gt; I[重做按钮]<br>    G --&gt; J[清空按钮]<br>    <br>    style A fill:#e1f5fe<br>    style C fill:#f3e5f5<br>    style D fill:#f3e5f5<br>    style E fill:#e8f5e8<br>    style F fill:#e8f5e8<br>    style G fill:#fff3e0<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-模块摘要-Executive-Summary&quot;&gt;&lt;a href=&quot;#1-模块摘要-Executive-Summary&quot; class=&quot;headerlink&quot; title=&quot;1. 模块摘要 (Executive Summary)&quot;&gt;&lt;/a&gt;1. 模块摘要 (Ex</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="状态管理" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
