<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes|笔记站</title>
  
  
  <link href="https://zhongye1.github.io/Arknight-notes/rss.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/Arknight-notes/"/>
  <updated>2025-12-29T07:44:54.292Z</updated>
  <id>https://zhongye1.github.io/Arknight-notes/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025-12-29-关于画布项目的相关考虑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/2357.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/2357.html</id>
    <published>2025-12-28T20:52:15.000Z</published>
    <updated>2025-12-29T07:44:54.292Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 仓库 <a href="https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>该项目技术栈先进（React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8），涉及高性能渲染、无限画布、撤销/重做、实时协作等复杂功能，因此问题往往聚焦于性能优化、状态管理、图形渲染、架构设计以及实际工程实践。</p><h3 id="1-项目整体介绍与架构设计"><a href="#1-项目整体介绍与架构设计" class="headerlink" title="1. 项目整体介绍与架构设计"></a>1. 项目整体介绍与架构设计</h3><h4 id="项目的主要功能、目标用户以及它解决了哪些实际问题？"><a href="#项目的主要功能、目标用户以及它解决了哪些实际问题？" class="headerlink" title="项目的主要功能、目标用户以及它解决了哪些实际问题？"></a><strong>项目的主要功能、目标用户以及它解决了哪些实际问题？</strong></h4><blockquote><p>BDdraw_DEV 是一个现代化的协同 2D 画布编辑器，采用 React + TypeScript + PixiJS 技术栈构建。该项目提供多种基本图形（矩形、圆形、菱形、线条、箭头、画笔等）元素的绘制，支持背景色、边框宽度、边框颜色等图形属性设置、富文本编辑、图片插入与滤镜处理，支持无限画布缩放、拖拽、提供 minimap，实现元素选择、分组、旋转、调整大小，支持撤销重做，快捷键，数据持久化，本地优先编辑，海量元素处理等交互功能。</p><p>该项目作为一个集成协同编辑、离线编辑的无限画布，来解决团队协作协作效率和同步的问题</p></blockquote><h4 id="项目架构是如何设计的？为什么选择将-React-用于-UI-层、Zustand-用于状态管理、PixiJS-用于渲染层分离？"><a href="#项目架构是如何设计的？为什么选择将-React-用于-UI-层、Zustand-用于状态管理、PixiJS-用于渲染层分离？" class="headerlink" title="项目架构是如何设计的？为什么选择将 React 用于 UI 层、Zustand 用于状态管理、PixiJS 用于渲染层分离？"></a><strong>项目架构是如何设计的？为什么选择将 React 用于 UI 层、Zustand 用于状态管理、PixiJS 用于渲染层分离？</strong></h4><blockquote><p>项目的核心在于其三层架构设计：React 负责 UI 层、Zustand 管理状态层、PixiJS 处理渲染层，实现数据驱动视图的模式。其便于实现撤销/重做、数据持久化和多人协同编辑等高级功能</p><p>其优势在于：<br>解耦设计：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展<br>便于协同：所有状态都集中管理在 Zustand Store 中，便于实现多人协同编辑<br>易于撤销/重做：通过保存和恢复 Store 的快照实现完整的撤销/重做功能<br>可持久化：状态数据可以轻松序列化/反序列化，便于保存和传输</p></blockquote><h4 id="项目是如何组织目录结构的？这种模块化设计带来了哪些好处？"><a href="#项目是如何组织目录结构的？这种模块化设计带来了哪些好处？" class="headerlink" title="项目是如何组织目录结构的？这种模块化设计带来了哪些好处？"></a><strong>项目是如何组织目录结构的？这种模块化设计带来了哪些好处？</strong></h4><p>前端部分主要是分为五个模块：</p><h5 id="src-api-API-客户端和类型定义（处理前后端通信）"><a href="#src-api-API-客户端和类型定义（处理前后端通信）" class="headerlink" title="src/api - API 客户端和类型定义（处理前后端通信）"></a>src/api - API 客户端和类型定义（处理前后端通信）</h5><ul><li>types - API 类型定义</li><li>utils - API 工具函数</li><li>API 服务封装和客户端工具</li></ul><h5 id="src-components-React-UI-组件（各种-UI-组件）"><a href="#src-components-React-UI-组件（各种-UI-组件）" class="headerlink" title="src/components - React UI 组件（各种 UI 组件）"></a>src/components - React UI 组件（各种 UI 组件）</h5><ul><li>canvas_toolbar - 画布工具栏组件</li><li>collaboration - 协作功能组件</li><li>header - 页面头部组件</li><li>property-panel - 属性面板组件</li><li>richtext_editor - 富文本编辑器组件</li></ul><h5 id="src-hooks-自定义-React-Hooks"><a href="#src-hooks-自定义-React-Hooks" class="headerlink" title="src/hooks - 自定义 React Hooks"></a>src/hooks - 自定义 React Hooks</h5><ul><li>状态管理（简单的本地存储，用于存储用户偏好、UI 状态等）</li><li>快捷键处理</li></ul><h5 id="src-lib-工具库和核心功能模块"><a href="#src-lib-工具库和核心功能模块" class="headerlink" title="src/lib - 工具库和核心功能模块"></a>src/lib - 工具库和核心功能模块</h5><ul><li>AddElementCommand.ts、RemoveElementCommand.ts、UndoRedoManager.ts - 命令模式实现</li><li>constants.ts - 常量定义</li><li>utils.ts - 通用工具函数</li></ul><h5 id="src-pages-页面组件"><a href="#src-pages-页面组件" class="headerlink" title="src/pages - 页面组件"></a>src/pages - 页面组件</h5><ul><li>auth - 认证相关页面</li><li>home - 主页</li><li>room - 房间管理页面</li><li><p><strong>canvas/Pixi_STM_modules - Pixi.js 状态管理模块</strong></p><ul><li>core - 核心类和初始化逻辑</li><li>interaction - 交互处理模块（例如拖拽、缩放、选择等）</li><li>utils - 工具函数目录（各项操作的封装）</li><li>shared - 共享类型定义</li></ul></li></ul><h5 id="src-stores-状态管理（Yjs-IndexedDB-复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）"><a href="#src-stores-状态管理（Yjs-IndexedDB-复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）" class="headerlink" title="src/stores - 状态管理（Yjs + IndexedDB - 复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）"></a>src/stores - 状态管理（Yjs + IndexedDB - 复杂的协同数据存储，用于存储画布元素数据，支持实时协同和离线编辑）</h5><ul><li>canvasStore.ts - 画布状态管理</li><li>persistenceStore.ts - 持久化状态管理</li><li>themeStore.ts - 主题状态管理</li></ul><p>后端部分的设计：</p><ul><li><strong>房间管理系统</strong> - 支持创建、修改、删除和查询房间</li><li><strong>用户认证系统</strong> - 提供用户登录、注册和权限验证</li><li><strong>实时协作支持</strong> - 通过  collab.ts  实现</li><li><strong>数据库</strong> - 通过  db.ts  连接和操作数据库</li></ul><p>数据库设计（sqlite，原型验证阶段所使用）</p><p class='item-img' data-src='https://pica.zhimg.com/80/v2-466ea97d53037f5c8505d87a87c2e52e_720w.webp'><img src="https://pica.zhimg.com/80/v2-466ea97d53037f5c8505d87a87c2e52e_720w.webp" alt=""></p><p>每个房间的画布数据在对应表中的 content 中</p><h4 id="项目中如何处理前端与后端（ALD-Backend）的交互？"><a href="#项目中如何处理前端与后端（ALD-Backend）的交互？" class="headerlink" title="项目中如何处理前端与后端（ALD_Backend）的交互？"></a><strong>项目中如何处理前端与后端（ALD_Backend）的交互？</strong></h4><blockquote><p>该项目前后端分离，交互采用 REST API（表现层状态转移应用编程接口，是一种基于 REST 架构风格设计的 Web API），前端通过 TypeScript 封装的 API 层统一管理所有 HTTP 请求，使用 Axios 作为 HTTP 客户端，配置了请求和响应拦截器来处理认证、错误处理和加载状态。其通过环境变量管理不同环境的基础 URL，定义了统一的响应格式和类型定义来确保类型安全，同时并在需要实时协作的场景下使用 WebSocket 进行双向通信。</p></blockquote><p>Axios 是一个基于 Promise 的网络请求库，用于在浏览器和 Node.js 中进行 HTTP 请求，并支持请求/响应拦截、取消，并发请求，自动转换数据等功能</p><p>详情见博客文章：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/16956.html">前端学习-接口类型定义、Axios 封装与请求规范 | 笔记站 (zhongye1.github.io)</a></p><p>身份验证管理实现：</p><ul><li>使用 JWT Token 进行身份验证</li><li>通过  setAuthToken  和  clearAuthToken  管理认证状态</li><li><code>onAuthenticate</code>  钩子验证用户权限</li></ul><p>详情见博客文章：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/42304.html">前端学习-身份验证管理-基于 JWT Token 的实现 (zhongye1.github.io)</a></p><hr><p><strong>实时协作部分是如何实现的？</strong></p><p>实时协作功能通过 Yjs、Hocuspocus 和 IndexedDB 实现：</p><p>可以看博客：</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/60473.html">2025-12-27-前端画布设计 Vol.3 实现 CRDT | Notes|笔记站 (zhongye1.github.io)</a></p><ol><li>前端(react)</li></ol><ul><li>使用 Yjs 的 CRDT 数据结构实现多客户端状态同步</li><li>通过  <code>HocuspocusProvider</code>  连接到后端 WebSocket 服务器</li><li>结合 IndexedDB 持久化，实现离线编辑功能</li></ul><ol><li>后端（bun）</li></ol><ul><li>使用 Hocuspocus 作为 Yjs 的协作服务器</li><li>实现了数据库扩展，将 Yjs 文档状态持久化到 SQLite 数据库</li><li>通过 WebSocket 协议处理实时通信</li></ul><ol><li>认证与权限控制</li></ol><ul><li>WebSocket 连接需要 JWT Token 认证</li><li>服务器验证用户是否有权限访问特定房间</li><li>如果用户没有访问权限，会自动将其添加到房间成员中</li></ul><ol><li>数据同步</li></ol><ul><li>前端使用 Yjs 的  <code>Y.Map</code>  存储画布元素数据</li><li>通过  <code>IndexeddbPersistence</code>  将数据持久化到浏览器的 IndexedDB</li><li>使用  <code>HocuspocusProvider</code>  将数据同步到服务器和其他客户端</li></ul><ol><li>在线/离线处理</li></ol><ul><li>当用户在线时，数据实时同步到服务器</li><li>当用户离线时，数据保存在本地 IndexedDB 中</li><li>重新连接后，本地更改会自动同步到服务器（CRDT）</li></ul><ol><li>用户状态管理</li></ol><ul><li>使用 Yjs 的 Awareness 功能跟踪在线用户</li><li>广播机制实时显示协作者的光标位置和选中状态</li><li>通过后端认证机制确保只有授权用户可以加入协作</li></ul><hr><h3 id="2-状态管理（Zustand）"><a href="#2-状态管理（Zustand）" class="headerlink" title="2. 状态管理（Zustand）"></a>2. 状态管理（Zustand）</h3><p>Zustand 是项目核心状态工具，轻量且无 boilerplate。</p><ul><li>为什么选择 Zustand 而非 Redux 或 Context API？在画布状态管理中，它相比其他方案的优势体现在哪里？</li></ul><blockquote><pre><code>Zustand 的 API 设计非常简洁，避免了 Redux 中大量样板代码（boilerplate code）的问题。在 Redux 中，我们需要定义 actions、reducers、store 等多个部分，而 Zustand 只需一个函数即可创建 storeZustand 在性能优化方面，可以实现选择性订阅，避免不必要的组件重新渲染。Context API 在状态更新时会触发所有子组件的重新渲染，而 Zustand 允许我们精确地控制哪些组件需要响应特定状态变化。</code></pre></blockquote><ul><li>如何使用 Zustand 管理画布元素状态（elements: Record<string, CanvasElement="">）？如何实现持久化（Zustand-persist + localForage + IndexedDB）？</string,></li></ul><h4 id="如何使用-Zustand-管理画布元素状态？"><a href="#如何使用-Zustand-管理画布元素状态？" class="headerlink" title="如何使用 Zustand 管理画布元素状态？"></a>如何使用 Zustand 管理画布元素状态？</h4><p>在我们的项目中，画布元素状态是通过  CanvasState  接口定义的，其中  elements  属性是一个  <code>Record&lt;string, CanvasElement&gt;</code>  类型的对象，用于存储所有画布元素：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[];<br>  <span class="hljs-comment">// ... 其他状态</span><br>}<br></code></pre></td></tr></table></figure><p>我们通过直接操作 Yjs 共享数据类型来管理元素状态，从而实现协同编辑功能：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 添加元素</span><br><span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    currentYElements?.<span class="hljs-title function_">set</span>(el.<span class="hljs-property">id</span>, el)<br>  })<br>},<br><br><span class="hljs-comment">// 更新元素</span><br><span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params">id, attrs</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">const</span> oldEl = currentYElements?.<span class="hljs-title function_">get</span>(id)<br>    <span class="hljs-keyword">if</span> (oldEl) {<br>      currentYElements?.<span class="hljs-title function_">set</span>(id, { ...oldEl, ...attrs })<br>    }<br>  })<br>},<br><br><span class="hljs-comment">// 删除元素</span><br><span class="hljs-attr">removeElements</span>: <span class="hljs-function">(<span class="hljs-params">ids</span>) =&gt;</span> {<br>  currentYDoc?.<span class="hljs-title function_">transact</span>(<span class="hljs-function">() =&gt;</span> {<br>    ids.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> currentYElements?.<span class="hljs-title function_">delete</span>(id))<br>  })<br>}<br></code></pre></td></tr></table></figure><h4 id="如何实现持久化（Zustand-persist-localForage-IndexedDB）？"><a href="#如何实现持久化（Zustand-persist-localForage-IndexedDB）？" class="headerlink" title="如何实现持久化（Zustand-persist + localForage + IndexedDB）？"></a>如何实现持久化（Zustand-persist + localForage + IndexedDB）？</h4><p>在我们的实现中，持久化是通过 Yjs 的 IndexedDB 持久化机制完成的，而不是使用传统的 zustand-persist。我们使用  IndexeddbPersistence  与 HocuspocusProvider 组合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 persistenceStore.ts 中创建持久化提供者</span><br><span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<br>  <span class="hljs-string">`canvas-local-db-<span class="hljs-subst">${roomId}</span>`</span>,<br>  yDoc<br>);<br></code></pre></td></tr></table></figure><p>这种设计的优势在于:</p><ol><li>Yjs 会自动处理 IndexedDB 的读写操作，无需手动管理</li><li>提供了离线支持，即使在断网情况下数据也能保存在本地</li><li>当重新连接网络时，会自动同步本地和远程数据</li><li>IndexedDB 的异步操作不会阻塞 UI 线程，保证了应用的响应性</li></ol><h4 id="在多用户协作场景下，Zustand-与-Y-js-CRDT-如何结合？如何处理冲突和状态同步？"><a href="#在多用户协作场景下，Zustand-与-Y-js-CRDT-如何结合？如何处理冲突和状态同步？" class="headerlink" title="在多用户协作场景下，Zustand 与 Y.js CRDT 如何结合？如何处理冲突和状态同步？"></a>在多用户协作场景下，Zustand 与 Y.js CRDT 如何结合？如何处理冲突和状态同步？</h4><p>Zustand 作为前端状态管理工具，提供状态访问接口<br>Y.js 作为协同编辑引擎，处理多用户间的数据同步和冲突解决<br>通过 Y.js 的 observe 机制，将 Y.js 的数据变化同步到 Zustand 状态中</p><h3 id="3-高性能渲染与-PixiJS-集成"><a href="#3-高性能渲染与-PixiJS-集成" class="headerlink" title="3. 高性能渲染与 PixiJS 集成"></a>3. 高性能渲染与 PixiJS 集成</h3><p>PixiJS WebGL 渲染是项目性能关键，面试官会深入考察。</p><h4 id="为什么引入-PixiJS-而非纯-Canvas-或-SVG？它在实现-60-FPS-和无限画布时发挥了什么作用？"><a href="#为什么引入-PixiJS-而非纯-Canvas-或-SVG？它在实现-60-FPS-和无限画布时发挥了什么作用？" class="headerlink" title="为什么引入 PixiJS 而非纯 Canvas 或 SVG？它在实现 60 FPS 和无限画布时发挥了什么作用？"></a>为什么引入 PixiJS 而非纯 Canvas 或 SVG？它在实现 60 FPS 和无限画布时发挥了什么作用？</h4><blockquote><pre><code>PixiJS 是一个基于 WebGL 的 2D 渲染引擎，它具有极高的性能优势，可以充分利用 GPU 加速。相比纯 Canvas API，PixiJS 提供了更高层次的抽象，开发者无需手动管理底层的渲染细节，同时能够获得更好的性能表现。与 SVG 相比，PixiJS 在处理大量图形元素时表现更佳。SVG 是基于 DOM 的，当元素数量增加时，DOM 操作的开销会显著增加，导致性能下降。而 PixiJS 直接在 GPU 层面进行渲染，即使处理数千个元素也能保持流畅性能。对于无限画布的实现，PixiJS 提供了强大的 pixi-viewport 插件，它可以处理大规模场景的渲染优化。通过视口裁剪（view culling）技术，PixiJS 只渲染当前可见区域内的元素，大幅减少了渲染开销。</code></pre></blockquote><h4 id="如何使用-pixi-viewport-实现无限画布的缩放、平移和边界限制？"><a href="#如何使用-pixi-viewport-实现无限画布的缩放、平移和边界限制？" class="headerlink" title="如何使用 pixi-viewport 实现无限画布的缩放、平移和边界限制？"></a>如何使用 pixi-viewport 实现无限画布的缩放、平移和边界限制？</h4><p>实现缩放、平移和边界限制：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Stage_InteractionHandler.ts 中实现视口功能</span><br>viewport<br>  .<span class="hljs-title function_">drag</span>() <span class="hljs-comment">// 启用拖拽平移</span><br>  .<span class="hljs-title function_">pinch</span>() <span class="hljs-comment">// 启用双指缩放</span><br>  .<span class="hljs-title function_">wheel</span>() <span class="hljs-comment">// 启用滚轮缩放</span><br>  .<span class="hljs-title function_">clamp</span>({ <span class="hljs-attr">direction</span>: <span class="hljs-string">"all"</span> }) <span class="hljs-comment">// 边界限制</span><br>  .<span class="hljs-title function_">bounce</span>(); <span class="hljs-comment">// 边界弹性效果</span><br></code></pre></td></tr></table></figure><p>缩放功能通过 pinch 和 wheel 插件实现，用户可以通过双指手势或鼠标滚轮进行缩放。平移功能通过 drag 插件实现，用户可以拖拽画布。clamp 功能用于限制视口边界，防止用户将视口拖拽到画布内容之外的区域。</p><p>viewport 提供多个配置选项，如缩放级别限制、平滑动画等</p><h4 id="项目中如何缓存-PixiJS-对象（spriteMap）以避免拖拽-缩放时的重复创建？这对性能有何影响？"><a href="#项目中如何缓存-PixiJS-对象（spriteMap）以避免拖拽-缩放时的重复创建？这对性能有何影响？" class="headerlink" title="项目中如何缓存 PixiJS 对象（spriteMap）以避免拖拽/缩放时的重复创建？这对性能有何影响？"></a>项目中如何缓存 PixiJS 对象（spriteMap）以避免拖拽/缩放时的重复创建？这对性能有何影响？</h4><p>在项目中，我们使用  spriteMap  来缓存 PixiJS 对象，避免在拖拽、缩放等操作中重复创建和销毁元素。spriteMap  是一个以元素 ID 为键的 Map，存储了每个画布元素对应的 PixiJS 显示对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Pixi_stageManager.ts 中定义</span><br>spriteMap <span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br></code></pre></td></tr></table></figure><p>当画布元素更新时，我们首先检查  spriteMap  中是否已存在对应的显示对象，如果存在则直接更新其属性，而不是创建新的对象。</p><ol><li>减少了对象创建和垃圾回收的开销</li><li>提高了渲染效率，因为现有对象只需更新属性而非重新创建</li><li>保持了对象状态的连续性，例如动画状态、事件监听器等</li></ol><h4 id="图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在-PixiJS-中实现的？遇到过哪些渲染挑战？"><a href="#图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在-PixiJS-中实现的？遇到过哪些渲染挑战？" class="headerlink" title="图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在 PixiJS 中实现的？遇到过哪些渲染挑战？"></a>图像滤镜（BlurFilter、ColorMatrixFilter）和富文本（HTMLText）是如何在 PixiJS 中实现的？遇到过哪些渲染挑战？</h4><p>在项目中，我们使用 PixiJS 的滤镜系统实现图像效果。对于 BlurFilter 和 ColorMatrixFilter 等滤镜，我们通过以下方式应用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BlurFilter</span>, <span class="hljs-title class_">ColorMatrixFilter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"pixi.js"</span>;<br><br><span class="hljs-comment">// 为图像元素添加滤镜</span><br><span class="hljs-keyword">const</span> blurFilter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlurFilter</span>();<br><span class="hljs-keyword">const</span> colorFilter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorMatrixFilter</span>();<br><br>sprite.<span class="hljs-property">filters</span> = [blurFilter, colorFilter];<br></code></pre></td></tr></table></figure><p>对于富文本渲染，我们使用了 pixi-text-html 库，它允许我们在 PixiJS 中渲染 HTML 样式的文本。HTMLText 组件可以解析 HTML 标签并渲染出格式化的文本。</p><h4 id="小地图（Minimap）如何通过-cacheAsBitmap-实现实时更新？为什么需要单独的-Pixi-Application？"><a href="#小地图（Minimap）如何通过-cacheAsBitmap-实现实时更新？为什么需要单独的-Pixi-Application？" class="headerlink" title="小地图（Minimap）如何通过 cacheAsBitmap 实现实时更新？为什么需要单独的 Pixi Application？"></a>小地图（Minimap）如何通过 cacheAsBitmap 实现实时更新？为什么需要单独的 Pixi Application？</h4><p>小地图的实现主要通过 cacheAsBitmap 属性来优化性能。cacheAsBitmap 将显示对象及其子对象渲染到一个内部纹理中，后续渲染只需绘制该纹理，而无需重新计算所有子对象的渲染，从而大幅提升性能。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">stage.<span class="hljs-property">cacheAsBitmap</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>小地图需要单独的 Pixi Application 实例，主要原因包括：</p><p>性能隔离：小地图的渲染频率可能与主画布不同，独立的实例可以更好地控制渲染性能<br>独立交互：小地图可能需要独立的交互逻辑，如点击跳转到画布特定位置<br>资源管理：独立的实例可以更好地管理小地图相关的纹理和资源<br>缩放独立性：小地图需要保持固定比例的缩略图，独立的渲染上下文更容易实现这一功能</p><h3 id="4-撤销-重做机制（命令模式）"><a href="#4-撤销-重做机制（命令模式）" class="headerlink" title="4. 撤销/重做机制（命令模式）"></a>4. 撤销/重做机制（命令模式）</h3><h4 id="项目中撤销-重做是如何实现的？为什么采用-Command-Pattern？"><a href="#项目中撤销-重做是如何实现的？为什么采用-Command-Pattern？" class="headerlink" title="项目中撤销/重做是如何实现的？为什么采用 Command Pattern？"></a>项目中撤销/重做是如何实现的？为什么采用 Command Pattern？</h4><p>撤销/重做功能是通过命令模式（Command Pattern）实现的。我们定义了一个  Command  接口，它包含  execute、undo  和  redo  三个方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">execute</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">undo</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">redo</span>(): <span class="hljs-built_in">void</span>;<br>}<br></code></pre></td></tr></table></figure><p>我们为不同类型的画布操作创建了相应的命令类，如  AddElementCommand、RemoveElementCommand  和  UpdateElementCommand  等。每个命令类都保存了执行操作所需的信息，能够在  undo  和  redo  时恢复到相应的状态。</p><p>采用命令模式的主要原因有以下几点：</p><p><strong>解耦</strong>：命令模式将操作的执行者与请求者解耦，使我们可以轻松地添加新的命令类型而无需修改现有代码。<br><strong>状态一致性</strong>：在协同编辑环境中，命令模式确保所有操作都可以被准确地撤销和重做，保持状态一致性。<br><strong>易于扩展</strong>：我们可以轻松地添加新的命令类型，如分组、取消分组等。</p><h4 id="每个命令（如-AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？"><a href="#每个命令（如-AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？" class="headerlink" title="每个命令（如 AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？"></a>每个命令（如 AddElementCommand、UpdateElementCommand）如何存储前后状态快照（structuredClone）？这在内存和性能上有哪些权衡？</h4><h5 id="AddElementCommand-的撤销与重做实现"><a href="#AddElementCommand-的撤销与重做实现" class="headerlink" title="AddElementCommand 的撤销与重做实现"></a>AddElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">payload</span>: { element: CanvasElement }</span>) {}<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 添加元素到画布</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 从画布移除元素，实现撤销</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>.<span class="hljs-property">id</span>]);<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重新添加元素，实现重做（与 execute 相同）</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>);<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：通过移除新增的元素恢复原状态，仅需元素 ID。</li><li><strong>重做（redo）</strong>：直接重复添加操作，无需额外存储数据。</li></ul><h5 id="RemoveElementCommand-的撤销与重做实现"><a href="#RemoveElementCommand-的撤销与重做实现" class="headerlink" title="RemoveElementCommand 的撤销与重做实现"></a>RemoveElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">elementData</span>: <span class="hljs-title class_">CanvasElement</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">payload</span>: { element: CanvasElement }</span>) {}<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 先保存被移除元素的完整数据（用于后续恢复）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span> = { ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span> };<br>    <span class="hljs-comment">// 执行移除</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">payload</span>.<span class="hljs-property">element</span>.<span class="hljs-property">id</span>]);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 使用保存的数据重新添加元素，实现撤销移除</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>) {<br>      useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">addElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>);<br>    }<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重复移除操作，实现重做</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>) {<br>      useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">removeElements</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>.<span class="hljs-property">id</span>]);<br>    }<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：依赖 execute 时存储的元素完整数据进行恢复。</li><li><strong>重做（redo）</strong>：使用存储的数据重复移除，避免直接依赖外部状态。</li></ul><h5 id="UpdateElementCommand-的撤销与重做实现"><a href="#UpdateElementCommand-的撤销与重做实现" class="headerlink" title="UpdateElementCommand 的撤销与重做实现"></a>UpdateElementCommand 的撤销与重做实现</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateElementCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">previousValues</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">elementId</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-attr">newValues</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-comment">// 在构造函数中保存更新前的属性值（旧状态）</span><br>    <span class="hljs-keyword">const</span> currentState = useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-property">elements</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span> = {};<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(newValues).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span>[key <span class="hljs-keyword">as</span> keyof <span class="hljs-title class_">CanvasElement</span>] =<br>        currentState[key <span class="hljs-keyword">as</span> keyof <span class="hljs-title class_">CanvasElement</span>];<br>    });<br>  }<br><br>  execute = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 应用新值</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">newValues</span>);<br>  };<br><br>  undo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 恢复旧值，实现撤销</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">previousValues</span>);<br>  };<br><br>  redo = <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-comment">// 重新应用新值，实现重做（与 execute 相同）</span><br>    useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">updateElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementId</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">newValues</span>);<br>  };<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>撤销（undo）</strong>：通过存储的 previousValues 恢复属性原值。</li><li><strong>重做（redo）</strong>：重复应用新值，确保操作可重复性。</li></ul><p>此设计的核心原则是：在命令对象中存储足够的信息（而非完整状态快照），以独立实现 undo 和 redo 操作，从而支持高效的命令模式撤销/重做栈管理。</p><p>在内存和性能上的权衡包括：</p><ol><li><strong>内存占用</strong>：每个命令都需要保存足够的信息来执行撤销/重做操作，这会增加内存使用。特别是  SnapshotCommand  会保存整个状态的副本，这在元素较多时会占用大量内存。</li><li><strong>性能影响</strong>：创建状态快照需要时间，特别是当画布中有大量元素时。使用  <code>structuredClone</code>  深拷贝大型对象会影响性能。</li><li><strong>存储优化</strong>：为减少内存占用，我们对不同的操作采用不同的存储策略。对于添加/删除操作，只需存储元素本身；对于更新操作，只需存储变更前的值和变更的属性。</li></ol><h4 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h4><p>限制历史栈大小以防止内存溢出<br>对于连续的多个操作，可以合并成一个批量命令，减少栈中命令的数量<br>对于包含大量数据的命令，如图像元素操作，可以在命令不再需要时清理其内部引用的数据<br>对于频繁的操作（如拖拽移动），可以使用防抖机制将连续操作合并为一个命令，减少命令栈的增长速度<br>操作分组：将相关的连续操作视为一个逻辑操作，例如，将创建一个复杂图形的多个步骤合并为一个撤销单位<br>操作描述：为每个命令添加描述，让用户在 UI 上看到具体可撤销/重做的操作内容<br>历史持久化：将撤销/重做历史保存到本地存储，即使页面刷新后也能恢复历史记录。<br>自适应栈大小：根据当前画布复杂度动态调整栈大小，元素较多时使用较小的栈，元素较少时使用较大的栈</p><h3 id="5-交互与用户体验"><a href="#5-交互与用户体验" class="headerlink" title="5. 交互与用户体验"></a>5. 交互与用户体验</h3><h4 id="变换控件（Transform-Controls）的检测与处理"><a href="#变换控件（Transform-Controls）的检测与处理" class="headerlink" title="变换控件（Transform Controls）的检测与处理"></a>变换控件（Transform Controls）的检测与处理</h4><p>变换控件由 TF_controler_Renderer.ts 模块负责渲染，包括包围选中元素的边界框、8 个缩放手柄（位于边角）和 1 个旋转手柄（通常位于顶部或底部）</p><p>手柄检测基于鼠标位置与手柄边界框的距离计算：</p><ul><li>当鼠标进入手柄区域时，光标样式相应改变（例如，边角手柄显示对角箭头，旋转手柄显示旋转图标）</li><li>每个手柄对应特定操作：<ul><li>8 个边角手柄：用于非均匀缩放（保持或不保持宽高比，根据修饰键）</li><li>旋转手柄：用于旋转选中元素（可能以组中心为旋转锚点）</li></ul></li></ul><p>在 Stage_InteractionHandler.ts 中处理实际变换逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 处理缩放操作</span><br><span class="hljs-title function_">handleScale</span>(<span class="hljs-params"><span class="hljs-attr">dx</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">dy</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">handleType</span>: <span class="hljs-built_in">string</span></span>) {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br><br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> element = elements[id];<br>    <span class="hljs-comment">// 根据手柄类型（e.g., 'top-left', 'bottom-right'）计算缩放比例和位置偏移</span><br>    updates[id] = <span class="hljs-title function_">calculateNewDimensions</span>(element, dx, dy, handleType);<br>  });<br><br>  <span class="hljs-comment">// 批量更新元素，避免多次重渲染</span><br>  useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">batchUpdateElements</span>(updates);<br>}<br><br><span class="hljs-comment">// 处理旋转操作（示例）</span><br><span class="hljs-title function_">handleRotate</span>(<span class="hljs-params"><span class="hljs-attr">deltaAngle</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">pivotPoint</span>: { x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span> }</span>) {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br><br>  selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> element = elements[id];<br>    updates[id] = <span class="hljs-title function_">calculateRotatedElement</span>(element, deltaAngle, pivotPoint);<br>  });<br><br>  useStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">batchUpdateElements</span>(updates);<br>}<br></code></pre></td></tr></table></figure><h4 id="交互模式切换逻辑"><a href="#交互模式切换逻辑" class="headerlink" title="交互模式切换逻辑"></a>交互模式切换逻辑</h4><p>项目定义了多种交互模式，主要在 Stage_InteractionHandler.ts 中管理，确保同一时刻仅一种模式活跃。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">onPointerDown = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: PIXI.<span class="hljs-title class_">FederatedPointerEvent</span></span>) =&gt;</span> {<br>  <span class="hljs-keyword">const</span> { x, y } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-title function_">toLocal</span>(event.<span class="hljs-property">global</span>);<br><br>  <span class="hljs-comment">// 1. 优先检测变换手柄（最高优先级）</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isOverTransformHandle</span>(x, y)) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'transforming'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startTransform</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCurrentHandleType</span>());<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 2. 检测是否点击元素</span><br>  <span class="hljs-keyword">const</span> hitElementId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isOverElement</span>(x, y);<br>  <span class="hljs-keyword">if</span> (hitElementId) {<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">originalEvent</span>.<span class="hljs-property">shiftKey</span>) {<br>      <span class="hljs-comment">// Shift + 点击：多选切换</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toggleSelection</span>(hitElementId);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// 普通点击：单选或重新开始选择</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">selectElement</span>(hitElementId);<br>    }<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'dragging'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startDrag</span>(x, y);<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 3. 空格键平移</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">originalEvent</span>.<span class="hljs-property">code</span> === <span class="hljs-string">'Space'</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'panning'</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startPan</span>(event);<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// 4. 默认：框选模式</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentMode</span> = <span class="hljs-string">'selecting'</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startSelectionBox</span>(x, y);<br>};<br></code></pre></td></tr></table></figure><p>模式优先级：<strong>transforming &gt; dragging &gt; panning &gt; selecting &gt; idle</strong>，确保变换手柄始终优先响应。</p><h4 id="对齐指南（Alignment-Guidelines）的计算与绘制"><a href="#对齐指南（Alignment-Guidelines）的计算与绘制" class="headerlink" title="对齐指南（Alignment Guidelines）的计算与绘制"></a>对齐指南（Alignment Guidelines）的计算与绘制</h4><p>对齐指南功能由 guidelineUtils.ts 实现，在元素拖拽过程中实时提供视觉反馈和吸附效果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 检测对齐位置</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectAlignments</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">movingElements</span>: <span class="hljs-title class_">CanvasElement</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">allElements</span>: <span class="hljs-title class_">CanvasElement</span>[],</span><br><span class="hljs-params">  <span class="hljs-attr">tolerance</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span></span><br><span class="hljs-params"></span>) {<br>  <span class="hljs-keyword">const</span> alignments = {<br>    <span class="hljs-attr">vertical</span>: [] <span class="hljs-keyword">as</span> { <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span> }[],<br>    <span class="hljs-attr">horizontal</span>: [] <span class="hljs-keyword">as</span> { <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span> }[],<br>  };<br><br>  movingElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">moving</span> =&gt;</span> {<br>    allElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> {<br>      <span class="hljs-keyword">if</span> (movingElements.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">id</span> === element.<span class="hljs-property">id</span>)) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 左/右边缘对齐</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(element.<span class="hljs-property">x</span> - moving.<span class="hljs-property">x</span>) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: element.<span class="hljs-property">x</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'left-edge'</span> });<br>      }<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span> - (moving.<span class="hljs-property">x</span> + moving.<span class="hljs-property">width</span>)) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'right-edge'</span> });<br>      }<br><br>      <span class="hljs-comment">// 水平中心对齐</span><br>      <span class="hljs-keyword">const</span> movingCenterX = moving.<span class="hljs-property">x</span> + moving.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">const</span> elementCenterX = element.<span class="hljs-property">x</span> + element.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(movingCenterX - elementCenterX) &lt; tolerance) {<br>        alignments.<span class="hljs-property">vertical</span>.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">position</span>: elementCenterX, <span class="hljs-attr">type</span>: <span class="hljs-string">'center'</span> });<br>      }<br><br>      <span class="hljs-comment">// 类似处理水平对齐（top/bottom/center）...</span><br>    });<br>  });<br><br>  <span class="hljs-comment">// 等间距检测（可选扩展）</span><br>  <span class="hljs-comment">// detectEqualSpacing(...);</span><br><br>  <span class="hljs-keyword">return</span> alignments;<br>}<br></code></pre></td></tr></table></figure><p><strong>绘制与吸附</strong>：</p><ul><li>在拖拽过程中，每帧调用 detectAlignments，若检测到对齐，则使用 PixiJS 的 Graphics 对象绘制虚线指南（通常为蓝色或绿色，带一定透明度）。</li><li>若移动偏移导致对齐，则自动吸附（snap）元素位置到精确对齐点，提供精准布局体验。</li></ul><h3 id="6-性能优化与工程实践"><a href="#6-性能优化与工程实践" class="headerlink" title="6. 性能优化与工程实践"></a>6. 性能优化与工程实践</h3><h4 id="项目中具体的性能优化措施"><a href="#项目中具体的性能优化措施" class="headerlink" title="项目中具体的性能优化措施"></a>项目中具体的性能优化措施</h4><p>项目采用了多项针对性优化，确保在复杂画布场景下的流畅运行：</p><ol><li><strong>对象缓存机制</strong> 使用 spriteMap 缓存 PixiJS 显示对象，避免频繁创建和销毁导致的性能开销。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在 Pixi_stageManager.ts 中</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-property">DisplayObject</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-title function_">updateElement</span>(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">attrs</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span>) {<br>  <span class="hljs-keyword">const</span> sprite = <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">get</span>(id);<br>  <span class="hljs-keyword">if</span> (sprite) {<br>    <span class="hljs-comment">// 重用现有对象，直接更新属性</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(sprite, attrs);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 首次创建并缓存</span><br>    <span class="hljs-keyword">const</span> newSprite = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createSprite</span>(attrs);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">spriteMap</span>.<span class="hljs-title function_">set</span>(id, newSprite);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">addChild</span>(newSprite);<br>  }<br>}<br></code></pre></td></tr></table></figure><ol><li><strong>WebGL 渲染优化</strong> 充分利用 PixiJS 的 GPU 加速，并通过 pixi-viewport 实现视口裁剪，仅渲染可见区域元素，显著减少绘制调用。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// viewport 配置示例</span><br><span class="hljs-keyword">const</span> viewport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Viewport</span>({<br>  <span class="hljs-attr">interaction</span>: app.<span class="hljs-property">renderer</span>.<span class="hljs-property">plugins</span>.<span class="hljs-property">interaction</span>,<br>  <span class="hljs-attr">cull</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用视口裁剪</span><br>});<br><br>viewport.<span class="hljs-title function_">on</span>(<span class="hljs-string">"frame-end"</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-comment">// 帧结束时可执行额外优化，如清理不可见资源</span><br>});<br></code></pre></td></tr></table></figure><ol><li><strong>Vite HMR（热模块替换）</strong> 在开发环境中利用 Vite 的快速热更新，无需完整页面刷新即可反映代码变更，大幅提升迭代效率。</li></ol><h4 id="TypeScript-在项目中的作用："><a href="#TypeScript-在项目中的作用：" class="headerlink" title="TypeScript 在项目中的作用："></a>TypeScript 在项目中的作用：</h4><ol><li><strong>类型安全</strong> 通过严格接口定义，确保数据一致性与错误早发现。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-title class_">ToolType</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">alpha</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">points</span>?: <span class="hljs-built_in">number</span>[][];<br>  <span class="hljs-attr">rotation</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 文本相关</span><br>  <span class="hljs-attr">text</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">fontSize</span>?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">fontFamily</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">textAlign</span>?: <span class="hljs-string">"left"</span> | <span class="hljs-string">"center"</span> | <span class="hljs-string">"right"</span>;<br>  <span class="hljs-comment">// 图像相关</span><br>  <span class="hljs-attr">imageUrl</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">filter</span>?: <span class="hljs-string">"none"</span> | <span class="hljs-string">"blur"</span> | <span class="hljs-string">"brightness"</span> | <span class="hljs-string">"grayscale"</span>;<br>  <span class="hljs-comment">// 分组相关</span><br>  <span class="hljs-attr">groupId</span>?: <span class="hljs-built_in">string</span>;<br>}<br></code></pre></td></tr></table></figure><ol><li><strong>智能提示与类型推断</strong>：显著提高编码效率。</li><li><strong>重构安全</strong>：类型系统可在大型重构时快速定位影响范围。</li><li><strong>接口契约</strong>：明确模块间数据结构，提升代码可维护性。</li></ol><h4 id="构建与部署方面"><a href="#构建与部署方面" class="headerlink" title="构建与部署方面"></a>构建与部署方面</h4><ol><li><strong>选用 Vite 的原因</strong><ul><li>极快的开发服务器启动与构建速度</li><li>即时热模块替换（HMR）</li><li>出色的构建性能与 Tree Shaking</li><li>开箱即用的 TypeScript、JSX 和 CSS Modules 支持</li></ul></li><li><strong>Docker 与 GitHub Actions CI/CD</strong><ul><li>项目根目录提供 Dockerfile 和 docker-compose.yml，支持容器化部署。</li><li>GitHub Actions 配置自动化流程：代码检查 → 单元测试 → 构建产物 → 镜像推送 → 部署至目标环境。</li></ul></li></ol><h4 id="样式一致性保证"><a href="#样式一致性保证" class="headerlink" title="样式一致性保证"></a>样式一致性保证</h4><p>为统一多组件库外观，项目实施以下策略：</p><ol><li><strong>TailwindCSS 统一设计系统</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// tailwind.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br>  <span class="hljs-attr">theme</span>: {<br>    <span class="hljs-attr">extend</span>: {<br>      <span class="hljs-attr">colors</span>: {<br>        <span class="hljs-attr">primary</span>: colors.<span class="hljs-property">blue</span>,<br>        <span class="hljs-attr">secondary</span>: colors.<span class="hljs-property">gray</span>,<br>      },<br>      <span class="hljs-attr">spacing</span>: {<br>        <span class="hljs-string">'18'</span>: <span class="hljs-string">'4.5rem'</span>,<br>        <span class="hljs-string">'88'</span>: <span class="hljs-string">'22rem'</span>,<br>      },<br>    },<br>  },<br>};<br></code></pre></td></tr></table></figure><ol><li><strong>CSS 变量系统</strong>：定义全局变量（如 —color-primary），确保所有组件引用统一值。</li><li><strong>主题管理</strong>：通过 themeStore.ts（基于 Zustand 或类似状态管理）集中控制主题切换。</li><li><strong>组件包装</strong>：对第三方库组件进行二次封装，统一应用项目样式和行为规范。</li></ol><h3 id="7-挑战与改进"><a href="#7-挑战与改进" class="headerlink" title="7. 挑战与改进"></a>7. 挑战与改进</h3><h4 id="开发过程中遇到的主要技术难点及解决方案"><a href="#开发过程中遇到的主要技术难点及解决方案" class="headerlink" title="开发过程中遇到的主要技术难点及解决方案"></a>开发过程中遇到的主要技术难点及解决方案</h4><p>在项目开发中，我们遇到了几个关键技术挑战，主要集中在实时协作、渲染同步以及性能优化方面。</p><ol><li><p><strong>实时协作冲突处理</strong> 最大的难点之一是多用户同时编辑画布时的数据冲突，可能导致操作覆盖或状态不一致。</p><ul><li>采用 <strong>Yjs 的 CRDT（Conflict-free Replicated Data Type）算法</strong>，自动合并并发修改，无需中央锁定机制，确保最终一致性。</li><li>通过 <strong>HocuspocusProvider</strong> 建立 WebSocket 连接，实现低延迟实时同步。</li><li><p>在 canvasStore.ts 中，利用 Yjs 的 observe 机制监听变更并同步到本地状态管理器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">yElements.<span class="hljs-title function_">observe</span>(<span class="hljs-function">() =&gt;</span> {<br>  useStore.<span class="hljs-title function_">setState</span>({<br>    <span class="hljs-attr">elements</span>: yElements.<span class="hljs-title function_">toJSON</span>(),<br>  });<br>});<br></code></pre></td></tr></table></figure></li><li><p>额外实现锁定机制，防止同步过程中向撤销/重做栈添加无效命令，避免历史污染。</p></li></ul></li><li><p><strong>PixiJS 与 React 状态同步</strong> 另一个重大挑战是保持 PixiJS 渲染层与 React/Zustand 状态的实时一致性，尤其在元素数量较多时易导致延迟或不一致。</p><ul><li>创建 Pixi_stageManager.ts 作为桥梁层，负责双向同步 React 状态与 PixiJS 显示对象。</li><li>使用 spriteMap 缓存 PixiJS 对象，避免重复创建/销毁。</li><li>引入防抖（debounce）机制，限制频繁同步频率。</li><li>实现选择性更新，仅针对变更元素进行渲染。</li></ul></li><li><p><strong>性能优化挑战</strong> 当画布元素数量激增时，渲染和交互性能显著下降。</p><ul><li>启用视口裁剪（viewport culling），仅渲染当前可见区域元素。</li><li>引入对象池和缓存机制，减少内存分配开销。</li><li>采用批量更新（batchUpdateElements），降低状态变更引起的多次重渲染。</li><li><p>针对静态元素启用 cacheAsBitmap，将内容烘焙为位图以减少重绘。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 示例：针对静态元素启用位图缓存</span><br><span class="hljs-keyword">if</span> (sprite.<span class="hljs-property">isStatic</span> &amp;&amp; !sprite.<span class="hljs-property">cacheAsBitmap</span>) {<br>  sprite.<span class="hljs-property">cacheAsBitmap</span> = <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GitHub 仓库 &lt;a href=&quot;https://github.com/Zhongye1/BDdraw_DEV?referrer=grok.com&quot;&gt;https://github.com/Zhongye1/BDdraw_DEV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该项目技术栈先进（R</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-28-力扣百题速练（Javascript、TypeScript）Vol.3</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/42325.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/42325.html</id>
    <published>2025-12-28T18:15:44.000Z</published>
    <updated>2025-12-28T18:24:57.620Z</updated>
    
    <content type="html"><![CDATA[<p>依旧刷题中</p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><p>输入：l1 = <code>[1,2,4]</code>, l2 = <code>[1,3,4]</code><br>输出：<code>[1,1,2,3,4,4]</code></p><p><strong>示例 2：</strong></p><p>输入：l1 = <code>[]</code>, l2 = <code>[]</code><br>输出：<code>[]</code></p><p><strong>示例 3：</strong></p><p>输入：l1 = <code>[]</code>, l2 = <code>[0]</code><br>输出：<code>[0]</code></p><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>Related Topics</p><ul><li>递归</li><li>链表</li></ul><p>解法很简单，假设输入两个有序链表：</p><p>list1: 1 → 2 → 4 list2: 1 → 3 → 4</p><p>合并过程逐步展示指针变化（→ 表示 next 指针，cur 为当前构建指针）：</p><p><strong>初始状态</strong> dummy → null cur = dummy list1: 1 → 2 → 4 list2: 1 → 3 → 4</p><p><strong>步骤 1</strong>：比较 list1.val(1) ≤ list2.val(1) cur.next = list1 的 1 cur 前进 → 指向 1 list1 前进 → 2 → 4 当前新链表：dummy → 1</p><p><strong>步骤 2</strong>：比较 list1.val(2) &gt; list2.val(1) cur.next = list2 的 1 cur 前进 → 指向 1 list2 前进 → 3 → 4 当前新链表：dummy → 1 → 1</p><p><strong>步骤 3</strong>：比较 list1.val(2) ≤ list2.val(3) cur.next = list1 的 2 cur 前进 → 指向 2 list1 前进 → 4 当前新链表：dummy → 1 → 1 → 2</p><p><strong>步骤 4</strong>：比较 list1.val(4) &gt; list2.val(3) cur.next = list2 的 3 cur 前进 → 指向 3 list2 前进 → 4 当前新链表：dummy → 1 → 1 → 2 → 3</p><p><strong>步骤 5</strong>：比较 list1.val(4) ≤ list2.val(4) cur.next = list1 的 4 cur 前进 → 指向 4 list1 前进 → null 当前新链表：dummy → 1 → 1 → 2 → 3 → 4</p><p><strong>步骤 6</strong>：list1 已空，剩余 list2(4) 直接接上 cur.next = list2 的 4 当前新链表：dummy → 1 → 1 → 2 → 3 → 4 → 4</p><p><strong>最终返回</strong>：dummy.next 结果链表：1 → 1 → 2 → 3 → 4 → 4</p><p>该过程通过不断比较两个链表的当前节点，将较小节点直接拼接至新链表尾部（cur 后），并前进对应指针，直至处理完所有节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"><span class="hljs-attr">list1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">list2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {  <br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>  <br>    <span class="hljs-keyword">let</span> dum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>)  <br>  <br>    <span class="hljs-keyword">let</span> cur = dum  <br>  <br>    <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) {  <br>        <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &lt;= list2.<span class="hljs-property">val</span>) {  <br>            cur.<span class="hljs-property">next</span> = list1;        <span class="hljs-comment">// 将较小节点接到 cur 后  </span><br>            list1 = list1.<span class="hljs-property">next</span>;      <span class="hljs-comment">// list1 前进  </span><br>        } <span class="hljs-keyword">else</span> {  <br>            cur.<span class="hljs-property">next</span> = list2;  <br>            list2 = list2.<span class="hljs-property">next</span>;  <br>        }  <br>        cur = cur.<span class="hljs-property">next</span>;              <span class="hljs-comment">// cur 前进  </span><br>    }  <br>  <br>    cur.<span class="hljs-property">next</span> = list1 || list2  <br>    <span class="hljs-keyword">return</span> dum.<span class="hljs-property">next</span>  <br>  <br>};<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;依旧刷题中&lt;/p&gt;
&lt;h2 id=&quot;21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21.合并两个有序链表&quot;&gt;&lt;/a&gt;21.合并两个有序链表&lt;/h2&gt;&lt;p&gt;将两个升序链表合并为一个新的 &lt;stron</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-28-前端学习-接口类型定义、Axios 封装与请求规范</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/16956.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/16956.html</id>
    <published>2025-12-28T17:01:18.000Z</published>
    <updated>2025-12-28T17:49:02.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于接口类型定义、Axios-封装与请求规范的常见问题"><a href="#关于接口类型定义、Axios-封装与请求规范的常见问题" class="headerlink" title="关于接口类型定义、Axios 封装与请求规范的常见问题"></a>关于接口类型定义、Axios 封装与请求规范的常见问题</h3><p>使用 TypeScript 的 React 或 Vue 项目中，通常会高度重视网络层的工程化实践，通常会从实际项目经验入手，逐步深入到设计理念、类型安全和最佳实践</p><p>关于接口类型定义、Axios 封装与请求规范的常见问题整理如下：</p><h4 id="基本经验与动机"><a href="#基本经验与动机" class="headerlink" title="基本经验与动机"></a>基本经验与动机</h4><ul><li><p><strong>在项目中是否对 Axios 进行过二次封装？为什么需要封装，而不是直接使用原生 Axios？</strong> 是的，在所有中大型项目中都会对 Axios 进行二次封装。主要原因是原生 Axios 配置分散、重复代码多（如每个请求都需手动设置 baseURL、headers 和错误处理）。封装后可以统一管理公共逻辑，减少冗余，提升代码一致性和可维护性，避免直接使用导致的配置不统一和后期修改困难。</p></li><li><p><strong>Vue/React 项目中，你们是怎么管理 API 接口的？有统一的请求封装吗？</strong> 我们采用统一的请求封装层。通常创建一个独立的 apiClient 实例作为基础，然后在 services 或 api 目录下按业务模块（如 auth、user、room）划分文件，每个模块导出具体的请求函数。所有接口调用都通过这些封装函数进行，确保风格一致、类型安全，并便于后期维护和 mock。</p></li><li><p><strong>说说 Axios 二次封装的主要目的和好处？</strong> 主要目的是统一配置和公共逻辑处理，包括 baseURL、超时、Token 添加、错误统一处理等。好处包括：减少重复代码、提升可维护性、统一错误提示和加载状态、便于环境切换、支持类型安全（TS 项目），最终降低 bug 率并提高团队开发效率。</p></li></ul><h4 id="实现细节与规范"><a href="#实现细节与规范" class="headerlink" title="实现细节与规范"></a>实现细节与规范</h4><ul><li><p><strong>怎么封装 Axios 的？主要封装了哪些方面（如 baseURL、超时、请求/响应拦截器、错误处理）？</strong> 首先使用 axios.create() 创建实例，设置 baseURL、timeout 和默认 headers。然后添加请求拦截器统一注入 Token 和加载状态；响应拦截器中提取 data、处理业务 code、统一错误提示（如 401 跳转登录），并支持 Token 刷新重试。</p></li><li><p><strong>在项目中，如何统一处理请求头（如添加 Token）、环境切换（开发/生产 baseURL）和错误提示？</strong> 请求头通过请求拦截器或 setAuthToken 函数统一添加 Authorization；环境切换利用 Vite 或 Webpack 的环境变量动态设置 baseURL；错误提示在响应拦截器中根据 status 或业务 code 统一处理，使用 toast 组件显示消息，或触发全局错误处理逻辑。</p></li><li><p><strong>封装后，如何组织和管理具体的 API 接口？（如按模块分文件、统一导出）</strong> 按业务模块分文件（如 auth.ts、room.ts），每个文件定义相关接口函数并导出；再创建一个 index.ts 统一导出所有模块，便于在业务组件中按需导入（如 import { login } from ‘@/api’）。这样结构清晰，便于维护和权限控制。</p></li><li><p><strong>如何处理请求取消、重复请求防抖或加载状态？</strong> 使用 Axios CancelToken 或 AbortController 实现请求取消，适用于组件卸载或搜索防抖场景；重复请求通过 URL + 方法 + 参数的 Map 缓存取消函数实现防重；加载状态可在拦截器中 dispatch 全局 loading action，或在单个请求中使用 async/await 结合状态管理。</p></li></ul><h4 id="类型安全与工程化（TypeScript）"><a href="#类型安全与工程化（TypeScript）" class="headerlink" title="类型安全与工程化（TypeScript）"></a>类型安全与工程化（TypeScript）</h4><ul><li><p><strong>在使用 TypeScript 的项目中，你是怎么结合接口类型定义来封装 Axios 的？如何实现响应数据的类型推导？</strong> 先在 types/api.ts 中集中定义所有接口的请求参数和响应类型。然后在服务函数中使用 Axios 泛型，如 <code>apiClient.get&lt;RoomListResponse&gt;(url)</code>，这样返回值的类型自动推导为定义的接口类型，实现全程类型检查和编辑器提示。</p></li><li><p><strong>说说 Axios 泛型的使用，比如如何通过 <code>&lt;T&gt;</code> 指定返回类型，确保调用时有类型提示和检查？</strong> 通过 <code>apiClient.post&lt;T&gt;(url, data)</code>的方式指定泛型 T 为具体响应类型（如 LoginResponse）。这样调用时 TypeScript 会自动推导返回值属性，提供属性提示和编译时错误检查（如访问不存在字段会报错），显著提升类型安全。</p></li><li><p><strong>怎么定义接口请求参数和响应类型的？有统一的响应包装类型（如 <code>ApiResponse&lt;T&gt;</code>）吗？</strong> 定义通用包装类型 <code>interface ApiResponse&lt;T&gt; { code: number; data: T; message?: string; }</code> 所有接口响应类型继承此泛型（如 <code>type LoginResponse = ApiResponse&lt;{ token: string }&gt;;）</code>，便于统一处理业务 code 和错误。</p></li><li><p><strong>在封装中，如何处理拦截器或自定义配置的 TypeScript 类型扩展（如扩展 AxiosRequestConfig）？</strong> 通过模块声明扩展 AxiosRequestConfig 接口，添加自定义字段（如 _retry: boolean 用于 Token 刷新）。拦截器参数类型自然继承扩展后的配置，确保类型兼容和提示完整。</p></li><li><p><strong>如果后端返回结构不统一，怎么通过类型守卫或转型确保类型安全？</strong></p></li></ul><blockquote><p>类型守卫（Type Guard）是 TypeScript 中的一种机制，用于在运行时缩小变量的类型范围，从而让编译器在特定代码块中更精确地推断变量的类型。它本质上是一个返回布尔值的表达式或函数，当该表达式为 true 时，TypeScript 会自动将变量的类型收窄（narrow）为更具体的类型。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//typeof 类型守卫 使用 JavaScript 的 typeof 操作符</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {<br>    <span class="hljs-comment">// 这里 value 被收窄为 string</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>());<br>  } <span class="hljs-keyword">else</span> {<br>  <span class="hljs-comment">// 这里 value 被收窄为 number</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));<br>  }<br>}<br></code></pre></td></tr></table></figure><p>在响应拦截器中先转型为 any 或 unknown，然后使用类型守卫（如 if (‘code’ in res &amp;&amp; res.code === 0)）判断成功，再返回 res.data 并断言为具体类型。这样既兼容不统一结构，又保持业务层类型安全</p><h4 id="深度与实践相关"><a href="#深度与实践相关" class="headerlink" title="深度与实践相关"></a>深度与实践相关</h4><ul><li><p><strong>封装后，在业务组件中调用接口的体验如何？相比直接用 Axios 有哪些改进？</strong> 体验显著提升：调用简洁，自动获得类型提示和错误检查；无需关心 Token、baseURL 或错误处理。相比直接使用，减少了大量样板代码，降低了出错概率，并提高了代码可读性。</p></li><li><p><strong>有考虑过从 OpenAPI/Swagger 自动生成类型和接口函数吗？</strong> 是的，在较大项目中会使用 openapi-typescript 或 swagger-typescript-api 从后端 OpenAPI 文档自动生成类型和请求函数。这样保持前后端类型一致，减少手动维护成本，并进一步提升工程化水平。</p></li><li><p><strong>如果项目规模很大，是怎么进一步优化网络层的（如模块化、服务层分离）？</strong> 通过严格的服务层分离：apiClient 只负责基础请求，services 层按领域划分（如 userService、orderService），每个服务聚合相关接口并处理业务逻辑；结合代码生成和 mock 工具，实现高度模块化和可测试性。</p></li><li><p><strong>说说项目中网络请求的常见痛点，以及封装如何解决的。</strong> 常见痛点包括 Token 管理散乱、错误处理不统一、环境配置易错、类型不安全。二次封装通过拦截器统一 Token 和错误、环境变量管理配置、TS 泛型确保类型安全，有效解决了这些问题，显著降低了联调和维护成本。</p></li></ul><hr><h3 id="Axios-封装与接口管理具体实现"><a href="#Axios-封装与接口管理具体实现" class="headerlink" title="Axios 封装与接口管理具体实现"></a>Axios 封装与接口管理具体实现</h3><h4 id="基础的实现"><a href="#基础的实现" class="headerlink" title="基础的实现"></a>基础的实现</h4><ol><li><p><strong>如何封装 Axios？</strong> 一个典型的 Axios 封装结构如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/utils/apiClient.ts</span><br><span class="hljs-keyword">import</span> axios, { <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosRequestConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<br><br><span class="hljs-keyword">const</span> apiClient = axios.<span class="hljs-title function_">create</span>({<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span> || <span class="hljs-string">"/api"</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,<br>  <span class="hljs-attr">headers</span>: {<br>    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,<br>  },<br>});<br><br><span class="hljs-comment">// 请求拦截器</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"token"</span>);<br>    <span class="hljs-keyword">if</span> (token) {<br>      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>;<br>    }<br>    <span class="hljs-keyword">return</span> config;<br>  },<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>);<br><br><span class="hljs-comment">// 响应拦截器</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-property">data</span>,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) {<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">"token"</span>);<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">"/login"</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  }<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> apiClient;<br></code></pre></td></tr></table></figure></li><li><p><strong>如何统一处理请求头、环境切换和错误提示？</strong></p><ul><li><strong>环境切换</strong>：通过 Vite 或 Webpack 的环境变量（如 VITE_API_BASE_URL）动态配置 baseURL。</li><li><strong>请求头处理</strong>：在请求拦截器中统一注入 Authorization 等认证头。</li><li><strong>错误提示</strong>：在响应拦截器中根据状态码或业务码统一处理错误，例如 401 跳转登录、500 显示服务器错误提示。</li></ul></li><li><p><strong>如何组织和管理具体的 API 接口？</strong> 按业务模块划分文件，并统一导出，便于维护。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/index.ts</span><br><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> userApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"./user"</span>;<br><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> roomApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"./room"</span>;<br><br><span class="hljs-comment">// api/room.ts</span><br><span class="hljs-keyword">import</span> apiClient <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils/apiClient"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">RoomResponse</span>, <span class="hljs-title class_">CreateRoomRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;<br><br><span class="hljs-keyword">const</span> roomApi = {<br>  <span class="hljs-attr">getRooms</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">params</span>: { page: <span class="hljs-built_in">number</span>; size: <span class="hljs-built_in">number</span> }</span>) =&gt;</span><br>    apiClient.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">RoomResponse</span>&gt;(<span class="hljs-string">"/rooms"</span>, { params }),<br>  <span class="hljs-attr">createRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-title class_">CreateRoomRequest</span></span>) =&gt;</span> apiClient.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/rooms"</span>, data),<br>  <span class="hljs-attr">updateRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CreateRoomRequest</span>&gt;</span>) =&gt;</span><br>    apiClient.<span class="hljs-title function_">put</span>(<span class="hljs-string">`/rooms/<span class="hljs-subst">${id}</span>`</span>, data),<br>  <span class="hljs-attr">deleteRoom</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> apiClient.<span class="hljs-title function_">delete</span>(<span class="hljs-string">`/rooms/<span class="hljs-subst">${id}</span>`</span>),<br>};<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> roomApi;<br></code></pre></td></tr></table></figure></li><li><p><strong>如何处理请求取消、重复请求防抖或加载状态？</strong> 使用 AbortController 实现请求取消和防重提交。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">AbortController</span>&gt;();<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {<br>  <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${config.method?.toUpperCase()}</span><span class="hljs-subst">${config.url}</span>`</span>;<br>  <span class="hljs-keyword">if</span> (pendingRequests.<span class="hljs-title function_">has</span>(requestKey)) {<br>    pendingRequests.<span class="hljs-title function_">get</span>(requestKey)?.<span class="hljs-title function_">abort</span>();<br>  }<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>  config.<span class="hljs-property">signal</span> = controller.<span class="hljs-property">signal</span>;<br>  pendingRequests.<span class="hljs-title function_">set</span>(requestKey, controller);<br>  <span class="hljs-keyword">return</span> config;<br>});<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<br>    <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${response.config.method?.toUpperCase()}</span><span class="hljs-subst">${</span></span><br><span class="hljs-subst"><span class="hljs-string">      response.config.url</span></span><br><span class="hljs-subst"><span class="hljs-string">    }</span>`</span>;<br>    pendingRequests.<span class="hljs-title function_">delete</span>(requestKey);<br>    <span class="hljs-keyword">return</span> response;<br>  },<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">config</span>) {<br>      <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${error.config.method?.toUpperCase()}</span><span class="hljs-subst">${</span></span><br><span class="hljs-subst"><span class="hljs-string">        error.config.url</span></span><br><span class="hljs-subst"><span class="hljs-string">      }</span>`</span>;<br>      pendingRequests.<span class="hljs-title function_">delete</span>(requestKey);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  }<br>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="类型安全与工程化（TypeScript）-1"><a href="#类型安全与工程化（TypeScript）-1" class="headerlink" title="类型安全与工程化（TypeScript）"></a>类型安全与工程化（TypeScript）</h4><ol><li><p><strong>如何结合接口类型定义封装 Axios？</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/types/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Room</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">updatedAt</span>: <span class="hljs-built_in">string</span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RoomResponse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApiResponse</span>&lt;<span class="hljs-title class_">Room</span>[]&gt; {<br>  <span class="hljs-attr">pagination</span>: { <span class="hljs-attr">page</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span> };<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CreateRoomRequest</span> {<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>?: <span class="hljs-built_in">string</span>;<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>Axios 泛型的使用</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// apiService.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<br><span class="hljs-keyword">import</span> apiClient <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils/apiClient"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">ApiResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> {<br>  <span class="hljs-keyword">async</span> get&lt;T&gt;(<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">config</span>?: <span class="hljs-title class_">AxiosRequestConfig</span><br>  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; = <span class="hljs-keyword">await</span> apiClient.<span class="hljs-title function_">get</span>(<br>      url,<br>      config<br>    );<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  }<br><br>  <span class="hljs-keyword">async</span> post&lt;T, D = <span class="hljs-built_in">any</span>&gt;(<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">data</span>?: D,<br>    <span class="hljs-attr">config</span>?: <span class="hljs-title class_">AxiosRequestConfig</span><br>  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;T&gt;&gt; = <span class="hljs-keyword">await</span> apiClient.<span class="hljs-title function_">post</span>(<br>      url,<br>      data,<br>      config<br>    );<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  }<br><br>  <span class="hljs-comment">// put、delete 同理</span><br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apiService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiService</span>();<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> apiService.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">Room</span>[]&gt;(<span class="hljs-string">"/rooms"</span>, {<br>    <span class="hljs-attr">params</span>: { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> },<br>  });<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>; <span class="hljs-comment">// 类型为 Room[]</span><br>};<br></code></pre></td></tr></table></figure></li><li><p><strong>定义统一的响应包装类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">data</span>: T;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiError</span> {<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">details</span>?: <span class="hljs-built_in">any</span>;<br>}<br></code></pre></td></tr></table></figure></li><li><p><strong>拦截器的 TypeScript 类型扩展</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 扩展 AxiosRequestConfig</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomAxiosRequestConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosRequestConfig</span> {<br>  <span class="hljs-attr">showLoading</span>?: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showError</span>?: <span class="hljs-built_in">boolean</span>;<br>}<br><br><span class="hljs-comment">// 在拦截器中使用</span><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">config</span>: <span class="hljs-title class_">CustomAxiosRequestConfig</span></span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">showLoading</span> !== <span class="hljs-literal">false</span>) {<br>    <span class="hljs-comment">// 显示加载状态</span><br>  }<br>  <span class="hljs-keyword">return</span> config;<br>});<br></code></pre></td></tr></table></figure></li><li><p><strong>处理不统一的后端返回结构</strong> 使用类型守卫确保类型安全。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> isApiResponse&lt;T&gt;(<span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>): data is <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {<br>  <span class="hljs-keyword">return</span> (<br>    data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-string">"code"</span> <span class="hljs-keyword">in</span> data &amp;&amp; <span class="hljs-string">"data"</span> <span class="hljs-keyword">in</span> data<br>  );<br>}<br><br>apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isApiResponse</span>(response.<span class="hljs-property">data</span>)) {<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> { <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>, <span class="hljs-attr">data</span>: response.<span class="hljs-property">data</span> };<br>  }<br>});<br></code></pre></td></tr></table></figure></li></ol><h4 id="应用及其后期实践"><a href="#应用及其后期实践" class="headerlink" title="应用及其后期实践"></a>应用及其后期实践</h4><ol><li><p><strong>封装后在业务组件中的使用</strong> 封装后调用更加简洁、安全，无需重复处理 Token、错误或类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 未封装前</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/rooms"</span>);<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">catch</span> (error) {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  }<br>};<br><br><span class="hljs-comment">// 封装后</span><br><span class="hljs-keyword">import</span> { roomApi } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/api"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchRooms</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> roomApi.<span class="hljs-title function_">getRooms</span>({ <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> });<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>  } <span class="hljs-keyword">catch</span> (error) {<br>    <span class="hljs-comment">// 错误已统一处理</span><br>  }<br>};<br></code></pre></td></tr></table></figure></li><li><p><strong>OpenAPI/Swagger 自动生成类型和接口函数</strong> 可使用 openapi-typescript-codegen 或 swagger-typescript-api 等工具从后端 OpenAPI 文档自动生成类型定义和请求函数，实现前后端类型完全一致，显著减少手动维护成本。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于接口类型定义、Axios-封装与请求规范的常见问题&quot;&gt;&lt;a href=&quot;#关于接口类型定义、Axios-封装与请求规范的常见问题&quot; class=&quot;headerlink&quot; title=&quot;关于接口类型定义、Axios 封装与请求规范的常见问题&quot;&gt;&lt;/a&gt;关于接口类</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-27-前端画布设计Vol.3 实时协作（Yjs + Hocuspocus + 持久化）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/60421.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/60421.html</id>
    <published>2025-12-27T21:46:01.000Z</published>
    <updated>2025-12-29T07:44:06.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时协作画布系统：Yjs-Hocuspocus-持久化"><a href="#实时协作画布系统：Yjs-Hocuspocus-持久化" class="headerlink" title="实时协作画布系统：Yjs + Hocuspocus + 持久化"></a>实时协作画布系统：Yjs + Hocuspocus + 持久化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在设计工具、白板应用和文档编辑器中，多用户同时编辑同一文档的需求日益增长。传统的客户端-服务器模型在这种场景下存在诸多挑战，例如冲突解决、网络延迟和离线支持等。</p><p>为了支持多用户同时编辑画布内容，并具备离线编辑能力，我们采用了 Yjs（一种 CRDT 实现）配合 IndexedDB 和 Hocuspocus 的架构方案。</p><h2 id="核心技术组件"><a href="#核心技术组件" class="headerlink" title="核心技术组件"></a>核心技术组件</h2><h3 id="Yjs-Y-Map"><a href="#Yjs-Y-Map" class="headerlink" title="Yjs (Y.Map)"></a>Yjs (Y.Map)</h3><p>Yjs 是一个用于创建实时协作应用程序的库，它实现了 Conflict-free Replicated Data Types (CRDTs) 算法。CRDTs 是一种特殊的数据结构，可以在多个副本之间同步，而不需要中央协调，从而保证最终一致性。</p><p>Y.Map 是 Yjs 提供的一种共享数据类型，类似于 JavaScript 中的 Map。它的关键特性包括：</p><ul><li><strong>自动冲突解决</strong>：当多个用户同时修改数据时，Yjs 自动解决冲突</li><li><strong>分布式一致性</strong>：保证所有客户端看到相同的数据状态</li><li><strong>高效同步</strong>：只传输变更部分，减少网络流量</li></ul><h3 id="持久化选项"><a href="#持久化选项" class="headerlink" title="持久化选项"></a>持久化选项</h3><p>持久化是协作系统的关键组件，不仅需要在客户端存储数据以支持离线使用，还需要在服务端存储数据以实现长期保存和共享。本项目实际实现的持久化策略包括：</p><h4 id="1-IndexedDB（客户端）"><a href="#1-IndexedDB（客户端）" class="headerlink" title="1. IndexedDB（客户端）"></a>1. IndexedDB（客户端）</h4><p>IndexedDB 是浏览器内置的数据库，用于存储大量结构化数据。在协作系统中，它用于：</p><ul><li>使用 <code>y-indexeddb</code> 库创建 IndexeddbPersistence 实例</li><li>为每个房间创建独立的 IndexedDB 存储 (<code>canvas-local-db-${roomId}</code>)</li><li>提供 getYDocForRoom、getYElementsForRoom 和 getIndexedDBProviderForRoom 等函数来管理不同房间的数据</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Y <span class="hljs-keyword">from</span> <span class="hljs-string">'yjs'</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IndexeddbPersistence</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'y-indexeddb'</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HocuspocusProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@hocuspocus/provider'</span>; <span class="hljs-comment">// 如需实时同步时导入</span><br><br><span class="hljs-comment">// 使用 Map 存储不同房间的 Yjs 文档及相关提供者，确保单例管理和数据隔离</span><br><span class="hljs-keyword">const</span> roomDocuments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<br>  <span class="hljs-built_in">string</span>,<br>  {<br>    <span class="hljs-attr">yDoc</span>: Y.<span class="hljs-property">Doc</span>;<br>    <span class="hljs-attr">yElements</span>: Y.<span class="hljs-property">Map</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>    <span class="hljs-attr">indexeddbProvider</span>: <span class="hljs-title class_">IndexeddbPersistence</span>;<br>    <span class="hljs-attr">wsProvider</span>: <span class="hljs-title class_">HocuspocusProvider</span> | <span class="hljs-literal">null</span>;<br>  }<br>&gt;();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取或创建指定房间的 Yjs 文档实例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> roomId 协作房间的唯一标识符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 该房间对应的 Y.Doc 实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getYDocForRoom = (<span class="hljs-attr">roomId</span>: <span class="hljs-built_in">string</span>): Y.<span class="hljs-property">Doc</span> =&gt; {<br>  <span class="hljs-comment">// 若该房间的文档已存在，直接复用以避免重复创建</span><br>  <span class="hljs-keyword">if</span> (roomDocuments.<span class="hljs-title function_">has</span>(roomId)) {<br>    <span class="hljs-keyword">return</span> roomDocuments.<span class="hljs-title function_">get</span>(roomId)!.<span class="hljs-property">yDoc</span>;<br>  }<br><br>  <span class="hljs-comment">// 创建新的 Yjs 文档实例</span><br>  <span class="hljs-keyword">const</span> yDoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br><br>  <span class="hljs-comment">// 获取画布元素的核心数据结构（Y.Map，用于存储所有 CanvasElement）</span><br>  <span class="hljs-keyword">const</span> yElements = yDoc.<span class="hljs-property">getMap</span>&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-string">'elements'</span>);<br><br>  <span class="hljs-comment">// 初始化 IndexedDB 持久化提供者</span><br>  <span class="hljs-comment">// 数据库名称动态包含 roomId，确保不同房间的数据互不干扰</span><br>  <span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<span class="hljs-string">`canvas-local-db-<span class="hljs-subst">${roomId}</span>`</span>, yDoc);<br><br>  <span class="hljs-comment">// 将文档相关信息存入 Map，便于后续访问和管理</span><br>  roomDocuments.<span class="hljs-title function_">set</span>(roomId, {<br>    yDoc,<br>    yElements,<br>    indexeddbProvider,<br>    <span class="hljs-attr">wsProvider</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 初始为空，后续可动态绑定 HocuspocusProvider 以实现实时协作</span><br>  });<br><br>  <span class="hljs-keyword">return</span> yDoc;<br>};<br></code></pre></td></tr></table></figure><ul><li><strong>离线数据存储</strong>：即使用户断网，数据也不会丢失</li><li><strong>快速本地访问</strong>：减少对服务器的依赖</li><li><strong>大容量存储</strong>：相比 localStorage，支持更大的数据量</li></ul><h4 id="2-SQLite（服务端）"><a href="#2-SQLite（服务端）" class="headerlink" title="2. SQLite（服务端）"></a>2. SQLite（服务端）</h4><p>SQLite 作为服务端数据库，用于持久化存储画布内容：</p><ul><li><strong>关系型结构</strong>：提供 SQL 查询能力</li><li><strong>轻量级</strong>：无需单独的服务器进程</li><li><strong>跨平台</strong>：可在多种环境中运行</li><li><strong>服务端存储</strong>：确保数据在服务端持久化</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 服务端数据库实现 (ALD_Backend/src/db.ts)</span><br><br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Database</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"bun:sqlite"</span>;<br><span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>(<span class="hljs-string">"collab.sqlite"</span>);<br><br><span class="hljs-comment">// 启用 WAL 模式以提高并发性能</span><br>db.<span class="hljs-title function_">exec</span>(<span class="hljs-string">"PRAGMA journal_mode = WAL;"</span>);<br><span class="hljs-comment">// 房间表，包含 content BLOB 字段存储 Yjs 二进制数据</span><br>db.<span class="hljs-title function_">run</span>(<span class="hljs-string">`</span><br><span class="hljs-string">  CREATE TABLE IF NOT EXISTS rooms (</span><br><span class="hljs-string">    id TEXT PRIMARY KEY,</span><br><span class="hljs-string">    name TEXT NOT NULL,</span><br><span class="hljs-string">    creator_id TEXT NOT NULL,</span><br><span class="hljs-string">    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,</span><br><span class="hljs-string">    content BLOB, -- Yjs 二进制数据</span><br><span class="hljs-string">    FOREIGN KEY (creator_id) REFERENCES users(id)</span><br><span class="hljs-string">  )</span><br><span class="hljs-string">`</span>);<br><br><span class="hljs-comment">// Hocuspocus 数据库扩展实现 (ALD_Backend/src/collab.ts)</span><br><br><span class="hljs-keyword">const</span> dbExtension = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HocuspocusDB</span>({<br>  <span class="hljs-attr">fetch</span>: <span class="hljs-title function_">async</span> ({ documentName }) =&gt; {<br>    <span class="hljs-keyword">const</span> roomId = <span class="hljs-title function_">getRoomId</span>(documentName);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">`[Yjs] Fetching data for RoomID: <span class="hljs-subst">${roomId}</span>, Original documentName: <span class="hljs-subst">${documentName}</span>`</span><br>    );<br><br>    <span class="hljs-keyword">const</span> query = db.<span class="hljs-title function_">query</span>(<span class="hljs-string">"SELECT content FROM rooms WHERE id = $id"</span>);<br>    <span class="hljs-keyword">const</span> row = query.<span class="hljs-title function_">get</span>({ <span class="hljs-attr">$id</span>: roomId }) <span class="hljs-keyword">as</span> {<br>      <span class="hljs-attr">content</span>: <span class="hljs-title class_">Uint8Array</span> | <span class="hljs-literal">null</span>;<br>    } | <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (row &amp;&amp; row.<span class="hljs-property">content</span> !== <span class="hljs-literal">null</span> &amp;&amp; row.<span class="hljs-property">content</span> !== <span class="hljs-literal">undefined</span>) {<br>      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">content</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`[Yjs] Returning data with size: <span class="hljs-subst">${row.content.length}</span> bytes`</span><br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(row.<span class="hljs-property">content</span>);<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] content is empty, creating new Yjs document`</span>);<br>        <span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br>        ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>); <span class="hljs-comment">// 存储图形元素</span><br>        <span class="hljs-keyword">return</span> Y.<span class="hljs-title function_">encodeStateAsUpdate</span>(ydoc);<br>      }<br>    }<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] No valid data found, creating new Yjs document`</span>);<br>    <span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br>    ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>); <span class="hljs-comment">// 存储图形元素</span><br>    <span class="hljs-keyword">return</span> Y.<span class="hljs-title function_">encodeStateAsUpdate</span>(ydoc);<br>  },<br><br>  <span class="hljs-attr">store</span>: <span class="hljs-title function_">async</span> ({ documentName, state }) =&gt; {<br>    <span class="hljs-keyword">const</span> roomId = <span class="hljs-title function_">getRoomId</span>(documentName);<br>    <span class="hljs-keyword">try</span> {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>        <span class="hljs-string">`[Yjs] Saving data for RoomID: <span class="hljs-subst">${roomId}</span>, State size: <span class="hljs-subst">${state.length}</span> bytes, Original documentName: <span class="hljs-subst">${documentName}</span>`</span><br>      );<br><br>      <span class="hljs-keyword">if</span> (state.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">const</span> roomCheck = db.<span class="hljs-title function_">query</span>(<span class="hljs-string">"SELECT id FROM rooms WHERE id = $id"</span>);<br><br>        <span class="hljs-keyword">const</span> roomExists = roomCheck.<span class="hljs-title function_">get</span>({ <span class="hljs-attr">$id</span>: roomId });<br><br>        <span class="hljs-keyword">if</span> (!roomExists) {<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<br>            <span class="hljs-string">`[Yjs] Room <span class="hljs-subst">${roomId}</span> does not exist, cannot save data`</span><br>          );<br><br>          <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">const</span> update = db.<span class="hljs-title function_">query</span>(<br>          <span class="hljs-string">"UPDATE rooms SET content = $blob WHERE id = $id"</span><br>        );<br><br>        update.<span class="hljs-title function_">run</span>({ <span class="hljs-attr">$blob</span>: state, <span class="hljs-attr">$id</span>: roomId });<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Yjs] Data saved successfully for RoomID: <span class="hljs-subst">${roomId}</span>`</span>);<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`[Yjs] Skipping save for RoomID: <span class="hljs-subst">${roomId}</span> as state is empty`</span><br>        );<br>      }<br>    } <span class="hljs-keyword">catch</span> (error) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[Yjs] Save failed for <span class="hljs-subst">${roomId}</span>:`</span>, error);<br>    }<br>  },<br>});<br></code></pre></td></tr></table></figure><h3 id="Hocuspocus-Provider"><a href="#Hocuspocus-Provider" class="headerlink" title="Hocuspocus Provider"></a>Hocuspocus Provider</h3><p>Hocuspocus 是一个协作编辑框架，提供了 Yjs 的服务器端实现。它负责：</p><ul><li><strong>多客户端同步</strong>：协调多个客户端之间的数据同步</li><li><strong>WebSocket 连接管理</strong>：建立持久连接</li><li><strong>房间管理</strong>：隔离不同协作空间的数据</li><li><strong>与多种持久化后端集成</strong>：可连接到数据库、文件系统等</li></ul><h2 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    subgraph "Frontend Application (React/Vue)"<br>        A[Canvas UI Components]<br>        B[State Management&lt;br/&gt;Zustand/Pinia]<br>        C[Yjs Document&lt;br/&gt;Shared Data]<br>        D[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    subgraph "Backend Services"<br>        E[Hono Server&lt;br/&gt;Port 3000]<br>        F[RESTful API&lt;br/&gt;Auth/RM]<br>        G[SQLite DB&lt;br/&gt;Persistence]<br>    end<br>    subgraph "WebSocket Services"<br>        H[Hocuspocus Server&lt;br/&gt;Port 1234]<br>        I[Yjs Extensions&lt;br/&gt;DB/Storage]<br>    end<br>    A &lt;--&gt; C<br>    B &lt;--&gt; C<br>    C &lt;--&gt; D<br>    C &lt;--&gt; H<br>    E &lt;--&gt; F<br>    E &lt;--&gt; G<br>    F &lt;--&gt; H<br>    H &lt;--&gt; I<br>    I &lt;--&gt; G<br>    style A fill:#87CEEB<br>    style B fill:#98FB98<br>    style C fill:#FFD700<br>    style D fill:#DDA0DD<br>    style E fill:#F0E68C<br>    style F fill:#FFA07A<br>    style G fill:#BA55D3<br>    style H fill:#20B2AA<br>    style I fill:#FF69B4<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>    subgraph "Client A"<br>        A[Y.Map&lt;br/&gt;Shared Data]<br>        B[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    subgraph "Server"<br>        C[Hocuspocus&lt;br/&gt;Server]<br>        D[SQLite DB&lt;br/&gt;Persistence]<br>    end<br>    subgraph "Client B"<br>        E[Y.Map&lt;br/&gt;Shared Data]<br>        F[IndexedDB&lt;br/&gt;Local Persistence]<br>    end<br>    A &lt;--&gt; C<br>    E &lt;--&gt; C<br>    B &lt;--&gt; D<br>    F &lt;--&gt; D<br>    C &lt;--&gt; D<br>    style A fill:#FFD700<br>    style B fill:#DDA0DD<br>    style C fill:#20B2AA<br>    style D fill:#BA55D3<br>    style E fill:#FFD700<br>    style F fill:#DDA0DD<br></code></pre></td></tr></table></figure><h3 id="数据流向"><a href="#数据流向" class="headerlink" title="数据流向"></a>数据流向</h3><ol><li>用户操作更新本地 Y.Map</li><li>变更自动同步到 IndexedDB（本地持久化）</li><li>变更通过 Hocuspocus 同步到服务器和其他客户端</li><li>服务器将变更存储到 SQLite 数据库</li><li>其他客户端接收变更并更新本地 Y.Map</li></ol><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="1-初始化协作环境"><a href="#1-初始化协作环境" class="headerlink" title="1. 初始化协作环境"></a>1. 初始化协作环境</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Y <span class="hljs-keyword">from</span> <span class="hljs-string">"yjs"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IndexeddbPersistence</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"y-indexeddb"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HocuspocusProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@hocuspocus/provider"</span>;<br><br><span class="hljs-comment">// 创建 Yjs 文档</span><br><span class="hljs-keyword">const</span> ydoc = <span class="hljs-keyword">new</span> Y.<span class="hljs-title class_">Doc</span>();<br><span class="hljs-comment">// 获取共享的 Y.Map 用于存储画布元素</span><br><span class="hljs-keyword">const</span> yElements = ydoc.<span class="hljs-title function_">getMap</span>(<span class="hljs-string">"elements"</span>);<br><span class="hljs-comment">// 设置 IndexedDB 持久化</span><br><span class="hljs-keyword">const</span> indexeddbProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexeddbPersistence</span>(<span class="hljs-string">"canvas-room"</span>, ydoc);<br><span class="hljs-comment">// 设置 Hocuspocus 提供者</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initWsProvider</span> = (<span class="hljs-params"><span class="hljs-attr">roomId</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">token</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-comment">// 如果房间不存在，先创建</span><br>  <span class="hljs-keyword">if</span> (!roomDocuments.<span class="hljs-title function_">has</span>(roomId)) {<br>    <span class="hljs-title function_">getYDocForRoom</span>(roomId);<br>  }<br><br>  <span class="hljs-keyword">const</span> roomData = roomDocuments.<span class="hljs-title function_">get</span>(roomId)!;<br><br>  <span class="hljs-comment">// 如果已存在 WebSocket 提供者，先销毁</span><br>  <span class="hljs-keyword">if</span> (roomData.<span class="hljs-property">wsProvider</span>) {<br>    roomData.<span class="hljs-property">wsProvider</span>.<span class="hljs-title function_">destroy</span>();<br>  }<br><br>  <span class="hljs-comment">// 创建新的 WebSocket 提供者，并关联 Yjs 文档</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-string">`[Room <span class="hljs-subst">${roomId}</span>] Initializing WebSocket Provider with token: <span class="hljs-subst">${token}</span>`</span><br>  );<br><br>  <span class="hljs-keyword">const</span> wsProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HocuspocusProvider</span>({<br>    <span class="hljs-comment">// 确保 URL 结尾规范，方便拼接</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`ws://localhost:3000/collaboration/<span class="hljs-subst">${roomId}</span>`</span>,<br>    <span class="hljs-attr">name</span>: roomId, <span class="hljs-comment">// Hocuspocus 会将其拼接为 /collaboration/{roomId}</span><br>    <span class="hljs-attr">token</span>: token,<br>    <span class="hljs-comment">// 明确指定要同步的文档</span><br>    <span class="hljs-attr">document</span>: roomData.<span class="hljs-property">yDoc</span>,<br>  });<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wsProvider);<br><br>  <span class="hljs-comment">// 监听 WebSocket 连接状态</span><br>  wsProvider.<span class="hljs-title function_">on</span>(<span class="hljs-string">"status"</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Room <span class="hljs-subst">${roomId}</span>] WebSocket status:`</span>, event.<span class="hljs-property">status</span>); <span class="hljs-comment">// 'connected' or 'disconnected'</span><br>  });<br><br>  <span class="hljs-comment">// 更新房间数据中的 WebSocket 提供者</span><br>  roomData.<span class="hljs-property">wsProvider</span> = wsProvider;<br>  <span class="hljs-keyword">return</span> wsProvider;<br>};<br></code></pre></td></tr></table></figure><h3 id="2-画布元素管理"><a href="#2-画布元素管理" class="headerlink" title="2. 画布元素管理"></a>2. 画布元素管理</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasElement</span> {<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>}<br><br><span class="hljs-comment">// 添加元素</span><br><br>yElements.<span class="hljs-title function_">set</span>(elementId, {<br>  <span class="hljs-attr">id</span>: elementId,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">"rectangle"</span>,<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">150</span>,<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">"#ff0000"</span>,<br>});<br><br><span class="hljs-comment">// 监听元素变化</span><br><br>yElements.<span class="hljs-title function_">observeDeep</span>(<span class="hljs-function">(<span class="hljs-params">events</span>) =&gt;</span> {<br>  events.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {<br>    <span class="hljs-comment">// 处理添加、更新、删除事件</span><br>  });<br>});<br></code></pre></td></tr></table></figure><h3 id="3-React-状态集成"><a href="#3-React-状态集成" class="headerlink" title="3. React 状态集成"></a>3. React 状态集成</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">"zustand"</span>;<br><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasStore</span> {<br>  <span class="hljs-attr">ydoc</span>: Y.<span class="hljs-property">Doc</span>;<br>  <span class="hljs-attr">yElements</span>: Y.<span class="hljs-property">Map</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;;<br>  <span class="hljs-attr">addElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">element</span>: <span class="hljs-title class_">CanvasElement</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">updateElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-attr">deleteElement</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>}<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCanvasStore = create&lt;<span class="hljs-title class_">CanvasStore</span>&gt;(<span class="hljs-function">(<span class="hljs-params">set, get</span>) =&gt;</span> ({<br>  <span class="hljs-comment">// ... store implementation</span><br>}));<br></code></pre></td></tr></table></figure><h3 id="4-离线支持实现"><a href="#4-离线支持实现" class="headerlink" title="4. 离线支持实现"></a>4. 离线支持实现</h3><p>离线支持是通过 IndexedDB 实现的：</p><ul><li>当用户在线时，所有操作同步到服务器和其他客户端</li><li>当用户离线时，操作仅保存在本地 IndexedDB 中</li><li>当用户重新连接时，本地更改自动同步到服务器</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 等待 IndexedDB 数据加载</span><br><span class="hljs-keyword">await</span> indexeddbProvider.<span class="hljs-property">whenSynced</span>;<br><br><span class="hljs-comment">// 监听连接状态</span><br>provider.<span class="hljs-title function_">on</span>(<span class="hljs-string">"synced"</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Document synced with server"</span>);<br>});<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>后续还可以实现批量更新，防抖，服务端数据验证等优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时协作画布系统：Yjs-Hocuspocus-持久化&quot;&gt;&lt;a href=&quot;#实时协作画布系统：Yjs-Hocuspocus-持久化&quot; class=&quot;headerlink&quot; title=&quot;实时协作画布系统：Yjs + Hocuspocus + 持久化&quot;&gt;&lt;/a&gt;实</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-18-前端画布设计Vol.2 实现富文本编辑</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/10362.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/10362.html</id>
    <published>2025-12-27T18:58:47.000Z</published>
    <updated>2025-12-27T20:23:25.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="画布项目中富文本编辑器的实现浅析"><a href="#画布项目中富文本编辑器的实现浅析" class="headerlink" title="画布项目中富文本编辑器的实现浅析"></a>画布项目中富文本编辑器的实现浅析</h2><h4 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h4><p>该画布项目采用 <strong>wangEditor</strong>（v5 版本）的 React 封装组件 @wangeditor/editor-for-react 实现富文本编辑功能。主要通过两个组件协作完成：</p><ul><li>RichTextEditor.tsx：核心富文本编辑器封装，负责工具栏和编辑区的渲染与配置。</li><li>BottomTextEditor.tsx：底部面板式编辑器，仅在选中单个文本元素时显示，将富文本编辑器集成到画布操作流程中，支持实时更新元素内容并记录撤销/重做操作。</li></ul><p>主要形式是一个底部面板，单击文本元素会出现</p><h4 id="0x01-RichTextEditor-组件实现"><a href="#0x01-RichTextEditor-组件实现" class="headerlink" title="0x01 RichTextEditor 组件实现"></a>0x01 RichTextEditor 组件实现</h4><p>RichTextEditor 是对 wangEditor 的二次封装，提供可复用的富文本编辑器</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">"@wangeditor/editor/dist/css/style.css"</span>;<br><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Editor</span>, <span class="hljs-title class_">Toolbar</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@wangeditor/editor-for-react"</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">toolbarConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IToolbarConfig</span>&gt; = {<br>  <span class="hljs-attr">toolbarKeys</span>: [<br>    <span class="hljs-string">"bold"</span>,<br>    <span class="hljs-string">"italic"</span>,<br>    <span class="hljs-string">"underline"</span>,<br>    <span class="hljs-string">"through"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"fontSize"</span>,<br>    <span class="hljs-string">"fontFamily"</span>,<br>    <span class="hljs-string">"color"</span>,<br>    <span class="hljs-string">"bgColor"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"justifyLeft"</span>,<br>    <span class="hljs-string">"justifyCenter"</span>,<br>    <span class="hljs-string">"justifyRight"</span>,<br>    <span class="hljs-string">"|"</span>,<br>    <span class="hljs-string">"undo"</span>,<br>    <span class="hljs-string">"redo"</span>,<br>  ],<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">editorConfig</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">IEditorConfig</span>&gt; = {<br>  <span class="hljs-attr">placeholder</span>: <span class="hljs-string">"请输入文本..."</span>,<br>  <span class="hljs-attr">autoFocus</span>: <span class="hljs-literal">true</span>,<br>};<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (editor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    editor.<span class="hljs-title function_">destroy</span>();<br>    <span class="hljs-title function_">setEditor</span>(<span class="hljs-literal">null</span>);<br>  };<br>}, [editor]);<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"..."</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> <span class="hljs-attr">editor</span>=<span class="hljs-string">{editor}</span> <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{toolbarConfig}</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"simple"</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Editor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">defaultConfig</span>=<span class="hljs-string">{editorConfig}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onCreated</span>=<span class="hljs-string">{setEditor}</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(editor)</span> =&gt;</span> onChange(editor.getHtml())}</span><br><span class="language-xml">      mode="simple"</span><br><span class="language-xml">      style={{ height: "200px", overflowY: "auto" }}</span><br><span class="language-xml">    /&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>工具栏配置（toolbarConfig）</strong> 通过 toolbarKeys 指定显示的菜单键（加粗、斜体、下划线、删除线、字体大小/家族、颜色、背景色、对齐方式）以及撤销/重做。</li><li><strong>编辑器配置（editorConfig）</strong> 设置占位符和自动聚焦。wangEditor 支持更丰富的配置（如最大长度、自定义菜单等），此处保持最小化。</li><li><strong>生命周期管理</strong> 使用 useEffect 在组件卸载或 editor 实例变化时调用 editor.destroy()，防止内存泄漏。</li><li><strong>内容同步</strong>value props 控制初始 HTML，onChange 回调通过 editor.getHtml() 获取最新 HTML 内容并向上通知。</li></ol><h4 id="0x02-BottomTextEditor-组件实现"><a href="#0x02-BottomTextEditor-组件实现" class="headerlink" title="0x02 BottomTextEditor 组件实现"></a>0x02 BottomTextEditor 组件实现</h4><p>BottomTextEditor 将富文本编辑器集成到画布状态管理中，仅针对选中单个文本元素时激活。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> { selectedIds, elements, updateElement } = <span class="hljs-title function_">useStore</span>();<br><br><span class="hljs-keyword">const</span> selectedId = selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> ? selectedIds[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> element = selectedId ? elements[selectedId] : <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">const</span> [localHtml, setLocalHtml] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>);<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (element &amp;&amp; element.<span class="hljs-property">type</span> === <span class="hljs-string">"text"</span>) {<br>    <span class="hljs-title function_">setLocalHtml</span>(element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>);<br>  }<br>}, [element?.<span class="hljs-property">id</span>, element?.<span class="hljs-property">text</span>]);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params"><span class="hljs-attr">html</span>: <span class="hljs-built_in">string</span></span>) =&gt; {<br>  <span class="hljs-title function_">setLocalHtml</span>(html);<br>  <span class="hljs-keyword">const</span> initialText = element.<span class="hljs-property">text</span> || <span class="hljs-string">""</span>;<br>  <span class="hljs-title function_">updateElement</span>(element.<span class="hljs-property">id</span>, { <span class="hljs-attr">text</span>: html });<br><br>  <span class="hljs-keyword">const</span> updateCommand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateElementPropertyCommand</span>(<br>    { <span class="hljs-attr">id</span>: element.<span class="hljs-property">id</span>, <span class="hljs-attr">property</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">oldValue</span>: initialText, <span class="hljs-attr">newValue</span>: html },<br>    <span class="hljs-string">"修改文本内容"</span><br>  );<br>  undoRedoManager.<span class="hljs-title function_">executeCommand</span>(updateCommand);<br>};<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-8 ... animate-slide-up"</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">RichTextEditor</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{localHtml}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ol><li><strong>选中元素判断</strong> 从 Zustand store（canvasStore）获取选中 ID 和元素集合，仅当选中单个文本类型元素时渲染编辑器。</li><li><strong>本地状态（localHtml）</strong> 使用 useState 维护本地 HTML 副本，并在选中元素变化时通过 useEffect 同步 store 中的 element.text。 此设计主要解决中文输入法（IME）组成阶段的问题：在拼音输入过程中，wangEditor 的 onChange 会频繁触发，若直接更新全局 store，可能导致输入延迟、光标跳动或内容混乱。通过本地状态缓冲实时变化，避免不必要的 store 更新。</li><li><strong>内容变更处理（handleChange）</strong><ul><li>更新本地状态。</li><li>实时调用 updateElement 更新画布 store，驱动 canvas 重新渲染文本元素。</li><li>创建 UpdateElementPropertyCommand 命令并执行，支持撤销/重做（undo/redo）。命令记录旧值和新值，处理历史操作</li></ul></li></ol><h4 id="0x03-关键问题解决与设计"><a href="#0x03-关键问题解决与设计" class="headerlink" title="0x03 关键问题解决与设计"></a>0x03 关键问题解决与设计</h4><ol><li><strong>输入法兼容性</strong> 中文输入过程中，组成事件（composition）会多次触发编辑器变更。若直接在 onChange 中更新全局状态，可能导致性能问题或输入体验不佳。本实现通过本地状态缓冲 setLocalHtml(html) 缓解该问题</li><li><strong>实时渲染与历史管理</strong> 实时更新 store 确保画布文本即时反映变更；同时通过命令模式记录操作，实现完整的 undo/redo 支持。</li></ol><h4 id="0x04-当前实现的风险与不足分析"><a href="#0x04-当前实现的风险与不足分析" class="headerlink" title="0x04 当前实现的风险与不足分析"></a>0x04 当前实现的风险与不足分析</h4><p>当前实现虽已满足基础富文本编辑需求，但是还是有一些问题</p><ol><li><strong>输入法体验优化不彻底</strong> 虽通过本地状态缓冲缓解了 IME 组成阶段的频繁更新问题，但未监听 compositionstart/compositionend 事件。在某些极端输入场景（如快速切换输入法或长句输入）下，仍可能出现光标偏移或临时内容丢失的现象。</li><li><strong>内容净化与 XSS 防护不足</strong> 完全依赖 wangEditor 内置的有限转义机制，未引入 DOMPurify 等专用净化库。在用户插入外部链接、图片或自定义 HTML 时，存在潜在的存储型或 DOM 型 XSS 风险，尤其在内容后续导出或分享场景中。</li><li><strong>样式与对齐精度问题</strong> wangEditor 生成的 HTML 结构（如多层 span/div 嵌套）与画布自定义文本渲染逻辑可能不完全匹配，导致编辑器中预览效果与画布最终渲染存在细微差异（如行高、字间距、对齐方式）。</li><li><strong>性能与内存管理</strong> 频繁的实时更新（onChange 触发 store 更新与命令记录）在长文本场景下可能导致轻微卡顿；此外，未对编辑器实例进行复用，当快速切换不同文本元素时会反复创建/销毁实例，增加内存开销。</li></ol><p>面对这些问题后续都可以做一些改进：</p><ol><li><strong>引入 DOMPurify 进行内容净化来处理 XSS 问题</strong> 在内容存储前（提交到 store 或后端）及渲染时统一调用 DOMPurify.sanitize，对 HTML 进行严格过滤。自定义白名单以保留 wangEditor 支持的必要标签与属性，同时移除所有事件处理器及危险协议。</li><li><strong>完善输入法兼容性</strong> 在 RichTextEditor 中监听 composition 事件，在组成阶段暂不触发 handleChange，仅在 compositionend 后统一更新 store 与命令记录，进一步消除输入延迟与光标问题。</li><li><strong>性能优化</strong> 实现编辑器实例复用（单一全局实例，根据选中元素动态切换内容），并在长文本时增加防抖处理，减少不必要的 store 更新与命令执行。</li></ol><h4 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h4><p>主要就是 wangEditor 的 React 封装，结合 Zustand 状态管理和命令模式，来适配画布类项目的文本编辑需求，实现了基础的文本编辑功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;a href=&quot;#画布项目中富文本编辑器的实现浅析&quot; class=&quot;headerlink&quot; title=&quot;画布项目中富文本编辑器的实现浅析&quot;&gt;&lt;/a&gt;画布项目中富文本编辑器的实现浅析&lt;/h2&gt;&lt;h4 id=&quot;0x00-概述&quot;&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-17-前端画布设计Vol.1 实现基础元素渲染和状态控制</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/43445.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/43445.html</id>
    <published>2025-12-27T17:23:08.000Z</published>
    <updated>2025-12-28T17:54:19.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PixiJS-实现基础元素渲染和状态控制"><a href="#PixiJS-实现基础元素渲染和状态控制" class="headerlink" title="PixiJS 实现基础元素渲染和状态控制"></a>PixiJS 实现基础元素渲染和状态控制</h2><p>PixiJS 是一个强大的 2D 渲染引擎，它使用 WebGL 和 Canvas 技术来高效地渲染图形，主要通过  ElementRenderer  类实现。</p><h3 id="基本图形渲染实现"><a href="#基本图形渲染实现" class="headerlink" title="基本图形渲染实现"></a>基本图形渲染实现</h3><p>设计的画布中，基本图形是通过 PixiJS 的 Graphics 类绘制的，支持以下基本图形类型：</p><ol><li><p><strong>矩形 (rect)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆角矩形 (rounded rectangle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">roundRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.<span class="hljs-property">width</span>, data.<span class="hljs-property">height</span>, data.<span class="hljs-property">radius</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>圆形 (circle)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">ellipse</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li><li><p><strong>菱形 (diamond)</strong>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-title function_">poly</span>([<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">width</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,<br>  data.<span class="hljs-property">height</span>,<br>  <span class="hljs-number">0</span>,<br>  data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>,<br>]);<br>g.<span class="hljs-title function_">fill</span>({ <span class="hljs-attr">color</span>: fillColor, alpha });<br>g.<span class="hljs-title function_">stroke</span>({ <span class="hljs-attr">width</span>: strokeWidth, <span class="hljs-attr">color</span>: strokeColor });<br></code></pre></td></tr></table></figure></li></ol><h3 id="图形属性实现"><a href="#图形属性实现" class="headerlink" title="图形属性实现"></a>图形属性实现</h3><p>每个图形元素都由  CanvasElement  接口定义，支持以下属性：</p><ol><li><p><strong>背景色 (background)</strong>:</p><ul><li>通过  fill  属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li><li>使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>边框宽度 (border-width)</strong>:</p><ul><li>通过  strokeWidth  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li></ul></li><li><p><strong>边框颜色 (border-color)</strong>:</p><ul><li>通过  stroke  属性实现</li><li>例如：<code>g.stroke({ width: strokeWidth, color: strokeColor })</code></li><li>同样使用 <code>PIXI.Color</code> 类处理颜色值</li></ul></li><li><p><strong>透明度 (alpha)</strong>:</p><ul><li>通过 alpha 属性实现</li><li>例如：<code>g.fill({ color: fillColor, alpha })</code></li></ul></li></ol><p>在  ElementRenderer  类中，图形渲染的过程包括以下步骤：</p><ol><li>首先清空之前的图形绘制：<code>g.clear()</code></li><li><p>设置绘制样式（边框宽度、边框颜色、填充颜色、透明度）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> strokeWidth = data.<span class="hljs-property">strokeWidth</span> ?? <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> strokeColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">stroke</span>);<br><span class="hljs-keyword">const</span> fillColor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">PIXI</span>.<span class="hljs-title class_">Color</span>(data.<span class="hljs-property">fill</span>);<br><span class="hljs-keyword">const</span> alpha = data.<span class="hljs-property">alpha</span> ?? <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>根据图形类型绘制对应的形状</p></li><li><p>设置图形的位置和旋转：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">g.<span class="hljs-property">pivot</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(data.<span class="hljs-property">x</span> + data.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, data.<span class="hljs-property">y</span> + data.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>g.<span class="hljs-property">rotation</span> = data.<span class="hljs-property">rotation</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="特殊功能"><a href="#特殊功能" class="headerlink" title="特殊功能"></a>特殊功能</h3><ol><li><strong>旋转功能</strong>: 通过设置  pivot  点和  rotation  属性实现</li><li><strong>圆角矩形</strong>: 使用  <code>g.roundRect(x, y, width, height, radius)</code>  方法</li><li><strong>纹理缓存</strong>: 对图像元素使用纹理缓存以提高性能</li><li><strong>动态加载</strong>: 图像元素支持异步加载纹理</li></ol><h2 id="状态管理机制"><a href="#状态管理机制" class="headerlink" title="状态管理机制"></a>状态管理机制</h2><p>在您的项目中，状态管理由  zustand  库实现，通过  CanvasStore  集中管理所有画布元素的状态。状态管理包含以下几个核心部分：</p><h3 id="1-状态结构"><a href="#1-状态结构" class="headerlink" title="1. 状态结构"></a>1. 状态结构</h3><ul><li>elements: 一个记录对象，包含所有画布元素</li><li>selectedIds: 当前选中的元素 ID 数组</li><li>tool: 当前使用的工具类型</li><li>currentStyle: 当前绘制样式（填充色、边框色、边框宽度等）</li></ul><h3 id="2-状态更新机制"><a href="#2-状态更新机制" class="headerlink" title="2. 状态更新机制"></a>2. 状态更新机制</h3><p>状态更新通过以下方法实现：</p><ul><li>addElement: 添加元素</li><li>updateElement: 更新元素属性</li><li>removeElements: 删除元素</li><li>setSelected: 设置选中的元素</li><li>batchUpdateElements: 批量更新元素（用于提高性能）</li></ul><h2 id="元素渲染机制"><a href="#元素渲染机制" class="headerlink" title="元素渲染机制"></a>元素渲染机制</h2><p>元素渲染通过  ElementRenderer  类实现，它与状态管理紧密结合：</p><h3 id="1-状态-渲染同步"><a href="#1-状态-渲染同步" class="headerlink" title="1. 状态-渲染同步"></a>1. 状态-渲染同步</h3><p>在  Core_StageManager.ts  中，有一个关键的订阅机制：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">useStore.<span class="hljs-title function_">subscribe</span>(   <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">elements</span>: state.<span class="hljs-property">elements</span>, <span class="hljs-attr">selectedIds</span>: state.<span class="hljs-property">selectedIds</span>, <span class="hljs-attr">tool</span>: state.<span class="hljs-property">tool</span> }),   <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {     <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">destroyed</span>) {       <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRenderer</span>.<span class="hljs-title function_">renderElements</span>(state.<span class="hljs-property">elements</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementLayer</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">destroyed</span>)       <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerRenderer</span>.<span class="hljs-title function_">renderTransformer</span>(         state.<span class="hljs-property">elements</span>,         state.<span class="hljs-property">selectedIds</span>,         <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRenderer</span>.<span class="hljs-title function_">getSpriteMap</span>(),         <span class="hljs-variable language_">this</span>.<span class="hljs-property">onHandleDown</span>,         <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span>.<span class="hljs-property">scale</span>.<span class="hljs-property">x</span>,       )       <span class="hljs-comment">// ...</span><br><span class="hljs-comment">//</span><br>}<br> },   { <span class="hljs-attr">equalityFn</span>: stateEqualityFn }, )<br></code></pre></td></tr></table></figure><p>每当状态发生变化时，就会触发渲染更新。</p><h3 id="2-渲染过程"><a href="#2-渲染过程" class="headerlink" title="2. 渲染过程"></a>2. 渲染过程</h3><p>ElementRenderer.renderElements  方法遍历所有元素并执行以下操作：</p><ol><li><strong>元素映射管理</strong>：使用  spriteMap  记录已渲染的元素</li><li><strong>类型处理</strong>：根据元素类型（矩形、圆形、文本、图像等）进行相应渲染</li><li><strong>属性应用</strong>：将状态中的属性（位置、大小、颜色等）应用到渲染对象</li></ol><h3 id="3-状态与渲染的实时同步"><a href="#3-状态与渲染的实时同步" class="headerlink" title="3. 状态与渲染的实时同步"></a>3. 状态与渲染的实时同步</h3><p>当状态变化时，例如：</p><ul><li>用户拖动元素时，updateElement  更新元素的  x  和  y  坐标</li><li>用户改变填充颜色时，updateElement  更新  fill  属性</li><li>选择元素时，setSelected  更新  selectedIds</li></ul><p>这些状态变更会立即触发渲染更新，确保 UI 与状态保持同步。</p><h2 id="状态控制机制"><a href="#状态控制机制" class="headerlink" title="状态控制机制"></a>状态控制机制</h2><h3 id="1-撤销-重做"><a href="#1-撤销-重做" class="headerlink" title="1. 撤销/重做"></a>1. 撤销/重做</h3><p>项目集成了撤销/重做功能，通过  UndoRedoManager  和命令模式实现：</p><ul><li>每个操作（添加、删除、更新）都创建一个命令对象</li><li>命令对象包含执行和撤销操作的逻辑</li><li>undo  和  redo  方法控制历史记录栈</li></ul><h3 id="2-选择状态管理"><a href="#2-选择状态管理" class="headerlink" title="2. 选择状态管理"></a>2. 选择状态管理</h3><ul><li>selectedIds  数组跟踪当前选中的元素</li><li>选择变化会触发渲染更新，显示选择框和控制点</li><li>TransformerRenderer 负责渲染选择框和调整手柄</li></ul><h3 id="3-工具状态管理"><a href="#3-工具状态管理" class="headerlink" title="3. 工具状态管理"></a>3. 工具状态管理</h3><ul><li>tool  属性跟踪当前使用的工具</li><li>工具变化会影响交互行为和光标样式</li><li>不同工具对相同的用户输入（如鼠标点击）会有不同的响应</li></ul><h3 id="4-实时协作"><a href="#4-实时协作" class="headerlink" title="4. 实时协作"></a>4. 实时协作</h3><p>项目使用 Yjs 实现实时协作功能：</p><ul><li>状态变化通过 Yjs 同步到其他用户</li><li>Yjs 的 observe 机制确保本地状态与共享状态同步</li><li>使用事务（transact）保证操作的原子性</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><strong>状态比较优化</strong>：使用  stateEqualityFn  减少不必要的重渲染</li><li><strong>批量更新</strong>：batchUpdateElements  方法用于批量更新元素，减少渲染次数</li><li><strong>精灵映射</strong>：ElementRenderer  保留精灵映射以避免重复创建/销毁</li><li><strong>防抖机制</strong>：虽然代码中注释掉了防抖，但设计中考虑了性能优化</li></ol><p>这种架构确保了状态与渲染之间的紧密同步，同时保持了良好的性能和可扩展性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PixiJS-实现基础元素渲染和状态控制&quot;&gt;&lt;a href=&quot;#PixiJS-实现基础元素渲染和状态控制&quot; class=&quot;headerlink&quot; title=&quot;PixiJS 实现基础元素渲染和状态控制&quot;&gt;&lt;/a&gt;PixiJS 实现基础元素渲染和状态控制&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-27-算法刷题-关于链表操作</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/40452.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/40452.html</id>
    <published>2025-12-27T08:12:42.000Z</published>
    <updated>2025-12-27T10:53:26.438Z</updated>
    
    <content type="html"><![CDATA[<p>后悔数据结构当初没有好好学的第n天<br>现在恶补，知识学爆</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><p>基础操作：</p><ul><li>查找元素：根据值查找节点位置</li><li>指定位置插入：在特定位置插入新节点</li><li>指定位置获取：获取特定位置的节点值</li><li>指定位置删除：删除特定位置的节点</li><li>获取长度：统计链表中节点的数量</li></ul><div class="table-container"><table><thead><tr><th></th><th>题目描述</th><th>主要实现思路</th></tr></thead><tbody><tr><td>BM1</td><td>反转链表</td><td>使用三指针（prev、curr、next）迭代反转：保存下一个节点，反转当前指向，移动指针。返回prev作为新头。</td></tr><tr><td>BM2</td><td>链表内指定区间反转</td><td>引入虚拟头结点定位第m-1个节点（pre）。然后在[m,n]区间执行(n-m)次头插法（逐个将下一个节点插入pre后）。</td></tr><tr><td>BM3</td><td>链表中的节点每k个一组翻转</td><td>每k个节点为一组，使用反转链表方法局部反转。若剩余不足k个，则保持原序。递归或迭代均可，推荐迭代分段处理。</td></tr><tr><td>BM4</td><td>合并两个排序的链表</td><td>双指针模拟归并排序：比较两个链表当前节点值，小者接入新链表，移动对应指针。处理剩余部分。</td></tr><tr><td>BM5</td><td>合并k个已排序的链表</td><td>使用小根堆（优先队列）维护k个链表头结点，每次弹出最小值并接入结果链表，同时推入其下一个节点。</td></tr><tr><td>BM6</td><td>判断链表中是否有环</td><td>快慢指针（Floyd判圈算法）：fast每次走2步，slow走1步。若相遇则有环，否则无环。</td></tr><tr><td>BM7</td><td>链表中环的入口结点</td><td>先用快慢指针相遇于环内某点，再令一指针从头启动，与慢指针同步移动，相遇处即环入口。</td></tr><tr><td>BM8</td><td>链表中倒数最后k个结点</td><td>快慢指针：fast先走k步，然后slow与fast同步移动，至fast到尾时slow即为倒数第k个节点。</td></tr><tr><td>BM9</td><td>删除链表的倒数第n个节点</td><td>同BM8定位倒数第n+1个节点（pre），然后pre.next = pre.next.next删除目标节点。注意头节点特殊处理。</td></tr><tr><td>BM10</td><td>两个链表的第一个公共结点</td><td>双指针同步走：先计算长度差，长者先走差值步；或让指针走完一链表后换另一链表，总路程相等时相遇即公共节点。</td></tr><tr><td>BM11</td><td>链表相加(二)</td><td>模拟加法从低位到高位（需先反转链表或用栈），处理进位。结果可能需反转回原序。</td></tr><tr><td>BM12</td><td>单链表的排序</td><td>归并排序（自底向上）：分段合并有序子链表，或快慢指针找中点递归归并。时间O(n log n)。</td></tr><tr><td>BM13</td><td>判断一个链表是否为回文结构</td><td>快慢指针找中点，反转后半部分，与前半部分逐节点比较值是否相等。恢复链表可选。</td></tr><tr><td>BM14</td><td>链表的奇偶重排</td><td>分离奇偶位节点成两个链表（odd、even），然后even接odd尾部。注意偶数长度处理。</td></tr><tr><td>BM15</td><td>删除有序链表中重复的元素-I</td><td>单指针遍历：若当前节点与下一节点值相同，跳过下一节点（保留首次出现）。</td></tr><tr><td>BM16</td><td>删除有序链表中重复的元素-II</td><td>引入虚拟头结点，双指针或单指针遍历：若连续重复，跳过整个重复段（一个不留）。</td></tr></tbody></table></div><hr><p>一般会给出一个最基础的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = (val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = (next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next);<br>}<br></code></pre></td></tr></table></figure><ul><li><strong>节点包含两个成员</strong>：<ul><li>val：存储节点的值，通常为整数（int），题目中 |val| ≤ 1000。</li><li>next：指向下一个节点的指针（引用），类型为同类 ListNode*（或 ListNode），初始可能为 NULL/null/None</li></ul></li><li><strong>无哑头节点（dummy head）</strong>：输入的 head 就是真实头结点（有有效值），除非题目特别说明</li><li><strong>单向链表</strong>：只能从头到尾遍历，无前向指针</li><li><strong>输入形式</strong>：<ul><li>函数签名通常为 ListNode* head（或类似），可能额外传入其他参数（如 m、n、k 等）</li><li>空链表：head = NULL / null / None</li></ul></li><li><strong>输出形式</strong>：<ul><li>大多数题目要求返回新的头结点（ListNode*）</li><li>操作通常要求<strong>原地修改</strong>，以满足空间复杂度 O(1)</li></ul></li></ul><hr><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="单链表常见操作的实现方法"><a href="#单链表常见操作的实现方法" class="headerlink" title="单链表常见操作的实现方法"></a>单链表常见操作的实现方法</h3><p>以下针对单链表（节点结构为 val 和 next）的几种常见操作，提供标准、高效的实现思路。所有操作均基于从头结点开始遍历，时间复杂度与空间复杂度分析清晰。假设节点定义如下（以 JavaScript 为例，其他语言类似）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next || <span class="hljs-literal">null</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="1-查找元素：根据值查找节点位置（返回位置或节点）"><a href="#1-查找元素：根据值查找节点位置（返回位置或节点）" class="headerlink" title="1. 查找元素：根据值查找节点位置（返回位置或节点）"></a>1. 查找元素：根据值查找节点位置（返回位置或节点）</h4><p><strong>思路</strong>：从头遍历，逐个比较节点值，直到找到匹配值或到达链表末尾。</p><p><strong>实现要点</strong>：</p><ul><li>返回第一个匹配节点的<strong>位置</strong>（从 1 开始）或节点本身。</li><li>未找到返回 -1 或 null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findNode</span>(<span class="hljs-params">head, target</span>) {<br>    <span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">if</span> (curr.<span class="hljs-property">val</span> === target) {<br>            <span class="hljs-keyword">return</span> pos;  <span class="hljs-comment">// 或 return curr; 返回节点本身</span><br>        }<br>        curr = curr.<span class="hljs-property">next</span>;<br>        pos++;<br>    }<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）"><a href="#2-指定位置插入：在第-i-个位置插入新节点（i-从-1-开始）" class="headerlink" title="2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）"></a>2. 指定位置插入：在第 i 个位置插入新节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，将新节点插入其后。特殊处理插入到头部（i=1）。</p><p><strong>实现要点</strong>：</p><ul><li>若 i=1，新节点成为新头。</li><li>若 i &gt; 长度，插入失败或插入尾部（视题目要求）。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAtPosition</span>(<span class="hljs-params">head, i, val</span>) {<br>    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>        newNode.<span class="hljs-property">next</span> = head;<br>        <span class="hljs-keyword">return</span> newNode;  <span class="hljs-comment">// 新头结点</span><br>    }<br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围，不插入</span><br>    <br>    newNode.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>;<br>    curr.<span class="hljs-property">next</span> = newNode;<br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）"><a href="#3-指定位置获取：获取第-i-个节点的値（i-从-1-开始）" class="headerlink" title="3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）"></a>3. 指定位置获取：获取第 i 个节点的値（i 从 1 开始）</h4><p><strong>思路</strong>：遍历 i-1 步，直接返回当前节点的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> curr ? curr.<span class="hljs-property">val</span> : <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 未找到返回 null</span><br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="4-指定位置删除：删除第-i-个节点（i-从-1-开始）"><a href="#4-指定位置删除：删除第-i-个节点（i-从-1-开始）" class="headerlink" title="4. 指定位置删除：删除第 i 个节点（i 从 1 开始）"></a>4. 指定位置删除：删除第 i 个节点（i 从 1 开始）</h4><p><strong>思路</strong>：遍历到第 i-1 个节点，修改其 next 指向跳过第 i 个节点。特殊处理删除头结点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAtPosition</span>(<span class="hljs-params">head, i</span>) {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 删除头结点</span><br>    <br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>; pos &lt; i - <span class="hljs-number">1</span> &amp;&amp; curr !== <span class="hljs-literal">null</span>; pos++) {<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (curr === <span class="hljs-literal">null</span> || curr.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// i 超出范围</span><br>    <br>    curr.<span class="hljs-property">next</span> = curr.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 跳过第 i 个节点</span><br>    <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(i) → 最坏 O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="5-获取链表长度（节点数量）"><a href="#5-获取链表长度（节点数量）" class="headerlink" title="5. 获取链表长度（节点数量）"></a>5. 获取链表长度（节点数量）</h4><p><strong>思路</strong>：遍历链表，累计计数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>        len++;<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> len;<br>}<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="BM1-全量反转链表"><a href="#BM1-全量反转链表" class="headerlink" title="BM1  | 全量反转链表"></a>BM1  | 全量反转链表</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤n≤10000≤n≤1000</p><p>要求：空间复杂度 O(1)O(1) ，时间复杂度 O(n)O(n) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p class='item-img' data-src='https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249'><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt=""></p><hr><p>解法：</p><ul><li>初始化 prev 为 null（新链表的尾部）。</li><li>current 从链表头节点开始。</li><li>在循环中：<ul><li>暂存 next = current.next（避免指针丢失）。</li><li>将 current.next 指向 prev（反转当前指针）。</li><li>更新 prev = current（前移 prev）。</li><li>更新 current = next（前移 current）。</li></ul></li><li>循环结束后，prev 指向原链表的尾节点（新头节点），更新 list.head = prev。</li></ul><p>其实就是三指针原地反转</p><p class='item-img' data-src='https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp'><img src="https://pic4.zhimg.com/v2-6a742659e12b185569b64a1f773bd993_b.webp" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ReverseList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span></span>): <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br><br>    <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    <br>        <span class="hljs-comment">// 保存下一个节点，防止断链</span><br>        <span class="hljs-keyword">let</span> next = curr.<span class="hljs-property">next</span>;<br><br>        <span class="hljs-comment">// 反转当前节点的指向</span><br>        curr.<span class="hljs-property">next</span> = prev;<br><br>        <span class="hljs-comment">// 指针向前移动</span><br>        prev = curr;<br>        curr = next;<br>    }<br>    <span class="hljs-comment">// prev 指向反转后的新头结点</span><br>    <span class="hljs-keyword">return</span> prev;<br>};<br></code></pre></td></tr></table></figure><h3 id="BM2-反转链表部分区间"><a href="#BM2-反转链表部分区间" class="headerlink" title="BM2  | 反转链表部分区间"></a>BM2  | 反转链表部分区间</h3><p>给定一个单链表的头结点 head，长度为 n，反转该链表从位置 m 到 n 的部分，返回反转后的链表。</p><p>数据范围： 0≤m≤n≤n≤1000 ，链表中任意节点的值满足 |val|≤1000</p><p>例如：<br>给出的链表为 1→2→3→4→5→NULL1→2→3→4→5→NULL, m=2,n=4m=2,n=4,<br>返回 1→4→3→2→5→NULL1→4→3→2→5→NULL.  </p><p>要实现原地反转指定区间，需要：</p><ol><li>找到反转区间的前一个节点（pre），即第 m-1 个节点。</li><li>找到反转区间的最后一个节点（记为 end），即第 n 个节点。</li><li>将 [m, n] 区间使用经典链表反转方法进行原地反转。</li><li>正确连接反转后的区间与前后部分：<ul><li>pre.next 指向反转后区间的新的头节点（原第 n 个节点）。</li><li>反转后区间的尾节点（原第 m 个节点）指向 end.next。</li></ul></li></ol><p>关键操作：</p><ul><li>先遍历定位到 pre 和反转区间的起始节点 start（第 m 个节点）。</li><li>然后在 [start, end] 区间内使用三指针迭代反转。</li><li>最后调整指针连接。</li></ul><p class='item-img' data-src='https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif'><img src="https://pica.zhimg.com/v2-88b21fbd767be1a41379e156251ad554_1440w.gif" alt="alt text"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">m</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || m === n) <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> pre = dummy;<br><br>    <span class="hljs-comment">// 移动到第 m-1 个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) {<br>        pre = pre.<span class="hljs-property">next</span>!;<br>    }<br><br>    <span class="hljs-keyword">let</span> start = pre.<span class="hljs-property">next</span>!;   <span class="hljs-comment">// 第 m 个节点（反转区间的原头部）</span><br>    <span class="hljs-keyword">let</span> then = start.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 第 m+1 个节点（待头插的节点）</span><br><br>    <span class="hljs-comment">// 执行 (n - m) 次头插</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++) {<br>        start.<span class="hljs-property">next</span> = then.<span class="hljs-property">next</span>;   <span class="hljs-comment">// 从原区间摘除 then</span><br>        then.<span class="hljs-property">next</span> = pre.<span class="hljs-property">next</span>;     <span class="hljs-comment">// then 插入 pre 之后（成为新头部）</span><br>        pre.<span class="hljs-property">next</span> = then;          <span class="hljs-comment">// 更新 pre 的 next</span><br>        then = start.<span class="hljs-property">next</span>;        <span class="hljs-comment">// 更新 then 为下一个待移动节点</span><br>    }<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;后悔数据结构当初没有好好学的第n天&lt;br&gt;现在恶补，知识学爆&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?sou</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-力扣百题速练（Javascript、TypeScript）Vol.2</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39620.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39620.html</id>
    <published>2025-12-26T05:57:08.000Z</published>
    <updated>2025-12-27T12:52:43.608Z</updated>
    
    <content type="html"><![CDATA[<p>这里是力扣速刷第二期awa<br>说是速刷其实卡了挺久</p><p class='item-img' data-src='https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b'><img src="https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source=d16d100b" style="height=100px"></p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为  <code>n</code>  的整数数组  <code>height</code> 。有  <code>n</code>  条垂线，第  <code>i</code>  条线的两个端点是  <code>(i, 0)</code>  和  <code>(i, height[i])</code><br>找出其中的两条线，使得它们与  <code>x</code>  轴共同构成的容器可以容纳最多的水<br>返回容器可以储存的最大水量</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49</p><p>最开始直接暴力解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; height.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">let</span> xin = (j - i) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]);<br>      <span class="hljs-keyword">if</span> (xin &gt; res) {<br>        res = xin;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>后面想了一下，做了些改进</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params"><span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (i &lt; j) {<br>    <span class="hljs-keyword">let</span> fin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[i], height[j]) * (j - i);<br>    <span class="hljs-keyword">if</span> (fin &gt; res) {<br>      res = fin;<br>    }<br>    <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) {<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      j--;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>初始时宽度最大，若当前面积不是最大，则必须通过增加高度来补偿宽度损失<br>移动较短指针是因为：保持较短边不动，宽度只会变小，面积不可能增大；只有移动较短边才可能遇到更高的高度，从而提升面积</p><p>经典双指针加贪心的题</p><hr><h2 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h2><p>七个不同的符号代表罗马数字，其值如下：</p><div class="table-container"><table><thead><tr><th>符号</th><th>值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：</p><ul><li>如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。</li><li>如果该值以 4 或 9 开头，使用  <strong>减法形式</strong>，表示从以下符号中减去一个符号，例如 4 是 5 (<code>V</code>) 减 1 (<code>I</code>): <code>IV</code> ，9 是 10 (<code>X</code>) 减 1 (<code>I</code>)：<code>IX</code>。仅使用以下减法形式：4 (<code>IV</code>)，9 (<code>IX</code>)，40 (<code>XL</code>)，90 (<code>XC</code>)，400 (<code>CD</code>) 和 900 (<code>CM</code>)。</li><li>只有 10 的次方（<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (<code>V</code>)，50 (<code>L</code>) 或 500 (<code>D</code>)。如果需要将符号附加 4 次，请使用  <strong>减法形式</strong>。</li></ul><p>给定一个整数，将其转换为罗马数字。</p><p><strong>示例 1：</strong></p><p>**输入：num = 3749</p><p><strong>输出：</strong> “MMMDCCXLIX”</p><p><strong>解释：</strong></p><p>3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)<br>700 = DCC 由于 500 (D) + 100 (C) + 100 (C)<br>40 = XL 由于 50 (L) 减 10 (X)<br>9 = IX 由于 10 (X) 减 1 (I)<br>注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位</p><p><strong>示例 2：</strong></p><p>**输入：num = 58</p><p><strong>输出：</strong>“LVIII”</p><p><strong>解释：</strong></p><p>50 = L<br>8 = VIII</p><p><strong>示例 3：</strong></p><p>**输入：num = 1994</p><p><strong>输出：</strong>“MCMXCIV”</p><p><strong>解释：</strong></p><p>1000 = M<br>900 = CM<br>90 = XC<br>4 = IV</p><p>最初想法是尝试通过<strong>逐位处理数字</strong>的方式将整数转换为罗马数字：</p><ol><li><strong>将数字转换为字符串并反转</strong>： 使用 reverseString(num.toString()) 将数字从高位到低位变为低位到高位（例如 1994 → “4991”）,从个位开始依次处理每个数位（个位、十位、百位、千位）</li><li><strong>为每个数位定义对应的罗马符号</strong>：<ul><li><code>个位（i===0）：1→"I", 5→"V", 10→"X"</code></li><li><code>十位（i===1）：1→"X", 5→"L", 10→"C"</code></li><li><code>百位（i===2）：1→"C", 5→"D", 10→"M"</code></li><li><code>千位（i===3）：直接用 "M" 重复</code></li></ul></li><li><strong>根据当前位上的数字（0-9）生成对应罗马表示</strong>：<ul><li>1-3：重复添加 “1” 的符号（curr1）</li><li>4：curr1 + curr2（如 “IV”）</li><li>5：curr2（如 “V”）</li><li>6-8：curr2 + 重复 (digit-5) 次 curr1</li><li>9：curr1 + curr3（如 “IX”）</li></ul></li><li><strong>使用数组 + unshift 收集符号</strong>： 因为已反转数字，低位先处理，使用 unshift（从数组头部插入）试图让高位符号最终出现在前面</li><li><strong>最后 join 成字符串返回</strong></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">let</span> curr1 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr2 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> curr3 = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span><br>    str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-keyword">let</span> top = <span class="hljs-title function_">reverseString</span>(num.<span class="hljs-title function_">toString</span>());<br>  <span class="hljs-keyword">let</span> l = top.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">finalstr</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">nums</span>(<span class="hljs-params"><span class="hljs-attr">pos</span>: <span class="hljs-built_in">number</span></span>) {<br>    <span class="hljs-keyword">const</span> di = <span class="hljs-title class_">Number</span>(top[pos]);<br>    <span class="hljs-keyword">if</span> (di === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">4</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">5</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di &lt;= <span class="hljs-number">8</span>) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; di - <span class="hljs-number">5</span>; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(curr1);<br>      }<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr2);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (di === <span class="hljs-number">9</span>) {<br>      finalstr.<span class="hljs-title function_">unshift</span>(curr1 + curr3);<br>    }<br>  }<br>  <span class="hljs-keyword">while</span> (i &lt; l) {<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {<br>      curr1 = <span class="hljs-string">"I"</span>;<br>      curr2 = <span class="hljs-string">"V"</span>;<br>      curr3 = <span class="hljs-string">"X"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span>) {<br>      curr1 = <span class="hljs-string">"X"</span>;<br>      curr2 = <span class="hljs-string">"L"</span>;<br>      curr3 = <span class="hljs-string">"C"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) {<br>      curr1 = <span class="hljs-string">"C"</span>;<br>      curr2 = <span class="hljs-string">"D"</span>;<br>      curr3 = <span class="hljs-string">"M"</span>;<br>      <span class="hljs-title function_">nums</span>(i);<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) {<br>      <span class="hljs-keyword">const</span> vas = <span class="hljs-title class_">Number</span>(top[i]);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; vas; j++) {<br>        finalstr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">"M"</span>);<br>      }<br>      i++;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> finalstr.<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>}<br></code></pre></td></tr></table></figure><p>题目标准解法是<strong>贪心算法 + 值-符号映射表</strong>，从高位到低位匹配最大可能值，这个写法确实没有想出来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">valueSymbols</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>][] = [<br>        [<span class="hljs-number">1000</span>, <span class="hljs-string">"M"</span>], [<span class="hljs-number">900</span>, <span class="hljs-string">"CM"</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">"D"</span>], [<span class="hljs-number">400</span>, <span class="hljs-string">"CD"</span>],<br>        [<span class="hljs-number">100</span>,  <span class="hljs-string">"C"</span>], [<span class="hljs-number">90</span>,  <span class="hljs-string">"XC"</span>], [<span class="hljs-number">50</span>,  <span class="hljs-string">"L"</span>], [<span class="hljs-number">40</span>,  <span class="hljs-string">"XL"</span>],<br>        [<span class="hljs-number">10</span>,   <span class="hljs-string">"X"</span>], [<span class="hljs-number">9</span>,   <span class="hljs-string">"IX"</span>], [<span class="hljs-number">5</span>,   <span class="hljs-string">"V"</span>], [<span class="hljs-number">4</span>,   <span class="hljs-string">"IV"</span>],<br>        [<span class="hljs-number">1</span>,    <span class="hljs-string">"I"</span>]<br>    ];<br><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [value, <span class="hljs-built_in">symbol</span>] <span class="hljs-keyword">of</span> valueSymbols) {<br>        <span class="hljs-keyword">while</span> (num &gt;= value) {<br>            result += <span class="hljs-built_in">symbol</span>;<br>            num -= value;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>  和  <code>M</code>。</p><p><strong>字符</strong> <strong>数值</strong><br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000</p><p>例如， 罗马数字  <code>2</code>  写做  <code>II</code> ，即为两个并列的 1 。<code>12</code>  写做  <code>XII</code> ，即为  <code>X</code> + <code>II</code> 。 <code>27</code>  写做  <code>XXVII</code>, 即为  <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  <code>IIII</code>，而是  <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code>  可以放在  <code>V</code> (5) 和  <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code>  可以放在  <code>L</code> (50) 和  <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code>  可以放在  <code>D</code> (500) 和  <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> s = “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> s = “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> s = “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> s = “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> s = “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p><p>直接从左到右遍历字符串，比较当前符号与下一个符号的值：</p><ul><li>如果当前值 &lt; 下一个值，则减去当前值（形成减法组合）。</li><li>否则加上当前值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> map = {<br>    <span class="hljs-attr">I</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">V</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">X</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">L</span>: <span class="hljs-number">50</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">D</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">M</span>: <span class="hljs-number">1000</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> current = map[s[i]];<br>    <span class="hljs-keyword">const</span> next = map[s[i + <span class="hljs-number">1</span>]];<br><br>    <span class="hljs-keyword">if</span> (next &amp;&amp; current &lt; next) {<br>      res += next - current;<br>      i++;<br>    } <span class="hljs-keyword">else</span> {<br>      res += current;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀</p><p>如果不存在公共前缀，返回空字符串  <code>""</code></p><p><strong>示例 1：</strong></p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p><strong>示例 2：</strong></p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀</p><p>题解比较简单，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params"><span class="hljs-attr">strs</span>: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (strs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">const</span> char = strs[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (i === strs[j].<span class="hljs-property">length</span> || strs[j][i] !== char) {<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i);<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></table></figure><p>主要就是注意一个写法，在 JavaScript（以及 TypeScript）中，<code>strs[0][i]</code> 是一种链式索引访问（chained indexing）的写法，用于访问二维结构或嵌套可索引对象中的元素</p><p>假设 <code>strs = ["flower", "flow", "flight"]</code>，循环变量 <code>i = 2</code> 时：</p><ul><li><code>strs[0] → "flower"</code></li><li><code>strs[0][2] → "flower"</code> 的第 2 个字符 → <code>'o'</code></li></ul><p>同理：</p><ul><li><code>strs[1][2] → "flow"[2] → 'o'</code></li><li><code>strs[2][2] → "flight"[2] → 'i'</code></li></ul><p>通过比较 <code>strs[0][i]</code>与其他字符串的 <code>strs[j][i]</code> 是否相等，来判断第 i 位置是否仍属于公共前缀</p><h3 id="等价的写法"><a href="#等价的写法" class="headerlink" title="等价的写法"></a>等价的写法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> firstStr = strs[<span class="hljs-number">0</span>];<br>firstStr[i];<br><br><span class="hljs-comment">// 使用 charAt 方法</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">charAt</span>(i);<br><br><span class="hljs-comment">// 使用 at 方法 ES2022+</span><br>strs[<span class="hljs-number">0</span>].<span class="hljs-title function_">at</span>(i);<br></code></pre></td></tr></table></figure><hr><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>一个整数数组  <code>nums</code> ，判断是否存在三元组  <code>[nums[i], nums[j], nums[k]]</code>  满足  <code>i != j</code>、<code>i != k</code>  且  <code>j != k</code> ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code> ，返回所有和为  <code>0</code>  且不重复的三元组，且答案中不可以包含重复的三元组</p><p>示例 1：<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code><br>输出：<code>[[-1,-1,2],[-1,0,1]]</code><br>解释：<br><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code><br><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code><br><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code><br>不同的三元组是 <code>[-1,0,1]</code>和 <code>[-1,-1,2]</code></p><p>示例 2：<br>输入：<code>nums = [0,1,1]</code><br>输出：<code>[]</code><br>解释：唯一可能的三元组和不为 0</p><p>示例 3：<br>输入：<code>nums = [0,0,0]</code><br>输出：<code>[[0,0,0]]</code><br>解释：唯一可能的三元组和为 0</p><p>最开始是想直接 n^3 暴力解，然后用 Set 去重</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br>  <span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = j + <span class="hljs-number">1</span>; k &lt; nums.<span class="hljs-property">length</span>; k++) {<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">const</span> triplet = [nums[i], nums[j], nums[k]];<br>          <span class="hljs-keyword">const</span> key = triplet.<span class="hljs-title function_">join</span>(<span class="hljs-string">","</span>);<br>          <span class="hljs-keyword">if</span> (!seen.<span class="hljs-title function_">has</span>(key)) {<br>            seen.<span class="hljs-title function_">add</span>(key);<br>            result.<span class="hljs-title function_">push</span>(triplet);<br>          }<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>很明显，时间复杂度特别高，直接爆了</p><p>解法的话依旧双指针降维</p><h3 id="第一步：排序"><a href="#第一步：排序" class="headerlink" title="第一步：排序"></a>第一步：排序</h3><p>排序后可以：利用有序数组的特性，通过指针移动快速缩小范围</p><p>比如原数组是 <code>[-1,0,1,2,-1,-4]</code>，排序后变成 <code>[-4,-1,-1,0,1,2]</code>。这时候，相同的元素（比如两个 <code>-1</code>）会挨在一起，方便后续去重（重复元素会相邻，容易跳过）</p><h3 id="第二步：固定一个数，双指针找另外两个数"><a href="#第二步：固定一个数，双指针找另外两个数" class="headerlink" title="第二步：固定一个数，双指针找另外两个数"></a>第二步：固定一个数，双指针找另外两个数</h3><p>排序后，我们固定第一个数 <code>nums[i]</code>，然后用左指针 <code>left</code> 指向 <code>i+1</code>，右指针 <code>right</code> 指向数组末尾。三个数的和 <code>sum = nums[i] + nums[left] + nums[right]</code>：</p><ul><li>如果 <code>sum &lt; 0</code>：说明需要更大的数，左指针右移（<code>left++</code>）；</li><li>如果 <code>sum &gt; 0</code>：说明需要更小的数，右指针左移（<code>right--</code>）；</li><li>如果 <code>sum = 0</code>：找到一个有效三元组，记录结果。</li></ul><h3 id="第三步：去重"><a href="#第三步：去重" class="headerlink" title="第三步：去重"></a>第三步：去重</h3><p>具体分三种情况：</p><h4 id="1-固定数-nums-i-重复"><a href="#1-固定数-nums-i-重复" class="headerlink" title="1. 固定数 nums[i] 重复"></a>1. 固定数 <code>nums[i]</code> 重复</h4><p>比如排序后的数组是 <code>[-4,-1,-1,0,1,2]</code>，当 <code>i=1</code>（<code>nums[i]=-1</code>）时，和 <code>i=2</code>（<code>nums[i]=-1</code>）时的情况是一样的。这时候需要跳过重复的 <code>nums[i]</code>。</p><p><strong>判断条件</strong>：如果 <code>i &gt; 0</code> 且 <code>nums[i] === nums[i-1]</code>，说明当前 <code>nums[i]</code> 和前一个数重复，直接跳过。</p><h4 id="2-左指针-nums-left-重复"><a href="#2-左指针-nums-left-重复" class="headerlink" title="2. 左指针 nums[left] 重复"></a>2. 左指针 <code>nums[left]</code> 重复</h4><p>假设已经找到 <code>i=0</code>（<code>nums[i]=-4</code>），<code>left=1</code>（<code>nums[left]=-1</code>），<code>right=5</code>（<code>nums[right]=2</code>），此时和为 <code>-4 + (-1) + 2 = -3</code>，不满足条件。左指针右移到 <code>left=2</code>（<code>nums[left]=-1</code>），这时候 <code>nums[left]</code> 和前一个 <code>left</code> 位置的数重复，需要跳过。</p><p><strong>判断条件</strong>：当找到和为 0 的三元组后，需要循环判断 <code>nums[left] === nums[left+1]</code>，如果是，左指针右移，直到遇到不同的数。</p><h4 id="3-右指针-nums-right-重复"><a href="#3-右指针-nums-right-重复" class="headerlink" title="3. 右指针 nums[right] 重复"></a>3. 右指针 <code>nums[right]</code> 重复</h4><p>同样，找到和为 0 的三元组后，如果 <code>nums[right]</code> 和前一个 <code>right</code> 位置的数重复（比如 <code>nums[right]=1</code> 和 <code>nums[right-1]=1</code>），需要跳过。</p><p><strong>判断条件</strong>：循环判断 <code>nums[right] === nums[right-1]</code>，如果是，右指针左移，直到遇到不同的数。</p><ol><li><strong>先排序</strong>：nums.sort((a, b) =&gt; a - b)，使得相同元素相邻，便于跳过重复。</li><li><strong>外层循环跳过重复的 i</strong>：如果当前 nums[i] 与前一个相同，则跳过（避免同一值的 i 产生重复三元组）。</li><li><strong>内层双指针移动时跳过重复的 left 和 right</strong>：找到一个有效三元组后，跳过所有相同的 left 和 right 值。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 先排序，关键一步</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-comment">// 跳过重复的 nums[i]</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) {<br>      <span class="hljs-keyword">continue</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br><br>      <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) {<br>        result.<span class="hljs-title function_">push</span>([nums[i], nums[left], nums[right]]); <span class="hljs-comment">//加入结果</span><br><br>        <span class="hljs-comment">// 跳过重复的 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) {<br>          left++;<br>        }<br>        <span class="hljs-comment">// 跳过重复的 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) {<br>          right--;<br>        }<br><br>        left++;<br>        right--;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> {<br>        right--;<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给你一个长度为  <code>n</code>  的整数数组  <code>nums</code>  和 一个目标值  <code>target</code>。请你从  <code>nums</code>  中选出三个整数，使它们的和与  <code>target</code>  最接近，返回这三个数的和<br>假定每组输入只存在恰好一个解</p><p>示例：<br>输入：nums = <code>[-1,2,1,-4]</code> , <code>target = 1</code><br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)</p><p>解法和三数之和一样都是双指针解题<br>多一些判断而已</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> closestSum = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> minDiff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(closestSum - target);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {<br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>      <span class="hljs-keyword">const</span> sum = nums[i] + nums[left] + nums[right];<br>      <span class="hljs-keyword">const</span> diff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(sum - target);<br><br>      <span class="hljs-keyword">if</span> (diff &lt; minDiff) {<br>        minDiff = diff;<br>        closestSum = sum;<br>      }<br><br>      <span class="hljs-keyword">if</span> (sum &lt; target) {<br>        left++;<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) {<br>        right--;<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> sum;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> closestSum;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="17-电话号码的的数字组合"><a href="#17-电话号码的的数字组合" class="headerlink" title="17.电话号码的的数字组合"></a>17.电话号码的的数字组合</h2><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按  <strong>任意顺序</strong>  返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p class='item-img' data-src='https://pic.leetcode.cn/1752723054-mfIHZs-image.png'><img src="https://pic.leetcode.cn/1752723054-mfIHZs-image.png" alt="电话按键" width="300"></p><p>示例 1：<br>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：<br>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p><p>练度不够，还得继续练</p><p>主要解法是迭代法：</p><ul><li>外层循环遍历 digits 中的每一个数字（从左到右）。</li><li>对于当前数字 digit：<ul><li>获取其对应的所有可能字母 letters（如 ‘2’ → ‘abc’）。</li><li>创建一个临时数组 temp，用于存储“加入当前数字字母后的新组合”。</li><li>遍历当前 result 中的每一个已有组合 prev（这些是处理前几个数字得到的所有组合）。</li><li>对 letters 中的每一个 letter，将其追加到 prev 后面，形成新字符串 prev + letter，并加入 temp。</li></ul></li><li>一轮结束后，将 temp 赋值给 result，成为下一轮的“已有组合”。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params"><span class="hljs-attr">digits</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>[] {<br>  <span class="hljs-keyword">if</span> (digits.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: { [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> } = {<br>    <span class="hljs-string">"2"</span>: <span class="hljs-string">"abc"</span>,<br>    <span class="hljs-string">"3"</span>: <span class="hljs-string">"def"</span>,<br>    <span class="hljs-string">"4"</span>: <span class="hljs-string">"ghi"</span>,<br>    <span class="hljs-string">"5"</span>: <span class="hljs-string">"jkl"</span>,<br>    <span class="hljs-string">"6"</span>: <span class="hljs-string">"mno"</span>,<br>    <span class="hljs-string">"7"</span>: <span class="hljs-string">"pqrs"</span>,<br>    <span class="hljs-string">"8"</span>: <span class="hljs-string">"tuv"</span>,<br>    <span class="hljs-string">"9"</span>: <span class="hljs-string">"wxyz"</span>,<br>  };<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">""</span>];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> digit <span class="hljs-keyword">of</span> digits) {<br>    <span class="hljs-keyword">const</span> letters = map[digit];<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">temp</span>: <span class="hljs-built_in">string</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prev <span class="hljs-keyword">of</span> result) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> letter <span class="hljs-keyword">of</span> letters) {<br>        temp.<span class="hljs-title function_">push</span>(prev + letter);<br>      }<br>    }<br>    result = temp;<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><p>从“空组合”开始，依次将每个新数字的字母可能性“横向扩展”到所有已有组合上，最终得到所有完整组合</p><hr><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><p>给你一个由  <code>n</code>  个整数组成的数组  <code>nums</code> ，和一个目标值  <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组  <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code>  和  <code>d</code>  互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>输入：<code>nums = [1,0,-1,0,-2,2]</code>, <code>target = 0</code><br>输出：<code>[[-2,-1,1,2] , [-2,0,0,2] , [-1,0,0,1]]</code></p><p>输入：<code>nums = [2,2,2,2,2]</code>, <code>target = 8</code><br>输出：<code>[[2,2,2,2]]</code></p><p><strong>就是三数之和的基础上再套上一层 for 循环</strong></p><p>题解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number[][]</span>}</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) {<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);  <span class="hljs-comment">// 先排序</span><br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> result = [];<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) {<br>        <span class="hljs-comment">// 去重 i</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前四个最小值之和已大于 target，直接终止</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 剪枝：当前 i 与后面三个最大值之和小于 target，跳过本次 i</span><br>        <span class="hljs-keyword">if</span> (nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) {<br>            <span class="hljs-comment">// 去重 j</span><br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">let</span> left = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (left &lt; right) {<br>                <span class="hljs-keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];<br><br>                <span class="hljs-keyword">if</span> (sum === target) {<br>                    result.<span class="hljs-title function_">push</span>([nums[i], nums[j], nums[left], nums[right]]);<br><br>                    <span class="hljs-comment">// 去重 left</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-comment">// 去重 right</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) right--;<br><br>                    left++;<br>                    right--;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {<br>                    left++;<br>                } <span class="hljs-keyword">else</span> {<br>                    right--;<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> result;<br>};<br></code></pre></td></tr></table></figure><hr><h2 id="19-删除链表的第-n-个节点"><a href="#19-删除链表的第-n-个节点" class="headerlink" title="19. 删除链表的第 n 个节点"></a>19. 删除链表的第 n 个节点</h2><p>给你一个链表，删除链表的倒数第  <code>n</code>  个结点，并且返回链表的头结点</p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>输入：head = [1], n = 1<br>输出：[]</p><p>自己写的一版，思路主要是遍历一趟链表搞到 length，再用 n 确定 index 来定位要删的位置，最后再删掉该节点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> curr = head;<br>  <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>    len++;<br>    curr = curr.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">if</span> (len === n) {<br>    <span class="hljs-keyword">return</span> head?.<span class="hljs-property">next</span> ?? <span class="hljs-literal">null</span>;<br>  }<br><br>  <span class="hljs-keyword">let</span> index = len - n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> delindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">let</span> del = head;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  prev.<span class="hljs-property">next</span> = head;<br>  <span class="hljs-keyword">while</span> (del !== <span class="hljs-literal">null</span>) {<br>    prev = prev.<span class="hljs-property">next</span>;<br>    del = del.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (delindex === index) {<br>      prev.<span class="hljs-property">next</span> = del.<span class="hljs-property">next</span>;<br>    }<br>    delindex++;<br>  }<br>  <span class="hljs-keyword">return</span> head;<br>}<br></code></pre></td></tr></table></figure><p>题解的话主要是用快慢指针,这个思路挺不错的其实</p><ul><li>引入虚拟头结点 dummy</li><li>让 fast 指针先走 n 步</li><li>然后 slow 与 fast 同步移动，当 fast 到达末尾时，slow 指向的就是倒数第 n 个节点的前一个节点</li><li>执行 slow.next = slow.next.next 删除目标节点</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-comment">// 边界：空链表或 n 无效直接返回</span><br>  <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  dummy.<span class="hljs-property">next</span> = head;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">fast</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">slow</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = dummy;<br><br>  <span class="hljs-comment">// fast 先走 n 步</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    fast = fast!.<span class="hljs-property">next</span>; <span class="hljs-comment">// n 合法时不会为 null</span><br>  }<br><br>  <span class="hljs-comment">// fast 和 slow 同步移动，直到 fast 到达末尾</span><br>  <span class="hljs-keyword">while</span> (fast!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    fast = fast!.<span class="hljs-property">next</span>;<br>    slow = slow!.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-comment">// 此时 slow 指向倒数第 n 个节点的前一个节点</span><br>  <span class="hljs-keyword">if</span> (slow!.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) {<br>    slow!.<span class="hljs-property">next</span> = slow!.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p>给定一个只包括  <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>  的字符串  <code>s</code> ，判断字符串是否有效</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例 1：<br>输入：<code>s = "()"</code><br>输出：true</p><p>示例 2：<br>输入：<code>s = "()[]{}"</code><br>输出：true</p><p>示例 3：<br>输入：<code>s = "(]"</code><br>输出：false</p><p>示例 4：<br>输入：<code>s = "([])"</code><br>输出：true</p><p>示例 5：<br>输入：<code>s = "([)]"</code><br>输出：false</p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code>  仅由括号  <code>'()[]{}'</code>  组成</li></ul><p>思路不难，主要就是栈匹配问题</p><ul><li>开括号 → 入栈 <code>stk.push(s[i])</code></li><li>闭括号 → 元素出栈 <code>stk.pop()</code> 进行匹配  </li><li>若栈空或栈顶不匹配 → 立即返回 false；否则弹出栈顶</li><li>遍历结束 → 栈空返回 true，否则 false</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">stk</span>: <span class="hljs-built_in">string</span>[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"("</span> || s[i] === <span class="hljs-string">"["</span> || s[i] === <span class="hljs-string">"{"</span>) {<br>      stk.<span class="hljs-title function_">push</span>(s[i]);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">")"</span> || s[i] === <span class="hljs-string">"]"</span> || s[i] === <span class="hljs-string">"}"</span>) {<br>      <span class="hljs-keyword">if</span> (stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>      <span class="hljs-keyword">let</span> curr = stk.<span class="hljs-title function_">pop</span>()!;<br>      <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"("</span> &amp;&amp; s[i] === <span class="hljs-string">")"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"["</span> &amp;&amp; s[i] === <span class="hljs-string">"]"</span>) {<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curr === <span class="hljs-string">"{"</span> &amp;&amp; s[i] === <span class="hljs-string">"}"</span>) {<br>      } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> stk.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是力扣速刷第二期awa&lt;br&gt;说是速刷其实卡了挺久&lt;/p&gt;
&lt;p class=&#39;item-img&#39; data-src=&#39;https://picx.zhimg.com/v2-1e47d2da440013ae7d4262f54c26dd52_720w.webp?source</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-关于Javascript/TypeScript 的顺序表，链表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/46758.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/46758.html</id>
    <published>2025-12-26T04:16:12.000Z</published>
    <updated>2025-12-26T04:42:12.018Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。</p><p>以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并附带说明。</p><h2 id="1-顺序表（基于数组的动态顺序表）"><a href="#1-顺序表（基于数组的动态顺序表）" class="headerlink" title="1. 顺序表（基于数组的动态顺序表）"></a>1. 顺序表（基于数组的动态顺序表）</h2><p>顺序表的核心是连续存储，使用数组实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建顺序表</span><br><span class="hljs-keyword">const</span> seqList = [];<br><br><span class="hljs-comment">// 添加元素</span><br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">10</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>);<br>seqList.<span class="hljs-title function_">push</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// 在索引 1 处插入 15</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">// [10, 15, 20, 30]</span><br><br><span class="hljs-comment">// 修改索引 2 处的元素</span><br>seqList[<span class="hljs-number">2</span>] = <span class="hljs-number">25</span>;           <span class="hljs-comment">// [10, 15, 25, 30]</span><br><br><span class="hljs-comment">// 删除索引 0 处的元素</span><br>seqList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">// [15, 25, 30]</span><br><br><span class="hljs-comment">// 输出长度和内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'长度:'</span>, seqList.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内容:'</span>, seqList);         <span class="hljs-comment">// [15, 25, 30]</span><br></code></pre></td></tr></table></figure><p>手动实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity = <span class="hljs-number">10</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity);  <span class="hljs-comment">// 存储元素</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 当前元素个数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;         <span class="hljs-comment">// 当前容量</span><br>    }<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 扩容（当 size === capacity 时）</span><br>    <span class="hljs-title function_">resize</span>(<span class="hljs-params">newCapacity</span>) {<br>        <span class="hljs-keyword">const</span> newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(newCapacity);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            newData[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = newData;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = newCapacity;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 扩容为两倍</span><br>        }<br>        <span class="hljs-comment">// 从后向前移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>; i &gt;= index; i--) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在末尾添加元素</span><br>    <span class="hljs-title function_">append</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 删除索引 index 处的元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">const</span> removed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>        <span class="hljs-comment">// 从前向后移动元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-comment">// 可选：缩容（避免频繁缩容，通常当 size == capacity / 4 时缩为一半）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">4</span>)) {<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resize</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> / <span class="hljs-number">2</span>));<br>        }<br>        <span class="hljs-keyword">return</span> removed;<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index] = element;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'SequentialList: ['</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>; i++) {<br>            str += <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[i];<br>            <span class="hljs-keyword">if</span> (i !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> - <span class="hljs-number">1</span>) str += <span class="hljs-string">', '</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> seqList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequentialList</span>();<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);<br>seqList.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);<br>seqList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>seqList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// SequentialList: [1, 3, 2]</span><br></code></pre></td></tr></table></figure><h2 id="2-链表（单向链表）"><a href="#2-链表（单向链表）" class="headerlink" title="2. 链表（单向链表）"></a>2. 链表（单向链表）</h2><p>链表使用节点分散存储，支持高效的插入和删除（O(1)），但随机访问较慢（O(n)）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();  <span class="hljs-comment">// 虚拟头结点，便于操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-title function_">getSize</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>;<br>    }<br><br>    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 在索引 index 处插入元素</span><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(element);<br>        node.<span class="hljs-property">next</span> = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>    }<br><br>    <span class="hljs-comment">// 在链表头部添加元素</span><br>    <span class="hljs-title function_">addFirst</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">0</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 在链表末尾添加元素</span><br>    <span class="hljs-title function_">addLast</span>(<span class="hljs-params">element</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>, element);<br>    }<br><br>    <span class="hljs-comment">// 获取索引处元素</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 设置索引处元素</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">index, element</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        cur.<span class="hljs-property">val</span> = element;<br>    }<br><br>    <span class="hljs-comment">// 删除索引处元素并返回</span><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">index</span>) {<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'索引越界'</span>);<br>        }<br>        <span class="hljs-keyword">let</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {<br>            prev = prev.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-keyword">const</span> removedNode = prev.<span class="hljs-property">next</span>;<br>        prev.<span class="hljs-property">next</span> = removedNode.<span class="hljs-property">next</span>;<br>        removedNode.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;<br>        <span class="hljs-keyword">return</span> removedNode.<span class="hljs-property">val</span>;<br>    }<br><br>    <span class="hljs-comment">// 遍历打印</span><br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">'LinkedList: ['</span>;<br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            str += cur.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">next</span>) str += <span class="hljs-string">' -&gt; '</span>;<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        str += <span class="hljs-string">']'</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">1</span>);<br>linkedList.<span class="hljs-title function_">addLast</span>(<span class="hljs-number">2</span>);<br>linkedList.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>linkedList.<span class="hljs-title function_">print</span>();  <span class="hljs-comment">// LinkedList: [1 -&gt; 3 -&gt; 2]</span><br></code></pre></td></tr></table></figure><hr><h2 id="LRU-缓存的实现（使用双向链表-HashMap）"><a href="#LRU-缓存的实现（使用双向链表-HashMap）" class="headerlink" title="LRU 缓存的实现（使用双向链表 + HashMap）"></a>LRU 缓存的实现（使用双向链表 + HashMap）</h2><p>LRU（Least Recently Used）缓存是一种常见的数据结构，用于实现固定容量缓存，当容量满时淘汰最近最少使用的元素。在 JavaScript 中，最高效的实现方式是结合<strong>双向链表</strong>（控制访问顺序）和<strong>Map</strong>（或对象）作为哈希表（实现 O(1) 访问）</p><h3 id="JS实现："><a href="#JS实现：" class="headerlink" title="JS实现："></a>JS实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 缓存的最大容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;        <span class="hljs-comment">// 缓存容量</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();          <span class="hljs-comment">// 使用 Map 作为哈希表，保持插入顺序并支持 O(1) 操作</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟头节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = {};                  <span class="hljs-comment">// 双向链表的虚拟尾节点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;      <span class="hljs-comment">// 初始化链表：head &lt;-&gt; tail</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将节点移动到链表头部（表示最近使用）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">node</span> - 要移动的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_moveToHead</span>(<span class="hljs-params">node</span>) {<br>        <span class="hljs-comment">// 先从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>;<br><br>        <span class="hljs-comment">// 插入到头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从链表尾部移除节点（淘汰最久未使用的）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 被移除的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">_removeTail</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>;<br>        lastNode.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any</span>} 值，如果不存在返回 -1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 未找到</span><br>        }<br>        <span class="hljs-comment">// 刷新访问顺序：将节点移到头部</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 放入缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">key</span> - 键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            <span class="hljs-comment">// 已存在：更新值并移到头部</span><br>            existingNode.<span class="hljs-property">value</span> = value;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 不存在：创建新节点</span><br>            <span class="hljs-keyword">const</span> newNode = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入到头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 检查容量是否超出</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeTail</span>();  <span class="hljs-comment">// 移除尾部节点</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);      <span class="hljs-comment">// 从哈希表中删除</span><br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 可选：打印当前缓存顺序（用于调试）</span><br>    <span class="hljs-title function_">printCache</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-keyword">const</span> result = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current.key}</span>:<span class="hljs-subst">${current.value}</span>`</span>);<br>            current = current.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache (most recent -&gt; least recent):'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2（刷新顺序）</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br><br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);            <span class="hljs-comment">// 容量满，淘汰最久未使用的 1</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 4:4 -&gt; 2:2 -&gt; 3:3</span><br></code></pre></td></tr></table></figure><h3 id="TS实现"><a href="#TS实现" class="headerlink" title="TS实现"></a>TS实现</h3><p>使用双向链表结合 Map（Map 在 TypeScript 中天然支持泛型）实现 O(1) 时间复杂度的 get 和 put 操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 双向链表节点接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>    <span class="hljs-attr">key</span>: K;<br>    <span class="hljs-attr">value</span>: V;<br>    <span class="hljs-attr">prev</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; | <span class="hljs-literal">null</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K = <span class="hljs-built_in">number</span>, V = <span class="hljs-built_in">number</span>&gt; {<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span>;                <span class="hljs-comment">// 缓存容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">cache</span>: <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;;        <span class="hljs-comment">// 哈希表：键到节点的映射</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">head</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;;                <span class="hljs-comment">// 虚拟尾节点</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">capacity</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;K, <span class="hljs-title class_">Node</span>&lt;K, V&gt;&gt;();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>    }<br><br>    <span class="hljs-comment">// 将节点移动到头部（最近使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">moveToHead</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt;): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-comment">// 从当前位置移除</span><br>        node.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>!;<br><br>        <span class="hljs-comment">// 插入头部</span><br>        node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = node;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;<br>    }<br><br>    <span class="hljs-comment">// 移除尾部节点（最久未使用）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">removeTail</span>(): <span class="hljs-title class_">Node</span>&lt;K, V&gt; {<br>        <span class="hljs-keyword">const</span> lastNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>!;<br>        lastNode.<span class="hljs-property">prev</span>!.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = lastNode.<span class="hljs-property">prev</span>;<br>        <span class="hljs-keyword">return</span> lastNode;<br>    }<br><br>    <span class="hljs-comment">// 获取值</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: K): V | -<span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>        <span class="hljs-keyword">if</span> (!node) {<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(node);  <span class="hljs-comment">// 刷新访问顺序</span><br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;<br>    }<br><br>    <span class="hljs-comment">// 放入键值对</span><br>    <span class="hljs-title function_">put</span>(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> existingNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br><br>        <span class="hljs-keyword">if</span> (existingNode) {<br>            existingNode.<span class="hljs-property">value</span> = value;  <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveToHead</span>(existingNode);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">const</span> <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">Node</span>&lt;K, V&gt; = { key, value, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);<br><br>            <span class="hljs-comment">// 插入头部</span><br>            newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>            newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>!.<span class="hljs-property">prev</span> = newNode;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = newNode;<br><br>            <span class="hljs-comment">// 超出容量时淘汰</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>                <span class="hljs-keyword">const</span> tailNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeTail</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tailNode.<span class="hljs-property">key</span>);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 调试：打印缓存顺序（最近 -&gt; 最久）</span><br>    <span class="hljs-title function_">printCache</span>(): <span class="hljs-built_in">void</span> {<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = [];<br>        <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (current !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${current!.key}</span>:<span class="hljs-subst">${current!.value}</span>`</span>);<br>            current = current!.<span class="hljs-property">next</span>;<br>        }<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LRU Cache:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>    }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>cache.<span class="hljs-title function_">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cache.<span class="hljs-title function_">printCache</span>();  <span class="hljs-comment">// 3:3 -&gt; 2:2 -&gt; 1:1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 2</span><br>cache.<span class="hljs-title function_">printCache</span>();         <span class="hljs-comment">// 2:2 -&gt; 3:3 -&gt; 1:1</span><br></code></pre></td></tr></table></figure><h2 id="链表反转的实现"><a href="#链表反转的实现" class="headerlink" title="链表反转的实现"></a>链表反转的实现</h2><p>单向链表的反转实现，包括迭代和递归两种方式</p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 单向链表节点定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val = <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params">arr</span>) {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表的辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 方法一：迭代反转（推荐，空间复杂度 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 前驱指针</span><br>    <span class="hljs-keyword">let</span> current = head;      <span class="hljs-comment">// 当前指针</span><br>    <span class="hljs-keyword">let</span> next = <span class="hljs-literal">null</span>;         <span class="hljs-comment">// 临时存储下一节点</span><br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        next = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev; <span class="hljs-comment">// 反转指针</span><br>        prev = current;      <span class="hljs-comment">// 前驱前进</span><br>        current = next;      <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// prev 成为新头节点</span><br>}<br><br><span class="hljs-comment">// 方法二：递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params">head</span>) {<br>    <span class="hljs-comment">// 递归终止条件：空链表或只有一个节点</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br><br>    <span class="hljs-comment">// 递归反转后续链表</span><br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br><br>    <span class="hljs-comment">// 反转当前节点与下一节点的指向</span><br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> newHead;  <span class="hljs-comment">// 新头节点始终是原链表的尾节点</span><br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIterative = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIterative);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list2);  <span class="hljs-comment">// 6 -&gt; 7 -&gt; 8</span><br><br><span class="hljs-keyword">const</span> reversedRecursive = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRecursive);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><h3 id="TS实现-1"><a href="#TS实现-1" class="headerlink" title="TS实现"></a>TS实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 单向链表节点类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span></span>) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val ?? <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next ?? <span class="hljs-literal">null</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 创建链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">const</span> head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>        current.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(arr[i]);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-keyword">return</span> head;<br>}<br><br><span class="hljs-comment">// 打印链表辅助函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLinkedList</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">let</span> current = head;<br>    <span class="hljs-keyword">while</span> (current) {<br>        result.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>        current = current.<span class="hljs-property">next</span>;<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'LinkedList:'</span>, result.<span class="hljs-title function_">join</span>(<span class="hljs-string">' -&gt; '</span>));<br>}<br><br><span class="hljs-comment">// 迭代反转（推荐，空间 O(1)）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListIterative</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">current</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = head;<br><br>    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">const</span> next = current.<span class="hljs-property">next</span>;  <span class="hljs-comment">// 保存下一节点</span><br>        current.<span class="hljs-property">next</span> = prev;        <span class="hljs-comment">// 反转指针</span><br>        prev = current;             <span class="hljs-comment">// 前驱前进</span><br>        current = next;             <span class="hljs-comment">// 当前前进</span><br>    }<br>    <span class="hljs-keyword">return</span> prev;  <span class="hljs-comment">// 新头节点</span><br>}<br><br><span class="hljs-comment">// 递归反转</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseListRecursive</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseListRecursive</span>(head.<span class="hljs-property">next</span>);<br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-title function_">printLinkedList</span>(list);  <span class="hljs-comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><br><span class="hljs-keyword">const</span> reversedIter = <span class="hljs-title function_">reverseListIterative</span>(list);<br><span class="hljs-title function_">printLinkedList</span>(reversedIter);  <span class="hljs-comment">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span><br><br><span class="hljs-keyword">const</span> list2 = <span class="hljs-title function_">createLinkedList</span>([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-keyword">const</span> reversedRec = <span class="hljs-title function_">reverseListRecursive</span>(list2);<br><span class="hljs-title function_">printLinkedList</span>(reversedRec);  <span class="hljs-comment">// 8 -&gt; 7 -&gt; 6</span><br></code></pre></td></tr></table></figure><p>DFA:</p><ul><li><strong>顺序表</strong>：适合随机访问（O(1)），插入/删除较慢（O(n)），实现简单，内存连续</li><li><strong>链表</strong>：适合频繁插入/删除（O(1)），随机访问慢（O(n)），内存分散，支持动态扩展, 链表常用于特定算法（如 LRU 缓存、链表反转等）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 原生提供了 Array 作为高效的动态顺序表实现，但为了理解底层原理，通常需要手动实现。链表则需要完全手动实现，因为 JavaScript 无内置链表结构。&lt;/p&gt;
&lt;p&gt;以下分别提供两种数据结构的完整实现，包括基本操作（插入、删除、查找、遍历等），并</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-26-关于JavaScript面试算法：字符串，数组，数字反转和转换</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/47427.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/47427.html</id>
    <published>2025-12-26T03:20:25.000Z</published>
    <updated>2025-12-27T04:41:06.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串，数组，数字的转换"><a href="#字符串，数组，数字的转换" class="headerlink" title="字符串，数组，数字的转换"></a>字符串，数组，数字的转换</h2><p><strong>数字（Number）</strong>、<strong>字符串（String）</strong> 和 <strong>数组（Array）</strong> 之间的相互转换算是常见操作了，常见转换方向、推荐方法、示例代码及说明如下：</p><div class="table-container"><table><thead><tr><th>从 → 到</th><th>方法</th><th>示例代码</th><th>说明</th></tr></thead><tbody><tr><td>Number → String</td><td>String(num) 或 num.toString()</td><td>let str = String(123); // “123” let str = (123).toString(); // “123”</td><td>最可靠方式。toString() 可指定进制，如 (10).toString(2) // “1010”。</td></tr><tr><td>Number → Array</td><td>String(num).split(‘’)</td><td>let arr = String(123).split(‘’); // [“1”, “2”, “3”]</td><td>先转为字符串，再按字符拆分成数组（适用于单个数字的位拆分）。</td></tr><tr><td>String → Number</td><td>Number(str) 或 +str 或 parseInt(str, 10)</td><td>let num = Number(“123”); // 123 let num = +”123”; // 123 let num = parseInt(“123”, 10); // 123</td><td>+str 最简洁；parseInt 适合提取整数部分（忽略后缀非数字）。</td></tr><tr><td>String → Array</td><td>str.split(separator)</td><td>let arr = “1,2,3”.split(‘,’); // [“1”, “2”, “3”] let arr = “123”.split(‘’); // [“1”, “2”, “3”]</td><td>split(‘’) 按单个字符拆分；split(‘,’) 按逗号等分隔符拆分。</td></tr><tr><td>Array → String</td><td>arr.toString() 或 arr.join(separator)</td><td>let str = [1,2,3].toString(); // “1,2,3” let str = [1,2,3].join(‘’); // “123” let str = [1,2,3].join(‘-‘); // “1-2-3”</td><td>join() 更灵活，可自定义分隔符（默认逗号）。</td></tr><tr><td>Array → Number</td><td>先转为字符串，再转为数字（如 Number(arr.join(‘’))）</td><td>let num = Number([1,2,3].join(‘’)); // 123</td><td>适用于纯数字数组；若数组含非数字，返回 NaN。</td></tr><tr><td>Array(Number) → Array(String)</td><td>arr.map(String) 或 arr.map(num =&gt; num.toString())</td><td>let strArr = [1,2,3].map(String); // [“1”, “2”, “3”]</td><td>逐元素转换为字符串，最常用方法。</td></tr><tr><td>Array(String) → Array(Number)</td><td>arr.map(Number) 或 arr.map(str =&gt; parseInt(str, 10))</td><td>let numArr = [“1”,”2”,”3”].map(Number); // [1, 2, 3]</td><td>逐元素转换为数字；parseInt 更安全处理可能含非纯数字字符串。</td></tr></tbody></table></div><p>数组转数字本质是拼接字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'2'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'22'</span>, <span class="hljs-string">'23'</span>];<br><br><span class="hljs-comment">// 步骤1: 使用 join('') 无分隔符拼接成字符串 const str = arr.join(''); // "212223"</span><br><br><span class="hljs-comment">// 步骤2: 转换为数字 const num = Number(str); // 212223 // 或等价简写：const num = +arr.join('');</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 212223（number 类型）</span><br></code></pre></td></tr></table></figure><p>数组转连续字符串本质也是拼接字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TS"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">'X'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'W'</span>];<br><br><span class="hljs-comment">// 使用 join('')（最常用） </span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>); <span class="hljs-comment">// "XWW"</span><br><br><span class="hljs-comment">// 使用 join() 无参数（默认逗号，但空字符串等价） </span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str2</span>: <span class="hljs-built_in">string</span> = arr.<span class="hljs-title function_">join</span>(); <span class="hljs-comment">// 注意：默认会得到 "X,W,W"，必须传空字符串</span><br></code></pre></td></tr></table></figure><h2 id="字符串反转："><a href="#字符串反转：" class="headerlink" title="字符串反转："></a>字符串反转：</h2><p><strong>ES6:</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);<br><br><span class="hljs-comment">// 使用示例 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverseString</span>(<span class="hljs-string">'hello'</span>)); <span class="hljs-comment">// 'olleh'</span><br></code></pre></td></tr></table></figure><p><strong>手动循环</strong>（不依赖内置方法）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">str</span>) {<br>  <span class="hljs-keyword">let</span> reversed = <span class="hljs-string">''</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    reversed += str[i];<br>  }<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure><h2 id="数组反转（Array-Reverse）"><a href="#数组反转（Array-Reverse）" class="headerlink" title="数组反转（Array Reverse）:"></a>数组反转（Array Reverse）:</h2><p><strong>原地反转</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">reverse</span>();  <span class="hljs-comment">// arr 变为 [4, 3, 2, 1]</span><br></code></pre></td></tr></table></figure><p><strong>手动实现</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) {<br>    [arr[left], arr[right]] = [arr[right], arr[left]];<br>    left++;<br>    right--;<br>  }<br>  <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></table></figure><h2 id="数字反转（leetcode-7）"><a href="#数字反转（leetcode-7）" class="headerlink" title="数字反转（leetcode # 7）"></a>数字反转（leetcode # 7）</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseInt</span>(<span class="hljs-params">x</span>) {<br>  <span class="hljs-keyword">const</span> sign = x &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> reversed = sign * <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>), <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> reversed;<br>}<br></code></pre></td></tr></table></figure><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>数组排序</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串，数组，数字的转换&quot;&gt;&lt;a href=&quot;#字符串，数组，数字的转换&quot; class=&quot;headerlink&quot; title=&quot;字符串，数组，数字的转换&quot;&gt;&lt;/a&gt;字符串，数组，数字的转换&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数字（Number）&lt;/strong&gt;、&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-面试算法ACM模式构建构建输入输出模板（Javascript）</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/31996.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/31996.html</id>
    <published>2025-12-25T15:09:45.000Z</published>
    <updated>2025-12-26T07:14:53.570Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞<br>上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板</p><h2 id="一、基础模板"><a href="#一、基础模板" class="headerlink" title="一、基础模板"></a>一、基础模板</h2><p>我们先来看一个基础模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello Nowcoder!"</span>);<br>})();<br></code></pre></td></tr></table></figure><p>我们接下来逐行解析下每行代码的作用</p><h5 id="1-引入-readline-模块并创建接口"><a href="#1-引入-readline-模块并创建接口" class="headerlink" title="1. 引入 readline 模块并创建接口"></a>1. 引入 readline 模块并创建接口</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br></code></pre></td></tr></table></figure><ul><li><code>require("readline")</code>：引入 Node.js 内置的<code>readline</code>模块，这个模块用于从命令行（标准输入）读取一行一行的输入。</li><li><code>createInterface({ input: process.stdin })</code>：创建一个输入接口，指定输入源为<code>process.stdin</code>（标准输入，也就是用户在控制台输入的内容）。</li><li>变量<code>rl</code>就是这个输入接口的实例，后续通过它来控制输入的读取。</li></ul><h5 id="2-创建异步迭代器"><a href="#2-创建异步迭代器" class="headerlink" title="2. 创建异步迭代器"></a>2. 创建异步迭代器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br></code></pre></td></tr></table></figure><ul><li><code>Symbol.asyncIterator</code>是 Javascript 的一个内置符号，用于定义对象的异步迭代器</li><li>这里通过<code>rl[Symbol.asyncIterator]()</code>获取 rl 接口的异步迭代器，赋值给<code>iter</code>。</li><li>异步迭代器的作用是：可以通过<code>next()</code>方法<strong>异步地获取下一行输入</strong>（因为输入是用户手动输入的，属于异步操作）。</li></ul><h5 id="3-定义读取一行输入的函数"><a href="#3-定义读取一行输入的函数" class="headerlink" title="3. 定义读取一行输入的函数"></a>3. 定义读取一行输入的函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br></code></pre></td></tr></table></figure><ul><li>这是一个异步函数（<code>async</code>标记），作用是读取一行输入。</li><li>调用<code>iter.next()</code>会返回一个 Promise，<code>await</code>会等待这个 Promise 完成，获取下一行输入的结果。</li><li>结果的<code>value</code>属性就是读取到的一行字符串（如果没有更多输入，<code>value</code>会是<code>undefined</code>）。</li><li>简单说：调用<code>readline()</code>就可以得到一行输入的内容（字符串类型）</li></ul><h5 id="4-立即执行的异步函数（核心逻辑区）"><a href="#4-立即执行的异步函数（核心逻辑区）" class="headerlink" title="4. 立即执行的异步函数（核心逻辑区）"></a>4. 立即执行的异步函数（核心逻辑区）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here 👉 你的核心代码写在这里</span><br>  <span class="hljs-comment">// 直接输出需要的字符串，不需要处理输入 console.log("Hello Nowcoder!");</span><br>})();<br></code></pre></td></tr></table></figure><p>这是整个代码的<strong>执行入口</strong>，也就是你需要编写核心逻辑的地方，我们拆解一下：</p><ul><li><code>void async function (){...}()</code>:这是一个<strong>立即执行的异步函数表达式</strong> (IIFE)。<ul><li><code>async</code>标记：允许函数内部使用 await 关键字（因为读取输入输出是异步操作）。</li><li><code>void</code>：避免函数执行后返回值可能导致的语法问题，单纯让函数执行。</li><li>最后的<code>()</code>：表示定义后立即执行这个函数。</li></ul></li></ul><h4 id="核心代码写在哪里？"><a href="#核心代码写在哪里？" class="headerlink" title="核心代码写在哪里？"></a>核心代码写在哪里？</h4><p>答案是：写在<code>void async function () { ... }</code>这个函数内部（也就是注释<code>// Write your code here</code>的位置）。根据题目的输入格式不同，你需要修改这个区域的代码。具体常见的输入格式见我第二部分详细讲解。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个模板的作用是标准化输入读取流程：</p><ol><li>准备好读取输入的工具（<code>rl</code>接口，<code>iter</code>迭代器，<code>readline</code>函数）。</li><li>在立即执行的异步函数中，通过<code>await readline()</code>获取输入。</li><li>在函数内部编写你的核心逻辑（处理输入、计算、输出结果）。</li></ol><h2 id="二、常见出题形式"><a href="#二、常见出题形式" class="headerlink" title="二、常见出题形式"></a>二、常见出题形式</h2><h4 id="1-单组-A-B"><a href="#1-单组-A-B" class="headerlink" title="1.单组 A+B"></a>1.单组 A+B</h4><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>给定两个整数<code>a</code>和<code>b</code>，请你求出<code>a + b</code>的值。</p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>第一行有两个整数<code>a</code>和<code>b</code></p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输入一个整数，代表<code>a + b</code>的值。</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// Write your code here</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h6 id="核心逻辑解析"><a href="#核心逻辑解析" class="headerlink" title="核心逻辑解析"></a>核心逻辑解析</h6><p>函数内部的<code>while</code>循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span>(line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>()) { ... }<br></code></pre></td></tr></table></figure><ul><li>作用：<strong>持续读取每一行输入</strong> ，直到没有更多输入(<code>readline()</code>返回<code>undefined</code>，循环终止)。</li><li><code>line = await readline()</code>：先调用<code>readline()</code>读取每一行输入，赋值给<code>line</code>。</li><li>当没有输入时，<code>readline()</code>先返回<code>undefined</code>，循环条件为<code>false</code>，退出循环。</li></ul><p>循环内部的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>); <span class="hljs-comment">// 将一行输入按空格分割成数组（比如输入"1 2"，得到["1", "2"]）</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 将第一个元素转为整数</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 将第二个元素转为整数 console.log(a + b); // 输出结果</span><br></code></pre></td></tr></table></figure><h4 id="2-多组-A-B-EOF-形式"><a href="#2-多组-A-B-EOF-形式" class="headerlink" title="2.多组_A+B_EOF 形式"></a>2.多组_A+B_EOF 形式</h4><h6 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，读取至文件末尾为止，每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，读取至文件末尾为止</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入，直到没有更多输入（EOF）</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 将一行输入按空格分割成数组（例如"1 2"分割为["1", "2"]）</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-comment">// 将分割后的字符串转为整数</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出两数之和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="3-多组-A-B-T-组形式"><a href="#3-多组-A-B-T-组形式" class="headerlink" title="3.多组_A+B_T 组形式"></a>3.多组_A+B_T 组形式</h4><h6 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h6><p>给定 t 组测试数据。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数 t，每行有两个整数 a 和 b</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取测试用例数量T</span><br>  <span class="hljs-keyword">let</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：循环T次，处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取一行输入</span><br>    <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>    <span class="hljs-comment">// 分割成两个数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="4-多组A-B零尾模式"><a href="#4-多组A-B零尾模式" class="headerlink" title="4.多组A+B零尾模式"></a>4.多组<em>A+B</em>零尾模式</h4><h6 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h6><p>给定若干组测试数据，最后一组数据为 0 0，作为输入的结尾。每组数据有两个整数 a 和 b，请你求出 a + b 的值。</p><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>每行有两个整数 a 和 b，最后一组数据为 0 0，作为输入的结尾。</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出若干行，每行一个整数，代表 a + b 的值。</p><h6 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">114</span> <span class="hljs-number">514</span><br><span class="hljs-number">2024</span> <span class="hljs-number">727</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span><br>输出：<br><span class="hljs-number">3</span><br><span class="hljs-number">628</span><br><span class="hljs-number">2751</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 循环读取每一行输入</span><br>  <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) {<br>    <span class="hljs-comment">// 分割并转换为数字</span><br>    <span class="hljs-keyword">let</span> tokens = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">parseInt</span>(tokens[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 关键：判断是否为0 0，是则终止循环</span><br>    <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 退出循环，不再处理后续输入</span><br>    }<br><br>    <span class="hljs-comment">// 不是终止条件则输出结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="5-单组-一维数组"><a href="#5-单组-一维数组" class="headerlink" title="5.单组_一维数组"></a>5.单组_一维数组</h4><h6 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br>输出：<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 第一步：读取第一行，获取数字的个数n</span><br>  <span class="hljs-keyword">let</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 第二步：读取第二行，获取包含n个数字的字符串</span><br>  <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 第三步：对字符串进行处理，转化为数字数组</span><br>  <span class="hljs-keyword">let</span> nums = line<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 用空格分割，过滤空值</span><br><br>  <span class="hljs-comment">// 第四步：计算数组中所有数字的总和</span><br>  <span class="hljs-keyword">let</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 第五步：输出总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="6-多组-一维数组-T-组形式"><a href="#6-多组-一维数组-T-组形式" class="headerlink" title="6.多组_一维数组_T 组形式"></a>6.多组_一维数组_T 组形式</h4><h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>输出：<br><span class="hljs-number">12</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 循环处理每组数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) {<br>    <span class="hljs-comment">// 读取当前组的元素个数n</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 读取当前组的数组元素行</span><br>    <span class="hljs-keyword">const</span> arrayLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 将字符串分割为数字数组</span><br>    <span class="hljs-keyword">const</span> numbers = arrayLine<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-comment">// 计算数组总和（使用reduce累加，初始值为0）</span><br>    <span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, current</span>) =&gt;</span> acc + current, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="7-单组-二维数组"><a href="#7-单组-二维数组" class="headerlink" title="7.单组_二维数组"></a>7.单组_二维数组</h4><h6 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>输出：<br><span class="hljs-number">78</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">let</span> firstLine = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br>  <span class="hljs-keyword">let</span> [m, n] = firstLine.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// m=3, n=4（对应示例输入）</span><br><br>  <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储总和</span><br><br>  <span class="hljs-comment">// 2. 循环读取m行数据（二维数组的每一行）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    <span class="hljs-keyword">let</span> row = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>(); <span class="hljs-comment">// 读取一行数据（如"1 2 3 4"）</span><br>    <span class="hljs-keyword">let</span> nums = row<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>); <span class="hljs-comment">// 转为数字数组（如[1,2,3,4]）</span><br><br>    <span class="hljs-comment">// 3. 累加当前行的所有元素到总和</span><br>    <span class="hljs-keyword">let</span> rowSum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>    totalSum += rowSum;<br>  }<br><br>  <span class="hljs-comment">// 4. 输出二维数组所有元素的总和</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>})();<br></code></pre></td></tr></table></figure><h4 id="8-多组-二维数组-T-组形式"><a href="#8-多组-二维数组-T-组形式" class="headerlink" title="8.多组_二维数组_T 组形式"></a>8.多组_二维数组_T 组形式</h4><h6 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br>输出：<br><span class="hljs-number">78</span><br><span class="hljs-number">2024</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组二维数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的行数m和列数n</span><br>    <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储当前组的总和</span><br><br>    <span class="hljs-comment">// 2.2 读取m行数据（二维数组的每一行）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>      <span class="hljs-keyword">const</span> row = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>        .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>      <span class="hljs-comment">// 累加当前行的所有元素</span><br>      <span class="hljs-keyword">const</span> rowSum = row.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br>      totalSum += rowSum;<br>    }<br><br>    <span class="hljs-comment">// 2.3 输出当前组的总和</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalSum);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="9-单组-字符串"><a href="#9-单组-字符串" class="headerlink" title="9.单组_字符串"></a>9.单组_字符串</h4><h6 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h6><p>给定一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>n</code>，第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">5</span><br>abcde<br>输出：<br>edcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行：字符串的长度n（本题中可忽略具体值，仅用于匹配输入格式）</span><br>  <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 读取第二行：需要反转的字符串</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 3. 反转字符串：</span><br>  <span class="hljs-comment">//    - split('') 将字符串转为字符数组（如"abcde" → ['a','b','c','d','e']）</span><br>  <span class="hljs-comment">//    - reverse() 反转数组（→ ['e','d','c','b','a']）</span><br>  <span class="hljs-comment">//    - join('') 将数组转回字符串（→ "edcba"）</span><br>  <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>  <span class="hljs-comment">// 4. 输出反转后的字符串</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>})();<br></code></pre></td></tr></table></figure><h4 id="10-多组-字符串-T-组形式"><a href="#10-多组-字符串-T-组形式" class="headerlink" title="10.多组_字符串_T 组形式"></a>10.多组_字符串_T 组形式</h4><h6 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次只给出一个长度为<code>n</code>的字符串<code>s</code>,请你将其倒置，然后输出。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后<code>t</code>组数据。每组的第一行有一个整数<code>n</code>,每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出<code>t</code>行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br>abcde<br><span class="hljs-number">8</span><br>redocwon<br><span class="hljs-number">9</span><br>tfarcenim<br>输出：<br>edcba<br>nowcoder<br>minecraft<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串长度n（仅用于匹配输入格式，反转逻辑不依赖此值）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取当前组需要反转的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 反转字符串：拆分为字符数组 → 反转数组 → 拼接为字符串</span><br>    <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><br>    <span class="hljs-comment">// 2.4 输出反转后的字符串</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedStr);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="11-单组-二维字符数组"><a href="#11-单组-二维字符数组" class="headerlink" title="11.单组_二维字符数组"></a>11.单组_二维字符数组</h4><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有两个整数<code>n</code>和<code>m</code>，随后<code>n</code>行，每行有<code>m</code>个字符，仅包含小写英文字符。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个二维字符数组。</p><h6 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>abcd<br>efgh<br>ijkl<br>输出：<br>lkji<br>hgfe<br>dcba<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取第一行，获取二维数组的行数m和列数n</span><br>  <span class="hljs-keyword">const</span> [m, n] = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>  <span class="hljs-comment">// 2. 读取m行字符串，存储到数组中</span><br>  <span class="hljs-keyword">const</span> rows = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>    rows.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br>  }<br><br>  <span class="hljs-comment">// 3. 处理逻辑：</span><br>  <span class="hljs-comment">//    a. 先将每行字符串反转（如"abcd" → "dcba"）</span><br>  <span class="hljs-comment">//    b. 再将所有行的顺序反转（如[行1, 行2, 行3] → [行3, 行2, 行1]）</span><br>  <span class="hljs-keyword">const</span> reversedRows = rows<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>)) <span class="hljs-comment">// 每行字符反转</span><br>    .<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// 行顺序反转</span><br><br>  <span class="hljs-comment">// 4. 逐行输出处理后的结果</span><br>  reversedRows.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(row));<br>})();<br></code></pre></td></tr></table></figure><h4 id="12-多组-带空格的字符串-T-组形式"><a href="#12-多组-带空格的字符串-T-组形式" class="headerlink" title="12.多组_带空格的字符串_T 组形式"></a>12.多组_带空格的字符串_T 组形式</h4><h6 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h6><p>给定<code>t</code>组询问，每次给出一个长度为<code>n</code>的带空格的字符串<code>s</code>，请你去掉空格之后，将其倒置，然后输出。</p><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行有一个整数<code>t</code>，随后有<code>t</code>组数据。每组的第一行有一个整数<code>n</code>，每组的第二行有一个字符串<code>s</code>，仅包含小写英文字符和空格，保证字符串首尾都不是空格。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出 t 行，每行一个字符串，代表倒置后的字符串<code>s</code>。</p><h6 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">3</span><br><span class="hljs-number">9</span><br>one space<br><span class="hljs-number">11</span><br>two  spaces<br><span class="hljs-number">14</span><br>three   spaces<br>输出：<br>ecapseno<br>secapsowt<br>secapseerht<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取测试用例总数T</span><br>  <span class="hljs-keyword">const</span> T = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>  <span class="hljs-comment">// 2. 循环处理每组字符串</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; T; t++) {<br>    <span class="hljs-comment">// 2.1 读取当前组的字符串总长度n（用于匹配输入格式）</span><br>    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>());<br><br>    <span class="hljs-comment">// 2.2 读取带空格的字符串</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>    <span class="hljs-comment">// 2.3 处理逻辑：</span><br>    <span class="hljs-comment">//    a. 先将字符串所有字符（包括空格）反转</span><br>    <span class="hljs-comment">//    b. 再去除反转后字符串中的所有空格</span><br>    <span class="hljs-keyword">const</span> processed = str<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拆分为字符数组（含空格）</span><br>      .<span class="hljs-title function_">reverse</span>() <span class="hljs-comment">// 反转所有字符（包括空格）</span><br>      .<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 拼接回字符串</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// 去除所有空格（\s+匹配任意空白字符）</span><br><br>    <span class="hljs-comment">// 2.4 输出处理结果</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processed);<br>  }<br>})();<br></code></pre></td></tr></table></figure><h4 id="13-单组-保留小数位数"><a href="#13-单组-保留小数位数" class="headerlink" title="13.单组_保留小数位数"></a>13.单组_保留小数位数</h4><h6 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h6><p>给定一个小数 n ，请你保留 3 位小数后输出。</p><p>如果原来的小数位数少于 3 ，需要补充 0 。</p><p>如果原来的小数位数多于 3 ，需要四舍五入到 3 位。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">1.23</span><br>输出：<br><span class="hljs-number">1.230</span><br><br>输入：<br><span class="hljs-number">114.514</span><br>输出：<br><span class="hljs-number">114.514</span><br><br>输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">123.000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的小数（单组输入，只需读一次）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 将字符串转换为浮点数</span><br>  <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">parseFloat</span>(numStr);<br><br>  <span class="hljs-comment">// 3. 保留3位小数：toFixed(3)会自动补零，确保结果是3位小数</span><br>  <span class="hljs-keyword">const</span> result = num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">// 4. 输出格式化后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h4 id="14-单组-补充前导零"><a href="#14-单组-补充前导零" class="headerlink" title="14.单组_补充前导零"></a>14.单组_补充前导零</h4><h6 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h6><p>给定一个正整数 n ，请你保留 9 个数位，然后输出。</p><p>如果数位少于 9 个，那么需要补充前导零。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个小数，保留 3 位。</p><h6 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">输入：<br><span class="hljs-number">123</span><br>输出：<br><span class="hljs-number">000000123</span><br><br>输入：<br><span class="hljs-number">123456789</span><br>输出：<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readline"</span>).<span class="hljs-title function_">createInterface</span>({ <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> });<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-title function_">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-comment">// 1. 读取输入的数字（单组输入，读取一行即可）</span><br>  <span class="hljs-keyword">const</span> numStr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>();<br><br>  <span class="hljs-comment">// 2. 补充前导零至9位：</span><br>  <span class="hljs-comment">//    - padStart(9, '0') 表示如果字符串长度不足9位，在前面补'0'直到长度为9</span><br>  <span class="hljs-keyword">const</span> result = numStr.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">9</span>, <span class="hljs-string">"0"</span>);<br><br>  <span class="hljs-comment">// 3. 输出处理后的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>})();<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>parseInt()</code>：将字符串转化为整数。</li><li><code>parseFloat()</code>：将字符串转化为浮点数。</li><li><code>split()</code>：将字符串按指定分隔符分割成数组。</li><li><code>reverse()</code>：反转数组。</li><li><code>join()</code>：将数组元素按指定分隔符拼接成字符串。</li><li><p><code>padStart()</code>：在字符串前面补充指定字符，直到字符串长度达到指定长度。</p></li><li><p><code>line = await readline()</code>：要注意 await readline()获取的是一段字符串，后面我们还要自己将它分割或者转化为其他数据类型。</p></li><li><code>let tokens = line.split(' ')</code>：这段代码作用是，将一行输入按空格分割成数组（例如”1 2”分割为[“1”, “2”]）。</li><li><code>let a = parseInt(tokens[0])</code>：这段代码的作用是，将分割的字符转化为数字。</li></ul><p>再配合<code>while</code>和<code>for</code>语句差不多可以应对各种题型了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我觉得就应该像力扣那样搞关键函数模式，至少前端岗可以这么搞&lt;br&gt;上 ACM 感觉除了 cpp 和 py 其他处理输入输出要麻烦死，遂在这里记录 js 的处理模板&lt;/p&gt;
&lt;h2 id=&quot;一、基础模板&quot;&gt;&lt;a href=&quot;#一、基础模板&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25-ES6-关于JavaScript的Set 方法</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/27040.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/27040.html</id>
    <published>2025-12-25T07:26:18.000Z</published>
    <updated>2025-12-26T05:45:01.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Set-方法详解"><a href="#JavaScript-Set-方法详解" class="headerlink" title="JavaScript Set 方法详解"></a>JavaScript Set 方法详解</h1><h2 id="1-Set-是什么？"><a href="#1-Set-是什么？" class="headerlink" title="1. Set 是什么？"></a>1. Set 是什么？</h2><p><strong>Set</strong>​ 是 ES6 引入的一种新的数据结构，它类似于数组，但<strong>成员的值都是唯一的</strong>，没有重复的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 创建一个 Set</span><br><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 或者从数组创建</span><br><span class="hljs-keyword">const</span> setFromArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// 会自动去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setFromArray); <span class="hljs-comment">// Set(4) {1, 2, 3, 4}</span><br></code></pre></td></tr></table></figure><h2 id="2-Set-的基本方法"><a href="#2-Set-的基本方法" class="headerlink" title="2. Set 的基本方法"></a>2. Set 的基本方法</h2><h3 id="2-1-添加元素：add"><a href="#2-1-添加元素：add" class="headerlink" title="2.1 添加元素：add()"></a>2.1 添加元素：<code>add()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 添加单个元素</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复添加，不会被添加进去</span><br><br><span class="hljs-comment">// 链式调用</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 可以添加任意类型的值</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"hello"</span>);<br>set.<span class="hljs-title function_">add</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> });<br>set.<span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// NaN 在 Set 中也是唯一的</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// 不会添加第二个 NaN</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 查看大小</span><br></code></pre></td></tr></table></figure><h3 id="2-2-删除元素：delete"><a href="#2-2-删除元素：delete" class="headerlink" title="2.2 删除元素：delete()"></a>2.2 删除元素：<code>delete()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-comment">// 删除指定值</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(4) {1, 2, 4, 5}</span><br><br><span class="hljs-comment">// 删除不存在的值返回 false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 删除对象引用需要相同的引用</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> })); <span class="hljs-comment">// false，因为不是同一个引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">delete</span>(obj)); <span class="hljs-comment">// true，删除成功</span><br></code></pre></td></tr></table></figure><h3 id="2-3-检查存在：has"><a href="#2-3-检查存在：has" class="headerlink" title="2.3 检查存在：has()"></a>2.3 检查存在：<code>has()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 对于 NaN，Set 能正确处理</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="2-4-清空-Set：clear"><a href="#2-4-清空-Set：clear" class="headerlink" title="2.4 清空 Set：clear()"></a>2.4 清空 Set：<code>clear()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 5</span><br><br>set.<span class="hljs-title function_">clear</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(0) {}</span><br></code></pre></td></tr></table></figure><h2 id="3-Set-的遍历方法"><a href="#3-Set-的遍历方法" class="headerlink" title="3. Set 的遍历方法"></a>3. Set 的遍历方法</h2><h3 id="3-1-forEach"><a href="#3-1-forEach" class="headerlink" title="3.1 forEach()"></a>3.1 <code>forEach()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>]);<br><br><span class="hljs-comment">// 遍历每个元素</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key, set</span>) =&gt;</span> {<br>  <span class="hljs-comment">// Set 的 key 和 value 相同</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);<br>});<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// apple: apple</span><br><span class="hljs-comment">// banana: banana</span><br><span class="hljs-comment">// orange: orange</span><br></code></pre></td></tr></table></figure><h3 id="3-2-keys-、values-、entries"><a href="#3-2-keys-、values-、entries" class="headerlink" title="3.2 keys()、values()、entries()"></a>3.2 <code>keys()</code>、<code>values()</code>、<code>entries()</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]);<br><br><span class="hljs-comment">// keys() - 返回键名的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">keys</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// values() - 返回键值的遍历器（Set 的键和值相同）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// a, b, c</span><br>}<br><br><span class="hljs-comment">// entries() - 返回键值对的遍历器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">entries</span>()) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry); <span class="hljs-comment">// ['a', 'a'], ['b', 'b'], ['c', 'c']</span><br>}<br></code></pre></td></tr></table></figure><h2 id="4-Set-的特性"><a href="#4-Set-的特性" class="headerlink" title="4. Set 的特性"></a>4. Set 的特性</h2><h3 id="4-1-唯一性"><a href="#4-1-唯一性" class="headerlink" title="4.1 唯一性"></a>4.1 唯一性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 自动去重</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> uniqueSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...uniqueSet]); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 对象引用不同，不算重复</span><br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> objSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([obj1, obj2, obj1]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objSet.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，obj1 和 obj2 被认为是不同的</span><br></code></pre></td></tr></table></figure><h3 id="4-2-与数组的对比"><a href="#4-2-与数组的对比" class="headerlink" title="4.2 与数组的对比"></a>4.2 与数组的对比</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 查找元素</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><br><span class="hljs-comment">// 数组查找是 O(n)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，需要遍历</span><br><br><span class="hljs-comment">// Set 查找是 O(1)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true，哈希查找，更快</span><br><br><span class="hljs-comment">// 判断是否重复</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicates</span> = (<span class="hljs-params">array</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array).<span class="hljs-property">size</span> !== array.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="4-3-迭代顺序"><a href="#4-3-迭代顺序" class="headerlink" title="4.3 迭代顺序"></a>4.3 迭代顺序</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 的遍历顺序就是插入顺序</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 3, 1, 2（插入顺序）</span><br>}<br><br><span class="hljs-comment">// 与对象不同，对象的键顺序不保证</span><br><span class="hljs-keyword">const</span> obj = { <span class="hljs-number">3</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>: <span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>: <span class="hljs-string">"c"</span> };<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)); <span class="hljs-comment">// ['1', '2', '3']（数字键会排序）</span><br></code></pre></td></tr></table></figure><h2 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h2><h3 id="5-1-数组去重（最常用）"><a href="#5-1-数组去重（最常用）" class="headerlink" title="5.1 数组去重（最常用）"></a>5.1 数组去重（最常用）</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传统方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniqueArray</span>(numbers)); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// 字符串去重</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"hello world"</span>;<br><span class="hljs-keyword">const</span> uniqueChars = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueChars); <span class="hljs-comment">// 'helo wrd'</span><br></code></pre></td></tr></table></figure><h3 id="5-2-求交集、并集、差集"><a href="#5-2-求交集、并集、差集" class="headerlink" title="5.2 求交集、并集、差集"></a>5.2 求交集、并集、差集</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> setA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">const</span> setB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">const</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...union]); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">const</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...intersection]); <span class="hljs-comment">// [3, 4]</span><br><br><span class="hljs-comment">// 差集（A 有 B 没有）</span><br><span class="hljs-keyword">const</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...difference]); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="5-3-数据筛选"><a href="#5-3-数据筛选" class="headerlink" title="5.3 数据筛选"></a>5.3 数据筛选</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 从数组中过滤出唯一的元素</span><br><span class="hljs-keyword">const</span> data = [<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Bob"</span> },<br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> }, <span class="hljs-comment">// 重复</span><br>  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Charlie"</span> },<br>];<br><br><span class="hljs-comment">// 基于 id 去重</span><br><span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> uniqueData = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {<br>  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(item.<span class="hljs-property">id</span>)) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  } <span class="hljs-keyword">else</span> {<br>    seen.<span class="hljs-title function_">add</span>(item.<span class="hljs-property">id</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>});<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueData);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//     { id: 1, name: 'Alice' },</span><br><span class="hljs-comment">//     { id: 2, name: 'Bob' },</span><br><span class="hljs-comment">//     { id: 3, name: 'Charlie' }</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h3 id="5-4-标签-分类系统"><a href="#5-4-标签-分类系统" class="headerlink" title="5.4 标签/分类系统"></a>5.4 标签/分类系统</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TagSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-title function_">addTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">removeTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">delete</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-title function_">hasTag</span>(<span class="hljs-params">tag</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">has</span>(tag.<span class="hljs-title function_">toLowerCase</span>());<br>  }<br><br>  <span class="hljs-title function_">getAllTags</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>];<br>  }<br><br>  <span class="hljs-title function_">merge</span>(<span class="hljs-params">otherTagSystem</span>) {<br>    otherTagSystem.<span class="hljs-property">tags</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">tag</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tags</span>.<span class="hljs-title function_">add</span>(tag));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> articleTags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagSystem</span>();<br>articleTags.<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"Tutorial"</span>).<span class="hljs-title function_">addTag</span>(<span class="hljs-string">"JavaScript"</span>); <span class="hljs-comment">// 不会重复添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(articleTags.<span class="hljs-title function_">getAllTags</span>()); <span class="hljs-comment">// ['javascript', 'tutorial']</span><br></code></pre></td></tr></table></figure><h2 id="6-Set-性能优势"><a href="#6-Set-性能优势" class="headerlink" title="6. Set 性能优势"></a>6. Set 性能优势</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 测试查找性能</span><br><span class="hljs-keyword">const</span> largeArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);<br><span class="hljs-keyword">const</span> largeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(largeArray);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Array查找"</span>);<br>largeArray.<span class="hljs-title function_">includes</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Array查找"</span>); <span class="hljs-comment">// 约 0.5-1ms</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set查找"</span>);<br>largeSet.<span class="hljs-title function_">has</span>(<span class="hljs-number">999999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set查找"</span>); <span class="hljs-comment">// 约 0.01ms</span><br><br><span class="hljs-comment">// 测试重复检查性能</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesArray</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) {<br>      <span class="hljs-keyword">if</span> (arr[i] === arr[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>};<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkDuplicatesSet</span> = (<span class="hljs-params">arr</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>;<br>};<br><br><span class="hljs-keyword">const</span> testArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">() =&gt;</span><br>  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)<br>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"数组检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesArray</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"数组检查重复"</span>); <span class="hljs-comment">// 慢</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Set检查重复"</span>);<br><span class="hljs-title function_">checkDuplicatesSet</span>(testArray);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Set检查重复"</span>); <span class="hljs-comment">// 快</span><br></code></pre></td></tr></table></figure><h2 id="7-WeakSet"><a href="#7-WeakSet" class="headerlink" title="7. WeakSet"></a>7. WeakSet</h2><h3 id="7-1-与-Set-的区别"><a href="#7-1-与-Set-的区别" class="headerlink" title="7.1 与 Set 的区别"></a>7.1 与 Set 的区别</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set 可以存储任何类型的值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };<br>set.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// WeakSet 只能存储对象引用</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>weakSet.<span class="hljs-title function_">add</span>(obj); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// weakSet.add(1); // TypeError: Invalid value used in weak set</span><br><br><span class="hljs-comment">// WeakSet 的引用是弱引用，不会阻止垃圾回收</span><br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除引用</span><br><span class="hljs-comment">// 等待垃圾回收后，weakSet 中的对应项会自动被移除</span><br></code></pre></td></tr></table></figure><h3 id="7-2-WeakSet-的方法"><a href="#7-2-WeakSet-的方法" class="headerlink" title="7.2 WeakSet 的方法"></a>7.2 WeakSet 的方法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><span class="hljs-keyword">const</span> obj1 = {};<br><span class="hljs-keyword">const</span> obj2 = {};<br><br>weakSet.<span class="hljs-title function_">add</span>(obj1);<br>weakSet.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// true</span><br>weakSet.<span class="hljs-title function_">delete</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// WeakSet 没有 size 属性，不能遍历</span><br><span class="hljs-comment">// console.log(weakSet.size); // undefined</span><br><span class="hljs-comment">// weakSet.forEach(...) // 没有 forEach 方法</span><br></code></pre></td></tr></table></figure><h3 id="7-3-WeakSet-的应用场景"><a href="#7-3-WeakSet-的应用场景" class="headerlink" title="7.3 WeakSet 的应用场景"></a>7.3 WeakSet 的应用场景</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 1. 存储 DOM 节点，避免内存泄漏</span><br><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">"button"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button</span>) =&gt;</span> {<br>  weakSet.<span class="hljs-title function_">add</span>(button);<br>  button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-keyword">if</span> (weakSet.<span class="hljs-title function_">has</span>(button)) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"按钮在集合中"</span>);<br>    }<br>  });<br>});<br><br><span class="hljs-comment">// 当按钮从 DOM 中移除时，会被自动垃圾回收</span><br><span class="hljs-comment">// weakSet 中的引用也会自动移除</span><br><br><span class="hljs-comment">// 2. 私有属性模拟</span><br><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    privateData.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 标记为"初始化"</span><br>  }<br><br>  <span class="hljs-title function_">isInitialized</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">has</span>(<span class="hljs-variable language_">this</span>);<br>  }<br>}<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Alice"</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-title function_">isInitialized</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="8-常见的一些陷阱和注意事项"><a href="#8-常见的一些陷阱和注意事项" class="headerlink" title="8. 常见的一些陷阱和注意事项"></a>8. 常见的一些陷阱和注意事项</h2><h3 id="8-1-NaN-的处理"><a href="#8-1-NaN-的处理" class="headerlink" title="8.1 NaN 的处理"></a>8.1 NaN 的处理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 注意：NaN === NaN 为 false，但 Set 认为 NaN 等于自身</span><br></code></pre></td></tr></table></figure><h3 id="8-2-对象引用"><a href="#8-2-对象引用" class="headerlink" title="8.2 对象引用"></a>8.2 对象引用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<br><br>set.<span class="hljs-title function_">add</span>(obj1);<br>set.<span class="hljs-title function_">add</span>(obj2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，因为 obj1 和 obj2 是不同的对象引用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> })); <span class="hljs-comment">// false，新对象不是同一个引用</span><br></code></pre></td></tr></table></figure><h3 id="8-3-类型转换"><a href="#8-3-类型转换" class="headerlink" title="8.3 类型转换"></a>8.3 类型转换</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">"1"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2，1 和 '1' 类型不同，不会去重</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">"1"</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="8-4-遍历时修改"><a href="#8-4-遍历时修改" class="headerlink" title="8.4 遍历时修改"></a>8.4 遍历时修改</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 在遍历时删除元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">2</span>) {<br>    set.<span class="hljs-title function_">delete</span>(item); <span class="hljs-comment">// 当前正在遍历的元素可以安全删除</span><br>  }<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 1, 2, 3（会正常遍历完）</span><br>}<br><br><span class="hljs-comment">// 在遍历时添加元素可能有问题</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set) {<br>  <span class="hljs-keyword">if</span> (item === <span class="hljs-number">1</span>) {<br>    set.<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加的元素在本次遍历中可能不会被访问</span><br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="9-与其它数据结构的转换"><a href="#9-与其它数据结构的转换" class="headerlink" title="9. 与其它数据结构的转换"></a>9. 与其它数据结构的转换</h2><h3 id="9-1-Set-与-Array"><a href="#9-1-Set-与-Array" class="headerlink" title="9.1 Set 与 Array"></a>9.1 Set 与 Array</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Set → Array</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> arr1 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set);<br><span class="hljs-keyword">const</span> arr2 = [...set];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1, arr2); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// Array → Set</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...newSet]); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="9-2-Set-与-String"><a href="#9-2-Set-与-String" class="headerlink" title="9.2 Set 与 String"></a>9.2 Set 与 String</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 字符串去重并排序</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">"javascript"</span>;<br><span class="hljs-keyword">const</span> uniqueSorted = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(str)].<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueSorted); <span class="hljs-comment">// 'aijprstv'</span><br></code></pre></td></tr></table></figure><h3 id="9-3-Set-与-Map"><a href="#9-3-Set-与-Map" class="headerlink" title="9.3 Set 与 Map"></a>9.3 Set 与 Map</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用 Set 存储 Map 的键</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>],<br>]);<br><br><span class="hljs-keyword">const</span> keysSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(map.<span class="hljs-title function_">keys</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...keysSet]); <span class="hljs-comment">// ['a', 'b', 'c']</span><br></code></pre></td></tr></table></figure><h2 id="10-综合示例"><a href="#10-综合示例" class="headerlink" title="10. 综合示例"></a>10. 综合示例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实现一个简单的权限系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionSystem</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  }<br><br>  <span class="hljs-comment">// 添加权限</span><br>  <span class="hljs-title function_">addPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 批量添加权限</span><br>  <span class="hljs-title function_">addPermissions</span>(<span class="hljs-params">permissionsArray</span>) {<br>    permissionsArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">add</span>(p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 检查是否有某个权限</span><br>  <span class="hljs-title function_">hasPermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(permission);<br>  }<br><br>  <span class="hljs-comment">// 检查是否有所有指定权限</span><br>  <span class="hljs-title function_">hasAllPermissions</span>(<span class="hljs-params">requiredPermissions</span>) {<br>    <span class="hljs-keyword">return</span> requiredPermissions.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 检查是否有任一指定权限</span><br>  <span class="hljs-title function_">hasAnyPermission</span>(<span class="hljs-params">permissions</span>) {<br>    <span class="hljs-keyword">return</span> permissions.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">has</span>(p));<br>  }<br><br>  <span class="hljs-comment">// 获取所有权限</span><br>  <span class="hljs-title function_">getAllPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>];<br>  }<br><br>  <span class="hljs-comment">// 移除权限</span><br>  <span class="hljs-title function_">removePermission</span>(<span class="hljs-params">permission</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">delete</span>(permission);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br><br>  <span class="hljs-comment">// 清空所有权限</span><br>  <span class="hljs-title function_">clearPermissions</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">permissions</span>.<span class="hljs-title function_">clear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  }<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> userPermissions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionSystem</span>();<br>userPermissions<br>  .<span class="hljs-title function_">addPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>, <span class="hljs-string">"delete"</span>])<br>  .<span class="hljs-title function_">addPermission</span>(<span class="hljs-string">"execute"</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasPermission</span>(<span class="hljs-string">"write"</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">hasAllPermissions</span>([<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>])); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userPermissions.<span class="hljs-title function_">getAllPermissions</span>()); <span class="hljs-comment">// ['read', 'write', 'delete', 'execute']</span><br></code></pre></td></tr></table></figure><hr><p>总之</p><ul><li>高效查找：<code>has()</code>方法的时间复杂度是 O(1)</li><li>遍历时按插入顺序输出</li><li>需要去重时，优先考虑 Set</li><li>需要快速查找元素是否存在时，用 Set 代替数组</li><li>存储唯一值集合时，Set 是最佳选择</li><li>需要存储对象引用并自动清理时，考虑 WeakSet</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-Set-方法详解&quot;&gt;&lt;a href=&quot;#JavaScript-Set-方法详解&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Set 方法详解&quot;&gt;&lt;/a&gt;JavaScript Set 方法详解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-25-力扣百题速练（Javascript/TypeScript）Vol.1</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39687.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39687.html</id>
    <published>2025-12-25T05:57:08.000Z</published>
    <updated>2025-12-27T03:55:34.755Z</updated>
    
    <content type="html"><![CDATA[<p>简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都</p><hr><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target<br>在该数组中找出 <strong>和为目标值 target</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标<br>你可以假设每种输入只会对应一个答案，并且同一个元素不能重复使用</p><p><strong>示例</strong>：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1] 解释：因为 nums[0] + nums[1] = 2 + 7 = 9。</p><p>直接用双重循环解，优化的话其实可以上哈希表</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) {<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) {<br>                <span class="hljs-keyword">return</span> [i, j];<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> [];<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p>给定两个非空单向链表，表示两个非负整数<br>每个节点存储一位数字，数字以逆序存储（个位在头部），要求返回一个新链表表示它们的和（同样逆序存储）<br>不允许修改原链表</p><p><strong>示例：</strong><br>输入：l1 = 2 → 4 → 3（表示 342），l2 = 5 → 6 → 4（表示 465）<br>输出：7 → 0 → 8（表示 807）</p><p>本质上是模拟竖式加法，从低位到高位逐位相加。由于链表逆序存储，正好从个位开始遍历</p><ol><li><strong>逐位相加并处理进位</strong>：<ul><li>同时遍历两个链表的节点，取当前节点值相加，加上上一位的进位（初始进位为 0）。</li><li>当前位结果 = (val1 + val2 + carry) % 10</li><li>新进位 carry = Math.floor((val1 + val2 + carry) / 10)</li></ul></li><li><strong>使用哑节点（dummy head）简化代码</strong>：<ul><li>创建一个哑节点，尾指针指向它，便于统一处理头部节点，避免单独处理第一个节点。</li></ul></li><li><strong>处理链表长度不等和最终进位</strong>：<ul><li>当一个链表遍历完时，将另一个链表的剩余节点视为 val = 0 继续相加。</li><li>遍历结束后，若仍有进位（carry = 1），需添加一个新节点值为 1。</li></ul></li></ol><p>提供以下 ListNode 类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>  <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">val</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">next</span>?: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params"><span class="hljs-attr">l1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">l2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dummy</span>: <span class="hljs-title class_">ListNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 哑节点，没有 dummy，直接从第一个节点开始构建，结果链表的头节点会在循环中不断变化</span><br>  <span class="hljs-comment">//需要额外判断是否是第一个节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">tail</span>: <span class="hljs-title class_">ListNode</span> = dummy;<br>  <span class="hljs-comment">//始终指向结果链表的“当前最后一个节点”。</span><br>  <span class="hljs-comment">//每次计算出一位新数字后，直接在 tail 后面添加新节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">carry</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 进位，当前这一位加完后，是否需要给下一位（更高位）额外加 1</span><br><br>  <span class="hljs-keyword">while</span> (l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span> || carry !== <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val1</span>: <span class="hljs-built_in">number</span> = l1 ? l1.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">val2</span>: <span class="hljs-built_in">number</span> = l2 ? l2.<span class="hljs-property">val</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">sum</span>: <span class="hljs-built_in">number</span> = val1 + val2 + carry;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">digit</span>: <span class="hljs-built_in">number</span> = sum % <span class="hljs-number">10</span>;<br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br><br>    tail.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(digit);<br>    tail = tail.<span class="hljs-property">next</span>;<br><br>    <span class="hljs-keyword">if</span> (l1) l1 = l1.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (l2) l2 = l2.<span class="hljs-property">next</span>;<br>  }<br><br>  <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p>要求给定一个字符串 s，找出其中不含有重复字符的最长<strong>子串</strong>的长度<br>（而非子序列）</p><p><strong>示例：</strong></p><ul><li>输入：”abcabcbb” → 输出：3（子串 “abc”）</li><li>输入：”bbbbb” → 输出：1</li><li>输入：”pwwkew” → 输出：3（子串 “wke”）</li></ul><p class='item-img' data-src='https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp'><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240827143904/Longest-Substring-without-repeating-characters-using-Sliding-window-1.webp" alt="Longest Substring Without Repeating Characters - GeeksforGeeks"></p><p>直接上滑动窗口，结合哈希集合（Set）或映射</p><ul><li>使用左指针 left 和右指针 right 维护一个窗口 (left, right)</li><li>扩展右指针，若遇到重复字符，则收缩左指针直到无重复</li><li>每次更新最大长度 maxLength = Math.max(maxLength, right - left)</li></ul><p class='item-img' data-src='https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png'><img src="https://favtutor.com/resources/images/uploads/mceu_28165975511699020966300.png" alt=""></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// 记录窗口内字符</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 左指针</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-property">length</span>; right++) {<br>        <span class="hljs-comment">// 若当前字符已存在，收缩左指针</span><br>        <span class="hljs-keyword">while</span> (charSet.<span class="hljs-title function_">has</span>(s[right])) {<br>            charSet.<span class="hljs-title function_">delete</span>(s[left]);<br>            left++;<br>        }<br>        charSet.<span class="hljs-title function_">add</span>(s[right]);<br>        maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLength, right - left + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> maxLength;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><p>要求在两个已排序数组 nums1 和 nums2 中找到合并后的中位数，且时间复杂度必须为 O(log(m + n))，其中 m 和 n 分别为数组长度</p><p><strong>示例</strong>：</p><p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><h3 id="最初思路"><a href="#最初思路" class="headerlink" title="最初思路"></a>最初思路</h3><p>最开始打算做双指针合并，使用两个指针 i 和 j 分别指向 nums1 和 nums2 的当前待比较位置（初始为 0），每次比较 nums1[i] 和 nums2[j]，将较小的元素放入结果数组 merged，并将对应指针后移，当某个数组遍历完后，将另一个数组剩余元素全部追加到 merged，合并完成后，merged 就是一个完整有序数组</p><p>然后就可以根据总长度奇偶性计算中位数：<br>奇数直接取第 (total+1)/2 个元素（索引 mid）<br>偶数取第 total/2 和第 total/2 + 1 个元素的平均（索引 mid-1 和 mid）</p><p>想了 40 分钟，但是复杂度 m * n，直接寄了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; nums2.<span class="hljs-property">length</span>; j++) {<br>        <span class="hljs-keyword">while</span>(nums2[j] &lt;= nums1[i]);<br>            merged.<span class="hljs-title function_">push</span>(nums2[j]);<br>        }<br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; nums2.<span class="hljs-property">length</span>; k++) {<br>        merged.<span class="hljs-title function_">push</span>(nums2[k]);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> ? merged[mid] : (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li><strong>外层 for</strong>：遍历 nums1 的每一个元素 nums1[i]。</li><li><strong>内层 while</strong>（代替 for，避免重复遍历）：在放入 nums1[i] 之前，先检查 nums2 的头部元素（nums2[0]）。<ul><li>只要 nums2[0] &lt;= nums1[i]，就说明这个元素应该排在 nums1[i] 前面，先放入 merged，并从 nums2 中移除（使用 shift()）。</li><li>这样保证了顺序正确。</li></ul></li><li>放入当前 nums1[i]。</li><li>外层循环结束后，如果 nums2 还有剩余元素（说明它们都大于 nums1 所有元素），直接全部追加。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>  <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>    <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>      merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!); <span class="hljs-comment">// 取出 nums2 头部元素</span><br>    }<br>    <span class="hljs-comment">// 放入当前 nums1[i]</span><br>    merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>  }<br>  <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>  <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>    merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>  }<br><br>  <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>    <span class="hljs-keyword">return</span> merged[mid];<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>暴力合并为 O(m + n)，但题目要求对数复杂度，因此需避免完整合并。核心思路是将问题转化为<strong>在较短数组上二分查找一个分区点</strong>，使左右部分满足中位数条件：</p><ul><li>总元素数 total = m + n。</li><li>中位数位置：若 total 奇数，为第 (total + 1)/2 个元素；若偶数，为第 total/2 和第 total/2 + 1 个元素的平均。</li><li>我们需要在合并数组的“左侧”选取 total/2 个元素（使用 (total + 1)/2 以统一奇偶处理）。</li><li>在较短数组 A 上二分查找左侧元素个数 i（0 ≤ i ≤ m），则较长数组 B 左侧元素个数 j = (total + 1)/2 - i。</li><li>分区条件：<ul><li>左侧最大值 ≤ 右侧最小值：max(A[i-1], B[j-1]) ≤ min(A[i], B[j])。</li></ul></li><li>处理边界：使用 -∞ 和 +∞ 填充空侧。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>确保 nums1 为较短数组（若不是，交换）。</li><li>二分范围：low = 0, high = nums1.length。</li><li>计算分区：i = (low + high) / 2, j = (m + n + 1) / 2 - i。</li><li>检查分区：<ul><li>若 A[i-1] &gt; B[j]，则 i 太大，high = i - 1。</li><li>若 B[j-1] &gt; A[i]，则 i 太小，low = i + 1。</li><li>否则，分区正确。</li></ul></li><li>计算中位数：<ul><li>左侧最大：max(A[i-1], B[j-1])。</li><li>右侧最小：min(A[i], B[j])。</li><li>若 total 奇数，返回左侧最大；偶数，返回平均。</li></ul></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params"><span class="hljs-attr">nums1</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">nums2</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">merged</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    <span class="hljs-comment">// 外层循环遍历 nums1 的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 在放入 nums1[i] 之前，先把 nums2 中所有小于等于 nums1[i] 的元素放入 merged</span><br>        <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums2[<span class="hljs-number">0</span>] &lt;= nums1[i]) {<br>            merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);  <span class="hljs-comment">// 取出 nums2 头部元素</span><br>        }<br><br>        <span class="hljs-comment">// 放入当前 nums1[i]</span><br>        merged.<span class="hljs-title function_">push</span>(nums1[i]);<br>    }<br><br>    <span class="hljs-comment">// 处理 nums2 中剩余的所有元素（如果 nums2 还有）</span><br>    <span class="hljs-keyword">while</span> (nums2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {<br>        merged.<span class="hljs-title function_">push</span>(nums2.<span class="hljs-title function_">shift</span>()!);<br>    }<br><br>    <span class="hljs-keyword">const</span> total = merged.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(total / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> merged[mid];<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> (merged[mid - <span class="hljs-number">1</span>] + merged[mid]) / <span class="hljs-number">2</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="5-最长的回文子串"><a href="#5-最长的回文子串" class="headerlink" title="5.最长的回文子串"></a>5.最长的回文子串</h2><p>要求给定一个字符串 s，返回其中最长的回文子串（回文指正读反读相同的连续子串）<br>示例：</p><ul><li>输入：”babad” → 输出：”bab” 或 “aba”（长度 3）</li><li>输入：”cbbd” → 输出：”bb”（长度 2）</li></ul><p class='item-img' data-src='https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png'><img src="https://nicklee1006.github.io/Leetcode-5-Longest-Palindromic-Substring/1.png" alt="Leetcode 5. Longest Palindromic Substring | Nick Li"></p><h3 id="中心扩展法（Expand-Around-Center）"><a href="#中心扩展法（Expand-Around-Center）" class="headerlink" title="中心扩展法（Expand Around Center）"></a>中心扩展法（Expand Around Center）</h3><p>时间复杂度 O(n²)，空间复杂度 O(1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回文串以中心对称。中心可能为单个字符（奇数长度回文）或两个相同字符间（偶数长度回文）。 对于字符串每个可能中心（共 2n-1 个），向两侧扩展比较字符，直至不对称。记录扩展中最长回文。</p><p>步骤：</p><ol><li>遍历字符串索引 i 从 0 到 n-1。</li><li>以 i 为中心扩展奇数长度回文。</li><li>以 i 和 i+1 为中心扩展偶数长度回文。</li><li>每次扩展更新最长回文起点和长度。</li><li>返回对应子串。</li></ol><p class='item-img' data-src='https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg'><img src="https://cdn.prod.website-files.com/6828da5fc9f6eba971cc609f/6870e9a611fec83938e98155_Longest%20Palindromic%20Substring.jpg" alt="Longest Palindromic Substring (With Visualization)"></p><h3 id="TypeScript-实现"><a href="#TypeScript-实现" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 最长回文起点</span><br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最长回文长度（初始至少 1）</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">expandAroundCenter</span>(<span class="hljs-params"><span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-property">length</span> &amp;&amp; s[left] === s[right]) {<br>            <span class="hljs-keyword">const</span> currentLength = right - left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (currentLength &gt; maxLength) {<br>                start = left;<br>                maxLength = currentLength;<br>            }<br>            left--;<br>            right++;<br>        }<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-comment">// 奇数长度回文（中心为 i）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i);<br>        <span class="hljs-comment">// 偶数长度回文（中心为 i 和 i+1）</span><br>        <span class="hljs-title function_">expandAroundCenter</span>(i, i + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(start, start + maxLength);<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="6-Z-字变换"><a href="#6-Z-字变换" class="headerlink" title="6. Z 字变换"></a>6. Z 字变换</h2><p>将一个给定字符串  <code>s</code>  根据给定的行数  <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列<br>比如输入字符串为  <code>"PAYPALISHIRING"</code>  行数为  <code>3</code>  时，排列如下：</p><p>P A H N<br>A P L S I I G<br>Y I R</p><p>之后输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>"PAHNAPLSIIGYIR"</code></p><p>实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><p>输入：s = “PAYPALISHIRING”, numRows = 3<br>输出：”PAHNAPLSIIGYIR”</p><p>示例 2：</p><p>输入：s = “PAYPALISHIRING”, numRows = 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br>P I N<br>A L S I G<br>Y A H R<br>P I</p><h3 id="TypeScript-实现-1"><a href="#TypeScript-实现-1" class="headerlink" title="TypeScript 实现"></a>TypeScript 实现</h3><p>直接计算位置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">numRows</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>  <span class="hljs-keyword">if</span> (numRows === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">const</span> cycle = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; numRows; row++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i + row &lt; s.<span class="hljs-property">length</span>; i += cycle) {<br>      result += s[i + row];<br>      <span class="hljs-keyword">if</span> (row !== <span class="hljs-number">0</span> &amp;&amp; row !== numRows - <span class="hljs-number">1</span> &amp;&amp; i + cycle - row &lt; s.<span class="hljs-property">length</span>) {<br>        result += s[i + cycle - row];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><p>给你一个 32 位的有符号整数  <code>x</code> ，返回将  <code>x</code>  中的数字部分反转后的结果<br>如果反转后整数超过 32 位的有符号整数的范围  <code>[−231, 231 − 1]</code> ，就返回 0<br>假设环境不允许存储 64 位整数（有符号或无符号</p><p>示例 1：<br>输入：x = 123<br>输出：321</p><p>示例 2：<br>输入：x = -123<br>输出：-321</p><p>没啥好讲的，转字符串反转再转回去，处理一下负号和边界情况就成</p><p>反转字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> reverseString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">return</span> x;<br>  }<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX</span> = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN</span> = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> mid = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">LI</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (mid[<span class="hljs-number">0</span>] === <span class="hljs-string">"-"</span>) {<br>    <span class="hljs-variable constant_">LI</span> = <span class="hljs-literal">false</span>;<br>  }<br>  <span class="hljs-keyword">const</span> reverseString = mid.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">true</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(reverseString) &lt; <span class="hljs-variable constant_">MIN</span> || <span class="hljs-built_in">parseInt</span>(reverseString) &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(reverseString);<br>  }<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">LI</span> === <span class="hljs-literal">false</span>) {<br>    <span class="hljs-keyword">let</span> fin = reverseString.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, reverseString.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> fin2 = -<span class="hljs-built_in">parseInt</span>(fin);<br>    <span class="hljs-keyword">if</span> (fin2 &lt; <span class="hljs-variable constant_">MIN</span> || fin2 &gt; <span class="hljs-variable constant_">MAX</span>) {<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> fin2;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8.字符串转换整数"></a>8.字符串转换整数</h2><p>实现一个  <code>myAtoi(string s)</code>  函数，使其能将字符串转换成一个 32 位有符号整数。</p><p>函数  <code>myAtoi(string s)</code>  的算法如下：</p><ol><li>空格：读入字符串并丢弃无用的前导空格（<code>" "</code>）</li><li>符号：检查下一个字符（假设还未到字符末尾）为  <code>'-'</code>  还是  <code>'+'</code>如果两者都不存在，则假定结果为正</li><li>转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾，如果没有读取数字，则结果为 0</li><li>舍入：如果整数数超过 32 位有符号整数范围  <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于  <code>−231</code>  的整数应该被舍入为  <code>−231</code> ，大于  <code>231 − 1</code>  的整数应该被舍入为  <code>231 − 1</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myAtoi</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> min = -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>);<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">sign</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> fin = <span class="hljs-string">""</span>;<br>  <span class="hljs-keyword">let</span> clac = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (i &lt;= s.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">" "</span>) {<br>      i++;<br>    }<br><br>    <span class="hljs-keyword">while</span> (s[i] === <span class="hljs-string">"-"</span> || s[i] === <span class="hljs-string">"+"</span>) {<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"-"</span>) {<br>        sign = -<span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"+"</span>) {<br>        sign = <span class="hljs-number">1</span>;<br>      }<br>      <span class="hljs-keyword">if</span> (clac === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      }<br>      clac = <span class="hljs-number">1</span>;<br>      i++;<br>    }<br>    <span class="hljs-keyword">while</span> (s[i] &lt;= <span class="hljs-string">"9"</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">"0"</span>) {<br>      fin = fin + s[i];<br>      i++;<br>    }<br>    <span class="hljs-keyword">if</span> (fin === <span class="hljs-string">""</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sign === <span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(fin);<br>    }<br>    <span class="hljs-keyword">if</span> (sign === -<span class="hljs-number">1</span>) {<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &gt;= max) {<br>        <span class="hljs-keyword">return</span> max;<br>      }<br>      <span class="hljs-keyword">if</span> (-<span class="hljs-built_in">parseInt</span>(fin) &lt;= min) {<br>        <span class="hljs-keyword">return</span> min;<br>      }<br>      <span class="hljs-keyword">return</span> -fin;<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure><p>没啥好说的，处理一下转换和条件判断的事情</p><hr><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h2><p>给一个整数  <code>x</code> ，如果  <code>x</code>  是一个回文整数，返回  <code>true</code> ；否则，返回  <code>false</code><br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数<br>例如，<code>121</code>  是回文，而  <code>123</code>  不是</p><p>智斗程度堪比两数之和，转字符串逆序比较秒了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">let</span> arr = x.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> brr = arr.<span class="hljs-title function_">split</span>(<span class="hljs-string">""</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);<br>  <span class="hljs-keyword">if</span> (arr === brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">if</span> (arr !== brr) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.正则表达式匹配</h2><p>给你一个字符串  <code>s</code>  和一个字符规律  <code>p</code>，请你来实现一个支持  <code>'.'</code>  和  <code>'*'</code>  的正则表达式匹配。</p><ul><li><code>'.'</code>  匹配任意单个字符</li><li><code>'*'</code>  匹配零个或多个前面的那一个元素</li></ul><p>匹配是要涵盖  <strong>整个</strong>  字符串  <code>s</code>  的，而不是部分字符串。</p><p>示例 1：</p><p>输入：s = “aa”, p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:</p><p>输入：s = “aa”, p = “a<em>“<br>输出：true<br>解释：因为 ‘</em>‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p>示例 3：</p><p>输入：s = “ab”, p = “.<em>“<br>输出：true<br>解释：”.</em>“ 表示可匹配零个或多个（’*‘）任意字符（’.’）</p><p>这道题最开始是想要用纯同步双指针来解，没解出来</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">if</span> (s == p) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>  <span class="hljs-keyword">let</span> sindex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> pindex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (sindex &lt; s.<span class="hljs-property">length</span> &amp;&amp; pindex &lt; p.<span class="hljs-property">length</span>) {<br>    <span class="hljs-keyword">if</span> (s[sindex] === p[pindex] || p[pindex] === <span class="hljs-string">"."</span>) {<br>      sindex++;<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (p[pindex] === <span class="hljs-string">"*"</span>) {<br>      <span class="hljs-keyword">while</span> (s[sindex] === s[sindex + <span class="hljs-number">1</span>]) {<br>        sindex++;<br>      }<br>      pindex++;<br>    }<br>    <span class="hljs-keyword">if</span> (s[sindex] !== p[pindex]) {<br>      <span class="hljs-keyword">if</span> (p[pindex] !== <span class="hljs-string">"*"</span> &amp;&amp; p[pindex] !== <span class="hljs-string">"."</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><p>↑ 错误答案</p><p>主要是该问题具有<strong>非确定性</strong>：同一个 “x*“ 可以有多种匹配方式（0 次、1 次、多次），需要尝试不同分支。纯同步双指针（单路径贪婪）无法处理回溯需求，会在某些案例中错误消耗字符，导致后续失败。</p><p>比如说在 s = “aaa”, p = “ab<em>a” 里贪婪匹配可能错误使用 “b</em>“，而实际应跳过 “b*“（匹配 0 次）</p><p>因此<strong>不能用简单 while 循环同步双指针线性解决</strong>，必须引入分支或状态记录</p><p>然后题解就是使用 dp 解决：</p><p><code>定义二维布尔数组 dp[i][j] 表示：s 的前 i 个字符（s[0..i-1]）是否能被 p 的前 j 个字符（p[0..j-1]）匹配，最终答案为 dp[m][n]，其中 m = s.length，n = p.length</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {<br>  <span class="hljs-keyword">const</span> m = s.<span class="hljs-property">length</span>,<br>    n = p.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">const</span> dp = <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));<br><br>  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>      dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>    }<br>  }<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>      <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"*"</span>) {<br>        dp[i][j] =<br>          dp[i][j - <span class="hljs-number">2</span>] ||<br>          ((s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">2</span>] || p[j - <span class="hljs-number">2</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j]);<br>      } <span class="hljs-keyword">else</span> {<br>        dp[i][j] =<br>          (s[i - <span class="hljs-number">1</span>] === p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">"."</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>      }<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> dp[m][n];<br>}<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p><strong>空串与空模式</strong><code>dp[0][0] = true</code>：空字符串可以被空模式匹配。<br><strong>空字符串与非空模式</strong> 只有当模式中某些 “x*” 可以匹配 0 次字符时，才可能匹配空字符串。 因此从左向右扫描模式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {<br>    <span class="hljs-keyword">if</span> (p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'*'</span>) {<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">2</span>];  <span class="hljs-comment">// 直接继承“跳过当前 x*”的状态</span><br>    }<br>}<br></code></pre></td></tr></table></figure><p>示例：p = “a<em>b</em>c*“ 可以匹配空字符串，故 dp[0][2]、dp[0][4]、dp[0][6] 均为 true。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>遍历 <code>i = 1..m</code> 和 <code>j = 1..n</code>，根据 <code>p[j-1]</code> 的类型分为两种情况：</p><ol><li><p><strong>当前模式字符不是 ‘*‘</strong>（普通字符或 ‘.’） 只能进行单字符匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = (s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">1</span>] || p[j-<span class="hljs-number">1</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>含义：当前字符匹配且前一个子问题也匹配，则当前子问题成立。</p></li><li><p><strong>当前模式字符是 ‘*‘</strong>（与前一个字符组成 “x<em>”） ‘</em>‘ 提供了两种选择：</p><ul><li>匹配 0 次：直接跳过整个 “x*”，状态等同于 dp[i][j-2]。</li><li>匹配 1 次或多次：前提是当前 <code>s[i-1]</code> 能与 “x” 匹配（<code>s[i-1] === p[j-2]</code> 或 <code>p[j-2] === '.'</code>），且在上一个字符已匹配的基础上继续使用 “x*” 匹配当前字符，即 <code>dp[i-1][j]</code></li></ul><p>两者任一成立即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] ||<br>          ((s[i-<span class="hljs-number">1</span>] === p[j-<span class="hljs-number">2</span>] || p[j-<span class="hljs-number">2</span>] === <span class="hljs-string">'.'</span>) &amp;&amp; dp[i-<span class="hljs-number">1</span>][j]);<br></code></pre></td></tr></table></figure></li></ol><h3 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h3><ul><li>时间复杂度：O(mn)，每个状态只计算一次。</li><li>空间复杂度：O(mn)，可进一步优化为 O(n)（仅使用两行或一行滚动数组）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单刷个力扣百题，完球了这玩意从大二下开坑以来就没刷完，现在后端转前端也要那前端那一套来过一趟，还有几天字节面试了都&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://zhongye1.github.io/Arknight-notes/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-15-杂谈-系统问题</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/48096.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/48096.html</id>
    <published>2025-12-15T03:51:13.000Z</published>
    <updated>2025-12-25T03:23:33.852Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="请联系站长。WXID:Zhong_ye1" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">      <script id="hbeData" type="hbeData" data-hmacdigest="302fb9ef81d6456313da0e313059bc39bfeae0bc0f3dd24fd920451c58ac8875" data-keysalt="6775e1f95d4243a806845549b8b0d89d8262017c270b2ba32457091b99694fb7" data-ivsalt="d10520be8f6844d66043f4079163697c6d748b01cc920fe7afc18a4cbc460a61">        064c4bd4fdb0bdd3db719c0ced511a3d2c3798a17bc19db18f0b1268279697bc5567bb48398719a9ddc014eefa4b229780bd7fab70f30c4af3d1cce59f90ede17f0c135123bc67e08907db501d013b5c3e78699ae1d18497e7755d7439e61fadf527386a33b0ef0c033ce441a74b260d460f986c6b3863b4b4a1f0958c9b370cf2fc5d45a7e22d1ff2709fd22c78b19485f00a623f3328a8122a74aefcce052bb38a54d1f76a4dbd2603e3f4bc9db278e6cc409806ece01b9d50acce9397527322b8999f34fa1c8cc7eefa707727f518407fad36f231d4989023f0adb4704b5f70540931f341685d9d62319958fd2afc99ab232f3e90500f12d848be6af27507817373fee7187c520cff6db83541e2960671a56526deefeded4e68d1c86fff449f2c8c38b0cfb3695f1123296753f7eafa545319691ab7856f7e512939efc03d4760980749fa59392d99acbc9eb8014b2eae2d4ae9733838b91fe78af780d99537fbfa3dfe84c494b88be191afe3f8dff736ed92f99b7789233dda850dc6a3d7e1af26c6cba9f815ef2e18f1ecea9fc2954f69966007c8f9267b821782bf16fad534b73438e9bffcc0dac2bebb8d7ed1a3d25c49229a521a63b08d8fe0599e69813d1633ae36d103093539c4018af61045db97c438b98e466c84f7dcd7ede5351c06f6336b3b159b66abe240ffbd2e4729b4dac31a6ae8820f48f0422d91105164f4fb3dec1c38fd20e375f3cc0acf95b579b98f99038c9b573dfc7c183a8e74e13c4c194604274be5a937b40aeed2385c84ef07d3717f64ed0ebd0c17b71c1dadbbea1832bd8a9d8823ce304a7ed0e19785c1a09e8a5a060e7dc9685028572d4aca0868b489447a7b8ef3aa897cd3a9d5201a4dea1fea186d1adf2059c7feba58d840457bb2bcbdeb4605d10fd9649d93c565bc4db3e6ded924314391ab2e4fedb598fc7e25ceb33a96c135cddc0375257e312a04f3e40fa5810d0d167e2e455032b4bd1db828e971e969dfb8462506fdf534da435070338ecb769229a2f2ac9fb038bcb93e85d0dfacc06664d07e068ec22aca8ca93c0e094f2828163bf80bd8b3cfa59f03d8cc08ef5ccd45be64e1f662d2dc64a73b9bd4b9efbee5f896f1e06c62c8981a0eb7a3c3af48c0bd992d1a751de4dc4b4660b62cdf6a9cac5dd0cb42c3a18a69f6e93902f4f59a4160651097d42991b335eb0bed2b8b955c8039f355b2bbe50357d5be732bd3623847c6dbf3cb11c97f4cfd141b7049940daf6c6a18cfbccd04591959f23919afdbd1b7c4b89936859997628274d2081cca218c7184ec81b2ac96950b34381f2a6b4ae4af3bc828a044fa6ba06a30abbda0505b5c4c4589280f0caa9442b0879a473aa0b27a81dbba97192892fd6a6f228fc5c79fda5e80716cbacc146740377e403c06c899f3477561408f8a5884e2e0d48986b44490eb1bc2eaeac07dbaa4bd02f13054b5b3b1dd037cf55ae55cedf6b6abf21b20ef54a662dacf43571a1436289d283d53a580aa52ed95b2ef31eebf52000e6470fb620ce690529f2ede175b8fe658d285760fc1b551915778b063be68ff5bc3d01949ae57ce207f66e7f8c5e2430832f57ba1c465113675fee6230cde7fa296fa5a044662a99c59704774fcadc6fb2110a5940743ab6ff46612d426b1e3180f20458e98fe19221c943ac00e148a0223266e6978f2ed089880302326d0ce2a05355865ae599ac841b67ece0cc682f8f7b0d7f115b702ed358bbc5e9a17775c6b56086221265cc01caecb2c1725d21ee865a8d0bc8ef1b408209d40fa510eafdcad52000564af234c0f0c79e6b46a17abcb785be614ca528170572779dfef09275428f450fd73f143dca07a5cb581dc2d3beaf0961ac49b581855f3210579254723ee69ce355e5acd49f1240f4b2b85b92f9d8fe8d4815bc12b07fb35701a5af411278b51eb3a15e474b4120f3d55ad7737e72191a11e7202cc5cb41dfb7e1ee524027e9714209af67194a9c14fe8b04f4ef8fce587cc219a2cc2a638adc03cc76af9d8e9fd8c8724c88ab2653497550477d6dd120757d1a9dbfe871287f881a258a741760276466c0467fe308a31ddaf00ccf5b73308ab46409c8500312c09086bc957d5e2efbe6319335d9b194cdfb1ebcd408a113e791e68da6720f5dcb49b10fa3b6db49a12e7ace9b06f5b44503701d7f5b6b724c8485e0ce8cf9710070b6f11a89620ac2c06246849730508d28031716a56ef169fa51ab53fc3f9165d352c8d5932c55ece8b3e066de94cf6e844bc3fcb95ca64e66c61a7f944b0b459760c3d7d1a267b0b03b86cf8bd69e24d2b02161823805a4c13f6f9c80fd6b48ff7a938b410927cd93eaed98fe9310aab1cc5db242e753cc4838e7f04a07cce6c52840ea44ff1e9369b1930ee8f35f053ba58111d75232ef4bd91865d29662dbd05d0ad5a202c604f77d5152b0b1fd11e9d55f686f9470610a3591051a2074cb11ff3c0fc3459e23ea04a2f684960caa410d0aa4f2eeccb0a5716bbb2ecffa8111556030a5d1a1b51bb21533b637933bceab0a5b478430ee165daf2cded5d947c9f1ac4f81dfd4dddb378cdb6b5271d7514fe927e67b69e0d897a76ac8813445e5f6d307885d5748033adc0aaa644220d93ab147b8b75775f6c0c1426d43eb1ffe60339bfea1d6448ad61090aeeeb1c705baa9de32cafdc6f049e32419b7630f67178bc1f1598eaa5ca3728fa678ba69bb73bb41140b6358424c482443e4d75858c083c57759421b47629a958bdb2de8c23c23bd1ec53cb9bf63451c144f8e2ca46fabff36dfa1d7a3247b51e1f16e9a4c2c470beb918a2c1e5ca7a68f69acfd77d0b17bc2392d051c147202ce95266bcb39188be7b71aa593bcb20bd135de791e4f6cf5ca54e571cf977448613b91e91e25ea6f34466bf3695dd711f325cc458f1b8ac891791b8fdc0b7bc05ac88149d184427b45e3f1379ee4bd834109da9278593e641186250e13358875e40854bba0db4e93b05c7f650465eaa867b972d3552e7e183cf643c1ac74974a235d44a92d6ae08c64130f672a70761572015ec86d43f243e5f5e2cb49bc52056fd797a5c09d1e805c8a96f656fffca9e7a9918391e605f49b6bc63e1f67527f97346c15168353c28d1732478f6f2b995fc5ea5ebb82687fbd1da565cecc1a05580b20567ebbe1b8748f929871fc42776c029c215e4dc1c16721c594237b0c131e5b6a6372980d1c7f27542f4705ef96d8b93ed69c23af43ca0a53ef2fa272eebfaa2eb1c2e80878c8b40b9f32cc0101221e6e071e4f1ff0ce4a13043fbbfc73df009c7eeb42b8335477740335a55ffdd4a1ee58edcdfe5c51e9070595318282e13a26b39bb836f88cfe345f14f7e10249824bcb9db06041009613ca73f6f657bd5e67784798bb49e2a11bfc1d71b99e14d6a232110d70b461969f0720e4bf82773f46b2127519032b9ab497f49c7536e16dfc5fd14885b5ba1be29dbedacaa71c24415c338fd4b202587a66716a920719288b937811c7cc9af9fc8aa7e137a995513ed9a161cd938a6560dbbaa87de61cc89629c9bfca4fa9fc9698bd72878278c71ab86044172805e146d9c022a7b28871bf1bd803d93bde6756a26fb56e9df44126347e91d5cb15e6a027c57916feec69f2b063da6eaf6440ea54a532ea8fd3d43aac79bd748ce055fdcf759eef0202f4996aff320d769e3b73e580be41d698cc1665363a1636b88a2d6a59f213fd58e4f94501fff084bc1562e2c4fab50d877bc9c1ae4d4f914b890f817bb4eb49088d0acd7df2d8d254c4c7483b6c1a9dd1477cc816030900f1e8e98463c22df191304a89feea7c2b0e9bd7eca1eff5bac8a4eb1f5dd353327c486c29950b40188d2b31962e1fc008dff9a25db3150b9c71fc3b94d6e01c58e8908ad4b74d230e6db9fb8bd8ba4a9f416322f8601504810cac822e18011ab32010dd051252c4d618ae5d482c369d6378f3291752bc7beefc1599fe2d2ba7b75638ee5e1ef976d8a4d38fa2ffc2c5b0cbf33dd2132ad3e0238f7ed19e8ddcd5ea1c5e7d22ee10537eb5578449db5c7d33ab486c4e430fb9f2431a4fac0ca0b7a920dac3c8b8f292233a65ac171e9415f5d7f28ec72c6ca06fec45778363579ca9ffb6e2d743192c9f4d4eacd06da6b9d4f1e1ec3e943c151c61b6c42ecf5c757f84eb65953fc8a5db2a45d653b110f49c4cd3100ba05abd2ed5b97d988fd900d6cbb07bc24497a6340fe74c61f075fb9c610ab91a496c42fc61a12f5e4e19387f9cbcbbc62f7f714c05c505931bb00497b512a7b9aa43a230d122d5deb04b209cd71327995a63edcf775374d1246510e00a0e22f3cd4bd105f7f9179406cbd0f48ab2c10f53a348eb7af7ccea239ff34df5fef52dc41e2b636f3d1a8d77ef951d145a78cc17cc5b0ba2b8f88176a7a7f06affe501e58b528e003a024aaabe772d1cbc9fb25005a23102dcaf473d1cca850fc3724b0ea622d6579163602fbc1aa1fcc611978d62c49b3e5d81312736fed1402b06f71c305b451ac33679ed0b90688506779521a15ced68893c3c05824e4015aae8fea7ee827093b9ffdad800f09f2027f9d722f79b315d4eaf1fc8b38ef0f6599a123afb2322cf47213c856ce2df2cbf31d9233122c6184d505784590391dec4283c7f962285ea44e4961dc5555f31dc54ae365170c801e672f6891315d70ff7ce5b99a878014c6547886df8bc760958ee8b65d3af8f87b5259fa9ccba99a6f2745bf2b2e019a9ee9d0553432ce96d02a04d1d2a7446d5e9d85e6701c5c5ff1e2979a2a05fcefd225bb74c63b32ffd0fedd41a829301e93d6b5e4e0f72a683ad0fff43a0fe887955f7559eee0d515868846fdfe42d9f90ef6c33125548a8b384cbbdcfe42a90fb000184f2a5b31f1bee7ada6a88b2fc2264b672d8cb0066c4873e7448a976cae1ca6ab81708a8ebf2060a8b7e199fdfd7ecfd96f9f9e284732f87b0d6514a8518468c3df43a72010d3ff215457419d5af085aa29a0fa9d713f14845322a0655fd79edf3ee2478c28746c5cce8a370ace338a4047e3a6b000c11e6f00ef31824c4e5b891a6ed50d1e81f4c8fd3bfc9fdad270522a66eae4bf27fdda523174e2d111dadfc9080726ab029815e27ff703797abec15840560c0189518e23a4cfb51276c6771cc1dc6400996856a88464448f511630b38b8fa9e6d4270c0e32947538de32afe7162b46d53c3f96cdc3f50d3fb855ef6d52813323d15cdadc3823343b9c7d9d8db5242fa7d1694a77ee19a17515ab19fa89ab2ccda48252a07900fe394d7ee26d24aa88df7c5fab8d26cd35379a4c228d6b914e0ab9e2c98a4cbd8151dfdd88b11ab0d1031dc7aee325b3238ddd301dda211e76f263140e1d9382e4f420c56189565aa12c33c3c676b36b80813053082028ec3210b35abf1112b721a7806387361dd1943c0aab0a69dc0d579c93dca46a166d81928286228777494eea4346ae161614db60cae42d5a9466a78ddc3f55e42783e3854f07de089e4df39101af300bec3a8b75c883899e0a4a1c2b02ca199fef89cd1959b6396273c1961d2e859456104296d8ea63ab27744bc8c32f739c59a7333714a288b74a602b6d52d076ad3cbaa0d8043d049c545961daa19b0de4d5c4163f0946395727b5bed3079f63210295f8d518af333518b91cd272b1e33c5b60bb9389d23765030a89c8a375906fb2d49b8ac1e405400c37314a02bda1f3ae5a5cfb09af2dc326a2b4f5e79315e79211ad262ca9dfec97f883c69219951ea1ccfc366373b2d0285dbe75a728534b149f4632c555825d33f706b1ebad72573300f7de00eb5369e2abc249d5cfd6ae8d830cb0ec4cf264424875d58397a59d99d43482c20c40922f076bf87930672bf07f20ab1a877598c34dd6ceb82cca11b117162c1f470f9ab8db33d8196868c3fb691e1a072719abb84ed3f4f7a74bef1f565fa3f560d22693dc7966f0d4f413c0f131509ce9276f57d5a9d1d59244854135696632d70118bdd4842dfcff9fb98bf94aa0f004edd3fe3d99d553c818fc2dc4d016d41c2d0b8647b7a08f6d9ae78851c966457246fbe17dedcc981e0f5cc78478cfd538c51afe554a539a13cedc34cfc247c76aa464f061d1e8336d052e0077251f71900ad760de551c705642a27904f7240887f7711855d745146684e6fdf51418d5b796ce46f022a7c91c6e416dacba9c55cdee38b5fe939097006c7e4e7a715f52740cb6322ec3f56d7f579e006cc03485067e658664294dcfd5463eac3686cdde5ee2d03a74416ee294a4321e29b8dc576dba4d2362c05965a71f8541658b51a21d1da4813c4e4b2baf6ea7eca4aae65a3d7b7ca82bab1431f556252314ddd6e950f19c5806d66831788679cfb6b9e07d3eefc456feafc95ea212fb5090b4919e91a4dcb1fe0b13aea6f873c8c180d82bcd4ce3a0e42fd32ae88297ed5749ba706befaed11532aff49ffe6bb130a8d2ae1884e6eb2e7b440426db515810207f140a8216655b1565d83aedfb041aafb9ce534af9c4a5c8e7999e88a97205614b77e1b1403a3e86d4190249edf616c1bb74858a04b0a937a66fe8a7f0249be34510a0cc6747dde65932dfe32115544cea4c5a7cf966ce33844959604996307b9001888e2dc2ea6b4c7bbce5e9bfdca6625ca64153e3defc83be74b50c837b5a522520697df897c969e6f6cf6c1185c08bc49fa738f089ed2e464d41540670bd13083b7aa0268d04586e2b6582fbc912ad3cf889fabb7ab6e3e114f9dcea100528c4b0f46f9880d941b2b4a9fe215dcacd832645f9c8c733fb939b9d89fea092ed9c114ee80715cabe76edf07b37acc7af93db1ef94dd903d50c38b9d44b0e7bd5e3aa4a881593974f8d8b6004d3ebe643bbb39f0de7a561f6c6120748375af898664defbcbaeb600394e6f1317bc1e075203c816d36abff6127146f23be88785e6ff2ad6c0eb5e0ac2a4158cc6b3fdf23e20b60cbd3a058f0d13e296c3a9a665d1e4b155d4776fbe4a4d715ed0ded21922c563ab21a4f96e06fce780baf2e7f2b00a11ff7c888478bb3ce22c9eafca63e3216053fe57bb4170c6235d3c5b3d8ea49ddaaf979cfd1bebbe8ba60b3e9fdc5dc7bcfa075ae8fcb2145d640e7f3ccdfe774af8fbd8d4e6e0f8e844be4168cb86188ab675f6d3f9c4c5e10f5117b1967757dbfba433815ef2203ebb24d0392b94035ec731c2dfcfdea60e68494ae8b44a4bcbb6205b188409e0957e8780e77930d2a3d815d7671559b55aba57f38015147f55e34f175cd40395bbab12a322116a6c98466c42981092828c80b9cf49c1158a46d6287095974997e63c17e8db09ea4eb601372b70ff6424471558e4b457c33cb3a0fc113f414974fab27d9ba90736aea2cd44911f8a70c64140df493215b96cfe6150a81baadfc03642dd2bf8118e5da326c71be11b74e0940ad4a89ac051f4776662bbd75d091a66657e42a3648c2bf9cc54f4651a8589e545078d545044f37b20b25fd2ce978798f49c62b7cdd01e02347bf4cf4ff651b494744f94e327d44247aa82b9670333cfeb720d06ecaba11cfbcf72d68330b2343f367993d68b80ce480d551f9f7aec640fb715f7d35229cab2228ec6338812035cec200ba4701eef9e1fa742e0f50307a22863a34c738324cc3eaa16719ef36ef5b3a04fdc2bd0476722c57fd8367eab04ec54c8c64b1a33ed35d50df8c37f4e3e1dcf19b4be8c6589696d30c3e7e203f5ccef2f40bf731a653562ed37b87ab26f227685e26d68ff1e37454e52d05ff776ee87f934c2ac0785602400ab1c37f3a3e93c154b74e632ec24d468aaad8cb35c84081c5bc32d45d265eee895c8c1161c0d2da66dd5b4ba96fde2f6c95a3c9e8d1cb94e51807192c07984cb293d96c428b684a561afe5c50846ee4f510dcdc6ef84c0b20a682b3f3bceeddfe428be1a314968be6951df9f4159e7ac24226dffb2d877efef0c90b13bea988fd11116886d86dba4d90c789185752472039be2256d3868ecb9ce4d8ba5c726b3f987de4dd34268fd517db3b36e1151fb8d6ba676720fe9efe16cbd0f71cc7c6718072b9788e978998163507ee827c2ee4926e11a948815c2e1539eb945c3d3eacaa2bd4a991e32ab907f825ec9c7264581b588c321a5f7133eedaf466d7a3af00cfa7a7fb421563a4897d3b955898af19c8c99abaabbe21b05dee1af4745eb9c18c017c9caef759fb86638999105b452ca863c794d6a8c0ecf7a130bde8c663a880cae4bf76d1742391f0917f648ebd292ed2cf61cd899c85d5b5556b8ea4ce83323c17f0bd95199d0ab53399ca4ffff79d3efe6ffa90407830b839ae738535fc7f7f43664eba434694de18e3c00ca4001690203793918ecb0e2a110b0253afab7da05092a7ff552d974e0caae068ad031b81b53c6863771d1ecf14321806c94292bf2b80dd7d63849b4564b878756efeb53dcf33b03ef589dc732982a1e725f3f708f56825f60fde8760f8a3cd346caf7ebabe5a1e6a762154a32f0ff34578a9c4ee103be5c6bb7cb655aa2c9d9fb5cc36a744ceea363e3b9958a11888682ce61e16844a8c15a54ee683c3550031f4115f6b28bd2cd5b3fed487ea6b17bd7e3147b20e5a2ff28130f9ac807dd5c7c4420389ae2f11ccc6565a309f84d501a63358c0acd2b19acdec39ddb6572850226372f94c3737c3f5966444b67a44cabca79f8ca758eb841ea613fa3fe890fc44d32356f56d4fa9f31dcec36a60e325649b122a7554301e66cd43ffcc9055b004f2d7c68f35c36b4059707829a22bdf378be49c9b3ba0fb4b2f8925a8ab1cab51a284fed2327780e4b350f8556091d5759169fcbf36e8279ab9ce0173e67ff34cc6e65090a0673fd1ec25eb7fa58e9c3eb6667b8e76e3e2e195f9f8d7d52f418d4fb9b4d3dedde2373e6f53a73ce37e52e1580901921bd182e2fc95cf89ef6c0b97930c7692efe25340db31a92a41235f6aeff00f8fff78625242c514543e53facc6d18f0659ed2882cf54914bc8f52fcb5e268fda2ce57482f1c678748f5eae29c52842d4fac69a7c6010a2e3a62e6b72d42ccb1233f107c1c4f98437a1ff6ad410aea6864c2daddc22f27b2c564dd774cbff12e138b05352c019c648673a7bef71616e1a3f3c350726308f2407eedc1e6d9e73174164c4cb83bab532edf7137c31cc490801e8e5e2012e7e2d704bcb32b90d94fac4d3c8aee9709a69e42431e7543cc71c004bb241326fa8e800af3ffead076d297ab118eee80fbf7c6de2ec04ffaf3ef90886b808798714b4d0309541ca56f5a0e055f7e70170fadb8e0fbd95a8b9db5aec23e02e156b4c013490922387b2ecb5c1189a7dec42aa1182e5a25e02e4ae8a63cbab6f520ddfd5270e62bec2b8d49999d95d5a62f470446e7d6b6683aa123e9ea773420bab5f64230bf992c3a8748fe33b4f553956052032f27289fb3bc2a265127f33da74cff9873d74e7456b64e6e91f5f780adb292ba51e84579f29b9997ef8cca9829ebf89e07b0a725894198c08c82b9e328e0b6f64253f1acaf7a1b09da61160e8e602aa310df2c3930cc803b21727d976b19505f25feaa7d9efc56c56229c8fbd53e76f737a4088aedbfb0ea8fb5829f14189c23b23de447774ca7fab7414f04097b376c8f7337ecea5990f8306395248d34ea810b6713d2f507bd808be1e6a1208af0a2d10a7e60c42adaf98a14ce42f37482ec8428f2989e7edb5c1d30c517911ccb58199c584c1b0ca73a7a1670757a58f813bd0b35ce617eee7dfc7fb2e16004527c91f13fe1ca9945814805022d836a47181a1c855720724539f21a2445947fe5e2bf3f47610b9c8e1c33a9a2de347fcbc6e68bd49108d98d2ce425c8ad547c7ba6b99ea3fda7033924d20c74115553095a1fec7c57ed59b0704437e7ce568a24c6e8afc9f154026feb703255b164970e716e1b685dbb45522265a8c4e5e24c74189b3e74bba9a3aff3dcb78b6b27389aac43e7cfffebd155778667b3d076f0d30675acaf38d78c50f14e803c6a6568e6e4da6cce6d5a46137c4942dbe256766995c8e3137412366c961cbcc0ce933c2db8a4654e1345455bea96a275c4ab0a45da663423274dcb6f33d2ee2990a51e4f90062619d27f0894a5c7cc5dfb3432bece278b5505121c2f243cb85031882893f739be4817c823c34bb0dc96975694c8e55f2cc7add5f8510941614009d0057f9b9b5e2f114b4bfcf985f8d4b9217f4f0330e234c35459238007d7674a9ff71e2b444f0ebf30f30b5fa3370122d920a7cfa6bc060f7f5c339354efcbb4cec93fa780c64e6b433d06004c38e5d1e5ba205a9028d15d9d0180fdc1fbd60a86412a9356ef1fa30d6416f9574f1f6d44dbdfeae542e6ae637db2ec223a9e8c75279c924ec012209f47a099612335d59bc314bbe80c626ca1d2b566d40e7649f38296217d812b99c3f2d5ee40193fd3e8a653b1ca6136f441d220b49b0fc56c8698cc8b01fca79314902cb467a9991d10e2f0e3f7e5e3d01a61ff0d58d46840abeca6e104019bd4c8e2b8d5db58508afd496973b3502e42f94d5d6f84f8b36981a986e78621ef42129ede6ef81d14600d84b254eed90f66aba3b4ae99a8c11b9d93907e52d0ffac39c8f9c4af20e3b520a0f2134fb6cd2da4201075b4c9c106d07e60957b0e6c83125f9cad335f467ac5a8627fd0f78ae9dd4dea3665f23592f1eaa11d410321570a63a56f79470afe1d52a4bbc5e831d057128cf486e94ffbb392b7aa55bc57e2ce788cd687958a022b7e2e33ad90d9e27d0e19889eb990d24d574e517c9199cf4db0975c3ec4ec698a7fedbb4a1952b642cae71731471534b1f69ef25b64c206812e1cc5c78ac493050bc5130da84adcab5d0c06bec889869961ac534d4a39ec9567a69768918f23d1e1e609acb543aebe0e19bc91269abfeca7bf570c347748e85186cf27405c4a742b965497038456ca8b92f4f9e3f39be89fa594a12ee23e79a500b2846120619bc315f1ba22a35b7e95730d2846deefd109aa2447ae1b50d6c7dcc00199b999369c6b0bb85a4a31664842d053bdb271227db18cb64e34d1c37b43989a208c0437812f4ed1fe1d4e97c294e00b7893f52e83be160ca766b9c2b779b1e30a808ab545f9eda8a64bbc377fd3c6b37393bce6f87ef95a65a770d226a3dcbeed2484406dbe304adcb4bad34dfa67959a4cc5277b4afdc115172ec5782de9ab12b8513fe334e7fe8602b9292a11c6ebaeff2ea19886aba98f47a193d1c11ab8cf705ee91d1b5f2fd63dbbcd7ea32075e38dea03bb693cd9b6d2ca23da96e8437daeb905256ff1c530e24e16aaf32382208838f4fea47183c3aae7c0c30e20c286f78112bf0b2dbd24ce9a2787d84f770b4610d74be7730b0db58df9cd4d5ae2c286b8a7800bf494ddc9d33b59649ea02b72869718a61cd35a667130894a3b300d245e2168f68db8f69677b93221fd65299b09ba2440837c0f5220b928447b4cb2269a01f0aa6667806adf955407619e439f6339cd0497100a10747b82959f88192ac35aae88415c1674771c2a03267e430e027083843b988fa31e078aa31527ccbbcd7edd4bf9544d1ae001051b7be302c312e20505162eb2892398f26e712d46cec9e03a1f30f13ec2a8bea77e5f4844922e59664ffdbf6fc6dcebd26d94cdeaea43aef4fafe2f02ea444d9a394a66a2cc717452e9a784acc4cc80cd96e930aaf76939bf004b8bd91f2d0f4fb60d1e54001a449cb359531976691b9e59122e30239e62d046f5222ef7a1182e03defa234b2774345f266c7435975b665fbdd1ffa5c5f43725120110f20298ac3402ac2be1c739361f19245e0bc6383ffefec812ebc1d5c3a15b9d5b191ca5adde2e12c3a23d084df1d72347fd7eb1a25c359379e98784a87eb54b13c25393be4ab533bed13286e6f9e442481e9d91ec75e3c510e8f453b09e51b3c1532a6d82fe88c2dc8686e85bd7726de6b86b4556df3f0653df94b280ccd380d42e710481a1ff9e6edaf6adcc274ad6f1a220f29b2aac6fe7abfed76701077517190eb8abdd0a62652e914c84c8bfe4e522d30ff2d7199e27be42bfe25342d39dd369d8a5fecbf96254d862b3a97908fc13d7cb00588bb5820aecf7ac1b039d6a5c223315291976d20bd5c50bf86f18100fe77761746e7fdaeeaa2d94aa0e3709d1587d1f12c185c27f97417ee3473931ff6eb64d8adc8f4d91dd96bb99db7e98d6b20c972c2ff5d3dcfa0ac769859dfbcc2ed8e62bfd7f4b5660d015468ad7031dcdd1920d0e9ae9b834ac1ae0376492dd34389f6ccc7092a1eb3175e79a4eaf1b7db896de3e5ecbe5e5e6d58f1abb16eff26d65a72a1b03b0aa01b912069e3bd2b55b585c711c748b9c35577e27deb9f3dc5dc6d0c611d94e9eb543afd862744377aeb1546b1d79e860bc16319ae2487285f092c3352857e503653dfe28513fed4e8c8f84a14655dcce23ae014037bb5f3d61ad1601f4a582ff7f0484e609d31e558aa2e62ff2b36b5fe8563265e460ef730475912552994d535a665124555e34e7a3535587edd538bf5a8fe53e81102b689ff9bb5a922b3681ce609b92a351945776bc7a961dfdedac40e810334706805412e901a6d6eaa7566f1d40f14283bf9e732bd0fced29dca2883982b97a65e8108b82c742131079765ff4403366d0dbbaf4da585fbbf1413b26be67c86715fe55674c1e04862305b64dffc2ee05b0e7ecb0e7eb55d6f6bd04750c2599fed2471713476386274b2efaa264697846348d7b0b76613a943e311631e8860ddbd89cf6499d7880bcc9dc79b4bfd31124a699238e447c15ad685fac73f1c810f4c16cdc76926884edd045a44bd2d213683ef94d965e7f8a33b8a10bd6074c73a31a5b2526139ffdf62602c934e9e3ab6fd0064764a1768a066487d94411408fb339288c337ceadfcac0844ff8b91b88704e1a5d7b0bcd818466b88eb39124d4ede717098e158af36a2b6ddf0eff50c4a875699f9fa6f8d3a24480a41a64d9cd2997b378c28ee08811e1e87d8853ac2dd5e2ac9036e821eea8b4f2cd5873386121799d8fac5539cc7892d69aeb0e9c5ec1b9bc0b06e56572a9896300ede760da9625bace001f25e4872a93bf9045deab644217482e86e212323c3a20a141f919a676318a80c87994d123ea286f6868b1a0ad0a9cd36b24e925654e35bc05deb801d7f895374bb0392d169f78e8574a479b35f0d965dd7149035ed8ba7468b2ab7a617ac99cc3650fd24c914e4d3467fa7b09ec2a6fb8cbcd85fff0d7525519546b9f7186aa40203a0a32d25e9c24f5ba6192851f1e87ad59941177cc05c546c10f56860d927a64d48bcbcd5cb14e7b201ba579c0178b0338a0e6168b341cd541ea7ff9e400cbd04a4eb813421ec5b538966e96754607ad5859f96ffc2fb8e41ceda8dce7c6288cfdbbe218bb89039a1ed8b44e4c0636b2beff0a0425e8b8ca35557f3bd39eab6078cff4a4009e6c5b7f585d2f9009c3d674e121f04fc271b08aa35fa23d6c3310fd40b83ed4255ddb5946b71f0b900594c29b10a1c7c8735fcc56bf0bab3ae4a51d519d1efc5adffb6f066a553ebf456ce0a967d27b640466b2fdcbece4df339cf338160b541a965d276fa7edde45e2a9b1d3108c302e372006a3c4c18cef1febc358ac64a4a423804ad35c360756043a491c9ef359d90ebb497e10e0180c81c5d60e32234bbbad86b722732f99039ffcec59956553741d07e03c7f8499e85ec5080f3c59b2de97a763f507e7be5c2c139283a7c1c846118beb6d4fa77afc4401088b5e1694725fa0153cd21233d9952022bbaec4bbeca6f8fb795189a28a2714ad086cee39e336d1c5482825274738085a37277d299c27891112393f45021d4c2e3a35323e2dec970a5643127098baa2a06c59d702e03b08a6ff723f9d03d987ebe0c74973214e717fc3c8579ed6c879ad8c077a8f0a197b49296390c6372989dc8f0168b87bd9c9aa34e0763f5dbb649f6698f82ee826b07f1d7348e77bbd12c801c613100b228aba72483aa352076c9f4b9a70fec2372dc675a38daec0de9e1ab0aea91e8838eca6f1b20584bb16df306819fea1cdfd14f9686e5a72b46f91636b18e62f74ac71652b23e34ce665ebbd202f88825108c0d2797b887dc9fb6d8cfe65cc374b785cfde65759454b0bbb014419efefe5cbab0cef272e99c06c55c96a9b080a59acfc3e722a776080b1aef91112965df28e5cd921beec85259aebb8698b2ca484805f893d8625be97e8bad5db89133081e475c3602f9d7c8f4ee7b6a06ecf488111c184354edd43fcf9e2b4b387dcb3fb20e20e6898b5b99931241cce884d1b1fa324f460b87b7f9552d81e4bb88ff4be277fcebb53ad67b46ee894c73566cda33e95c8424e5cf7a9198354b390b21c172d81c7baef1c44faf34db7f545f38fa0ca2a8cc701529ece62161538aeca3f801c8fb7ec33db8ffd3da9c241ba89e872206e068078fd59009d7142c1fa6504fbd69c04afc5358b0b386ba02ec6dcb9f23f90327474aee442e336e6cf6ba24bbeb9f8197dd4e3755c8833cda8a2b5c58809b358ba97d36ab7596fa4f1dd4dad51b06b11812ff6f26defcefdb48b2becb3be11a6c08aef0b6523009d6d6a0f79d69e2d8187a12599c0ee85cdccfa11f50409821d44b871a01d4b792790b15b20844a3cd7d265465fb0c07ba6d11bfb6fddefb601ab6cc0ad95a694c9c58a58b3960c0acd990dc9946e3235998304459e3d29e322b8ed6718556d7f2d5d35270b1ec23e1c5e149116b4a0c0ed53c94d8f5c46f01c5ff90ba200f960454c2f2e5c31771d152eb43fcc19d01f036a1204065fcf9aa9932c4b6b522150bac9a2b9f89a578a9ba6e5543c081a294abf273c4ee77e18a6ce7732156601d6343d342dc459d26971d27e7b75323b67195bd7d5b9229a1f0dbed6b27b2b09e3b5a4f7bc35db86630a51ca8abd9d0fe1e4a217db4dcea4b9914ea3768c01b32b6d48c8a43597ac443e1419a67373ac0cf64e0c273ba42baf452d4e7eb184c38e82d1d22020217c25fbb7d4fd9de3a8dc24075216172ca8be99f5fe4c6f53dbaafbe8ec7b7f0ac4012a3581cc15533820bcbe974705287bc21b4c412e83da58a371b3f23035564b5e1937f765577ce2b1e3aa42c4d8faf37866e0a1cb4e17548d8a914af2b54c9a38a4a099d2ee3efb76955e16757c515415563f4ce43ef19b38e78a489f16115cf47fd208dc445e412d0d4b21b86c0299adcc716ce672c9fda10bb3a329ffd79ab2fcbbef03879a2207a5e66ef46c193ac1c67ca1ce0adf09490594a45cdcbc4929ca22c63a1ff51f0718e4ea235c24787b4fe2b6228af89e46323889a99e272c0c6494b0feabe571afbe7d184156ec8cbf5695d2708c019121915abd3042bc8497bebe3705b901eb37e1e725ee581b15372013a9dc90e2c8a15d4f8b6a732548f6a2e46a93815bb9f7bf0805680de7e43cab2cdfedbd831e445cd815cb650b7d20adf8fa46e8f6344952845fbf6bd50092a4ff753e334735d69f3d900277987915656488209483d0d6d8e01135b67de6ff8a40015f86051fdadab59b797e074faaff749aa9b2dd50b5a6dc6611c87407ae92abef5b5a00262a47f99b244159b0dda2570208e2ecfe3d3bbdc0498dfe5523e7536853200a47d114655f4452c2a461fc52a0117c1dec6107d38a2c5016aa3b857f02bd1b14db3a76913d4856f67adfba44d6ddeddcc6e5b3338e06447c978b1615f1b81e7627b69d286349d1b00edef19c18ca208d6f0c01ed55c3b45e3a94c44bfe9678d969409541b02b44dd88beec72a6bdbe1ca3924bc57a743ae7117dc071f5cce88dcbf43ef16de5d1a0eed259cf7eb66843d1c1cb399d3f0d5daf5439ad0194a36f8112e7c7202dc634cbea9a3667f95cf197feaa9d6eaf5c47f0f9539db38962c677f78b8f6947dcf8768716cc0af03e9d8484572fb33017e007e45b099f764bb3451ffa333c90076f72ec2404d826193460d48533bc6ef4fd4f5df32e455dcba5aaf7dc596fe768e98819670f90caa62eda51be072f41852a3e7abe8d0a3fd1a263344d4f4b81056f710d55cf744d21a8d3f4142c0d6d826ec238a531e4d2fa730c2a72d7455747d92ed7391cb45901c5bdb0046d476aebe225b5ac2ebabfa5252220a88d76ef2894ea77f751362f33d16739963d7e2aceee4592e9c2c2dbef4271477507c989e8a5f1df1529aa4c0d7f2a6af54e777c016f39dac85a2d3cbffff505bdf364a8dabad2be4b619db9a6ee8ce443c44a95d9aa3923d1551a484e099aa0dae266269290965c10ba3fd630be0ff440d6bd3e14a3f952f18f2e48dc009a083d3490fc7557843d5b6b194e5a56fdd3940fe6f9ca94197668041004886aae12f77c17d5f8afba1b1cfeaf6eb3251cd4a36d6b905462f40ee74291a3aa5a982d008d9d7c252c42649a3161164de1dbf8a41b9f0f0d522a692066f3530e684f9a57c569f709e27f5069e27fa6b0b039fe493971ff43d0aa8bbd552ab67bbe0ed14bdcb389ade6116997c4b3c27aed617b9e04891b646d131a4ba3c4c7dcb63afb854a014d455b95a5254c78ce0b06a3cb75723a84c98f8465204314545abbfa5e6b2b4107951cbca63809d4f8efc033020b3a063e203482c617aa963bd5e1ae43c5f9cd421c702a0f7f5326dd9e1a9abb2988cb124b49d2891ec31b86a372d95978406e1bc41585677ae4c9bb6c49f456fdc2705027ef0d3e3afcb1ac8f486936e2002b275f7a909b3b22d8a31f8540f8522ee3d8c2bb125d5e2b773be559507e0b686808181bc3efc37d4e40eb2fdd06f1c8360f85bd6a524b3edfb22c2a36aa2f4898abb4c1ff9199191cdc82281fdebe0f34422b58965371dfd8cc2360919ff842d75c257669378e5a38588b3628877fcaf96fb889c6c04ec954722a205f0c842fd2584fb9327904f38dc4919c5fc338a62e56f8e4edd14e7aff35b779b07002a089f00d247d8b3500a0000ae18a0bb7c510c863c82fb48dcc4ccafb51d0d5099498ca579436d92295dcd9cf43669e48ff1b34975d503626c0c78868b9d1932cd01cebac05309a8e2578e5773e86249dc5bd79cf3106bc7f005b7685e76add8cca00e9f053a5a0f00c682454fe8c60ba1d7e0c5826d80c046f7ffca05eace685efb50c7e260bbebdbfa9e020ffdbc7af930189a2a9aa13349182f59f1a875d96e346cac7e409afa993b116177ad357012b63d6c64feb194055c955cbfb9b6955ea19108d8481f6e879348c27fb778f7e42d4fc27106626e88e9b50243585d2ec5c80b2af66e03bb7a443426c5dc84117f68b8f301eb4f96820beaf864010507d5776d9bc2a1223fd3f9b00d64cd76161de18f776949f5b6c6461c487d34db5b29eb8db11da1bcd40c9814a51ca9ac3b7c45e4b0358ad3e7178b07f5b02a7048c9318801b7e36d764739c85a611d728653c016956fb84c2314756c0e1ecdc440b775bb37a6e0d20b98dca7b8a2204b3ef9970578875b318441c8addf38859a6640e1418f0e339b6297fc66076fedb1e941d9a71165af1efb3c941ae45fb23d783be81eac1e4c2622efe41becf3304c1ee192b5755b80ad9437a43f8ae946d5e90e24c440213c35b79518959a832da69e65efeefadfa5a0d4462baf58945ea7983d87784bc025433284202b1a7622157b323f7427c1599062648e28a83c4f1ff5697a2a3096a4b87bf56b186de201e91433a1b7a720fc78894ba6c1da892c8e691a8b0b5677cc702a4b4138c2c0c9488d41018285cb7525b309c8ba186bfa11c364fc895710f5cba1a2751da2fe992fe9031a219d555e658e1a727d6cdaa8e35266588dff37439591c1757d92623f0b51bc6da0e72445e9e082d1bfbf79e51ce0b8ff1735a5aa2d01a70c69decd1061704290883510073414857e15d14d06275298fb2c8d22a342ffaf0e640a9a9ac81710fafb94ece5df196b75efab86d8aa1adfed046c02012e59822dfb9e9764c6185f043bbacc509fb1301ea72734e48009a2b5444e92e00ff27ad464ff934786ca42f282c1a892193d550478f45d60747bea1084251648c9bd25d8194ebec9bcfb50896dab10cfca82b50f28c21f2e80b1247f4e5bcc0b29fe02e56e7f29e09980cfe00b0c1912e346907f149720c9e1fa6f94ee8854c12f977fbed3fdb70448abf01010701fcba2c12b2c17ab03fde46a915fcd487d41dd23a7b5eae7f293bbbd95c797a6d3269ab2e91b533a422f236b587f7ab08bde0bd7f8b9a4633f397681e9064915db6061c1a3de25e04236bb7f92821420357f5e5989558dceaabe5cc2b08c616bcd877703dbc83702e6cac5c990c995500efe3dca5e607860b1b58569fb2a37de7a038a66d550da864e4bf5633a7133457e796a7a9cd6d2e032f8d848e911ff34f760790b3495af505b5dc0453e596a6962cbbabe41665ed7a6ef871a9db3c8e38d824d22e9357653d1026f85b2b1b249f48d034a453f4e942831f70262320b6890dc97388883a58e97542d81b10b1851abf40831fbac0125966beb6de747b92ac29e5ef4e81cf76f5c748082f6405a8b8b352e7ec02ebf42c703315fc8a93adc64d6d4d7513bfeb9ed904f2030c05dcd0e8cf22b63e8f39293458242d226f6dde24df15e804423cf2cb62343fffe06fd5c409851f8190ac5c93b05f68e730e8999d505ee11f49c19fca522e560842ec7ea1dec5fa875a467d104b9028d60ce1e24acd7469b4714cb1cb024ecd299ff22fd7c487c07a602016f60be273b2a81ea4f39291e0168b715d94790cb165eba00dd59aa00df6a709de5e58d683939c2b7d648e60969f047ef47b65d985c92e7357369f5f2626394c77a84ea173775a89a4690070db539026b957ba2924d7b0965a2010324eb95c824e163980c28d2cad07302593a5e3b42df8f4236a08307e39ab0ba387e88f83cb44fcf436c70cbc6470635b532bd20e10861823a3309f820cc360b66f266b76efada5926187ba420812e0d9b721653f0dc53225772bea8db4c714f4013dba9c81658c00d7516598b403c7a68d82832b751ed74aa9fc6e4225b9708289dab5d2c392c5c592989c7b60f6cbddd9f84665e8ead9cce7f58c92989aa41ac9f221d9797afc6321acaf426eab9362c41270ab079604fa7f48ff3c035c7691220aac8d5d072d1b9897496d24d2ef084cb9f34a438b6b4e2c3d70e92a9d0d7abd083794fa251062307b69796c306da7f25b7d64029034dcb07da7e0004e9655baea27b3941bb34abe0992e2f7ab96409a6b8b47b32c95dd9e24124e8808dba0116301cd10e709e8bd498e158214b4b95e96cfdecaa1ec3d2e91550c92a7d5d3244d23560695893f1e42d59a54b56bf2c5876d41a22d58e75a7c3ee7dc82b5d31fd75f4f9931284f860c9f183ce477b9e585ccee2914bd5ef3233b9441c4981bccc5d338cbbe4de90b23190850f833d275364951ecb02400d13996caba3c1117683cbbe162c53f173d3a4b0f77f037ae9f343662508fc4784b3cf0f0080b58ee3f1e41d815a920a6a9b7ec2af2376b8038c94361dc03888dfeccb09ef05c49fc6125f377e8d8691c12a7b0b7596024fb758a7c2ff5415e56a0010a4d602bd10761f030a9e5a6b34cde4e99ef6595dececf8047defe67dc33684a517f8f94d784dfa7d7010c5c087891a665cf14f75bd27a0d46bda8976770f83eb8b3186c626dcbfcd42208d530e8f23b2900dfc4fb1b8866f4e5398de5a11f7374647582021d995c73f099f711499639fcefb9211f4e63000f8b438d968b854f6dca8575cbde1582a4f50f0665e944421a6318c0bf7296b1ab0be1a714580459e7fa34b0a3238f447af70718fb0678318a3405a1588257be20373c176b776a5a139e1fd2198990fd1d6687ee6b26d6cfaba98d989988273c465376d1ba96d3d617b12816ebe9d8e2f15f3c6488c6c3a5aa58dafd699f8a2043c50f059351982cecd53e61d72e848d258811cf66600f959cc1e89e5cf00d881de52602147859ec973b13a7dcddf0cdb733e90eb2ae3526ac295aa8b0d642fbdad72b27e69135a1241c6735398c51f51dc0e7f0ebcb698c541c64e053f25eee4e48056a715710b3b8d6b5ca0f542e691014eeaa301d50898e54346d7e615f14fcfe419ae5718620bf0e579d7473e8722a1941c9bf0c66b1c725d23e29030584e37bd30d017fe7bf559ced5ca6bfcecef82c6c59fc0d93161b0468dc6df70f63631e876f81f8bb66f9fa4a831d424242c5fe380f026fbd76bf5c1082bb5ce9076f1c17c54953b6f34c7a20b79f4c2cdeebd6685849be51a9457876fdfffda41faf7c54459758e60e226ff0c989e3c617283bc4169de148821cfa263cb396e30587784c043a679b329fe71f0ea69394d1ef13276d3ec48d9e7cba30d4a32cdfc0695c29ae05a8a19e80f9825261b11298bc81ccbdf0f856454f9cd5958640f3f0b1bff2c55979a7fc71abc6ab99a727ec8048d426a14923f4c4f619cce3babe3338836939ee1a67be480e90d4ef98325f964724b7161e08ebad54fae73deb8a09e003a5ab21fbb1a36969ab7e36ef27dfc7644c12ea230c501ae7ad65730534dbabb8004cc12c5cfa91ba74e580437a2929baebb753c1ce336e5ddcc543c78becb04b487a07fc028a99b2d3daf77ffaf4e14cd1e9ca5a1a5ce6f2c5e1e3e156559a5a01caf1758621db6ef00e0f8a62daae0a84938fb27ed304464cd41cb9e518dba15bbffdb1efe04e502020c7e3d1be07f4b48e6fef387f4220dace99e06d430523ef7af75b734bc9e7610a40968d7ed73a02578bf21bb830      </script>      <div class="hbe hbe-content">        <div class="hbe hbe-input hbe-input-default">          <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">          <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">            <span class="hbe hbe-input-label-content hbe-input-label-content-default" data-content="联系站长以查看密码">联系站长以查看密码</span>          </label>        </div>        <button class="hbe hbe-confirm"></button>      </div>    </div>    ]]></content>
    
    
    <summary type="html">联系站长以查看密码</summary>
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-07-杂谈-复杂异构系统监控与可视化项目设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/51477.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/51477.html</id>
    <published>2025-12-07T13:09:33.000Z</published>
    <updated>2025-12-27T18:41:58.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复杂异构系统监控与可视化项目设计"><a href="#复杂异构系统监控与可视化项目设计" class="headerlink" title="复杂异构系统监控与可视化项目设计"></a><strong>复杂异构系统监控与可视化</strong>项目设计</h2><h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><p>现在需要设计一个系统，使用 py 的 fastapi 作为后端</p><p>目前有一个使用 Docker Compose 编排的复杂容器化环境，基于 SeedEmu（SEED Internet Emulator）框架构建。该框架专用于模拟大规模互联网基础设施，常用于网络安全研究、教育和实验，特别是区块链网络的安全性测试。<br>此 docker-compose.yml 定义了一个模拟的互联网环境，其中部署了一个完整的 Ethereum Proof-of-Stake (PoS) 区块链网络，分布在多个自治系统（Autonomous Systems, AS）中，并通过互联网交换点（Internet Exchange Points, IXP）和路由器实现互联。该环境的主要目的是模拟真实互联网拓扑下的区块链网络行为，支持研究区块链在复杂网络环境下的安全性、性能、攻击与防御（如 Eclipse 攻击、分区攻击、路由攻击等），并提供可视化监控、数据采集和分析工具。</p><p>主要组件与功能有：数据库与辅助服务，包括用于存储区块链监控数据的 postgresql（数据库名为 ethereum_monitor），作为缓存或消息队列的 redis，以及用于存储和分析网络拓扑、区块链节点关系等复杂关系数据的图数据库 neo4j。</p><p>Ethereum 区块链网络在 AS 101–112（共 12 个自治系统）中部署了大量 Ethereum PoS 节点。每个 AS 内部包含 3 个本地网络（inet0、inet1、inet2），每个网络内有 3 个 Ethereum 节点（共 9 个节点/AS）。总计约 108 个 Ethereum validator/miner 节点（节点 ID 从 2 到 108），加上一个 BootNode 和 BeaconSetup 节点。所有节点运行在自定义的链上（chain_id: 1337, chain_name: posCurrentEnhancedNet）。部分节点（如 AS101 的 host0）暴露了 JSON-RPC (8545)、WebSocket (8546) 和 Web 界面 (8000) 端口，便于外部交互。</p><p>网络路由基础设施基于 SeedEmu，AS 2 作为一个骨干/中转 AS，包含四个边界路由器（r51–r54），通过点对点链路（net_2_net_51_52 等）连接。IXP（互联网交换点）包括四个全球 IXP（ix51–ix54），每个有 Route Server（路由服务器），用于多边对等互联。AS 21–24 作为 IXP 的参与者（peering AS），每个连接一个 IXP。AS 101–112 每个 AS 有一个边界路由器连接到对应的 IXP（例如 AS101 连接 ix51），实现与外部互联网的连通。所有路由器运行真实路由协议（如 BGP），支持模拟路由攻击、劫持等。</p><p>可视化与监控工具包括运行 SeedEmu 的互联网拓扑可视化界面的 seedemu-internet-client，映射端口 8080，提供整个网络拓扑的图形化视图，以及运行 Ethereum 网络专用可视化界面的 seedemu-ether-client，映射端口 5000，用于查看区块链节点状态、同步情况、交易等。eth_node_cleaner 是自定义服务，暴露端口 8888，可能用于中央数据收集、节点状态清理或监控指标聚合，连接 PostgreSQL、Redis 和 Neo4j。</p><p>其他特性包括大量自定义网络（local 和 global 类型），精确分配 IP 地址段，节点标签丰富（org.seedsecuritylabs.seedemu.meta.*），便于 SeedEmu 工具识别和渲染，部分服务使用 privileged 模式和 cap_add: ALL，以支持模拟路由所需的网络权限。</p><p>现在需要实现一系列功能，提供基于 FastAPI 框架的 RESTful API 路由模块（topology_router），专用于提供区块链仿真环境（特别是结合 SeedEmu 和 Ethereum PoS 网络）的完整拓扑数据访问接口如下：GET /overview 获取整个仿真环境的拓扑概览信息（如节点总数、层级结构等）；GET /statistics 获取拓扑统计数据（如节点、链路数量等汇总指标）；GET /health 检查拓扑服务的健康状态，返回组件运行状况。</p><p>GET /ethereum 获取完整的以太坊网络拓扑数据（节点与 P2P 连接）；GET /ethereum/nodes 获取所有以太坊节点列表，支持按层级过滤（execution 或 consensus）；GET /ethereum/nodes/{node_id}获取指定以太坊节点（执行层或共识层）的详细信息；GET /ethereum/validators/{validator_id}根据验证者公钥获取单个验证者节点的详细状态和信息。</p><p>GET /physical 获取纯物理拓扑结构（不包含容器运行时监控数据）；GET /physical/devices 获取物理设备列表（路由器、主机等），支持按设备类型过滤；GET /physical/links 获取物理链路（网络连接）列表，支持按连接类型过滤；GET /physical/networks 获取所有物理网络的配置信息（网络 ID、名称、子网、网关等）。</p><p>GET /contract 获取智能合约相关的拓扑视图（合约部署、调用关系等）；GET /contract/statistics 获取合约层面的统计信息（如合约数量、调用频率等）。</p><p>GET /transaction 获取交易拓扑数据，支持通过时间范围（start_time 和 end_time）过滤；GET /transaction/statistics 获取交易层面的统计信息；GET /transaction/address/{address}/analysis 分析特定以太坊地址的资金/交易流向（流入流出关系图）。</p><p>GET /layer/{layer}根据指定拓扑层（枚举值，如 ethereum、physical 等）获取对应层级的完整拓扑数据；POST /combined 支持组合多个拓扑层（如以太坊层+物理层）生成统一的拓扑视图，可指定渲染格式。</p><p>POST /render 接收任意拓扑数据和渲染请求（格式如 cytoscape、graphviz 等），返回经过布局算法处理的可直接用于前端可视化的数据。</p><p>GET /nodes/{node_id}获取任意节点（跨层级）的详细信息，支持指定层级；GET /analysis/{layer}对指定层级进行网络分析（如连通性、中心性、社区检测等指标）。</p><p>POST /cache/clear 清空服务内部所有缓存（用于强制刷新数据）；GET /debug/info 获取详细的调试信息，包括服务组件状态、各处理器缓存大小、支持的层级与渲染格式等，便于开发与运维排查。</p><hr><h2 id="针对该环境和需求的系统设计方案"><a href="#针对该环境和需求的系统设计方案" class="headerlink" title="针对该环境和需求的系统设计方案"></a>针对该环境和需求的<strong>系统设计方案</strong></h2><p>需要设计一个 FastAPI 后端，它充当一个”中间层（Middleware）”或”聚合层（Aggregator）”，将底层分散的基础设施（Docker）、网络拓扑（SeedEmu/Neo4j）和应用状态（Ethereum/PostgreSQL）整合成统一的 API 暴露给前端</p><h3 id="1-系统架构概览"><a href="#1-系统架构概览" class="headerlink" title="1. 系统架构概览"></a>1. 系统架构概览</h3><p>由于涉及 140+ 容器和多种数据源，系统的核心挑战在于数据聚合和性能优化。建议采用分层架构，包括前端/可视化大屏与 FastAPI 网关的交互，以及 FastAPI 后端应用内的 Redis 缓存层、业务逻辑层 TopologyService，和各种适配器（Docker Adapter、Neo4j Adapter、Ethereum Adapter Web3.py、DB Adapter SQLAlchemy）的协作，最终与基础设施 Docker Compose 中的 Docker Socket、Neo4j 图数据库、JSON-RPC AS101 Host0 和 PostgreSQL ethereum_monitor 进行交互。</p><h3 id="2-核心模块设计"><a href="#2-核心模块设计" class="headerlink" title="2. 核心模块设计"></a>2. 核心模块设计</h3><p>我们需要将代码组织为清晰的模块，以应对你列出的 9 大类接口。</p><h4 id="2-1-数据模型层-Models-Schemas"><a href="#2-1-数据模型层-Models-Schemas" class="headerlink" title="2.1 数据模型层 (Models/Schemas)"></a>2.1 数据模型层 (Models/Schemas)</h4><p>使用 Pydantic 定义统一的拓扑数据结构，这是所有接口返回的基础。网络拓扑系统采用了分层架构设计，主要包括以下几个层级：API 层 - topology_api.py 提供 RESTful 接口，服务层 - topology_service.py 协调各种拓扑功能，数据层 - real_topology_service.py 处理真实数据获取，专门处理器层 - 处理合约、交易等特定类型的拓扑，管理与渲染层 - 负责生命周期管理和数据渲染。</p><p>用户通过 API 请求拓扑数据（如 /topology/ethereum），API 调用 TopologyService 的 get_ethereum_topology() 方法，TopologyService 委托给 _real_data_service（即 RealTopologyService），RealTopologyService 从 Neo4j 数据库获取真实的以太坊 P2P 网络拓扑数据，数据经过处理和格式化后返回给用户。</p><p>对于以太坊拓扑，从 Neo4j 数据库查询执行层和共识层节点及其连接关系，查询验证者节点并与共识节点关联，将原始数据转换为前端友好的拓扑格式，通过 Docker 客户端获取容器信息，建立 IP 地址与容器名称的映射。对于物理拓扑，通过 Docker 客户端获取所有容器的详细信息，根据容器名称识别设备类型（路由器、主机等），根据容器连接的网络建立设备间连接关系，使用共享网络原则确定设备连接。</p><p>在 topology_interfaces.py 中定义了核心抽象类：TopologyNode 作为拓扑节点基类，包含 id（节点唯一标识）、name（节点名称）、node_type（节点类型，执行层、共识层、验证者等）、ip_address（IP 地址）、layer（所属层级）、status（状态）、metadata（元数据）等属性；TopologyLink 作为拓扑连接基类，包含 source（源节点 ID）、target（目标节点 ID）、link_type（连接类型）、layer（所属层级）、direction（连接方向）、metadata（元数据）等属性。</p><p>不同类型的拓扑节点包括以太坊节点（执行层节点、共识层节点、验证者节点）和物理节点（路由器、主机、交换机）。拓扑数据最终以 nodes（节点列表，每个节点包含 id、name、type、ip_address、status 等属性）、links（连接列表，每个连接包含 source、target、type 等属性）、元数据（时间戳、数据源、统计信息等）的格式组织。</p><p>这是与底层交互的关键。InfrastructureAdapter (Docker &amp; SeedEmu) 作用是获取物理拓扑，实现方式是使用 docker Python 库读取容器列表，解析 com.docker.compose.service 和 org.seedsecuritylabs.seedemu.meta.<em> 标签来识别节点角色（AS、路由器、主机）；对应接口是 /physical/</em>。</p><p>GraphDBAdapter (Neo4j) 作用是获取网络静态拓扑和关联关系，实现方式是使用 neo4j Python 驱动，SeedEmu 通常会将生成的拓扑导入 Neo4j，查询 Cypher 语句来获取节点间的连接；对应接口是 /overview, /analysis/{layer}。</p><p>BlockchainAdapter (Web3.py &amp; Postgres) 作用是获取链上实时状态，实现方式是使用 web3.py (AsyncHTTPProvider) 连接开放 RPC 端口的节点（如 AS101 的 8545）获取 Block Height, Peer Count，以及连接 PostgreSQL (ethereum<em>monitor) 查询交易历史、合约调用统计；对应接口是 /ethereum/</em>, /contract/_, /transaction/*。</p><h4 id="2-3-业务服务层-Services"><a href="#2-3-业务服务层-Services" class="headerlink" title="2.3 业务服务层 (Services)"></a>2.3 业务服务层 (Services)</h4><p>这是实现 RealTopologyService 的地方，负责组装数据。TopologyService 能够根据请求的 layer (physical, ethereum) 调用不同的 Adapter，实现 /combined 接口，将 Docker 的运行状态（Up/Down）注入到 Neo4j 查出的静态拓扑中，并将 Ethereum 节点的逻辑 ID（Validator ID）映射到物理容器 IP。非常重要的是使用 Redis 缓存完整的拓扑 JSON，并设置后台定时任务（FastAPI lifespan 或 APScheduler）每 5-10 秒刷新一次缓存。</p><p>AnalysisService 将拓扑数据加载到 Python 的 networkx 库中，计算中心性（Centrality）、最短路径（用于分析攻击传播）、社区发现等算法；对应接口是 /analysis/*。</p><h3 id="3-具体接口实现策略"><a href="#3-具体接口实现策略" class="headerlink" title="3. 具体接口实现策略"></a>3. 具体接口实现策略</h3><p>针对你提供的文档，以下是具体实现建议：</p><p>物理层 (Physical Layer) 的挑战是如何知道哪个容器连接哪个。方案是 SeedEmu 通常会在生成容器时将连接信息写入 Neo4j 或生成的 metadata 文件。优先从 Neo4j 读取链路关系，从 Docker API 读取节点存活状态（Status: Running/Exited）。</p><p>以太坊层 (Ethereum Layer) 的挑战是 108 个节点，如何获取所有节点状态。方案是使用信标链数据 (Consensus)，连接 Beacon Node API (如果环境中有) 获取验证者状态 (Active/Slashed)；使用 P2P 拓扑，使用 admin_peers RPC 方法（需要节点开启该 API）查询节点的连接对象。由于无法轮询所有 108 个节点，可以只轮询几个关键 Bootnode 和 AS 网关节点，构建局部图；使用 Postgres 补充，从数据库中读取已知的节点列表和 Validator ID 映射。</p><p>交易与合约 (Transaction &amp; Contract) 的挑战是实时分析交易流向。方案是不要直接扫描链，而是利用环境中的 postgresql (ethereum_monitor)。SeedEmu 的监控器应该已经将区块和交易写入库中。接口 /transaction/address/{address}/analysis 直接执行 SQL 聚合查询（Group by to/from），返回资金流向图。</p><p>可视化渲染 (Rendering) 的接口是 POST /render，逻辑是前端可能只需传递原始数据，后端使用 networkx 计算布局（如 ForceAtlas2 或层级布局），计算出每个节点的 (x, y) 坐标，返回给前端直接绘制。这能减轻前端浏览器处理 140+ 节点布局的压力。</p><h3 id="4-代码结构示例"><a href="#4-代码结构示例" class="headerlink" title="4. 代码结构示例"></a>4. 代码结构示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/topology.py</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">from</span> app.schemas.topology <span class="hljs-keyword">import</span> TopologyGraph<br><br>router = APIRouter(prefix=<span class="hljs-string">"/topology"</span>, tags=[<span class="hljs-string">"Topology"</span>])<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/overview"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_overview</span>(<span class="hljs-params">service: TopologyService = Depends(<span class="hljs-params">get_topology_service</span>)</span>):<br>    <span class="hljs-comment"># 从缓存获取，如果无则计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.get_system_overview()<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/ethereum/nodes/{node_id}"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eth_node_detail</span>(<span class="hljs-params">node_id: <span class="hljs-built_in">str</span>, service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 1. 查 Neo4j 获取节点基础信息</span><br>    <span class="hljs-comment"># 2. 查 Docker 确认容器是否在线</span><br>    <span class="hljs-comment"># 3. 查 Web3/DB 获取链上余额和状态</span><br>    data = <span class="hljs-keyword">await</span> service.get_node_composite_info(node_id, layer=<span class="hljs-string">"ethereum"</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"Node not found"</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">"/combined"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_combined_view</span>(<span class="hljs-params">layers: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 融合物理层和区块链层</span><br>    <span class="hljs-comment"># 例如：展示 区块链P2P连线 覆盖在 物理AS拓扑 上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.generate_combined_topology(layers)<br></code></pre></td></tr></table></figure><h3 id="5-关键技术难点与解决方案"><a href="#5-关键技术难点与解决方案" class="headerlink" title="5. 关键技术难点与解决方案"></a>5. 关键技术难点与解决方案</h3><p>Docker 网络访问方面，FastAPI 容器需要挂载 /var/run/docker.sock 才能查询兄弟容器的状态。docker-compose.yml 配置中需要添加 volumes: - /var/run/docker.sock:/var/run/docker.sock。</p><p>跨容器数据库连接方面，连接 Neo4j 和 Postgres 时，Host 应使用 Docker Compose 服务名（如 neo4j, postgresql），而不是 localhost。</p><p>性能瓶颈方面，问题在于/ethereum 接口如果实时调用 100+ 次 RPC 会超时。解决方法是使用”后台采集 + 前端读取”模式，编写一个后台 Task (使用 asyncio 或 Celery) 每 10 秒扫描一次网络状态存入 Redis。API 接口只读 Redis。</p><p>IP 地址管理方面，SeedEmu 的自定义网络（inet0, net_2_net_51_52）非常复杂。在返回 /physical 拓扑时，务必解析 Docker inspect 结果中的 NetworkSettings，将特定网段 IP 映射给前端，否则前端无法理解路由关系。</p><h3 id="6-总结建议"><a href="#6-总结建议" class="headerlink" title="6. 总结建议"></a>6. 总结建议</h3><p>设计这个系统时，请遵循以下步骤：首先打通 Neo4j，它是拓扑的真理来源（Source of Truth），确保能查询出 AS、Router 和 Host 的关系；其次实现缓存机制，复杂的 Docker 集群状态获取很慢，不要让 API 直接穿透到 Docker Daemon；定义清晰的 ID 映射，最大的坑在于关联 “Docker Container Name” (e.g., as101_host0) 和 “Ethereum Node ID” (e.g., Validator-3)，需要在服务启动时建立这个映射表；按层开发，先做 Physical（最简单，只读 Docker），再做 Ethereum（读 DB），最后做高级的 Contract/Transaction 分析。</p><p>实现”实时更新”并”高亮变化”的核心在于结合 FastAPI 的 WebSocket 推送机制与 D3.js 的 General Update Pattern（通用更新模式）。这里有三个关键点：后端推送，只推送最新的全量/增量状态；前端数据绑定，D3 必须通过 Key Function 识别哪些是新节点、哪些是旧节点，而不是每次清空画布重绘；视觉反馈，利用 CSS 动画或 D3 Transition 让变化的节点产生”闪烁”或”颜色渐变”。</p><h3 id="1-整体架构设计"><a href="#1-整体架构设计" class="headerlink" title="1. 整体架构设计"></a>1. 整体架构设计</h3><p>后端 (FastAPI) 运行一个后台任务（Background Task），每隔几秒扫描一次 Docker/Ethereum 状态，通过 WebSocket 广播给前端；前端 (D3.js) 维护一个长连接，收到数据后，执行 updateGraph(newData)。</p><h3 id="2-后端：FastAPI-WebSocket-实现"><a href="#2-后端：FastAPI-WebSocket-实现" class="headerlink" title="2. 后端：FastAPI WebSocket 实现"></a>2. 后端：FastAPI WebSocket 实现</h3><p>我们需要一个 ConnectionManager 来管理前端连接，并推送拓扑数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/ws_topology.py</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, WebSocket, WebSocketDisconnect<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><br>router = APIRouter()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections: <span class="hljs-built_in">list</span>[WebSocket] = []<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-keyword">await</span> websocket.accept()<br>        <span class="hljs-variable language_">self</span>.active_connections.append(websocket)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections.remove(websocket)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">self, message: <span class="hljs-built_in">dict</span></span>):<br>        <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.active_connections:<br>            <span class="hljs-keyword">await</span> connection.send_json(message)<br><br>manager = ConnectionManager()<br><br><span class="hljs-comment"># 模拟后台数据推送任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">topology_broadcaster</span>(<span class="hljs-params">service: TopologyService</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    这个函数需要在 main.py 的 @app.on_event("startup") 中启动</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 获取最新拓扑（包含 Docker 状态 + Geth 连接）</span><br>        topology_data = <span class="hljs-keyword">await</span> service.get_full_topology_snapshot()<br><br>        <span class="hljs-comment"># 广播数据</span><br>        <span class="hljs-keyword">if</span> manager.active_connections:<br>            <span class="hljs-keyword">await</span> manager.broadcast(topology_data)<br><br>        <span class="hljs-comment"># 每 5 秒推送一次，避免前端渲染压力过大</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-meta">@router.websocket(<span class="hljs-params"><span class="hljs-string">"/ws/topology"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">websocket_endpoint</span>(<span class="hljs-params">websocket: WebSocket</span>):<br>    <span class="hljs-keyword">await</span> manager.connect(websocket)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 保持连接活跃，也可以接收前端的控制指令（比如点击了某个节点）</span><br>            data = <span class="hljs-keyword">await</span> websocket.receive_text()<br>    <span class="hljs-keyword">except</span> WebSocketDisconnect:<br>        manager.disconnect(websocket)<br></code></pre></td></tr></table></figure><h3 id="3-前端：D3-js-实时更新与高亮逻辑"><a href="#3-前端：D3-js-实时更新与高亮逻辑" class="headerlink" title="3. 前端：D3.js 实时更新与高亮逻辑"></a>3. 前端：D3.js 实时更新与高亮逻辑</h3><p>这是最关键的部分。不要清空 SVG！使用 D3 的 Enter (新增), Update (更新), Exit (删除) 模式。</p><p>核心策略包括 ID 绑定，告诉 D3 如何通过 ID（如 enode_id 或 container_name）区分节点，而不是数组索引；平滑模拟，数据更新时，不要将 alpha 重置为 1（会导致整个图剧烈爆炸），而是重置为 0.3 左右（轻微调整）；样式 Diff，比对新旧数据，如果状态变化（如 IP 变了，Peer 数变了），添加 CSS 类名触发动画。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;a href=&quot;#复杂异构系统监控与可视化项目设计&quot; class=&quot;headerlink&quot; title=&quot;复杂异构系统监控与可视化项目设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;复杂异构系统监控与可视化&lt;/strong&gt;项目设计&lt;/h2&gt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-06-杂记-前端图拓扑渲染优化</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/7900.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/7900.html</id>
    <published>2025-12-06T03:25:47.000Z</published>
    <updated>2025-12-14T17:56:13.795Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>性能优化 (Web Workers)</strong>: 目前的数据获取、解析和Diff算法都在<strong>主线程</strong>运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 <strong>Web Worker</strong>。</p></li><li><p><strong>D3 渲染优化</strong>: 目前的设计倾向于每次更新都全量替换 filteredNodes，这会导致 D3 力导向图重新初始化或位置抖动。应该利用 Diff 结果进行<strong>增量渲染 (Enter/Update/Exit)</strong>。</p></li><li><p><strong>状态管理解耦</strong>: useTopologyData 承担了太多职责（数据存储、UI状态、标签逻辑）。应该拆分为“数据层”和“视觉层”。</p></li><li><p><strong>数据结构优化</strong>: 数组查找（.find）效率低，应更多使用 Map/Set 索引。</p></li></ol><h3 id="优化后文件结构"><a href="#优化后文件结构" class="headerlink" title="优化后文件结构"></a>优化后文件结构</h3><p>采用了 <strong>Core (数据核心) + Visual (视觉逻辑) + Worker (后台计算)</strong> 的分层结构。</p><p>codeText</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span>/<br>  ├── types/<br>  │   └── topology<span class="hljs-selector-class">.ts</span>           <span class="hljs-comment">// (保持不变) 类型定义</span><br>  ├── workers/<br>  │   └── topology<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [新] 负责Fetch、解析数据、计算Diff</span><br>  ├── composables/<br>  │   ├── useTopologyCore<span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [优化] 负责与Worker通信，持有原始数据</span><br>  │   ├── useTopologyVisual<span class="hljs-selector-class">.ts</span>  <span class="hljs-comment">// [拆分] 负责过滤、标签、高亮等UI逻辑</span><br>  │   └── useD3Renderer<span class="hljs-selector-class">.ts</span>      <span class="hljs-comment">// [新] 封装D3的具体操作，接受Diff指令</span><br>  └── components/<br>      └── EthereumTopology<span class="hljs-selector-class">.vue</span>  <span class="hljs-comment">// [优化] 变得很薄，只负责组装</span><br></code></pre></td></tr></table></figure><p>现在的以太坊拓扑渲染架构采用了 <strong>“分层响应式架构” (Layered Reactive Architecture)</strong>，结合了 <strong>Web Worker 多线程计算</strong> 和 <strong>D3 增量渲染</strong> 技术。</p><p>这是一种高性能、低耦合的现代前端架构，专门为了处理大量节点（数千级）的实时动态拓扑而设计。</p><p>以下是该架构的详细层级解析：</p><h3 id="1-架构总览图"><a href="#1-架构总览图" class="headerlink" title="1. 架构总览图"></a>1. 架构总览图</h3><p>数据流向是单向的，状态管理是响应式的：</p><p>codeMermaid</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">graph TD<br>    BackEnd[FastAPI 后端] --&gt;|<span class="hljs-type">JSON</span> Stream| <span class="hljs-type">Worker</span>[Web Worker (后台线程)]<br>    <br>    subgraph <span class="hljs-string">"Main Thread (主线程)"</span><br>        Worker --&gt;|<span class="hljs-type">Diff</span> Update (增量/全量)| <span class="hljs-type">Store</span>[useTopologyCore (数据层)]<br>        Store --&gt;|<span class="hljs-type">Raw</span> Data| <span class="hljs-type">Visual</span>[useTopologyVisual (视觉层)]<br>        <br>        subgraph <span class="hljs-string">"UI Components (视图层)"</span><br>            Visual --&gt;|<span class="hljs-type">Filtered</span> Data| <span class="hljs-type">Renderer</span>[useD3Renderer (渲染层)]<br>            Visual --&gt;|<span class="hljs-type">Filters</span>/<span class="hljs-keyword">Mode</span>| <span class="hljs-type">Controls</span>[TopologyVisualization (控制面板)]<br>            Renderer --&gt;|<span class="hljs-type">Click</span> Event| <span class="hljs-type">Details</span>[PhysicalTopology (详情抽屉)]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br>    Renderer --&gt;|<span class="hljs-type">Draw</span>| <span class="hljs-type">DOM</span>[SVG/Canvas]<br></code></pre></td></tr></table></figure><hr><h3 id="2-核心层级详细解析"><a href="#2-核心层级详细解析" class="headerlink" title="2. 核心层级详细解析"></a>2. 核心层级详细解析</h3><h4 id="第一层：数据处理层-Worker-Thread"><a href="#第一层：数据处理层-Worker-Thread" class="headerlink" title="第一层：数据处理层 (Worker Thread)"></a>第一层：数据处理层 (Worker Thread)</h4><p><strong>文件</strong>: workers/topology.worker.ts<br>这是架构的“发动机”，完全脱离主线程运行。</p><ul><li><p><strong>职责</strong>：</p><ol><li><p><strong>数据拉取</strong>：直接发起 Fetch 请求，不占用主线程网络资源。</p></li><li><p><strong>数据清洗</strong>：解析复杂的 JSON 结构，标准化为 TopologyNode 和 TopologyLink。</p></li><li><p><strong>智能 Diff (差异计算)</strong>：</p><ul><li><p>这是性能优化的关键。它对比新旧数据，计算出新增、删除和更新的节点。</p></li><li><p><strong>坐标继承</strong>：在 Worker 中将旧节点的 x, y 坐标赋值给新节点，防止 D3 在数据更新时重新计算布局导致视图“爆炸”或闪烁。</p></li></ul></li></ol></li></ul><h4 id="第二层：状态管理层-Composables"><a href="#第二层：状态管理层-Composables" class="headerlink" title="第二层：状态管理层 (Composables)"></a>第二层：状态管理层 (Composables)</h4><p>这一层利用 Vue 3 的 Composition API 将业务逻辑拆分为独立的模块。</p><ul><li><p><strong>数据持有 (useTopologyCore.ts)</strong>：</p><ul><li><p>与 Worker 通信的桥梁。</p></li><li><p>使用 shallowRef 存储庞大的拓扑数据。<strong>优化点</strong>：shallowRef 不会深度监听节点内部属性的变化（如 x, y 坐标），这极大减轻了 Vue 响应式系统的负担，因为 D3 会直接操作这些原生对象。</p></li></ul></li><li><p><strong>视觉逻辑 (useTopologyVisual.ts)</strong>：</p><ul><li><p><strong>纯粹的计算层</strong>。它不关心数据怎么来的，只关心怎么显示。</p></li><li><p><strong>动态过滤</strong>：利用 computed 属性，根据 filters（如隐藏共识节点）实时生成 filteredNodes。</p></li><li><p><strong>样式映射</strong>：集中管理颜色 (getNodeColor) 和标签 (getNodeLabel) 逻辑，实现逻辑与渲染分离。</p></li></ul></li></ul><h4 id="第三层：渲染驱动层-Render-Engine"><a href="#第三层：渲染驱动层-Render-Engine" class="headerlink" title="第三层：渲染驱动层 (Render Engine)"></a>第三层：渲染驱动层 (Render Engine)</h4><p><strong>文件</strong>: useD3Renderer.ts<br>这是 D3.js 与 Vue 的结合点。</p><ul><li><p><strong>生命周期接管</strong>：它在 onMounted 时初始化 D3 仿真器。</p></li><li><p><strong>增量渲染 (Incremental Rendering)</strong>：</p><ul><li><p>使用 Vue 的 watch 监听过滤后的数据。</p></li><li><p>利用 D3 的 enter(), update(), exit() 模式。</p></li><li><p><strong>Enter</strong>: 新节点淡入。</p></li><li><p><strong>Exit</strong>: 被过滤或删除的节点淡出移除。</p></li><li><p><strong>Update</strong>: 现有节点平滑移动到新位置。</p></li></ul></li><li><p><strong>事件桥接</strong>：将 D3 的 click、drag 事件转换为 Vue 的回调函数，传递给上层组件。</p></li></ul><h4 id="第四层：视图组装层-View-Integration"><a href="#第四层：视图组装层-View-Integration" class="headerlink" title="第四层：视图组装层 (View Integration)"></a>第四层：视图组装层 (View Integration)</h4><p><strong>文件</strong>: EthereumTopology.vue (父组件)<br>这是架构的“容器”和“胶水”。</p><ul><li><p><strong>依赖注入 (Dependency Injection)</strong>：</p><ul><li><p>父组件通过 provide(‘topology-state’, …) 将 mode、filters 等状态下发。</p></li><li><p>子组件 TopologyVisualization 通过 inject 直接获取并修改这些状态。避免了深层 Prop 传递（Prop Drilling）。</p></li></ul></li><li><p><strong>组件编排</strong>：</p><ul><li><p>负责布局：左上角悬浮控制面板、中间 D3 画布、右侧详情抽屉。</p></li><li><p>负责联动：当 D3 点击节点时，控制 showPhysicalDetails 变量来弹出侧边栏。</p></li></ul></li></ul><hr><h3 id="3-关键性能优化点总结"><a href="#3-关键性能优化点总结" class="headerlink" title="3. 关键性能优化点总结"></a>3. 关键性能优化点总结</h3><ol><li><p><strong>非阻塞主线程 (Off-Main-Thread)</strong>:</p><ul><li><p><strong>旧架构</strong>：在组件内 fetch 数据 -&gt; 解析 -&gt; 赋值。数据量大时 UI 会卡顿。</p></li><li><p><strong>新架构</strong>：所有数据处理都在 Worker 中完成，主线程只负责接收“准备好渲染”的数据。</p></li></ul></li><li><p><strong>浅层响应式 (Shallow Reactivity)</strong>:</p><ul><li>使用 shallowRef 代替 ref 存储节点数组。D3 内部高频修改 node.x 和 node.y 时，不会触发 Vue 的依赖更新系统，显著提升动画帧率。</li></ul></li><li><p><strong>状态保持 (State Preservation)</strong>:</p><ul><li>Worker 在处理新数据时，会查找旧数据的 ID，并将 x, y, vx, vy (速度向量) 复制给新数据。这保证了在轮询更新时，节点不会重置位置，实现了“流式”的平滑更新效果。</li></ul></li><li><p><strong>按需计算 (Computed Filtering)</strong>:</p><ul><li>连接 (links) 的过滤依赖于节点 (nodes) 的过滤结果。新架构使用了 Set 来建立索引，将连接过滤的时间复杂度从 O(N*M) 降低到 O(M)（其中 N 是节点数，M 是连接数）。</li></ul></li></ol><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>现在的架构是一个 <strong>“重后台、轻前台、数据驱动视图”</strong> 的专业可视化架构。</p><ul><li><p><strong>Worker</strong> 负责“脏活累活”（数据处理）。</p></li><li><p><strong>D3</strong> 负责“精细活”（物理仿真和绘图）。</p></li><li><p><strong>Vue</strong> 负责“指挥”（状态管理和组件通信）。</p></li></ul><p>这种架构非常适合需要长时间运行、实时监控网络状态的生产级系统。</p><hr><p>根据提供的代码（EthereumTopologyHandler 和 RealTopologyService），以太坊网络拓扑的处理流程是一个<strong>分层获取、数据融合、格式化输出</strong>的过程。核心逻辑依赖于 <strong>Neo4j 图数据库</strong>（存储P2P关系）和 <strong>Docker 守护进程</strong>（提供容器运行时信息）。</p><p>以下是详细的处理步骤解析：</p><h3 id="1-数据源获取-Data-Acquisition"><a href="#1-数据源获取-Data-Acquisition" class="headerlink" title="1. 数据源获取 (Data Acquisition)"></a>1. 数据源获取 (Data Acquisition)</h3><p>系统主要通过两个渠道获取数据：</p><ul><li><p><strong>Neo4j 数据库 (核心数据源)</strong>：存储了爬虫或客户端上报的节点发现数据，包含节点ID、IP、以及节点间的 P2P 连接关系。</p></li><li><p><strong>Docker Client (辅助数据源)</strong>：用于获取运行中容器的实时状态、名称映射和网络设置。</p></li></ul><h3 id="2-核心处理流程"><a href="#2-核心处理流程" class="headerlink" title="2. 核心处理流程"></a>2. 核心处理流程</h3><p>整个拓扑生成的逻辑主要集中在 _get_real_topology_from_neo4j 和 _convert_topology_format 方法中。</p><h4 id="步骤-A：从-Neo4j-提取原始拓扑结构"><a href="#步骤-A：从-Neo4j-提取原始拓扑结构" class="headerlink" title="步骤 A：从 Neo4j 提取原始拓扑结构"></a>步骤 A：从 Neo4j 提取原始拓扑结构</h4><p>代码通过 Cypher 查询语句分三步提取数据：</p><ol><li><p><strong>查询执行层 (Execution Layer)</strong>：</p><ul><li><p>查找所有 ExecNode 标签的节点。</p></li><li><p>查找 EXEC_PEERS_WITH 关系，获取该节点的对等节点（Peers）。</p></li></ul></li><li><p><strong>查询共识层 (Consensus Layer)</strong>：</p><ul><li><p>查找所有 ConsNode 标签的节点。</p></li><li><p>查找 CONS_PEERS_WITH 关系。</p></li></ul></li><li><p><strong>查询验证者 (Validators)</strong>：</p><ul><li><p>查找与共识节点通过 MANAGES_VALIDATOR 关系连接的 Validator 节点。</p></li><li><p>这反映了哪个信标节点（Beacon Node）管理着哪些验证者客户端。</p></li></ul></li></ol><h4 id="步骤-B：容器身份映射-Container-Mapping"><a href="#步骤-B：容器身份映射-Container-Mapping" class="headerlink" title="步骤 B：容器身份映射 (Container Mapping)"></a>步骤 B：容器身份映射 (Container Mapping)</h4><ul><li><p><strong>目的</strong>：数据库中只有 IP 地址，但在前端展示时，最好能显示具体的 Docker 容器名称（如 geth-node-1）。</p></li><li><p><strong>实现</strong>：_create_ip_to_container_mapping 方法遍历所有 Docker 容器，提取其网络设置中的 IP 地址，建立 IP -&gt; ContainerName 的映射表。</p></li></ul><h4 id="步骤-C：构建拓扑对象-Topology-Construction"><a href="#步骤-C：构建拓扑对象-Topology-Construction" class="headerlink" title="步骤 C：构建拓扑对象 (Topology Construction)"></a>步骤 C：构建拓扑对象 (Topology Construction)</h4><p>系统将原始数据转换为前端可视化的 JSON 格式，包含 nodes 和 links。</p><p><strong>1. 节点生成 (Nodes):</strong><br>代码根据逻辑自动计算节点的坐标 (x, y) 以便可视化布局：</p><ul><li><p><strong>执行层节点</strong>：</p><ul><li><p>type: execution</p></li><li><p>位置：固定在 Y=150 的水平线上。</p></li></ul></li><li><p><strong>共识层节点</strong>：</p><ul><li><p>type: consensus</p></li><li><p>位置：固定在 Y=350 的水平线上（位于执行层下方）。</p></li></ul></li><li><p><strong>验证者节点</strong>：</p><ul><li><p>type: validator</p></li><li><p>位置：簇拥在所属共识节点的下方 (y + 60)，通过计算偏移量排成小方阵。</p></li></ul></li></ul><p><strong>2. 连接生成 (Links):</strong><br>系统构建了四种类型的连接：</p><ul><li><p><strong>执行层 P2P (exec_peer)</strong>：基于 Neo4j 中的 EXEC_PEERS_WITH 关系，表示 Geth/Nethermind 节点间的 Gossip 协议连接。</p></li><li><p><strong>共识层 P2P (cons_peer)</strong>：基于 CONS_PEERS_WITH 关系，表示 Lighthouse/Prysm 节点间的连接。</p></li><li><p><strong>管理关系 (manages_validator)</strong>：连接共识节点和它管理的验证者节点。</p></li><li><p><strong>跨层连接 (cross_layer)</strong>：<strong>关键逻辑</strong>。代码会自动匹配 IP 地址相同的执行层节点和共识层节点，并创建一个垂直连接。这代表了以太坊客户端组合（Engine API 通信，例如 Geth &lt;-&gt; Lighthouse 在同一台机器/Pod内）。</p></li></ul><h3 id="3-容错与缓存机制"><a href="#3-容错与缓存机制" class="headerlink" title="3. 容错与缓存机制"></a>3. 容错与缓存机制</h3><p>为了保证性能和稳定性，代码中包含了以下机制：</p><ul><li><p><strong>缓存 (Caching)</strong>：</p><ul><li><p>使用 self.cache 存储计算好的拓扑。</p></li><li><p>设置 cache_ttl (20-30秒)，防止频繁查询 Neo4j 导致数据库过载。</p></li></ul></li><li><p><strong>降级模式 (Fallback - 仅在 Service 中)</strong>：</p><ul><li><p>如果 Neo4j 连接失败或返回空数据，RealTopologyService 会调用 _get_container_based_topology。</p></li><li><p><strong>Fallback 逻辑</strong>：直接扫描 Docker 容器，如果发现名为 ethereum 的容器，就根据容器数量“伪造”一个链式的拓扑结构（非网状），以确保界面上至少能看到节点存在，而不是一片空白。</p></li></ul></li></ul><h3 id="4-统计与验证-Statistics-amp-Validation"><a href="#4-统计与验证-Statistics-amp-Validation" class="headerlink" title="4. 统计与验证 (Statistics & Validation)"></a>4. 统计与验证 (Statistics &amp; Validation)</h3><p>EthereumTopologyHandler 还提供了额外的高级功能：</p><ul><li><p><strong>独立查询</strong>：get_nodes 和 get_links 可以不依赖完整拓扑逻辑，直接查询特定层的数据，提高效率。</p></li><li><p><strong>拓扑验证</strong>：validate_topology 检查数据一致性：</p><ul><li><p>节点 ID 是否唯一。</p></li><li><p>连接的源/目标节点是否存在。</p></li><li><p>是否存在孤立节点。</p></li><li><p>IP 地址分布是否异常（例如一个 IP 运行了超过2个主要节点）。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该系统处理以太坊拓扑的核心思想是：<strong>“数据库定义逻辑关系，Docker 定义物理属性，代码负责视觉组装”</strong>。</p><ol><li><p><strong>逻辑层</strong>：谁连谁？由 Neo4j 决定。</p></li><li><p><strong>物理层</strong>：你是谁？由 Docker IP 映射决定。</p></li><li><p><strong>视觉层</strong>：你在哪？由代码中的分层坐标计算逻辑决定（执行层在上，共识层在中，验证者在下）。</p></li></ol><hr><p>目前的实现逻辑虽然功能完整，但在性能上存在几个显著的<strong>瓶颈</strong>，特别是在节点数量增多或 Docker 容器较多时，响应速度会明显下降。</p><p>以下是针对代码的具体性能优化方案，按<strong>提升幅度从大到小</strong>排序：</p><h3 id="1-痛点分析：目前的性能瓶颈在哪里？"><a href="#1-痛点分析：目前的性能瓶颈在哪里？" class="headerlink" title="1. 痛点分析：目前的性能瓶颈在哪里？"></a>1. 痛点分析：目前的性能瓶颈在哪里？</h3><ol><li><p><strong>Docker API 调用过于频繁 (主要瓶颈)</strong>：</p><ul><li><p>_create_ip_to_container_mapping 每次生成拓扑都会被调用。它会遍历<strong>所有</strong>容器并检查网络设置。Docker API 的响应通常是毫秒级到秒级的，如果不缓存，这会严重阻塞主线程。</p></li><li><p>在物理拓扑中，_get_link_bandwidth 会对每个连接进入容器执行 tc 命令。如果有 50 个连接，就要串行执行 50 次 docker exec，这是极慢的 IO 操作。</p></li></ul></li><li><p><strong>串行数据库查询</strong>：</p><ul><li>在 _get_real_topology_from_neo4j 中，执行层查询及处理完之后，才开始共识层的查询。这两者没有依赖关系，完全可以并行。</li></ul></li><li><p><strong>计算密集型的重复操作</strong>：</p><ul><li>每次请求都重新计算所有节点的坐标和映射关系，即使数据没有变化。</li></ul></li></ol><hr><h3 id="2-优化方案一：Docker-数据的独立缓存与后台更新"><a href="#2-优化方案一：Docker-数据的独立缓存与后台更新" class="headerlink" title="2. 优化方案一：Docker 数据的独立缓存与后台更新"></a>2. 优化方案一：Docker 数据的独立缓存与后台更新</h3><p>Docker 的元数据（IP、容器名）变化频率远低于 P2P 网络连接的变化频率。<strong>不要在每次请求拓扑时都去查询 Docker。</strong></p><p><strong>优化策略：</strong> 使用“读写分离”的策略，后台任务更新 Docker 映射，前台请求只读内存变量。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 原有初始化 ...</span><br>        <span class="hljs-variable language_">self</span>.ip_container_map_cache = {}<br>        <span class="hljs-variable language_">self</span>.map_last_update = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.map_update_lock = asyncio.Lock()<br>        <br>        <span class="hljs-comment"># 启动时预热</span><br>        <span class="hljs-comment"># 注意：实际代码中建议使用 apscheduler 或 asyncio.create_task 在后台循环运行</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_ip_to_container_map_optimized</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化后的获取映射方法：</span><br><span class="hljs-string">        1. 优先返回内存缓存</span><br><span class="hljs-string">        2. 缓存过期（如5分钟）才异步更新</span><br><span class="hljs-string">        """</span><br>        current_time = time.time()<br>        <span class="hljs-comment"># 缓存有效期设为 300秒 (Docker容器IP不会频繁变动)</span><br>        <span class="hljs-keyword">if</span> current_time - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br><br>        <span class="hljs-comment"># 如果需要更新，且未被锁定</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.map_update_lock.locked():<br>             <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.map_update_lock:<br>                 <span class="hljs-comment"># 二次检查</span><br>                 <span class="hljs-keyword">if</span> time.time() - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span>: <br>                     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br>                 <br>                 <span class="hljs-comment"># 执行耗时的 Docker 查询</span><br>                 <span class="hljs-comment"># 建议：在一个线程池中运行同步的 docker client 操作，避免阻塞事件循环</span><br>                 loop = asyncio.get_running_loop()<br>                 <span class="hljs-variable language_">self</span>.ip_container_map_cache = <span class="hljs-keyword">await</span> loop.run_in_executor(<br>                     <span class="hljs-literal">None</span>, <span class="hljs-variable language_">self</span>._create_ip_to_container_mapping<br>                 )<br>                 <span class="hljs-variable language_">self</span>.map_last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br></code></pre></td></tr></table></figure><h3 id="3-优化方案二：物理拓扑带宽检测的“非阻塞化”"><a href="#3-优化方案二：物理拓扑带宽检测的“非阻塞化”" class="headerlink" title="3. 优化方案二：物理拓扑带宽检测的“非阻塞化”"></a>3. 优化方案二：物理拓扑带宽检测的“非阻塞化”</h3><p>在 RealTopologyService 中，物理连接的带宽检测（tc 命令）是极其耗时的。绝对不能在用户请求 API 时实时去跑 tc 命令。</p><p><strong>优化策略：</strong> 将带宽数据设为“最终一致性”。主接口只返回拓扑结构，带宽字段先返回缓存值或 “Checking…”，后台任务专门负责轮询更新带宽。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealTopologyService</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-variable language_">self</span>.bandwidth_cache = {} <span class="hljs-comment"># Key: "container_ip", Value: "100Mbit"</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_dynamic_physical_topology_from_containers</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 前面生成 nodes 和 links 的逻辑保持不变 ...</span><br>        <br>        <span class="hljs-comment"># --- 优化点：移除实时 await _get_link_bandwidth ---</span><br>        <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>            target_id = link[<span class="hljs-string">'target'</span>]<br>            target_node = nodes_by_id[target_id]<br>            container_name = target_node[<span class="hljs-string">'container_name'</span>]<br>            link_ip = target_node[<span class="hljs-string">'networks'</span>].get(link[<span class="hljs-string">'shared_network'</span>])<br>            <br>            <span class="hljs-comment"># 1. 尝试从缓存获取</span><br>            cache_key = <span class="hljs-string">f"<span class="hljs-subst">{container_name}</span>::<span class="hljs-subst">{link_ip}</span>"</span><br>            cached_bw = <span class="hljs-variable language_">self</span>.bandwidth_cache.get(cache_key)<br>            <br>            <span class="hljs-keyword">if</span> cached_bw:<br>                link[<span class="hljs-string">'bandwidth'</span>] = cached_bw<br>            <span class="hljs-keyword">else</span>:<br>                link[<span class="hljs-string">'bandwidth'</span>] = <span class="hljs-string">"Querying..."</span><br>                <span class="hljs-comment"># 2. 触发后台更新任务 (Fire and Forget)</span><br>                asyncio.create_task(<span class="hljs-variable language_">self</span>._update_bandwidth_cache(container_name, link_ip, cache_key))<br>                <br>        <span class="hljs-keyword">return</span> nodes, links<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bandwidth_cache</span>(<span class="hljs-params">self, container_name, link_ip, cache_key</span>):<br>        <span class="hljs-string">"""后台单独更新带宽"""</span><br>        bw = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>._get_link_bandwidth(container_name, link_ip)<br>        <span class="hljs-variable language_">self</span>.bandwidth_cache[cache_key] = bw<br></code></pre></td></tr></table></figure><h3 id="4-优化方案三：Neo4j-并发查询"><a href="#4-优化方案三：Neo4j-并发查询" class="headerlink" title="4. 优化方案三：Neo4j 并发查询"></a>4. 优化方案三：Neo4j 并发查询</h3><p>Neo4j 的 Python Driver (尤其是 Bolt 协议) 支持并发。执行层和共识层的查询是独立的，可以使用 asyncio.gather 同时发起查询。</p><p><strong>注意</strong>：这需要你的 database_manager 支持异步操作。如果底层是同步驱动，可以用 run_in_executor 包装。</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 EthereumTopologyHandler 中</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_real_topology_from_neo4j</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Dict</span>, <span class="hljs-type">Dict</span>]:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># ... 连接检查 ...</span><br><br>            <span class="hljs-comment"># 定义查询函数</span><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_exec</span>():<br>                <span class="hljs-comment"># 这里假设 database_manager 提供了某种异步执行方式，</span><br>                <span class="hljs-comment"># 或者我们将同步的 session.run 放入线程池</span><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        result = session.run(<span class="hljs-string">"MATCH (n:ExecNode)..."</span>) <span class="hljs-comment"># 填入完整的 Cypher</span><br>                        <span class="hljs-keyword">return</span> {r[<span class="hljs-string">'node_id'</span>]: ... <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result} <span class="hljs-comment"># 处理结果</span><br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_cons_and_validators</span>():<br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        <span class="hljs-comment"># 合并共识节点和验证者的查询逻辑，减少一次 session 创建开销</span><br>                        cons_result = session.run(<span class="hljs-string">"MATCH (n:ConsNode)..."</span>) <br>                        <span class="hljs-comment"># ... 处理共识 ...</span><br>                        validator_result = session.run(<span class="hljs-string">"MATCH ... validators ..."</span>)<br>                        <span class="hljs-comment"># ... 处理验证者 ...</span><br>                        <span class="hljs-keyword">return</span> cons_data<br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-comment"># 并发执行</span><br>            exec_nodes_data, cons_nodes_data = <span class="hljs-keyword">await</span> asyncio.gather(<br>                fetch_exec(), <br>                fetch_cons_and_validators()<br>            )<br><br>            <span class="hljs-keyword">return</span> exec_nodes_data, cons_nodes_data<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># ... Error handling</span><br></code></pre></td></tr></table></figure><h3 id="5-优化方案四：Cypher-查询语句优化"><a href="#5-优化方案四：Cypher-查询语句优化" class="headerlink" title="5. 优化方案四：Cypher 查询语句优化"></a>5. 优化方案四：Cypher 查询语句优化</h3><p>目前的 Cypher 使用了 OPTIONAL MATCH 和 collect，这在数据量大时比较慢。</p><p><strong>原查询：</strong></p><p>codeCypher</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">MATCH (n:ExecNode)<br>OPTIONAL MATCH (n)-<span class="hljs-selector-attr">[r:EXEC_PEERS_WITH]</span>-&gt;(p:ExecNode)<br>RETURN ... <span class="hljs-built_in">collect</span>(...)<br></code></pre></td></tr></table></figure><p>如果在节点很多的情况下，这个查询会扫描整个图。</p><p><strong>优化建议：</strong></p><ol><li><p><strong>分批次</strong>：如果节点超过 1000 个，不要一次性 collect 所有 Peers。前端通常不需要展示所有几千条连线（会卡死浏览器）。可以限制返回的 Peer 数量，例如 LIMIT 10。</p></li><li><p><strong>索引</strong>：确保 node_id, ip 在 Neo4j 中建立了索引 (CREATE INDEX ON :ExecNode(node_id)).</p></li><li><p><strong>只查 ID</strong>：先查出所有 Node 的基础信息，再查 Relation 表（Links），在内存中组装，通常比 Graph DB 做复杂的聚合（Map/Collect）要快。</p></li></ol><h3 id="6-综合改进后的代码结构建议"><a href="#6-综合改进后的代码结构建议" class="headerlink" title="6. 综合改进后的代码结构建议"></a>6. 综合改进后的代码结构建议</h3><p>这里给出一个集成优化思路的 EthereumTopologyHandler 核心方法重构示例：</p><p>codePython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-comment"># ... init ...</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_topology</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        <span class="hljs-string">"""获取完整的以太坊拓扑 (优化版)"""</span><br>        <span class="hljs-comment"># 1. 检查拓扑缓存 (Short TTL: e.g., 5s)</span><br>        <span class="hljs-comment"># 拓扑结构变化很快，缓存时间短一点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._is_cache_valid(<span class="hljs-string">"full_ethereum_topology"</span>, ttl=<span class="hljs-number">5</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>]<br><br>        <span class="hljs-comment"># 2. 并行获取数据</span><br>        <span class="hljs-comment"># A. 获取 Docker 映射 (从长效缓存或后台任务获取，极快)</span><br>        <span class="hljs-comment"># B. 获取 Neo4j 数据 (并发查询)</span><br>        <br>        task_docker = <span class="hljs-variable language_">self</span>._get_ip_to_container_map_optimized() <span class="hljs-comment"># 优化点1</span><br>        task_neo4j = <span class="hljs-variable language_">self</span>._get_real_topology_from_neo4j()       <span class="hljs-comment"># 优化点3 (并发内部实现)</span><br>        <br>        ip_map, (exec_data, cons_data) = <span class="hljs-keyword">await</span> asyncio.gather(task_docker, task_neo4j)<br><br>        <span class="hljs-comment"># 3. 转换数据 (CPU 密集型)</span><br>        <span class="hljs-comment"># 如果节点数非常多 (&gt;5000)，可以考虑放入 ProcessPoolExecutor</span><br>        nodes, links = <span class="hljs-variable language_">self</span>._convert_topology_format_optimized(exec_data, cons_data, ip_map)<br><br>        topology_data = {<br>            <span class="hljs-string">'nodes'</span>: nodes, <span class="hljs-string">'links'</span>: links, <span class="hljs-string">'timestamp'</span>: time.time(),<br>            <span class="hljs-comment"># ...</span><br>        }<br><br>        <span class="hljs-comment"># 更新缓存</span><br>        <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>] = topology_data<br>        <span class="hljs-variable language_">self</span>.last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> topology_data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_convert_topology_format_optimized</span>(<span class="hljs-params">self, exec_data, cons_data, ip_map</span>):<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化点：</span><br><span class="hljs-string">        1. 使用 ip_map.get 避免重复循环</span><br><span class="hljs-string">        2. 预计算 positions 字典，避免列表遍历查找</span><br><span class="hljs-string">        """</span><br>        nodes = []<br>        links = []<br>        <span class="hljs-comment"># 使用字典加速查找: key=node_id, value={idx, type, ...}</span><br>        node_lookup = {} <br>        <br>        <span class="hljs-comment"># ... 处理 Exec 节点 ...</span><br>        <span class="hljs-keyword">for</span> i, (nid, data) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exec_data.items()):<br>            <span class="hljs-comment"># 直接查预热好的 Map，O(1)</span><br>            container = ip_map.get(data[<span class="hljs-string">'ip'</span>], <span class="hljs-string">f"exec-<span class="hljs-subst">{data[<span class="hljs-string">'ip'</span>]}</span>"</span>)<br>            <span class="hljs-comment"># ... 创建 node ...</span><br>            node_lookup[nid] = {<span class="hljs-string">'type'</span>: <span class="hljs-string">'execution'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-string">f'<span class="hljs-subst">{nid}</span>-exec'</span>}<br>            <br>        <span class="hljs-comment"># ... 处理 Cons 节点 ...</span><br>        <br>        <span class="hljs-comment"># ... 处理连接 ...</span><br>        <span class="hljs-comment"># 只需要遍历一次 exec_data 的 peers，利用 node_lookup 快速验证</span><br>        <span class="hljs-keyword">for</span> nid, data <span class="hljs-keyword">in</span> exec_data.items():<br>             source_full_id = <span class="hljs-string">f"<span class="hljs-subst">{nid}</span>-exec"</span><br>             <span class="hljs-keyword">for</span> peer <span class="hljs-keyword">in</span> data.get(<span class="hljs-string">'peers'</span>, []):<br>                 target_nid = peer[<span class="hljs-string">'peer_id'</span>]<br>                 <span class="hljs-comment"># O(1) 检查目标是否存在</span><br>                 <span class="hljs-keyword">if</span> target_nid <span class="hljs-keyword">in</span> node_lookup <span class="hljs-keyword">and</span> node_lookup[target_nid][<span class="hljs-string">'type'</span>] == <span class="hljs-string">'execution'</span>:<br>                     links.append({<br>                         <span class="hljs-string">'source'</span>: source_full_id,<br>                         <span class="hljs-string">'target'</span>: <span class="hljs-string">f"<span class="hljs-subst">{target_nid}</span>-exec"</span>,<br>                         <span class="hljs-comment"># ...</span><br>                     })<br>                     <br>        <span class="hljs-keyword">return</span> nodes, links<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>要进行性能优化，最关键的修改是：</p><ol><li><p><strong>Docker 映射</strong>：改为后台定时更新或长缓存，不要每秒都去 inspect 容器。</p></li><li><p><strong>物理带宽 (tc)</strong>：改为异步/后台获取，不要阻塞 API 响应。</p></li><li><p><strong>Neo4j</strong>：使用并发查询，并限制 Cypher 复杂度。</p></li></ol><hr><h2 id="攻击方式（Attack-Strategies）"><a href="#攻击方式（Attack-Strategies）" class="headerlink" title="攻击方式（Attack Strategies）"></a>攻击方式（Attack Strategies）</h2><p>系统目前支持以下6种攻击方式：</p><h3 id="1-节点断网攻击（Node-Disconnection-Attack）"><a href="#1-节点断网攻击（Node-Disconnection-Attack）" class="headerlink" title="1. 节点断网攻击（Node Disconnection Attack）"></a>1. 节点断网攻击（Node Disconnection Attack）</h3><p>通过网络隔离手段切断目标节点与其他节点的连接。支持的方法包括：</p><ul><li><code>interface_down</code>: 禁用网络接口</li><li><code>route_flush</code>: 清除路由表</li><li><code>firewall_block</code>: 防火墙阻断</li><li><code>p2p_block</code>: P2P连接阻断</li></ul><h3 id="2-通信干扰攻击（Communication-Interference-Attack）"><a href="#2-通信干扰攻击（Communication-Interference-Attack）" class="headerlink" title="2. 通信干扰攻击（Communication Interference Attack）"></a>2. 通信干扰攻击（Communication Interference Attack）</h3><p>通过大量无效通信干扰目标节点正常通信。支持的方法包括：</p><ul><li><code>json_rpc_flood</code>: JSON-RPC请求泛洪</li><li><code>p2p_flood</code>: P2P消息泛洪</li><li><code>memory_exhaustion</code>: 内存耗尽攻击</li></ul><h3 id="3-时间攻击（Timestamp-Attack）"><a href="#3-时间攻击（Timestamp-Attack）" class="headerlink" title="3. 时间攻击（Timestamp Attack）"></a>3. 时间攻击（Timestamp Attack）</h3><p>针对共识机制的时间同步进行攻击。支持的方法包括：</p><ul><li>time_shift: 时间偏移</li><li><code>ntp_block</code>: 阻断NTP时间同步</li><li><code>time_drift</code>: 时间漂移</li></ul><h3 id="4-简化Sybil攻击（Simplified-Sybil-Attack）"><a href="#4-简化Sybil攻击（Simplified-Sybil-Attack）" class="headerlink" title="4. 简化Sybil攻击（Simplified Sybil Attack）"></a>4. 简化Sybil攻击（Simplified Sybil Attack）</h3><p>创建虚假节点来影响网络。可以配置：</p><ul><li>虚假节点数量（1-20）</li><li>节点类型（轻节点、全节点、验证者节点）</li><li>网络环境（主网、测试网、开发网）</li><li>连接真实节点选项</li></ul><h3 id="5-存储攻击（Storage-Attack）"><a href="#5-存储攻击（Storage-Attack）" class="headerlink" title="5. 存储攻击（Storage Attack）"></a>5. 存储攻击（Storage Attack）</h3><p>针对节点存储系统的攻击。支持的方法包括：</p><ul><li><code>disk_fill</code>: 磁盘空间填充</li><li><code>database_corruption</code>: 数据库损坏</li><li><code>state_pollution</code>: 状态污染</li><li><code>chain_data_spam</code>: 链上数据垃圾信息</li></ul><h3 id="6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）"><a href="#6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）" class="headerlink" title="6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）"></a>6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）</h3><p>针对特定以太坊客户端的攻击。支持的方法包括：</p><ul><li><code>process_kill</code>: 终止进程</li><li><code>db_corruption</code>: 数据库损坏</li><li><code>port_blocking</code>: 端口阻断</li><li><code>config_modification</code>: 配置文件修改</li></ul><h2 id="攻击模式（Execution-Modes）"><a href="#攻击模式（Execution-Modes）" class="headerlink" title="攻击模式（Execution Modes）"></a>攻击模式（Execution Modes）</h2><p>系统支持三种攻击执行模式：</p><h3 id="1-一次性攻击（One-shot）"><a href="#1-一次性攻击（One-shot）" class="headerlink" title="1. 一次性攻击（One-shot）"></a>1. 一次性攻击（One-shot）</h3><p>执行一次攻击，持续指定时间后自动清理恢复。 配置参数：</p><ul><li>duration_seconds: 攻击持续时间（秒）</li></ul><h3 id="2-重复攻击（Repeated）"><a href="#2-重复攻击（Repeated）" class="headerlink" title="2. 重复攻击（Repeated）"></a>2. 重复攻击（Repeated）</h3><p>按指定间隔重复执行多次攻击。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>repeat_count: 重复次数</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h3 id="3-持续攻击（Continuous）"><a href="#3-持续攻击（Continuous）" class="headerlink" title="3. 持续攻击（Continuous）"></a>3. 持续攻击（Continuous）</h3><p>持续不断地执行攻击，直到手动停止。 配置参数：</p><ul><li>interval_seconds: 攻击间隔时间（秒）</li><li>duration_seconds: 每次攻击持续时间（秒）</li></ul><h2 id="动态目标攻击"><a href="#动态目标攻击" class="headerlink" title="动态目标攻击"></a>动态目标攻击</h2><p>系统还支持一种特殊的动态目标攻击功能，可以根据网络拓扑分析结果自动选择攻击目标。支持的中心性指标包括：</p><ul><li>度中心性（Degree Centrality）</li><li>介数中心性（Betweenness Centrality）</li><li>接近中心性（Closeness Centrality）</li><li>特征向量中心性（Eigenvector Centrality）</li></ul><p>通过这些攻击方式和模式的组合，系统可以模拟各种真实的以太坊网络攻击场景，帮助评估网络的安全性和鲁棒性。</p><hr><h3 id="1-发起普通攻击-Standard-Attack"><a href="#1-发起普通攻击-Standard-Attack" class="headerlink" title="1. 发起普通攻击 (Standard Attack)"></a>1. 发起普通攻击 (Standard Attack)</h3><p>此接口用于对<strong>明确指定的静态 IP 列表</strong>发起攻击。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate</p></li><li><p><strong>功能</strong>: 发起针对特定静态目标（IP/ID列表）的攻击模拟。</p></li><li><p><strong>逻辑约束</strong>:</p><ol><li><p>parameters.target_nodes 必须是字符串数组 [“ip1”, “ip2”]。</p></li><li><p>支持所有三种执行模式 (one_shot, repeated, continuous)。</p></li></ol></li><li><p><strong>请求体构建规则</strong>:</p><ul><li><p><strong>Level 1 (执行配置)</strong>: 决定攻击的时间维度。</p><ul><li><p>若是 one_shot: 仅需 duration_seconds。</p></li><li><p>若是 repeated: 需额外提供 interval_seconds 和 repeat_count。</p></li></ul></li><li><p><strong>Level 2 (策略参数)</strong>: 决定攻击的具体手段。</p><ul><li><p>必须包含 strategy 字段（枚举值）。</p></li><li><p>其余字段根据 strategy 变化（如 storage_attack 需要 size_mb，而 node_disconnection 不需要）。</p></li></ul></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 场景：对两个节点进行重复的 P2P 洪水攻击</span><br>{<br>  <span class="hljs-string">"execution_config"</span>: {<br>    <span class="hljs-string">"mode"</span>: <span class="hljs-string">"repeated"</span>,<br>    <span class="hljs-string">"duration_seconds"</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">"interval_seconds"</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">"repeat_count"</span>: <span class="hljs-number">5</span><br>  },<br>  <span class="hljs-string">"parameters"</span>: {<br>    <span class="hljs-string">"strategy"</span>: <span class="hljs-string">"communication_interference"</span>,<br>    <span class="hljs-string">"method"</span>: <span class="hljs-string">"p2p_flood"</span>,<br>    <span class="hljs-string">"intensity"</span>: <span class="hljs-string">"high"</span>,<br>    <span class="hljs-string">"target_nodes"</span>: <span class="hljs-selector-attr">[<span class="hljs-string">"192.168.1.10"</span>, <span class="hljs-string">"192.168.1.11"</span>]</span><br>  }<br>}<br></code></pre></td></tr></table></figure><hr><h3 id="2-发起自适应攻击-Adaptive-Attack"><a href="#2-发起自适应攻击-Adaptive-Attack" class="headerlink" title="2. 发起自适应攻击 (Adaptive Attack)"></a>2. 发起自适应攻击 (Adaptive Attack)</h3><p>此接口用于<strong>动态目标</strong>攻击，系统会在每一轮攻击开始前重新计算受害者（例如：总是攻击网络中连接数最多的节点）。</p><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>功能</strong>: 发起自适应攻击，目标由后端实时计算。</p></li><li><p><strong>关键区别</strong>:</p><ol><li><p><strong>不支持</strong> one_shot 模式（因为一次性攻击不需要”自适应”变化）。必须是 repeated 或 continuous。</p></li><li><p>parameters.target_nodes <strong>必须</strong>是特定格式的字符串指令，以 dynamic: 开头。</p></li></ol></li><li><p><strong>目标指令语法</strong>: dynamic:{指标}:{选择策略}</p><ul><li><p>示例: dynamic:degree:top:5 (度中心性最高的前5个)</p></li><li><p>示例: dynamic:betweenness:highest (介数中心性最高的1个)</p></li></ul></li></ul><p><strong>请求示例 (JSON):</strong></p><p>codeJSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 场景：持续攻击网络中度中心性最高的前5个节点</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"execution_config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"continuous"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"duration_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"interval_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"strategy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_disconnection"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"firewall_block"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"target_nodes"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dynamic:degree:top:5"</span> <span class="hljs-comment">// 注意这里是字符串</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-前端分流逻辑-Frontend-Logic"><a href="#3-前端分流逻辑-Frontend-Logic" class="headerlink" title="3. 前端分流逻辑 (Frontend Logic)"></a>3. 前端分流逻辑 (Frontend Logic)</h3><p>这是前端 Vue 组件如何决定调用哪个接口的核心逻辑说明。</p><p><strong>Prompt / 逻辑说明:</strong></p><p>前端在点击”发起攻击”按钮时，必须执行以下判断逻辑：</p><ol><li><p><strong>检查目标类型</strong>:</p><ul><li><p>获取用户在表单中输入的目标配置。</p></li><li><p>如果目标是<strong>字符串指令</strong>且以 dynamic: 开头 -&gt; 标记为 isDynamic。</p></li><li><p>如果目标是<strong>手动输入的 IP 列表</strong> -&gt; 标记为 isStatic。</p></li></ul></li><li><p><strong>检查执行模式</strong>:</p><ul><li>获取用户选择的模式 (one_shot, repeated, continuous)。</li></ul></li><li><p><strong>路由决策树</strong>:</p><ul><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode == one_shot):</p><ul><li>❌ <strong>报错</strong>: 自适应攻击不支持一次性模式。</li></ul></li><li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode != one_shot):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate/adaptive</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段发送字符串。</p></li></ul></li><li><p><strong>ELSE</strong> (即静态目标，无论什么模式):</p><ul><li><p>✅ <strong>调用接口</strong>: POST /api/simulate</p></li><li><p><strong>注意</strong>: 此时 target_nodes 字段必须转换为数组 [] 发送。</p></li></ul></li></ul></li></ol><hr><h3 id="4-停止攻击-Stop-Attack"><a href="#4-停止攻击-Stop-Attack" class="headerlink" title="4. 停止攻击 (Stop Attack)"></a>4. 停止攻击 (Stop Attack)</h3><p><strong>Prompt / 接口说明:</strong></p><ul><li><p><strong>接口地址</strong>: DELETE /api/simulations/{attack_id}</p></li><li><p><strong>功能</strong>: 立即终止一个正在运行 (running) 或挂起 (pending) 的攻击任务。</p></li><li><p><strong>适用场景</strong>:</p><ul><li><p>用户点击”紧急停止”按钮。</p></li><li><p>用于中断 continuous (无限持续) 类型的攻击。</p></li><li><p>用于中断剩余轮次尚未执行的 repeated 攻击。</p></li></ul></li><li><p><strong>后端行为</strong>:</p><ul><li><p>取消对应的 asyncio.Task。</p></li><li><p>执行清理逻辑（如恢复防火墙规则、删除垃圾文件）。</p></li><li><p>将数据库中的状态更新为 stopped。</p></li></ul></li></ul><hr><h3 id="5-状态轮询与监控-Monitoring"><a href="#5-状态轮询与监控-Monitoring" class="headerlink" title="5. 状态轮询与监控 (Monitoring)"></a>5. 状态轮询与监控 (Monitoring)</h3><p><strong>Prompt / 接口说明:</strong></p><p>为了在前端展示”实时状态”和”系统日志”，需要配合使用以下两个接口：</p><ol><li><p><strong>获取活跃列表</strong>: GET /api/simulations/active</p><ul><li><p><strong>用途</strong>: 判断当前是否有攻击在跑 (isRunning 状态)。</p></li><li><p><strong>频率</strong>: 建议每 3-5 秒轮询一次。</p></li><li><p><strong>返回</strong>: 包含 progress (进度百分比) 和 current_round (当前轮次)。</p></li></ul></li><li><p><strong>获取详情/日志</strong>: GET /api/simulations/{attack_id}</p><ul><li><p><strong>用途</strong>: 获取特定攻击的详细日志流。</p></li><li><p><strong>返回</strong>: 包含 logs 数组 ([“Attack started”, “Round 1 finished”])。</p></li><li><p><strong>前端展示</strong>: 将 logs 渲染到控制台面板中。</p></li></ul></li></ol><hr><h3 id="总结：数据结构对照表-Type-Mapping"><a href="#总结：数据结构对照表-Type-Mapping" class="headerlink" title="总结：数据结构对照表 (Type Mapping)"></a>总结：数据结构对照表 (Type Mapping)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>参数字段</td><td>描述</td><td>类型限制</td></tr><tr><td><strong>execution_config</strong></td><td></td><td></td></tr><tr><td>mode</td><td>执行模式</td><td>“one_shot” \</td><td>“repeated” \</td><td>“continuous”</td></tr><tr><td>duration_seconds</td><td>单次持续时长</td><td>Integer (秒)</td></tr><tr><td>interval_seconds</td><td>轮次间隔</td><td>Integer (秒), 仅 repeated/continuous 有效</td></tr><tr><td>repeat_count</td><td>重复次数</td><td>Integer, 仅 repeated 有效</td></tr><tr><td><strong>parameters</strong></td><td></td><td></td></tr><tr><td>strategy</td><td>攻击策略</td><td>“node_disconnection” \</td><td>“storage_attack” …</td></tr><tr><td>target_nodes</td><td>攻击目标</td><td>Array [str] (普通) <strong>OR</strong> String dynamic:… (自适应)</td></tr><tr><td>method</td><td>具体手段</td><td>依赖于 strategy (如 firewall_block, disk_fill)</td></tr><tr><td>…</td><td>其他参数</td><td>依赖于 strategy (如 size_mb, intensity)</td></tr></tbody></table></div><hr><h3 id="1-全局枚举定义-Global-Enums"><a href="#1-全局枚举定义-Global-Enums" class="headerlink" title="1. 全局枚举定义 (Global Enums)"></a>1. 全局枚举定义 (Global Enums)</h3><p>这些枚举值用于填充请求体中的特定字段。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>枚举类型</td><td>字段名</td><td>可选值 (Value)</td><td>说明</td></tr><tr><td><strong>执行模式</strong></td><td>mode</td><td>one_shot</td><td><strong>一次性</strong>：执行一次，持续指定时间后恢复。</td></tr><tr><td></td><td></td><td>repeated</td><td><strong>重复执行</strong>：按间隔重复执行多次。</td></tr><tr><td></td><td></td><td>continuous</td><td><strong>持续执行</strong>：按间隔无限执行，直到手动停止。</td></tr><tr><td><strong>攻击策略</strong></td><td>strategy</td><td>node_disconnection</td><td>节点断连攻击</td></tr><tr><td></td><td></td><td>communication_interference</td><td>通信干扰攻击</td></tr><tr><td></td><td></td><td>storage_attack</td><td>存储耗尽攻击</td></tr><tr><td></td><td></td><td>timestamp_attack</td><td>时间/NTP攻击</td></tr><tr><td></td><td></td><td>simplified_sybil_attack</td><td>简化版女巫攻击</td></tr><tr><td></td><td></td><td>geth_lighthouse_attack</td><td>客户端特定攻击 (Geth/Lighthouse)</td></tr></tbody></table></div><hr><h3 id="2-执行配置-execution-config"><a href="#2-执行配置-execution-config" class="headerlink" title="2. 执行配置 (execution_config)"></a>2. 执行配置 (execution_config)</h3><p>根据 mode 的不同，所需字段不同。<strong>注意：自适应攻击接口 (/simulate/adaptive) 不支持 one_shot。</strong></p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>模式 (Mode)</td><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>约束/说明</td></tr><tr><td><strong>通用</strong></td><td>duration_seconds</td><td>Int</td><td>✅</td><td>30</td><td>攻击生效持续时间 (秒)，&gt;=1</td></tr><tr><td><strong>Repeated</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr><tr><td>(重复)</td><td>repeat_count</td><td>Int</td><td>✅</td><td>-</td><td>重复执行的总轮数，&gt;=1</td></tr><tr><td><strong>Continuous</strong></td><td>interval_seconds</td><td>Int</td><td>✅</td><td>60</td><td>轮次间隔时间 (秒)，&gt;=1</td></tr></tbody></table></div><hr><h3 id="3-策略参数详情-parameters"><a href="#3-策略参数详情-parameters" class="headerlink" title="3. 策略参数详情 (parameters)"></a>3. 策略参数详情 (parameters)</h3><p>此部分为多态结构，根据 strategy 字段的值，JSON 结构发生变化。</p><h4 id="3-1-节点断连-node-disconnection"><a href="#3-1-节点断连-node-disconnection" class="headerlink" title="3.1 节点断连 (node_disconnection)"></a>3.1 节点断连 (node_disconnection)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>interface_down (网卡下线), route_flush (清空路由), firewall_block (防火墙), p2p_block (P2P阻断)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令 (见第4节)</td></tr></tbody></table></div><h4 id="3-2-通信干扰-communication-interference"><a href="#3-2-通信干扰-communication-interference" class="headerlink" title="3.2 通信干扰 (communication_interference)"></a>3.2 通信干扰 (communication_interference)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>json_rpc_flood (RPC泛洪), p2p_flood (P2P泛洪), memory_exhaustion (内存耗尽)</td></tr><tr><td>intensity</td><td>String</td><td>❌</td><td>medium</td><td>low, medium, high, extreme</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h4 id="3-3-存储攻击-storage-attack"><a href="#3-3-存储攻击-storage-attack" class="headerlink" title="3.3 存储攻击 (storage_attack)"></a>3.3 存储攻击 (storage_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>disk_fill (填充), database_corruption (脏数据), state_pollution (状态污染), chain_data_spam (链上垃圾)</td></tr><tr><td>size_mb</td><td>Int</td><td>❌</td><td>1000</td><td>填充大小 (MB)，100 - 10000</td></tr><tr><td>file_count</td><td>Int</td><td>❌</td><td>100</td><td>生成文件数量，10 - 1000</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-4-时间攻击-timestamp-attack"><a href="#3-4-时间攻击-timestamp-attack" class="headerlink" title="3.4 时间攻击 (timestamp_attack)"></a>3.4 时间攻击 (timestamp_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>time_shift (平移), ntp_block (NTP阻断), time_drift (漂移)</td></tr><tr><td>time_shift</td><td>String</td><td>❌</td><td>+1 hour</td><td>偏移量 (如 +1 hour, -30 minutes)，仅 time_shift 方法有效</td></tr><tr><td>drift_seconds</td><td>Int</td><td>❌</td><td>3600</td><td>漂移秒数，-86400 到 86400，仅 time_drift 方法有效</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><h4 id="3-5-女巫攻击-simplified-sybil-attack"><a href="#3-5-女巫攻击-simplified-sybil-attack" class="headerlink" title="3.5 女巫攻击 (simplified_sybil_attack)"></a>3.5 女巫攻击 (simplified_sybil_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>fake_node_count</td><td>Int</td><td>❌</td><td>5</td><td>虚假节点数量 (1-20)</td></tr><tr><td>node_type</td><td>String</td><td>❌</td><td>light</td><td>light (轻节点), full (全节点), validator (验证者)</td></tr><tr><td>network</td><td>String</td><td>❌</td><td>testnet</td><td>mainnet, testnet, devnet</td></tr><tr><td>connect_to_real</td><td>Bool</td><td>❌</td><td>True</td><td>是否连接真实节点</td></tr><tr><td>min_connections</td><td>Int</td><td>❌</td><td>3</td><td>最小连接数 (0-10)</td></tr><tr><td>target_nodes</td><td>-</td><td>-</td><td>-</td><td><strong>注意：此策略通常不需要指定具体目标节点</strong></td></tr></tbody></table></div><h4 id="3-6-客户端攻击-geth-lighthouse-attack"><a href="#3-6-客户端攻击-geth-lighthouse-attack" class="headerlink" title="3.6 客户端攻击 (geth_lighthouse_attack)"></a>3.6 客户端攻击 (geth_lighthouse_attack)</h4><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>默认值</td><td>描述/选项</td></tr><tr><td>method</td><td>String</td><td>✅</td><td>-</td><td>process_kill, db_corruption, port_blocking, config_modification</td></tr><tr><td>attack_type</td><td>String</td><td>✅</td><td>-</td><td>geth, lighthouse (指定攻击的客户端类型)</td></tr><tr><td>target_nodes</td><td>Array/Str</td><td>✅</td><td>-</td><td>静态IP列表 或 动态指令</td></tr></tbody></table></div><hr><h3 id="4-目标节点配置-target-nodes"><a href="#4-目标节点配置-target-nodes" class="headerlink" title="4. 目标节点配置 (target_nodes)"></a>4. 目标节点配置 (target_nodes)</h3><p>target_nodes 字段在不同接口下有严格的格式要求。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>接口端点</td><td>格式类型</td><td>数据结构示例</td><td>说明</td></tr><tr><td>/api/simulate</td><td><strong>静态列表</strong></td><td>[“192.168.1.10”, “node_id_123”]</td><td>明确指定要攻击的节点列表。</td></tr><tr><td>/api/simulate/adaptive</td><td><strong>动态指令</strong></td><td>“dynamic:degree:top:5”</td><td>字符串格式，后端自动计算目标。</td></tr></tbody></table></div><p><strong>动态指令语法:</strong> dynamic:{指标}:{选择器}</p><ol><li><p><strong>指标 (Metric)</strong>:</p><ul><li><p>degree (度中心性)</p></li><li><p>betweenness (介数中心性)</p></li><li><p>closeness (接近中心性)</p></li><li><p>eigenvector (特征向量中心性)</p></li></ul></li><li><p><strong>选择器 (Selector)</strong>:</p><ul><li><p>highest (选最高的1个)</p></li><li><p>top:N (选前 N 个，N为数字)</p></li></ul></li></ol><hr><h3 id="5-防护配置-defense-enable"><a href="#5-防护配置-defense-enable" class="headerlink" title="5. 防护配置 (/defense/enable)"></a>5. 防护配置 (/defense/enable)</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段名</td><td>类型</td><td>必填</td><td>示例</td><td>说明</td></tr><tr><td>enabled</td><td>Bool</td><td>❌</td><td>true</td><td>是否启用防护</td></tr><tr><td>rules</td><td>Object</td><td>✅</td><td>{“rate_limit”: 100}</td><td>防护规则字典，具体Key由后端逻辑决定</td></tr></tbody></table></div><hr><h3 id="6-响应结构概览"><a href="#6-响应结构概览" class="headerlink" title="6. 响应结构概览"></a>6. 响应结构概览</h3><p>所有接口通常遵循统一的响应格式：</p><p>codeJSON</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">{<br>  <span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>,  <span class="hljs-string">//</span> 或 <span class="hljs-string">"error"</span><br>  <span class="hljs-string">"message"</span>: <span class="hljs-string">"操作描述"</span>,<br>  <span class="hljs-string">"data"</span>: { <span class="hljs-string">...</span> }       <span class="hljs-string">//</span> 具体业务数据<br>}<br></code></pre></td></tr></table></figure><p><strong>关键数据字段 (data)</strong>:</p><ul><li><p>attack_id: (String) 攻击任务的唯一标识符。</p></li><li><p>status: (Enum) pending, running, completed, failed, stopped, cancelled。</p></li><li><p>logs: (Array[Str]) 攻击日志列表。</p></li></ul><p>{<br>  “nodes”: [<br>    {<br>      “id”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”,<br>      “name”: “Tether USD (USDT)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 5<br>    },<br>    {<br>      “id”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”,<br>      “name”: “USD Coin (USDC)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 3<br>    },<br>    {<br>      “id”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”,<br>      “name”: “Uniswap V3: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 8<br>    },<br>    {<br>      “id”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”,<br>      “name”: “Uniswap V3: SwapRouter02”,<br>      “type”: “SwapRouter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 6<br>    },<br>    {<br>      “id”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”,<br>      “name”: “Uniswap V3: Quoter”,<br>      “type”: “Quoter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”,<br>      “name”: “Uniswap V2: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 7<br>    },<br>    {<br>      “id”: “0x881D40237659C251811CEC9c364ef91dC08D300C”,<br>      “name”: “Curve: 3pool Controller”,<br>      “type”: “CurvePool”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”,<br>      “name”: “Curve: 3pool Gauge”,<br>      “type”: “Gauge”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 2<br>    }<br>  ],<br>  “links”: [<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “type”: “transfer_approve” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap_out” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “type”: “swap_in” },<br>    { “source”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “target”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “type”: “call” },<br>    { “source”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “target”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”, “type”: “quote” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “type”: “approve” },<br>    { “source”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “type”: “deposit” },<br>    { “source”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “target”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”, “type”: “stake” }<br>  ],<br>  “timestamp”: 1765095677.891234,<br>  “data_source”: “real_web3”,<br>  “topology_type”: “contract”<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[ETH前端] --&gt; B[src]<br>    A --&gt; C[package.json]<br>    A --&gt; D[index.html]<br>    A --&gt; E[vite.config.ts]<br>    A --&gt; F[README.md]<br>    A --&gt; G[public]<br>    <br>    B --&gt; H[__tests__]<br>    B --&gt; I[api]<br>    B --&gt; J[assets]<br>    B --&gt; K[components]<br>    B --&gt; L[composables]<br>    B --&gt; M[router]<br>    B --&gt; N[services]<br>    B --&gt; O[types]<br>    B --&gt; P[utils]<br>    B --&gt; Q[views]<br>    B --&gt; R[App.vue]<br>    B --&gt; S[main.ts]<br>    <br>    I --&gt; T[api_docs]<br>    I --&gt; U[attack]<br>    <br>    J --&gt; V[styles]<br>    V --&gt; W[global.css]<br>    V --&gt; X[tailwind.css]<br>    <br>    K --&gt; Y[blockchain]<br>    K --&gt; Z[common]<br>    K --&gt; AA[layout]<br>    K --&gt; AB[tabs]<br>    K --&gt; AC[topology]<br>    <br>    Y --&gt; AD[BlockchainCanvas.vue]<br>    Y --&gt; AE[BlockchainInfoPanel.vue]<br>    Y --&gt; AF[BlockchainModal.vue]<br>    Y --&gt; AG[BlockchainVisualization.vue]<br>    Y --&gt; AH[composables]<br>    Y --&gt; AI[types]<br>    <br>    AH --&gt; AJ[useBlockchainAPI.ts]<br>    AH --&gt; AK[useBlockchainAnimations.ts]<br>    AH --&gt; AL[useBlockchainData.ts]<br>    AH --&gt; AM[useBlockchainEvents.ts]<br>    AH --&gt; AN[useBlockchainRenderer.ts]<br>    AH --&gt; AO[useBlockchainScrolling.ts]<br>    <br>    Z --&gt; AP[ContainerTerminal.vue]<br>    Z --&gt; AQ[DEP-TERM.vue]<br>    Z --&gt; AR[StandaloneTerminal.vue]<br>    Z --&gt; AS[Terminal.vue]<br>    Z --&gt; AT[websocket_terminal8080.vue]<br>    <br>    AA --&gt; AU[DashboardHeader.vue]<br>    AA --&gt; AV[LeftPanel.vue]<br>    AA --&gt; AW[PanelSplitter.vue]<br>    AA --&gt; AX[RightPanel.vue]<br>    <br>    AB --&gt; AY[AttackMonitoringTab.vue]<br>    AB --&gt; AZ[Attack_sys]<br>    AB --&gt; BA[BlockchainBrowserTab.css]<br>    AB --&gt; BB[BlockchainBrowserTab.vue]<br>    AB --&gt; BC[ContainerListTab.vue]<br>    AB --&gt; BD[NetworkTopologyTab.vue]<br>    AB --&gt; BE[sections]<br>    AB --&gt; BF[tabstyle.css]<br>    <br>    AZ --&gt; BG[AttackSystemTab.vue]<br>    BE --&gt; BH[Network-analysis.vue]<br>    BE --&gt; BI[NodeInfoPanel.vue]<br>    BE --&gt; BJ[RealTimeMonitoring.vue]<br>    <br>    AC --&gt; BK[ContractTopology.vue]<br>    AC --&gt; BL[Ethereum_Topology]<br>    AC --&gt; BM[Physical_Topology]<br>    AC --&gt; BN[TopologyVisualization.vue]<br>    AC --&gt; BO[TransactionTopology.vue]<br>    AC --&gt; BP[composables]<br>    AC --&gt; BQ[types]<br>    <br>    BL --&gt; BR[types]<br>    BL --&gt; BS[workers]<br>    BL --&gt; BT[EthereumTopology_new.vue]<br>    BL --&gt; BU[useD3Renderer.ts]<br>    BL --&gt; BV[use_topology_core.ts]<br>    BL --&gt; BW[use_topology_visuals.ts]<br>    <br>    BM --&gt; BX[composables]<br>    BM --&gt; BY[PhysicalTopology.vue]<br>    <br>    BP --&gt; BZ[index.ts]<br>    BP --&gt; CA[topology.css]<br>    BP --&gt; CB[useTopologyAPI.ts]<br>    BP --&gt; CC[useTopologyData.ts]<br>    BP --&gt; CD[useTopologyRendererBase.ts]<br>    <br>    L --&gt; CE[useDashboardData.ts]<br>    L --&gt; CF[useDashboardLayout.ts]<br>    L --&gt; CG[useDashboardTabs.ts]<br>    <br>    M --&gt; CH[index.ts]<br>    <br>    N --&gt; CI[analysis.ts]<br>    N --&gt; CJ[api.ts]<br>    N --&gt; CK[apiService.ts]<br>    N --&gt; CL[attack.ts]<br>    N --&gt; CM[blockchain.ts]<br>    N --&gt; CN[daily-operations.ts]<br>    N --&gt; CO[device-monitoring.ts]<br>    N --&gt; CP[execution.ts]<br>    N --&gt; CQ[foundation.ts]<br>    N --&gt; CR[monitoring.ts]<br>    N --&gt; CS[readme.md]<br>    N --&gt; CT[root-api.ts]<br>    N --&gt; CU[security.ts]<br>    N --&gt; CV[temporal.ts]<br>    N --&gt; CW[topology.ts]<br>    <br>    O --&gt; CX[topology.ts]<br>    <br>    P --&gt; CY[http.ts]<br>    P --&gt; CZ[index.ts]<br>    P --&gt; DA[types.ts]<br>    <br>    Q --&gt; DB[BlockchainTest.vue]<br>    Q --&gt; DC[Dashboard.vue]<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;性能优化 (Web Workers)&lt;/strong&gt;: 目前的数据获取、解析和Diff算法都在&lt;strong&gt;主线程&lt;/strong&gt;运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 &lt;strong&gt;Web Worker&lt;</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-05-字节工训营画布项目相关设计</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/17798.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/17798.html</id>
    <published>2025-12-04T18:00:16.000Z</published>
    <updated>2025-12-25T03:23:33.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BDdraw-DEV"><a href="#BDdraw-DEV" class="headerlink" title="BDdraw_DEV"></a>BDdraw_DEV</h1><p>代码仓库：<br><a href="https://github.com/Zhongye1/BDdraw_DEV">https://github.com/Zhongye1/BDdraw_DEV</a></p><p>现代协同 2D 画布编辑器 · React 18 + TypeScript + Vite + TailwindCSS + Zustand + PixiJS v8</p><h4 id="技术栈-·-Tech-Stack"><a href="#技术栈-·-Tech-Stack" class="headerlink" title="技术栈 · Tech Stack"></a>技术栈 · Tech Stack</h4><p class='item-img' data-src='https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white'><img src="https://img.shields.io/badge/React-18.2.0-61DAFB?logo=react&logoColor=white" alt="React 18"> <img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5" class='item-img' data-src='https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white'><img src="https://img.shields.io/badge/TypeScript-5.3.3-3178C6?logo=typescript&logoColor=white" alt="TypeScript 5"> <img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6" class='item-img' data-src='https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white'><img src="https://img.shields.io/badge/React_Router-6-CA4245?logo=reactrouter&logoColor=white" alt="React Router 6"> <img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate" class='item-img' data-src='https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4'><img src="https://img.shields.io/badge/tailwindcss--animate-1.0.7-06B6D4" alt="animate"> <img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design" class='item-img' data-src='https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white'><img src="https://img.shields.io/badge/Arco_Design-2.66.8-006AFF?logo=arco-design&logoColor=white" alt="Arco Design"> <img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide" class='item-img' data-src='https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white'><img src="https://img.shields.io/badge/Lucide_React-0.554.0-000000?logo=lucide&logoColor=white" alt="Lucide"> <img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer" class='item-img' data-src='https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white'><img src="https://img.shields.io/badge/Immer-10.2.0-00E0C8?logo=immer&logoColor=white" alt="Immer"> <img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8" class='item-img' data-src='https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white'><img src="https://img.shields.io/badge/PixiJS-8.14.3-CC0066?logo=pixijs&logoColor=white" alt="PixiJS v8"> <img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3" class='item-img' data-src='https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white'><img src="https://img.shields.io/badge/Tiptap-3.11.0-1F1F1F?logo=tiptap&logoColor=white" alt="Tiptap v3"> <img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12" class='item-img' data-src='https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white'><img src="https://img.shields.io/badge/Framer_Motion-12.23.24-9D5CFF?logo=framer&logoColor=white" alt="Framer Motion 12"> <img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid" class='item-img' data-src='https://img.shields.io/badge/nanoid-5.1.6-000000'><img src="https://img.shields.io/badge/nanoid-5.1.6-000000" alt="nanoid"> <img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint" class='item-img' data-src='https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white'><img src="https://img.shields.io/badge/ESLint-8.38.0-4B32C3?logo=eslint&logoColor=white" alt="ESLint"> <img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky" class='item-img' data-src='https://img.shields.io/badge/Husky-8.0.3-7711A4'><img src="https://img.shields.io/badge/Husky-8.0.3-7711A4" alt="Husky"> <img src="https://img.shields.io/badge/Deploy-GitHub_Pages-222222?logo=githubpages&logoColor=white" alt="GitHub Pages"></p><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p><strong>frontend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:Zhongye1/BDdraw_DEV.git<br><br><span class="hljs-built_in">cd</span> BDdraw_DEV (进入项目)<br>bun install (安装依赖包)<br>bun start (启动服务)<br></code></pre></td></tr></table></figure><p><strong>backend</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> BDdraw_DEV/ALD_Backend/<br>bun install <span class="hljs-comment">#安装依赖</span><br>bun index.ts  <span class="hljs-comment">#启动后端服务</span><br></code></pre></td></tr></table></figure><p>推荐使用 bun 包管理器，见个人博客</p><p><a href="https://zhongye1.github.io/Arknight-notes/posts/15722.html">关于包管理器 npm,pnpm,yarn 和 bun 以及我为何选择后者</a></p><h4 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h4><p>项目支持通过 Docker 进行容器化部署，使用 Node 22 和 Bun 包管理器。</p><p><strong>开发环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><strong>生产环境部署：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -f docker-compose.prod.yml up -d<br></code></pre></td></tr></table></figure><p>部署完成后，可以通过以下地址访问：</p><ul><li>前端应用: <a href="http://localhost:5000/BDdraw_DEV/">http://localhost:5000/BDdraw_DEV/</a></li><li>后端 API 文档: <a href="http://localhost:3000/swagger-ui">http://localhost:3000/swagger-ui</a></li></ul><h4 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h4><p>项目采用了模块化的架构设计，将不同的功能划分为独立的模块，以方便后续维护和扩展</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>60 FPS 渲染（得益于 PixiJS WebGL）</li><li>完整撤销/重做（Command Pattern + 防抖快照）</li><li>多元素选择与群组操作</li><li>画布元素变换控制器</li><li>富文本所见即所得编辑（WanngEditor + PIXI.HTMLText）</li><li>图片插入 + 内置滤镜（模糊、亮度、灰度等）</li><li>插件式元素系统</li><li>插件式元素系统</li><li>完整的 TypeScript 类型支持</li><li>现代开发体验（Vite + ESLint + Prettier + Husky）</li><li>集成 GitHub-Actions 支持， 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作</li></ul><hr><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>这时候需要简单做一个技术选型分析，根据任务拆解，选择了如下技术栈</p><p><strong>【框架】</strong>【技术方案：采用 React 18 + TypeScript 5 构建应用，React 提供完整的 UI 生态，TypeScript 提供更清晰可靠的类型安全，相比 JavaScript 更易于维护】</p><p><strong>【构建工具】</strong>【技术方案：使用 Vite 5 作为构建工具，其开发服务器启动和热模块替换（HMR）速度明显快于 Webpack】</p><p><strong>【路由】</strong>【技术方案：采用 React Router DOM 6 实现路由管理，API 稳定且文档完善】</p><p><strong>【样式】</strong>【技术方案：使用 Tailwind CSS 3 + PostCSS 处理样式，开发时编写样式更快，生产环境会自动进行 tree-shaking 优化，相比 CSS Modules 和 styled-components 更高效且原子化更直观，对 AI 工具友好】</p><p><strong>【样式扩展】</strong>【技术方案：少量使用 Less 覆盖 Tailwind 主题变量，保持兼容性】</p><p><strong>【SVG 处理】</strong>【技术方案：使用 SVGR 1.5 处理 SVG，Vite 原生支持，可以将 SVG 作为 React 组件使用，比直接使用 SVG 或 SVG sprite 更灵活】</p><p><strong>【UI 组件库】</strong>【技术方案：采用 shadcn/ui（latest）和 Arco Design 2 实现 UI 组件，易于使用，符合字节项目使用字节组件库的习惯】</p><p><strong>【全局状态】</strong>【技术方案：采用 Zustand 4 管理全局状态，API 简洁、性能良好且无样板代码，相比 Redux Toolkit、Pinia、Jotai 代码量更少且配有 Devtools】</p><p><strong>【图形/画布】</strong>【技术方案：使用 PixiJS 8 + pixi-viewport 实现图形和画布功能，基于 WebGL 渲染，适合处理大量精灵元素，相比其他可选方案性能更高】</p><p><strong>【富文本编辑器】</strong>【技术方案：采用 WangEditor 5 作为富文本编辑器，轻量且文档和社区均为中文，相比 Slate/TipTap 等编辑器，默认输出的 HTML 可直接给 PixiJS HTMLText 进行渲染】</p><p><strong>【图标】</strong>【技术方案：使用 Lucide React 图标库，图标数量多、风格统一且支持 Tree-shaking】</p><p><strong>【工具库】</strong>【技术方案：采用 nanoid 3 为画布元素生成唯一标识符等操作，轻量实用】</p><p><strong>【代码质量】</strong>【技术方案：使用 ESLint + Stylelint + Prettier + Husky + lint-staged + commitlint 保证团队代码风格一致，这是中大型项目的基本配置，有利于多人协作开发】</p><p>此外，还配置了 react 开发者工具 react-dev-inspector，配置了一下，开发环境下 ctrl+q 可以实现点击页面上的组件，在 VSCode 中自动跳转到对应文件，并定位到对应行号，方便调试（先前写 vue 也用过类似的）</p><p>项目 <a href="https://react-dev-inspector.zthxxx.me/docs">https://react-dev-inspector.zthxxx.me/docs</a></p><h3 id="功能要素和方案"><a href="#功能要素和方案" class="headerlink" title="功能要素和方案"></a>功能要素和方案</h3><p>分析以上需求，查阅相关资料后，进行各个核心模块的技术方案选型，确定初步实现方案</p><p><strong>【基础渲染引擎】</strong>【技术方案：PixiJS v8（WebGL）提供高性能 2D 渲染，根据不同元素类型创建对应的 Pixi 对象（图形、文本、图像），通过 pixi-viewport 实现无限画布的视口控制，支持缩放、拖拽等交互】</p><p><strong>【无限画布视口】</strong>【技术方案：pixi-viewport（内置 zoom、drag、decelerate、clampZoom）库创建无限画布，在 StageManagerCore.ts 中初始化 viewport，并添加拖拽、缩放等交互功能，支持鼠标中键拖拽画布、滚轮缩放等常见操作】</p><p><strong>【富文本编辑】</strong>【技术方案：WangEditor 5 作为富文本编辑器，提供完整的文本编辑功能，编辑结果以 HTML 格式存储在元素的 text/string 属性中，元素使用 PixiJS 内置的 HTMLText 进行渲染实现富文本效果】</p><p><strong>【状态管理与数据结构】</strong>【技术方案：Zustand 作为全局状态管理库，通过 structuredClone 函数手动创建状态快照，管理画布元素、选中状态、工具类型等，通过中间件监听状态变化并触发重渲染，在特定的 ts 中定义所有状态和操作方法】</p><p><strong>【图片上传显示与滤镜】</strong>【技术方案：PixiJS 内置 Filter 系统包括 BlurFilter、ColorMatrixFilter（黑白、对比度、饱和度）实现图像处理效果，支持模糊、亮度调整、灰度等多种滤镜效果，在 ElementRenderer.ts 中根据元素的 filter 属性应用相应滤镜，支持 blur（模糊）、brightness（亮度）、grayscale（灰度）等滤镜类型】</p><p><strong>【选中与变换系统】</strong>【技术方案：SelectionManager + TransformOverlay（8 个把手 + 旋转把手）实现变换控件渲染，支持单个元素选中和多个元素群组选中，提供 8 个控制点和 1 个旋转点进行变换操作，根据不同元素类型提供不同的控制方式】</p><p><strong>【旋转与组合嵌套】</strong>【技术方案：每个元素维护自己的 matrix（局部矩阵），组合后父容器统一应用矩阵变换，支持多层级嵌套和复杂变换】</p><p><strong>【Minimap】</strong>【技术方案：单独一个小的 Pixi.Application（共享 texture 缓存）实现缩略图功能，主画布所有容器使用 cacheAsBitmap 后生成低分辨率 texture，实时更新到小画布，视口框用一个半透明矩形表示在主画布中的位置】</p><p><strong>【元素永久缓存】</strong>【技术方案：使用 spriteMap 来存储 PIXI 对象，元素更新时只修改属性并设置 container.dirty = true，而不是销毁重建，来解决拖拽中断、光标丢失、闪烁等问题】</p><p><strong>【辅助对齐线】</strong>【技术方案：拖拽时实时遍历所有元素 bounds，计算对齐情况（水平/垂直/间距相等），差值&lt;6px 就吸附并画蓝线，支持水平、垂直对齐以及等间距对齐等多种对齐方式，当距离小于阈值时自动吸附并对齐】</p><p><strong>【Undo/Redo】</strong>【技术方案：Command Pattern + structuredClone 完整快照（每步 before/after）实现撤销/重做功能，通过管理命令栈（undo，redo 栈），使用 structuredClone 创建状态快照，记录操作前后的完整状态，来支持添加元素、删除元素、修改元素属性等操作的撤销/重做，针对拖拽和调整大小操作的命令生成逻辑可能还要具体再处理一套】</p><p><strong>【数据持久化与离线】</strong>【技术方案：Zustand-persist + localForage（IndexedDB）实现数据持久化和离线使用，使用 Zustand 的持久化中间件保存状态，通过 localForage 将数据存储到 IndexedDB 中，实现数据的自动保存和恢复功能】</p><p><strong>【实时协同】</strong>【技术方案：Y.js + y-websocket（或自己写 CRDT）+ Operation Transform 合并策略实现无冲突的实时协同编辑，通过 y-websocket 插件实现服务端同步（问的 AI），有个思路是把操作打给时间 tag，然后然后按时间合并】</p><hr><h4 id="项目架构树"><a href="#项目架构树" class="headerlink" title="项目架构树"></a>项目架构树</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs sh">BDdraw_DEV/<br>├── ALD_Backend/                    <span class="hljs-comment"># 后端服务目录</span><br>│   ├── src/                        <span class="hljs-comment"># 后端源代码</span><br>│   │   ├── api/                    <span class="hljs-comment"># API接口目录</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关API</span><br>│   │   │   │   ├── types/          <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   │   ├── CORE.ts         <span class="hljs-comment"># 核心房间管理逻辑</span><br>│   │   │   │   ├── Room_CRUD.ts    <span class="hljs-comment"># 房间增删改查操作实现</span><br>│   │   │   │   ├── Room_List.ts    <span class="hljs-comment"># 房间列表管理实现</span><br>│   │   │   │   └── Room_users.ts   <span class="hljs-comment"># 房间用户管理实现</span><br>│   │   │   ├── USER_management/    <span class="hljs-comment"># 用户管理相关API</span><br>│   │   │   │   ├── auth_API.ts     <span class="hljs-comment"># 用户认证API实现</span><br>│   │   │   │   └── auth_API_types.ts  <span class="hljs-comment"># 用户认证类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API索引文件</span><br>│   │   ├── auth.ts                 <span class="hljs-comment"># 认证模块实现</span><br>│   │   ├── collab.ts               <span class="hljs-comment"># 协作功能模块实现</span><br>│   │   └── db.ts                   <span class="hljs-comment"># 数据库连接和操作实现</span><br>│   ├── ARCHITECTURE.md             <span class="hljs-comment"># 后端架构说明文档</span><br>│   ├── README.md                   <span class="hljs-comment"># 后端说明文档</span><br>│   ├── index.ts                    <span class="hljs-comment"># 后端服务入口文件</span><br>│   ├── package.json                <span class="hljs-comment"># 后端依赖配置文件</span><br>│   └── tsconfig.json               <span class="hljs-comment"># 后端TypeScript配置</span><br>├── src/                            <span class="hljs-comment"># 前端源代码目录</span><br>│   ├── api/                        <span class="hljs-comment"># 前端API客户端</span><br>│   │   ├── types/                  <span class="hljs-comment"># API类型定义</span><br>│   │   │   ├── Room_management/    <span class="hljs-comment"># 房间管理相关类型定义</span><br>│   │   │   │   ├── Room_CRUD_types.ts  <span class="hljs-comment"># 房间增删改查类型定义</span><br>│   │   │   │   ├── Room_List_types.ts  <span class="hljs-comment"># 房间列表类型定义</span><br>│   │   │   │   ├── Room_users_types.ts <span class="hljs-comment"># 房间用户类型定义</span><br>│   │   │   │   └── index.ts            <span class="hljs-comment"># 类型索引文件</span><br>│   │   │   ├── auth_API_types.ts   <span class="hljs-comment"># 认证相关类型定义</span><br>│   │   │   └── index.ts            <span class="hljs-comment"># API类型索引文件</span><br>│   │   ├── utils/                  <span class="hljs-comment"># API工具函数</span><br>│   │   │   └── apiClient.ts        <span class="hljs-comment"># API客户端工具</span><br>│   │   ├── apiService.ts           <span class="hljs-comment"># API服务封装实现</span><br>│   │   └── index.ts                <span class="hljs-comment"># API索引文件</span><br>│   ├── components/                 <span class="hljs-comment"># React组件目录</span><br>│   │   ├── Richtext_editor/        <span class="hljs-comment"># 富文本编辑器组件</span><br>│   │   │   ├── BottomTextEditor.tsx    <span class="hljs-comment"># 底部文本编辑器实现</span><br>│   │   │   └── Richtext_editor.tsx     <span class="hljs-comment"># 富文本编辑器主组件</span><br>│   │   ├── canvas_toolbar/         <span class="hljs-comment"># 画布工具栏组件</span><br>│   │   │   ├── ContextMenu.tsx     <span class="hljs-comment"># 上下文菜单实现</span><br>│   │   │   └── TopToolbar.tsx      <span class="hljs-comment"># 顶部工具栏实现</span><br>│   │   ├── collaboration/          <span class="hljs-comment"># 协作功能组件</span><br>│   │   │   ├── CollaboratorCursors.tsx <span class="hljs-comment"># 协作者光标显示组件</span><br>│   │   │   └── RemoteSelectionLayer.tsx <span class="hljs-comment"># 远程选择层组件</span><br>│   │   ├── error-page/             <span class="hljs-comment"># 错误页面组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 错误页面实现</span><br>│   │   ├── header/                 <span class="hljs-comment"># 页面头部组件</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 头部内容组件</span><br>│   │   │   │   ├── ExportCanvasModal.tsx   <span class="hljs-comment"># 导出画布模态框</span><br>│   │   │   │   └── StageManagerContext.tsx <span class="hljs-comment"># 舞台管理上下文</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 头部组件入口</span><br>│   │   ├── image-insert-modal/     <span class="hljs-comment"># 图片插入模态框组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 图片插入模态框实现</span><br>│   │   ├── layout/                 <span class="hljs-comment"># 布局组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 布局组件实现</span><br>│   │   ├── minimap/                <span class="hljs-comment"># 小地图组件</span><br>│   │   │   └── Minimap.tsx         <span class="hljs-comment"># 小地图实现</span><br>│   │   ├── property-panel/         <span class="hljs-comment"># 属性面板组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 属性面板实现</span><br>│   │   ├── settings/               <span class="hljs-comment"># 设置组件</span><br>│   │   │   └── setting.tsx         <span class="hljs-comment"># 设置组件实现</span><br>│   │   ├── ui/                     <span class="hljs-comment"># 基础UI组件</span><br>│   │   │   ├── blackwhitebutton.tsx    <span class="hljs-comment"># 黑白按钮组件</span><br>│   │   │   ├── button.tsx          <span class="hljs-comment"># 按钮组件</span><br>│   │   │   ├── icon-circle.tsx     <span class="hljs-comment"># 圆形图标组件</span><br>│   │   │   ├── icon-clear.tsx      <span class="hljs-comment"># 清除图标组件</span><br>│   │   │   ├── icon-rect.tsx       <span class="hljs-comment"># 矩形图标组件</span><br>│   │   │   ├── icon-select.tsx     <span class="hljs-comment"># 选择图标组件</span><br>│   │   │   └── icon-triangle.tsx   <span class="hljs-comment"># 三角形图标组件</span><br>│   │   ├── AnimatedRoutes.tsx      <span class="hljs-comment"># 动画路由组件</span><br>│   │   ├── ParallaxBackground.tsx  <span class="hljs-comment"># 视差背景组件</span><br>│   │   └── WipeTransition.tsx      <span class="hljs-comment"># 擦除过渡动画组件</span><br>│   ├── hooks/                      <span class="hljs-comment"># 自定义React Hooks</span><br>│   │   ├── use-localstorage-state.ts   <span class="hljs-comment"># localStorage状态管理Hook</span><br>│   │   └── use_React_hotkeys_management.ts <span class="hljs-comment"># 快捷键管理Hook</span><br>│   ├── lib/                        <span class="hljs-comment"># 工具库和核心功能模块</span><br>│   │   ├── AddElementCommand.ts    <span class="hljs-comment"># 添加元素命令实现</span><br>│   │   ├── RemoveElementCommand.ts <span class="hljs-comment"># 删除元素命令实现</span><br>│   │   ├── UndoRedoManager.ts      <span class="hljs-comment"># 撤销重做管理器实现</span><br>│   │   ├── UpdateElementCommand.ts <span class="hljs-comment"># 更新元素命令实现</span><br>│   │   ├── UpdateElementPropertyCommand.ts <span class="hljs-comment"># 更新元素属性命令实现</span><br>│   │   ├── constants.ts            <span class="hljs-comment"># 常量定义文件</span><br>│   │   ├── env.ts                  <span class="hljs-comment"># 环境变量配置</span><br>│   │   ├── minimapUtils.ts         <span class="hljs-comment"># 小地图工具函数</span><br>│   │   └── utils.ts                <span class="hljs-comment"># 通用工具函数</span><br>│   ├── pages/                      <span class="hljs-comment"># 页面组件目录</span><br>│   │   ├── auth/                   <span class="hljs-comment"># 认证相关页面</span><br>│   │   │   ├── Login.tsx           <span class="hljs-comment"># 登录页面实现</span><br>│   │   │   └── Register.tsx        <span class="hljs-comment"># 注册页面实现</span><br>│   │   ├── canvas/                 <span class="hljs-comment"># 画布主页面</span><br>│   │   │   ├── Pixi_STM_modules/   <span class="hljs-comment"># Pixi.js状态管理模块</span><br>│   │   │   │   ├── core/           <span class="hljs-comment"># 核心类和初始化逻辑</span><br>│   │   │   │   │   ├── Core_StageManager.ts    <span class="hljs-comment"># 核心舞台管理器</span><br>│   │   │   │   │   ├── ElementRender.ts        <span class="hljs-comment"># 元素渲染器</span><br>│   │   │   │   │   ├── TF_controler_Renderer.ts <span class="hljs-comment"># 变换控制器渲染器</span><br>│   │   │   │   │   └── types.ts                <span class="hljs-comment"># 核心类型定义</span><br>│   │   │   │   ├── interaction/    <span class="hljs-comment"># 交互处理模块</span><br>│   │   │   │   │   ├── Base_InteractionHandler.ts   <span class="hljs-comment"># 基础交互处理器</span><br>│   │   │   │   │   └── Stage_InteractionHandler.ts  <span class="hljs-comment"># 舞台交互处理器</span><br>│   │   │   │   ├── shared/         <span class="hljs-comment"># 共享类型定义</span><br>│   │   │   │   │   └── types.ts    <span class="hljs-comment"># 共享类型定义文件</span><br>│   │   │   │   ├── utils/          <span class="hljs-comment"># 工具函数目录</span><br>│   │   │   │   │   ├── commandUtils.ts      <span class="hljs-comment"># 命令工具函数</span><br>│   │   │   │   │   ├── cursorUtils.ts       <span class="hljs-comment"># 光标工具函数</span><br>│   │   │   │   │   ├── destroyUtils.ts      <span class="hljs-comment"># 销毁工具函数</span><br>│   │   │   │   │   ├── dragUtils.ts         <span class="hljs-comment"># 拖拽工具函数</span><br>│   │   │   │   │   ├── drawingUtils.ts      <span class="hljs-comment"># 绘图工具函数</span><br>│   │   │   │   │   ├── eraserUtils.ts       <span class="hljs-comment"># 橡皮擦工具函数</span><br>│   │   │   │   │   ├── geometryUtils.ts     <span class="hljs-comment"># 几何工具函数</span><br>│   │   │   │   │   ├── guidelineUtils.ts    <span class="hljs-comment"># 辅助线工具函数</span><br>│   │   │   │   │   ├── interactionUtils.ts  <span class="hljs-comment"># 交互工具函数</span><br>│   │   │   │   │   ├── renderUtils.ts       <span class="hljs-comment"># 渲染工具函数</span><br>│   │   │   │   │   ├── resizeUtils.ts       <span class="hljs-comment"># 调整大小工具函数</span><br>│   │   │   │   │   ├── rotationUtils.ts     <span class="hljs-comment"># 旋转工具函数</span><br>│   │   │   │   │   ├── scaleUtils.ts        <span class="hljs-comment"># 缩放工具函数</span><br>│   │   │   │   │   ├── selectionUtils.ts    <span class="hljs-comment"># 选择工具函数</span><br>│   │   │   │   │   └── stateUtils.ts        <span class="hljs-comment"># 状态工具函数</span><br>│   │   │   │   └── STM_modules.md  <span class="hljs-comment"># 状态管理模块说明文档</span><br>│   │   │   ├── Pixi_stageManager.ts    <span class="hljs-comment"># Pixi舞台管理器入口</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 画布页面入口文件</span><br>│   │   ├── home/                   <span class="hljs-comment"># 主页</span><br>│   │   │   ├── contents/           <span class="hljs-comment"># 主页内容组件</span><br>│   │   │   │   └── AKN.tsx         <span class="hljs-comment"># AKN内容组件</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 主页入口文件</span><br>│   │   ├── intro/                  <span class="hljs-comment"># 介绍页面</span><br>│   │   │   └── index.tsx           <span class="hljs-comment"># 介绍页面实现</span><br>│   │   └── room/                   <span class="hljs-comment"># 房间管理页面</span><br>│   │       └── RoomManagement.tsx  <span class="hljs-comment"># 房间管理页面实现</span><br>│   ├── router/                     <span class="hljs-comment"># 路由配置目录</span><br>│   │   └── router.tsx              <span class="hljs-comment"># 路由配置实现</span><br>│   ├── stores/                     <span class="hljs-comment"># 状态存储目录(Zustand)</span><br>│   │   ├── canvasStore.ts          <span class="hljs-comment"># 画布状态存储</span><br>│   │   ├── persistenceStore.ts     <span class="hljs-comment"># 持久化状态存储</span><br>│   │   └── themeStore.ts           <span class="hljs-comment"># 主题状态存储</span><br>│   ├── app.tsx                     <span class="hljs-comment"># 应用根组件</span><br>│   ├── main.tsx                    <span class="hljs-comment"># 应用入口文件</span><br>│   └── vite-env.d.ts               <span class="hljs-comment"># Vite环境声明文件</span><br>├── README.md                       <span class="hljs-comment"># 项目说明文档</span><br>├── components.json                 <span class="hljs-comment"># 组件配置文件</span><br>├── index.html                      <span class="hljs-comment"># HTML入口文件</span><br>├── lint-staged.config.js           <span class="hljs-comment"># Lint-staged配置</span><br>├── package.json                    <span class="hljs-comment"># 项目依赖和脚本配置</span><br>├── postcss.config.js               <span class="hljs-comment"># PostCSS配置</span><br>├── tailwind.config.js              <span class="hljs-comment"># Tailwind CSS配置</span><br>├── transmart.config.ts             <span class="hljs-comment"># Transmart配置</span><br>├── tsconfig.json                   <span class="hljs-comment"># TypeScript配置</span><br>├── tsconfig.node.json              <span class="hljs-comment"># Node.js TypeScript配置</span><br>└── vite.config.ts                  <span class="hljs-comment"># Vite构建配置</span><br></code></pre></td></tr></table></figure><h3 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h3><p>项目采用数据驱动视图（Data-Driven View）模式，使用<strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>的三层架构</p><p>React 只负责 UI 和事件入口<br>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）<br>PixiJS 层只做”渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建<br>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</p><p>项目主要划分为三个层次：渲染层、状态管理层和逻辑层，来实现关注点分离，提高代码的可维护性和可扩展性。</p><h4 id="渲染层"><a href="#渲染层" class="headerlink" title="渲染层"></a><strong>渲染层</strong></h4><p>主要由 PixiJS (WebGL) 负责处理图形渲染，包括创建、更新和删除图形对象。这一层负责将状态管理层的数据转换为可视化的图形元素，并处理用户的交互操作，如拖拽、缩放和旋转等</p><h4 id="状态管理层"><a href="#状态管理层" class="headerlink" title="状态管理层"></a><strong>状态管理层</strong></h4><p>采用 Zustand 管理 JSON 画布数据。<br>先定义一个 CanvasState 接口（JSON 数据结构，包含 id, type, x, y, width, height 等属性）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CanvasState</span> {<br>  <span class="hljs-attr">tool</span>: <span class="hljs-title class_">ToolType</span> <span class="hljs-comment">// 当前工具类型</span><br>  <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt; <span class="hljs-comment">// 画布元素集合</span><br>  <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[] <span class="hljs-comment">// 选中元素ID列表</span><br>  <span class="hljs-attr">editingId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> <span class="hljs-comment">// 正在编辑的元素ID</span><br>  <span class="hljs-attr">clipboard</span>: <span class="hljs-title class_">CanvasElement</span>[] | <span class="hljs-literal">null</span> <span class="hljs-comment">// 剪贴板数据</span><br>  <span class="hljs-attr">pasteOffset</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 粘贴偏移计数</span><br>  <span class="hljs-attr">currentStyle</span>: {<br>    <span class="hljs-attr">fill</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">stroke</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-comment">// ... 其他样式属性</span><br>  }<br>}<br></code></pre></td></tr></table></figure><p>使用 Zustand 状态管理库，其中 elements 被定义为 Record<string, CanvasElement="">类型，表示一个以 id 为键，CanvasElement 为值的对象，用于存储画布上的所有元素。更新元素时使用 structuredClone 函数来克隆状态数据。后续持久化存储和撤销重做机制也是基于这一套状态管理来实现。这一层作为数据核心，主要维护画布上所有元素的状态信息，通过集中管理状态，确保了数据的一致性，便于后续的协同编辑和撤销重做功能的开发。</string,></p><h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a><strong>逻辑层</strong></h4><p>核心是 StageManagerCore 类，通过 StageManagerState 接口管理交互状态，包括当前交互模式、起始位置、当前元素 ID、初始元素状态等，处理多种交互模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">idle - 空闲状态<br>panning - 画布平移<br>selecting - 选择元素<br>dragging - 拖拽元素<br>resizing - 调整元素大小<br>drawing - 绘制元素<br>texting - 文本编辑<br>erasing - 擦除元素<br></code></pre></td></tr></table></figure><p>处理多种元素操作逻辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建元素 - 根据不同工具类型创建相应元素<br>选择元素 - 支持单选和多选<br>拖拽元素 - 记录初始状态，计算偏移量<br>调整大小 - 通过控制手柄调整元素尺寸<br>删除元素 - 通过橡皮擦工具删除元素<br></code></pre></td></tr></table></figure><p>通过这种方式来实现面向对象编程并封装业务逻辑，提高代码的可维护性，利用后续拓展</p><hr><h3 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h3><p class='item-img' data-src='./assets/image-20251123121234358.png'><img src="./assets/image-20251123121234358.png" alt="image-20251123121234358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    A[用户交互] --&gt; B{交互类型}<br>    B --&gt;|创建元素| C[StageManagerCore.onPointerDown]<br>    B --&gt;|拖拽元素| D[StageManagerCore.onPointerMove]<br>    B --&gt;|调整大小| E[StageManagerCore.onHandleDown]<br>    B --&gt;|选择元素| F[StageManagerCore.onPointerUp]<br><br>    C --&gt; G[Zustand Store.addElement]<br>    D --&gt; H[Zustand Store.updateElement]<br>    E --&gt; I[Zustand Store.updateElement]<br>    F --&gt; J[Zustand Store.setSelected]<br><br>    G --&gt; K[Zustand 状态更新]<br>    H --&gt; K<br>    I --&gt; K<br>    J --&gt; K<br><br>    K --&gt; L{状态变化}<br>    L --&gt;|元素变化| M[ElementRenderer.renderElements]<br>    L --&gt;|选择变化| N[TransformerRenderer.renderTransformer]<br><br>    M --&gt; O[PixiJS 图形渲染]<br>    N --&gt; O<br><br>    O --&gt; P[用户看到更新结果]<br><br>    K --&gt; Q[Zustand 持久化]<br>    Q --&gt; R[本地存储/IndexedDB]<br><br>    K --&gt; S[撤销/重做管理]<br>    S --&gt; T[命令栈管理]<br><br>    style A fill:#e1f5fe<br>    style O fill:#e8f5e8<br>    style K fill:#fff3e0<br>    style Q fill:#fce4ec<br></code></pre></td></tr></table></figure><p>流程如下：</p><h4 id="用户交互输入"><a href="#用户交互输入" class="headerlink" title="用户交互输入"></a>用户交互输入</h4><p>所有用户交互事件由 StageManagerCore 处理<br>用户通过鼠标、键盘等方式与画布进行交互：</p><ul><li>创建新元素（点击工具栏选择图形类型后在画布上绘制）</li><li>拖拽元素（选中元素后拖动）</li><li>调整元素大小（拖拽元素控制点）</li><li>选择元素（点击或框选元素）</li></ul><h4 id="创建元素流程"><a href="#创建元素流程" class="headerlink" title="创建元素流程"></a>创建元素流程</h4><ol><li>用户在画布上按下鼠标开始绘制</li><li><a href="">onPointerDown</a>捕获事件，创建新元素</li><li>调用 Zustand store 的<a href="">addElement</a>方法添加元素</li></ol><blockquote><p>创建元素时的中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="拖拽元素流程"><a href="#拖拽元素流程" class="headerlink" title="拖拽元素流程"></a>拖拽元素流程</h4><ol><li>用户按下并拖动已选中的元素</li><li><a href="">onPointerMove</a>持续捕获鼠标移动事件</li><li>实时调用 Zustand store 的<a href="">updateElement</a>更新元素位置</li></ol><blockquote><p>拖拽元素时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="调整大小流程"><a href="#调整大小流程" class="headerlink" title="调整大小流程"></a>调整大小流程</h4><ol><li>用户拖拽元素的控制点（resize handle）</li><li><a href="">onHandleDown</a>捕获控制点拖拽事件</li><li><a href="">onPointerMove</a>计算缩放比例并更新元素大小</li><li>调用 Zustand store 的<a href="">updateElement</a>更新元素属性</li></ol><blockquote><p>调整元素大小时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态</p></blockquote><h4 id="交互结束处理"><a href="#交互结束处理" class="headerlink" title="交互结束处理"></a>交互结束处理</h4><ol><li>用户释放鼠标按键，<a href="">onPointerUp</a>处理交互结束,解锁撤销/重做管理器</li><li>创建相应的命令（<a href="">UpdateElementCommand</a>并添加到命令栈中</li><li>清理临时状态</li></ol><h4 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h4><p>Zustand 作为全局状态管理器，处理所有状态更新：</p><ol><li><strong>状态更新</strong>：自定义一套<a href="">originalSet</a>方法更新状态</li><li><strong>撤销/重做处理</strong>：创建状态快照并生成命令对象</li><li><strong>状态订阅</strong>：通知所有订阅者状态变化</li></ol><h4 id="渲染更新"><a href="#渲染更新" class="headerlink" title="渲染更新"></a>渲染更新</h4><p>Zustand 状态变化触发 StageManagerCore 的订阅回调：</p><ol><li><a href="">ElementRenderer.renderElements</a> 根据元素数据更新 PixiJS 图形对象</li><li><a href="">TransformerRenderer.renderTransformer</a> 更新选中元素的变换控制器</li><li>PixiJS 自动进行渲染</li></ol><h4 id="撤销-重做管理"><a href="#撤销-重做管理" class="headerlink" title="撤销/重做管理"></a>撤销/重做管理</h4><p>通过命令模式实现撤销/重做功能：</p><ol><li>每个操作生成对应的命令对象（<a href="">UpdateElementCommand</a>、<a href="">SnapshotCommand</a>等）</li><li>命令对象保存操作前后的状态快照</li><li>通过<a href="">UndoRedoManager</a>管理命令栈，实现撤销和重做功能</li></ol><h4 id="数据持久化阶段"><a href="#数据持久化阶段" class="headerlink" title="数据持久化阶段"></a>数据持久化阶段</h4><p>Zustand 状态变化同时触发数据持久化：</p><ol><li>状态通过<a href="">persist</a>中间件自动保存到本地存储</li><li>数据存储在 IndexedDB 中，来支持离线使用</li></ol><blockquote><p>这一块还在写</p></blockquote><hr><h3 id="设计的相关考虑"><a href="#设计的相关考虑" class="headerlink" title="设计的相关考虑"></a>设计的相关考虑</h3><p><strong>解耦</strong>：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展</p><p><strong>便于后续的协同编辑</strong>：实现多人协同，要监听 WebSocket 消息，然后更新 Zustand Store。StageManager 可以去监听到 Store 的变化，并作出相应的渲染更新</p><p><strong>对撤销/重做的实现</strong>：因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照</p><p><strong>序列化/反序列化</strong>：保存项目只需 JSON.stringify(store.elements)</p><h4 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h4><p>【待补充】</p><h2 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h2><p>部署地址：<a href="https://zhongye1.github.io/BDdraw_DEV/">https://zhongye1.github.io/BDdraw_DEV/</a></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h4 id="【P0】基础渲染"><a href="#【P0】基础渲染" class="headerlink" title="【P0】基础渲染"></a><del>【P0】基础渲染</del></h4><ul><li><del>支持图形渲染，需要支持至少 3 种不同图形，比如矩形、圆角矩形、圆形、三角形等。需要支持以下图形属性：</del><ul><li><del>背景色（background）</del></li><li><del>边框宽度（border-width）</del></li><li><del>边框颜色（border-color）</del></li></ul></li><li><del>支持图片渲染，需要支持 png、jpeg 格式，支持设置三种简单滤镜</del></li><li><del>支持富文本文字渲染，需要支持以下文本属性：</del><ul><li><del>字体（font-family）</del></li><li><del>字号（font-size）</del></li><li><del>颜色（color）</del></li><li><del>背景色（background）</del></li><li><del>BIUS（加粗、斜体、下划线、删除线）</del></li></ul></li></ul><h4 id="【P0】画布交互"><a href="#【P0】画布交互" class="headerlink" title="【P0】画布交互"></a><del>【P0】画布交互</del></h4><ul><li><del>支持无限画布的缩放、滚动、拖拽</del><ul><li><del>支持无限画布滚动条</del></li><li><del>支持无限画布的 minimap 功能</del></li></ul></li><li><del>支持选区功能：</del><ul><li><del>点击选中单个元素</del></li><li><del>框选选中多个元素</del></li></ul></li><li><del>支持数据持久化，每次操作后自动保存数据，刷新页面数据仍然存在</del></li><li><del>快捷键复制选中元素</del></li><li><del>支持辅助线功能</del></li></ul><h4 id="【P0】调参工具栏"><a href="#【P0】调参工具栏" class="headerlink" title="【P0】调参工具栏"></a><del>【P0】调参工具栏</del></h4><ul><li><del>浮动工具栏</del><ul><li><del>当选中文本元素时出现在上方，支持设置不同文本属性</del>（做了个编辑器）</li><li><del>当选中图形元素时出现在上方，支持设置不同图形属性</del></li><li><del>选中文本元素的部分文字时也能够出现，支持设置局部文本的文本属性</del>（编辑器内编辑可实现）</li></ul></li></ul><h4 id="【P0】元素编辑"><a href="#【P0】元素编辑" class="headerlink" title="【P0】元素编辑"></a><del>【P0】元素编辑</del></h4><ul><li><del>支持双击文本进入编辑，可以输入/删除文本内容</del></li><li><del>支持对选中元素（单个或多个）删除</del></li><li><del>支持对选中元素（单个或多个）拖拽</del></li><li><del>支持对选中元素（单个或多个）缩放</del></li><li><del>支持对选中元素（单个或多个）旋转</del></li><li><del>支持对多个元素进行组合操作，组合可以嵌套</del></li><li><del>支持对多个元素进行打组、解组</del><del>(组操作 bug 复现了，目前在修)</del>（已修复）</li></ul><h4 id="【P0】性能优化"><a href="#【P0】性能优化" class="headerlink" title="【P0】性能优化"></a><del>【P0】性能优化</del></h4><ul><li><del>画布存在 100 个元素，打开页面到渲染完成 &lt; 3s</del></li><li><del>同时操作 100 个元素，FPS 50+</del></li></ul><h4 id="【P1】协同"><a href="#【P1】协同" class="headerlink" title="【P1】协同"></a><del>【P1】协同</del></h4><ul><li><del>支持 undo &amp; redo 操作</del> <del>（大体实现了，可能要修一下 undo，redo 栈，有个不能稳定复现的 bug）</del>（已实现）</li><li><del>支持协同编辑，多人打开同一个画布可以协同编辑</del> (写了个 Node.js 后端)</li><li><del>支持离线编辑，断网后仍然可以对画布编辑，恢复网络后自动提交数据</del>（IndexedDB）</li></ul><blockquote><p>各模块的技术文档补充中<br>此文档最后编辑于 2025.11.27<br>项目开发中，欢迎提 issue 和 pr</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BDdraw-DEV&quot;&gt;&lt;a href=&quot;#BDdraw-DEV&quot; class=&quot;headerlink&quot; title=&quot;BDdraw_DEV&quot;&gt;&lt;/a&gt;BDdraw_DEV&lt;/h1&gt;&lt;p&gt;代码仓库：&lt;br&gt;&lt;a href=&quot;https://github.com/Z</summary>
      
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/Arknight-notes/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="excalidraw" scheme="https://zhongye1.github.io/Arknight-notes/tags/excalidraw/"/>
    
    <category term="github" scheme="https://zhongye1.github.io/Arknight-notes/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-29-JavaScript中的数组方法与栈（Stack）和队列（Queue）的实现</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/28254.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/28254.html</id>
    <published>2025-11-29T08:58:15.000Z</published>
    <updated>2025-12-27T07:27:06.557Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能</p><p>这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在<strong>两端</strong>高效操作的能力</p><p>先简单回顾一下这四种数组方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>操作位置</th><th>操作类型</th><th>返回值</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>push()</code></td><td>尾部</td><td>添加</td><td>新长度</td><td>O(1)</td></tr><tr><td><code>pop()</code></td><td>尾部</td><td>删除</td><td>被删除元素</td><td>O(1)</td></tr><tr><td><code>unshift()</code></td><td>头部</td><td>添加</td><td>新长度</td><td>O(n)</td></tr><tr><td><code>shift()</code></td><td>头部</td><td>删除</td><td>被删除元素</td><td>O(n)</td></tr></tbody></table></div><h3 id="1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）"><a href="#1-实现栈（Stack）——后进先出（LIFO，Last-In-First-Out）" class="headerlink" title="1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）"></a>1. 实现栈（Stack）——后进先出（LIFO，Last In First Out）</h3><p>主要使用数组的<strong>末尾</strong>操作实现：</p><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入栈（push）</td><td>array.push(item)</td><td>stack.push(1)</td><td>O(1)</td></tr><tr><td>出栈（pop）</td><td>array.pop()</td><td>const item = stack.pop()</td><td>O(1)</td></tr></tbody></table></div><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> stack = [];<br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// [1]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// [1, 2]</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>());  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack);        <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><h3 id="2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）"><a href="#2-实现队列（Queue）——先进先出（FIFO，First-In-First-Out）" class="headerlink" title="2. 实现队列（Queue）——先进先出（FIFO，First In First Out）"></a>2. 实现队列（Queue）——先进先出（FIFO，First In First Out）</h3><h4 id="方式一：头部删除-尾部插入"><a href="#方式一：头部删除-尾部插入" class="headerlink" title="方式一：头部删除 + 尾部插入"></a>方式一：<strong>头部删除 + 尾部插入</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队（enqueue）</td><td>array.push(item)</td><td>queue.push(1)</td><td>O(1)</td></tr><tr><td>出队（dequeue）</td><td>array.shift()</td><td>const item = queue.shift()</td><td>O(n)</td></tr></tbody></table></div><p>问题：shift() 会导致数组所有元素向前移动，时间复杂度为 O(n)，频繁操作时性能很差</p><h4 id="方式二：尾部插入-头部删除"><a href="#方式二：尾部插入-头部删除" class="headerlink" title="方式二：尾部插入 + 头部删除"></a>方式二：<strong>尾部插入 + 头部删除</strong></h4><div class="table-container"><table><thead><tr><th>操作</th><th>数组方法</th><th>示例代码</th><th>时间复杂度</th></tr></thead><tbody><tr><td>入队</td><td>array.unshift(item)</td><td>queue.unshift(1)</td><td>O(n)</td></tr><tr><td>出队</td><td>array.pop()</td><td>const item = queue.pop()</td><td>O(1)</td></tr></tbody></table></div><p>同样存在 O(n) 操作</p><p>如果需要高效队列，可以使用<strong>双端队列</strong>实现或第三方库，有几种方式</p><ol><li><strong>使用两个数组模拟</strong>（常见面试实现）：<ul><li>一个栈用于入队，一个栈用于出队，需要时倒腾</li></ul></li><li><strong>使用 JavaScript 的 Deque（双端队列）库</strong>：<ul><li>如 js-deque 或其他库，支持 O(1) 的头尾操作</li></ul></li><li><strong>ES6+ 原生替代</strong>：虽然没有内置 Queue，但可以用 Array + 手动索引模拟环形队列（较复杂）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 中的数组方法完全可以用来实现栈（Stack）和队列（Queue）的基本功能&lt;/p&gt;
&lt;p&gt;这是因为栈和队列本质上是对“插入”和“删除”操作位置的限制，而数组的push、pop、unshift、shift这些方法正好提供了在&lt;strong&gt;两端&lt;/str</summary>
      
    
    
    
    <category term="归档" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-11-27-前端安全Vol.1-关于XSS与CRSF及其相关对策</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/33361.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/33361.html</id>
    <published>2025-11-27T18:05:25.000Z</published>
    <updated>2025-12-27T18:49:21.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跨站脚本攻击（XSS）和跨站请求伪造（CSRF）"><a href="#跨站脚本攻击（XSS）和跨站请求伪造（CSRF）" class="headerlink" title="跨站脚本攻击（XSS）和跨站请求伪造（CSRF）"></a>跨站脚本攻击（XSS）和跨站请求伪造（CSRF）</h3><p>跨站脚本攻击（Cross-Site Scripting，简称 XSS）和跨站请求伪造（Cross-Site Request Forgery，简称 CSRF 或 XSRF）是 Web 应用中最常见的两种安全漏洞。尽管名称相似，但攻击原理、影响和防御方式完全不同。</p><h4 id="1-跨站脚本攻击（XSS）"><a href="#1-跨站脚本攻击（XSS）" class="headerlink" title="1. 跨站脚本攻击（XSS）"></a>1. 跨站脚本攻击（XSS）</h4><p><strong>定义</strong>：XSS 是一种代码注入攻击，攻击者将恶意客户端脚本（通常为 JavaScript）注入到网页中，当受害者访问该页面时，恶意脚本在受害者的浏览器中执行，从而窃取信息或执行恶意操作。</p><p><strong>分类</strong>：XSS 攻击主要分为三种类型。首先是反射型 XSS（Reflected XSS），恶意脚本通过 URL 参数、表单提交等反射回响应页面，常用于钓鱼攻击，例如用户点击含有<script>alert(document.cookie)</script>的链接。其次是存储型 XSS（Stored/Persistent XSS），恶意脚本被永久存储在服务器（如数据库中的评论、帖子），所有访问该内容的用户均受影响，危害最大。最后是基于 DOM 的 XSS（DOM-based XSS），恶意脚本通过客户端 JavaScript 操作 DOM 注入，通常不涉及服务器反射。</p><p><strong>攻击后果</strong>：XSS 攻击可能导致多种严重后果。攻击者可以窃取 Cookie、Session Token，导致会话劫持；伪造请求、钓鱼、键盘记录；还可以对页面进行篡改（Defacement）。</p><p><strong>防御措施</strong>：针对 XSS 攻击有多种防御措施。输出编码（Output Encoding）是在 HTML、JavaScript、CSS、URL 等上下文中对用户输入进行适当转义（如使用 DOMPurify 净化 HTML）；内容安全策略（Content Security Policy, CSP）通过 HTTP 头限制脚本来源；输入验证则是严格验证和过滤用户输入；HttpOnly Cookie 可以防止 JavaScript 访问 Cookie；使用安全库如 DOMPurify、OWASP Java Encoder 等也是有效手段。</p><p><strong>详细防御策略</strong>：在具体实施中，HTML 编码将特殊字符（&lt;、&gt;、&amp;、”、’）转换为 HTML 实体，防止浏览器将其解释为标签。JavaScript 编码在 JavaScript 上下文中使用用户输入前，将特殊字符转义为 JavaScript 字符串或正则表达式格式。CSS 编码在 CSS 上下文中使用用户输入时，需要转义特殊字符。URL 编码则对 URL 参数进行编码，确保 URL 安全。</p><p>CSP 实施示例可以通过 HTTP 头设置：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>default-src 'self';<br>script-src 'self' 'unsafe-inline' https://trusted-cdn.example.com;<br>object-src 'none'; frame-ancestors 'none';<br></code></pre></td></tr></table></figure><p>也可以在 HTML 中设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><br><span class="hljs-tag">  <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Security-Policy"</span></span><br><span class="hljs-tag">  <span class="hljs-attr">content</span>=<span class="hljs-string">"default-src 'self'; script-src 'self' 'unsafe-inline';"</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure><p>使用模板引擎的安全特性也很重要，如 Jinja2、Handlebars 等模板引擎通常内置 XSS 防护，使用时避免使用”raw”或”unsafe”过滤器。同时需要进行严格的输入验证，不仅在服务端验证输入，也要在客户端进行验证（虽然客户端验证可被绕过，但可以改善用户体验）。</p><h4 id="2-跨站请求伪造（CSRF）"><a href="#2-跨站请求伪造（CSRF）" class="headerlink" title="2. 跨站请求伪造（CSRF）"></a>2. 跨站请求伪造（CSRF）</h4><p><strong>定义</strong>：CSRF 是一种利用用户已认证身份的攻击。攻击者诱导已登录的用户在不知情情况下向目标网站发送恶意请求，利用浏览器自动携带 Cookie 的特性执行敏感操作。</p><p><strong>攻击原理</strong>：首先，用户已登录目标网站（如银行网站），浏览器保存了认证 Cookie。然后，攻击者通过钓鱼邮件、恶意网站诱导用户访问含有恶意表单或图像的页面，例如 HTML 中的<code>&lt;img src="https://bank.com/transfer?amount=1000&amp;to=attacker"&gt;</code><br>最后，浏览器自动携带 Cookie 发送请求，完成转账等操作</p><p><strong>攻击后果</strong>：CSRF 攻击可能导致未经授权执行敏感操作（如转账、修改密码、删除账户）。虽然它不直接窃取数据，但可利用用户权限造成破坏。</p><p><strong>防御措施</strong>：针对 CSRF 有多种防御措施。CSRF Token（同步器令牌）是在表单或请求中加入服务器生成的随机 Token，服务器验证 Token 是否匹配且有效，主流框架（如 Django、Spring、Rails）内置支持。SameSite Cookie 是设置 Cookie 的 SameSite 属性（Lax 或 Strict），限制跨站请求携带 Cookie，其中 SameSite=Lax 允许顶级导航（如 GET 链接），阻止大多数 CSRF；SameSite=Strict 完全阻止跨站请求携带 Cookie。双重提交 Cookie（Double Submit Cookie）是将 Token 同时存入 Cookie 和表单，服务器比对两者（适用于无状态应用）。验证 Referer/Origin 头是检查请求来源是否合法（可被伪造或禁用，不推荐单独使用）。使用安全的 HTTP 方法是敏感操作仅允许 POST、PUT、DELETE 等非幂等方法。</p><p><strong>详细防御策略</strong>：CSRF Token 的实现包括几个步骤：服务器生成随机的 CSRF Token（如使用加密安全的随机数生成器）；将 Token 放入表单隐藏字段或 HTTP 头中；用户提交请求时，服务器验证 Token 是否匹配且未过期；Token 应在每次会话或关键操作后更新。</p><p>SameSite Cookie 设置示例包括设置 SameSite 属性：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123;<br>Path=/;<br>HttpOnly;<br>SameSite=Strict<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; Path=/; HttpOnly; SameSite=Lax<br></code></pre></td></tr></table></figure><p>自定义请求头验证要求所有 API 请求包含自定义头部（如 X-Requested-With 或 X-CSRF-Token），因为浏览器在跨站请求中不会自动添加这些头部。验证码机制对高风险操作（如修改密码、转账）要求用户输入验证码或进行二次确认。登出确认在登出页面添加确认步骤，防止攻击者诱导用户登出。</p><h4 id="XSS-与-CSRF-的对比总结"><a href="#XSS-与-CSRF-的对比总结" class="headerlink" title="XSS 与 CSRF 的对比总结"></a>XSS 与 CSRF 的对比总结</h4><div class="table-container"><table><thead><tr><th>项目</th><th>XSS</th><th>CSRF</th></tr></thead><tbody><tr><td>攻击目标</td><td>浏览器中的信任（执行恶意脚本）</td><td>网站对用户的信任（利用已认证会话）</td></tr><tr><td>是否需要注入代码</td><td>是（注入 JavaScript）</td><td>否（仅诱导发送请求）</td></tr><tr><td>主要危害</td><td>窃取数据、会话劫持、页面篡改</td><td>伪造用户操作（如转账、改密）</td></tr><tr><td>典型场景</td><td>用户输入未过滤的评论、搜索框</td><td>登录后访问恶意网站</td></tr><tr><td>核心防御</td><td>输出编码、CSP、输入验证</td><td>CSRF Token、SameSite Cookie</td></tr><tr><td>是否可相互利用</td><td>XSS 可绕过 CSRF 防御（直接读 Token）</td><td>CSRF 无法直接引发 XSS</td></tr></tbody></table></div><p><strong>综合防御策略</strong>：在实际安全防护中，需要采用多种策略。分层防御是结合多种防御措施，而不是依赖单一方法。安全默认值是在系统设计时就考虑安全因素，而不是事后补救。定期安全审计使用自动化工具和手动测试来识别潜在的安全漏洞。开发者培训提高团队对安全问题的认识和防范能力。监控和日志记录可疑活动，及时发现攻击尝试。</p><p><strong>实际应用示例</strong>：在实际开发中，我们通常会组合使用多种防御策略。例如 JavaScript 代码示例中，createSecureForm 函数首先验证输入数据，然后对输出进行编码，最后添加 CSRF Token，这样就结合了多种安全措施。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 一个安全的表单处理示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSecureForm</span>(<span class="hljs-params">data</span>) {<br>  <span class="hljs-comment">// 1. 验证输入数据</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidInput</span>(data)) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Invalid input"</span>);<br>  }<br><br>  <span class="hljs-comment">// 2. 输出编码</span><br>  <span class="hljs-keyword">const</span> safeData = <span class="hljs-title function_">encodeForHTML</span>(data);<br><br>  <span class="hljs-comment">// 3. 添加 CSRF Token</span><br>  <span class="hljs-keyword">const</span> csrfToken = <span class="hljs-title function_">getCSRFToken</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;form method="POST" action="/submit"&gt;</span><br><span class="hljs-string">      &lt;input type="hidden" name="csrf_token" value="<span class="hljs-subst">${csrfToken}</span>"&gt;</span><br><span class="hljs-string">      &lt;div&gt;<span class="hljs-subst">${safeData}</span>&lt;/div&gt;</span><br><span class="hljs-string">      &lt;button type="submit"&gt;提交&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/form&gt;</span><br><span class="hljs-string">  `</span>;<br>}<br><br><span class="hljs-comment">// 通过 CSP 策略进一步保护</span><br><span class="hljs-comment">// Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';</span><br></code></pre></td></tr></table></figure><p>攻击者若成功执行 XSS，可轻松绕过 CSRF Token（通过脚本读取并发送 Token），因此，在 Web 安全开发中，必须同时防御这两种漏洞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;跨站脚本攻击（XSS）和跨站请求伪造（CSRF）&quot;&gt;&lt;a href=&quot;#跨站脚本攻击（XSS）和跨站请求伪造（CSRF）&quot; class=&quot;headerlink&quot; title=&quot;跨站脚本攻击（XSS）和跨站请求伪造（CSRF）&quot;&gt;&lt;/a&gt;跨站脚本攻击（XSS）和跨站</summary>
      
    
    
    
    <category term="前端" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-27-前端学习-关于JavaScript 实现哈希表</title>
    <link href="https://zhongye1.github.io/Arknight-notes/posts/39960.html"/>
    <id>https://zhongye1.github.io/Arknight-notes/posts/39960.html</id>
    <published>2025-11-27T03:31:39.000Z</published>
    <updated>2025-12-26T09:09:52.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-实现哈希表"><a href="#JavaScript-实现哈希表" class="headerlink" title="JavaScript 实现哈希表"></a>JavaScript 实现哈希表</h1><p><strong>哈希表</strong>（Hash Table，散列表）是一种通过键（Key）直接访问值（Value）的数据结构，通过哈希函数将键映射到表中的位置</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 简单的哈希函数示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashString</span>(<span class="hljs-params">key, tableSize</span>) {<br>  <span class="hljs-keyword">let</span> hash = <span class="hljs-number">17</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-property">length</span>; i++) {<br>    hash = (<span class="hljs-number">13</span> * hash * key.<span class="hljs-title function_">charCodeAt</span>(i)) % tableSize;<br>  }<br>  <span class="hljs-keyword">return</span> hash;<br>}<br></code></pre></td></tr></table></figure><h2 id="用-JavaScript-实现哈希表"><a href="#用-JavaScript-实现哈希表" class="headerlink" title="用 JavaScript 实现哈希表"></a>用 JavaScript 实现哈希表</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 哈希函数</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX_LENGTH</span> = <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(key.<span class="hljs-property">length</span>, <span class="hljs-variable constant_">MAX_LENGTH</span>); i++) {<br>      <span class="hljs-keyword">const</span> char = key[i];<br>      <span class="hljs-keyword">const</span> value = char.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">96</span>; <span class="hljs-comment">// a=1, b=2...</span><br>      total = (total * <span class="hljs-variable constant_">PRIME</span> + value) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>;<br>    }<br>    <span class="hljs-keyword">return</span> total;<br>  }<br><br>  <span class="hljs-comment">// 插入键值对</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index] = [];<br>    }<br>    <br>    <span class="hljs-comment">// 检查键是否已存在，存在则更新</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>  }<br><br>  <span class="hljs-comment">// 获取值</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">1</span>];<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-comment">// 删除键值对</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index].<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取所有键</span><br>  <span class="hljs-title function_">keys</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> keysArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!keysArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>])) {<br>            keysArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">0</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> keysArr;<br>  }<br><br>  <span class="hljs-comment">// 获取所有值</span><br>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> valuesArr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i].<span class="hljs-property">length</span>; j++) {<br>          <span class="hljs-keyword">if</span> (!valuesArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>])) {<br>            valuesArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][j][<span class="hljs-number">1</span>]);<br>          }<br>        }<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> valuesArr;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialCapacity = <span class="hljs-number">8</span>, loadFactor = <span class="hljs-number">0.75</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = initialCapacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span> = loadFactor;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>  }<br><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">let</span> hashCode = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;<br>    <br>    <span class="hljs-comment">// 处理不同类型的键</span><br>    <span class="hljs-keyword">const</span> keyStr = <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span> ? key : <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keyStr.<span class="hljs-property">length</span>; i++) {<br>      hashCode = (<span class="hljs-variable constant_">PRIME</span> * hashCode + keyStr.<span class="hljs-title function_">charCodeAt</span>(i)) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>    }<br>    <span class="hljs-keyword">return</span> hashCode;<br>  }<br><br>  <span class="hljs-title function_">_resize</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> oldBuckets = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> *= <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bucket <span class="hljs-keyword">of</span> oldBuckets) {<br>      <span class="hljs-keyword">if</span> (bucket) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> bucket) {<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">set</span>(key, value);<br>        }<br>      }<br>    }<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-comment">// 检查是否需要扩容</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadFactor</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_resize</span>();<br>    }<br><br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index]) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index] = [];<br>    }<br><br>    <span class="hljs-comment">// 更新或添加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-property">length</span>; i++) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">0</span>] === key) {<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index][i][<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>    }<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index].<span class="hljs-title function_">push</span>([key, value]);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">const</span> bucket = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span>[index];<br>    <br>    <span class="hljs-keyword">if</span> (bucket) {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> bucket) {<br>        <span class="hljs-keyword">if</span> (k === key) <span class="hljs-keyword">return</span> v;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(key) !== <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buckets</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 获取负载因子</span><br>  <span class="hljs-title function_">getLoadFactor</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h3 id="支持任何类型键的通用哈希表"><a href="#支持任何类型键的通用哈希表" class="headerlink" title="支持任何类型键的通用哈希表"></a>支持任何类型键的通用哈希表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniversalHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>  }<br><br>  <span class="hljs-comment">// 通用哈希函数，支持多种类型</span><br>  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'number'</span>) {<br>      <span class="hljs-keyword">return</span> key % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span>) {<br>      <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.<span class="hljs-property">length</span>; i++) {<br>        hash = (hash &lt;&lt; <span class="hljs-number">5</span>) - hash + key.<span class="hljs-title function_">charCodeAt</span>(i);<br>        hash = hash &amp; hash; <span class="hljs-comment">// 转为32位整数</span><br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'object'</span> &amp;&amp; key !== <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 对象使用JSON字符串化</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(key));<br>    }<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希解决冲突</span><br>  <span class="hljs-title function_">_hash2</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key) % <span class="hljs-number">7</span>);<br>  }<br><br>  <span class="hljs-comment">// 使用线性探测开放寻址</span><br>  <span class="hljs-title function_">_findSlot</span>(<span class="hljs-params">key, forInsert = <span class="hljs-literal">false</span></span>) {<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);<br>    <span class="hljs-keyword">let</span> step = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">undefined</span>) {<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到键</span><br>      }<br>      <br>      <span class="hljs-keyword">if</span> (forInsert &amp;&amp; (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] === <span class="hljs-literal">undefined</span>)) {<br>        <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 找到可插入的空槽</span><br>      }<br>      <br>      <span class="hljs-comment">// 线性探测</span><br>      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>;<br>      step++;<br>      <br>      <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>.<span class="hljs-property">length</span>) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Hash table is full'</span>);<br>      }<br>    }<br>    <br>    <span class="hljs-keyword">return</span> forInsert ? index : -<span class="hljs-number">1</span>;<br>  }<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">true</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = { key, value };<br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> index !== -<span class="hljs-number">1</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">value</span> : <span class="hljs-literal">undefined</span>;<br>  }<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_findSlot</span>(key, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 标记为删除</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="使用-JavaScript-内置结构"><a href="#使用-JavaScript-内置结构" class="headerlink" title="使用 JavaScript 内置结构"></a>使用 JavaScript 内置结构</h2><p>使用 Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 最简单的哈希表实现</span><br><span class="hljs-keyword">const</span> hashTable = {};<br>hashTable[<span class="hljs-string">'key1'</span>] = <span class="hljs-string">'value1'</span>;<br>hashTable[<span class="hljs-string">'key2'</span>] = <span class="hljs-string">'value2'</span>;<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-keyword">const</span> value = hashTable[<span class="hljs-string">'key1'</span>];<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> hashTable[<span class="hljs-string">'key1'</span>];<br></code></pre></td></tr></table></figure><p>使用 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6 Map 是更好的哈希表实现</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 设置键值对</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'name'</span>, <span class="hljs-string">'Alice'</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">42</span>, <span class="hljs-string">'The Answer'</span>);<br>map.<span class="hljs-title function_">set</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }, <span class="hljs-string">'Object Key'</span>);<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'name'</span>)); <span class="hljs-comment">// Alice</span><br><br><span class="hljs-comment">// 检查是否存在</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br>map.<span class="hljs-title function_">delete</span>(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// 大小</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>);<br><br><span class="hljs-comment">// 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> {<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>});<br><br><span class="hljs-comment">// 清空</span><br>map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>使用 Set（类似哈希集合）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用于存储唯一值</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复，不会被添加</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>);   <span class="hljs-comment">// 2</span><br><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>选择合适的哈希函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 更好的字符串哈希函数（djb2算法）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashDJB2</span>(<span class="hljs-params">str, tableSize</span>) {<br>  <span class="hljs-keyword">let</span> hash = <span class="hljs-number">5381</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) {<br>    hash = (hash * <span class="hljs-number">33</span>) ^ str.<span class="hljs-title function_">charCodeAt</span>(i);<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(hash) % tableSize;<br>}<br></code></pre></td></tr></table></figure><p>优化冲突处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedHashTable</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleted</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'deleted'</span>); <span class="hljs-comment">// 特殊标记删除</span><br>  }<br><br>  <span class="hljs-comment">// 二次探测</span><br>  <span class="hljs-title function_">_probe</span>(<span class="hljs-params">index, i, tableSize</span>) {<br>    <span class="hljs-keyword">return</span> (index + i * i) % tableSize;<br>  }<br><br>  <span class="hljs-comment">// 双重哈希</span><br>  <span class="hljs-title function_">_doubleHash</span>(<span class="hljs-params">index, i, tableSize, key</span>) {<br>    <span class="hljs-keyword">const</span> hash2 = <span class="hljs-number">1</span> + (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash2</span>(key) % (tableSize - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> (index + i * hash2) % tableSize;<br>  }<br>}<br></code></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>频率计数器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">frequencyCounter</span>(<span class="hljs-params">arr</span>) {<br>  <span class="hljs-keyword">const</span> frequency = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) {<br>    frequency.<span class="hljs-title function_">set</span>(item, (frequency.<span class="hljs-title function_">get</span>(item) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> frequency;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'banana'</span>];<br><span class="hljs-keyword">const</span> freq = <span class="hljs-title function_">frequencyCounter</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(freq.<span class="hljs-title function_">get</span>(<span class="hljs-string">'banana'</span>)); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>缓存实现（LRU Cache）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 哈希表 + 维护顺序</span><br>  }<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value); <span class="hljs-comment">// 更新为最近使用</span><br>    <br>    <span class="hljs-keyword">return</span> value;<br>  }<br><br>  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {<br>      <span class="hljs-comment">// 删除最久未使用的</span><br>      <span class="hljs-keyword">const</span> oldestKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(oldestKey);<br>    }<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value);<br>  }<br>}<br></code></pre></td></tr></table></figure><p>分组算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">groupBy</span>(<span class="hljs-params">array, keyFn</span>) {<br>  <span class="hljs-keyword">const</span> groups = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) {<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">typeof</span> keyFn === <span class="hljs-string">'function'</span> <br>      ? <span class="hljs-title function_">keyFn</span>(item) <br>      : item[keyFn];<br>    <br>    <span class="hljs-keyword">if</span> (!groups.<span class="hljs-title function_">has</span>(key)) {<br>      groups.<span class="hljs-title function_">set</span>(key, []);<br>    }<br>    <br>    groups.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">push</span>(item);<br>  }<br>  <br>  <span class="hljs-keyword">return</span> groups;<br>}<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> people = [<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },<br>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> }<br>];<br><br><span class="hljs-keyword">const</span> groupedByAge = <span class="hljs-title function_">groupBy</span>(people, <span class="hljs-string">'age'</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(groupedByAge.<span class="hljs-title function_">get</span>(<span class="hljs-number">25</span>));<br><span class="hljs-comment">// [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }]</span><br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><div class="table-container"><table><thead><tr><th>操作</th><th>Object</th><th>Map</th><th>自定义哈希表</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(1)</td><td>O(1)-O(n)</td></tr><tr><td>遍历键</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div><p>最坏情况（所有键冲突）会退化为 O(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-实现哈希表&quot;&gt;&lt;a href=&quot;#JavaScript-实现哈希表&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 实现哈希表&quot;&gt;&lt;/a&gt;JavaScript 实现哈希表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;哈希表&lt;/s</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zhongye1.github.io/Arknight-notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="前端开发" scheme="https://zhongye1.github.io/Arknight-notes/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
