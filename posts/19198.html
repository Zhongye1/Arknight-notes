<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2026-01-17-力扣百题速练（Javascript、TypeScript）Vol-4 | Zhongye's Blogs</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://picx.zhimg.com/v2-6c94831ec3400e77452e9bd9dde85cb5_r.jpg');
 --light-background: url('https://pica.zhimg.com/v2-0323b00e97b41d914a545c7ccea6ab0a_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Zhongye's Blogs" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2026-01-17-力扣百题速练（Javascript、TypeScript）Vol-4</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2026-01-17T14:53:01.000Z" id="date"> 2026-01-17</time></div></span><br><span>Last Update: <div class="control"><time datetime="2026-01-19T07:28:38.514Z" id="updated"> 2026-01-19</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><p>依旧刷题</p>
<h2 id="30-串联所有单词的字串"><a href="#30-串联所有单词的字串" class="headerlink" title="30.串联所有单词的字串"></a>30.串联所有单词的字串</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong></p>
<p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串</p>
<ul>
<li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么 <code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>， <code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code> 都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li>
</ul>
<p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>s = "barfoothefoobarman", words = ["foo","bar"]</code><br><strong>输出：</strong><code>[0,9]</code><br><strong>解释：</strong><code>因为 words.length == 2</code> 同时 <code>words[i].length == 3</code>，连接的子字符串的长度必须为 6<br>子串 “barfoo” 开始位置是 0。它是 words 中以 <code>["bar","foo"]</code> 顺序排列的连接<br>子串 “foobar” 开始位置是 9。它是 words 中以 <code>["foo","bar"]</code> 顺序排列的连接<br>输出顺序无关紧要。返回 <code>[9,0]</code> 也是可以的</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong><code>s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]</code><br><strong>输出：</strong><code>[]</code><br><strong>解释：</strong> 因为 <code>words.length == 4</code> 并且 <code>words[i].length == 4</code>，所以串联子串的长度必须为 16<br>s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。<br>所以我们返回一个空数组。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> <code>s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]</code><br><strong>输出：</strong> <code>[6,9,12]</code><br><strong>解释：</strong> 因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9<br>子串 “foobarthe” 开始位置是 6。它是 words 中以 <code>["foo","bar","the"]</code> 顺序排列的连接<br>子串 “barthefoo” 开始位置是 9。它是 words 中以 <code>["bar","the","foo"]</code> 顺序排列的连接<br>子串 “thefoobar” 开始位置是 12。它是 words 中以 <code>["the","foo","bar"]</code> 顺序排列的连接</p>
<p>滑动窗口 + 哈希表解题</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findSubstring</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">words</span>: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || words.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-keyword">const</span> wordLen = words[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; <span class="hljs-comment">// 每个单词长度</span><br>    <span class="hljs-keyword">const</span> totalLen = wordLen * words.<span class="hljs-property">length</span>; <span class="hljs-comment">// 总共需要匹配的长度</span><br>    <span class="hljs-keyword">const</span> wordCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;(); <span class="hljs-comment">// 目标单词的频率表</span><br><br>    <span class="hljs-comment">// 统计目标单词出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) {<br>        wordCount.<span class="hljs-title function_">set</span>(word, (wordCount.<span class="hljs-title function_">get</span>(word) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-comment">// 对每一种可能的起点偏移量进行滑动窗口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++) {<br>        <span class="hljs-comment">// 当前窗口内已经匹配到的单词数</span><br>        <span class="hljs-keyword">let</span> matchCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当前窗口的单词频率统计（临时）</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-variable language_">window</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;();<br><br>        <span class="hljs-comment">// 滑动窗口右边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = i; right + wordLen &lt;= s.<span class="hljs-property">length</span>; right += wordLen) {<br>            <span class="hljs-comment">// 取出当前单词</span><br>            <span class="hljs-keyword">const</span> word = s.<span class="hljs-title function_">substring</span>(right, right + wordLen);<br><br>            <span class="hljs-comment">// 如果这个单词根本不在目标集合里，直接跳过整个窗口</span><br>            <span class="hljs-keyword">if</span> (!wordCount.<span class="hljs-title function_">has</span>(word)) {<br>                <span class="hljs-comment">// 重置窗口</span><br>                <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">clear</span>();<br>                matchCount = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            }<br><br>            <span class="hljs-comment">// 记录当前窗口单词出现次数</span><br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">set</span>(word, (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(word) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 如果当前单词出现次数 ≤ 需要的次数，匹配数+1</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(word)! &lt;= wordCount.<span class="hljs-title function_">get</span>(word)!) {<br>                matchCount++;<br>            }<br><br>            <span class="hljs-comment">// 窗口大小超过目标长度，需要左移</span><br>            <span class="hljs-keyword">if</span> (right - i + wordLen &gt; totalLen) {<br>                <span class="hljs-keyword">const</span> leftWord = s.<span class="hljs-title function_">substring</span>(i, i + wordLen);<br>                <span class="hljs-keyword">if</span> (wordCount.<span class="hljs-title function_">has</span>(leftWord)) {<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(leftWord)! &lt;= wordCount.<span class="hljs-title function_">get</span>(leftWord)!) {<br>                        matchCount--;<br>                    }<br>                    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">set</span>(leftWord, <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(leftWord)! - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(leftWord) === <span class="hljs-number">0</span>) {<br>                        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">delete</span>(leftWord);<br>                    }<br>                }<br>                i += wordLen; <span class="hljs-comment">// 左边界移动</span><br>            }<br><br>            <span class="hljs-comment">// 完美匹配</span><br>            <span class="hljs-keyword">if</span> (matchCount === words.<span class="hljs-property">length</span>) {<br>                result.<span class="hljs-title function_">push</span>(i);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> </li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。<br>必须原地修改，只允许使用额外常数空间。</p>
<p><strong>示例 1：</strong><br><strong>输入：</strong><code>nums = [1,2,3]</code><br><strong>输出：</strong><code>[1,3,2]</code></p>
<p><strong>示例 2：</strong><br><strong>输入：</strong><code>nums = [3,2,1]</code><br><strong>输出：</strong><code>[1,2,3]</code></p>
<p><strong>示例 3：</strong><br><strong>输入：</strong><code>nums = [1,1,5]</code><br><strong>输出：</strong><code>[1,5,1]</code></p>
<p>从右向左，找到第一个位置i，使得<code>nums[i] &lt; nums[i+1]</code>，那么<code>nums[i :-1]</code>就是我们需要变换的区域<br>在<code>nums[i+1 : -1]</code>自右向左中找到第一个大于<code>nums[i]</code>的元素，将它与<code>nums[i]</code>交换，此时<code>nums[i+1 : -1]</code>是降序的<br>将<code>nums[i+1 : -1]</code>升序排列，即将它们逆序</p>
<p><strong>解题的话，这道题目其实是一道找规律的题目</strong></p>
<p>对比一下这两个数字，探究一下是怎样变化的：<br>143652<br>145236</p>
<p>后四位都发生了改变，以保证让这个数大一点点。观察到前两位是没有变化的，也就是如果这个数字是3652，那么下一个排列也是5236，与前面的数字暂时无关。<br>所以，我们其实要关注的是最小的变换区域。这个区域应该是从右向左找，以确保变换后的排列与当前的排列是紧邻的。那么怎样找到这一区域呢？</p>
<p>为什么52不能是变换区域？因为52已经是这两个数字能组成的最大排列了，所以没法再进一步变大，因此不能变换<br>以此类推，为什么652也不能是变换区域呢？同样是因为已经达到了最大排列</p>
<p>总结一下，降序排列的部分已经达到了最大的排列，不能再增大。也正是处于这一点，我们最终找到了3652，其中3与6不是降序排列的，并且是从右向左查找过程中的第一个升序段，以保证变换的区域最小。</p>
<p><strong>如何变换？</strong><br>我们已经弄清楚了怎样确定变换区域，因此下面将目光集中到这一小段上：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3652 </span>——&gt; <span class="hljs-number">5236</span><br></code></pre></td></tr></table></figure>
<p>我们想要让3652增大，但只增大最小的幅度。由于652已经达到最大，因此以3开头已经达到最大了，所以如果想继续增大，不能再以3开头，要在剩下的数字中比3大、但是只能大一点点的数字进行开头，所以这个数字应该是大于3的数字中最小的，也就是5</p>
<p>现在已经知道了要怎样找下一个开头，接下来仅剩的问题就是除了开头以外的数字怎样排列。换了一个开头，现在其实需要的是这个新的开头的最小排列，因此剩下的数字升序排列就是符合要求的</p>
<p><strong>算法总结</strong></p>
<p><strong>从右向左，找到第一个位置i，使得<code>nums[i] &lt; nums[i+1]</code>，那么<code>nums[i :-1]</code>就是我们需要变换的区域</strong><br><strong>在<code>nums[i+1 : -1]</code>自右向左中找到第一个大于<code>nums[i]</code>的元素，将它与<code>nums[i]</code>交换，此时<code>nums[i+1 : -1]</code>是降序的</strong><br><strong>将<code>nums[i+1 : -1]</code>升序排列，即将它们逆序</strong></p>
<p>感觉面试根本现场想不到，解题思路要背</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextPermutation</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">void</span> {<br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) {<br>            index = i;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt; index; j--) {<br>        <span class="hljs-keyword">if</span> (nums[j] &gt; nums[index]) {<br>            [nums[index], nums[j]] = [nums[j], nums[index]];<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-keyword">let</span> left = index + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) {<br>        [nums[left], nums[right]] = [nums[right], nums[left]];<br>        left++;<br>        right--;<br>    }<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。</p>
<p>左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 <code>"(()())"</code>。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>s = "(()"</code><br><strong>输出：</strong><code>2</code><br><strong>解释：</strong> 最长有效括号子串是 “()”</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong><code>s = ")()())"</code><br><strong>输出：</strong><code>4</code><br><strong>解释：</strong> 最长有效括号子串是 “()()”</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong><code>s = ""</code><br><strong>输出：</strong><code>0</code></p>
<p>解题的话用栈记录「还没匹配的左括号下标」+ 「上一个有效结束位置」<br>遇到右括号就计算长度，并更新 max_len</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">case</span>     栈操作                 何时更新答案                     长度怎么算<br>──────   ──────────────────     ─────────────────────────────   ────────────<br>遇 <span class="hljs-string">'('</span>   stack.<span class="hljs-built_in">push</span>(i);         不更新                          —<br>遇 <span class="hljs-string">')'</span>   先 <span class="hljs-built_in">pop</span>()               —                               —<br>         ① 弹成功，栈还有东西   更新答案                        i - stack.<span class="hljs-built_in">top</span>()<br>         ② 弹成功，栈空了       更新答案                        i - (<span class="hljs-number">-1</span>) 即 i+<span class="hljs-number">1</span><br>         ③ 弹失败（栈本来就空） 不更新，把自己当新墙            stack.<span class="hljs-built_in">push</span>(i);<br></code></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestValidParentheses</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">"("</span>) {<br>            stack.<span class="hljs-title function_">push</span>(i);<br>        } <span class="hljs-keyword">else</span> {<br>            stack.<span class="hljs-title function_">pop</span>();<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>                stack.<span class="hljs-title function_">push</span>(i);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">const</span> length = i - stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>                maxLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLen, length);<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> maxLen;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>向左旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 下标 <code>3</code> 上向左旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>nums = [4,5,6,7,0,1,2], target = 0</code><br><strong>输出：</strong><code>4</code></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong><code>nums = [4,5,6,7,0,1,2], target = 3</code><br><strong>输出：</strong><code>-1</code></p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> <code>nums = [1], target = 0</code><br><strong>输出：</strong> <code>-1</code></p>
<p>主要就是二分的思想，从left和right出发，在 while(left &lt;= right) 循环中，每次计算 mid 后</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">if</span> nums[<span class="hljs-built_in">mid</span>] == target → 直接返回 <span class="hljs-built_in">mid</span><br><br>否则进行分支判断：<br><br>情况<span class="hljs-number">1</span>：nums[<span class="hljs-built_in">left</span>] &lt;= nums[<span class="hljs-built_in">mid</span>]    ← 左半部分 [left...mid] 是升序的<br>    此时左边这段是连续有序的<br>    判断 target 是否落在这段有序区间内：<br>        如果 nums[<span class="hljs-built_in">left</span>] &lt;= target &lt; nums[<span class="hljs-built_in">mid</span>]  → target 在左半 → <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span><br>        否则                                 → target 不在左半 → <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span><br><br>情况<span class="hljs-number">2</span>：nums[<span class="hljs-built_in">left</span>] &gt; nums[<span class="hljs-built_in">mid</span>]     ← 左半部分无序，则右半部分 [mid...right] 必然有序<br>    判断 target 是否落在右半有序区间内：<br>        如果 nums[<span class="hljs-built_in">mid</span>] &lt; target &lt;= nums[<span class="hljs-built_in">right</span>]  → target 在右半 → <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span><br>        否则                                 → target 不在右半 → <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>算法实现如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">search</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(left + right / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (nums[mid] === nums[target]) {<br>        <span class="hljs-keyword">return</span> nums[target];<br>    }<br><br>    <span class="hljs-comment">// 判断左半边是否有序</span><br>    <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) {<br>        <span class="hljs-comment">// 左半边有序</span><br>        <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) {<br>            <span class="hljs-comment">// target 在有序的左半边</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// target 在可能无序的右半边</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        }<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">// 右半边有序</span><br>        <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) {<br>            <span class="hljs-comment">// target 在有序的右半边</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// target 在可能无序的左半边</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="34-在排序数组中找出元素的第一个与最后一个位置"><a href="#34-在排序数组中找出元素的第一个与最后一个位置" class="headerlink" title="34.在排序数组中找出元素的第一个与最后一个位置"></a>34.在排序数组中找出元素的第一个与最后一个位置</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>nums = [</code>5,7,7,8,8,10]<code>, target = 8</code><br><strong>输出：</strong><code>[3,4]</code></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong><code>nums = [</code>5,7,7,8,8,10]<code>, target = 6</code><br><strong>输出：</strong><code>[-1,-1]</code></p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong><code>nums = [], target = 0</code><br><strong>输出：</strong><code>[-1,-1]</code></p>
<p>主要就是二分的思想</p>
<p>从left和right出发,在 while(left &lt;= right) 循环中，每次计算 mid<br><code>if nums[mid] == target</code>,找到任意一个 target 后，向两侧暴力扩展</p>
<p>以当前 mid 作为初始的左右指针起点（lindex = mid, rindex = mid）<br>向左扫描：只要左边相邻位置仍然等于 target，就继续左移<br>向右扫描：只要右边相邻位置仍然等于 target，就继续右移</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] {<br>    <span class="hljs-keyword">let</span> lf = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> rg = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (lf &lt;= rg) {<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((lf + rg) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] === target) {<br>            <span class="hljs-keyword">let</span> lindex = mid;<br>            <span class="hljs-keyword">let</span> rindex = mid;<br>            <span class="hljs-keyword">while</span> (lindex &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[lindex - <span class="hljs-number">1</span>] === target) {<br>                lindex--;<br>            }<br>            <span class="hljs-keyword">while</span> (rindex &lt; nums.<span class="hljs-property">length</span> &amp;&amp; nums[rindex + <span class="hljs-number">1</span>] === target) {<br>                rindex++;<br>            }<br>            <span class="hljs-keyword">return</span> [lindex, rindex];<br>        }<br>        <span class="hljs-keyword">if</span> (target &gt; nums[mid]) {<br>            lf = mid + <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) {<br>            rg = mid - <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> <code>nums = [1,3,5,6], target = 5</code><br><strong>输出:</strong> <code>2</code></p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> <code>nums = [1,3,5,6], target = 2</code><br><strong>输出:</strong> <code>1</code></p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> <code>nums = [1,3,5,6], target = 7</code><br><strong>输出:</strong> <code>4</code></p>
<p>非常经典的二分查找</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) {<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] === target) {<br>            <span class="hljs-keyword">return</span> mid;<br>        }<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) {<br>            right = mid - <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            left = mid + <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> left;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="36-有趣的数独"><a href="#36-有趣的数独" class="headerlink" title="36.有趣的数独"></a>36.有趣的数独</h2><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 <code>'.'</code> 表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p class='item-img' data-src='https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png'><img src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt=""></p>
<p><strong>输入：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs prolog">board =<br>[[<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>]<br>,[<span class="hljs-string">"4"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>]<br>,[<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"5"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>]]<br></code></pre></td></tr></table></figure>
<p><strong>输出：</strong> true</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs prolog">board =<br>[[<span class="hljs-string">"8"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>]<br>,[<span class="hljs-string">"4"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>]<br>,[<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"5"</span>]<br>,[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>]]<br></code></pre></td></tr></table></figure>
<p><strong>输出：</strong> false<br><strong>解释：</strong> 除了第一行的第一个数字从 <strong>5</strong> 改为 <strong>8</strong> 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p>
<p>解法很通俗</p>
<p>判断数组有无重复项直接用这个</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicate</span> = (<span class="hljs-params">nums</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(nums).<span class="hljs-property">size</span> !== nums.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params"><span class="hljs-attr">board</span>: <span class="hljs-built_in">string</span>[][]</span>): <span class="hljs-built_in">boolean</span> {<br>    <span class="hljs-keyword">let</span> vali = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ine = <span class="hljs-number">0</span>; ine &lt; <span class="hljs-number">9</span>; ine++) {<br>        <span class="hljs-title function_">linevali</span>(ine);<br>        <span class="hljs-title function_">rowvali</span>(ine);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-title function_">nnvali</span>(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>);<br>    }<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">KT</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>) {<br>            vali = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">linevali</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">let</span> stk = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {<br>            <span class="hljs-keyword">if</span> (board[num][i] !== <span class="hljs-string">"."</span>) {<br>                stk.<span class="hljs-title function_">push</span>(board[num][i]);<br>            }<br>        }<br>        <span class="hljs-title function_">KT</span>(stk);<br>    }<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">rowvali</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">let</span> stk = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {<br>            <span class="hljs-keyword">if</span> (board[i][num] !== <span class="hljs-string">"."</span>) {<br>                stk.<span class="hljs-title function_">push</span>(board[i][num]);<br>            }<br>        }<br>        <span class="hljs-title function_">KT</span>(stk);<br>    }<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">nnvali</span>(<span class="hljs-params"><span class="hljs-attr">HT</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">ST</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">let</span> stk = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) {<br>                <span class="hljs-keyword">if</span> (board[<span class="hljs-variable constant_">HT</span> + i][<span class="hljs-variable constant_">ST</span> + j] !== <span class="hljs-string">"."</span>) {<br>                    stk.<span class="hljs-title function_">push</span>(board[<span class="hljs-variable constant_">HT</span> + i][<span class="hljs-variable constant_">ST</span> + j]);<br>                }<br>            }<br>        }<br>        <span class="hljs-title function_">KT</span>(stk);<br>    }<br>    <span class="hljs-keyword">return</span> vali;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h2><p>（TODO）</p>
<hr>
<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h2><p>「外观数列」是一个数位字符串序列，由递归公式定义：</p>
<ul>
<li><code>countAndSay(1) = "1"</code></li>
<li><code>countAndSay(n)</code> 是 <code>countAndSay(n-1)</code> 的行程长度编码。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940">行程长度编码</a>（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串 <code>"3322251"</code> ，我们将 <code>"33"</code> 用 <code>"23"</code> 替换，将 <code>"222"</code> 用 <code>"32"</code> 替换，将 <code>"5"</code> 用 <code>"15"</code> 替换并将 <code>"1"</code> 用 <code>"11"</code> 替换。因此压缩后字符串变为 <code>"23321511"</code>。</p>
<p>给定一个整数 <code>n</code> ，返回 <strong>外观数列</strong> 的第 <code>n</code> 个元素。</p>
<p><strong>示例 1：</strong><br><strong>输入：</strong><code>n = 4</code><br><strong>输出：</strong><code>"1211"</code></p>
<p><strong>解释：</strong><br>countAndSay(1) = “1”<br>countAndSay(2) = “1” 的行程长度编码 = “11”<br>countAndSay(3) = “11” 的行程长度编码 = “21”<br>countAndSay(4) = “21” 的行程长度编码 = “1211”</p>
<p><strong>示例 2：</strong><br><strong>输入：</strong><code>n = 1</code><br><strong>输出：</strong><code>"1"</code></p>
<p><strong>解释：</strong><br>这是基本情况。</p>
<p>解题的主要步骤：</p>
<ol>
<li>从初始字符串 “1” 开始</li>
<li>每一轮生成新字符串时：<ul>
<li>遍历上一轮字符串</li>
<li>统计<strong>连续相同字符</strong>的个数</li>
<li>遇到不同字符就把「计数+前一个字符」拼接到结果中</li>
<li>最后一组也加上</li>
</ul>
</li>
<li>重复 n-1 次</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countAndSay</span>(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-string">"1"</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">let</span> next = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; current.<span class="hljs-property">length</span>; j++) {<br>            <span class="hljs-keyword">if</span> (current[j] === current[j - <span class="hljs-number">1</span>]) {<br>                count++;<br>            } <span class="hljs-keyword">else</span> {<br>                next += count + current[j - <span class="hljs-number">1</span>];<br>                count = <span class="hljs-number">1</span>;<br>            }<br>        }<br><br>        next += count + current[current.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>        current = next;<br>    }<br><br>    <span class="hljs-keyword">return</span> current;<br>}<br><span class="hljs-comment">//runtime:5 ms</span><br><span class="hljs-comment">//memory:58.6 MB</span><br></code></pre></td></tr></table></figure>
<hr>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>candidates = [2,3,6,7], target = 7</code><br><strong>输出：</strong><code>[[2,2,3],[7]]</code><br><strong>解释：</strong><br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次<br>7 也是一个候选， 7 = 7<br>仅有这两种组合</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入:</strong> <code>candidates = [2,3,5], target = 8</code><br><strong>输出:</strong> <code>[[2,2,2,2],[2,3,3],[3,5]]</code></p>
<p><strong>示例 3：</strong></p>
<p><strong>输入:</strong> <code>candidates = [2], target = 1</code><br><strong>输出:</strong> <code>[]</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params"><span class="hljs-attr">candidates</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[][] {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span>[][] = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>    candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bt</span>(<span class="hljs-params"><span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">remain</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">if</span> (remain === <span class="hljs-number">0</span>) {<br>            result.<span class="hljs-title function_">push</span>([...path]);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (remain &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.<span class="hljs-property">length</span>; i++) {<br>            <span class="hljs-keyword">if</span> (candidates[i] &gt; remain) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            path.<span class="hljs-title function_">push</span>(candidates[i]);<br>            <span class="hljs-title function_">bt</span>(i, remain - candidates[i]);<br>            path.<span class="hljs-title function_">pop</span>();<br>        }<br>    }<br>    <span class="hljs-title function_">bt</span>(<span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/57550.html">← Next 2026-01-19-力扣百题速练（Javascript、TypeScript）Vol-5</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/56232.html">2026-01-16-记录关于论文细化的方法论 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">Zhongye</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%97%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">30.串联所有单词的字串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">31.下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">3.</span> <span class="toc-text">32. 最长有效括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">33.搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8E%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.1.</span> <span class="toc-text">34.在排序数组中找出元素的第一个与最后一个位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">35.搜索插入位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E7%8B%AC"><span class="toc-number">6.</span> <span class="toc-text">36.有趣的数独</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-number">7.</span> <span class="toc-text">37.解数独</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">38.外观数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">9.</span> <span class="toc-text">39.组合总和</span></a></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><!-- ── 访客信息获取脚本（建议放在页面底部 layout/_partial/after-footer.pug 或单独引入） ──--><script>(function() {
  const MAX_RETRY = 1;
  let retryCount = 0;

  async function fetchVisitorInfo() {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort(new Error('Request timeout after 1000ms'));
    }, 1000);

    try {
      const response = await fetch('https://ipapi.co/json/', {
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const data = await response.json();

      document.getElementById('visitor-ip').textContent = data.ip || '无法获取';
      
      const parts = [];
      if (data.city) parts.push(data.city);
      if (data.region) parts.push(data.region);
      if (data.country_name) parts.push(data.country_name);
      
      document.getElementById('visitor-location').textContent = 
        parts.length > 0 ? parts.join(' - ') : '未知地区';

    } catch (err) {
      clearTimeout(timeoutId);

      // 如果是超时错误，且还有重试次数，则重试一次
      if (err.name === 'AbortError' && retryCount < MAX_RETRY) {
        retryCount++;
        // 可选：显示「正在重试...」提示
        document.getElementById('visitor-ip').textContent = '超时，正在重试...';
        document.getElementById('visitor-location').textContent = '——';
        
        // 立即重试（也可加个很短的延迟，如 300ms）
        setTimeout(fetchVisitorInfo, 300);
        return;
      }

      // 最终失败
      document.getElementById('visitor-ip').textContent = '████';
      document.getElementById('visitor-location').textContent = '████';
    }
  }

  // 页面加载完成后获取访客信息
  fetchVisitorInfo();

  // 添加对PJAX事件的监听，以便在页面切换后重新获取访客信息
  document.addEventListener('pjax:complete', function() {
    // 延迟执行，确保DOM已经更新完成
    setTimeout(fetchVisitorInfo, 100);
  });
})();</script></main><canvas id="canvas-dust"></canvas></body></html>