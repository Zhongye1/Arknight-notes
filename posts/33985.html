<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构-栈 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>数据结构-栈</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-04-17T16:17:37.000Z" id="date"> 2025-04-18</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-04-22T07:35:17.967Z" id="updated"> 2025-04-22</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><h1 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h1><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p><strong>栈</strong>：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。<br class='item-img' data-src='https://pic1.zhimg.com/80/v2-a1d987369534eb6c471da568be4aa5cd_720w.png'><img src="https://pic1.zhimg.com/80/v2-a1d987369534eb6c471da568be4aa5cd_720w.png" alt="img"><br><strong>栈顶</strong>（Top）：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>（Bottom)：固定的，不允许进行插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p>
<p>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</p>
<h3 id="栈的常见基本操作"><a href="#栈的常见基本操作" class="headerlink" title="栈的常见基本操作"></a>栈的常见基本操作</h3><p><strong>InitStack(&amp;S)</strong>：初始化一个空栈S</p>
<p><strong>StackEmpty(S)</strong>：判断一个栈是否为空，若栈为空则返回true，否则返回false</p>
<p><strong>Push(&amp;S, x)</strong>：进栈（栈的插入操作），若栈S未满，则将x加入使之成为新栈顶</p>
<p><strong>Pop(&amp;S, &amp;x)</strong>：出栈（栈的删除操作），若栈S非空，则弹出栈顶元素，并用x返回</p>
<p><strong>GetTop(S, &amp;x)</strong>：读栈顶元素，若栈S非空，则用x返回栈顶元素</p>
<p><strong>DestroyStack(&amp;S)</strong>：栈销毁，并释放S占用的存储空间（“&amp;”表示引用调用）</p>
<h1 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h1><h4 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h4><p>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br>若存储栈的长度为MAXSIZE，则栈顶位置top必须小于MAXSIZE。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。<br>栈的顺序存储结构可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 5  </span><br><span class="hljs-comment">//定义栈中元素的最大个数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span>&#123;</span><br>    <span class="hljs-type">int</span> data[MAXSIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure>
<p>若现在有一个栈，MAXSIZE是5，则栈的普通情况、空栈、满栈的情况分别如下图所示：</p>
<p class='item-img' data-src='https://picx.zhimg.com/80/v2-b667691c4e541ad1b4d77611d936ef7e_720w.png'><img src="https://picx.zhimg.com/80/v2-b667691c4e541ad1b4d77611d936ef7e_720w.png" alt="img"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack* S)</span>&#123; <br>    <span class="hljs-comment">//SqStack&amp; S 是 C++ 的引用参数，用于直接修改外部栈对象</span><br>    <span class="hljs-comment">//若用 C 语言，需改用指针（SqStack* S）</span><br>    S-&gt;top = <span class="hljs-number">-1</span>;             <span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么要用 <code>S-&gt;top = -1</code>？</strong></p>
<p><strong>顺序栈的本质是一个数组</strong>，栈顶指针 <code>top</code> 表示当前栈顶元素在数组中的位置索引。<br>初始化时 <code>top = -1</code> 有</p>
<p><strong>空栈条件</strong>：<code>top == -1</code><br>当栈中没有元素时，<code>top</code> 指向数组的“前一个位置”（即无效索引），逻辑上表示“无元素”。</p>
<p><strong>入栈操作</strong></p>
<p>先让 <code>top++</code>，移动到下一个可用位置；将新元素存入 <code>data[top]</code>。<br>例如，第一次入栈时，<code>top</code> 从 <code>-1</code> 变为 <code>0</code>，元素存入 <code>data[0]</code>，对应数组的第一个索引。</p>
<p><strong>判断栈满</strong></p>
<p><strong>栈满条件</strong>：<code>top == MAX_SIZE - 1</code><br>如果数组大小为 <code>MAX_SIZE</code>，当 <code>top</code> 指向最后一个位置（即 <code>MAX_SIZE - 1</code>）时，表示栈已满。</p>
<h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack* S)</span>&#123;<br>    <span class="hljs-keyword">if</span>( S-&gt;top == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//栈中没有元素时，`top` 指向数组的“前一个位置”（即无效索引），逻辑上表示“无元素”</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>( S-&gt;top == MAXSIZE - <span class="hljs-number">1</span> )&#123; <span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <br>    &#125;<br>    S-&gt;top++ ;                  <span class="hljs-comment">//栈顶指针加1</span><br>    S-&gt;data[S-&gt;top] = x;         <span class="hljs-comment">//入栈,写入元素到新栈顶位置</span><br>    <span class="hljs-comment">//S-&gt;data[S-&gt;top]代表栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<span class="hljs-comment">//通过指针修改外部变量</span><br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无法出栈\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    S-&gt;top--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<span class="hljs-comment">//通过指针修改外部变量</span><br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无栈顶元素\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈顶元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>出栈和读栈顶元素操作需要返回两个信息：</p>
<ul>
<li><strong>是否成功</strong>（通过 <code>bool</code> 返回值）。</li>
<li><strong>得到的元素值</strong>（通过 <code>int* x</code> 指针参数）。</li>
</ul>
<h3 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 5  <span class="hljs-comment">// 示例栈容量设为5</span></span><br><br><span class="hljs-comment">//栈结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqStack</span> &#123;</span><br>    <span class="hljs-type">int</span> data[MAXSIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125; SqStack;<br><br><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    S-&gt;top = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;top == <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">// 判断栈满</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackFull</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;top == MAXSIZE - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackFull(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已满，无法入栈 %d\n&quot;</span>, x);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    S-&gt;top++;<br>    S-&gt;data[S-&gt;top] = x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;入栈元素: %d\n&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 出栈（通过指针返回栈顶元素）</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无法出栈\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    S-&gt;top--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">// 获取栈顶元素（通过指针返回）</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack* S, <span class="hljs-type">int</span>* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空，无栈顶元素\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *x = S-&gt;data[S-&gt;top];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈顶元素: %d\n&quot;</span>, *x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 打印栈内容（辅助函数）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintStack</span><span class="hljs-params">(SqStack* S)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StackEmpty(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈内容 (从底到顶): &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= S-&gt;top; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, S-&gt;data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    SqStack S;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 用于接收出栈/栈顶元素的值</span><br><br>    InitStack(&amp;S);<br>    PrintStack(&amp;S);  <span class="hljs-comment">// 栈空</span><br><br>    <span class="hljs-comment">// 入栈测试</span><br>    Push(&amp;S, <span class="hljs-number">10</span>);<br>    Push(&amp;S, <span class="hljs-number">20</span>);<br>    Push(&amp;S, <span class="hljs-number">30</span>);<br>    Push(&amp;S, <span class="hljs-number">40</span>);<br>    Push(&amp;S, <span class="hljs-number">50</span>);   <span class="hljs-comment">// 栈满</span><br>    Push(&amp;S, <span class="hljs-number">60</span>);   <span class="hljs-comment">// 触发栈满报错</span><br>    PrintStack(&amp;S);  <span class="hljs-comment">// 10 20 30 40 50</span><br><br>    <span class="hljs-comment">// 获取栈顶</span><br>    GetTop(&amp;S, &amp;val);  <span class="hljs-comment">// 50</span><br><br>    <span class="hljs-comment">// 出栈测试</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 50出栈</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 40出栈</span><br>    PrintStack(&amp;S);    <span class="hljs-comment">// 10 20 30</span><br><br>    <span class="hljs-comment">// 继续出栈直到栈空</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 30</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 20</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 10</span><br>    Pop(&amp;S, &amp;val);     <span class="hljs-comment">// 触发栈空报错</span><br>    PrintStack(&amp;S);    <span class="hljs-comment">// 栈空</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h1><p>采用<strong>链式存储</strong>的栈称为<strong>链栈</strong>，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头节点，<strong>Lhead</strong>指向栈顶元素</p>
<p class='item-img' data-src='https://pic4.zhimg.com/80/v2-2f84fc59716af6dc2a4bf3ca23f496d7_720w.webp'><img src="https://pic4.zhimg.com/80/v2-2f84fc59716af6dc2a4bf3ca23f496d7_720w.webp" alt="img"></p>
<p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。</p>
<h4 id="链栈的结构定义："><a href="#链栈的结构定义：" class="headerlink" title="链栈的结构定义："></a>链栈的结构定义：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义链式栈的节点结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> </span><br><span class="hljs-class">&#123;</span>	<br>    <span class="hljs-type">int</span> data;                       <span class="hljs-comment">// 存储栈元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> * <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一节点的指针</span><br>&#125; LinkedStackNode, * LinkedStack;   <span class="hljs-comment">// 类型别名：LinkedStackNode表示节点，LinkedStack表示节点指针</span><br>LinkedStack top; <span class="hljs-comment">// 声明一个栈顶指针（本质是LinkedStackNode*类型）</span><br></code></pre></td></tr></table></figure>
<h4 id="初始化空栈"><a href="#初始化空栈" class="headerlink" title="初始化空栈"></a>初始化空栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br>LinkedStack <span class="hljs-title function_">Init_LinkedStack</span><span class="hljs-params">()</span>                                       <br>&#123;	<br>	LinkedStack top=(LinkedStackNode * )<span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>( LinkedStackNode));<br>	<span class="hljs-keyword">if</span>(top!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//申请空间成功</span><br>	top-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置栈顶指针为空</span><br>	<span class="hljs-keyword">return</span> top;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="判断栈空-1"><a href="#判断栈空-1" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判栈空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LinkedStack_Empty</span><span class="hljs-params">(LinkedStack top)</span>                            <br>&#123;	<br>	<span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//检查栈顶指针的值 </span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//栈S为空，函数返回1</span><br>	&#125;	<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Push_LinkedStack</span><span class="hljs-params">(LinkedStack top,elemtype x)</span>                     <br>	<span class="hljs-comment">//插入数据元素x为新的栈顶元素</span><br>&#123;	<br>	LinkedStackNode * node;<br>	node=(LinkedStackNode * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkedStackNode));<br>	<span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//申请结点空间失败,插入失败，函数返回0</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		node-&gt;data=x;<span class="hljs-comment">//设置新结点的数据域</span><br>		node-&gt;next=top-&gt;next;<span class="hljs-comment">//设置新结点的指针城</span><br>		top-&gt;next=node;<span class="hljs-comment">//设置头结点指针城指向新的栈顶元素</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//插入成功，函数返回1</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Pop_LinkedStack</span><span class="hljs-params">(LinkedStack top, elemtype *x)</span>                    <br>&#123;	LinkedStackNode * node;<br>	<span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		node=top-&gt;next;<span class="hljs-comment">//将原栈顶数据元素弹出并赋给node</span><br>		*x=node-&gt;data;<span class="hljs-comment">//将原栈顶数据元素的数据赋值给x</span><br>		top-&gt;next=node-&gt;next;<span class="hljs-comment">//top指向链栈中的下一个数据元素</span><br>		<span class="hljs-built_in">free</span> (node);<span class="hljs-comment">//释放原栈顶数据元素所占的空间</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;  <br></code></pre></td></tr></table></figure>
<h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                <br>&#123; <br>	<span class="hljs-keyword">if</span>(top-&gt;next)<br>      &#123;<br>            <span class="hljs-keyword">return</span> top-&gt;next-&gt;data;<br><br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="求栈长"><a href="#求栈长" class="headerlink" title="求栈长"></a>求栈长</h4><p>设置计数器，随top指针后移，计数器加1，直到遍历完所有元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求栈长</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                                       <br>&#123;<br>	<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(top-&gt;next!=<span class="hljs-literal">NULL</span>) <br>	&#123;<br>		++count;<br>		top=top-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="完整代码实现-1"><a href="#完整代码实现-1" class="headerlink" title="完整代码实现"></a>完整代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 定义链式栈的节点结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> </span><br><span class="hljs-class">&#123;</span>	<br>    <span class="hljs-type">int</span> data;                       <span class="hljs-comment">// 存储栈元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedStackNode</span> * <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一节点的指针</span><br>&#125; LinkedStackNode, * LinkedStack;   <span class="hljs-comment">// 类型别名：LinkedStackNode表示节点，LinkedStack表示节点指针</span><br>LinkedStack top; <span class="hljs-comment">// 声明一个栈顶指针（本质是LinkedStackNode*类型）</span><br><br><span class="hljs-comment">//初始化</span><br>LinkedStack <span class="hljs-title function_">Init_LinkedStack</span><span class="hljs-params">()</span>                                       <br>&#123;	<br>	LinkedStack top=(LinkedStackNode * )<span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>( LinkedStackNode));<br>	<span class="hljs-keyword">if</span>(top!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//申请空间成功</span><br>	top-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置栈顶指针为空</span><br>	<span class="hljs-keyword">return</span> top;<br>&#125;<br><br><span class="hljs-comment">//判栈空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LinkedStack_Empty</span><span class="hljs-params">(LinkedStack top)</span>                            <br>&#123;	<br>	<span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//检查栈顶指针的值 </span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//栈S为空，函数返回1</span><br>	&#125;	<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//入栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push_LinkedStack</span><span class="hljs-params">(LinkedStack top,elemtype x)</span>                     <br>	<span class="hljs-comment">//插入数据元素x为新的栈顶元素</span><br>&#123;	<br>	LinkedStackNode * node;<br>	node=(LinkedStackNode * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkedStackNode));<br>	<span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//申请结点空间失败,插入失败，函数返回0</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		node-&gt;data=x;<span class="hljs-comment">//设置新结点的数据域</span><br>		node-&gt;next=top-&gt;next;<span class="hljs-comment">//设置新结点的指针城</span><br>		top-&gt;next=node;<span class="hljs-comment">//设置头结点指针城指向新的栈顶元素</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//插入成功，函数返回1</span><br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//求栈长</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                                       <br>&#123;<br>	<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(top-&gt;next!=<span class="hljs-literal">NULL</span>) <br>	&#123;<br>		++count;<br>		top=top-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//出栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop_LinkedStack</span><span class="hljs-params">(LinkedStack top, elemtype *x)</span>                    <br>&#123;	LinkedStackNode * node;<br>	<span class="hljs-keyword">if</span>(top-&gt;next==<span class="hljs-literal">NULL</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		node=top-&gt;next;<span class="hljs-comment">//将原栈顶数据元素弹出并赋给node</span><br>		*x=node-&gt;data;<span class="hljs-comment">//将原栈顶数据元素的数据赋值给x</span><br>		top-&gt;next=node-&gt;next;<span class="hljs-comment">//top指向链栈中的下一个数据元素</span><br>		<span class="hljs-built_in">free</span> (node);<span class="hljs-comment">//释放原栈顶数据元素所占的空间</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;  <br><br><span class="hljs-comment">//取栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop_LinkedStack</span><span class="hljs-params">(LinkedStack top)</span>                <br>&#123; <br>	<span class="hljs-keyword">if</span>(top-&gt;next)<br>      &#123;<br>            <span class="hljs-keyword">return</span> top-&gt;next-&gt;data;<br><br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//主函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> i,t,x,a[<span class="hljs-number">20</span>];<br>	LinkedStack top=Init_LinkedStack();<span class="hljs-comment">//初始化栈</span><br>	x=LinkedStack_Empty(top);<span class="hljs-comment">//判栈空结果赋值给X</span><br>	<span class="hljs-keyword">if</span>(x=<span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈为空\n&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请依次输入5个数,开始入栈：\n&quot;</span>);<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <br>	&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>		Push_LinkedStack(top,a[i]);<br>		x=GetTop_LinkedStack(top);<br>		<span class="hljs-keyword">if</span>(x!=<span class="hljs-number">-1</span>)<br>		&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈顶元素为%d\n&quot;</span>,x);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;入栈结束\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈长为%d\n&quot;</span>,Length_LinkedStack(top));<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始出栈:\n&quot;</span>);<br>	<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>	&#123;<br>		Pop_LinkedStack(top,&amp;t);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,t);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈后栈长为%d\n&quot;</span>,Length_LinkedStack(top));<br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/19969.html">← Next 数据结构-树</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/18076.html">数据结构-图 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">栈的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">栈的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.2.</span> <span class="toc-text">栈的常见基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">栈的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">栈的顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">判断栈空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">2.0.0.6.</span> <span class="toc-text">读栈顶元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.0.1.</span> <span class="toc-text">完整代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">栈的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">链栈的结构定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%A0%88"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">初始化空栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA-1"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">判断栈空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E6%A0%88"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">入栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88-1"><span class="toc-number">3.0.0.5.</span> <span class="toc-text">出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">3.0.0.6.</span> <span class="toc-text">取栈顶元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E6%A0%88%E9%95%BF"><span class="toc-number">3.0.0.7.</span> <span class="toc-text">求栈长</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">完整代码实现</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>