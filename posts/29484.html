<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-11-19-重拾编程语言设计与计科相关概念 | Zhongye's Blogs</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":500,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://picx.zhimg.com/v2-6c94831ec3400e77452e9bd9dde85cb5_r.jpg');
 --light-background: url('https://pica.zhimg.com/v2-0323b00e97b41d914a545c7ccea6ab0a_r.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Zhongye's Blogs" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-11-19-重拾编程语言设计与计科相关概念</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-11-19T03:06:20.000Z" id="date"> 2025-11-19</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-11-19T03:22:30.204Z" id="updated"> 2025-11-19</time></div></span><br><span id="busuanzi_container_page_pv">页面浏览: <span class="control" id="busuanzi_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><p>计算机类专业结果这些都得自己学，整理一套编程语言设计与计算机科学核心概念集，日后开坑学习，博客狠狠写，知识学爆</p>
<h2 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li>指针（Pointer）</li>
<li>引用（Reference）</li>
<li>堆（Heap）</li>
<li>栈（Stack）</li>
<li>内存布局（Memory Layout）</li>
<li>垃圾回收（Garbage Collection）</li>
<li>内存泄漏（Memory Leak）</li>
<li>悬挂指针/引用（Dangling Pointer/Reference）</li>
<li>内存序（Memory Ordering）</li>
<li>写时复制（Copy-on-Write）</li>
<li>内存映射文件（Memory-mapped Files）</li>
<li>缓存一致性协议（Cache Coherence Protocol）</li>
<li>虚拟内存机制（Virtual Memory）</li>
<li>内存屏障（Memory Barrier）</li>
<li>内存对齐（Memory Alignment）</li>
<li>内存分配器（Memory Allocator）</li>
<li>内存池（Memory Pool）</li>
<li>引用计数（Reference Counting）</li>
<li>弱引用（Weak Reference）</li>
<li>循环引用（Circular Reference）</li>
<li>内存碎片（Memory Fragmentation）：包括内部碎片和外部碎片</li>
<li>分页与分段（Paging and Segmentation）：虚拟内存管理技术</li>
<li>垃圾回收算法：如标记-清除、复制、标记-整理等具体算法</li>
<li>内存管理单元（Memory Management Unit）</li>
<li>内存保护（Memory Protection）</li>
<li>内存访问（Memory Access）</li>
</ul>
<h3 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h3><ul>
<li>自动存储期（Automatic Storage Duration）</li>
<li>静态存储期（Static Storage Duration）</li>
<li>动态存储期（Dynamic Storage Duration）</li>
<li>线程存储期（Thread Storage Duration）</li>
<li>寄存器变量（Register Variable）</li>
</ul>
<h2 id="二、程序执行模型"><a href="#二、程序执行模型" class="headerlink" title="二、程序执行模型"></a>二、程序执行模型</h2><h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><ul>
<li>调用栈（Call Stack）</li>
<li>栈帧（Stack Frame）</li>
<li>调用约定（Calling Convention）</li>
<li>参数传递（Parameter Passing）</li>
<li>尾调用优化（Tail Call Optimization）</li>
<li>尾递归（Tail Recursion）</li>
<li>Trampoline 机制</li>
<li>Thunk：延迟计算的代码块</li>
<li>Thunk 函数：用于实现惰性求值的技术</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul>
<li>作用域（Scope）</li>
<li>词法作用域（Lexical Scope）</li>
<li>动态作用域（Dynamic Scope）</li>
<li>作用域链（Scope Chain）</li>
<li>闭包（Closure）</li>
<li>执行上下文（Execution Context）</li>
<li>变量环境（Variable Environment）</li>
<li>词法环境（Lexical Environment）</li>
<li>延续（Continuation）</li>
<li>协程（Coroutine）</li>
<li>生成器（Generator）</li>
</ul>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><ul>
<li>事件循环（Event Loop）</li>
<li>计算器模型（Evaluator Model）</li>
<li>消息传递接口（Message Passing）</li>
<li>Actor 模型</li>
<li>CSP（Communicating Sequential Processes）</li>
<li>控制流图（Control Flow Graph）</li>
<li>数据流分析（Data Flow Analysis）</li>
</ul>
<h2 id="三、并发与并行"><a href="#三、并发与并行" class="headerlink" title="三、并发与并行"></a>三、并发与并行</h2><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><ul>
<li>并发（Concurrency）</li>
<li>并行（Parallelism）</li>
<li>绿色线程（Green Threads）</li>
<li>内核线程（Kernel Threads）</li>
<li>用户态线程（User-level Threads）</li>
<li>线程池（Thread Pool）</li>
<li>工作窃取（Work Stealing）</li>
<li>屏障（Barrier）：同步原语</li>
<li>fork-join 模型：并行任务执行模型</li>
<li>数据竞争（Data Race）：并发访问共享数据的问题</li>
</ul>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><ul>
<li>原子操作（Atomic Operations）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>锁（Lock）</li>
<li>自旋锁（Spinlock）</li>
<li>互斥锁（Mutex）</li>
<li>读写锁（Read-Write Lock）</li>
<li>信号量（Semaphore）</li>
<li>条件变量（Condition Variable）</li>
<li>无锁编程（Lock-free Programming）</li>
<li>内存模型（Memory Model）</li>
<li>顺序一致性（Sequential Consistency）</li>
<li>释放获取语义（Release-Acquire Semantics）</li>
</ul>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><ul>
<li>Promise/Future</li>
<li>async/await</li>
<li>响应式编程（Reactive Programming）</li>
<li>数据并行（Data Parallelism）</li>
<li>任务并行（Task Parallelism）</li>
<li>事务内存（Transactional Memory）</li>
</ul>
<h2 id="四、类型系统"><a href="#四、类型系统" class="headerlink" title="四、类型系统"></a>四、类型系统</h2><h3 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h3><ul>
<li>静态类型（Static Typing）</li>
<li>动态类型（Dynamic Typing）</li>
<li>强类型（Strong Typing）</li>
<li>弱类型（Weak Typing）</li>
<li>基本数据类型（Primitive Data Types）</li>
<li>复合数据类型（Composite Data Types）</li>
<li>引用类型（Reference Types）</li>
<li>值类型（Value Types）</li>
<li>类型推导（Type Inference）</li>
<li>类型检查（Type Checking）</li>
<li>类型擦除（Type Erasure）</li>
<li>类型转换（Type Casting）</li>
<li>类型别名（Type Alias）</li>
<li>类型注解（Type Annotation）</li>
<li>泛型（Generics）</li>
<li>类型参数（Type Parameter）</li>
<li>类型变量（Type Variable）</li>
<li>类型约束（Type Constraint）</li>
<li>类型构造器（Type Constructor）</li>
<li>类型等价（Type Equality）</li>
<li>类型子类型（Type Subtyping）</li>
<li>类型上界（Type Upper Bound）</li>
<li>类型下界（Type Lower Bound）</li>
<li>类型推断（Type Inference）</li>
<li>类型检查（Type Checking）</li>
<li>子类型（Subtyping）：类型之间的关系</li>
<li>型变（Covariance/Contravariance）：更详细的变型规则说明</li>
<li>不透明类型（Opaque Types）：隐藏实现细节的类型</li>
</ul>
<h3 id="高级类型概念"><a href="#高级类型概念" class="headerlink" title="高级类型概念"></a>高级类型概念</h3><ul>
<li>行多态（Row Polymorphism）</li>
<li>存在类型（Existential Types）</li>
<li>高阶类型（Higher-Kinded Types）</li>
<li>依赖类型（Dependent Types）</li>
<li>渐进类型（Gradual Typing）</li>
<li>类型类（Type Classes）</li>
<li>泛型（Generics）</li>
<li>变型（Variance）：协变、逆变、不变</li>
<li>类型安全（Type Safety）</li>
<li>类型擦除（Type Erasure）</li>
<li>单态化（Monomorphization）</li>
</ul>
<h2 id="五、函数与抽象"><a href="#五、函数与抽象" class="headerlink" title="五、函数与抽象"></a>五、函数与抽象</h2><h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><ul>
<li>高阶函数（Higher-Order Function）</li>
<li>回调函数（Callback）</li>
<li>递归（Recursion）</li>
<li>匿名函数（Anonymous Function）</li>
<li>Lambda 表达式</li>
<li>柯里化（Currying）</li>
<li>部分应用（Partial Application）</li>
<li>函数组合（Function Composition）</li>
</ul>
<h3 id="抽象机制"><a href="#抽象机制" class="headerlink" title="抽象机制"></a>抽象机制</h3><ul>
<li>控制抽象（Control Abstraction）</li>
<li>数据抽象（Data Abstraction）</li>
<li>迭代器（Iterator）</li>
<li>流处理（Stream Processing）</li>
<li>声明式编程（Declarative Programming）</li>
<li>函子（Functor）：映射结构的抽象概念</li>
<li>单子（Monad）：具有绑定操作的计算容器</li>
</ul>
<h2 id="六、面向对象编程"><a href="#六、面向对象编程" class="headerlink" title="六、面向对象编程"></a>六、面向对象编程</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li>类（Class）</li>
<li>对象（Object）</li>
<li>封装（Encapsulation）</li>
<li>继承（Inheritance）</li>
<li>多态（Polymorphism）</li>
<li>接口（Interface）</li>
<li>抽象类（Abstract Class）</li>
<li>混入（Mixin）</li>
<li>特质（Trait）</li>
</ul>
<h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><ul>
<li>虚函数表（Virtual Method Table）</li>
<li>方法解析顺序（Method Resolution Order）</li>
<li>对象布局（Object Layout）</li>
<li>多重继承（Multiple Inheritance）</li>
<li>虚继承（Virtual Inheritance）</li>
<li>原型继承（Prototypal Inheritance）</li>
<li>消息传递（Message Passing）：对象间的通信机制</li>
<li>委托（Delegation）：替代继承的复用机制</li>
</ul>
<h2 id="七、元编程与反射"><a href="#七、元编程与反射" class="headerlink" title="七、元编程与反射"></a>七、元编程与反射</h2><h3 id="元编程技术"><a href="#元编程技术" class="headerlink" title="元编程技术"></a>元编程技术</h3><ul>
<li>反射（Reflection）</li>
<li>内省（Introspection）</li>
<li>宏系统（Macro System）</li>
<li>卫生宏（Hygienic Macro）</li>
<li>语法宏（Syntax Macro）</li>
<li>过程宏（Procedural Macro）</li>
<li>模板元编程（Template Metaprogramming）</li>
<li>注解处理（Annotation Processing）</li>
<li>属性导向编程（Attribute-Oriented Programming）</li>
</ul>
<h3 id="运行时元编程"><a href="#运行时元编程" class="headerlink" title="运行时元编程"></a>运行时元编程</h3><ul>
<li>动态代理（Dynamic Proxy）</li>
<li>方法缺失处理（Method Missing）</li>
<li>代码生成（Code Generation）</li>
<li>AST 操作（Abstract Syntax Tree Manipulation）</li>
</ul>
<h2 id="八、编译与解释"><a href="#八、编译与解释" class="headerlink" title="八、编译与解释"></a>八、编译与解释</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul>
<li>词法分析（Lexical Analysis）</li>
<li>语法分析（Syntax Analysis）</li>
<li>语义分析（Semantic Analysis）</li>
<li>中间代码生成（Intermediate Code Generation）</li>
<li>代码优化（Code Optimization）</li>
<li>目标代码生成（Target Code Generation）</li>
<li>编译器架构（Compiler Architecture）</li>
<li>编译器设计（Compiler Design）</li>
<li>编译器实现（Compiler Implementation）</li>
<li>链接时优化（Link Time Optimization, LTO）：跨模块优化技术</li>
<li>Profile-Guided Optimization (PGO)：基于运行时信息的优化</li>
</ul>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><ul>
<li>解释器（Interpreter）</li>
<li>字节码（Bytecode）</li>
<li>即时编译（Just-In-Time Compilation）</li>
<li>抽象语法树（Abstract Syntax Tree, AST）</li>
<li>单态化（Monomorphization）</li>
<li>类型擦除（Type Erasure）</li>
<li>中间表示（Intermediate Representation）</li>
<li>SSA 形式（Static Single Assignment）</li>
</ul>
<h2 id="九、系统接口"><a href="#九、系统接口" class="headerlink" title="九、系统接口"></a>九、系统接口</h2><h3 id="操作系统交互"><a href="#操作系统交互" class="headerlink" title="操作系统交互"></a>操作系统交互</h3><ul>
<li>系统调用（System Call）</li>
<li>文件描述符（File Descriptor）</li>
<li>ABI（Application Binary Interface）</li>
<li>系统 V ABI</li>
<li>TLS（Thread Local Storage）</li>
<li>信号处理（Signal Handling）</li>
</ul>
<h2 id="十、异常与错误处理"><a href="#十、异常与错误处理" class="headerlink" title="十、异常与错误处理"></a>十、异常与错误处理</h2><h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><ul>
<li>异常处理（Exception Handling）</li>
<li>返回值错误（Error Return Values）</li>
<li>Result 类型</li>
<li>可选值（Option/Maybe）</li>
<li>断言（Assertion）</li>
<li>契约编程（Design by Contract）</li>
</ul>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><ul>
<li>RAII（Resource Acquisition Is Initialization）</li>
<li>所有权系统（Ownership System）</li>
<li>借用检查（Borrow Checking）</li>
<li>生命周期（Lifetime）</li>
<li>析构函数（Destructor）</li>
<li>finally 块</li>
</ul>
<h2 id="十一、模块化与代码组织"><a href="#十一、模块化与代码组织" class="headerlink" title="十一、模块化与代码组织"></a>十一、模块化与代码组织</h2><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><ul>
<li>模块化（Modularity）</li>
<li>命名空间（Namespace）</li>
<li>包管理（Package Management）</li>
<li>依赖注入（Dependency Injection）</li>
<li>接口隔离（Interface Segregation）</li>
</ul>
<h3 id="链接与加载"><a href="#链接与加载" class="headerlink" title="链接与加载"></a>链接与加载</h3><ul>
<li>静态链接（Static Linking）</li>
<li>动态链接（Dynamic Linking）</li>
<li>符号解析（Symbol Resolution）</li>
<li>重定位（Relocation）</li>
<li>名称修饰（Name Mangling）</li>
</ul>
<h2 id="十二、性能优化"><a href="#十二、性能优化" class="headerlink" title="十二、性能优化"></a>十二、性能优化</h2><h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><ul>
<li>内联优化（Inlining）</li>
<li>常量传播（Constant Propagation）</li>
<li>死代码消除（Dead Code Elimination）</li>
<li>循环优化（Loop Optimization）</li>
<li>向量化（Vectorization）</li>
<li>分支目标缓冲（Branch Target Buffer）：提高分支预测准确性的硬件机制</li>
<li>指令级并行（Instruction Level Parallelism）：CPU 级别的并行执行</li>
</ul>
<h3 id="运行时优化"><a href="#运行时优化" class="headerlink" title="运行时优化"></a>运行时优化</h3><ul>
<li>内联缓存（Inline Cache）</li>
<li>方法缓存（Method Cache）</li>
<li>逃逸分析（Escape Analysis）</li>
<li>栈上替换（On-Stack Replacement）</li>
<li>热点代码检测（Hotspot Detection）</li>
</ul>
<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><ul>
<li>缓存局部性（Cache Locality）</li>
<li>分支预测（Branch Prediction）</li>
<li>流水线冒险（Pipeline Hazard）</li>
<li>预取（Prefetching）</li>
<li>SIMD（Single Instruction Multiple Data）</li>
</ul>
<h2 id="十三、形式化方法与理论"><a href="#十三、形式化方法与理论" class="headerlink" title="十三、形式化方法与理论"></a>十三、形式化方法与理论</h2><h3 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h3><ul>
<li>霍尔逻辑（Hoare Logic）</li>
<li>指称语义（Denotational Semantics）</li>
<li>操作语义（Operational Semantics）</li>
<li>公理语义（Axiomatic Semantics）</li>
<li>进展定理（Progress Theorem）</li>
<li>保持定理（Preservation Theorem）</li>
</ul>
<h3 id="计算理论"><a href="#计算理论" class="headerlink" title="计算理论"></a>计算理论</h3><ul>
<li>λ 演算（Lambda Calculus）</li>
<li>组合子逻辑（Combinatory Logic）</li>
<li>图灵完备性（Turing Completeness）</li>
<li>邱奇-图灵论题（Church-Turing Thesis）</li>
<li>停机问题（Halting Problem）</li>
</ul>
<h2 id="十四、现代语言特性"><a href="#十四、现代语言特性" class="headerlink" title="十四、现代语言特性"></a>十四、现代语言特性</h2><h3 id="语言设计趋势"><a href="#语言设计趋势" class="headerlink" title="语言设计趋势"></a>语言设计趋势</h3><ul>
<li>空安全（Null Safety）</li>
<li>模式匹配（Pattern Matching）</li>
<li>异步/等待（Async/Await）</li>
<li>记录类型（Record Types）</li>
<li>代数数据类型（Algebraic Data Types）</li>
<li>效应系统（Effect System）</li>
<li>资源安全（Resource Safety）</li>
<li>所有权与借用（Ownership and Borrowing）：Rust 中的内存安全机制</li>
<li>异构编程（Heterogeneous Programming）：利用多种计算设备的编程模型</li>
</ul>
<h3 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h3><ul>
<li>表达式问题（Expression Problem）</li>
<li>访问者模式（Visitor Pattern）</li>
<li>模式匹配解构</li>
</ul>
<h2 id="十五、编程范式"><a href="#十五、编程范式" class="headerlink" title="十五、编程范式"></a>十五、编程范式</h2><h3 id="主要范式"><a href="#主要范式" class="headerlink" title="主要范式"></a>主要范式</h3><ul>
<li>命令式编程（Imperative Programming）</li>
<li>声明式编程（Declarative Programming）</li>
<li>函数式编程（Functional Programming）</li>
<li>逻辑编程（Logic Programming）</li>
<li>面向对象编程（Object-Oriented Programming）</li>
<li>面向方面编程（Aspect-Oriented Programming）</li>
</ul>
<h3 id="混合范式"><a href="#混合范式" class="headerlink" title="混合范式"></a>混合范式</h3><ul>
<li>多范式编程（Multi-paradigm Programming）</li>
<li>函数响应式编程（Functional Reactive Programming）</li>
<li>元对象协议（Metaobject Protocol）</li>
</ul>
<h2 id="十六、软件开发基础"><a href="#十六、软件开发基础" class="headerlink" title="十六、软件开发基础"></a>十六、软件开发基础</h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li>表达式与语句（Expressions vs Statements）</li>
<li>控制流（Control Flow）</li>
<li>数据结构（Data Structures）</li>
<li>算法（Algorithms）</li>
<li>复杂度分析（Complexity Analysis）</li>
<li>设计模式（Design Patterns）：常见问题的标准解决方案</li>
<li>SOLID 原则：面向对象设计的五个基本原则</li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/25943.html">← 下一篇 2025-11-20-关于滑动窗口</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/24254.html">2025-11-17-关于动态规划(背包问题为例) 上一篇 →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">Zhongye</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">一、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">存储类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">二、程序执行模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">函数调用机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.2.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text">控制流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.</span> <span class="toc-text">三、并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">并发模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">异步编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">四、类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">类型分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">高级类型概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">五、函数与抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">函数概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.</span> <span class="toc-text">抽象机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">六、面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">对象模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">7.</span> <span class="toc-text">七、元编程与反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">7.1.</span> <span class="toc-text">元编程技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">运行时元编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A"><span class="toc-number">8.</span> <span class="toc-text">八、编译与解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">编译原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">8.2.</span> <span class="toc-text">执行引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">九、系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92"><span class="toc-number">9.1.</span> <span class="toc-text">操作系统交互</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">十、异常与错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">10.1.</span> <span class="toc-text">错误处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text">资源管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">11.</span> <span class="toc-text">十一、模块化与代码组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">11.1.</span> <span class="toc-text">代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A0%E8%BD%BD"><span class="toc-number">11.2.</span> <span class="toc-text">链接与加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">12.</span> <span class="toc-text">十二、性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">12.1.</span> <span class="toc-text">编译器优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BC%98%E5%8C%96"><span class="toc-number">12.2.</span> <span class="toc-text">运行时优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">12.3.</span> <span class="toc-text">硬件优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95%E4%B8%8E%E7%90%86%E8%AE%BA"><span class="toc-number">13.</span> <span class="toc-text">十三、形式化方法与理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81"><span class="toc-number">13.1.</span> <span class="toc-text">形式化验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA"><span class="toc-number">13.2.</span> <span class="toc-text">计算理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">14.</span> <span class="toc-text">十四、现代语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E8%B6%8B%E5%8A%BF"><span class="toc-number">14.1.</span> <span class="toc-text">语言设计趋势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">14.2.</span> <span class="toc-text">表达式问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">十五、编程范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%8C%83%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">主要范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%8C%83%E5%BC%8F"><span class="toc-number">15.2.</span> <span class="toc-text">混合范式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-number">16.</span> <span class="toc-text">十六、软件开发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="toc-number">16.1.</span> <span class="toc-text">基础概念</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><!-- ── 访客信息获取脚本（建议放在页面底部 layout/_partial/after-footer.pug 或单独引入） ──--><script>(function() {
  const MAX_RETRY = 1;
  let retryCount = 0;

  async function fetchVisitorInfo() {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort(new Error('Request timeout after 1000ms'));
    }, 1000);

    try {
      const response = await fetch('https://ipapi.co/json/', {
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const data = await response.json();

      document.getElementById('visitor-ip').textContent = data.ip || '无法获取';
      
      const parts = [];
      if (data.city) parts.push(data.city);
      if (data.region) parts.push(data.region);
      if (data.country_name) parts.push(data.country_name);
      
      document.getElementById('visitor-location').textContent = 
        parts.length > 0 ? parts.join(' - ') : '未知地区';

    } catch (err) {
      clearTimeout(timeoutId);

      // 如果是超时错误，且还有重试次数，则重试一次
      if (err.name === 'AbortError' && retryCount < MAX_RETRY) {
        retryCount++;
        // 可选：显示「正在重试...」提示
        document.getElementById('visitor-ip').textContent = '超时，正在重试...';
        document.getElementById('visitor-location').textContent = '——';
        
        // 立即重试（也可加个很短的延迟，如 300ms）
        setTimeout(fetchVisitorInfo, 300);
        return;
      }

      // 最终失败
      document.getElementById('visitor-ip').textContent = '████';
      document.getElementById('visitor-location').textContent = '████';
    }
  }

  // 页面加载完成后获取访客信息
  fetchVisitorInfo();

  // 添加对PJAX事件的监听，以便在页面切换后重新获取访客信息
  document.addEventListener('pjax:complete', function() {
    // 延迟执行，确保DOM已经更新完成
    setTimeout(fetchVisitorInfo, 100);
  });
})();</script></main><canvas id="canvas-dust"></canvas></body></html>