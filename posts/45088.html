<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构-绪论 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pica.zhimg.com/v2-1d14a5f80bbe62302dce99b273e3a948_r.jpg');
 --light-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>数据结构-绪论</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-04-05T03:31:22.000Z" id="date"> 2025-04-05</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-12-27T07:56:29.295Z" id="updated"> 2025-12-27</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a><strong>1.1 数据结构的基本概念</strong></h2><p>　　数据、数据元素、数据对象、数据结构、存储结构、数据类型和抽象数据类型。</p>
<blockquote>
<p><strong>数据</strong>(data)是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。<br><strong>数据元素</strong>(data element)是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。<br><strong>数据对象</strong>(data object)是性质相同的数据元素的集合，是数据的一个子集。<br><strong>数据结构</strong>(data structure)是相互之间存在一种或多种特定关系的数据元素的集合。<br><strong>存储结构</strong>（<strong>物理结构</strong>）是数据结构在计算机中的表示（又称映像）。<br><strong>数据类型</strong>(data type)是一个值的集合和定义在这个值集上的一组操作的总称。<br><strong>抽象数据类型</strong>(Abstract Data Type)是指一个数学模型以及定义在该模型上的一组操作。</p>
</blockquote>
<h3 id="抽象数据类型的定义"><a href="#抽象数据类型的定义" class="headerlink" title="抽象数据类型的定义"></a><strong>抽象数据类型的定义</strong></h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">ADT 抽象数据类型名</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    数据对象：数据对象的定义</span><br><span class="hljs-template-variable">    数据关系：数据关系的定义</span><br><span class="hljs-template-variable">    基本操作：基本操作的定义</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">ADT 抽象数据类型名</span><br></code></pre></td></tr></table></figure>
<p>例子如下</p>
<p><strong>抽象数据类型复数和有理数的定义</strong>（有理数是其分子、分母均为自然数且分母不为零的分数）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">复数定义：<br>ADT Complex  <span class="hljs-comment">//复数定义 a±bi</span><br>&#123;<br>    数据对象：D = &#123;a, b | a,b为实数&#125;<br>    数据关系：R = &#123;&lt;a, b&gt;&#125;<br>    基本操作：<br>        InitComplex(&amp;C, re, im)<br>            操作结果：构造一个复数C，其实部和虚部分别为re和im<br>        DestroyCmoplex(&amp;C)<br>            操作结果：销毁复数C<br>        Get(C, k, &amp;e)<br>            初始条件：复数C已存在<br>            操作结果：用e返回复数C的第k元的值<br>        Put(&amp;C, k, e)<br>            初始条件：复数C已存在<br>            操作结果：改变复数C的第k元的值为e<br>        IsAscending(C)<br>            初始条件：复数C已存在<br>            操作结果：如果复数C的两个元素按升序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        IsDescending(C)<br>            初始条件：复数C已存在<br>            操作结果：如果复数C的两个元素按降序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        Max(C, &amp;e)<br>            初始条件：复数C已存在<br>            操作结果：用e返回复数C的两个元素中值较大的一个<br>        Min(C, &amp;e)<br>            初始条件：复数C已存在<br>            操作结果：用e返回复数C的两个元素中值较小的一个<br>&#125;ADT Complex<br><br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">有理数定义：<br>ADT RationalNumber  <span class="hljs-comment">//有理数定义</span><br>&#123;<br>    数据对象：D=&#123;s, m | s,m为自然数，且m不为<span class="hljs-number">0</span>&#125;<br>    数据关系：R=&#123;&lt;s, m&gt;&#125;<br>    基本操作：<br>        InitRationalNumber(&amp;R, s, m)<br>            操作结果：构造一个有理数R，其分子和分母分别为s和m<br>        DestroyRationalNumber(&amp;R)<br>            操作结果：销毁有理数R<br>        Get(R, k, &amp;e)<br>            初始条件：有理数R已存在<br>            操作结果：用e返回有理数R的第k元的值<br>        Put(&amp;R, k, e)<br>            初始条件：有理数R已存在<br>            操作结果：改变有理数R的第k元的值为e<br>        IsAscending(R)<br>            初始条件：有理数R已存在<br>            操作结果：若有理数R的两个元素按升序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        IsDescending(R)<br>            初始条件：有理数R已存在<br>            操作结果：若有理数R的两个元素按降序排列，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br>        Max(R, &amp;e)<br>            初始条件：有理数R已存在<br>            操作结果：用e返回有理数R的两个元素中值较大的一个<br>        Min(R, &amp;e)<br>            初始条件：有理数R已存在<br>            操作结果：用e返回有理数R的两个元素中值较小的一个<br>&#125;ADT RationalNumber<br></code></pre></td></tr></table></figure>
<p>　　</p>
<p>根据数据元素之间关系的 不同特性，通常有下列几种类基本结构：</p>
<p>(1) <strong>集合</strong> 结构中的 如生 数据元素之间除了“同属千一个集合”的关系外，别无其他关系</p>
<p>(2) <strong>线性结构</strong> 结构中的数据元素之间存在一个对 一个的关系；</p>
<p>(3) <strong>树形结构</strong> 结构中的数据元素之间存在一 个对多个的关系； </p>
<p>(4) <strong>图状结构或网状结构</strong> 结构中的数据 元素之间存在多个对多个的关系。</p>
<h3 id="1-1-2-数据结构三要素"><a href="#1-1-2-数据结构三要素" class="headerlink" title="1.1.2 数据结构三要素"></a><strong>1.1.2 数据结构三要素</strong></h3><p>　　　　<strong>① 逻辑结构</strong></p>
<p>　　　　　　逻辑结构指数据元素之间存在的逻辑关系，是固有的客观联系；</p>
<p>　　　　　　逻辑结构分为<strong>线性结构</strong>与<strong>非线性结构</strong>，比如：线性表、树、图等；</p>
<p>　　　　<strong>② 存储结构</strong></p>
<p>　　　　　　存储结构又称为物理结构，指数据结构在计算机中的表示（映像），是计算机内部的存储方法；</p>
<p>　　　　　　存储结构主要有<strong>顺序存储、链式存储、索引存储</strong>和<strong>散列存储</strong>；</p>
<p>　　　　　　一种逻辑结构通过映像便可以得到它的存储结构；</p>
<p>　　　　　　诸如顺序表、哈希表、链表这样的表述，它们既体现了逻辑结构（均为线性），又体现了存储结构（顺序、散列、链式）；</p>
<p>　　　　　　而这样的表述我们往往就直接称之为<strong>数据结构</strong>；</p>
<p>　　　　　　诸如有序表，它只体现了逻辑结构（线性），而存储结构是未知的（可以是顺序、链式……）；</p>
<p>　　　　　　不存在只体现存储结构而不体现逻辑结构的表述；</p>
<p>　　　　　　所以，我们认为：<strong>逻辑结构独立于存储结构。</strong></p>
<p>　　　　<strong>③ 数据的运算（算法）</strong></p>
<p>　　　　　　算法包括运算的<strong>定义</strong>（取决于逻辑结构，体现算法功能）与<strong>实现</strong>（取决于存储结构，体现于操作步骤）。</p>
<h3 id="1-2-算法的基本概念"><a href="#1-2-算法的基本概念" class="headerlink" title="1.2 算法的基本概念"></a><strong>1.2 算法的基本概念</strong></h3><p>　　算法的 5 个重要特性：<strong>有穷性、确定性、有效性（可行性）、输入</strong>，<strong>输出</strong>；</p>
<p>　　一个好的算法的目标：<strong>正确性、可读性、鲁棒性、效率与低存储量需求</strong>。</p>
<p><strong>1.3 算法分析</strong></p>
<p>　　<strong>时间复杂度</strong>指算法所有语句被重复执行次数总和的数量级。</p>
<p>　　常见时间复杂度比较：</p>
<p>　　　　<strong>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</strong></p>
<p>　　　　(log 表示以 2 为底的对数)</p>
<p>　　<strong>空间复杂度</strong>指算法耗费存储空间的数量级。</p>
<p><strong>1.4 时间复杂度的计算</strong></p>
<h3 id="计算时间复杂度"><a href="#计算时间复杂度" class="headerlink" title="计算时间复杂度"></a><strong>计算时间复杂度</strong></h3><p>问题规模——&gt; 输入量的多少</p>
<p>语句频度——&gt; 一条语句的重复执行次数</p>
<p>执行时间&lt;—— 所有语句频度之和</p>
<blockquote>
<p>1.基本操作，即只有常数项，认为其时间复杂度为O(1)<br>2.顺序结构，时间复杂度按加法进行计算<br>3.循环结构，时间复杂度按乘法进行计算<br>4.分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略<br>5.在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度</p>
</blockquote>
<p>　　</p>
<p><strong>循环条件包含主体变量</strong></p>
<p>将执行次数代入循环条件进行求解：</p>
<p><strong>示例1：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= n) <br>    i = i * <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>每次循环后 <em>i</em> =2<em>t</em>（<em>t</em> 为执行次数）</li>
<li>终止条件：2<em>t</em> ≤ <em>n</em></li>
<li>解得 <em>t </em>≤ log2<em>n</em></li>
<li>时间复杂度：<em>T</em>(<em>n</em>) = <em>O</em>(log<em>n</em>)</li>
</ul>
<p><strong>示例2：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">while</span> ((i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">1</span>) &lt; n) <br>    i = i + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>令 <em>t</em>=<em>i</em>−3，则 <em>i</em>=<em>t</em>+3</li>
<li>代入条件：(<em>t</em>+3+1)2&lt;<em>n</em>⟹(<em>t</em>+4)2&lt;<em>n</em></li>
<li>解得 <em>t</em>&lt;<em>n</em>−4</li>
<li>时间复杂度：<em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
</ul>
<hr>
<p><strong>循环条件与主体变量无关</strong></p>
<p>通过数学归纳法或递归展开直接计数：</p>
<p><strong>示例（递归函数）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>递归方程：<em>T</em>(<em>n</em>)=1+<em>T</em>(<em>n</em>−1)</li>
<li>展开递推：<em>T</em>(<em>n</em>)=1+<em>T</em>(<em>n</em>−1)=1+1+<em>T</em>(<em>n</em>−2) ⋮=<em>k</em>+<em>T</em>(<em>n</em>−<em>k</em>)(当 <em>k</em>=<em>n</em>−1)=(<em>n</em>−1)+<em>T</em>(1)=<em>O</em>(<em>n</em>)</li>
<li>时间复杂度：<em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
</ul>
<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><p>如下图所示，常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。</p>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599638810-SZDwfK-Picture1.png'><img src="https://pic.leetcode-cn.com/1599638810-SZDwfK-Picture1.png" alt="Picture1.png"></p>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。</p>
<p>如下图所示，构建此数组需要在初始化时给定长度，并对数组每个索引元素赋值，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化一个长度为 5 的数组 array</span><br><span class="hljs-type">int</span> array[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 元素赋值</span><br>array[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br>array[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<br>array[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>array[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>array[<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>
<p>或者可以使用直接赋值的初始化方式，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> array[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599587176-JAxwpf-Picture2.png'><img src="https://pic.leetcode-cn.com/1599587176-JAxwpf-Picture2.png" alt="Picture2.png"></p>
<p>「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化可变数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; array;<br><br><span class="hljs-comment">// 向尾部添加元素</span><br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>array.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 <code>val</code>」，「后继节点引用 <code>next</code>」 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;        <span class="hljs-comment">// 节点值</span><br>    ListNode *next; <span class="hljs-comment">// 后继节点引用</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实例化节点</span><br>ListNode *n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 节点 head</span><br>ListNode *n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br>ListNode *n3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1-&gt;next = n2;<br>n2-&gt;next = n3;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599578767-zgLjYw-Picture3.png'><img src="https://pic.leetcode-cn.com/1599578767-zgLjYw-Picture3.png" alt="Picture3.png"></p>
<hr>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; stk;<br></code></pre></td></tr></table></figure>
<p>如下图所示，通过常用操作「入栈 <code>push()</code>」,「出栈 <code>pop()</code>」，展示了栈的先入后出特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 元素 1 入栈</span><br>stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 元素 2 入栈</span><br>stk.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出栈 -&gt; 元素 2</span><br>stk.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出栈 -&gt; 元素 1</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599578767-ZifMEX-Picture4.png'><img src="https://pic.leetcode-cn.com/1599578767-ZifMEX-Picture4.png" alt="Picture4.png"></p>
<hr>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; que;<br></code></pre></td></tr></table></figure>
<p>如下图所示，通过常用操作「入队 <code>push()</code>」,「出队 <code>pop()</code>」，展示了队列的先入先出特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">que.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 元素 1 入队</span><br>que.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 元素 2 入队</span><br>que.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出队 -&gt; 元素 1</span><br>que.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 出队 -&gt; 元素 2</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599588416-Majmwh-Picture5.png'><img src="https://pic.leetcode-cn.com/1599588416-Majmwh-Picture5.png" alt="Picture5.png"></p>
<hr>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 <code>root</code>」。以二叉树为例，每个节点包含三个成员变量：「值 <code>val</code>」、「左子节点 <code>left</code>」、「右子节点 <code>right</code>」 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;         <span class="hljs-comment">// 节点值</span><br>    TreeNode *left;  <span class="hljs-comment">// 左子节点</span><br>    TreeNode *right; <span class="hljs-comment">// 右子节点</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如下图所示，建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化节点</span><br>TreeNode *n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 根节点 root</span><br>TreeNode *n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">4</span>);<br>TreeNode *n3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">5</span>);<br>TreeNode *n4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">1</span>);<br>TreeNode *n5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1-&gt;left = n2;<br>n1-&gt;right = n3;<br>n2-&gt;left = n4;<br>n2-&gt;right = n5;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599579136-bBARpC-Picture6.png'><img src="https://pic.leetcode-cn.com/1599579136-bBARpC-Picture6.png" alt="Picture6.png"></p>
<hr>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是一种非线性数据结构，由「节点（顶点）<code>vertex</code>」和「边 <code>edge</code>」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。本文 <strong>以无向图为例</strong> 开展介绍。</p>
<p>如下图所示，此无向图的 <strong>顶点</strong> 和 <strong>边</strong> 集合分别为：</p>
<ul>
<li>顶点集合： <code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></li>
<li>边集合： <code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;</code></li>
</ul>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599579136-Fxseew-Picture7.png'><img src="https://pic.leetcode-cn.com/1599579136-Fxseew-Picture7.png" alt="Picture7.png"></p>
<p>表示图的方法通常有两种：</p>
<p><strong>邻接矩阵</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> vertices[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> edges[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>                   &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>                   &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>                   &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>                   &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<p><strong>邻接表：</strong></p>
<ul>
<li><strong>顶点存储</strong>: 数组 <code>vertices</code> 存储顶点值</li>
<li><strong>边存储</strong>: 二维容器 <code>edges</code> 存储边关系<ul>
<li>第一维 <code>i</code> 表示顶点索引（对应 <code>vertices[i]</code>）</li>
<li>第二维 <code>edges[i]</code> 存储该顶点连接的<strong>目标顶点值集合</strong></li>
<li><strong><code>edges[i]</code> 中的数字直接表示目标顶点</strong>值**（非索引）</li>
<li>例如 <code>edges[0] = [1,2,3,4]</code> 表示顶点1连接到值2/3/4/5（注意实际值比索引大1）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> vertices[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; edge_1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_3 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_4 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge_5 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>edges.<span class="hljs-built_in">push_back</span>(edge_1);<br>edges.<span class="hljs-built_in">push_back</span>(edge_2);<br>edges.<span class="hljs-built_in">push_back</span>(edge_3);<br>edges.<span class="hljs-built_in">push_back</span>(edge_4);<br>edges.<span class="hljs-built_in">push_back</span>(edge_5);<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>邻接矩阵 VS 邻接表 ：</strong></p>
<p>邻接矩阵的大小只与节点数量有关，即 N2<em>N</em>2 ，其中 N<em>N</em> 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。<br>因此，<strong>邻接表</strong> 适合存储稀疏图（顶点较多、边较少）； <strong>邻接矩阵</strong> 适合存储稠密图（顶点较少、边较多）。</p>
</blockquote>
<hr>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，以实现高效的元素查找。</p>
<blockquote>
<p>设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。<br>现需求从「姓名」查找「学号」。</p>
</blockquote>
<p>则可通过建立姓名为 <code>key</code> ，学号为 <code>value</code> 的散列表实现此需求，代码如下：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 初始化散列表</span><br>unordered_map&lt;string, int&gt; dic;<br><br><span class="hljs-comment">// 添加 key -&gt; value 键值对</span><br>dic[<span class="hljs-string">&quot;小力&quot;</span>] = <span class="hljs-number">10001</span>;<br>dic[<span class="hljs-string">&quot;小特&quot;</span>] = <span class="hljs-number">10002</span>;<br>dic[<span class="hljs-string">&quot;小扣&quot;</span>] = <span class="hljs-number">10003</span>;<br><br><span class="hljs-comment">// 从姓名查找学号</span><br>dic.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;小力&quot;</span>)-&gt;<span class="hljs-built_in">second</span>; <span class="hljs-comment">// -&gt; 10001</span><br>dic.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;小特&quot;</span>)-&gt;<span class="hljs-built_in">second</span>; <span class="hljs-comment">// -&gt; 10002</span><br>dic.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;小扣&quot;</span>)-&gt;<span class="hljs-built_in">second</span>; <span class="hljs-comment">// -&gt; 10003</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599811794-ruXMOV-Picture8.png'><img src="https://pic.leetcode-cn.com/1599811794-ruXMOV-Picture8.png" alt="Picture8.png"></p>
<p><strong>Hash 函数设计示例 ：</strong></p>
<blockquote>
<p>假设需求：从「学号」查找「姓名」。</p>
</blockquote>
<p>将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2 。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">string</span> names[] = &#123; <span class="hljs-string">&quot;小力&quot;</span>, <span class="hljs-string">&quot;小特&quot;</span>, <span class="hljs-string">&quot;小扣&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>
<p>此时，我们构造一个简单的 Hash 函数（ %% 为取余符号 ），公式和封装函数如下所示：</p>
<p>hash(key)=(key−1)%10000</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> <span class="hljs-built_in">hash</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">id</span>) &#123;<br>    <span class="hljs-built_in">int</span> index = (<span class="hljs-built_in">id</span> - <span class="hljs-number">1</span>) % <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>则我们构建了以学号为 <code>key</code> 、姓名对应的数组索引为 <code>value</code> 的散列表。利用此 Hash 函数，则可在 O(1)<em>O</em>(1) 时间复杂度下通过学号查找到对应姓名，即：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">names[<span class="hljs-built_in">hash</span>(<span class="hljs-number">10001</span>)] <span class="hljs-comment">// 小力</span><br>names[<span class="hljs-built_in">hash</span>(<span class="hljs-number">10002</span>)] <span class="hljs-comment">// 小特</span><br>names[<span class="hljs-built_in">hash</span>(<span class="hljs-number">10003</span>)] <span class="hljs-comment">// 小扣</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599811794-NfbpfW-Picture8-1.png'><img src="https://pic.leetcode-cn.com/1599811794-NfbpfW-Picture8-1.png" alt="Picture8-1.png"></p>
<p>以上设计只适用于此示例，实际的 Hash 函数需保证低碰撞率、 高鲁棒性等，以适用于各类数据和场景。</p>
<hr>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</p>
<blockquote>
<p><strong>完全二叉树定义：</strong> 设二叉树深度为 k<em>k</em> ，若二叉树除第 k<em>k</em> 层外的其它各层（第 11 至 k−1<em>k</em>−1 层）的节点达到最大个数，且处于第 k<em>k</em> 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。</p>
</blockquote>
<p>如下图所示，为包含 <code>1, 4, 2, 6, 8</code> 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。</p>
<p class='item-img' data-src='https://pic.leetcode-cn.com/1599584901-xoiGEQ-Picture9.png'><img src="https://pic.leetcode-cn.com/1599584901-xoiGEQ-Picture9.png" alt="Picture9.png"></p>
<p>通过使用「优先队列」的「压入 <code>push()</code>」和「弹出 <code>pop()</code>」操作，即可完成堆排序，实现代码如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 初始化小顶堆</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; heap;<br><br><span class="hljs-comment">// 元素入堆</span><br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">4</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">2</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">6</span>);<br>heap.<span class="hljs-keyword">push</span>(<span class="hljs-number">8</span>);<br><br><span class="hljs-comment">// 元素出堆（从小到大）</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 1</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 2</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 4</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 6</span><br>heap.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// -&gt; 8</span><br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/25842.html">← Next 数据结构-算法复杂度</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/12835.html">关于数据结构的一些想法 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1.1 数据结构的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">抽象数据类型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">1.1.2 数据结构三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 算法的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">计算时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">常见的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">2.6.</span> <span class="toc-text">图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">散列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.8.</span> <span class="toc-text">堆</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>