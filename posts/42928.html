<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构-线性表（下） | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>数据结构-线性表（下）</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-04-05T16:24:40.000Z" id="date"> 2025-04-06</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-04-06T07:02:49.513Z" id="updated"> 2025-04-06</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><h2 id="链表（链式存储结构）"><a href="#链表（链式存储结构）" class="headerlink" title="链表（链式存储结构）"></a>链表（链式存储结构）</h2><p>链表又称单链表、链式存储结构，用于存储逻辑关系为“一对一”的数据。</p>
<p>和顺序表不同，使用链表存储数据，不强制要求数据在内存中集中存储，各个元素可以分散存储在内存中。例如，使用链表存储 {1,2,3}，各个元素在内存中的存储状态可能是：</p>
<p class='item-img' data-src='https://pic2.zhimg.com/v2-5d42c22a139067e60fadd7957ef2c383_b.jpg'><img src="https://pic2.zhimg.com/v2-5d42c22a139067e60fadd7957ef2c383_b.jpg" alt="动图封面"></p>
<p>可以看到，数据不仅没有集中存放，在内存中的存储次序也是混乱的。那么，链表是如何存储数据间逻辑关系的呢？</p>
<p>链表存储数据间逻辑关系的实现方案是：为每一个元素配置一个指针，每个元素的指针都指向自己的直接后继元素，如下图所示：</p>
<p class='item-img' data-src='https://pic4.zhimg.com/v2-fdb02aabf90a9eb2d64c5e8a06feb053_b.jpg'><img src="https://pic4.zhimg.com/v2-fdb02aabf90a9eb2d64c5e8a06feb053_b.jpg" alt="动图封面"></p>
<p>显然，我们只需要记住元素 1 的存储位置，通过它的指针就可以找到元素 2，通过元素 2 的指针就可以找到元素 3，以此类推，各个元素的先后次序一目了然。</p>
<p>像图 2 这样，数据元素随机存储在内存中，通过指针维系数据之间“一对一”的逻辑关系，这样的存储结构就是链表。</p>
<h3 id="结点（节点）"><a href="#结点（节点）" class="headerlink" title="结点（节点）"></a>结点（节点）</h3><blockquote>
<p>很多教材中，也将“结点”写成“节点”，它们是一个意思。</p>
</blockquote>
<p>在链表中，每个数据元素都配有一个指针，这意味着，链表上的每个“元素”都长下图这个样子：</p>
<p class='item-img' data-src='https://pic3.zhimg.com/v2-375eac6ce04146b28224cf447e00b012_b.jpg'><img src="https://pic3.zhimg.com/v2-375eac6ce04146b28224cf447e00b012_b.jpg" alt="动图封面"></p>
<p>数据域用来存储元素的值，指针域用来存放指针。数据结构中，通常将图 3 这样的整体称为结点。</p>
<p>也就是说，链表中实际存放的是一个一个的结点，数据元素存放在各个结点的数据域中。举个简单的例子，图 2 中 {1,2,3} 的存储状态用链表表示，如下图所示：</p>
<p class='item-img' data-src='https://pic1.zhimg.com/v2-6c920d117fb3d0a2bdcccfd3b002e20c_b.jpg'><img src="https://pic1.zhimg.com/v2-6c920d117fb3d0a2bdcccfd3b002e20c_b.jpg" alt="动图封面"></p>
<p>在 C 语言中，可以用结构体表示链表中的结点，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span>&#123;<br>    <span class="hljs-type">char</span> elem; <span class="hljs-comment">//代表数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span> * next; <span class="hljs-comment">//代表指针域，指向直接后继元素</span><br>&#125;Link;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>我们习惯将结点中的指针命名为 next，因此指针域又常称为“Next 域”。</p>
</blockquote>
<h3 id="头结点、头指针和首元结点"><a href="#头结点、头指针和首元结点" class="headerlink" title="头结点、头指针和首元结点"></a>头结点、头指针和首元结点</h3><p>图 4 所示的链表并不完整，一个完整的链表应该由以下几部分构成：</p>
<ol>
<li>头指针：一个和结点类型相同的指针，它的特点是：永远指向链表中的第一个结点。上文提到过，我们需要记录链表中第一个元素的存储位置，就是用头指针实现。</li>
<li>结点：链表中的节点又细分为头结点、首元结点和其它结点：</li>
</ol>
<ul>
<li>头结点：某些场景中，为了方便解决问题，会故意在链表的开头放置一个空结点，这样的结点就称为头结点。也就是说，头结点是位于链表开头、数据域为空（不利用）的结点。</li>
<li>首元结点：指的是链表开头第一个存有数据的结点。</li>
<li>其他节点：链表中其他的节点。</li>
</ul>
<p>也就是说，一个完整的链表是由头指针和诸多个结点构成的。每个链表都必须有头指针，但头结点不是必须的。</p>
<p>例如，创建一个包含头结点的链表存储 {1,2,3}，如下图所示：</p>
<p class='item-img' data-src='https://pic1.zhimg.com/v2-f2b1f40c7ed8cb36d1c7f3215f7b5530_b.jpg'><img src="https://pic1.zhimg.com/v2-f2b1f40c7ed8cb36d1c7f3215f7b5530_b.jpg" alt="动图封面"></p>
<p>再次强调，头指针永远指向链表中的第一个结点。换句话说，如果链表中包含头结点，那么头指针指向的是头结点，反之头指针指向首元结点。</p>
<h3 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h3><p>创建一个链表，实现步骤如下：</p>
<ol>
<li>定义一个头指针；</li>
<li>创建一个头结点或者首元结点，让头指针指向它；</li>
<li>每创建一个结点，都令其直接前驱结点的指针指向它。</li>
</ol>
<p>例如，创建一个存储 {1,2,3,4} 且无头节点的链表，C 语言实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建首元结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">1</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向首元结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再比如，创建一个存储 {1,2,3,4} 且含头节点的链表，则 C 语言实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建头结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">0</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向头结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链表的使用"><a href="#链表的使用" class="headerlink" title="链表的使用"></a>链表的使用</h3><p>对于创建好的链表，我们可以依次获取链表中存储的数据，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">//链表中节点的结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span> &#123;<br>    <span class="hljs-type">int</span>  elem;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span>* next;<br>&#125;Link;<br><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建头结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">0</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向头结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Link* p)</span> </span>&#123;<br>    Link* temp = p;<span class="hljs-comment">//temp指针用来遍历链表</span><br>    <span class="hljs-comment">//只要temp指向结点的next值不是NULL，就执行输出语句。</span><br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        Link* f = temp;<span class="hljs-comment">//准备释放链表中的结点</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, temp-&gt;elem);<br>        temp = temp-&gt;next;<br>        <span class="hljs-built_in">free</span>(f);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化链表为：\n&quot;</span>);<br>    <span class="hljs-comment">//创建链表&#123;1,2,3,4&#125;</span><br>    p = <span class="hljs-built_in">initLink</span>();<br>    <span class="hljs-comment">//输出链表中的数据</span><br>    <span class="hljs-built_in">display</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序中创建的是带头结点的链表，头结点的数据域存储的是元素 0，因此最终的输出结果为：</p>
<blockquote>
<p>0 1 2 3 4</p>
</blockquote>
<p>如果不想输出头结点的值，可以将 p-&gt;next 作为实参传递给 display() 函数。</p>
<p>如果程序中创建的是不带头结点的链表，最终的输出结果应该是：</p>
<blockquote>
<p>1 2 3 4</p>
</blockquote>
<h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><p>学会创建链表之后，本节继续讲解链表的一些基本操作，包括向链表中添加数据、删除链表中的数据、查找和更改链表中的数据。</p>
<p>首先，创建一个带头结点的链表，链表中存储着 {1,2,3,4}：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链表中节点的结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span> &#123;<br>    <span class="hljs-type">int</span>  elem;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link</span>* next;<br>&#125;Link;<br><span class="hljs-function">Link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//1、创建头指针</span><br>    Link* p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//2、创建头结点</span><br>    Link* temp = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    temp-&gt;elem = <span class="hljs-number">0</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//头指针指向头结点</span><br>    p = temp;<br>    <span class="hljs-comment">//3、每创建一个结点，都令其直接前驱结点的指针指向它</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个结点</span><br>        Link* a = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//每次 temp 指向的结点就是 a 的直接前驱结点</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//temp指向下一个结点（也就是a),为下次添加结点做准备</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链表插入元素"><a href="#链表插入元素" class="headerlink" title="链表插入元素"></a>链表插入元素</h3><p>同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：</p>
<ul>
<li>插入到链表的头部，作为首元节点；</li>
<li>插入到链表中间的某个位置；</li>
<li>插入到链表的最末端，作为链表中最后一个结点；</li>
</ul>
<p>对于有头结点的链表，3 种插入元素的实现思想是相同的，具体步骤是：</p>
<ol>
<li>将新结点的 next 指针指向插入位置后的结点；</li>
<li>将插入位置前结点的 next 指针指向插入结点；</li>
</ol>
<p>例如，在链表 {1,2,3,4}的基础上分别实现在头部、中间、尾部插入新元素 5，其实现过程如下图所示：</p>
<p class='item-img' data-src='https://pica.zhimg.com/v2-2b74576c4133d98967e430da2a156c6e_b.jpg'><img src="https://pica.zhimg.com/v2-2b74576c4133d98967e430da2a156c6e_b.jpg" alt="动图封面"></p>
<p>从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem, <span class="hljs-type">int</span> add)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Link* c = <span class="hljs-literal">NULL</span>;<br>    Link* temp = p;<span class="hljs-comment">//创建临时结点temp</span><br>    <span class="hljs-comment">//首先找到要插入位置的上一个结点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add; i++) &#123;<br>        temp = temp-&gt;next;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置无效\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//创建插入结点c</span><br>    c = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>    c-&gt;elem = elem;<br>    <span class="hljs-comment">//① 将新结点的 next 指针指向插入位置后的结点</span><br>    c-&gt;next = temp-&gt;next;<br>    <span class="hljs-comment">//② 将插入位置前结点的 next 指针指向插入结点；</span><br>    temp-&gt;next = c;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 1。</p>
<p>对于没有头结点的链表，在头部插入结点比较特殊，需要单独实现。</p>
<p class='item-img' data-src='https://pica.zhimg.com/v2-bc993f6cb9d4f6bfd732b0a341cfdf84_b.jpg'><img src="https://pica.zhimg.com/v2-bc993f6cb9d4f6bfd732b0a341cfdf84_b.jpg" alt="动图封面"></p>
<p>和 2)、3) 种情况相比，由于链表没有头结点，在头部插入新结点，此结点之前没有任何结点，实现的步骤如下：</p>
<ol>
<li>将新结点的指针指向首元结点；</li>
<li>将头指针指向新结点。</li>
</ol>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Link* <span class="hljs-title">insertElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem, <span class="hljs-type">int</span> add)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (add == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//创建插入结点c</span><br>        Link* c = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        c-&gt;elem = elem;<br>        c-&gt;next = p;<br>        p = c;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        Link* c = <span class="hljs-literal">NULL</span>;<br>        Link* temp = p;<span class="hljs-comment">//创建临时结点temp</span><br>        <span class="hljs-comment">//首先找到要插入位置的上一个结点</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add<span class="hljs-number">-1</span>; i++) &#123;<br>            temp = temp-&gt;next;<br>            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置无效\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//创建插入结点c</span><br>        c = (Link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Link));<br>        c-&gt;elem = elem;<br>        <span class="hljs-comment">//向链表中插入结点</span><br>        c-&gt;next = temp-&gt;next;<br>        temp-&gt;next = c;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意当 add&#x3D;&#x3D;1 成立时，形参指针 p 的值会发生变化，因此需要它的新值作为函数的返回值返回。</p>
</blockquote>
<h3 id="链表删除元素"><a href="#链表删除元素" class="headerlink" title="链表删除元素"></a>链表删除元素</h3><p>从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除。</p>
<p>对于有头结点的链表来说，无论删除头部（首元结点）、中部、尾部的结点，实现方式都一样，执行以下三步操作：</p>
<ol>
<li>找到目标元素所在结点的直接前驱结点；</li>
<li>将目标结点从链表中摘下来;</li>
<li>手动释放结点占用的内存空间；</li>
</ol>
<p>从链表上摘除目标节点，只需找到该节点的直接前驱节点 temp，执行如下操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">temp-&gt;next=temp-&gt;next-&gt;next;<br></code></pre></td></tr></table></figure>

<p>例如，从存有 {1,2,3,4}的链表中删除存储元素 3 的结点，则此代码的执行效果如图 3 所示：</p>
<p class='item-img' data-src='https://pica.zhimg.com/v2-6d8f7d30515db53226312254da2db706_b.jpg'><img src="https://pica.zhimg.com/v2-6d8f7d30515db53226312254da2db706_b.jpg" alt="动图封面"></p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p为原链表，elem 为要删除的目标元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    Link* del = <span class="hljs-literal">NULL</span>, *temp = p;<br>    <span class="hljs-type">int</span> find = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//1、找到目标元素的直接前驱结点</span><br>    <span class="hljs-keyword">while</span> (temp-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;next-&gt;elem == elem) &#123;<br>            find = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (find == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//删除失败</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//标记要删除的结点</span><br>        del = temp-&gt;next;<br>        <span class="hljs-comment">//2、将目标结点从链表上摘除</span><br>        temp-&gt;next = temp-&gt;next-&gt;next;<br>        <span class="hljs-comment">//3、释放目标结点</span><br>        <span class="hljs-built_in">free</span>(del);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于不带头结点的链表，需要单独考虑删除首元结点的情况，删除其它结点的方式和上图完全相同，如下图所示：</p>
<p class='item-img' data-src='https://pica.zhimg.com/v2-a82095c25e668736e2d38dcccf45a5bc_b.jpg'><img src="https://pica.zhimg.com/v2-a82095c25e668736e2d38dcccf45a5bc_b.jpg" alt="动图封面"></p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p为原链表，elem 为要删除的目标元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delElem</span><span class="hljs-params">(Link** p, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    Link* del = <span class="hljs-literal">NULL</span>, *temp = *p;<br>    <span class="hljs-comment">//删除首元结点需要单独考虑</span><br>    <span class="hljs-keyword">if</span> (temp-&gt;elem == elem) &#123;<br>        (*p) = (*p)-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> find = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//1、找到目标元素的直接前驱结点</span><br>        <span class="hljs-keyword">while</span> (temp-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (temp-&gt;next-&gt;elem == elem) &#123;<br>                find = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            temp = temp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (find == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//删除失败</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//标记要删除的结点</span><br>            del = temp-&gt;next;<br>            <span class="hljs-comment">//2、将目标结点从链表上摘除</span><br>            temp-&gt;next = temp-&gt;next-&gt;next;<br>            <span class="hljs-comment">//3、释放目标结点</span><br>            <span class="hljs-built_in">free</span>(del);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数返回 1 时，表示删除成功；返回 -1，表示删除失败。注意，该函数的形参 p 为二级指针，调用时需要传递链表头指针的地址。</p>
<h3 id="链表查找元素"><a href="#链表查找元素" class="headerlink" title="链表查找元素"></a>链表查找元素</h3><p>在链表中查找指定数据元素，最常用的方法是：从首元结点开始依次遍历所有节点，直至找到存储目标元素的结点。如果遍历至最后一个结点仍未找到，表明链表中没有存储该元素。</p>
<p>因此，链表中查找特定数据元素的 C 语言实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p为原链表，elem表示被查找元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//带头结点，p 指向首元结点</span><br>    p = p-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;elem == elem) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        p = p-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//返回-1，表示未找到</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意第 5 行代码，对于有结点的链表，需要先将 p 指针指向首元结点；反之，对于不带头结点的链表，注释掉第 5 行代码即可。</p>
<h3 id="链表更新元素"><a href="#链表更新元素" class="headerlink" title="链表更新元素"></a>链表更新元素</h3><p>更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。</p>
<p>直接给出链表中更新数据元素的 C 语言实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p 为有头结点的链表，oldElem 为旧元素，newElem 为新元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">amendElem</span><span class="hljs-params">(Link* p, <span class="hljs-type">int</span> oldElem, <span class="hljs-type">int</span> newElem)</span> </span>&#123;<br>    p = p-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;elem == oldElem) &#123;<br>            p-&gt;elem = newElem;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数返回 1，表示更改成功；返回数字 -1，表示更改失败。如果是没有头结点的链表，直接删除第 3 行代码即可。</p>
<hr>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>目前我们所学到的链表，无论是动态链表还是静态链表，表中各个节点都只包含一个指针（游标），且都统一指向直接后继节点，这类链表又统称为单向链表或单链表。</p>
<p>虽然单链表能 100% 存储逻辑关系为 “一对一” 的数据，但在解决某些实际问题时，单链表的执行效率并不高。例如，若实际问题中需要频繁地查找某个结点的前驱结点，使用单链表存储数据显然没有优势，因为单链表的强项是从前往后查找目标元素，不擅长从后往前查找元素。</p>
<p>解决此类问题，可以建立双向链表（简称双链表）。</p>
<h3 id="双向链表是什么"><a href="#双向链表是什么" class="headerlink" title="双向链表是什么"></a>双向链表是什么</h3><p>从名字上理解双向链表，即链表是 “双向” 的，如下图所示：</p>
<p class='item-img' data-src='https://pic4.zhimg.com/v2-62da5191aa8b27e80c1ffc4b1d61d367_b.jpg'><img src="https://pic4.zhimg.com/v2-62da5191aa8b27e80c1ffc4b1d61d367_b.jpg" alt="动图封面"></p>
<p>“双向”指的是各节点之间的逻辑关系是双向的，头指针通常只设置一个。</p>
<p>从上图中可以看到，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：</p>
<ol>
<li>指针域：用于指向当前节点的直接前驱节点；</li>
<li>数据域：用于存储数据元素。</li>
<li>指针域：用于指向当前节点的直接后继节点；</li>
</ol>
<p class='item-img' data-src='https://pic4.zhimg.com/v2-6b063e7219eb5143755d567c16dc06b1_b.jpg'><img src="https://pic4.zhimg.com/v2-6b063e7219eb5143755d567c16dc06b1_b.jpg" alt="动图封面"></p>
<p>因此，双链表的节点结构用 C 语言实现为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> * prior; <span class="hljs-comment">//指向直接前趋</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> * next; <span class="hljs-comment">//指向直接后继</span><br>&#125;Line;<br></code></pre></td></tr></table></figure>

<h3 id="双向链表的创建"><a href="#双向链表的创建" class="headerlink" title="双向链表的创建"></a>双向链表的创建</h3><p>同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。</p>
<p>需要注意的是，与单链表不同，双链表创建过程中，每创建一个新节点都要与其前驱节点建立两次联系，分别是：</p>
<ul>
<li>将新节点的 prior 指针指向直接前驱节点；</li>
<li>将直接前驱节点的 next 指针指向新节点；</li>
</ul>
<p>这里给出创建双向链表的 C 语言实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以尝试着在 main 函数中输出创建的双链表，C 语言代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* prior; <span class="hljs-comment">//指向直接前趋</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* next; <span class="hljs-comment">//指向直接后继</span><br>&#125;Line;<br><br><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//输出链表中的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-comment">//如果该节点无后继节点，说明此节点是链表的最后一个节点</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, temp-&gt;data);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &lt;-&gt; &quot;</span>, temp-&gt;data);<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//释放链表中结点占用的空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free_line</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = head;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个头指针</span><br>    Line* head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//调用链表创建函数</span><br>    head = <span class="hljs-built_in">initLine</span>(head);<br>    <span class="hljs-comment">//输出创建好的链表</span><br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-comment">//显示双链表的优点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表中第 4 个节点的直接前驱是：%d&quot;</span>, head-&gt;next-&gt;next-&gt;next-&gt;prior-&gt;data);<br>    <span class="hljs-built_in">free_line</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<blockquote>
<p>1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 链表中第 4 个节点的直接前驱是：3</p>
</blockquote>
<h2 id="双向链表基本操作"><a href="#双向链表基本操作" class="headerlink" title="双向链表基本操作"></a>双向链表基本操作</h2><p>前面学习了如何创建一个双向链表，本节学习有关双向链表的一些基本操作，即如何在双向链表中添加、删除、查找或更改数据元素。</p>
<p>本节知识基于已熟练掌握双向链表创建过程的基础上，我们继续上节所创建的双向链表来学习本节内容，创建好的双向链表如下图所示：</p>
<p class='item-img' data-src='https://pic2.zhimg.com/v2-c5f7cce2077c56369e912c09fbe8b1ef_b.jpg'><img src="https://pic2.zhimg.com/v2-c5f7cce2077c56369e912c09fbe8b1ef_b.jpg" alt="动图封面"></p>
<p>图 双向链表示意图</p>
<h3 id="双向链表添加节点"><a href="#双向链表添加节点" class="headerlink" title="双向链表添加节点"></a>双向链表添加节点</h3><p>根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：</p>
<ol>
<li>添加至表头</li>
</ol>
<p>将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。</p>
<p>换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：</p>
<ol>
<li>temp-&gt;next&#x3D;head; head-&gt;prior&#x3D;temp;</li>
<li>将 head 移至 temp，重新指向新的表头；</li>
</ol>
<p>例如，将新元素 7 添加至双链表的表头，则实现过程如图 2 所示：</p>
<p class='item-img' data-src='https://pic2.zhimg.com/v2-b9156e5d719713d2e4e61c308869a13b_b.jpg'><img src="https://pic2.zhimg.com/v2-b9156e5d719713d2e4e61c308869a13b_b.jpg" alt="动图封面"></p>
<p>图 添加元素至双向链表的表头</p>
<ol start="2">
<li>添加至表的中间位置</li>
</ol>
<p>同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，如下图所示：</p>
<ol>
<li>新节点先与其直接后继节点建立双层逻辑关系；</li>
<li>新节点的直接前驱节点与之建立双层逻辑关系；</li>
</ol>
<p class='item-img' data-src='https://pic2.zhimg.com/v2-f5407b137acf9de84e56c5e30cfc16e7_b.jpg'><img src="https://pic2.zhimg.com/v2-f5407b137acf9de84e56c5e30cfc16e7_b.jpg" alt="动图封面"></p>
<p>图 双向链表中间位置添加数据元素</p>
<ol start="3">
<li>添加至表尾</li>
</ol>
<p>与添加到表头是一个道理，实现过程如下（如图 4 所示）：</p>
<ol>
<li>找到双链表中最后一个节点；</li>
<li>让新节点与最后一个节点进行双层逻辑关系；</li>
</ol>
<p class='item-img' data-src='https://pic1.zhimg.com/v2-829fe83055126221b40116352bf5cdc6_b.jpg'><img src="https://pic1.zhimg.com/v2-829fe83055126221b40116352bf5cdc6_b.jpg" alt="动图封面"></p>
<p>图 双向链表尾部添加数据元素</p>
<p>因此，我们可以试着编写双向链表添加数据的 C 语言代码，参考代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Line* <span class="hljs-title">insertLine</span><span class="hljs-params">(Line* head, <span class="hljs-type">int</span> data, <span class="hljs-type">int</span> add)</span> </span>&#123;<br>    <span class="hljs-comment">//新建数据域为data的结点</span><br>    Line* temp = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>    temp-&gt;data = data;<br>    temp-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//插入到链表头，要特殊考虑</span><br>    <span class="hljs-keyword">if</span> (add == <span class="hljs-number">1</span>) &#123;<br>        temp-&gt;next = head;<br>        head-&gt;prior = temp;<br>        head = temp;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        Line* body = head;<br>        <span class="hljs-comment">//找到要插入位置的前一个结点</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add - <span class="hljs-number">1</span>; i++) &#123;<br>            body = body-&gt;next;<br>            <span class="hljs-comment">//只要 body 不存在，表明插入位置输入错误</span><br>            <span class="hljs-keyword">if</span> (!body) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置有误！\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断条件为真，说明插入位置为链表尾，实现第 2 种情况</span><br>        <span class="hljs-keyword">if</span> (body &amp;&amp; (body-&gt;next == <span class="hljs-literal">NULL</span>)) &#123;<br>            body-&gt;next = temp;<br>            temp-&gt;prior = body;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//第 2 种情况的具体实现</span><br>            body-&gt;next-&gt;prior = temp;<br>            temp-&gt;next = body-&gt;next;<br>            body-&gt;next = temp;<br>            temp-&gt;prior = body;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双向链表删除节点"><a href="#双向链表删除节点" class="headerlink" title="双向链表删除节点"></a>双向链表删除节点</h3><p>和添加结点的思想类似，在双向链表中删除目标结点也分为 3 种情况。</p>
<ol>
<li>删除表头结点</li>
</ol>
<p>删除表头结点的过程如下图所示：</p>
<p class='item-img' data-src='https://picx.zhimg.com/v2-66cf8b9a6cc816e4a69143a68b662e25_b.jpg'><img src="https://picx.zhimg.com/v2-66cf8b9a6cc816e4a69143a68b662e25_b.jpg" alt="动图封面"></p>
<p>删除表头结点的实现过程是：</p>
<ol>
<li>新建一个指针指向表头结点；</li>
<li>断开表头结点和其直接后续结点之间的关联，更改 head 头指针的指向，同时将其直接后续结点的 prior 指针指向 NULL；</li>
<li>释放表头结点占用的内存空间。</li>
<li>删除表中结点</li>
</ol>
<p>删除表中结点的过程如下图所示：</p>
<p class='item-img' data-src='https://pic2.zhimg.com/v2-08e8d26851903ee8889321bbd20279d9_b.jpg'><img src="https://pic2.zhimg.com/v2-08e8d26851903ee8889321bbd20279d9_b.jpg" alt="动图封面"></p>
<p>删除表中结点的实现过程是：</p>
<ol>
<li>找到目标结点，新建一个指针指向改结点；</li>
<li>将目标结点从链表上摘除；</li>
<li>释放该结点占用的内存空间。</li>
<li>删除表尾结点</li>
</ol>
<p>删除表尾结点的过程如下图所示：</p>
<p class='item-img' data-src='https://picx.zhimg.com/v2-8c26da9694cfa9d5cdbe2043e553795b_b.jpg'><img src="https://picx.zhimg.com/v2-8c26da9694cfa9d5cdbe2043e553795b_b.jpg" alt="动图封面"></p>
<p>删除表尾结点的实现过程是：</p>
<ol>
<li>找到表尾结点，新建一个指针指向该结点；</li>
<li>断点表尾结点和其直接前驱结点的关联，并将其直接前驱结点的 next 指针指向 NULL；</li>
<li>释放表尾结点占用的内存空间。</li>
</ol>
<p>双向链表删除节点的 C 语言实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除结点的函数，data为要删除结点的数据域的值</span><br><span class="hljs-function">Line* <span class="hljs-title">delLine</span><span class="hljs-params">(Line* head, <span class="hljs-type">int</span> data)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;data == data) &#123;<br>            <span class="hljs-comment">//删除表头结点</span><br>            <span class="hljs-keyword">if</span> (temp-&gt;prior == <span class="hljs-literal">NULL</span>) &#123;<br>                head = head-&gt;next;<br>                <span class="hljs-keyword">if</span> (head) &#123;<br>                    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>                    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-built_in">free</span>(temp);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            <span class="hljs-comment">//删除表中结点</span><br>            <span class="hljs-keyword">if</span> (temp-&gt;prior &amp;&amp; temp-&gt;next) &#123;<br>                temp-&gt;next-&gt;prior = temp-&gt;prior;<br>                temp-&gt;prior-&gt;next = temp-&gt;next;<br>                <span class="hljs-built_in">free</span>(temp);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            <span class="hljs-comment">//删除表尾结点</span><br>            <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>                temp-&gt;prior-&gt;next = <span class="hljs-literal">NULL</span>;<br>                temp-&gt;prior = <span class="hljs-literal">NULL</span>;<br>                <span class="hljs-built_in">free</span>(temp);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表中没有目标元素，删除失败\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双向链表查找节点"><a href="#双向链表查找节点" class="headerlink" title="双向链表查找节点"></a>双向链表查找节点</h3><p>通常情况下，双向链表和单链表一样都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，也是从表头依次遍历表中元素。</p>
<p>C 语言实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//head为原双链表，elem表示被查找元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(line * head,<span class="hljs-type">int</span> elem)</span></span>&#123;<br><span class="hljs-comment">//新建一个指针t，初始化为头指针 head</span><br>    line * t=head;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (t-&gt;data==elem) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        i++;<br>        t=t-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//程序执行至此处，表示查找失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双向链表更改节点"><a href="#双向链表更改节点" class="headerlink" title="双向链表更改节点"></a>双向链表更改节点</h3><p>更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p>
<p>实现此操作的 C 语言实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//更新函数，其中，add 表示要修改的元素，newElem 为新数据的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">amendElem</span><span class="hljs-params">(Line* p, <span class="hljs-type">int</span> oldElem, <span class="hljs-type">int</span> newElem)</span> </span>&#123;<br>    Line* temp = p;<br>    <span class="hljs-type">int</span> find = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//找到要修改的目标结点</span><br>    <span class="hljs-keyword">while</span> (temp)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;data == oldElem) &#123;<br>            find = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//成功找到，则进行更改操作</span><br>    <span class="hljs-keyword">if</span> (find == <span class="hljs-number">1</span>) &#123;<br>        temp-&gt;data = newElem;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//查找失败，输出提示信息</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表中未找到目标元素，更改失败\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>无论静态链表还是动态链表，有时在解决具体问题时，需要我们对其结构进行稍微地调整。比如，可以把链表的两头连接，使其成为了一个环状链表，通常称为循环链表。</p>
<p>和它名字的表意一样，只需要将表中最后一个结点的指针指向头结点，链表就能成环儿，如下图所示。</p>
<p class='item-img' data-src='https://picx.zhimg.com/v2-584465255c37aeaae235df42d7f2ab39_1440w.jpg'><img src="https://picx.zhimg.com/v2-584465255c37aeaae235df42d7f2ab39_1440w.jpg" alt="img"></p>
<p>需要注意的是，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。</p>
<p>这里给大家一个循环链表的实例，用循环链表实现约瑟夫环</p>
<p><a href="https://link.zhihu.com/?target=https://xiexuewu.github.io/view/7.html">循环链表实现约瑟夫环 - 玩转C语言和数据结构xiexuewu.github.io&#x2F;view&#x2F;7.html</a></p>
<h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p>我们知道，单链表通过首尾连接可以构成单向循环链表，如下图所示：</p>
<p class='item-img' data-src='https://pic3.zhimg.com/v2-2996fac84cba2bbc4ce278d68ec1f40c_b.jpg'><img src="https://pic3.zhimg.com/v2-2996fac84cba2bbc4ce278d68ec1f40c_b.jpg" alt="动图封面"></p>
<p>同样，双向链表也可以进行首尾连接，构成双向循环链表。如下图所示：</p>
<p class='item-img' data-src='https://pic3.zhimg.com/v2-6661ba94cff67952b5108a7af5ca4564_b.jpg'><img src="https://pic3.zhimg.com/v2-6661ba94cff67952b5108a7af5ca4564_b.jpg" alt="动图封面"></p>
<p>解决某些问题，可能既需要正向遍历数据，又需要逆向遍历数据，这时就可以考虑使用双向循环链表。</p>
<h3 id="双向循环链表的创建"><a href="#双向循环链表的创建" class="headerlink" title="双向循环链表的创建"></a>双向循环链表的创建</h3><p>创建双向循环链表，只需在创建完成双向链表的基础上，将其首尾节点进行双向连接即可。</p>
<p>C 语言实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建双向循环链表</span><br><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接</span><br>    list-&gt;next=head;<br>    head-&gt;prior=list;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过向 main 函数中调用 initLine 函数，就可以成功创建一个存储有 {1,2,3} 数据的双向循环链表，其完整的 C 语言实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* prior; <span class="hljs-comment">//指向直接前趋</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>* next; <span class="hljs-comment">//指向直接后继</span><br>&#125;Line;<br><span class="hljs-comment">//创建双向循环链表</span><br><span class="hljs-function">Line* <span class="hljs-title">initLine</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    Line* list = <span class="hljs-literal">NULL</span>;<br>    head = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<span class="hljs-comment">//创建链表第一个结点（首元结点）</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-comment">//创建并初始化一个新结点</span><br>        Line* body = (Line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//直接前趋结点的next指针指向新结点</span><br>        list-&gt;next = body;<br>        <span class="hljs-comment">//新结点指向直接前趋结点</span><br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接</span><br>    list-&gt;next = head;<br>    head-&gt;prior = list;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//输出链表中的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = head;<br>    <span class="hljs-comment">//由于是循环链表，所以当遍历指针temp指向的下一个节点是head时，证明此时已经循环至链表的最后一个节点</span><br>    <span class="hljs-keyword">while</span> (temp-&gt;next != head) &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, temp-&gt;data);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, temp-&gt;data);<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//输出循环链表中最后一个节点的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, temp-&gt;data);<br>&#125;<br><span class="hljs-comment">//释放链表中结点占用的空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free_line</span><span class="hljs-params">(Line* head)</span> </span>&#123;<br>    Line* temp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//切断循环</span><br>    head-&gt;prior-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//从第一个结点开始，依次 free</span><br>    temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = head;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个头指针</span><br>    Line* head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//调用链表创建函数</span><br>    head = <span class="hljs-built_in">initLine</span>(head);<br>    <span class="hljs-comment">//输出创建好的链表</span><br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-comment">//手动释放链表占用的内存</span><br>    <span class="hljs-built_in">free_line</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序输出结果如下：</p>
<blockquote>
<p>1-&gt;2-&gt;3</p>
</blockquote>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/23014.html">数据结构-线性表（上） Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%88%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">链表（链式存储结构）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%EF%BC%88%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">结点（节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%81%E5%A4%B4%E6%8C%87%E9%92%88%E5%92%8C%E9%A6%96%E5%85%83%E7%BB%93%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">头结点、头指针和首元结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.</span> <span class="toc-text">链表的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">链表的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">单链表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">链表插入元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">链表删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.</span> <span class="toc-text">链表查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0"><span class="toc-number">2.4.</span> <span class="toc-text">链表更新元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">双向链表是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">3.2.</span> <span class="toc-text">双向链表的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">双向链表基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">双向链表添加节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">双向链表删除节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">双向链表查找节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%9B%B4%E6%94%B9%E8%8A%82%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">双向链表更改节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">6.</span> <span class="toc-text">双向循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.1.</span> <span class="toc-text">双向循环链表的创建</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>