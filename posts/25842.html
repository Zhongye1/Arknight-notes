<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构-算法复杂度 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>数据结构-算法复杂度</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-04-05T08:09:55.000Z" id="date"> 2025-04-05</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-04-06T06:09:57.643Z" id="updated"> 2025-04-06</time></div></span><br><span id="busuanzi_container_page_pv">页面浏览: <span class="control" id="busuanzi_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>算法复杂度旨在计算在输入数据量 N的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数据大小 N」而增大的速度。</p>
<p>算法复杂度主要可从 <strong>时间</strong> 、<strong>空间</strong> 两个角度评价：</p>
<ul>
<li><strong>时间：</strong> 假设各操作的运行时间为固定常数，统计算法运行的「计算操作的数量」 ，以代表算法运行所需时间；</li>
<li><strong>空间：</strong> 统计在最差情况下，算法运行所需使用的「最大空间」；</li>
</ul>
<p>「输入数据大小N」指算法处理的输入数据量；根据不同算法，具有不同定义，例如：</p>
<ul>
<li><strong>排序算法：</strong> N代表需要排序的元素数量；</li>
<li><strong>搜索算法：</strong> N代表搜索范围的元素总数，例如数组大小、矩阵大小、二叉树节点数、图节点和边数等；</li>
</ul>
<p>接下来，我们将分别从概念定义、符号表示、常见种类、时空权衡、示例解析、示例题目等角度入手，学习「时间复杂度」和「空间复杂度」。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><strong>代码执行次数的简化估算值就是时间复杂度。</strong></p>
<p>一些例子</p>
<ol>
<li><p>线性复杂度<em>O</em>(<em>N</em>)：单层循环，如遍历数组求和。</p>
</li>
<li><p>对数复杂度<em>O</em>(log<em>N</em>)：二分查找。</p>
</li>
<li><p>线性对数复杂度<em>O</em>(<em>N</em>log<em>N</em>)：快速排序或归并排序的分治策略。</p>
</li>
<li><p>平方复杂度<em>O</em>(<em>N</em>^2)：双重循环，如冒泡排序。</p>
</li>
<li><p>指数复杂度<em>O</em>(2^<em>N</em>)：递归斐波那契。</p>
</li>
<li><p>阶乘复杂度<em>O</em>(<em>N</em>!)：全排列生成。</p>
</li>
</ol>
<p>   其中有：<em>O</em>(1)&lt;<em>O</em>(log<em>N</em>)&lt;<em>O</em>(<em>N</em>)&lt;<em>O</em>(<em>N</em>log<em>N</em>)&lt;<em>O</em>(<em>N</em>^2)&lt;<em>O</em>(2^<em>N</em>)&lt;<em>O</em>(<em>N</em>!)</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f219793a6bc.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f219793a6bc.png" alt=""></p>
<h3 id="基本复杂度计算"><a href="#基本复杂度计算" class="headerlink" title="基本复杂度计算"></a><strong>基本复杂度计算</strong></h3><p>层层（循环、递归）相加：比如有2层循环，第一层循环共执行n次基本语句，每个基本语句执行1次，也就是n个“1”次相加，为n；第二层循环执行log2n次第一次循环，每个第一次循环执行n次，总的也就是log2n个“n”次相加为nlog2n，故时间复杂度为O(nlogn)。</p>
<h3 id="复杂度计算的核心规则"><a href="#复杂度计算的核心规则" class="headerlink" title="复杂度计算的核心规则"></a>复杂度计算的核心规则</h3><ol>
<li><strong>单层循环</strong>：直接取循环次数，如 <code>O(n)</code>.  </li>
<li><strong>嵌套循环</strong>：各层循环次数相乘，如 <code>O(n²)</code> 或 <code>O(n log n)</code>.  </li>
<li><strong>递归算法</strong>：<br>• 递归次数 × 每次递归的操作次数，如斐波那契数列的 <code>O(2ⁿ)</code>.<br>• 分治策略（如归并排序）通过主定理计算，结果为 <code>O(n log n)</code>.  </li>
<li><strong>忽略低阶项</strong>：如 <code>T(n) = 3n² + 2n + 1</code> 简化为 <code>O(n²)</code>.  </li>
</ol>
<h3 id="1-O-1-—-常数复杂度"><a href="#1-O-1-—-常数复杂度" class="headerlink" title="1. O(1) — 常数复杂度"></a><strong>1. O(1) — 常数复杂度</strong></h3><p><strong>特点</strong>：运行次数与 N 大小呈常数关系，即不随输入数据大小 N 的变化而变化。</p>
<p><strong>示例</strong>：访问数组元素或交换变量。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 访问数组元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> arr[index]; <span class="hljs-comment">// 无论数组大小，直接访问固定位置</span><br>&#125;<br><br><span class="hljs-comment">// 交换变量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;<br>    <span class="hljs-type">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp; <span class="hljs-comment">// 仅需三次赋值操作</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f219792807e.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f219792807e.png" alt=""></p>
<hr>
<h3 id="2-O-log-n-—-对数复杂度"><a href="#2-O-log-n-—-对数复杂度" class="headerlink" title="2. O(log n) — 对数复杂度"></a><strong>2. O(log n) — 对数复杂度</strong></h3><p><strong>特点</strong>：每次操作将问题规模缩减为固定比例（如折半）。<br><strong>示例</strong>：二分查找。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 每次搜索范围减半</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如下图所示，为二分查找的时间复杂度示意图，每次二分将搜索区间缩小一半。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197929e82.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197929e82.png" alt=""></p>
<hr>
<h3 id="3-O-n-—-线性复杂度"><a href="#3-O-n-—-线性复杂度" class="headerlink" title="3. O(n) — 线性复杂度"></a><strong>3. O(n) — 线性复杂度</strong></h3><p><strong>特点</strong>：执行时间与输入规模成线性正比。<br><strong>示例</strong>：遍历数组求和。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sumArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        sum += arr[i]; <span class="hljs-comment">// 遍历所有元素，执行次数为n</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197926290.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197926290.png" alt=""></p>
<hr>
<h3 id="4-O-n-log-n-—-对数线性复杂度"><a href="#4-O-n-log-n-—-对数线性复杂度" class="headerlink" title="4. O(n log n) — 对数线性复杂度"></a><strong>4. O(n log n) — 对数线性复杂度</strong></h3><p><strong>特点</strong>：两层循环相互独立，第一层和第二层时间复杂度分别为 O(log⁡N) 和 O(N)，则总体时间复杂度为 O(Nlog⁡N)</p>
<p>结合线性与对数操作，常见于分治算法。<br><strong>示例</strong>：快速排序。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = partition(arr, low, high); <span class="hljs-comment">// 分区操作O(n)</span><br>        quickSort(arr, low, pivot - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 递归左半部分</span><br>        quickSort(arr, pivot + <span class="hljs-number">1</span>, high); <span class="hljs-comment">// 递归右半部分</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 每次递归将问题规模分半，递归深度为log n，每层总操作次数为n</span><br></code></pre></td></tr></table></figure>
<p>线性对数阶常出现于排序算法，例如「快速排序」、「归并排序」、「堆排序」等，其时间复杂度原理如下图所示。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f219792ceba.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f219792ceba.png" alt=""></p>
<hr>
<h3 id="5-O-nᵏ-—-多项式复杂度（k-2为例）"><a href="#5-O-nᵏ-—-多项式复杂度（k-2为例）" class="headerlink" title="5. O(nᵏ) — 多项式复杂度（k=2为例）"></a><strong>5. O(nᵏ) — 多项式复杂度（k=2为例）</strong></h3><p><strong>特点</strong>：嵌套循环导致时间复杂度为输入规模的k次方。<br><strong>示例</strong>：冒泡排序。 第一层和第二层时间复杂度分别为 O(N) 和 O(N)，则总体时间复杂度为 O(N^2) </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size<span class="hljs-number">-1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size-i<span class="hljs-number">-1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>                swap(&amp;arr[j], &amp;arr[j+<span class="hljs-number">1</span>]); <span class="hljs-comment">// 双重循环，操作次数为n²</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197949027.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197949027.png" alt=""></p>
<hr>
<h3 id="6-O-kⁿ-—-指数复杂度"><a href="#6-O-kⁿ-—-指数复杂度" class="headerlink" title="6. O(kⁿ) — 指数复杂度"></a><strong>6. O(kⁿ) — 指数复杂度</strong></h3><p><strong>特点</strong>：问题规模每增加1，计算量翻倍。<br><strong>示例</strong>：斐波那契数列的递归实现。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fibonacci(n<span class="hljs-number">-1</span>) + fibonacci(n<span class="hljs-number">-2</span>); <span class="hljs-comment">// 每次递归分裂为两次调用，复杂度为O(2ⁿ)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f21979ba451.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f21979ba451.png" alt=""></p>
<hr>
<h3 id="7-O-n-—-阶乘复杂度"><a href="#7-O-n-—-阶乘复杂度" class="headerlink" title="7. O(n!) — 阶乘复杂度"></a><strong>7. O(n!) — 阶乘复杂度</strong></h3><p><strong>特点</strong>：问题规模每增加1，计算量增长为阶乘级。<br><strong>示例</strong>：生成全排列，给定 N<em>N</em> 个互不重复的元素，求其所有可能的排列方案（递归回溯）。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        count += algorithm(N - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f21979bc3d1.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f21979bc3d1.png" alt=""></p>
<h1 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h1><p>时间复杂度不同，随着输入数据量的增加，代码运行的时间也会增加。</p>
<p>例如O(1)无论输入数据如何增多，代码运行时间都不变。而O(n)的运行时间和输入数据量成正比。如果时间复杂度过高，例如O(2^n)，那么在小数据情况下，代码还可以运行，一旦数据量增大，则代码的运行时间将会几何级增加。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197c5a42b.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197c5a42b.png" alt=""></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197b9fefb.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197b9fefb.png" alt=""></p>
<p>代码执行时间总结如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>常数时间</td>
<td>O(1)</td>
</tr>
<tr>
<td>对数时间</td>
<td>O(log n)</td>
</tr>
<tr>
<td>线性时间</td>
<td>O(n)</td>
</tr>
<tr>
<td>线性对数时间</td>
<td>O(nlog n)</td>
</tr>
<tr>
<td>二次时间</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>三次时间</td>
<td>O(n^3)</td>
</tr>
<tr>
<td>指数时间</td>
<td>O(2^n)</td>
</tr>
</tbody>
</table>
</div>
<h1 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h1><p class='item-img' data-src='https://pica.zhimg.com/80/v2-582c21adb0ae8039ad5cf5010c3b46b2_1440w.webp'><img src="https://pica.zhimg.com/80/v2-582c21adb0ae8039ad5cf5010c3b46b2_1440w.webp" alt="img"></p>
<p class='item-img' data-src='https://pic4.zhimg.com/80/v2-4671f059ba17906a6438c07a6a2815f7_1440w.webp'><img src="https://pic4.zhimg.com/80/v2-4671f059ba17906a6438c07a6a2815f7_1440w.webp" alt="img"></p>
<p class='item-img' data-src='https://pic2.zhimg.com/80/v2-6dd67dfea6b61a260c60b8b6cfc826f3_1440w.webp'><img src="https://pic2.zhimg.com/80/v2-6dd67dfea6b61a260c60b8b6cfc826f3_1440w.webp" alt="img"></p>
<hr>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><blockquote>
<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少字节的空间，因为这个也没太大意义，所以<strong>空间复杂度算的是变量的个数</strong>。空间复杂度计算规则基本跟时间复杂度类似，也使用大O渐进表示法。</p>
</blockquote>
<h3 id="常数-O-1"><a href="#常数-O-1" class="headerlink" title="常数 O(1)"></a>常数 O(1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算冒泡排序函数的空间复杂度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> N)</span><br>&#123;<br>	assert(a);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> exchange = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N - <span class="hljs-number">1</span> - i; j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (a[j]&gt;a[j + <span class="hljs-number">1</span>])<br>			&#123;<br>				<span class="hljs-type">int</span> tmp = a[j];<br>				a[j] = a[j + <span class="hljs-number">1</span>];<br>				a[j + <span class="hljs-number">1</span>] = tmp;<br>				exchange = <span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (exchange == <span class="hljs-number">0</span>)<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>冒泡排序函数中使用了常数个额外空间（即常数个变量），所以用大O的渐进表示法表示冒泡排序函数的空间复杂度为<strong>O(1)</strong> 。</p>
<h3 id="线性-O-N"><a href="#线性-O-N" class="headerlink" title="线性 O(N)"></a>线性 O<em>(</em>N)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算阶乘递归函数的空间复杂度</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Factorial</span><span class="hljs-params">(<span class="hljs-type">size_t</span> N)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> N &lt; <span class="hljs-number">2</span> ? N : Factorial(N - <span class="hljs-number">1</span>)*N;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>阶乘递归函数会依次调用Factorial(N),Factorial(N-1),…,Factorial(2),Factorial(1)，开辟了N个空间，所以空间复杂度为<strong>O(N)</strong> 。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197a7f3a0.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197a7f3a0.png" alt=""></p>
<h3 id="平方-O-N²"><a href="#平方-O-N²" class="headerlink" title="平方 O(N²)"></a>平方 O(N²)</h3><p>元素数量与 N呈平方关系的任意类型集合（常见于矩阵），皆使用平方大小的空间。</p>
<ol>
<li><strong>递归调用栈的深度</strong><br>每次递归调用参数递减 1，直到 N ≤ 0。递归深度为 N 次（例如 N=5 时调用链为 algorithm(5) → algorithm(4) → … → algorithm(0)）</li>
<li><strong>每次递归的临时空间占用</strong><br>每次递归调用时，会在栈上动态创建一个大小为 N 的整型数组 <code>int nums[N]</code>。随着递归深度增加，数组长度的变化为 N, N-1, N-2, …, 1</li>
<li><strong>空间累计计算</strong><br>总空间占用为各次递归调用中数组大小的累加：<br><em>S</em>(<em>N</em>)=<em>N</em>+(<em>N</em>−1)+(<em>N</em>−2)+⋯+1=2<em>N</em>(<em>N</em>+1)​<br>根据大 O 表示法，简化为 ​<strong>​O(N²)​</strong>​</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> nums[N];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">algorithm</span>(N - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197a7bf34.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197a7bf34.png" alt=""></p>
<h3 id="指数-O-2ᴺ"><a href="#指数-O-2ᴺ" class="headerlink" title="指数 O(2ᴺ)"></a>指数 O(2ᴺ)</h3><p>指数阶常见于二叉树、多叉树的空间分析，例如：</p>
<ol>
<li><p>满二叉树</p>
<p>高度为 <strong>N</strong> 的满二叉树，节点总数为 <strong>2ᴺ</strong>，空间复杂度为 <strong>O(2ᴺ)</strong>。</p>
</li>
<li><p>满 m 叉树</p>
<p>高度为 <strong>N</strong> 的满 m 叉树，节点总数为 <strong>mᴺ</strong>。</p>
<p>当 m 为常数时，<strong>O(mᴺ) = O(2ᴺ)</strong>（指数级增长性质相同）。</p>
</li>
</ol>
<p>指数阶常见于二叉树、多叉树。例如，高度为 N的「满二叉树」的节点数量为 2^N，占用 O(2^N)大小的空间；同理，高度为 N的「满 m叉树」的节点数量为 m^N，占用 O(m^N)大小的空间。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2025/04/06/67f2197a8e599.png'><img src="https://free-img.400040.xyz/4/2025/04/06/67f2197a8e599.png" alt=""></p>
<h3 id="对数-O-log-N"><a href="#对数-O-log-N" class="headerlink" title="对数 O(log N)"></a><strong>对数 O(log N)</strong></h3><p>对数阶常出现于分治算法的栈帧空间累计、数据类型转换等，例如：</p>
<ul>
<li><strong>快速排序</strong>，平均空间复杂度为 Θ(log N)，最差空间复杂度为 O(N)。<br>通过应用尾递归优化，可以将快速排序的最差空间复杂度限定至 O(N)。</li>
<li><strong>数字转化为字符串</strong>，设某正整数为 N，则字符串的空间复杂度为 O(log N)。<br>正整数 N 的位数为 log₁₀ N，即转化的字符串长度为 log₁₀ N，因此空间复杂度为 O(log N)。</li>
</ul>
<p><strong>注：递归算法的空间复杂度通常是递归的深度（即递归多少层）。</strong></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/23014.html">← 下一篇 数据结构-线性表（顺序表）</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/45088.html">数据结构-绪论 上一篇 →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">算法复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">2.0.1.</span> <span class="toc-text">基本复杂度计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99"><span class="toc-number">2.0.2.</span> <span class="toc-text">复杂度计算的核心规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-O-1-%E2%80%94-%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.3.</span> <span class="toc-text">1. O(1) — 常数复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-O-log-n-%E2%80%94-%E5%AF%B9%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.4.</span> <span class="toc-text">2. O(log n) — 对数复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-O-n-%E2%80%94-%E7%BA%BF%E6%80%A7%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.5.</span> <span class="toc-text">3. O(n) — 线性复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-O-n-log-n-%E2%80%94-%E5%AF%B9%E6%95%B0%E7%BA%BF%E6%80%A7%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.6.</span> <span class="toc-text">4. O(n log n) — 对数线性复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-O-n%E1%B5%8F-%E2%80%94-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88k-2%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.0.7.</span> <span class="toc-text">5. O(nᵏ) — 多项式复杂度（k&#x3D;2为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-O-k%E2%81%BF-%E2%80%94-%E6%8C%87%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.8.</span> <span class="toc-text">6. O(kⁿ) — 指数复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-O-n-%E2%80%94-%E9%98%B6%E4%B9%98%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.9.</span> <span class="toc-text">7. O(n!) — 阶乘复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">3.</span> <span class="toc-text">时间复杂度的意义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">常见的时间复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">空间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0-O-1"><span class="toc-number">5.0.1.</span> <span class="toc-text">常数 O(1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7-O-N"><span class="toc-number">5.0.2.</span> <span class="toc-text">线性 O(N)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9-O-N%C2%B2"><span class="toc-number">5.0.3.</span> <span class="toc-text">平方 O(N²)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0-O-2%E1%B4%BA"><span class="toc-number">5.0.4.</span> <span class="toc-text">指数 O(2ᴺ)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0-O-log-N"><span class="toc-number">5.0.5.</span> <span class="toc-text">对数 O(log N)</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>