<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-11-04-JavaScript 常用方法速查 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-11-04-JavaScript 常用方法速查</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-11-04T07:29:35.000Z" id="date"> 2025-11-04</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-11-17T02:26:53.983Z" id="updated"> 2025-11-17</time></div></span><br><span id="busuanzi_container_page_pv">页面浏览: <span class="control" id="busuanzi_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><p>JavaScript 常用方法速查</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
<th><strong>返回值/副作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(...items)</code></td>
<td>末尾添加元素</td>
<td><code>arr.push(4)</code> → 修改原数组</td>
<td>返回新数组长度</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>删除末尾元素</td>
<td><code>arr.pop()</code> → 修改原数组</td>
<td>返回被删除元素</td>
</tr>
<tr>
<td><code>unshift(...items)</code></td>
<td>开头添加元素</td>
<td><code>arr.unshift(0)</code> → 修改原数组</td>
<td>返回新数组长度</td>
</tr>
<tr>
<td><code>shift()</code></td>
<td>删除开头元素</td>
<td><code>arr.shift()</code> → 修改原数组</td>
<td>返回被删除元素</td>
</tr>
<tr>
<td><code>slice(start, end)</code></td>
<td>截取数组片段（不修改原数组）</td>
<td><code>arr.slice(1, 3)</code></td>
<td>返回新数组</td>
</tr>
<tr>
<td><code>splice(start, deleteCount, ...items)</code></td>
<td>删除/替换元素</td>
<td><code>arr.splice(1, 2, 'a')</code> → 修改原数组</td>
<td>返回被删除元素组成的数组</td>
</tr>
<tr>
<td><code>map(callback)</code></td>
<td>遍历并返回新数组</td>
<td><code>[1,2,3].map(x =&gt; x*2)</code> → <code>[2,4,6]</code></td>
<td>新数组</td>
</tr>
<tr>
<td><code>filter(callback)</code></td>
<td>过滤符合条件的元素</td>
<td><code>[1,2,3].filter(x =&gt; x&gt;1)</code> → <code>[2,3]</code></td>
<td>新数组</td>
</tr>
<tr>
<td><code>reduce(callback, initialValue)</code></td>
<td>累计计算（如求和、统计）</td>
<td><code>[1,2,3].reduce((sum, x) =&gt; sum + x, 0)</code> → <code>6</code></td>
<td>最终累计值</td>
</tr>
<tr>
<td><code>find(callback)</code></td>
<td>查找第一个符合条件的元素</td>
<td><code>[1,2,3].find(x =&gt; x&gt;1)</code> → <code>2</code></td>
<td>元素或  <code>undefined</code></td>
</tr>
<tr>
<td><code>findIndex(callback)</code></td>
<td>查找第一个符合条件的索引</td>
<td><code>[1,2,3].findIndex(x =&gt; x&gt;1)</code> → <code>1</code></td>
<td>索引或  <code>-1</code></td>
</tr>
<tr>
<td><code>includes(value)</code></td>
<td>判断是否包含某元素（ES6）</td>
<td><code>[1,2,3].includes(2)</code> → <code>true</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>flat(depth)</code></td>
<td>扁平化嵌套数组（ES2019）</td>
<td><code>[1, [2]].flat()</code> → <code>[1, 2]</code></td>
<td>新数组</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
<th><strong>返回值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>split(separator)</code></td>
<td>按分隔符拆分为数组</td>
<td><code>"a,b,c".split(",")</code> → <code>["a", "b", "c"]</code></td>
<td>数组</td>
</tr>
<tr>
<td><code>substring(start, end)</code></td>
<td>截取子字符串（不包含  <code>end</code>  索引）</td>
<td><code>"Hello".substring(1, 3)</code> → <code>"el"</code></td>
<td>新字符串</td>
</tr>
<tr>
<td><code>slice(start, end)</code></td>
<td>截取子字符串（支持负数索引）</td>
<td><code>"Hello".slice(-3)</code> → <code>"llo"</code></td>
<td>新字符串</td>
</tr>
<tr>
<td><code>replace(searchValue, newValue)</code></td>
<td>替换匹配内容（支持正则表达式）</td>
<td><code>"abc".replace("a", "A")</code> → <code>"Abc"</code></td>
<td>新字符串</td>
</tr>
<tr>
<td><code>toUpperCase()</code></td>
<td>转为大写</td>
<td><code>"hello".toUpperCase()</code> → <code>"HELLO"</code></td>
<td>新字符串</td>
</tr>
<tr>
<td><code>toLowerCase()</code></td>
<td>转为小写</td>
<td><code>"HELLO".toLowerCase()</code> → <code>"hello"</code></td>
<td>新字符串</td>
</tr>
<tr>
<td><code>trim()</code></td>
<td>去除首尾空格（ES5）</td>
<td><code>" hello ".trim()</code> → <code>"hello"</code></td>
<td>新字符串</td>
</tr>
<tr>
<td><code>startsWith(str)</code></td>
<td>判断是否以某字符串开头（ES6）</td>
<td><code>"hello".startsWith("he")</code> → <code>true</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>endsWith(str)</code></td>
<td>判断是否以某字符串结尾（ES6）</td>
<td><code>"hello".endsWith("lo")</code> → <code>true</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>padStart(length, padStr)</code></td>
<td>头部填充字符串（ES2017）</td>
<td><code>"5".padStart(3, "0")</code> → <code>"005"</code></td>
<td>新字符串</td>
</tr>
</tbody>
</table>
</div>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object.assign()</td>
<td>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</td>
</tr>
<tr>
<td>Object.create()</td>
<td>方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</td>
</tr>
<tr>
<td>Object.defineProperties()</td>
<td>方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</td>
</tr>
<tr>
<td>Object.defineProperty()</td>
<td>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</td>
</tr>
<tr>
<td>Object.entries()</td>
<td>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致。</td>
</tr>
<tr>
<td>Object.freeze()</td>
<td>方法可以冻结一个对象。</td>
</tr>
<tr>
<td>Object.fromEntries()</td>
<td>方法把键值对列表转换为一个对象。</td>
</tr>
<tr>
<td>Object.getOwnPropertyDescriptor()</td>
<td>方法返回指定对象上一个自有属性对应的属性描述符。</td>
</tr>
<tr>
<td>Object.getOwnPropertyDescriptors()</td>
<td>方法用来获取一个对象的所有自身属性的描述符。</td>
</tr>
<tr>
<td>Object.getOwnPropertyNames()</td>
<td>方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。</td>
</tr>
<tr>
<td>Object.getOwnPropertySymbols()</td>
<td>方法返回一个给定对象自身的所有 Symbol 属性的数组。</td>
</tr>
<tr>
<td>Object.getPrototypeOf()</td>
<td>方法返回指定对象的原型（内部[[Prototype]]属性的值）。</td>
</tr>
<tr>
<td>Object.is()</td>
<td>方法判断两个值是否为同一个值。</td>
</tr>
<tr>
<td>Object.isExtensible()</td>
<td>方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</td>
</tr>
<tr>
<td>Object.isFrozen()</td>
<td>方法判断一个对象是否被冻结。</td>
</tr>
<tr>
<td>Object.preventExtensions()</td>
<td>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</td>
</tr>
<tr>
<td>Object.isSealed()</td>
<td>方法判断一个对象是否被密封。</td>
</tr>
<tr>
<td>Object.keys()</td>
<td>方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</td>
</tr>
<tr>
<td>Object.setPrototypeOf()</td>
<td>方法设置一个指定的对象的原型到另一个对象。</td>
</tr>
<tr>
<td>Object.values()</td>
<td>方法返回一个给定对象自身的所有可枚举属性值的数组。</td>
</tr>
<tr>
<td>Object.seal()</td>
<td>方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Number-方法"><a href="#Number-方法" class="headerlink" title="Number 方法"></a>Number 方法</h3><p>Number 对象本身有一些静态属性和方法，而 Number 实例的方法是通过 Number.prototype 定义的，但通常我们使用数字字面量时可以直接调用这些方法（因为 JavaScript 会自动装箱）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>返回对创建此对象的 Number 函数的引用。</td>
</tr>
<tr>
<td>isFinite()</td>
<td>检查值是否是有限数。</td>
</tr>
<tr>
<td>isInteger()</td>
<td>检查值是否为整数。</td>
</tr>
<tr>
<td>isNaN()</td>
<td>检查值是否为 Number.NaN。</td>
</tr>
<tr>
<td>parseFloat()</td>
<td>检查值是否为整数。</td>
</tr>
<tr>
<td>parseInt()</td>
<td>检查值是否为整数。</td>
</tr>
<tr>
<td>prototype</td>
<td>允许您向对象添加属性和方法。</td>
</tr>
<tr>
<td>toFixed(x)</td>
<td>把数字转换为字符串，结果的小数点后有指定位数的数字。</td>
</tr>
<tr>
<td>toPrecision(x)</td>
<td>把数字格式化为指定的长度。</td>
</tr>
<tr>
<td>toString()</td>
<td>把数字转换为字符串。</td>
</tr>
<tr>
<td>valueOf()​</td>
<td>返回数字的原始值（基本数字值）。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Math-方法"><a href="#Math-方法" class="headerlink" title="Math 方法"></a>Math 方法</h3><p>Math 对象是一个静态对象，它包含了许多数学常数和函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.abs(x)</td>
<td>返回一个数的绝对值。</td>
</tr>
<tr>
<td>Math.ceil(x)</td>
<td>返回大于或等于一个数的最小整数（向上取整）。</td>
</tr>
<tr>
<td>Math.floor(x)</td>
<td>返回小于或等于一个数的最大整数（向下取整）。</td>
</tr>
<tr>
<td>Math.round(x)</td>
<td>返回一个数四舍五入后的整数。</td>
</tr>
<tr>
<td>Math.max([value1[, value2[, …]]])</td>
<td>返回一组数中的最大值。</td>
</tr>
<tr>
<td>Math.min([value1[, value2[, …]]])</td>
<td>返回一组数中的最小值。</td>
</tr>
<tr>
<td>Math.pow(x, y)</td>
<td>返回 x 的 y 次幂。</td>
</tr>
<tr>
<td>Math.sqrt(x)</td>
<td>返回一个数的平方根。</td>
</tr>
<tr>
<td>Math.random()</td>
<td>返回一个 0 到 1 之间的伪随机数。</td>
</tr>
<tr>
<td>Math.sin(x)</td>
<td>返回一个数的正弦值。</td>
</tr>
<tr>
<td>Math.cos(x)</td>
<td>返回一个数的余弦值。</td>
</tr>
<tr>
<td>Math.tan(x)</td>
<td>返回一个数的正切值。</td>
</tr>
<tr>
<td>Math.log(x)</td>
<td>返回一个数的自然对数。</td>
</tr>
<tr>
<td>Math.exp(x)</td>
<td>返回 e 的 x 次幂。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Date-对象方法"><a href="#Date-对象方法" class="headerlink" title="Date 对象方法"></a>Date 对象方法</h3><p>Date 对象用于处理日期和时间</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date.now()</td>
<td>返回自 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的毫秒数。</td>
</tr>
<tr>
<td>Date.parse(dateString)</td>
<td>解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 UTC 所经过的毫秒数。</td>
</tr>
<tr>
<td>Date.UTC(year, month[, day[, hour[, minute[, second[, millisecond]]]]])</td>
<td>接受和构造函数最长形式的参数相同的参数，并返回从 1970-1-1 00:00:00 UTC 所经过的毫秒数。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>getFullYear()</td>
<td>根据本地时间返回指定日期对象的年份。</td>
</tr>
<tr>
<td>getMonth()</td>
<td>根据本地时间返回指定日期对象的月份（0-11）。</td>
</tr>
<tr>
<td>getDate()</td>
<td>根据本地时间返回指定日期对象的日期（1-31）。</td>
</tr>
<tr>
<td>getDay()</td>
<td>根据本地时间返回指定日期对象的星期（0-6）。</td>
</tr>
<tr>
<td>getHours()</td>
<td>根据本地时间返回指定日期对象的小时（0-23）。</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>根据本地时间返回指定日期对象的分钟（0-59）。</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>根据本地时间返回指定日期对象的秒数（0-59）。</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>根据本地时间返回指定日期对象的毫秒数。</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回从 1970-1-1 00:00:00 UTC 到该日期经过的毫秒数。</td>
</tr>
<tr>
<td>setFullYear(year, [month], [day])</td>
<td>根据本地时间设置指定日期对象的年份。</td>
</tr>
<tr>
<td>setMonth(month, [day])</td>
<td>根据本地时间设置指定日期对象的月份。</td>
</tr>
<tr>
<td>setDate(day)</td>
<td>根据本地时间设置指定日期对象的日期。</td>
</tr>
<tr>
<td>setHours(hour, [min], [sec], [ms])</td>
<td>根据本地时间设置指定日期对象的小时。</td>
</tr>
<tr>
<td>setMinutes(min, [sec], [ms])</td>
<td>根据本地时间设置指定日期对象的分钟。</td>
</tr>
<tr>
<td>setSeconds(sec, [ms])</td>
<td>根据本地时间设置指定日期对象的秒数。</td>
</tr>
<tr>
<td>setMilliseconds(ms)</td>
<td>根据本地时间设置指定日期对象的毫秒数。</td>
</tr>
<tr>
<td>setTime(time)</td>
<td>通过指定从 1970-1-1 00:00:00 UTC 开始经过的毫秒数来设置日期对象。</td>
</tr>
<tr>
<td>toISOString()</td>
<td>返回一个 ISO 格式的字符串：YYYY-MM-DDTHH:mm:ss.sssZ。</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>返回一个表示日期对象的字符串，该字符串与当地环境的语言相对应。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="JSON-对象的方法"><a href="#JSON-对象的方法" class="headerlink" title="JSON 对象的方法"></a>JSON 对象的方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>JSON.parse(text[, reviver])</td>
<td>将一个 JSON 字符串转换为对象。</td>
</tr>
<tr>
<td>JSON.stringify(value[, replacer[, space]])</td>
<td>将一个值转换为 JSON 字符串。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Map-对象的方法"><a href="#Map-对象的方法" class="headerlink" title="Map 对象的方法"></a>Map 对象的方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>set(key, value)</td>
<td>设置 Map 对象中键的值，返回该 Map 对象。</td>
</tr>
<tr>
<td>get(key)</td>
<td>返回键对应的值，如果不存在，则返回 undefined。</td>
</tr>
<tr>
<td>has(key)</td>
<td>返回一个布尔值，表示 Map 实例是否包含键对应的值。</td>
</tr>
<tr>
<td>delete(key)</td>
<td>删除 Map 中的元素，删除成功返回 true，否则返回 false。</td>
</tr>
<tr>
<td>clear()</td>
<td>移除 Map 对象中的所有元素。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的键。</td>
</tr>
<tr>
<td>values()</td>
<td>返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。</td>
</tr>
<tr>
<td>entries()</td>
<td>返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的[key, value]数组。</td>
</tr>
<tr>
<td>forEach(callbackFn[, thisArg])</td>
<td>按插入顺序，为 Map 对象里的每一键值对调用一次 callbackFn 函数。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Set-对象的方法"><a href="#Set-对象的方法" class="headerlink" title="Set 对象的方法"></a>Set 对象的方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(value)</td>
<td>在 Set 对象尾部添加一个元素，返回该 Set 对象。</td>
</tr>
<tr>
<td>has(value)</td>
<td>返回一个布尔值，表示该值在 Set 中存在与否。</td>
</tr>
<tr>
<td>delete(value)</td>
<td>移除 Set 中与这个值相等的元素，返回 Set.prototype.has(value)在这个操作前返回的值。</td>
</tr>
<tr>
<td>clear()</td>
<td>移除 Set 对象内的所有元素。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回一个新的 Iterator 对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。</td>
</tr>
<tr>
<td>values()</td>
<td>与 keys()方法相同，返回一个新的 Iterator 对象。</td>
</tr>
<tr>
<td>entries()</td>
<td>返回一个新的 Iterator 对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值的[value, value]数组。</td>
</tr>
<tr>
<td>forEach(callbackFn[, thisArg])</td>
<td>按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Promise-对象的方法"><a href="#Promise-对象的方法" class="headerlink" title="Promise 对象的方法"></a>Promise 对象的方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Promise.all(iterable)</td>
<td>返回一个新的 Promise，它在 iterable 中所有的 Promise 都成功时才成功，只要有一个失败就失败。</td>
</tr>
<tr>
<td>Promise.race(iterable)</td>
<td>返回一个新的 Promise，它在 iterable 中任意一个 Promise 解决或拒绝时立即解决或拒绝。</td>
</tr>
<tr>
<td>Promise.resolve(value)</td>
<td>返回一个以给定值解析后的 Promise 对象。</td>
</tr>
<tr>
<td>Promise.reject(reason)</td>
<td>返回一个带有拒绝原因的 Promise 对象。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="函数与高阶方法"><a href="#函数与高阶方法" class="headerlink" title="函数与高阶方法"></a><strong>函数与高阶方法</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法/语法</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bind(thisArg, ...args)</code></td>
<td>绑定  <code>this</code>  并返回新函数</td>
<td><code>func.bind(obj)</code> → 新函数</td>
</tr>
<tr>
<td><code>call(thisArg, ...args)</code></td>
<td>立即调用函数并指定  <code>this</code></td>
<td><code>func.call(obj, 1, 2)</code></td>
</tr>
<tr>
<td><code>apply(thisArg, [args])</code></td>
<td>立即调用函数并指定  <code>this</code>（参数为数组）</td>
<td><code>func.apply(obj, [1, 2])</code></td>
</tr>
<tr>
<td><code>setTimeout(callback, delay)</code></td>
<td>延迟执行函数（返回定时器 ID）</td>
<td><code>setTimeout(() =&gt; {}, 1000)</code> → <code>ID</code></td>
</tr>
<tr>
<td><code>setInterval(callback, delay)</code></td>
<td>循环执行函数（返回定时器 ID）</td>
<td><code>setInterval(() =&gt; {}, 1000)</code> → <code>ID</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="RegExp-方法"><a href="#RegExp-方法" class="headerlink" title="RegExp 方法"></a>RegExp 方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>exec(string)</td>
<td>在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</td>
</tr>
<tr>
<td>test(string)</td>
<td>执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval(string)</td>
<td>执行字符串形式的 JavaScript 代码。</td>
</tr>
<tr>
<td>isNaN(value)</td>
<td>判断一个值是否是 NaN。注意：全局的 isNaN 会先将参数转换为数值再判断。</td>
</tr>
<tr>
<td>isFinite(value)</td>
<td>判断一个值是否是有限数字。</td>
</tr>
<tr>
<td>parseFloat(string)</td>
<td>将字符串解析成浮点数。</td>
</tr>
<tr>
<td>parseInt(string, radix)</td>
<td>将字符串解析成整数。</td>
</tr>
</tbody>
</table>
</div>
<p>【待补充】</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/10893.html">← 下一篇 2025-11-05-基于随机加权推断模型（IM）的参数估计算法</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/26939.html">2025-11-02 组会朝花夕拾 上一篇 →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">对象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number-%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">Number 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">Math 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">Date 对象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.0.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">6.0.2.</span> <span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">JSON 对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">Map 对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">Set 对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">Promise 对象的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E9%AB%98%E9%98%B6%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">函数与高阶方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegExp-%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">RegExp 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">8.1.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>