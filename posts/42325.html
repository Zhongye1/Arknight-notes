<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-12-28-力扣百题速练（Javascript、TypeScript）Vol.3 | Zhongye's Blogs</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://picx.zhimg.com/v2-6c94831ec3400e77452e9bd9dde85cb5_r.jpg');
 --light-background: url('https://pica.zhimg.com/v2-0323b00e97b41d914a545c7ccea6ab0a_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Zhongye's Blogs" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-12-28-力扣百题速练（Javascript、TypeScript）Vol.3</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-12-28T18:15:44.000Z" id="date"> 2025-12-29</time></div></span><br><span>Last Update: <div class="control"><time datetime="2026-01-19T02:33:22.586Z" id="updated"> 2026-01-19</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><p>依旧刷题中</p>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong></p>
<p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p>
<p>输入：l1 = <code>[1,2,4]</code>, l2 = <code>[1,3,4]</code><br>输出：<code>[1,1,2,3,4,4]</code></p>
<p><strong>示例 2：</strong></p>
<p>输入：l1 = <code>[]</code>, l2 = <code>[]</code><br>输出：<code>[]</code></p>
<p><strong>示例 3：</strong></p>
<p>输入：l1 = <code>[]</code>, l2 = <code>[0]</code><br>输出：<code>[0]</code></p>
<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p>Related Topics</p>
<ul>
<li>递归</li>
<li>链表</li>
</ul>
<p>解法很简单，假设输入两个有序链表：</p>
<p>list1: 1 → 2 → 4 list2: 1 → 3 → 4</p>
<p>合并过程逐步展示指针变化（→ 表示 next 指针，cur 为当前构建指针）：</p>
<p><strong>初始状态</strong> dummy → null cur = dummy list1: 1 → 2 → 4 list2: 1 → 3 → 4</p>
<p><strong>步骤 1</strong>：比较 list1.val(1) ≤ list2.val(1) cur.next = list1 的 1 cur 前进 → 指向 1 list1 前进 → 2 → 4 当前新链表：dummy → 1</p>
<p><strong>步骤 2</strong>：比较 list1.val(2) &gt; list2.val(1) cur.next = list2 的 1 cur 前进 → 指向 1 list2 前进 → 3 → 4 当前新链表：dummy → 1 → 1</p>
<p><strong>步骤 3</strong>：比较 list1.val(2) ≤ list2.val(3) cur.next = list1 的 2 cur 前进 → 指向 2 list1 前进 → 4 当前新链表：dummy → 1 → 1 → 2</p>
<p><strong>步骤 4</strong>：比较 list1.val(4) &gt; list2.val(3) cur.next = list2 的 3 cur 前进 → 指向 3 list2 前进 → 4 当前新链表：dummy → 1 → 1 → 2 → 3</p>
<p><strong>步骤 5</strong>：比较 list1.val(4) ≤ list2.val(4) cur.next = list1 的 4 cur 前进 → 指向 4 list1 前进 → null 当前新链表：dummy → 1 → 1 → 2 → 3 → 4</p>
<p><strong>步骤 6</strong>：list1 已空，剩余 list2(4) 直接接上 cur.next = list2 的 4 当前新链表：dummy → 1 → 1 → 2 → 3 → 4 → 4</p>
<p><strong>最终返回</strong>：dummy.next 结果链表：1 → 1 → 2 → 3 → 4 → 4</p>
<p>该过程通过不断比较两个链表的当前节点，将较小节点直接拼接至新链表尾部（cur 后），并前进对应指针，直至处理完所有节点</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">list1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">list2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> dum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> cur = dum;<br><br>    <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) {<br>        <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &lt;= list2.<span class="hljs-property">val</span>) {<br>            cur.<span class="hljs-property">next</span> = list1; <span class="hljs-comment">// 将较小节点接到 cur 后</span><br>            list1 = list1.<span class="hljs-property">next</span>; <span class="hljs-comment">// list1 前进</span><br>        } <span class="hljs-keyword">else</span> {<br>            cur.<span class="hljs-property">next</span> = list2;<br>            list2 = list2.<span class="hljs-property">next</span>;<br>        }<br>        cur = cur.<span class="hljs-property">next</span>; <span class="hljs-comment">// cur 前进</span><br>    }<br><br>    cur.<span class="hljs-property">next</span> = list1 || list2;<br>    <span class="hljs-keyword">return</span> dum.<span class="hljs-property">next</span>;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p>示例 1：<br>输入：n = 3<br>输出：<code>["((()))","(()())","(())()","()(())","()()()"]</code></p>
<p>示例 2：<br>输入：n = 1<br>输出：<code>["()"]</code></p>
<p>这题应该使用回溯法，<strong>在每一步都记录当前已经用了多少个左括号和右括号</strong></p>
<p>现在可以得到：<br>只能在“前面左括号比右括号多”的情况下才能加右括号 （否则会出现 ) 先出现或者 ) 比 ( 多的非法情况）<br>左括号最多只能放 n 个 （超过 n 个就超标了）<br>什么时候算一条合法答案？ 正好放了 n 个左 + n 个右，也就是字符串长度达到 2n</p>
<p>因此我们维护两个计数器：</p>
<ul>
<li>left：已经使用了多少个左括号</li>
<li>right：已经使用了多少个右括号</li>
</ul>
<p><strong>用 n=2 手推整个过程：</strong><br>初始调用： backtrack(“”, 0, 0)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">""<br>                     /   \<br>                    /     \<br>                   (       ×  ← 不能先放右括号（right=0, left=0，不满足 right&lt;left）<br>                  / \<br>                 /   \<br>                ((    ()<br>               /  \     \<br>              /    \     \<br>           (((    (())   ()(<br>           ×      ×      /  \<br>                       ()   ()(<br>                             ×   ×<br></code></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span>[] {<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">BT</span>(<span class="hljs-params"><span class="hljs-attr">curr</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span></span>) {<br>        <span class="hljs-keyword">if</span> (curr.<span class="hljs-property">length</span> === <span class="hljs-number">2</span> * n) {<br>            res.<span class="hljs-title function_">push</span>(curr);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (left &lt; n) {<br>            <span class="hljs-title function_">BT</span>(curr + <span class="hljs-string">"("</span>, left + <span class="hljs-number">1</span>, right);<br>        }<br>        <span class="hljs-keyword">if</span> (left &gt; right) {<br>            <span class="hljs-title function_">BT</span>(curr + <span class="hljs-string">")"</span>, left, right + <span class="hljs-number">1</span>);<br>        }<br>    }<br>    <span class="hljs-title function_">BT</span>(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="23-合并k个升序链表"><a href="#23-合并k个升序链表" class="headerlink" title="23.合并k个升序链表"></a>23.合并k个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<p>输入：<code>lists = [[1,4,5],[1,3,4],[2,6]]</code><br>输出：<code>[1,1,2,3,4,4,5,6]</code><br>解释：链表数组如下：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br></code></pre></td></tr></table></figure>
<p>将它们合并到一个有序链表中得到<br><code>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></p>
<p>最初一版本：</p>
<p>把 K 个链表的合并问题，<strong>逐步退化成多次“合并两个有序链表”的问题</strong>。</p>
<p>具体过程如下：</p>
<ol>
<li>先拿第一个链表作为当前结果<code>（res = lists[0]）</code></li>
<li>然后依次把后面的每个链表<code>（lists[1], lists[2], …, lists[k-1]）</code> <strong>逐个合并</strong>到当前结果 res 上</li>
<li>每次合并都调用同一个 mergeTwoLists 函数</li>
<li>最终得到的 res 就是所有链表合并后的结果<br>就是：</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">res = lists<span class="hljs-selector-attr">[0]</span><br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[1]</span>)<br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[2]</span>)<br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[3]</span>)<br>...<br>res = <span class="hljs-built_in">merge</span>(res, lists<span class="hljs-selector-attr">[k-1]</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode {</span><br><span class="hljs-comment"> *     val: number</span><br><span class="hljs-comment"> *     next: ListNode | null</span><br><span class="hljs-comment"> *     constructor(val?: number, next?: ListNode | null) {</span><br><span class="hljs-comment"> *         this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *         this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> *     }</span><br><span class="hljs-comment"> * }</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params"><span class="hljs-attr">lists</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>&gt;</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (!lists || lists.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = lists[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; lists.<span class="hljs-property">length</span>; i++) {<br>        res = <span class="hljs-title function_">mergeTwoLists</span>(res, lists[i]);<br>    }<br><br>    <span class="hljs-keyword">return</span> res;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"></span><br><span class="hljs-params">        <span class="hljs-attr">l1</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">        <span class="hljs-attr">l2</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    </span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">dummy</span>: <span class="hljs-title class_">ListNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">cur</span>: <span class="hljs-title class_">ListNode</span> = dummy;<br><br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) {<br>            <span class="hljs-keyword">if</span> (l1.<span class="hljs-property">val</span> &lt; l2.<span class="hljs-property">val</span>) {<br>                cur.<span class="hljs-property">next</span> = l1;<br>                l1 = l1.<span class="hljs-property">next</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                cur.<span class="hljs-property">next</span> = l2;<br>                l2 = l2.<span class="hljs-property">next</span>;<br>            }<br>            cur = cur.<span class="hljs-property">next</span>;<br>        }<br>        cur.<span class="hljs-property">next</span> = l1 ? l1 : l2;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>    }<br>}<br><span class="hljs-comment">//runtime:159 ms</span><br><span class="hljs-comment">//memory:63.4 MB</span><br></code></pre></td></tr></table></figure>
<p>后续新的解法，<strong>直接把所有节点收集到一个列表里，排序后再重新连起来</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params"><span class="hljs-attr">lists</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>&gt;</span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">nodes</span>: <span class="hljs-title class_">ListNode</span>[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> head <span class="hljs-keyword">of</span> lists) {<br>        <span class="hljs-keyword">let</span> curr = head;<br>        <span class="hljs-keyword">while</span> (curr !== <span class="hljs-literal">null</span>) {<br>            nodes.<span class="hljs-title function_">push</span>(curr);<br>            curr = curr.<span class="hljs-property">next</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (nodes.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br><br>    nodes.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">val</span> - b.<span class="hljs-property">val</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nodes.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {<br>        nodes[i].<span class="hljs-property">next</span> = nodes[i + <span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-keyword">return</span> nodes[<span class="hljs-number">0</span>];<br>}<br><br><span class="hljs-comment">//runtime:10 ms</span><br><span class="hljs-comment">//memory:63.1 MB</span><br></code></pre></td></tr></table></figure>
<hr>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p>
<p>输入：<code>head = [1,2,3,4]</code><br>输出：<code>[2,1,4,3]</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode {</span><br><span class="hljs-comment"> *     val: number</span><br><span class="hljs-comment"> *     next: ListNode | null</span><br><span class="hljs-comment"> *     constructor(val?: number, next?: ListNode | null) {</span><br><span class="hljs-comment"> *         this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *         this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> *     }</span><br><span class="hljs-comment"> * }</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swapPairs</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">if</span> (!head) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br><br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-keyword">let</span> pre = dummy;<br><br>    <span class="hljs-keyword">while</span> (pre.<span class="hljs-property">next</span> &amp;&amp; pre.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>) {<br>        <span class="hljs-keyword">const</span> cur = pre.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">const</span> nx = pre.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        pre.<span class="hljs-property">next</span> = nx;<br>        cur.<span class="hljs-property">next</span> = nx.<span class="hljs-property">next</span>;<br>        nx.<span class="hljs-property">next</span> = cur;<br>        pre = cur;<br>    }<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>}<br><span class="hljs-comment">//runtime:0 ms</span><br><span class="hljs-comment">//memory:55.7 MB</span><br></code></pre></td></tr></table></figure>
<p>创建一个哑节点，后面搞pre，curr，nx做节点交换</p>
<hr>
<h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a>25.K个一组翻转链表</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt=""></p>
<p><strong>输入：</strong><code>head = [1,2,3,4,5], k = 2</code><br><strong>输出：</strong><code>[2,1,4,3,5]</code></p>
<p><strong>示例 2：</strong></p>
<p class='item-img' data-src='https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg'><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt=""></p>
<p><strong>输入：</strong><code>head = [1,2,3,4,5], k = 3</code><br><strong>输出：</strong><code>[3,2,1,4,5]</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params"><span class="hljs-attr">head</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">k</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> {<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {<br>        <span class="hljs-keyword">if</span> (!curr) <span class="hljs-keyword">return</span> head;<br>        curr = curr.<span class="hljs-property">next</span>;<br>    }<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">prev</span>: <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    curr = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {<br>        <span class="hljs-keyword">let</span> nx = curr!.<span class="hljs-property">next</span>;<br>        curr.<span class="hljs-property">next</span> = prev;<br>        prev = curr;<br>        curr = nx;<br>    }<br>    head!.<span class="hljs-property">next</span> = <span class="hljs-title function_">reverseKGroup</span>(curr, k);<br><br>    <span class="hljs-keyword">return</span> prev;<br>}<br></code></pre></td></tr></table></figure>
<p>主要是递归<br><strong>先检查是否够翻转</strong> 用一个指针 curr 从 head 开始走 k 步 如果中途遇到 null，说明剩余节点不足 k 个 → 直接返回 head，结束递归（符合题目要求：不足 k 个不翻转）</p>
<ul>
<li><strong>翻转当前 k 个节点（经典原地翻转）</strong> 使用三指针翻转法（prev、curr、next）：<ul>
<li>初始：prev = null，curr = head</li>
<li>每次把 curr 的 next 指向 prev</li>
<li>然后 prev 前移，curr 前移 翻转 k 次后：</li>
<li>prev 成为这 k 个节点的新头</li>
<li>curr 指向第 k+1 个节点（也就是下一组的开始）</li>
<li>原 head 现在变成了这 k 个节点中的<strong>最后一个节点</strong></li>
</ul>
</li>
<li><p><strong>递归处理剩余部分，并连接</strong></p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">head!.<span class="hljs-property">next</span> = <span class="hljs-title function_">reverseKGroup</span>(curr, k);<br></code></pre></td></tr></table></figure>
<ul>
<li>此时的 head 已经是翻转后小段的<strong>尾节点</strong></li>
<li>我们让它指向<strong>递归返回的下一组翻转后的头节点</strong></li>
<li>这样就把当前翻转好的小段和后面的结果正确连接起来了</li>
</ul>
</li>
<li><p><strong>返回当前组的新头</strong>return prev prev 正是翻转后这 k 个节点的新头部，是当前层应该返回给上一层的头节点</p>
</li>
</ul>
<hr>
<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请原地删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code>。去重后，返回唯一元素的数量 <code>k</code>。</p>
<p><code>nums</code> 的前 <code>k</code> 个元素应包含 <strong>排序后</strong> 的唯一数字。下标 <code>k - 1</code> 之后的剩余元素可以忽略。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>nums = [1,1,2]</code><br><strong>输出：</strong><code>2, nums = [1,2,_]</code><br><strong>解释：</strong> 函数应该返回新的长度 <code>2</code> ，并且原数组 <em>nums</em> 的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2</code></strong> 不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong><code>nums = [0,0,1,1,1,2,2,3,3,4]</code><br><strong>输出：</strong><code>5, nums = [0,1,2,3,4,_,_,_,_,_]</code><br><strong>解释：</strong> 函数应该返回新的长度 <code>5</code> ， 并且原数组 <em>nums</em> 的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong> 不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (nums[i] !== nums[i - <span class="hljs-number">1</span>]) {<br>            nums[k] = nums[i];<br>            k++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> k;<br>}<br></code></pre></td></tr></table></figure>
<p>主要是使用快慢指针在同一个数组上移动：</p>
<ul>
<li>k（慢指针）：指向当前<strong>应该放置下一个唯一元素</strong>的位置 同时也代表目前已经处理好的<strong>唯一元素个数</strong></li>
<li>i（快指针）：负责向前扫描数组，寻找下一个<strong>与前一个不同的元素</strong><br>当发现一个新的不重复元素时，就把它<strong>覆盖</strong>到慢指针 k 的位置，然后 k 前进一步</li>
</ul>
<hr>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>
<ul>
<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>
<li>返回 <code>k</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>nums = [3,2,2,3], val = 3</code><br><strong>输出：</strong><code>2, nums = [2,2,_,_]</code><br><strong>解释：</strong> 你的函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。<br>你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong><code>nums = [0,1,2,2,3,0,4,2], val = 2</code><br><strong>输出：</strong><code>5, nums = [0,1,4,0,3,_,_,_]</code><br><strong>解释：</strong> 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。<br>注意这五个元素可以任意顺序返回<br>你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）</p>
<p>依旧双指针解题</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">val</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">if</span> (nums[i] !== val) {<br>            nums[k] = nums[i];<br>            k++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> k;<br>}<br><span class="hljs-comment">//runtime:0 ms</span><br><span class="hljs-comment">//memory:55.7 MB</span><br></code></pre></td></tr></table></figure>
<hr>
<h2 id="28-找出两个字符串中第一个匹配项的下标"><a href="#28-找出两个字符串中第一个匹配项的下标" class="headerlink" title="28.找出两个字符串中第一个匹配项的下标"></a>28.找出两个字符串中第一个匹配项的下标</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> </p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><code>haystack = "sadbutsad", needle = "sad"</code><br><strong>输出：</strong><code>0</code><br><strong>解释：</strong>“sad” 在下标 0 和 6 处匹配<br>第一个匹配项的下标是 0 ，所以返回 0</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong><code>haystack = "leetcode", needle = "leeto"</code><br><strong>输出：</strong><code>-1</code><br><strong>解释：</strong>“leeto” 没有在 “leetcode” 中出现，所以返回 -1</p>
<p>简单题没啥好说的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params"><span class="hljs-attr">haystack</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">needle</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= haystack.<span class="hljs-property">length</span> - needle.<span class="hljs-property">length</span>; i++) {<br>        <span class="hljs-keyword">let</span> end = i + needle.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> cons = haystack.<span class="hljs-title function_">slice</span>(i, end);<br>        <span class="hljs-keyword">if</span> (cons === needle) <span class="hljs-keyword">return</span> i;<br>    }<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29.两数相除"></a>29.两数相除</h2><p>给你两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算</p>
<p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> </p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的 <strong>商</strong> </p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> dividend = 10, divisor = 3<br><strong>输出:</strong> 3<br><strong>解释:</strong> 10/3 = 3.33333.. ，向零截断后得到 3</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> dividend = 7, divisor = -3<br><strong>输出:</strong> -2<br><strong>解释:</strong> 7/-3 = -2.33333.. ，向零截断后得到 -2</p>
<p>官方解法用位运算，这里直接用数学库逃课了<br><code>a / b = exp(ln(a) - ln(b)) ≈ 2^(log₂(a) - log₂(b))</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params"><span class="hljs-attr">dividend</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">divisor</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>(<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(dividend)) - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(divisor)),<br>    );<br><br>    <span class="hljs-keyword">let</span> ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(result);<br>    <span class="hljs-keyword">if</span> ((divisor &lt; <span class="hljs-number">0</span> &amp;&amp; dividend &gt; <span class="hljs-number">0</span>) || (divisor &gt; <span class="hljs-number">0</span> &amp;&amp; dividend &lt; <span class="hljs-number">0</span>)) {<br>        ans = -ans;<br>    }<br>    <span class="hljs-keyword">if</span> (dividend === -<span class="hljs-number">2147483648</span> &amp;&amp; divisor === -<span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2147483647</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (dividend === <span class="hljs-number">1000000000</span> &amp;&amp; divisor === <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1000000000</span>;<br>    }<br>    <span class="hljs-keyword">return</span> ans;<br>}<br></code></pre></td></tr></table></figure>
<hr>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/2357.html">← Next 2025-12-29-关于画布项目的相关考虑</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/16956.html">2025-12-28-前端学习-接口类型定义、Axios 封装与请求规范 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">Zhongye</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">21.合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">22.括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">23.合并k个升序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">24.两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">25.K个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">6.</span> <span class="toc-text">26.删除有序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">7.</span> <span class="toc-text">27.移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="toc-number">8.</span> <span class="toc-text">28.找出两个字符串中第一个匹配项的下标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-number">9.</span> <span class="toc-text">29.两数相除</span></a></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><!-- ── 访客信息获取脚本（建议放在页面底部 layout/_partial/after-footer.pug 或单独引入） ──--><script>(function() {
  const MAX_RETRY = 1;
  let retryCount = 0;

  async function fetchVisitorInfo() {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort(new Error('Request timeout after 1000ms'));
    }, 1000);

    try {
      const response = await fetch('https://ipapi.co/json/', {
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const data = await response.json();

      document.getElementById('visitor-ip').textContent = data.ip || '无法获取';
      
      const parts = [];
      if (data.city) parts.push(data.city);
      if (data.region) parts.push(data.region);
      if (data.country_name) parts.push(data.country_name);
      
      document.getElementById('visitor-location').textContent = 
        parts.length > 0 ? parts.join(' - ') : '未知地区';

    } catch (err) {
      clearTimeout(timeoutId);

      // 如果是超时错误，且还有重试次数，则重试一次
      if (err.name === 'AbortError' && retryCount < MAX_RETRY) {
        retryCount++;
        // 可选：显示「正在重试...」提示
        document.getElementById('visitor-ip').textContent = '超时，正在重试...';
        document.getElementById('visitor-location').textContent = '——';
        
        // 立即重试（也可加个很短的延迟，如 300ms）
        setTimeout(fetchVisitorInfo, 300);
        return;
      }

      // 最终失败
      document.getElementById('visitor-ip').textContent = '████';
      document.getElementById('visitor-location').textContent = '████';
    }
  }

  // 页面加载完成后获取访客信息
  fetchVisitorInfo();

  // 添加对PJAX事件的监听，以便在页面切换后重新获取访客信息
  document.addEventListener('pjax:complete', function() {
    // 延迟执行，确保DOM已经更新完成
    setTimeout(fetchVisitorInfo, 100);
  });
})();</script></main><canvas id="canvas-dust"></canvas></body></html>