<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-11-21-canvas项目杂记 | Zhongye's Blogs</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://picx.zhimg.com/v2-6c94831ec3400e77452e9bd9dde85cb5_r.jpg');
 --light-background: url('https://pica.zhimg.com/v2-0323b00e97b41d914a545c7ccea6ab0a_r.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Zhongye's Blogs" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-11-21-canvas项目杂记</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-11-21T06:50:48.000Z" id="date"> 2025-11-21</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-11-23T09:36:28.701Z" id="updated"> 2025-11-23</time></div></span><br><span id="busuanzi_container_page_pv">页面浏览: <span class="control" id="busuanzi_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><del>分析</del></h2><p><del>要做的就是一个<strong>类 Canva / Figma 的在线图形绘板</strong>，完整需求优先级和覆盖范围如下：</del></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>功能模块</th>
<th>具体需求</th>
<th>是否必须</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>基础渲染</td>
<td>矩形、圆形、三角形任意填充色、边框色、边框宽度、圆角、透明度</td>
<td>Yes</td>
<td>★☆</td>
</tr>
<tr>
<td>P0</td>
<td>图片支持</td>
<td>上传 png/jpg/webp，任意缩放、圆角、模糊、灰度、亮度调节、裁剪掩模</td>
<td>Yes</td>
<td>★★</td>
</tr>
<tr>
<td>P0</td>
<td>富文本</td>
<td>字体、字号、颜色、加粗、斜体、下划线、删除线、文本背景色、文字对齐、行距、局部样式支持</td>
<td>Yes</td>
<td>★★★★</td>
</tr>
<tr>
<td>P0</td>
<td>基本交互</td>
<td>单选、多选（框选 + Shift）、拖拽、删除、复制粘贴、缩放把手（8 个方向）、旋转把手</td>
<td>Yes</td>
<td>★★</td>
</tr>
<tr>
<td>P0</td>
<td>无限画布 + 缩放平移</td>
<td>Ctrl+滚轮缩放、空格拖拽平移、无限滚动</td>
<td>Yes</td>
<td>★☆</td>
</tr>
<tr>
<td>P0</td>
<td>数据持久化</td>
<td>自动 localStorage 保存、打开页面自动恢复</td>
<td>Yes</td>
<td>★☆</td>
</tr>
<tr>
<td>P1</td>
<td>高级交互</td>
<td>组合（Group）、解散组合、图层排序、辅助对齐线、吸附、旋转任意角度</td>
<td>Yes</td>
<td>★★★</td>
</tr>
<tr>
<td>P1</td>
<td>工具栏 &amp; 属性面板</td>
<td>顶部工具栏（切换文本/形状/图片模式）、右侧属性面板实时编辑属性</td>
<td>Yes</td>
<td>★★</td>
</tr>
<tr>
<td>P1</td>
<td>历史记录</td>
<td>Undo / Redo（支持跨会话）</td>
<td>Yes</td>
<td>★★</td>
</tr>
<tr>
<td>P1</td>
<td>性能要求</td>
<td>100 个复杂元素（图片+富文本）打开 &lt; 3s，拖拽 60fps 不闪烁</td>
<td>Yes</td>
<td>★★★★</td>
</tr>
<tr>
<td>P2</td>
<td>未来可扩展</td>
<td>实时协同编辑、离线编辑、模板库、导出 PNG/SVG/PDF、激光笔、箭头、自由画笔等</td>
<td>No</td>
<td>★★★★</td>
</tr>
</tbody>
</table>
</div>
<h1 id="架构方案"><a href="#架构方案" class="headerlink" title="架构方案"></a><del>架构方案</del></h1><ul>
<li><del><strong>渲染层</strong>：PixiJS (WebGL) 处理高性能图形渲染 + HTML DOM 处理文本编辑/输入框。</del></li>
<li><del><strong>状态管理</strong>：Zustand / Pinia (管理庞大的 JSON 画布数据)。</del></li>
<li><del><strong>逻辑层</strong>：自定义 Class 结构（如  Shape, Tool, History）实现面向对象编程。</del></li>
</ul>
<h3 id="二、项目设计要素"><a href="#二、项目设计要素" class="headerlink" title="二、项目设计要素"></a><del>二、项目设计要素</del></h3><div class="table-container">
<table>
<thead>
<tr>
<th>设计维度</th>
<th>推荐技术方案</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 渲染引擎</td>
<td>PixiJS v8（WebGL） + HTMLText</td>
<td>WebGL 抗锯齿完美 + 高分屏不模糊；HTMLText 是目前唯一能轻松实现富文本局部样式的方案</td>
</tr>
<tr>
<td>2. 状态管理</td>
<td>Zustand（或 Jotai + signals）</td>
<td>轻量、响应式、支持中间件（持久化、历史栈）</td>
</tr>
<tr>
<td>3. 元素对象缓存</td>
<td>Map<string, Container=""> 永久缓存（一个元素一个 Container，永不 destroy）</string,></td>
<td>彻底解决闪烁、拖拽中断、光标丢失的根本方案</td>
</tr>
<tr>
<td>4. 历史栈</td>
<td>Command Pattern + structuredClone 快照（每操作记录 before/after）</td>
<td>简单可靠，支持跨页面 Undo</td>
</tr>
<tr>
<td>5. 选中/变换系统</td>
<td>单独的 SelectionManager + TransformHandles（旋转、缩放把手层也缓存）</td>
<td>tldraw/Figma 标配</td>
</tr>
<tr>
<td>6. 辅助对齐线</td>
<td>拖拽时实时遍历所有元素 bounds，差值 &lt; 5px 就吸附并画蓝线</td>
<td>提升专业感</td>
</tr>
<tr>
<td>7. 组合（Group）</td>
<td>元素加 groupId 字段；选中时绘制大虚线框；拖拽/缩放/旋转时整体应用矩阵变换</td>
<td>必须有，属于 P1 核心</td>
</tr>
<tr>
<td>8. 数据持久化</td>
<td>Zustand middleware persist + localForage（IndexedDB）</td>
<td>防止 localStorage 炸掉</td>
</tr>
<tr>
<td>9. 图片处理</td>
<td>Sprite + Graphics mask（圆角）+ BlurFilter + ColorMatrixFilter</td>
<td>PixiJS 原生支持</td>
</tr>
<tr>
<td>10. 架构分层</td>
<td>- store（纯数据） - rendering（Pixi 元素缓存 &amp; 更新） - interaction（拖拽、选中逻辑） - ui（React 面板）</td>
</tr>
</tbody>
</table>
</div>
<p><del>installed pixi.js@8.14.3</del><br><del>installed zustand@5.0.8</del><br><del>installed nanoid@5.1.6</del></p>
<p><del><strong>数据驱动视图”（Data-Driven View）</strong>  模式，采用了  <strong>React (UI) + Zustand (数据) + PixiJS (渲染)</strong>  的三层分离架构</del></p>
<p><del>这种架构的核心理念是：<strong>PixiJS 实例不保存“业务状态”，它只是 Zustand 数据的“投影”</strong></del></p>
<p><del class='item-img' data-src='Pasted%20image%2020251121155817.png'><img src="Pasted%20image%2020251121155817.png" alt=""></del></p>
<p><del>其中，</del></p>
<ul>
<li><del>React 只负责 UI 和事件入口</del></li>
<li><del>Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）</del></li>
<li><del>PixiJS 层只做“渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建</del></li>
<li><del>所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）</del></li>
</ul>
<h3 id="三层架构详解"><a href="#三层架构详解" class="headerlink" title="三层架构详解"></a><del>三层架构详解</del></h3><h4 id="第一层：数据层-The-Source-of-Truth-canvasStore-ts"><a href="#第一层：数据层-The-Source-of-Truth-canvasStore-ts" class="headerlink" title="第一层：数据层 (The Source of Truth) - canvasStore.ts"></a><del>第一层：数据层 (The Source of Truth) - canvasStore.ts</del></h4><p><del>这是整个应用的大脑。</del></p>
<ul>
<li><del><strong>职责</strong>：只存储纯 JSON 数据（Serializable），不包含任何 UI 实例或 Pixi 对象。</del></li>
<li><del><strong>存储内容</strong>：</del><ul>
<li><del>elements: 一个 Map 对象（Record<id, Element="">），存储所有矩形、圆形的坐标、颜色等。</id,></del></li>
<li><del>selectedIds: 当前选中的 ID 列表。</del></li>
<li><del>tool: 当前使用的工具。</del></li>
</ul>
</li>
<li><del><strong>特点</strong>：</del><ul>
<li><del><strong>单一数据源</strong>：画布上显示什么，完全由这里的数据决定。</del></li>
<li><del><strong>无副作用</strong>：这里的 Action 只修改数据，不直接操作 DOM 或 Canvas。</del></li>
</ul>
</li>
</ul>
<h4 id="第二层：适配层-The-Bridge-StageManager-ts"><a href="#第二层：适配层-The-Bridge-StageManager-ts" class="headerlink" title="第二层：适配层 (The Bridge) - StageManager.ts"></a><del>第二层：适配层 (The Bridge) - StageManager.ts</del></h4><p><del>这是连接 React/Zustand 和 PixiJS 的胶水层，也是架构中最复杂的部分。</del></p>
<ul>
<li><del><strong>职责</strong>：将“声明式”的数据（Zustand）转换为“命令式”的 Pixi 调用。</del></li>
<li><del><strong>核心机制 - 增量更新 (Diffing)</strong>：</del><ul>
<li><del>它维护了一个  spriteMap (Map<id, PIXI.Graphics="">)。</id,></del></li>
<li><del><strong>订阅 (Subscribe)</strong>：它监听 Store 的变化。</del></li>
<li><del><strong>同步 (Sync/Render Loop)</strong>：</del><ul>
<li><del><strong>Create</strong>: Store 有 ID，Map 里没有 -&gt; new PIXI.Graphics()。</del></li>
<li><del><strong>Update</strong>: Store 有，Map 里也有 -&gt; 更新  x, y, width, color。</del></li>
<li><del><strong>Delete</strong>: Store 没有，Map 里有 -&gt; destroy()。</del></li>
</ul>
</li>
</ul>
</li>
<li><del><strong>事件转换</strong>：</del><ul>
<li><del>它监听 Pixi 的  pointerdown/move/up  事件，将屏幕坐标转换为逻辑坐标，然后调用 Store 的 Action。</del></li>
</ul>
</li>
</ul>
<h4 id="第三层：视图层-The-Container-Canvas-tsx"><a href="#第三层：视图层-The-Container-Canvas-tsx" class="headerlink" title="第三层：视图层 (The Container) - Canvas.tsx"></a><del>第三层：视图层 (The Container) - Canvas.tsx</del></h4><p><del>这是 React 组件层。</del></p>
<ul>
<li><del><strong>职责</strong>：</del><ul>
<li><del>提供  div  容器供 Pixi 挂载。</del></li>
<li><del>渲染 HTML UI（工具栏、属性面板）。</del></li>
<li><del>生命周期管理：组件 Mount 时初始化  StageManager，Unmount 时销毁。</del></li>
</ul>
</li>
</ul>
<p><del>—-</del></p>
<h3 id="3-关键数据流转-Data-Flow"><a href="#3-关键数据流转-Data-Flow" class="headerlink" title="3. 关键数据流转 (Data Flow)"></a><del>3. 关键数据流转 (Data Flow)</del></h3><p><del>让我们以  <strong>“拖拽矩形移动”</strong>  为例，看数据如何在架构中流转：</del></p>
<p><del><strong>Input (输入)</strong>:</del></p>
<ul>
<li><del>用户在画布上按住矩形并移动鼠标。</del></li>
<li><del>StageManager  的  onPointerMove  被触发。</del></li>
</ul>
<p><del><strong>Logic (逻辑处理)</strong>:</del></p>
<ul>
<li><del>StageManager  计算鼠标的偏移量  (dx, dy)。</del></li>
<li><del>它<strong>不直接修改</strong> Pixi 图形的  graphics.x (这是关键！)。</del></li>
<li><del>它调用  store.updateElement(id, { x: newX, y: newY })。</del></li>
</ul>
<p><del><strong>State Update (状态更新)</strong>:</del></p>
<ul>
<li><del>Zustand Store 更新内部的 JSON 数据。</del></li>
<li><del>Zustand 触发订阅回调 (subscribe)。</del></li>
</ul>
<p><del><strong>Render Sync (渲染同步)</strong>:</del></p>
<ul>
<li><del>StageManager  的  render  方法被调用。</del></li>
<li><del>它从  spriteMap  找到对应的 Pixi 实例。</del></li>
<li><del>执行  graphic.position.set(newX, newY)。</del></li>
<li><del>PixiJS 在下一个  requestAnimationFrame  自动重绘 Canvas。</del></li>
</ul>
<p><del>—-</del></p>
<h3 id="4-为什么选择这种架构？"><a href="#4-为什么选择这种架构？" class="headerlink" title="4. 为什么选择这种架构？"></a><del>4. 为什么选择这种架构？</del></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><del>优点：</del></h4><p><del><strong>解耦 (Decoupling)</strong>：渲染引擎可以随时替换（比如换成 Konva 或原生 Canvas），只需要重写  StageManager，数据层和 UI 层不需要动。</del></p>
<p><del><strong>协同编辑 (Collaboration) 友好</strong>：</del></p>
<ul>
<li><del>如果要实现多入协同，只需要监听 WebSocket 消息，然后更新 Zustand Store。StageManager  会自动把队友的操作画出来，无需写额外的同步绘图逻辑。</del><br><del><strong>撤销/重做 (Undo/Redo) 容易</strong>：</del></li>
<li><del>因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照（或 Patch）即可。</del><br><del><strong>序列化/反序列化</strong>：</del></li>
<li><del>保存项目只需  JSON.stringify(store.elements)。</del></li>
</ul>
<h4 id="潜在挑战（及优化方案）："><a href="#潜在挑战（及优化方案）：" class="headerlink" title="潜在挑战（及优化方案）："></a><del>潜在挑战（及优化方案）：</del></h4><p><del><strong>性能瓶颈</strong>：</del></p>
<ul>
<li><del>问题：高频触发  Store Update -&gt; Diff  循环可能在元素极多时（&gt;2000 个）产生开销。</del></li>
<li><del>优化：对于拖拽这种 60FPS 的操作，可以引入“临时层” (Transient State)。即拖拽时直接修改 Pixi 对象，鼠标松开时再同步到 Store。</del><br><del><strong>复杂性</strong>：</del></li>
<li><del>相比直接用 Canvas API 画图，这种架构代码量更大，需要维护 ID 映射和 Diff 逻辑。</del></li>
</ul>
<p><del>feat(canvas): 重构画布实现，应项目要求，删除了基于tldraw的实现转而选择PixiJS 库重构以进行渲染操作，基于Zustand 进行状态管理。新增的文件中canvasStore.ts主要负责维护整个画布项目的全局可序列化状态，是渲染画布系统中唯一数据来源。Pixi_stageManager.ts 负责将声明式数据（Zustand）实时、高性能地映射为命令式渲染实例（PixiJS），并处理所有用户交互的计算与反馈。canvas下的index.ts最轻量的一层，仅负责生命周期管理与组件组装。三层数据驱动架构详情可见文档</del></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/15722.html">← 下一篇 2025-11-22- 关于前端包管理器npm,pnpm,yarn和bun以及我为何选择后者</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/25943.html">2025-11-20-关于滑动窗口 上一篇 →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">Zhongye</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">架构方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%B4%A0"><span class="toc-number">0.1.</span> <span class="toc-text">二、项目设计要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">0.2.</span> <span class="toc-text">三层架构详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B1%82-The-Source-of-Truth-canvasStore-ts"><span class="toc-number">0.2.1.</span> <span class="toc-text">第一层：数据层 (The Source of Truth) - canvasStore.ts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%9A%E9%80%82%E9%85%8D%E5%B1%82-The-Bridge-StageManager-ts"><span class="toc-number">0.2.2.</span> <span class="toc-text">第二层：适配层 (The Bridge) - StageManager.ts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%B1%82%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%B1%82-The-Container-Canvas-tsx"><span class="toc-number">0.2.3.</span> <span class="toc-text">第三层：视图层 (The Container) - Canvas.tsx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC-Data-Flow"><span class="toc-number">0.3.</span> <span class="toc-text">3. 关键数据流转 (Data Flow)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E8%BF%99%E7%A7%8D%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-number">0.4.</span> <span class="toc-text">4. 为什么选择这种架构？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">0.4.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BD%9C%E5%9C%A8%E6%8C%91%E6%88%98%EF%BC%88%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%EF%BC%89%EF%BC%9A"><span class="toc-number">0.4.2.</span> <span class="toc-text">潜在挑战（及优化方案）：</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><!-- ── 访客信息获取脚本（建议放在页面底部 layout/_partial/after-footer.pug 或单独引入） ──--><script>(function() {
  const MAX_RETRY = 1;
  let retryCount = 0;

  async function fetchVisitorInfo() {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort(new Error('Request timeout after 1000ms'));
    }, 1000);

    try {
      const response = await fetch('https://ipapi.co/json/', {
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const data = await response.json();

      document.getElementById('visitor-ip').textContent = data.ip || '无法获取';
      
      const parts = [];
      if (data.city) parts.push(data.city);
      if (data.region) parts.push(data.region);
      if (data.country_name) parts.push(data.country_name);
      
      document.getElementById('visitor-location').textContent = 
        parts.length > 0 ? parts.join(' - ') : '未知地区';

    } catch (err) {
      clearTimeout(timeoutId);

      // 如果是超时错误，且还有重试次数，则重试一次
      if (err.name === 'AbortError' && retryCount < MAX_RETRY) {
        retryCount++;
        // 可选：显示「正在重试...」提示
        document.getElementById('visitor-ip').textContent = '超时，正在重试...';
        document.getElementById('visitor-location').textContent = '——';
        
        // 立即重试（也可加个很短的延迟，如 300ms）
        setTimeout(fetchVisitorInfo, 300);
        return;
      }

      // 最终失败
      document.getElementById('visitor-ip').textContent = '████';
      document.getElementById('visitor-location').textContent = '████';
    }
  }

  // 页面加载完成后获取访客信息
  fetchVisitorInfo();

  // 添加对PJAX事件的监听，以便在页面切换后重新获取访客信息
  document.addEventListener('pjax:complete', function() {
    // 延迟执行，确保DOM已经更新完成
    setTimeout(fetchVisitorInfo, 100);
  });
})();</script></main><canvas id="canvas-dust"></canvas></body></html>