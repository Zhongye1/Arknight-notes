<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-12-07-杂谈-复杂异构系统监控与可视化项目设计 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-12-07-杂谈-复杂异构系统监控与可视化项目设计</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-12-07T13:09:33.000Z" id="date"> 2025-12-07</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-12-15T03:40:34.795Z" id="updated"> 2025-12-15</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><h2 id="复杂异构系统监控与可视化项目设计"><a href="#复杂异构系统监控与可视化项目设计" class="headerlink" title="复杂异构系统监控与可视化项目设计"></a><strong>复杂异构系统监控与可视化</strong>项目设计</h2><h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><p>现在需要设计一个系统，使用py的fastapi作为后端</p>
<p>目前有一个使用 Docker Compose 编排的复杂容器化环境，基于 SeedEmu（SEED Internet Emulator）框架构建。该框架专用于模拟大规模互联网基础设施，常用于网络安全研究、教育和实验，特别是区块链网络的安全性测试。<br>此 docker-compose.yml 定义了一个模拟的互联网环境，其中部署了一个完整的 Ethereum Proof-of-Stake (PoS) 区块链网络，分布在多个自治系统（Autonomous Systems, AS）中，并通过互联网交换点（Internet Exchange Points, IXP）和路由器实现互联。该环境的主要目的是：</p>
<p>模拟真实互联网拓扑下的区块链网络行为。<br>支持研究区块链在复杂网络环境下的安全性、性能、攻击与防御（如 Eclipse 攻击、分区攻击、路由攻击等）。<br>提供可视化监控、数据采集和分析工具。</p>
<p>主要组件与功能有：</p>
<p>数据库与辅助服务：<br>postgresql: 用于存储区块链监控数据（数据库名为 ethereum_monitor）。<br>redis: 作为缓存或消息队列，可能用于节点间协调或数据临时存储。<br>neo4j: 图数据库，用于存储和分析网络拓扑、区块链节点关系等复杂关系数据。</p>
<p>Ethereum 区块链网络：<br>在 AS 101–112（共12个自治系统）中部署了大量 Ethereum PoS 节点。<br>每个 AS 内部包含 3 个本地网络（inet0、inet1、inet2），每个网络内有 3 个 Ethereum 节点（共9个节点/AS）。<br>总计约 108 个 Ethereum validator/miner 节点（节点ID从2到108），加上一个 BootNode 和 BeaconSetup 节点。<br>所有节点运行在自定义的链上（chain_id: 1337, chain_name: posCurrentEnhancedNet）。<br>部分节点（如 AS101 的 host0）暴露了 JSON-RPC (8545)、WebSocket (8546) 和 Web 界面 (8000) 端口，便于外部交互。</p>
<p>网络路由基础设施（基于 SeedEmu）：<br>AS 2：作为一个骨干/中转 AS，包含四个边界路由器（r51–r54），通过点对点链路（net_2_net_51_52 等）连接。<br>IXP（互联网交换点）：ix51–ix54 四个全球 IXP，每个有 Route Server（路由服务器），用于多边对等互联。<br>AS 21–24：作为 IXP 的参与者（peering AS），每个连接一个 IXP。<br>AS 101–112：每个 AS 有一个边界路由器连接到对应的 IXP（例如 AS101 连接 ix51），实现与外部互联网的连通。<br>所有路由器运行真实路由协议（如 BGP），支持模拟路由攻击、劫持等。</p>
<p>可视化与监控工具：<br>seedemu-internet-client：运行 SeedEmu 的互联网拓扑可视化界面，映射端口 8080，提供整个网络拓扑的图形化视图。<br>seedemu-ether-client：运行 Ethereum 网络专用可视化界面，映射端口 5000，用于查看区块链节点状态、同步情况、交易等。<br>eth_node_cleaner：自定义服务，暴露端口 8888，可能用于中央数据收集、节点状态清理或监控指标聚合，连接 PostgreSQL、Redis 和 Neo4j。</p>
<p>其他特性：<br>大量自定义网络（local 和 global 类型），精确分配 IP 地址段。<br>节点标签丰富（org.seedsecuritylabs.seedemu.meta.*），便于 SeedEmu 工具识别和渲染。<br>部分服务使用 privileged 模式和 cap_add: ALL，以支持模拟路由所需的网络权限。</p>
<p>现在需要实现一系列功能，提供基于FastAPI框架的RESTful API路由模块（topology_router），专用于提供区块链仿真环境（特别是结合SeedEmu和Ethereum PoS网络）的完整拓扑数据访问接口如下：</p>
<p>GET /overview<br>获取整个仿真环境的拓扑概览信息（如节点总数、层级结构等）。<br>GET /statistics<br>获取拓扑统计数据（如节点、链路数量等汇总指标）。<br>GET /health<br>检查拓扑服务的健康状态，返回组件运行状况。</p>
<p>GET /ethereum<br>获取完整的以太坊网络拓扑数据（节点与P2P连接）。<br>GET /ethereum/nodes<br>获取所有以太坊节点列表，支持按层级过滤（execution或consensus）。<br>GET /ethereum/nodes/{node_id}<br>获取指定以太坊节点（执行层或共识层）的详细信息。<br>GET /ethereum/validators/{validator_id}<br>根据验证者公钥获取单个验证者节点的详细状态和信息。</p>
<p>GET /physical<br>获取纯物理拓扑结构（不包含容器运行时监控数据）。<br>GET /physical/devices<br>获取物理设备列表（路由器、主机等），支持按设备类型过滤。<br>GET /physical/links<br>获取物理链路（网络连接）列表，支持按连接类型过滤。<br>GET /physical/networks<br>获取所有物理网络的配置信息（网络ID、名称、子网、网关等）。</p>
<p>GET /contract<br>获取智能合约相关的拓扑视图（合约部署、调用关系等）。<br>GET /contract/statistics<br>获取合约层面的统计信息（如合约数量、调用频率等）。</p>
<p>GET /transaction<br>获取交易拓扑数据，支持通过时间范围（start_time和end_time）过滤。<br>GET /transaction/statistics<br>获取交易层面的统计信息。<br>GET /transaction/address/{address}/analysis<br>分析特定以太坊地址的资金/交易流向（流入流出关系图）。</p>
<p>GET /layer/{layer}<br>根据指定拓扑层（枚举值，如ethereum、physical等）获取对应层级的完整拓扑数据。<br>POST /combined<br>支持组合多个拓扑层（如以太坊层+物理层）生成统一的拓扑视图，可指定渲染格式。</p>
<p>POST /render<br>接收任意拓扑数据和渲染请求（格式如cytoscape、graphviz等），返回经过布局算法处理的可直接用于前端可视化的数据。</p>
<p>GET /nodes/{node_id}<br>获取任意节点（跨层级）的详细信息，支持指定层级。<br>GET /analysis/{layer}<br>对指定层级进行网络分析（如连通性、中心性、社区检测等指标）。</p>
<p>POST /cache/clear<br>清空服务内部所有缓存（用于强制刷新数据）。<br>GET /debug/info<br>获取详细的调试信息，包括服务组件状态、各处理器缓存大小、支持的层级与渲染格式等，便于开发与运维排查。</p>
<hr>
<h2 id="针对该环境和需求的系统设计方案"><a href="#针对该环境和需求的系统设计方案" class="headerlink" title="针对该环境和需求的系统设计方案"></a>针对该环境和需求的<strong>系统设计方案</strong></h2><p>需要设计一个 FastAPI 后端，它充当一个“中间层（Middleware）”或“聚合层（Aggregator）”，将底层分散的基础设施（Docker）、网络拓扑（SeedEmu/Neo4j）和应用状态（Ethereum/PostgreSQL）整合成统一的 API 暴露给前端</p>
<h3 id="1-系统架构概览"><a href="#1-系统架构概览" class="headerlink" title="1. 系统架构概览"></a>1. 系统架构概览</h3><p>由于涉及 140+ 容器和多种数据源，系统的核心挑战在于<strong>数据聚合</strong>和<strong>性能优化</strong>。建议采用分层架构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    User[前端/可视化大屏] &lt;--&gt; API[FastAPI 网关]<br>    <br>    subgraph "FastAPI 后端应用"<br>        API --&gt; Cache[Redis 缓存层]<br>        API --&gt; Service[业务逻辑层 TopologyService]<br>        <br>        Service --&gt; Adapter1[Docker Adapter]<br>        Service --&gt; Adapter2[Neo4j Adapter]<br>        Service --&gt; Adapter3[Ethereum Adapter Web3.py]<br>        Service --&gt; Adapter4[DB Adapter SQLAlchemy]<br>    end<br>    <br>    subgraph "基础设施 Docker Compose"<br>        Adapter1 --&gt; DockerDaemon[Docker Socket]<br>        Adapter2 --&gt; Neo4j[Neo4j 图数据库]<br>        Adapter3 --&gt; EthNodes[JSON-RPC AS101 Host0]<br>        Adapter4 --&gt; PG[PostgreSQL ethereum_monitor]<br>    end<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="2-核心模块设计"><a href="#2-核心模块设计" class="headerlink" title="2. 核心模块设计"></a>2. 核心模块设计</h3><p>我们需要将代码组织为清晰的模块，以应对你列出的 9 大类接口。</p>
<h4 id="2-1-数据模型层-Models-Schemas"><a href="#2-1-数据模型层-Models-Schemas" class="headerlink" title="2.1 数据模型层 (Models/Schemas)"></a>2.1 数据模型层 (Models/Schemas)</h4><p>使用 Pydantic 定义统一的拓扑数据结构，这是所有接口返回的基础。</p>
<p>网络拓扑系统采用了分层架构设计，主要包括以下几个层级：</p>
<ol>
<li><strong>API层</strong> - topology_api.py 提供RESTful接口</li>
<li><strong>服务层</strong> - topology_service.py 协调各种拓扑功能</li>
<li><strong>数据层</strong> - real_topology_service.py 处理真实数据获取</li>
<li><strong>专门处理器层</strong> - 处理合约、交易等特定类型的拓扑</li>
<li><p><strong>管理与渲染层</strong> - 负责生命周期管理和数据渲染</p>
</li>
<li><p>用户通过API请求拓扑数据（如 /topology/ethereum）</p>
</li>
<li>API调用 TopologyService 的 get_ethereum_topology() 方法</li>
<li>TopologyService 委托给 _real_data_service（即 RealTopologyService）</li>
<li>RealTopologyService 从Neo4j数据库获取真实的以太坊P2P网络拓扑数据</li>
<li>数据经过处理和格式化后返回给用户</li>
</ol>
<p>对于以太坊拓扑：</p>
<ol>
<li>从Neo4j数据库查询执行层和共识层节点及其连接关系</li>
<li>查询验证者节点并与共识节点关联</li>
<li>将原始数据转换为前端友好的拓扑格式</li>
<li>通过Docker客户端获取容器信息，建立IP地址与容器名称的映射</li>
</ol>
<p>对于物理拓扑：</p>
<ol>
<li>通过Docker客户端获取所有容器的详细信息</li>
<li>根据容器名称识别设备类型（路由器、主机等）</li>
<li>根据容器连接的网络建立设备间连接关系</li>
<li>使用共享网络原则确定设备连接</li>
</ol>
<p>在 topology_interfaces.py 中定义了核心抽象类：</p>
<ol>
<li><p><strong>TopologyNode</strong> - 拓扑节点基类</p>
<ul>
<li>id: 节点唯一标识</li>
<li>name: 节点名称</li>
<li>node_type: 节点类型（执行层、共识层、验证者等）</li>
<li>ip_address: IP地址</li>
<li>layer: 所属层级</li>
<li>status: 状态</li>
<li>metadata: 元数据</li>
</ul>
</li>
<li><p><strong>TopologyLink</strong> - 拓扑连接基类</p>
<ul>
<li>source: 源节点ID</li>
<li>target: 目标节点ID</li>
<li>link_type: 连接类型</li>
<li>layer: 所属层级</li>
<li>direction: 连接方向</li>
<li>metadata: 元数据</li>
</ul>
</li>
</ol>
<p>不同类型的拓扑节点</p>
<ol>
<li><p><strong>以太坊节点</strong>：</p>
<ul>
<li>执行层节点（execution）</li>
<li>共识层节点（consensus）</li>
<li>验证者节点（validator）</li>
</ul>
</li>
<li><p><strong>物理节点</strong>：</p>
<ul>
<li>路由器（border_router）</li>
<li>主机（ethernet_host）</li>
<li>交换机（ixp_core）</li>
</ul>
</li>
</ol>
<p>拓扑数据最终以以下格式组织：</p>
<ul>
<li><strong>nodes</strong>: 节点列表，每个节点包含id、name、type、ip_address、status等属性</li>
<li><strong>links</strong>: 连接列表，每个连接包含source、target、type等属性</li>
<li><strong>元数据</strong>: 时间戳、数据源、统计信息等</li>
</ul>
<p>这是与底层交互的关键。</p>
<ol>
<li><p><strong>InfrastructureAdapter (Docker &amp; SeedEmu):</strong></p>
<ul>
<li><p><strong>作用:</strong> 获取物理拓扑。</p>
</li>
<li><p><strong>实现:</strong> 使用 docker Python 库读取容器列表。解析 com.docker.compose.service 和 org.seedsecuritylabs.seedemu.meta.* 标签来识别节点角色（AS、路由器、主机）。</p>
</li>
<li><p><strong>对应接口:</strong> /physical/*</p>
</li>
</ul>
</li>
<li><p><strong>GraphDBAdapter (Neo4j):</strong></p>
<ul>
<li><p><strong>作用:</strong> 获取网络静态拓扑和关联关系。</p>
</li>
<li><p><strong>实现:</strong> 使用 neo4j Python 驱动。SeedEmu 通常会将生成的拓扑导入 Neo4j。查询 Cypher 语句来获取节点间的连接。</p>
</li>
<li><p><strong>对应接口:</strong> /overview, /analysis/{layer}</p>
</li>
</ul>
</li>
<li><p><strong>BlockchainAdapter (Web3.py &amp; Postgres):</strong></p>
<ul>
<li><p><strong>作用:</strong> 获取链上实时状态。</p>
</li>
<li><p><strong>实现:</strong></p>
<ul>
<li><p>实时数据: 使用 web3.py (AsyncHTTPProvider) 连接开放 RPC 端口的节点（如 AS101 的 8545）。获取 Block Height, Peer Count。</p>
</li>
<li><p>历史/统计: 连接 PostgreSQL (ethereum_monitor)，查询交易历史、合约调用统计。</p>
</li>
</ul>
</li>
<li><p><strong>对应接口:</strong> /ethereum/<em>, /contract/</em>, /transaction/*</p>
</li>
</ul>
</li>
</ol>
<h4 id="2-3-业务服务层-Services"><a href="#2-3-业务服务层-Services" class="headerlink" title="2.3 业务服务层 (Services)"></a>2.3 业务服务层 (Services)</h4><p>这是实现 RealTopologyService 的地方，负责组装数据。</p>
<ul>
<li><p><strong>TopologyService:</strong></p>
<ul>
<li><p><strong>Layer Filtering:</strong> 能够根据请求的 layer (physical, ethereum) 调用不同的 Adapter。</p>
</li>
<li><p><strong>Merging:</strong> 实现 /combined 接口，将 Docker 的运行状态（Up/Down）注入到 Neo4j 查出的静态拓扑中，并将 Ethereum 节点的逻辑 ID（Validator ID）映射到物理容器 IP。</p>
</li>
<li><p><strong>Caching:</strong> <strong>非常重要</strong>。遍历 140 个容器和查询区块链是耗时的。</p>
<ul>
<li><p>使用 Redis 缓存完整的拓扑 JSON。</p>
</li>
<li><p>设置后台定时任务（FastAPI lifespan 或 APScheduler）每 5-10 秒刷新一次缓存。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>AnalysisService:</strong></p>
<ul>
<li><p><strong>NetworkX 集成:</strong> 将拓扑数据加载到 Python 的 networkx 库中。</p>
</li>
<li><p><strong>算法:</strong> 计算中心性（Centrality）、最短路径（用于分析攻击传播）、社区发现。</p>
</li>
<li><p><strong>对应接口:</strong> /analysis/*</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-具体接口实现策略"><a href="#3-具体接口实现策略" class="headerlink" title="3. 具体接口实现策略"></a>3. 具体接口实现策略</h3><p>针对你提供的文档，以下是具体实现建议：</p>
<h4 id="A-物理层-Physical-Layer"><a href="#A-物理层-Physical-Layer" class="headerlink" title="A. 物理层 (Physical Layer)"></a>A. 物理层 (Physical Layer)</h4><ul>
<li><p><strong>挑战:</strong> 如何知道哪个容器连接哪个？</p>
</li>
<li><p><strong>方案:</strong> SeedEmu 通常会在生成容器时将连接信息写入 Neo4j 或生成的 metadata 文件。优先从 <strong>Neo4j</strong> 读取链路关系，从 <strong>Docker API</strong> 读取节点存活状态（Status: Running/Exited）。</p>
</li>
</ul>
<h4 id="B-以太坊层-Ethereum-Layer"><a href="#B-以太坊层-Ethereum-Layer" class="headerlink" title="B. 以太坊层 (Ethereum Layer)"></a>B. 以太坊层 (Ethereum Layer)</h4><ul>
<li><p><strong>挑战:</strong> 108 个节点，如何获取所有节点状态？</p>
</li>
<li><p><strong>方案:</strong></p>
<ol>
<li><p><strong>信标链数据 (Consensus):</strong> 连接 Beacon Node API (如果环境中有) 获取验证者状态 (Active/Slashed)。</p>
</li>
<li><p><strong>P2P 拓扑:</strong> 使用 admin_peers RPC 方法（需要节点开启该 API）查询节点的连接对象。由于无法轮询所有 108 个节点，可以只轮询几个关键 Bootnode 和 AS 网关节点，构建局部图。</p>
</li>
<li><p><strong>Postgres 补充:</strong> 从数据库中读取已知的节点列表和 Validator ID 映射。</p>
</li>
</ol>
</li>
</ul>
<h4 id="C-交易与合约-Transaction-amp-Contract"><a href="#C-交易与合约-Transaction-amp-Contract" class="headerlink" title="C. 交易与合约 (Transaction & Contract)"></a>C. 交易与合约 (Transaction &amp; Contract)</h4><ul>
<li><p><strong>挑战:</strong> 实时分析交易流向。</p>
</li>
<li><p><strong>方案:</strong></p>
<ul>
<li><p>不要直接扫描链。</p>
</li>
<li><p>利用环境中的 postgresql (ethereum_monitor)。SeedEmu 的监控器应该已经将区块和交易写入库中。</p>
</li>
<li><p>接口 /transaction/address/{address}/analysis 直接执行 SQL 聚合查询（Group by to/from），返回资金流向图。</p>
</li>
</ul>
</li>
</ul>
<h4 id="D-可视化渲染-Rendering"><a href="#D-可视化渲染-Rendering" class="headerlink" title="D. 可视化渲染 (Rendering)"></a>D. 可视化渲染 (Rendering)</h4><ul>
<li><p><strong>接口:</strong> POST /render</p>
</li>
<li><p><strong>逻辑:</strong> 前端可能只需传递原始数据，后端使用 networkx 计算布局（如 ForceAtlas2 或层级布局），计算出每个节点的 (x, y) 坐标，返回给前端直接绘制。这能减轻前端浏览器处理 140+ 节点布局的压力。</p>
</li>
</ul>
<hr>
<h3 id="4-代码结构示例"><a href="#4-代码结构示例" class="headerlink" title="4. 代码结构示例"></a>4. 代码结构示例</h3><p>codePython</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/topology.py</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">from</span> app.schemas.topology <span class="hljs-keyword">import</span> TopologyGraph<br><br>router = APIRouter(prefix=<span class="hljs-string">"/topology"</span>, tags=[<span class="hljs-string">"Topology"</span>])<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/overview"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_overview</span>(<span class="hljs-params">service: TopologyService = Depends(<span class="hljs-params">get_topology_service</span>)</span>):<br>    <span class="hljs-comment"># 从缓存获取，如果无则计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.get_system_overview()<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/ethereum/nodes/{node_id}"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eth_node_detail</span>(<span class="hljs-params">node_id: <span class="hljs-built_in">str</span>, service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 1. 查 Neo4j 获取节点基础信息</span><br>    <span class="hljs-comment"># 2. 查 Docker 确认容器是否在线</span><br>    <span class="hljs-comment"># 3. 查 Web3/DB 获取链上余额和状态</span><br>    data = <span class="hljs-keyword">await</span> service.get_node_composite_info(node_id, layer=<span class="hljs-string">"ethereum"</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"Node not found"</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">"/combined"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_combined_view</span>(<span class="hljs-params">layers: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], service: TopologyService = Depends(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 融合物理层和区块链层</span><br>    <span class="hljs-comment"># 例如：展示 区块链P2P连线 覆盖在 物理AS拓扑 上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> service.generate_combined_topology(layers)<br></code></pre></td></tr></table></figure>
<h3 id="5-关键技术难点与解决方案"><a href="#5-关键技术难点与解决方案" class="headerlink" title="5. 关键技术难点与解决方案"></a>5. 关键技术难点与解决方案</h3><ol>
<li><p><strong>Docker 网络访问:</strong></p>
<ul>
<li><p>FastAPI 容器需要挂载 /var/run/docker.sock 才能查询兄弟容器的状态。</p>
</li>
<li><p>docker-compose.yml 配置:</p>
<p>  codeYaml</p>
  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">volumes:</span><br>  - <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/docker.sock:/</span><span class="hljs-keyword">var</span><span class="hljs-regexp">/run/</span>docker.sock<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>跨容器数据库连接:</strong></p>
<ul>
<li>连接 Neo4j 和 Postgres 时，Host 应使用 Docker Compose 服务名（如 neo4j, postgresql），而不是 localhost。</li>
</ul>
</li>
<li><p><strong>性能瓶颈:</strong></p>
<ul>
<li><p><strong>问题:</strong> /ethereum 接口如果实时调用 100+ 次 RPC 会超时。</p>
</li>
<li><p><strong>解决:</strong> 使用 <strong>“后台采集 + 前端读取”</strong> 模式。编写一个后台 Task (使用 asyncio 或 Celery) 每 10 秒扫描一次网络状态存入 Redis。API 接口只读 Redis。</p>
</li>
</ul>
</li>
<li><p><strong>IP地址管理:</strong></p>
<ul>
<li><p>SeedEmu 的自定义网络（inet0, net_2_net_51_52）非常复杂。</p>
</li>
<li><p>在返回 /physical 拓扑时，务必解析 Docker inspect 结果中的 NetworkSettings，将特定网段 IP 映射给前端，否则前端无法理解路由关系。</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-总结建议"><a href="#6-总结建议" class="headerlink" title="6. 总结建议"></a>6. 总结建议</h3><p>设计这个系统时，请遵循以下步骤：</p>
<ol>
<li><p><strong>优先打通 Neo4j:</strong> 它是拓扑的真理来源（Source of Truth）。确保能查询出 AS、Router 和 Host 的关系。</p>
</li>
<li><p><strong>实现缓存机制:</strong> 复杂的 Docker 集群状态获取很慢，不要让 API 直接穿透到 Docker Daemon。</p>
</li>
<li><p><strong>定义清晰的 ID 映射:</strong> 最大的坑在于关联 “Docker Container Name” (e.g., as101_host0) 和 “Ethereum Node ID” (e.g., Validator-3)。需要在服务启动时建立这个映射表。</p>
</li>
<li><p><strong>按层开发:</strong> 先做 Physical（最简单，只读 Docker），再做 Ethereum（读 DB），最后做高级的 Contract/Transaction 分析。</p>
</li>
</ol>
<hr>
<p>实现“实时更新”并“高亮变化”的核心在于结合 <strong>FastAPI 的 WebSocket</strong> 推送机制与 <strong>D3.js 的 General Update Pattern（通用更新模式）</strong>。</p>
<p>这里有三个关键点：</p>
<ol>
<li><p><strong>后端推送</strong>：只推送最新的全量/增量状态。</p>
</li>
<li><p><strong>前端数据绑定</strong>：D3 必须通过 Key Function 识别哪些是新节点、哪些是旧节点，而不是每次清空画布重绘。</p>
</li>
<li><p><strong>视觉反馈</strong>：利用 CSS 动画或 D3 Transition 让变化的节点产生“闪烁”或“颜色渐变”。</p>
</li>
</ol>
<hr>
<h3 id="1-整体架构设计"><a href="#1-整体架构设计" class="headerlink" title="1. 整体架构设计"></a>1. 整体架构设计</h3><ul>
<li><p><strong>后端 (FastAPI)</strong>: 运行一个后台任务（Background Task），每隔几秒扫描一次 Docker/Ethereum 状态，通过 WebSocket 广播给前端。</p>
</li>
<li><p><strong>前端 (D3.js)</strong>: 维护一个长连接，收到数据后，执行 updateGraph(newData)。</p>
</li>
</ul>
<hr>
<h3 id="2-后端：FastAPI-WebSocket-实现"><a href="#2-后端：FastAPI-WebSocket-实现" class="headerlink" title="2. 后端：FastAPI WebSocket 实现"></a>2. 后端：FastAPI WebSocket 实现</h3><p>我们需要一个 ConnectionManager 来管理前端连接，并推送拓扑数据。</p>
<p>codePython</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app/routers/ws_topology.py</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, WebSocket, WebSocketDisconnect<br><span class="hljs-keyword">from</span> app.services.topology_service <span class="hljs-keyword">import</span> TopologyService<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> json<br><br>router = APIRouter()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections: <span class="hljs-built_in">list</span>[WebSocket] = []<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-keyword">await</span> websocket.accept()<br>        <span class="hljs-variable language_">self</span>.active_connections.append(websocket)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">self, websocket: WebSocket</span>):<br>        <span class="hljs-variable language_">self</span>.active_connections.remove(websocket)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">self, message: <span class="hljs-built_in">dict</span></span>):<br>        <span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.active_connections:<br>            <span class="hljs-keyword">await</span> connection.send_json(message)<br><br>manager = ConnectionManager()<br><br><span class="hljs-comment"># 模拟后台数据推送任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">topology_broadcaster</span>(<span class="hljs-params">service: TopologyService</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    这个函数需要在 main.py 的 @app.on_event("startup") 中启动</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 获取最新拓扑（包含 Docker 状态 + Geth 连接）</span><br>        topology_data = <span class="hljs-keyword">await</span> service.get_full_topology_snapshot()<br>        <br>        <span class="hljs-comment"># 广播数据</span><br>        <span class="hljs-keyword">if</span> manager.active_connections:<br>            <span class="hljs-keyword">await</span> manager.broadcast(topology_data)<br>        <br>        <span class="hljs-comment"># 每 5 秒推送一次，避免前端渲染压力过大</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-meta">@router.websocket(<span class="hljs-params"><span class="hljs-string">"/ws/topology"</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">websocket_endpoint</span>(<span class="hljs-params">websocket: WebSocket</span>):<br>    <span class="hljs-keyword">await</span> manager.connect(websocket)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 保持连接活跃，也可以接收前端的控制指令（比如点击了某个节点）</span><br>            data = <span class="hljs-keyword">await</span> websocket.receive_text() <br>    <span class="hljs-keyword">except</span> WebSocketDisconnect:<br>        manager.disconnect(websocket)<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="3-前端：D3-js-实时更新与高亮逻辑"><a href="#3-前端：D3-js-实时更新与高亮逻辑" class="headerlink" title="3. 前端：D3.js 实时更新与高亮逻辑"></a>3. 前端：D3.js 实时更新与高亮逻辑</h3><p>这是最关键的部分。不要清空 SVG！使用 D3 的 <strong>Enter (新增), Update (更新), Exit (删除)</strong> 模式。</p>
<h4 id="核心策略："><a href="#核心策略：" class="headerlink" title="核心策略："></a>核心策略：</h4><ol>
<li><p><strong>ID 绑定</strong>：告诉 D3 如何通过 ID（如 enode_id 或 container_name）区分节点，而不是数组索引。</p>
</li>
<li><p><strong>平滑模拟</strong>：数据更新时，不要将 alpha 重置为 1（会导致整个图剧烈爆炸），而是重置为 0.3 左右（轻微调整）。</p>
</li>
<li><p><strong>样式Diff</strong>：比对新旧数据，如果状态变化（如 IP 变了，Peer 数变了），添加 CSS 类名触发动画。</p>
</li>
</ol>
<h4 id="代码实现-HTML-JS"><a href="#代码实现-HTML-JS" class="headerlink" title="代码实现 (HTML/JS)"></a>代码实现 (HTML/JS)</h4><p>codeJavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化 SVG 和 Simulation</span><br><span class="hljs-keyword">const</span> svg = d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">"#topology-svg"</span>);<br><span class="hljs-keyword">const</span> width = +svg.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"width"</span>);<br><span class="hljs-keyword">const</span> height = +svg.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"height"</span>);<br><br><span class="hljs-keyword">let</span> simulation = d3.<span class="hljs-title function_">forceSimulation</span>()<br>    .<span class="hljs-title function_">force</span>(<span class="hljs-string">"link"</span>, d3.<span class="hljs-title function_">forceLink</span>().<span class="hljs-title function_">id</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">id</span>).<span class="hljs-title function_">distance</span>(<span class="hljs-number">100</span>))<br>    .<span class="hljs-title function_">force</span>(<span class="hljs-string">"charge"</span>, d3.<span class="hljs-title function_">forceManyBody</span>().<span class="hljs-title function_">strength</span>(-<span class="hljs-number">300</span>))<br>    .<span class="hljs-title function_">force</span>(<span class="hljs-string">"center"</span>, d3.<span class="hljs-title function_">forceCenter</span>(width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 定义箭头和样式</span><br><span class="hljs-comment">// ... (省略定义 marker 的代码) ...</span><br><br><span class="hljs-comment">// 建立 WebSocket 连接</span><br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">"ws://localhost:8000/ws/topology"</span>);<br><br><span class="hljs-comment">// 本地存储当前数据，用于 diff</span><br><span class="hljs-keyword">let</span> currentNodes = [];<br><span class="hljs-keyword">let</span> currentEdges = [];<br><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);<br>    <span class="hljs-title function_">updateGraph</span>(data);<br>};<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateGraph</span>(<span class="hljs-params">data</span>) {<br>    <span class="hljs-comment">// 1. 保留旧节点的位置信息！</span><br>    <span class="hljs-comment">// 如果不这样做，每次更新所有节点都会瞬间跳回原点或随机位置</span><br>    <span class="hljs-keyword">const</span> nodeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(currentNodes.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> [n.<span class="hljs-property">id</span>, n]));<br>    data.<span class="hljs-property">nodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">newNode</span> =&gt;</span> {<br>        <span class="hljs-keyword">const</span> oldNode = nodeMap.<span class="hljs-title function_">get</span>(newNode.<span class="hljs-property">id</span>);<br>        <span class="hljs-keyword">if</span> (oldNode) {<br>            newNode.<span class="hljs-property">x</span> = oldNode.<span class="hljs-property">x</span>;<br>            newNode.<span class="hljs-property">y</span> = oldNode.<span class="hljs-property">y</span>;<br>            newNode.<span class="hljs-property">vx</span> = oldNode.<span class="hljs-property">vx</span>;<br>            newNode.<span class="hljs-property">vy</span> = oldNode.<span class="hljs-property">vy</span>;<br>        }<br>    });<br>    <br>    currentNodes = data.<span class="hljs-property">nodes</span>;<br>    currentEdges = data.<span class="hljs-property">edges</span>;<br><br>    <span class="hljs-comment">// ================= 处理连线 (Links) =================</span><br>    <span class="hljs-comment">// key function: d =&gt; d.source.id + "-" + d.target.id</span><br>    <span class="hljs-comment">// 确保连线唯一性</span><br>    <span class="hljs-keyword">const</span> links = svg.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">".link"</span>)<br>        .<span class="hljs-title function_">data</span>(data.<span class="hljs-property">edges</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${d.source}</span>-<span class="hljs-subst">${d.target}</span>`</span>);<br><br>    links.<span class="hljs-title function_">exit</span>()<br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">style</span>(<span class="hljs-string">"opacity"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 消失动画</span><br>        .<span class="hljs-title function_">remove</span>();<br><br>    <span class="hljs-keyword">const</span> linksEnter = links.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">"line"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"link"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"#999"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke-width"</span>, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// MERGE: 合并新老连线</span><br>    <span class="hljs-keyword">const</span> linksMerge = linksEnter.<span class="hljs-title function_">merge</span>(links);<br><br>    <span class="hljs-comment">// ================= 处理节点 (Nodes) =================</span><br>    <span class="hljs-keyword">const</span> nodes = svg.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">".node"</span>)<br>        .<span class="hljs-title function_">data</span>(data.<span class="hljs-property">nodes</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">id</span>); <span class="hljs-comment">// 关键：使用 id 作为 key</span><br><br>    <span class="hljs-comment">// EXIT: 节点消失</span><br>    nodes.<span class="hljs-title function_">exit</span>()<br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">1000</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">0</span>)<br>        .<span class="hljs-title function_">style</span>(<span class="hljs-string">"opacity"</span>, <span class="hljs-number">0</span>)<br>        .<span class="hljs-title function_">remove</span>();<br><br>    <span class="hljs-comment">// UPDATE: 节点状态更新（比如颜色变化）</span><br>    <span class="hljs-comment">// 可以在这里判断状态，比如 d.status === 'mining'</span><br>    nodes.<span class="hljs-title function_">classed</span>(<span class="hljs-string">"node-updated"</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 添加一个类触发 CSS 闪烁</span><br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">500</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">layer</span> === <span class="hljs-string">'ethereum'</span> ? <span class="hljs-string">"#69b3a2"</span> : <span class="hljs-string">"#ffcc00"</span>);<br><br>    <span class="hljs-comment">// ENTER: 新节点出现</span><br>    <span class="hljs-keyword">const</span> nodesEnter = nodes.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"node"</span>)<br>        .<span class="hljs-title function_">call</span>(d3.<span class="hljs-title function_">drag</span>()<br>            .<span class="hljs-title function_">on</span>(<span class="hljs-string">"start"</span>, dragstarted)<br>            .<span class="hljs-title function_">on</span>(<span class="hljs-string">"drag"</span>, dragged)<br>            .<span class="hljs-title function_">on</span>(<span class="hljs-string">"end"</span>, dragended));<br><br>    nodesEnter.<span class="hljs-title function_">append</span>(<span class="hljs-string">"circle"</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 初始大小为0，产生弹出的效果</span><br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"red"</span>) <span class="hljs-comment">//以此高亮新节点</span><br>        .<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">750</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">layer</span> === <span class="hljs-string">'ethereum'</span> ? <span class="hljs-string">"#69b3a2"</span> : <span class="hljs-string">"#ffcc00"</span>);<br><br>    nodesEnter.<span class="hljs-title function_">append</span>(<span class="hljs-string">"text"</span>)<br>        .<span class="hljs-title function_">text</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">id</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x"</span>, <span class="hljs-number">12</span>)<br>        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y"</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// MERGE: 合并</span><br>    <span class="hljs-keyword">const</span> nodesMerge = nodesEnter.<span class="hljs-title function_">merge</span>(nodes);<br><br>    <span class="hljs-comment">// ================= 重启模拟 =================</span><br>    simulation.<span class="hljs-title function_">nodes</span>(data.<span class="hljs-property">nodes</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">"tick"</span>, ticked);<br>    simulation.<span class="hljs-title function_">force</span>(<span class="hljs-string">"link"</span>).<span class="hljs-title function_">links</span>(data.<span class="hljs-property">edges</span>);<br>    <br>    <span class="hljs-comment">// 关键：温和地重启模拟，而不是完全重置</span><br>    <span class="hljs-comment">// alpha(0.3) 意味着只进行微调，不会导致布局剧烈震荡</span><br>    simulation.<span class="hljs-title function_">alpha</span>(<span class="hljs-number">0.3</span>).<span class="hljs-title function_">restart</span>();<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">ticked</span>(<span class="hljs-params"></span>) {<br>        linksMerge<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x1"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">source</span>.<span class="hljs-property">x</span>)<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y1"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">source</span>.<span class="hljs-property">y</span>)<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x2"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">target</span>.<span class="hljs-property">x</span>)<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y2"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">target</span>.<span class="hljs-property">y</span>);<br><br>        nodesMerge<br>            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"transform"</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-string">`translate(<span class="hljs-subst">${d.x}</span>,<span class="hljs-subst">${d.y}</span>)`</span>);<br>    }<br>}<br><br><span class="hljs-comment">// 拖拽函数（标准 D3 代码，略）</span><br></code></pre></td></tr></table></figure>
<h3 id="4-视觉高亮变化的技巧"><a href="#4-视觉高亮变化的技巧" class="headerlink" title="4. 视觉高亮变化的技巧"></a>4. 视觉高亮变化的技巧</h3><p>为了让用户明显看到“发生了什么变化”，建议配合 CSS 动画：</p>
<p><strong>技巧 A：新节点闪烁</strong><br>当节点 enter() 时，给它设置一个临时的高亮颜色（如亮绿色），然后 transition 回正常颜色。</p>
<p><strong>技巧 B：状态变更光环</strong><br>如果节点还在列表里，但状态变了（例如从 syncing 变成 mining），在 nodes (Update set) 中检测：</p>
<p>codeJavaScript</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs q">nodes.<span class="hljs-built_in">each</span>(function(d) {<br>    <span class="hljs-comment">// d 是新数据，this 是 DOM 元素</span><br>    const oldStatus = d3.<span class="hljs-keyword">select</span>(this).<span class="hljs-built_in">attr</span>(<span class="hljs-string">"data-status"</span>);<br>    if (oldStatus &amp;&amp; oldStatus !== d.status) {<br>        <span class="hljs-comment">// 状态变了！添加一个临时 SVG 圆环扩散动画</span><br>        d3.<span class="hljs-keyword">select</span>(this).append(<span class="hljs-string">"circle"</span>)<br>            .<span class="hljs-built_in">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">10</span>)<br>            .<span class="hljs-built_in">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"ripple"</span>)<br>            .transition().duration(<span class="hljs-number">1000</span>)<br>            .<span class="hljs-built_in">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-number">30</span>)<br>            .style(<span class="hljs-string">"opacity"</span>, <span class="hljs-number">0</span>)<br>            .remove();<br>    }<br>    <span class="hljs-comment">// 更新 DOM 上的状态标记</span><br>    d3.<span class="hljs-keyword">select</span>(this).<span class="hljs-built_in">attr</span>(<span class="hljs-string">"data-status"</span>, d.status);<br>});<br></code></pre></td></tr></table></figure>
<p><strong>技巧 C：固定骨干网（针对 SeedEmu）</strong><br>你的环境中有 AS 路由器（骨干网）和 Host（叶子节点）。</p>
<ul>
<li><p><strong>建议</strong>：在 D3 中，将骨干路由器（r51-r54, AS路由器）的坐标<strong>根据逻辑预设好并固定</strong>（设置 fx, fy）。</p>
</li>
<li><p><strong>效果</strong>：这样即使以太坊节点上线下线，整个网络的“骨架”不会乱跑，只有边缘节点在动，视觉上更清晰，更容易看清变化。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>FastAPI</strong>：使用 WebSocket + Background Task 推送全量快照。</p>
</li>
<li><p><strong>D3.js</strong>：使用 data(dataset, d =&gt; d.id) 绑定 ID。</p>
</li>
<li><p><strong>Diff 逻辑</strong>：</p>
<ul>
<li><p><strong>Enter</strong>: 初始半径为 0 -&gt; 放大，颜色高亮。</p>
</li>
<li><p><strong>Exit</strong>: 透明度变 0 -&gt; 移除。</p>
</li>
<li><p><strong>Update</strong>: 继承旧节点的 x, y 坐标，避免位置重置；利用 transition 表现状态变更。</p>
</li>
<li><p><strong>Simulation</strong>: 使用 alpha(0.3).restart() 进行温和重绘。</p>
</li>
</ul>
</li>
</ol>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/48096.html">← Next 2025-12-15-杂谈-系统问题</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/7900.html">2025-12-06-杂记-前端图拓扑渲染优化 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BC%82%E6%9E%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">复杂异构系统监控与可视化项目设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">问题背景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E8%AF%A5%E7%8E%AF%E5%A2%83%E5%92%8C%E9%9C%80%E6%B1%82%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">2.</span> <span class="toc-text">针对该环境和需求的系统设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">1. 系统架构概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.</span> <span class="toc-text">2. 核心模块设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%B1%82-Models-Schemas"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 数据模型层 (Models&#x2F;Schemas)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1%E5%B1%82-Services"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.3 业务服务层 (Services)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B7%E4%BD%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.</span> <span class="toc-text">3. 具体接口实现策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E7%89%A9%E7%90%86%E5%B1%82-Physical-Layer"><span class="toc-number">2.3.1.</span> <span class="toc-text">A. 物理层 (Physical Layer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%B1%82-Ethereum-Layer"><span class="toc-number">2.3.2.</span> <span class="toc-text">B. 以太坊层 (Ethereum Layer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%BA%A4%E6%98%93%E4%B8%8E%E5%90%88%E7%BA%A6-Transaction-amp-Contract"><span class="toc-number">2.3.3.</span> <span class="toc-text">C. 交易与合约 (Transaction &amp; Contract)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%B8%B2%E6%9F%93-Rendering"><span class="toc-number">2.3.4.</span> <span class="toc-text">D. 可视化渲染 (Rendering)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">4. 代码结构示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.5.</span> <span class="toc-text">5. 关键技术难点与解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.6.</span> <span class="toc-text">6. 总结建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.7.</span> <span class="toc-text">1. 整体架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8E%E7%AB%AF%EF%BC%9AFastAPI-WebSocket-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.8.</span> <span class="toc-text">2. 后端：FastAPI WebSocket 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%8D%E7%AB%AF%EF%BC%9AD3-js-%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E4%B8%8E%E9%AB%98%E4%BA%AE%E9%80%BB%E8%BE%91"><span class="toc-number">2.9.</span> <span class="toc-text">3. 前端：D3.js 实时更新与高亮逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">2.9.1.</span> <span class="toc-text">核心策略：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-HTML-JS"><span class="toc-number">2.9.2.</span> <span class="toc-text">代码实现 (HTML&#x2F;JS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%86%E8%A7%89%E9%AB%98%E4%BA%AE%E5%8F%98%E5%8C%96%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">2.10.</span> <span class="toc-text">4. 视觉高亮变化的技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.11.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>