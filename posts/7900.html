<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-12-06-杂记-前端图拓扑渲染优化 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-12-06-杂记-前端图拓扑渲染优化</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-12-06T03:25:47.000Z" id="date"> 2025-12-06</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-12-14T17:56:13.795Z" id="updated"> 2025-12-15</time></div></span><br><span id="busuanzi_container_page_pv">页面浏览: <span class="control" id="busuanzi_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><ol>
<li><p><strong>性能优化 (Web Workers)</strong>: 目前的数据获取、解析和Diff算法都在<strong>主线程</strong>运行。当拓扑变大时，计算Diff会导致页面卡顿。建议将这部分移至 <strong>Web Worker</strong>。</p>
</li>
<li><p><strong>D3 渲染优化</strong>: 目前的设计倾向于每次更新都全量替换 filteredNodes，这会导致 D3 力导向图重新初始化或位置抖动。应该利用 Diff 结果进行<strong>增量渲染 (Enter/Update/Exit)</strong>。</p>
</li>
<li><p><strong>状态管理解耦</strong>: useTopologyData 承担了太多职责（数据存储、UI状态、标签逻辑）。应该拆分为“数据层”和“视觉层”。</p>
</li>
<li><p><strong>数据结构优化</strong>: 数组查找（.find）效率低，应更多使用 Map/Set 索引。</p>
</li>
</ol>
<h3 id="优化后文件结构"><a href="#优化后文件结构" class="headerlink" title="优化后文件结构"></a>优化后文件结构</h3><p>采用了 <strong>Core (数据核心) + Visual (视觉逻辑) + Worker (后台计算)</strong> 的分层结构。</p>
<p>codeText</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span>/<br>  ├── types/<br>  │   └── topology<span class="hljs-selector-class">.ts</span>           <span class="hljs-comment">// (保持不变) 类型定义</span><br>  ├── workers/<br>  │   └── topology<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [新] 负责Fetch、解析数据、计算Diff</span><br>  ├── composables/<br>  │   ├── useTopologyCore<span class="hljs-selector-class">.ts</span>    <span class="hljs-comment">// [优化] 负责与Worker通信，持有原始数据</span><br>  │   ├── useTopologyVisual<span class="hljs-selector-class">.ts</span>  <span class="hljs-comment">// [拆分] 负责过滤、标签、高亮等UI逻辑</span><br>  │   └── useD3Renderer<span class="hljs-selector-class">.ts</span>      <span class="hljs-comment">// [新] 封装D3的具体操作，接受Diff指令</span><br>  └── components/<br>      └── EthereumTopology<span class="hljs-selector-class">.vue</span>  <span class="hljs-comment">// [优化] 变得很薄，只负责组装</span><br></code></pre></td></tr></table></figure>
<p>现在的以太坊拓扑渲染架构采用了 <strong>“分层响应式架构” (Layered Reactive Architecture)</strong>，结合了 <strong>Web Worker 多线程计算</strong> 和 <strong>D3 增量渲染</strong> 技术。</p>
<p>这是一种高性能、低耦合的现代前端架构，专门为了处理大量节点（数千级）的实时动态拓扑而设计。</p>
<p>以下是该架构的详细层级解析：</p>
<h3 id="1-架构总览图"><a href="#1-架构总览图" class="headerlink" title="1. 架构总览图"></a>1. 架构总览图</h3><p>数据流向是单向的，状态管理是响应式的：</p>
<p>codeMermaid</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">graph TD<br>    BackEnd[FastAPI 后端] --&gt;|<span class="hljs-type">JSON</span> Stream| <span class="hljs-type">Worker</span>[Web Worker (后台线程)]<br>    <br>    subgraph <span class="hljs-string">"Main Thread (主线程)"</span><br>        Worker --&gt;|<span class="hljs-type">Diff</span> Update (增量/全量)| <span class="hljs-type">Store</span>[useTopologyCore (数据层)]<br>        Store --&gt;|<span class="hljs-type">Raw</span> Data| <span class="hljs-type">Visual</span>[useTopologyVisual (视觉层)]<br>        <br>        subgraph <span class="hljs-string">"UI Components (视图层)"</span><br>            Visual --&gt;|<span class="hljs-type">Filtered</span> Data| <span class="hljs-type">Renderer</span>[useD3Renderer (渲染层)]<br>            Visual --&gt;|<span class="hljs-type">Filters</span>/<span class="hljs-keyword">Mode</span>| <span class="hljs-type">Controls</span>[TopologyVisualization (控制面板)]<br>            Renderer --&gt;|<span class="hljs-type">Click</span> Event| <span class="hljs-type">Details</span>[PhysicalTopology (详情抽屉)]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br>    Renderer --&gt;|<span class="hljs-type">Draw</span>| <span class="hljs-type">DOM</span>[SVG/Canvas]<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="2-核心层级详细解析"><a href="#2-核心层级详细解析" class="headerlink" title="2. 核心层级详细解析"></a>2. 核心层级详细解析</h3><h4 id="第一层：数据处理层-Worker-Thread"><a href="#第一层：数据处理层-Worker-Thread" class="headerlink" title="第一层：数据处理层 (Worker Thread)"></a>第一层：数据处理层 (Worker Thread)</h4><p><strong>文件</strong>: workers/topology.worker.ts<br>这是架构的“发动机”，完全脱离主线程运行。</p>
<ul>
<li><p><strong>职责</strong>：</p>
<ol>
<li><p><strong>数据拉取</strong>：直接发起 Fetch 请求，不占用主线程网络资源。</p>
</li>
<li><p><strong>数据清洗</strong>：解析复杂的 JSON 结构，标准化为 TopologyNode 和 TopologyLink。</p>
</li>
<li><p><strong>智能 Diff (差异计算)</strong>：</p>
<ul>
<li><p>这是性能优化的关键。它对比新旧数据，计算出新增、删除和更新的节点。</p>
</li>
<li><p><strong>坐标继承</strong>：在 Worker 中将旧节点的 x, y 坐标赋值给新节点，防止 D3 在数据更新时重新计算布局导致视图“爆炸”或闪烁。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="第二层：状态管理层-Composables"><a href="#第二层：状态管理层-Composables" class="headerlink" title="第二层：状态管理层 (Composables)"></a>第二层：状态管理层 (Composables)</h4><p>这一层利用 Vue 3 的 Composition API 将业务逻辑拆分为独立的模块。</p>
<ul>
<li><p><strong>数据持有 (useTopologyCore.ts)</strong>：</p>
<ul>
<li><p>与 Worker 通信的桥梁。</p>
</li>
<li><p>使用 shallowRef 存储庞大的拓扑数据。<strong>优化点</strong>：shallowRef 不会深度监听节点内部属性的变化（如 x, y 坐标），这极大减轻了 Vue 响应式系统的负担，因为 D3 会直接操作这些原生对象。</p>
</li>
</ul>
</li>
<li><p><strong>视觉逻辑 (useTopologyVisual.ts)</strong>：</p>
<ul>
<li><p><strong>纯粹的计算层</strong>。它不关心数据怎么来的，只关心怎么显示。</p>
</li>
<li><p><strong>动态过滤</strong>：利用 computed 属性，根据 filters（如隐藏共识节点）实时生成 filteredNodes。</p>
</li>
<li><p><strong>样式映射</strong>：集中管理颜色 (getNodeColor) 和标签 (getNodeLabel) 逻辑，实现逻辑与渲染分离。</p>
</li>
</ul>
</li>
</ul>
<h4 id="第三层：渲染驱动层-Render-Engine"><a href="#第三层：渲染驱动层-Render-Engine" class="headerlink" title="第三层：渲染驱动层 (Render Engine)"></a>第三层：渲染驱动层 (Render Engine)</h4><p><strong>文件</strong>: useD3Renderer.ts<br>这是 D3.js 与 Vue 的结合点。</p>
<ul>
<li><p><strong>生命周期接管</strong>：它在 onMounted 时初始化 D3 仿真器。</p>
</li>
<li><p><strong>增量渲染 (Incremental Rendering)</strong>：</p>
<ul>
<li><p>使用 Vue 的 watch 监听过滤后的数据。</p>
</li>
<li><p>利用 D3 的 enter(), update(), exit() 模式。</p>
</li>
<li><p><strong>Enter</strong>: 新节点淡入。</p>
</li>
<li><p><strong>Exit</strong>: 被过滤或删除的节点淡出移除。</p>
</li>
<li><p><strong>Update</strong>: 现有节点平滑移动到新位置。</p>
</li>
</ul>
</li>
<li><p><strong>事件桥接</strong>：将 D3 的 click、drag 事件转换为 Vue 的回调函数，传递给上层组件。</p>
</li>
</ul>
<h4 id="第四层：视图组装层-View-Integration"><a href="#第四层：视图组装层-View-Integration" class="headerlink" title="第四层：视图组装层 (View Integration)"></a>第四层：视图组装层 (View Integration)</h4><p><strong>文件</strong>: EthereumTopology.vue (父组件)<br>这是架构的“容器”和“胶水”。</p>
<ul>
<li><p><strong>依赖注入 (Dependency Injection)</strong>：</p>
<ul>
<li><p>父组件通过 provide(‘topology-state’, …) 将 mode、filters 等状态下发。</p>
</li>
<li><p>子组件 TopologyVisualization 通过 inject 直接获取并修改这些状态。避免了深层 Prop 传递（Prop Drilling）。</p>
</li>
</ul>
</li>
<li><p><strong>组件编排</strong>：</p>
<ul>
<li><p>负责布局：左上角悬浮控制面板、中间 D3 画布、右侧详情抽屉。</p>
</li>
<li><p>负责联动：当 D3 点击节点时，控制 showPhysicalDetails 变量来弹出侧边栏。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-关键性能优化点总结"><a href="#3-关键性能优化点总结" class="headerlink" title="3. 关键性能优化点总结"></a>3. 关键性能优化点总结</h3><ol>
<li><p><strong>非阻塞主线程 (Off-Main-Thread)</strong>:</p>
<ul>
<li><p><strong>旧架构</strong>：在组件内 fetch 数据 -&gt; 解析 -&gt; 赋值。数据量大时 UI 会卡顿。</p>
</li>
<li><p><strong>新架构</strong>：所有数据处理都在 Worker 中完成，主线程只负责接收“准备好渲染”的数据。</p>
</li>
</ul>
</li>
<li><p><strong>浅层响应式 (Shallow Reactivity)</strong>:</p>
<ul>
<li>使用 shallowRef 代替 ref 存储节点数组。D3 内部高频修改 node.x 和 node.y 时，不会触发 Vue 的依赖更新系统，显著提升动画帧率。</li>
</ul>
</li>
<li><p><strong>状态保持 (State Preservation)</strong>:</p>
<ul>
<li>Worker 在处理新数据时，会查找旧数据的 ID，并将 x, y, vx, vy (速度向量) 复制给新数据。这保证了在轮询更新时，节点不会重置位置，实现了“流式”的平滑更新效果。</li>
</ul>
</li>
<li><p><strong>按需计算 (Computed Filtering)</strong>:</p>
<ul>
<li>连接 (links) 的过滤依赖于节点 (nodes) 的过滤结果。新架构使用了 Set 来建立索引，将连接过滤的时间复杂度从 O(N*M) 降低到 O(M)（其中 N 是节点数，M 是连接数）。</li>
</ul>
</li>
</ol>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>现在的架构是一个 <strong>“重后台、轻前台、数据驱动视图”</strong> 的专业可视化架构。</p>
<ul>
<li><p><strong>Worker</strong> 负责“脏活累活”（数据处理）。</p>
</li>
<li><p><strong>D3</strong> 负责“精细活”（物理仿真和绘图）。</p>
</li>
<li><p><strong>Vue</strong> 负责“指挥”（状态管理和组件通信）。</p>
</li>
</ul>
<p>这种架构非常适合需要长时间运行、实时监控网络状态的生产级系统。</p>
<hr>
<p>根据提供的代码（EthereumTopologyHandler 和 RealTopologyService），以太坊网络拓扑的处理流程是一个<strong>分层获取、数据融合、格式化输出</strong>的过程。核心逻辑依赖于 <strong>Neo4j 图数据库</strong>（存储P2P关系）和 <strong>Docker 守护进程</strong>（提供容器运行时信息）。</p>
<p>以下是详细的处理步骤解析：</p>
<h3 id="1-数据源获取-Data-Acquisition"><a href="#1-数据源获取-Data-Acquisition" class="headerlink" title="1. 数据源获取 (Data Acquisition)"></a>1. 数据源获取 (Data Acquisition)</h3><p>系统主要通过两个渠道获取数据：</p>
<ul>
<li><p><strong>Neo4j 数据库 (核心数据源)</strong>：存储了爬虫或客户端上报的节点发现数据，包含节点ID、IP、以及节点间的 P2P 连接关系。</p>
</li>
<li><p><strong>Docker Client (辅助数据源)</strong>：用于获取运行中容器的实时状态、名称映射和网络设置。</p>
</li>
</ul>
<h3 id="2-核心处理流程"><a href="#2-核心处理流程" class="headerlink" title="2. 核心处理流程"></a>2. 核心处理流程</h3><p>整个拓扑生成的逻辑主要集中在 _get_real_topology_from_neo4j 和 _convert_topology_format 方法中。</p>
<h4 id="步骤-A：从-Neo4j-提取原始拓扑结构"><a href="#步骤-A：从-Neo4j-提取原始拓扑结构" class="headerlink" title="步骤 A：从 Neo4j 提取原始拓扑结构"></a>步骤 A：从 Neo4j 提取原始拓扑结构</h4><p>代码通过 Cypher 查询语句分三步提取数据：</p>
<ol>
<li><p><strong>查询执行层 (Execution Layer)</strong>：</p>
<ul>
<li><p>查找所有 ExecNode 标签的节点。</p>
</li>
<li><p>查找 EXEC_PEERS_WITH 关系，获取该节点的对等节点（Peers）。</p>
</li>
</ul>
</li>
<li><p><strong>查询共识层 (Consensus Layer)</strong>：</p>
<ul>
<li><p>查找所有 ConsNode 标签的节点。</p>
</li>
<li><p>查找 CONS_PEERS_WITH 关系。</p>
</li>
</ul>
</li>
<li><p><strong>查询验证者 (Validators)</strong>：</p>
<ul>
<li><p>查找与共识节点通过 MANAGES_VALIDATOR 关系连接的 Validator 节点。</p>
</li>
<li><p>这反映了哪个信标节点（Beacon Node）管理着哪些验证者客户端。</p>
</li>
</ul>
</li>
</ol>
<h4 id="步骤-B：容器身份映射-Container-Mapping"><a href="#步骤-B：容器身份映射-Container-Mapping" class="headerlink" title="步骤 B：容器身份映射 (Container Mapping)"></a>步骤 B：容器身份映射 (Container Mapping)</h4><ul>
<li><p><strong>目的</strong>：数据库中只有 IP 地址，但在前端展示时，最好能显示具体的 Docker 容器名称（如 geth-node-1）。</p>
</li>
<li><p><strong>实现</strong>：_create_ip_to_container_mapping 方法遍历所有 Docker 容器，提取其网络设置中的 IP 地址，建立 IP -&gt; ContainerName 的映射表。</p>
</li>
</ul>
<h4 id="步骤-C：构建拓扑对象-Topology-Construction"><a href="#步骤-C：构建拓扑对象-Topology-Construction" class="headerlink" title="步骤 C：构建拓扑对象 (Topology Construction)"></a>步骤 C：构建拓扑对象 (Topology Construction)</h4><p>系统将原始数据转换为前端可视化的 JSON 格式，包含 nodes 和 links。</p>
<p><strong>1. 节点生成 (Nodes):</strong><br>代码根据逻辑自动计算节点的坐标 (x, y) 以便可视化布局：</p>
<ul>
<li><p><strong>执行层节点</strong>：</p>
<ul>
<li><p>type: execution</p>
</li>
<li><p>位置：固定在 Y=150 的水平线上。</p>
</li>
</ul>
</li>
<li><p><strong>共识层节点</strong>：</p>
<ul>
<li><p>type: consensus</p>
</li>
<li><p>位置：固定在 Y=350 的水平线上（位于执行层下方）。</p>
</li>
</ul>
</li>
<li><p><strong>验证者节点</strong>：</p>
<ul>
<li><p>type: validator</p>
</li>
<li><p>位置：簇拥在所属共识节点的下方 (y + 60)，通过计算偏移量排成小方阵。</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. 连接生成 (Links):</strong><br>系统构建了四种类型的连接：</p>
<ul>
<li><p><strong>执行层 P2P (exec_peer)</strong>：基于 Neo4j 中的 EXEC_PEERS_WITH 关系，表示 Geth/Nethermind 节点间的 Gossip 协议连接。</p>
</li>
<li><p><strong>共识层 P2P (cons_peer)</strong>：基于 CONS_PEERS_WITH 关系，表示 Lighthouse/Prysm 节点间的连接。</p>
</li>
<li><p><strong>管理关系 (manages_validator)</strong>：连接共识节点和它管理的验证者节点。</p>
</li>
<li><p><strong>跨层连接 (cross_layer)</strong>：<strong>关键逻辑</strong>。代码会自动匹配 IP 地址相同的执行层节点和共识层节点，并创建一个垂直连接。这代表了以太坊客户端组合（Engine API 通信，例如 Geth &lt;-&gt; Lighthouse 在同一台机器/Pod内）。</p>
</li>
</ul>
<h3 id="3-容错与缓存机制"><a href="#3-容错与缓存机制" class="headerlink" title="3. 容错与缓存机制"></a>3. 容错与缓存机制</h3><p>为了保证性能和稳定性，代码中包含了以下机制：</p>
<ul>
<li><p><strong>缓存 (Caching)</strong>：</p>
<ul>
<li><p>使用 self.cache 存储计算好的拓扑。</p>
</li>
<li><p>设置 cache_ttl (20-30秒)，防止频繁查询 Neo4j 导致数据库过载。</p>
</li>
</ul>
</li>
<li><p><strong>降级模式 (Fallback - 仅在 Service 中)</strong>：</p>
<ul>
<li><p>如果 Neo4j 连接失败或返回空数据，RealTopologyService 会调用 _get_container_based_topology。</p>
</li>
<li><p><strong>Fallback 逻辑</strong>：直接扫描 Docker 容器，如果发现名为 ethereum 的容器，就根据容器数量“伪造”一个链式的拓扑结构（非网状），以确保界面上至少能看到节点存在，而不是一片空白。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-统计与验证-Statistics-amp-Validation"><a href="#4-统计与验证-Statistics-amp-Validation" class="headerlink" title="4. 统计与验证 (Statistics & Validation)"></a>4. 统计与验证 (Statistics &amp; Validation)</h3><p>EthereumTopologyHandler 还提供了额外的高级功能：</p>
<ul>
<li><p><strong>独立查询</strong>：get_nodes 和 get_links 可以不依赖完整拓扑逻辑，直接查询特定层的数据，提高效率。</p>
</li>
<li><p><strong>拓扑验证</strong>：validate_topology 检查数据一致性：</p>
<ul>
<li><p>节点 ID 是否唯一。</p>
</li>
<li><p>连接的源/目标节点是否存在。</p>
</li>
<li><p>是否存在孤立节点。</p>
</li>
<li><p>IP 地址分布是否异常（例如一个 IP 运行了超过2个主要节点）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该系统处理以太坊拓扑的核心思想是：<strong>“数据库定义逻辑关系，Docker 定义物理属性，代码负责视觉组装”</strong>。</p>
<ol>
<li><p><strong>逻辑层</strong>：谁连谁？由 Neo4j 决定。</p>
</li>
<li><p><strong>物理层</strong>：你是谁？由 Docker IP 映射决定。</p>
</li>
<li><p><strong>视觉层</strong>：你在哪？由代码中的分层坐标计算逻辑决定（执行层在上，共识层在中，验证者在下）。</p>
</li>
</ol>
<hr>
<p>目前的实现逻辑虽然功能完整，但在性能上存在几个显著的<strong>瓶颈</strong>，特别是在节点数量增多或 Docker 容器较多时，响应速度会明显下降。</p>
<p>以下是针对代码的具体性能优化方案，按<strong>提升幅度从大到小</strong>排序：</p>
<h3 id="1-痛点分析：目前的性能瓶颈在哪里？"><a href="#1-痛点分析：目前的性能瓶颈在哪里？" class="headerlink" title="1. 痛点分析：目前的性能瓶颈在哪里？"></a>1. 痛点分析：目前的性能瓶颈在哪里？</h3><ol>
<li><p><strong>Docker API 调用过于频繁 (主要瓶颈)</strong>：</p>
<ul>
<li><p>_create_ip_to_container_mapping 每次生成拓扑都会被调用。它会遍历<strong>所有</strong>容器并检查网络设置。Docker API 的响应通常是毫秒级到秒级的，如果不缓存，这会严重阻塞主线程。</p>
</li>
<li><p>在物理拓扑中，_get_link_bandwidth 会对每个连接进入容器执行 tc 命令。如果有 50 个连接，就要串行执行 50 次 docker exec，这是极慢的 IO 操作。</p>
</li>
</ul>
</li>
<li><p><strong>串行数据库查询</strong>：</p>
<ul>
<li>在 _get_real_topology_from_neo4j 中，执行层查询及处理完之后，才开始共识层的查询。这两者没有依赖关系，完全可以并行。</li>
</ul>
</li>
<li><p><strong>计算密集型的重复操作</strong>：</p>
<ul>
<li>每次请求都重新计算所有节点的坐标和映射关系，即使数据没有变化。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-优化方案一：Docker-数据的独立缓存与后台更新"><a href="#2-优化方案一：Docker-数据的独立缓存与后台更新" class="headerlink" title="2. 优化方案一：Docker 数据的独立缓存与后台更新"></a>2. 优化方案一：Docker 数据的独立缓存与后台更新</h3><p>Docker 的元数据（IP、容器名）变化频率远低于 P2P 网络连接的变化频率。<strong>不要在每次请求拓扑时都去查询 Docker。</strong></p>
<p><strong>优化策略：</strong> 使用“读写分离”的策略，后台任务更新 Docker 映射，前台请求只读内存变量。</p>
<p>codePython</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 原有初始化 ...</span><br>        <span class="hljs-variable language_">self</span>.ip_container_map_cache = {}<br>        <span class="hljs-variable language_">self</span>.map_last_update = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.map_update_lock = asyncio.Lock()<br>        <br>        <span class="hljs-comment"># 启动时预热</span><br>        <span class="hljs-comment"># 注意：实际代码中建议使用 apscheduler 或 asyncio.create_task 在后台循环运行</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_ip_to_container_map_optimized</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化后的获取映射方法：</span><br><span class="hljs-string">        1. 优先返回内存缓存</span><br><span class="hljs-string">        2. 缓存过期（如5分钟）才异步更新</span><br><span class="hljs-string">        """</span><br>        current_time = time.time()<br>        <span class="hljs-comment"># 缓存有效期设为 300秒 (Docker容器IP不会频繁变动)</span><br>        <span class="hljs-keyword">if</span> current_time - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br><br>        <span class="hljs-comment"># 如果需要更新，且未被锁定</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.map_update_lock.locked():<br>             <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.map_update_lock:<br>                 <span class="hljs-comment"># 二次检查</span><br>                 <span class="hljs-keyword">if</span> time.time() - <span class="hljs-variable language_">self</span>.map_last_update &lt; <span class="hljs-number">300</span>: <br>                     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br>                 <br>                 <span class="hljs-comment"># 执行耗时的 Docker 查询</span><br>                 <span class="hljs-comment"># 建议：在一个线程池中运行同步的 docker client 操作，避免阻塞事件循环</span><br>                 loop = asyncio.get_running_loop()<br>                 <span class="hljs-variable language_">self</span>.ip_container_map_cache = <span class="hljs-keyword">await</span> loop.run_in_executor(<br>                     <span class="hljs-literal">None</span>, <span class="hljs-variable language_">self</span>._create_ip_to_container_mapping<br>                 )<br>                 <span class="hljs-variable language_">self</span>.map_last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ip_container_map_cache<br></code></pre></td></tr></table></figure>
<h3 id="3-优化方案二：物理拓扑带宽检测的“非阻塞化”"><a href="#3-优化方案二：物理拓扑带宽检测的“非阻塞化”" class="headerlink" title="3. 优化方案二：物理拓扑带宽检测的“非阻塞化”"></a>3. 优化方案二：物理拓扑带宽检测的“非阻塞化”</h3><p>在 RealTopologyService 中，物理连接的带宽检测（tc 命令）是极其耗时的。绝对不能在用户请求 API 时实时去跑 tc 命令。</p>
<p><strong>优化策略：</strong> 将带宽数据设为“最终一致性”。主接口只返回拓扑结构，带宽字段先返回缓存值或 “Checking…”，后台任务专门负责轮询更新带宽。</p>
<p>codePython</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealTopologyService</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-variable language_">self</span>.bandwidth_cache = {} <span class="hljs-comment"># Key: "container_ip", Value: "100Mbit"</span><br>        <br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_dynamic_physical_topology_from_containers</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ... 前面生成 nodes 和 links 的逻辑保持不变 ...</span><br>        <br>        <span class="hljs-comment"># --- 优化点：移除实时 await _get_link_bandwidth ---</span><br>        <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>            target_id = link[<span class="hljs-string">'target'</span>]<br>            target_node = nodes_by_id[target_id]<br>            container_name = target_node[<span class="hljs-string">'container_name'</span>]<br>            link_ip = target_node[<span class="hljs-string">'networks'</span>].get(link[<span class="hljs-string">'shared_network'</span>])<br>            <br>            <span class="hljs-comment"># 1. 尝试从缓存获取</span><br>            cache_key = <span class="hljs-string">f"<span class="hljs-subst">{container_name}</span>::<span class="hljs-subst">{link_ip}</span>"</span><br>            cached_bw = <span class="hljs-variable language_">self</span>.bandwidth_cache.get(cache_key)<br>            <br>            <span class="hljs-keyword">if</span> cached_bw:<br>                link[<span class="hljs-string">'bandwidth'</span>] = cached_bw<br>            <span class="hljs-keyword">else</span>:<br>                link[<span class="hljs-string">'bandwidth'</span>] = <span class="hljs-string">"Querying..."</span><br>                <span class="hljs-comment"># 2. 触发后台更新任务 (Fire and Forget)</span><br>                asyncio.create_task(<span class="hljs-variable language_">self</span>._update_bandwidth_cache(container_name, link_ip, cache_key))<br>                <br>        <span class="hljs-keyword">return</span> nodes, links<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bandwidth_cache</span>(<span class="hljs-params">self, container_name, link_ip, cache_key</span>):<br>        <span class="hljs-string">"""后台单独更新带宽"""</span><br>        bw = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>._get_link_bandwidth(container_name, link_ip)<br>        <span class="hljs-variable language_">self</span>.bandwidth_cache[cache_key] = bw<br></code></pre></td></tr></table></figure>
<h3 id="4-优化方案三：Neo4j-并发查询"><a href="#4-优化方案三：Neo4j-并发查询" class="headerlink" title="4. 优化方案三：Neo4j 并发查询"></a>4. 优化方案三：Neo4j 并发查询</h3><p>Neo4j 的 Python Driver (尤其是 Bolt 协议) 支持并发。执行层和共识层的查询是独立的，可以使用 asyncio.gather 同时发起查询。</p>
<p><strong>注意</strong>：这需要你的 database_manager 支持异步操作。如果底层是同步驱动，可以用 run_in_executor 包装。</p>
<p>codePython</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 EthereumTopologyHandler 中</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_real_topology_from_neo4j</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">Dict</span>, <span class="hljs-type">Dict</span>]:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># ... 连接检查 ...</span><br><br>            <span class="hljs-comment"># 定义查询函数</span><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_exec</span>():<br>                <span class="hljs-comment"># 这里假设 database_manager 提供了某种异步执行方式，</span><br>                <span class="hljs-comment"># 或者我们将同步的 session.run 放入线程池</span><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        result = session.run(<span class="hljs-string">"MATCH (n:ExecNode)..."</span>) <span class="hljs-comment"># 填入完整的 Cypher</span><br>                        <span class="hljs-keyword">return</span> {r[<span class="hljs-string">'node_id'</span>]: ... <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result} <span class="hljs-comment"># 处理结果</span><br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_cons_and_validators</span>():<br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_query</span>():<br>                    <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.database_manager.neo4j.session() <span class="hljs-keyword">as</span> session:<br>                        <span class="hljs-comment"># 合并共识节点和验证者的查询逻辑，减少一次 session 创建开销</span><br>                        cons_result = session.run(<span class="hljs-string">"MATCH (n:ConsNode)..."</span>) <br>                        <span class="hljs-comment"># ... 处理共识 ...</span><br>                        validator_result = session.run(<span class="hljs-string">"MATCH ... validators ..."</span>)<br>                        <span class="hljs-comment"># ... 处理验证者 ...</span><br>                        <span class="hljs-keyword">return</span> cons_data<br>                <br>                loop = asyncio.get_running_loop()<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loop.run_in_executor(<span class="hljs-literal">None</span>, run_query)<br><br>            <span class="hljs-comment"># 并发执行</span><br>            exec_nodes_data, cons_nodes_data = <span class="hljs-keyword">await</span> asyncio.gather(<br>                fetch_exec(), <br>                fetch_cons_and_validators()<br>            )<br><br>            <span class="hljs-keyword">return</span> exec_nodes_data, cons_nodes_data<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># ... Error handling</span><br></code></pre></td></tr></table></figure>
<h3 id="5-优化方案四：Cypher-查询语句优化"><a href="#5-优化方案四：Cypher-查询语句优化" class="headerlink" title="5. 优化方案四：Cypher 查询语句优化"></a>5. 优化方案四：Cypher 查询语句优化</h3><p>目前的 Cypher 使用了 OPTIONAL MATCH 和 collect，这在数据量大时比较慢。</p>
<p><strong>原查询：</strong></p>
<p>codeCypher</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">MATCH (n:ExecNode)<br>OPTIONAL MATCH (n)-<span class="hljs-selector-attr">[r:EXEC_PEERS_WITH]</span>-&gt;(p:ExecNode)<br>RETURN ... <span class="hljs-built_in">collect</span>(...)<br></code></pre></td></tr></table></figure>
<p>如果在节点很多的情况下，这个查询会扫描整个图。</p>
<p><strong>优化建议：</strong></p>
<ol>
<li><p><strong>分批次</strong>：如果节点超过 1000 个，不要一次性 collect 所有 Peers。前端通常不需要展示所有几千条连线（会卡死浏览器）。可以限制返回的 Peer 数量，例如 LIMIT 10。</p>
</li>
<li><p><strong>索引</strong>：确保 node_id, ip 在 Neo4j 中建立了索引 (CREATE INDEX ON :ExecNode(node_id)).</p>
</li>
<li><p><strong>只查 ID</strong>：先查出所有 Node 的基础信息，再查 Relation 表（Links），在内存中组装，通常比 Graph DB 做复杂的聚合（Map/Collect）要快。</p>
</li>
</ol>
<h3 id="6-综合改进后的代码结构建议"><a href="#6-综合改进后的代码结构建议" class="headerlink" title="6. 综合改进后的代码结构建议"></a>6. 综合改进后的代码结构建议</h3><p>这里给出一个集成优化思路的 EthereumTopologyHandler 核心方法重构示例：</p>
<p>codePython</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EthereumTopologyHandler</span>(<span class="hljs-title class_ inherited__">TopologyProvider</span>):<br>    <span class="hljs-comment"># ... init ...</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_topology</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        <span class="hljs-string">"""获取完整的以太坊拓扑 (优化版)"""</span><br>        <span class="hljs-comment"># 1. 检查拓扑缓存 (Short TTL: e.g., 5s)</span><br>        <span class="hljs-comment"># 拓扑结构变化很快，缓存时间短一点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._is_cache_valid(<span class="hljs-string">"full_ethereum_topology"</span>, ttl=<span class="hljs-number">5</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>]<br><br>        <span class="hljs-comment"># 2. 并行获取数据</span><br>        <span class="hljs-comment"># A. 获取 Docker 映射 (从长效缓存或后台任务获取，极快)</span><br>        <span class="hljs-comment"># B. 获取 Neo4j 数据 (并发查询)</span><br>        <br>        task_docker = <span class="hljs-variable language_">self</span>._get_ip_to_container_map_optimized() <span class="hljs-comment"># 优化点1</span><br>        task_neo4j = <span class="hljs-variable language_">self</span>._get_real_topology_from_neo4j()       <span class="hljs-comment"># 优化点3 (并发内部实现)</span><br>        <br>        ip_map, (exec_data, cons_data) = <span class="hljs-keyword">await</span> asyncio.gather(task_docker, task_neo4j)<br><br>        <span class="hljs-comment"># 3. 转换数据 (CPU 密集型)</span><br>        <span class="hljs-comment"># 如果节点数非常多 (&gt;5000)，可以考虑放入 ProcessPoolExecutor</span><br>        nodes, links = <span class="hljs-variable language_">self</span>._convert_topology_format_optimized(exec_data, cons_data, ip_map)<br><br>        topology_data = {<br>            <span class="hljs-string">'nodes'</span>: nodes, <span class="hljs-string">'links'</span>: links, <span class="hljs-string">'timestamp'</span>: time.time(),<br>            <span class="hljs-comment"># ...</span><br>        }<br><br>        <span class="hljs-comment"># 更新缓存</span><br>        <span class="hljs-variable language_">self</span>.cache[<span class="hljs-string">"full_ethereum_topology"</span>] = topology_data<br>        <span class="hljs-variable language_">self</span>.last_update = time.time()<br>        <br>        <span class="hljs-keyword">return</span> topology_data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_convert_topology_format_optimized</span>(<span class="hljs-params">self, exec_data, cons_data, ip_map</span>):<br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        优化点：</span><br><span class="hljs-string">        1. 使用 ip_map.get 避免重复循环</span><br><span class="hljs-string">        2. 预计算 positions 字典，避免列表遍历查找</span><br><span class="hljs-string">        """</span><br>        nodes = []<br>        links = []<br>        <span class="hljs-comment"># 使用字典加速查找: key=node_id, value={idx, type, ...}</span><br>        node_lookup = {} <br>        <br>        <span class="hljs-comment"># ... 处理 Exec 节点 ...</span><br>        <span class="hljs-keyword">for</span> i, (nid, data) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exec_data.items()):<br>            <span class="hljs-comment"># 直接查预热好的 Map，O(1)</span><br>            container = ip_map.get(data[<span class="hljs-string">'ip'</span>], <span class="hljs-string">f"exec-<span class="hljs-subst">{data[<span class="hljs-string">'ip'</span>]}</span>"</span>)<br>            <span class="hljs-comment"># ... 创建 node ...</span><br>            node_lookup[nid] = {<span class="hljs-string">'type'</span>: <span class="hljs-string">'execution'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-string">f'<span class="hljs-subst">{nid}</span>-exec'</span>}<br>            <br>        <span class="hljs-comment"># ... 处理 Cons 节点 ...</span><br>        <br>        <span class="hljs-comment"># ... 处理连接 ...</span><br>        <span class="hljs-comment"># 只需要遍历一次 exec_data 的 peers，利用 node_lookup 快速验证</span><br>        <span class="hljs-keyword">for</span> nid, data <span class="hljs-keyword">in</span> exec_data.items():<br>             source_full_id = <span class="hljs-string">f"<span class="hljs-subst">{nid}</span>-exec"</span><br>             <span class="hljs-keyword">for</span> peer <span class="hljs-keyword">in</span> data.get(<span class="hljs-string">'peers'</span>, []):<br>                 target_nid = peer[<span class="hljs-string">'peer_id'</span>]<br>                 <span class="hljs-comment"># O(1) 检查目标是否存在</span><br>                 <span class="hljs-keyword">if</span> target_nid <span class="hljs-keyword">in</span> node_lookup <span class="hljs-keyword">and</span> node_lookup[target_nid][<span class="hljs-string">'type'</span>] == <span class="hljs-string">'execution'</span>:<br>                     links.append({<br>                         <span class="hljs-string">'source'</span>: source_full_id,<br>                         <span class="hljs-string">'target'</span>: <span class="hljs-string">f"<span class="hljs-subst">{target_nid}</span>-exec"</span>,<br>                         <span class="hljs-comment"># ...</span><br>                     })<br>                     <br>        <span class="hljs-keyword">return</span> nodes, links<br></code></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>要进行性能优化，最关键的修改是：</p>
<ol>
<li><p><strong>Docker 映射</strong>：改为后台定时更新或长缓存，不要每秒都去 inspect 容器。</p>
</li>
<li><p><strong>物理带宽 (tc)</strong>：改为异步/后台获取，不要阻塞 API 响应。</p>
</li>
<li><p><strong>Neo4j</strong>：使用并发查询，并限制 Cypher 复杂度。</p>
</li>
</ol>
<hr>
<h2 id="攻击方式（Attack-Strategies）"><a href="#攻击方式（Attack-Strategies）" class="headerlink" title="攻击方式（Attack Strategies）"></a>攻击方式（Attack Strategies）</h2><p>系统目前支持以下6种攻击方式：</p>
<h3 id="1-节点断网攻击（Node-Disconnection-Attack）"><a href="#1-节点断网攻击（Node-Disconnection-Attack）" class="headerlink" title="1. 节点断网攻击（Node Disconnection Attack）"></a>1. 节点断网攻击（Node Disconnection Attack）</h3><p>通过网络隔离手段切断目标节点与其他节点的连接。支持的方法包括：</p>
<ul>
<li><code>interface_down</code>: 禁用网络接口</li>
<li><code>route_flush</code>: 清除路由表</li>
<li><code>firewall_block</code>: 防火墙阻断</li>
<li><code>p2p_block</code>: P2P连接阻断</li>
</ul>
<h3 id="2-通信干扰攻击（Communication-Interference-Attack）"><a href="#2-通信干扰攻击（Communication-Interference-Attack）" class="headerlink" title="2. 通信干扰攻击（Communication Interference Attack）"></a>2. 通信干扰攻击（Communication Interference Attack）</h3><p>通过大量无效通信干扰目标节点正常通信。支持的方法包括：</p>
<ul>
<li><code>json_rpc_flood</code>: JSON-RPC请求泛洪</li>
<li><code>p2p_flood</code>: P2P消息泛洪</li>
<li><code>memory_exhaustion</code>: 内存耗尽攻击</li>
</ul>
<h3 id="3-时间攻击（Timestamp-Attack）"><a href="#3-时间攻击（Timestamp-Attack）" class="headerlink" title="3. 时间攻击（Timestamp Attack）"></a>3. 时间攻击（Timestamp Attack）</h3><p>针对共识机制的时间同步进行攻击。支持的方法包括：</p>
<ul>
<li>time_shift: 时间偏移</li>
<li><code>ntp_block</code>: 阻断NTP时间同步</li>
<li><code>time_drift</code>: 时间漂移</li>
</ul>
<h3 id="4-简化Sybil攻击（Simplified-Sybil-Attack）"><a href="#4-简化Sybil攻击（Simplified-Sybil-Attack）" class="headerlink" title="4. 简化Sybil攻击（Simplified Sybil Attack）"></a>4. 简化Sybil攻击（Simplified Sybil Attack）</h3><p>创建虚假节点来影响网络。可以配置：</p>
<ul>
<li>虚假节点数量（1-20）</li>
<li>节点类型（轻节点、全节点、验证者节点）</li>
<li>网络环境（主网、测试网、开发网）</li>
<li>连接真实节点选项</li>
</ul>
<h3 id="5-存储攻击（Storage-Attack）"><a href="#5-存储攻击（Storage-Attack）" class="headerlink" title="5. 存储攻击（Storage Attack）"></a>5. 存储攻击（Storage Attack）</h3><p>针对节点存储系统的攻击。支持的方法包括：</p>
<ul>
<li><code>disk_fill</code>: 磁盘空间填充</li>
<li><code>database_corruption</code>: 数据库损坏</li>
<li><code>state_pollution</code>: 状态污染</li>
<li><code>chain_data_spam</code>: 链上数据垃圾信息</li>
</ul>
<h3 id="6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）"><a href="#6-Geth-Lighthouse客户端攻击（Geth-Lighthouse-Attack）" class="headerlink" title="6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）"></a>6. Geth/Lighthouse客户端攻击（Geth/Lighthouse Attack）</h3><p>针对特定以太坊客户端的攻击。支持的方法包括：</p>
<ul>
<li><code>process_kill</code>: 终止进程</li>
<li><code>db_corruption</code>: 数据库损坏</li>
<li><code>port_blocking</code>: 端口阻断</li>
<li><code>config_modification</code>: 配置文件修改</li>
</ul>
<h2 id="攻击模式（Execution-Modes）"><a href="#攻击模式（Execution-Modes）" class="headerlink" title="攻击模式（Execution Modes）"></a>攻击模式（Execution Modes）</h2><p>系统支持三种攻击执行模式：</p>
<h3 id="1-一次性攻击（One-shot）"><a href="#1-一次性攻击（One-shot）" class="headerlink" title="1. 一次性攻击（One-shot）"></a>1. 一次性攻击（One-shot）</h3><p>执行一次攻击，持续指定时间后自动清理恢复。 配置参数：</p>
<ul>
<li>duration_seconds: 攻击持续时间（秒）</li>
</ul>
<h3 id="2-重复攻击（Repeated）"><a href="#2-重复攻击（Repeated）" class="headerlink" title="2. 重复攻击（Repeated）"></a>2. 重复攻击（Repeated）</h3><p>按指定间隔重复执行多次攻击。 配置参数：</p>
<ul>
<li>interval_seconds: 攻击间隔时间（秒）</li>
<li>repeat_count: 重复次数</li>
<li>duration_seconds: 每次攻击持续时间（秒）</li>
</ul>
<h3 id="3-持续攻击（Continuous）"><a href="#3-持续攻击（Continuous）" class="headerlink" title="3. 持续攻击（Continuous）"></a>3. 持续攻击（Continuous）</h3><p>持续不断地执行攻击，直到手动停止。 配置参数：</p>
<ul>
<li>interval_seconds: 攻击间隔时间（秒）</li>
<li>duration_seconds: 每次攻击持续时间（秒）</li>
</ul>
<h2 id="动态目标攻击"><a href="#动态目标攻击" class="headerlink" title="动态目标攻击"></a>动态目标攻击</h2><p>系统还支持一种特殊的动态目标攻击功能，可以根据网络拓扑分析结果自动选择攻击目标。支持的中心性指标包括：</p>
<ul>
<li>度中心性（Degree Centrality）</li>
<li>介数中心性（Betweenness Centrality）</li>
<li>接近中心性（Closeness Centrality）</li>
<li>特征向量中心性（Eigenvector Centrality）</li>
</ul>
<p>通过这些攻击方式和模式的组合，系统可以模拟各种真实的以太坊网络攻击场景，帮助评估网络的安全性和鲁棒性。</p>
<hr>
<h3 id="1-发起普通攻击-Standard-Attack"><a href="#1-发起普通攻击-Standard-Attack" class="headerlink" title="1. 发起普通攻击 (Standard Attack)"></a>1. 发起普通攻击 (Standard Attack)</h3><p>此接口用于对<strong>明确指定的静态 IP 列表</strong>发起攻击。</p>
<p><strong>Prompt / 接口说明:</strong></p>
<ul>
<li><p><strong>接口地址</strong>: POST /api/simulate</p>
</li>
<li><p><strong>功能</strong>: 发起针对特定静态目标（IP/ID列表）的攻击模拟。</p>
</li>
<li><p><strong>逻辑约束</strong>:</p>
<ol>
<li><p>parameters.target_nodes 必须是字符串数组 [“ip1”, “ip2”]。</p>
</li>
<li><p>支持所有三种执行模式 (one_shot, repeated, continuous)。</p>
</li>
</ol>
</li>
<li><p><strong>请求体构建规则</strong>:</p>
<ul>
<li><p><strong>Level 1 (执行配置)</strong>: 决定攻击的时间维度。</p>
<ul>
<li><p>若是 one_shot: 仅需 duration_seconds。</p>
</li>
<li><p>若是 repeated: 需额外提供 interval_seconds 和 repeat_count。</p>
</li>
</ul>
</li>
<li><p><strong>Level 2 (策略参数)</strong>: 决定攻击的具体手段。</p>
<ul>
<li><p>必须包含 strategy 字段（枚举值）。</p>
</li>
<li><p>其余字段根据 strategy 变化（如 storage_attack 需要 size_mb，而 node_disconnection 不需要）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>请求示例 (JSON):</strong></p>
<p>codeJSON</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 场景：对两个节点进行重复的 P2P 洪水攻击</span><br>{<br>  <span class="hljs-string">"execution_config"</span>: {<br>    <span class="hljs-string">"mode"</span>: <span class="hljs-string">"repeated"</span>,<br>    <span class="hljs-string">"duration_seconds"</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">"interval_seconds"</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">"repeat_count"</span>: <span class="hljs-number">5</span><br>  },<br>  <span class="hljs-string">"parameters"</span>: {<br>    <span class="hljs-string">"strategy"</span>: <span class="hljs-string">"communication_interference"</span>,<br>    <span class="hljs-string">"method"</span>: <span class="hljs-string">"p2p_flood"</span>,<br>    <span class="hljs-string">"intensity"</span>: <span class="hljs-string">"high"</span>,<br>    <span class="hljs-string">"target_nodes"</span>: <span class="hljs-selector-attr">[<span class="hljs-string">"192.168.1.10"</span>, <span class="hljs-string">"192.168.1.11"</span>]</span><br>  }<br>}<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="2-发起自适应攻击-Adaptive-Attack"><a href="#2-发起自适应攻击-Adaptive-Attack" class="headerlink" title="2. 发起自适应攻击 (Adaptive Attack)"></a>2. 发起自适应攻击 (Adaptive Attack)</h3><p>此接口用于<strong>动态目标</strong>攻击，系统会在每一轮攻击开始前重新计算受害者（例如：总是攻击网络中连接数最多的节点）。</p>
<p><strong>Prompt / 接口说明:</strong></p>
<ul>
<li><p><strong>接口地址</strong>: POST /api/simulate/adaptive</p>
</li>
<li><p><strong>功能</strong>: 发起自适应攻击，目标由后端实时计算。</p>
</li>
<li><p><strong>关键区别</strong>:</p>
<ol>
<li><p><strong>不支持</strong> one_shot 模式（因为一次性攻击不需要”自适应”变化）。必须是 repeated 或 continuous。</p>
</li>
<li><p>parameters.target_nodes <strong>必须</strong>是特定格式的字符串指令，以 dynamic: 开头。</p>
</li>
</ol>
</li>
<li><p><strong>目标指令语法</strong>: dynamic:{指标}:{选择策略}</p>
<ul>
<li><p>示例: dynamic:degree:top:5 (度中心性最高的前5个)</p>
</li>
<li><p>示例: dynamic:betweenness:highest (介数中心性最高的1个)</p>
</li>
</ul>
</li>
</ul>
<p><strong>请求示例 (JSON):</strong></p>
<p>codeJSON</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 场景：持续攻击网络中度中心性最高的前5个节点</span><br><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"execution_config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"continuous"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"duration_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"interval_seconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"strategy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_disconnection"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"firewall_block"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"target_nodes"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dynamic:degree:top:5"</span> <span class="hljs-comment">// 注意这里是字符串</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="3-前端分流逻辑-Frontend-Logic"><a href="#3-前端分流逻辑-Frontend-Logic" class="headerlink" title="3. 前端分流逻辑 (Frontend Logic)"></a>3. 前端分流逻辑 (Frontend Logic)</h3><p>这是前端 Vue 组件如何决定调用哪个接口的核心逻辑说明。</p>
<p><strong>Prompt / 逻辑说明:</strong></p>
<p>前端在点击”发起攻击”按钮时，必须执行以下判断逻辑：</p>
<ol>
<li><p><strong>检查目标类型</strong>:</p>
<ul>
<li><p>获取用户在表单中输入的目标配置。</p>
</li>
<li><p>如果目标是<strong>字符串指令</strong>且以 dynamic: 开头 -&gt; 标记为 isDynamic。</p>
</li>
<li><p>如果目标是<strong>手动输入的 IP 列表</strong> -&gt; 标记为 isStatic。</p>
</li>
</ul>
</li>
<li><p><strong>检查执行模式</strong>:</p>
<ul>
<li>获取用户选择的模式 (one_shot, repeated, continuous)。</li>
</ul>
</li>
<li><p><strong>路由决策树</strong>:</p>
<ul>
<li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode == one_shot):</p>
<ul>
<li>❌ <strong>报错</strong>: 自适应攻击不支持一次性模式。</li>
</ul>
</li>
<li><p><strong>IF</strong> (isDynamic == True <strong>AND</strong> mode != one_shot):</p>
<ul>
<li><p>✅ <strong>调用接口</strong>: POST /api/simulate/adaptive</p>
</li>
<li><p><strong>注意</strong>: 此时 target_nodes 字段发送字符串。</p>
</li>
</ul>
</li>
<li><p><strong>ELSE</strong> (即静态目标，无论什么模式):</p>
<ul>
<li><p>✅ <strong>调用接口</strong>: POST /api/simulate</p>
</li>
<li><p><strong>注意</strong>: 此时 target_nodes 字段必须转换为数组 [] 发送。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-停止攻击-Stop-Attack"><a href="#4-停止攻击-Stop-Attack" class="headerlink" title="4. 停止攻击 (Stop Attack)"></a>4. 停止攻击 (Stop Attack)</h3><p><strong>Prompt / 接口说明:</strong></p>
<ul>
<li><p><strong>接口地址</strong>: DELETE /api/simulations/{attack_id}</p>
</li>
<li><p><strong>功能</strong>: 立即终止一个正在运行 (running) 或挂起 (pending) 的攻击任务。</p>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li><p>用户点击”紧急停止”按钮。</p>
</li>
<li><p>用于中断 continuous (无限持续) 类型的攻击。</p>
</li>
<li><p>用于中断剩余轮次尚未执行的 repeated 攻击。</p>
</li>
</ul>
</li>
<li><p><strong>后端行为</strong>:</p>
<ul>
<li><p>取消对应的 asyncio.Task。</p>
</li>
<li><p>执行清理逻辑（如恢复防火墙规则、删除垃圾文件）。</p>
</li>
<li><p>将数据库中的状态更新为 stopped。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-状态轮询与监控-Monitoring"><a href="#5-状态轮询与监控-Monitoring" class="headerlink" title="5. 状态轮询与监控 (Monitoring)"></a>5. 状态轮询与监控 (Monitoring)</h3><p><strong>Prompt / 接口说明:</strong></p>
<p>为了在前端展示”实时状态”和”系统日志”，需要配合使用以下两个接口：</p>
<ol>
<li><p><strong>获取活跃列表</strong>: GET /api/simulations/active</p>
<ul>
<li><p><strong>用途</strong>: 判断当前是否有攻击在跑 (isRunning 状态)。</p>
</li>
<li><p><strong>频率</strong>: 建议每 3-5 秒轮询一次。</p>
</li>
<li><p><strong>返回</strong>: 包含 progress (进度百分比) 和 current_round (当前轮次)。</p>
</li>
</ul>
</li>
<li><p><strong>获取详情/日志</strong>: GET /api/simulations/{attack_id}</p>
<ul>
<li><p><strong>用途</strong>: 获取特定攻击的详细日志流。</p>
</li>
<li><p><strong>返回</strong>: 包含 logs 数组 ([“Attack started”, “Round 1 finished”])。</p>
</li>
<li><p><strong>前端展示</strong>: 将 logs 渲染到控制台面板中。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结：数据结构对照表-Type-Mapping"><a href="#总结：数据结构对照表-Type-Mapping" class="headerlink" title="总结：数据结构对照表 (Type Mapping)"></a>总结：数据结构对照表 (Type Mapping)</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>参数字段</td>
<td>描述</td>
<td>类型限制</td>
</tr>
<tr>
<td><strong>execution_config</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mode</td>
<td>执行模式</td>
<td>“one_shot” \</td>
<td>“repeated” \</td>
<td>“continuous”</td>
</tr>
<tr>
<td>duration_seconds</td>
<td>单次持续时长</td>
<td>Integer (秒)</td>
</tr>
<tr>
<td>interval_seconds</td>
<td>轮次间隔</td>
<td>Integer (秒), 仅 repeated/continuous 有效</td>
</tr>
<tr>
<td>repeat_count</td>
<td>重复次数</td>
<td>Integer, 仅 repeated 有效</td>
</tr>
<tr>
<td><strong>parameters</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>strategy</td>
<td>攻击策略</td>
<td>“node_disconnection” \</td>
<td>“storage_attack” …</td>
</tr>
<tr>
<td>target_nodes</td>
<td>攻击目标</td>
<td>Array [str] (普通) <strong>OR</strong> String dynamic:… (自适应)</td>
</tr>
<tr>
<td>method</td>
<td>具体手段</td>
<td>依赖于 strategy (如 firewall_block, disk_fill)</td>
</tr>
<tr>
<td>…</td>
<td>其他参数</td>
<td>依赖于 strategy (如 size_mb, intensity)</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="1-全局枚举定义-Global-Enums"><a href="#1-全局枚举定义-Global-Enums" class="headerlink" title="1. 全局枚举定义 (Global Enums)"></a>1. 全局枚举定义 (Global Enums)</h3><p>这些枚举值用于填充请求体中的特定字段。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>枚举类型</td>
<td>字段名</td>
<td>可选值 (Value)</td>
<td>说明</td>
</tr>
<tr>
<td><strong>执行模式</strong></td>
<td>mode</td>
<td>one_shot</td>
<td><strong>一次性</strong>：执行一次，持续指定时间后恢复。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>repeated</td>
<td><strong>重复执行</strong>：按间隔重复执行多次。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>continuous</td>
<td><strong>持续执行</strong>：按间隔无限执行，直到手动停止。</td>
</tr>
<tr>
<td><strong>攻击策略</strong></td>
<td>strategy</td>
<td>node_disconnection</td>
<td>节点断连攻击</td>
</tr>
<tr>
<td></td>
<td></td>
<td>communication_interference</td>
<td>通信干扰攻击</td>
</tr>
<tr>
<td></td>
<td></td>
<td>storage_attack</td>
<td>存储耗尽攻击</td>
</tr>
<tr>
<td></td>
<td></td>
<td>timestamp_attack</td>
<td>时间/NTP攻击</td>
</tr>
<tr>
<td></td>
<td></td>
<td>simplified_sybil_attack</td>
<td>简化版女巫攻击</td>
</tr>
<tr>
<td></td>
<td></td>
<td>geth_lighthouse_attack</td>
<td>客户端特定攻击 (Geth/Lighthouse)</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="2-执行配置-execution-config"><a href="#2-执行配置-execution-config" class="headerlink" title="2. 执行配置 (execution_config)"></a>2. 执行配置 (execution_config)</h3><p>根据 mode 的不同，所需字段不同。<strong>注意：自适应攻击接口 (/simulate/adaptive) 不支持 one_shot。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>模式 (Mode)</td>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>默认值</td>
<td>约束/说明</td>
</tr>
<tr>
<td><strong>通用</strong></td>
<td>duration_seconds</td>
<td>Int</td>
<td>✅</td>
<td>30</td>
<td>攻击生效持续时间 (秒)，&gt;=1</td>
</tr>
<tr>
<td><strong>Repeated</strong></td>
<td>interval_seconds</td>
<td>Int</td>
<td>✅</td>
<td>60</td>
<td>轮次间隔时间 (秒)，&gt;=1</td>
</tr>
<tr>
<td>(重复)</td>
<td>repeat_count</td>
<td>Int</td>
<td>✅</td>
<td>-</td>
<td>重复执行的总轮数，&gt;=1</td>
</tr>
<tr>
<td><strong>Continuous</strong></td>
<td>interval_seconds</td>
<td>Int</td>
<td>✅</td>
<td>60</td>
<td>轮次间隔时间 (秒)，&gt;=1</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="3-策略参数详情-parameters"><a href="#3-策略参数详情-parameters" class="headerlink" title="3. 策略参数详情 (parameters)"></a>3. 策略参数详情 (parameters)</h3><p>此部分为多态结构，根据 strategy 字段的值，JSON 结构发生变化。</p>
<h4 id="3-1-节点断连-node-disconnection"><a href="#3-1-节点断连-node-disconnection" class="headerlink" title="3.1 节点断连 (node_disconnection)"></a>3.1 节点断连 (node_disconnection)</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>默认值</td>
<td>描述/选项</td>
</tr>
<tr>
<td>method</td>
<td>String</td>
<td>✅</td>
<td>-</td>
<td>interface_down (网卡下线), route_flush (清空路由), firewall_block (防火墙), p2p_block (P2P阻断)</td>
</tr>
<tr>
<td>target_nodes</td>
<td>Array/Str</td>
<td>✅</td>
<td>-</td>
<td>静态IP列表 或 动态指令 (见第4节)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-2-通信干扰-communication-interference"><a href="#3-2-通信干扰-communication-interference" class="headerlink" title="3.2 通信干扰 (communication_interference)"></a>3.2 通信干扰 (communication_interference)</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>默认值</td>
<td>描述/选项</td>
</tr>
<tr>
<td>method</td>
<td>String</td>
<td>✅</td>
<td>-</td>
<td>json_rpc_flood (RPC泛洪), p2p_flood (P2P泛洪), memory_exhaustion (内存耗尽)</td>
</tr>
<tr>
<td>intensity</td>
<td>String</td>
<td>❌</td>
<td>medium</td>
<td>low, medium, high, extreme</td>
</tr>
<tr>
<td>target_nodes</td>
<td>Array/Str</td>
<td>✅</td>
<td>-</td>
<td>静态IP列表 或 动态指令</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-3-存储攻击-storage-attack"><a href="#3-3-存储攻击-storage-attack" class="headerlink" title="3.3 存储攻击 (storage_attack)"></a>3.3 存储攻击 (storage_attack)</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>默认值</td>
<td>描述/选项</td>
</tr>
<tr>
<td>method</td>
<td>String</td>
<td>✅</td>
<td>-</td>
<td>disk_fill (填充), database_corruption (脏数据), state_pollution (状态污染), chain_data_spam (链上垃圾)</td>
</tr>
<tr>
<td>size_mb</td>
<td>Int</td>
<td>❌</td>
<td>1000</td>
<td>填充大小 (MB)，100 - 10000</td>
</tr>
<tr>
<td>file_count</td>
<td>Int</td>
<td>❌</td>
<td>100</td>
<td>生成文件数量，10 - 1000</td>
</tr>
<tr>
<td>target_nodes</td>
<td>Array/Str</td>
<td>✅</td>
<td>-</td>
<td>静态IP列表 或 动态指令</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-4-时间攻击-timestamp-attack"><a href="#3-4-时间攻击-timestamp-attack" class="headerlink" title="3.4 时间攻击 (timestamp_attack)"></a>3.4 时间攻击 (timestamp_attack)</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>默认值</td>
<td>描述/选项</td>
</tr>
<tr>
<td>method</td>
<td>String</td>
<td>✅</td>
<td>-</td>
<td>time_shift (平移), ntp_block (NTP阻断), time_drift (漂移)</td>
</tr>
<tr>
<td>time_shift</td>
<td>String</td>
<td>❌</td>
<td>+1 hour</td>
<td>偏移量 (如 +1 hour, -30 minutes)，仅 time_shift 方法有效</td>
</tr>
<tr>
<td>drift_seconds</td>
<td>Int</td>
<td>❌</td>
<td>3600</td>
<td>漂移秒数，-86400 到 86400，仅 time_drift 方法有效</td>
</tr>
<tr>
<td>target_nodes</td>
<td>Array/Str</td>
<td>✅</td>
<td>-</td>
<td>静态IP列表 或 动态指令</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-5-女巫攻击-simplified-sybil-attack"><a href="#3-5-女巫攻击-simplified-sybil-attack" class="headerlink" title="3.5 女巫攻击 (simplified_sybil_attack)"></a>3.5 女巫攻击 (simplified_sybil_attack)</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>默认值</td>
<td>描述/选项</td>
</tr>
<tr>
<td>fake_node_count</td>
<td>Int</td>
<td>❌</td>
<td>5</td>
<td>虚假节点数量 (1-20)</td>
</tr>
<tr>
<td>node_type</td>
<td>String</td>
<td>❌</td>
<td>light</td>
<td>light (轻节点), full (全节点), validator (验证者)</td>
</tr>
<tr>
<td>network</td>
<td>String</td>
<td>❌</td>
<td>testnet</td>
<td>mainnet, testnet, devnet</td>
</tr>
<tr>
<td>connect_to_real</td>
<td>Bool</td>
<td>❌</td>
<td>True</td>
<td>是否连接真实节点</td>
</tr>
<tr>
<td>min_connections</td>
<td>Int</td>
<td>❌</td>
<td>3</td>
<td>最小连接数 (0-10)</td>
</tr>
<tr>
<td>target_nodes</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><strong>注意：此策略通常不需要指定具体目标节点</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-6-客户端攻击-geth-lighthouse-attack"><a href="#3-6-客户端攻击-geth-lighthouse-attack" class="headerlink" title="3.6 客户端攻击 (geth_lighthouse_attack)"></a>3.6 客户端攻击 (geth_lighthouse_attack)</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>默认值</td>
<td>描述/选项</td>
</tr>
<tr>
<td>method</td>
<td>String</td>
<td>✅</td>
<td>-</td>
<td>process_kill, db_corruption, port_blocking, config_modification</td>
</tr>
<tr>
<td>attack_type</td>
<td>String</td>
<td>✅</td>
<td>-</td>
<td>geth, lighthouse (指定攻击的客户端类型)</td>
</tr>
<tr>
<td>target_nodes</td>
<td>Array/Str</td>
<td>✅</td>
<td>-</td>
<td>静态IP列表 或 动态指令</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="4-目标节点配置-target-nodes"><a href="#4-目标节点配置-target-nodes" class="headerlink" title="4. 目标节点配置 (target_nodes)"></a>4. 目标节点配置 (target_nodes)</h3><p>target_nodes 字段在不同接口下有严格的格式要求。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>接口端点</td>
<td>格式类型</td>
<td>数据结构示例</td>
<td>说明</td>
</tr>
<tr>
<td>/api/simulate</td>
<td><strong>静态列表</strong></td>
<td>[“192.168.1.10”, “node_id_123”]</td>
<td>明确指定要攻击的节点列表。</td>
</tr>
<tr>
<td>/api/simulate/adaptive</td>
<td><strong>动态指令</strong></td>
<td>“dynamic:degree:top:5”</td>
<td>字符串格式，后端自动计算目标。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>动态指令语法:</strong> dynamic:{指标}:{选择器}</p>
<ol>
<li><p><strong>指标 (Metric)</strong>:</p>
<ul>
<li><p>degree (度中心性)</p>
</li>
<li><p>betweenness (介数中心性)</p>
</li>
<li><p>closeness (接近中心性)</p>
</li>
<li><p>eigenvector (特征向量中心性)</p>
</li>
</ul>
</li>
<li><p><strong>选择器 (Selector)</strong>:</p>
<ul>
<li><p>highest (选最高的1个)</p>
</li>
<li><p>top:N (选前 N 个，N为数字)</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-防护配置-defense-enable"><a href="#5-防护配置-defense-enable" class="headerlink" title="5. 防护配置 (/defense/enable)"></a>5. 防护配置 (/defense/enable)</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>示例</td>
<td>说明</td>
</tr>
<tr>
<td>enabled</td>
<td>Bool</td>
<td>❌</td>
<td>true</td>
<td>是否启用防护</td>
</tr>
<tr>
<td>rules</td>
<td>Object</td>
<td>✅</td>
<td>{“rate_limit”: 100}</td>
<td>防护规则字典，具体Key由后端逻辑决定</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="6-响应结构概览"><a href="#6-响应结构概览" class="headerlink" title="6. 响应结构概览"></a>6. 响应结构概览</h3><p>所有接口通常遵循统一的响应格式：</p>
<p>codeJSON</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">{<br>  <span class="hljs-string">"status"</span>: <span class="hljs-string">"success"</span>,  <span class="hljs-string">//</span> 或 <span class="hljs-string">"error"</span><br>  <span class="hljs-string">"message"</span>: <span class="hljs-string">"操作描述"</span>,<br>  <span class="hljs-string">"data"</span>: { <span class="hljs-string">...</span> }       <span class="hljs-string">//</span> 具体业务数据<br>}<br></code></pre></td></tr></table></figure>
<p><strong>关键数据字段 (data)</strong>:</p>
<ul>
<li><p>attack_id: (String) 攻击任务的唯一标识符。</p>
</li>
<li><p>status: (Enum) pending, running, completed, failed, stopped, cancelled。</p>
</li>
<li><p>logs: (Array[Str]) 攻击日志列表。</p>
</li>
</ul>
<p>{<br>  “nodes”: [<br>    {<br>      “id”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”,<br>      “name”: “Tether USD (USDT)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 5<br>    },<br>    {<br>      “id”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”,<br>      “name”: “USD Coin (USDC)”,<br>      “type”: “ERC20”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 3<br>    },<br>    {<br>      “id”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”,<br>      “name”: “Uniswap V3: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 8<br>    },<br>    {<br>      “id”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”,<br>      “name”: “Uniswap V3: SwapRouter02”,<br>      “type”: “SwapRouter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 6<br>    },<br>    {<br>      “id”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”,<br>      “name”: “Uniswap V3: Quoter”,<br>      “type”: “Quoter”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”,<br>      “name”: “Uniswap V2: Router”,<br>      “type”: “Router”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 7<br>    },<br>    {<br>      “id”: “0x881D40237659C251811CEC9c364ef91dC08D300C”,<br>      “name”: “Curve: 3pool Controller”,<br>      “type”: “CurvePool”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 4<br>    },<br>    {<br>      “id”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”,<br>      “name”: “Curve: 3pool Gauge”,<br>      “type”: “Gauge”,<br>      “ip_address”: “”,<br>      “status”: “active”,<br>      “layer”: “contract”,<br>      “container_name”: null,<br>      “neighbor_count”: 2<br>    }<br>  ],<br>  “links”: [<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “type”: “transfer_approve” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap_out” },<br>    { “source”: “0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45”, “target”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “type”: “swap_in” },<br>    { “source”: “0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48”, “target”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “type”: “call” },<br>    { “source”: “0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984”, “target”: “0xE592427A0AEce92De3Edee1F18E0157C05861564”, “type”: “quote” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “type”: “approve” },<br>    { “source”: “0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D”, “target”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “type”: “swap” },<br>    { “source”: “0xdAC17F958D2ee523a2206206994597C13D831ec7”, “target”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “type”: “deposit” },<br>    { “source”: “0x881D40237659C251811CEC9c364ef91dC08D300C”, “target”: “0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7”, “type”: “stake” }<br>  ],<br>  “timestamp”: 1765095677.891234,<br>  “data_source”: “real_web3”,<br>  “topology_type”: “contract”<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>    A[ETH前端] --&gt; B[src]<br>    A --&gt; C[package.json]<br>    A --&gt; D[index.html]<br>    A --&gt; E[vite.config.ts]<br>    A --&gt; F[README.md]<br>    A --&gt; G[public]<br>    <br>    B --&gt; H[__tests__]<br>    B --&gt; I[api]<br>    B --&gt; J[assets]<br>    B --&gt; K[components]<br>    B --&gt; L[composables]<br>    B --&gt; M[router]<br>    B --&gt; N[services]<br>    B --&gt; O[types]<br>    B --&gt; P[utils]<br>    B --&gt; Q[views]<br>    B --&gt; R[App.vue]<br>    B --&gt; S[main.ts]<br>    <br>    I --&gt; T[api_docs]<br>    I --&gt; U[attack]<br>    <br>    J --&gt; V[styles]<br>    V --&gt; W[global.css]<br>    V --&gt; X[tailwind.css]<br>    <br>    K --&gt; Y[blockchain]<br>    K --&gt; Z[common]<br>    K --&gt; AA[layout]<br>    K --&gt; AB[tabs]<br>    K --&gt; AC[topology]<br>    <br>    Y --&gt; AD[BlockchainCanvas.vue]<br>    Y --&gt; AE[BlockchainInfoPanel.vue]<br>    Y --&gt; AF[BlockchainModal.vue]<br>    Y --&gt; AG[BlockchainVisualization.vue]<br>    Y --&gt; AH[composables]<br>    Y --&gt; AI[types]<br>    <br>    AH --&gt; AJ[useBlockchainAPI.ts]<br>    AH --&gt; AK[useBlockchainAnimations.ts]<br>    AH --&gt; AL[useBlockchainData.ts]<br>    AH --&gt; AM[useBlockchainEvents.ts]<br>    AH --&gt; AN[useBlockchainRenderer.ts]<br>    AH --&gt; AO[useBlockchainScrolling.ts]<br>    <br>    Z --&gt; AP[ContainerTerminal.vue]<br>    Z --&gt; AQ[DEP-TERM.vue]<br>    Z --&gt; AR[StandaloneTerminal.vue]<br>    Z --&gt; AS[Terminal.vue]<br>    Z --&gt; AT[websocket_terminal8080.vue]<br>    <br>    AA --&gt; AU[DashboardHeader.vue]<br>    AA --&gt; AV[LeftPanel.vue]<br>    AA --&gt; AW[PanelSplitter.vue]<br>    AA --&gt; AX[RightPanel.vue]<br>    <br>    AB --&gt; AY[AttackMonitoringTab.vue]<br>    AB --&gt; AZ[Attack_sys]<br>    AB --&gt; BA[BlockchainBrowserTab.css]<br>    AB --&gt; BB[BlockchainBrowserTab.vue]<br>    AB --&gt; BC[ContainerListTab.vue]<br>    AB --&gt; BD[NetworkTopologyTab.vue]<br>    AB --&gt; BE[sections]<br>    AB --&gt; BF[tabstyle.css]<br>    <br>    AZ --&gt; BG[AttackSystemTab.vue]<br>    BE --&gt; BH[Network-analysis.vue]<br>    BE --&gt; BI[NodeInfoPanel.vue]<br>    BE --&gt; BJ[RealTimeMonitoring.vue]<br>    <br>    AC --&gt; BK[ContractTopology.vue]<br>    AC --&gt; BL[Ethereum_Topology]<br>    AC --&gt; BM[Physical_Topology]<br>    AC --&gt; BN[TopologyVisualization.vue]<br>    AC --&gt; BO[TransactionTopology.vue]<br>    AC --&gt; BP[composables]<br>    AC --&gt; BQ[types]<br>    <br>    BL --&gt; BR[types]<br>    BL --&gt; BS[workers]<br>    BL --&gt; BT[EthereumTopology_new.vue]<br>    BL --&gt; BU[useD3Renderer.ts]<br>    BL --&gt; BV[use_topology_core.ts]<br>    BL --&gt; BW[use_topology_visuals.ts]<br>    <br>    BM --&gt; BX[composables]<br>    BM --&gt; BY[PhysicalTopology.vue]<br>    <br>    BP --&gt; BZ[index.ts]<br>    BP --&gt; CA[topology.css]<br>    BP --&gt; CB[useTopologyAPI.ts]<br>    BP --&gt; CC[useTopologyData.ts]<br>    BP --&gt; CD[useTopologyRendererBase.ts]<br>    <br>    L --&gt; CE[useDashboardData.ts]<br>    L --&gt; CF[useDashboardLayout.ts]<br>    L --&gt; CG[useDashboardTabs.ts]<br>    <br>    M --&gt; CH[index.ts]<br>    <br>    N --&gt; CI[analysis.ts]<br>    N --&gt; CJ[api.ts]<br>    N --&gt; CK[apiService.ts]<br>    N --&gt; CL[attack.ts]<br>    N --&gt; CM[blockchain.ts]<br>    N --&gt; CN[daily-operations.ts]<br>    N --&gt; CO[device-monitoring.ts]<br>    N --&gt; CP[execution.ts]<br>    N --&gt; CQ[foundation.ts]<br>    N --&gt; CR[monitoring.ts]<br>    N --&gt; CS[readme.md]<br>    N --&gt; CT[root-api.ts]<br>    N --&gt; CU[security.ts]<br>    N --&gt; CV[temporal.ts]<br>    N --&gt; CW[topology.ts]<br>    <br>    O --&gt; CX[topology.ts]<br>    <br>    P --&gt; CY[http.ts]<br>    P --&gt; CZ[index.ts]<br>    P --&gt; DA[types.ts]<br>    <br>    Q --&gt; DB[BlockchainTest.vue]<br>    Q --&gt; DC[Dashboard.vue]<br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/51477.html">← 下一篇 2025-12-07-杂谈-复杂异构系统监控与可视化项目设计</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/17798.html">2025-12-05-字节工训营画布项目相关设计 上一篇 →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%90%8E%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">优化后文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">1. 架构总览图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%B1%82%E7%BA%A7%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">2. 核心层级详细解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B1%82-Worker-Thread"><span class="toc-number">3.1.</span> <span class="toc-text">第一层：数据处理层 (Worker Thread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%9A%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B1%82-Composables"><span class="toc-number">3.2.</span> <span class="toc-text">第二层：状态管理层 (Composables)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%B1%82%EF%BC%9A%E6%B8%B2%E6%9F%93%E9%A9%B1%E5%8A%A8%E5%B1%82-Render-Engine"><span class="toc-number">3.3.</span> <span class="toc-text">第三层：渲染驱动层 (Render Engine)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E5%B1%82%EF%BC%9A%E8%A7%86%E5%9B%BE%E7%BB%84%E8%A3%85%E5%B1%82-View-Integration"><span class="toc-number">3.4.</span> <span class="toc-text">第四层：视图组装层 (View Integration)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">3. 关键性能优化点总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">4. 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E6%BA%90%E8%8E%B7%E5%8F%96-Data-Acquisition"><span class="toc-number">6.</span> <span class="toc-text">1. 数据源获取 (Data Acquisition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">2. 核心处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-A%EF%BC%9A%E4%BB%8E-Neo4j-%E6%8F%90%E5%8F%96%E5%8E%9F%E5%A7%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">步骤 A：从 Neo4j 提取原始拓扑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-B%EF%BC%9A%E5%AE%B9%E5%99%A8%E8%BA%AB%E4%BB%BD%E6%98%A0%E5%B0%84-Container-Mapping"><span class="toc-number">7.2.</span> <span class="toc-text">步骤 B：容器身份映射 (Container Mapping)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-C%EF%BC%9A%E6%9E%84%E5%BB%BA%E6%8B%93%E6%89%91%E5%AF%B9%E8%B1%A1-Topology-Construction"><span class="toc-number">7.3.</span> <span class="toc-text">步骤 C：构建拓扑对象 (Topology Construction)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%B9%E9%94%99%E4%B8%8E%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">3. 容错与缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%9F%E8%AE%A1%E4%B8%8E%E9%AA%8C%E8%AF%81-Statistics-amp-Validation"><span class="toc-number">9.</span> <span class="toc-text">4. 统计与验证 (Statistics &amp; Validation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%97%9B%E7%82%B9%E5%88%86%E6%9E%90%EF%BC%9A%E7%9B%AE%E5%89%8D%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">1. 痛点分析：目前的性能瓶颈在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9ADocker-%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8B%AC%E7%AB%8B%E7%BC%93%E5%AD%98%E4%B8%8E%E5%90%8E%E5%8F%B0%E6%9B%B4%E6%96%B0"><span class="toc-number">12.</span> <span class="toc-text">2. 优化方案一：Docker 数据的独立缓存与后台更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E7%89%A9%E7%90%86%E6%8B%93%E6%89%91%E5%B8%A6%E5%AE%BD%E6%A3%80%E6%B5%8B%E7%9A%84%E2%80%9C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%8C%96%E2%80%9D"><span class="toc-number">13.</span> <span class="toc-text">3. 优化方案二：物理拓扑带宽检测的“非阻塞化”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9ANeo4j-%E5%B9%B6%E5%8F%91%E6%9F%A5%E8%AF%A2"><span class="toc-number">14.</span> <span class="toc-text">4. 优化方案三：Neo4j 并发查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E5%9B%9B%EF%BC%9ACypher-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="toc-number">15.</span> <span class="toc-text">5. 优化方案四：Cypher 查询语句优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BB%BC%E5%90%88%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E5%BB%BA%E8%AE%AE"><span class="toc-number">16.</span> <span class="toc-text">6. 综合改进后的代码结构建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">17.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%88Attack-Strategies%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">攻击方式（Attack Strategies）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8A%82%E7%82%B9%E6%96%AD%E7%BD%91%E6%94%BB%E5%87%BB%EF%BC%88Node-Disconnection-Attack%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1. 节点断网攻击（Node Disconnection Attack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E4%BF%A1%E5%B9%B2%E6%89%B0%E6%94%BB%E5%87%BB%EF%BC%88Communication-Interference-Attack%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 通信干扰攻击（Communication Interference Attack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E6%94%BB%E5%87%BB%EF%BC%88Timestamp-Attack%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. 时间攻击（Timestamp Attack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%80%E5%8C%96Sybil%E6%94%BB%E5%87%BB%EF%BC%88Simplified-Sybil-Attack%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4. 简化Sybil攻击（Simplified Sybil Attack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%98%E5%82%A8%E6%94%BB%E5%87%BB%EF%BC%88Storage-Attack%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">5. 存储攻击（Storage Attack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Geth-Lighthouse%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%EF%BC%88Geth-Lighthouse-Attack%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">6. Geth&#x2F;Lighthouse客户端攻击（Geth&#x2F;Lighthouse Attack）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%A8%A1%E5%BC%8F%EF%BC%88Execution-Modes%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">攻击模式（Execution Modes）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%80%E6%AC%A1%E6%80%A7%E6%94%BB%E5%87%BB%EF%BC%88One-shot%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1. 一次性攻击（One-shot）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E5%A4%8D%E6%94%BB%E5%87%BB%EF%BC%88Repeated%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 重复攻击（Repeated）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%81%E7%BB%AD%E6%94%BB%E5%87%BB%EF%BC%88Continuous%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. 持续攻击（Continuous）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%94%BB%E5%87%BB"><span class="toc-number"></span> <span class="toc-text">动态目标攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%91%E8%B5%B7%E6%99%AE%E9%80%9A%E6%94%BB%E5%87%BB-Standard-Attack"><span class="toc-number">1.</span> <span class="toc-text">1. 发起普通攻击 (Standard Attack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%91%E8%B5%B7%E8%87%AA%E9%80%82%E5%BA%94%E6%94%BB%E5%87%BB-Adaptive-Attack"><span class="toc-number">2.</span> <span class="toc-text">2. 发起自适应攻击 (Adaptive Attack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%8D%E7%AB%AF%E5%88%86%E6%B5%81%E9%80%BB%E8%BE%91-Frontend-Logic"><span class="toc-number">3.</span> <span class="toc-text">3. 前端分流逻辑 (Frontend Logic)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%81%9C%E6%AD%A2%E6%94%BB%E5%87%BB-Stop-Attack"><span class="toc-number">4.</span> <span class="toc-text">4. 停止攻击 (Stop Attack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%8A%B6%E6%80%81%E8%BD%AE%E8%AF%A2%E4%B8%8E%E7%9B%91%E6%8E%A7-Monitoring"><span class="toc-number">5.</span> <span class="toc-text">5. 状态轮询与监控 (Monitoring)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E7%85%A7%E8%A1%A8-Type-Mapping"><span class="toc-number">6.</span> <span class="toc-text">总结：数据结构对照表 (Type Mapping)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89-Global-Enums"><span class="toc-number">7.</span> <span class="toc-text">1. 全局枚举定义 (Global Enums)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE-execution-config"><span class="toc-number">8.</span> <span class="toc-text">2. 执行配置 (execution_config)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AD%96%E7%95%A5%E5%8F%82%E6%95%B0%E8%AF%A6%E6%83%85-parameters"><span class="toc-number">9.</span> <span class="toc-text">3. 策略参数详情 (parameters)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%8A%82%E7%82%B9%E6%96%AD%E8%BF%9E-node-disconnection"><span class="toc-number">9.1.</span> <span class="toc-text">3.1 节点断连 (node_disconnection)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%80%9A%E4%BF%A1%E5%B9%B2%E6%89%B0-communication-interference"><span class="toc-number">9.2.</span> <span class="toc-text">3.2 通信干扰 (communication_interference)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%AD%98%E5%82%A8%E6%94%BB%E5%87%BB-storage-attack"><span class="toc-number">9.3.</span> <span class="toc-text">3.3 存储攻击 (storage_attack)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%97%B6%E9%97%B4%E6%94%BB%E5%87%BB-timestamp-attack"><span class="toc-number">9.4.</span> <span class="toc-text">3.4 时间攻击 (timestamp_attack)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%A5%B3%E5%B7%AB%E6%94%BB%E5%87%BB-simplified-sybil-attack"><span class="toc-number">9.5.</span> <span class="toc-text">3.5 女巫攻击 (simplified_sybil_attack)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB-geth-lighthouse-attack"><span class="toc-number">9.6.</span> <span class="toc-text">3.6 客户端攻击 (geth_lighthouse_attack)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE-target-nodes"><span class="toc-number">10.</span> <span class="toc-text">4. 目标节点配置 (target_nodes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%B2%E6%8A%A4%E9%85%8D%E7%BD%AE-defense-enable"><span class="toc-number">11.</span> <span class="toc-text">5. 防护配置 (&#x2F;defense&#x2F;enable)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-number">12.</span> <span class="toc-text">6. 响应结构概览</span></a></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>