<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-11-22-canvas状态管理杂记其三 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-11-22-canvas状态管理杂记其三</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-11-22T08:43:45.000Z" id="date"> 2025-11-22</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-11-24T03:50:02.066Z" id="updated"> 2025-11-24</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><p>撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：</p>
<ol>
<li><p><strong>快照命令（SnapshotCommand）</strong>：</p>
<ul>
<li>用于记录整个画布状态的变化</li>
<li>通常用于添加元素、删除元素等较大范围的操作</li>
<li>保存完整的状态快照</li>
</ul>
</li>
<li><p><strong>更新元素命令（UpdateElementCommand）</strong>：</p>
<ul>
<li>用于记录特定元素的属性变化</li>
<li>主要用于拖拽移动和调整大小操作</li>
<li>只保存相关元素的特定属性变化</li>
</ul>
</li>
</ol>
<h2 id="操作序列和撤销栈状态变化"><a href="#操作序列和撤销栈状态变化" class="headerlink" title="操作序列和撤销栈状态变化"></a>操作序列和撤销栈状态变化</h2><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>撤销栈：空 重做栈：空</p>
<h3 id="1-创建元素A"><a href="#1-创建元素A" class="headerlink" title="1. 创建元素A"></a>1. 创建元素A</h3><p>当创建元素A时，系统会生成一个快照命令，记录整个画布状态的变化。</p>
<p>撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：空</p>
<h3 id="2-移动A到一个位置"><a href="#2-移动A到一个位置" class="headerlink" title="2. 移动A到一个位置"></a>2. 移动A到一个位置</h3><p>当移动元素A时，系统会生成一个更新元素命令（UpdateElementCommand），只记录A元素位置的变化。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：空</p>
<h3 id="3-创建元素B"><a href="#3-创建元素B" class="headerlink" title="3. 创建元素B"></a>3. 创建元素B</h3><p>当创建元素B时，系统会生成另一个快照命令，记录添加B元素后的状态。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：空</p>
<h3 id="4-缩放B到一个位置"><a href="#4-缩放B到一个位置" class="headerlink" title="4. 缩放B到一个位置"></a>4. 缩放B到一个位置</h3><p>当缩放元素B时，系统会生成一个更新元素命令，记录B元素尺寸和位置的变化。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：空</p>
<h3 id="5-移动B到一个位置"><a href="#5-移动B到一个位置" class="headerlink" title="5. 移动B到一个位置"></a>5. 移动B到一个位置</h3><p>当再次移动元素B时，系统会生成另一个更新元素命令，记录B元素位置的新变化。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5) 重做栈：空</p>
<h2 id="执行撤销操作时的状态变化"><a href="#执行撤销操作时的状态变化" class="headerlink" title="执行撤销操作时的状态变化"></a>执行撤销操作时的状态变化</h2><h3 id="第一次撤销（移动B操作）"><a href="#第一次撤销（移动B操作）" class="headerlink" title="第一次撤销（移动B操作）"></a>第一次撤销（移动B操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB</li>
<li>执行该命令的undo()方法，将B元素恢复到缩放后的位置</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：[UpdateElementCommand_MoveB] (大小: 1)</p>
<h3 id="第二次撤销（缩放B操作）"><a href="#第二次撤销（缩放B操作）" class="headerlink" title="第二次撤销（缩放B操作）"></a>第二次撤销（缩放B操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB</li>
<li>执行该命令的undo()方法，将B元素恢复到刚创建时的尺寸和位置</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)</p>
<h3 id="第三次撤销（创建B操作）"><a href="#第三次撤销（创建B操作）" class="headerlink" title="第三次撤销（创建B操作）"></a>第三次撤销（创建B操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：SnapshotCommand_B</li>
<li>执行该命令的undo()方法，将整个画布状态恢复到创建B之前的状态（即只包含A元素的状态）</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)</p>
<h3 id="第四次撤销（移动A操作）"><a href="#第四次撤销（移动A操作）" class="headerlink" title="第四次撤销（移动A操作）"></a>第四次撤销（移动A操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA</li>
<li>执行该命令的undo()方法，将A元素恢复到初始位置</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)</p>
<h3 id="第五次撤销（创建A操作）"><a href="#第五次撤销（创建A操作）" class="headerlink" title="第五次撤销（创建A操作）"></a>第五次撤销（创建A操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：SnapshotCommand_A</li>
<li>执行该命令的undo()方法，将整个画布状态恢复到初始状态（空画布）</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：空 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)</p>
<p><code>undoRedoManager.lock()</code> 锁定管理器</p>
<hr>
<p>redo问题</p>
<ol>
<li><p><strong>状态快照不完整</strong>：当创建元素时，状态快照可能在元素完全初始化之前就被捕获了，导致元素的width、height等属性为默认值（可能是0）。</p>
</li>
<li><p><strong>引用问题</strong>：虽然使用了深拷贝，但是在某些情况下，元素对象可能在快照创建后又被修改，导致快照中的数据不是预期的值。</p>
</li>
<li><p><strong>异步更新问题</strong>：元素创建和状态更新之间可能存在异步延迟，导致快照捕捉到了中间状态而非最终状态。</p>
</li>
</ol>
<p>需要确保在创建状态快照时，所有元素都已经完全初始化，并且使用可靠的方法进行深拷贝。</p>
<p>修复当用户执行 Undo 后再 Redo 时，恢复的是最初 width:0, height:0 的状态，导致元素不可见的问题，修复日志里“type: ‘未知操作’” 和 “重做无效”的问题，在绘制结束（onPointerUp）时，更新历史栈顶那个“创建命令”的 nextState，将其替换为绘制完成后的最终状态</p>
<hr>
<h2 id="元素移动（拖拽）实现"><a href="#元素移动（拖拽）实现" class="headerlink" title="元素移动（拖拽）实现"></a>元素移动（拖拽）实现</h2><p>元素的移动主要在 StageManagerCore.ts 文件中实现：</p>
<ol>
<li><p><strong>开始拖拽</strong>：</p>
<ul>
<li>在 onPointerDown 方法中检测到点击的是已选中的元素时，将模式设置为 dragging</li>
<li>记录所有选中元素的初始状态到 dragInitialStates 中</li>
</ul>
</li>
<li><p><strong>拖拽过程中</strong>：</p>
<ul>
<li>在 onPointerMove 方法中，当 mode 为 dragging 时，计算位移并更新元素位置</li>
<li>通过调用 <code>state.updateElement(id, { x: el.x + dx, y: el.y + dy })</code> 来更新元素坐标</li>
</ul>
</li>
<li><p><strong>结束拖拽</strong>：</p>
<ul>
<li>在 onPointerUp 方法中处理拖拽结束逻辑</li>
<li>创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中</li>
</ul>
</li>
</ol>
<h2 id="元素缩放（调整大小）实现"><a href="#元素缩放（调整大小）实现" class="headerlink" title="元素缩放（调整大小）实现"></a>元素缩放（调整大小）实现</h2><p>元素的缩放也在 StageManagerCore.ts 文件中实现：</p>
<ol>
<li><p><strong>开始缩放</strong>：</p>
<ul>
<li>在 onHandleDown 方法中处理控制点按下事件</li>
<li>将模式设置为 resizing</li>
<li>记录所有选中元素的初始状态到 resizeInitialStates 和 initialElementsMap 中</li>
<li>计算初始包围盒并存储在 initialGroupBounds 中</li>
</ul>
</li>
<li><p><strong>缩放过程中</strong>：</p>
<ul>
<li>在 onPointerMove 方法中，当 mode 为 resizing 时处理缩放逻辑</li>
<li>对于普通元素，基于初始包围盒和鼠标位移重新计算元素的位置和大小</li>
<li>对于线条和箭头等特殊元素，单独处理端点的拖拽</li>
</ul>
</li>
<li><p><strong>结束缩放</strong>：</p>
<ul>
<li>在 onPointerUp 方法中处理缩放结束逻辑</li>
<li>创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中</li>
</ul>
</li>
</ol>
<h2 id="关键类和文件"><a href="#关键类和文件" class="headerlink" title="关键类和文件"></a>关键类和文件</h2><ol>
<li><strong>StageManagerCore.ts</strong> - 核心逻辑实现</li>
<li><strong>TransformerRenderer.ts</strong> - 渲染选中元素的控制手柄</li>
<li><strong>UpdateElementCommand.ts</strong> - 撤销/重做命令实现</li>
<li><strong>UndoRedoManager.ts</strong> - 撤销/重做管理器</li>
</ol>
<p>总的来说，元素的移动和缩放操作都是通过 StageManagerCore 类统一管理和处理的，该类负责监听鼠标事件并根据当前模式执行相应的操作。</p>
<p>实现元素旋转功能需要涉及三个主要部分的修改：</p>
<ol>
<li><p><strong>数据模型与状态定义</strong>：支持 rotation 属性和旋转时的临时状态。</p>
</li>
<li><p><strong>交互逻辑 (Math)</strong>：处理单个元素旋转和多选组的旋转（组旋转需要处理“公转”和“自转”）。</p>
</li>
<li><p><strong>渲染器支持</strong>：虽然这里主要改 StageManagerCore，但你需要确保 TransformerRenderer 能渲染出旋转手柄（通常位于选中框顶部的延长线上）。</p>
</li>
</ol>
<p>以下是具体的实现步骤和代码修改。</p>
<h3 id="第一步：修改类型定义"><a href="#第一步：修改类型定义" class="headerlink" title="第一步：修改类型定义"></a>第一步：修改类型定义</h3><p>在 types.ts 或 StageManagerCore.ts 的状态定义中，增加旋转相关的临时状态。</p>
<p>codeTypeScript</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerState 接口中添加：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StageManagerState</span> {<br>  <span class="hljs-comment">// ... 原有属性</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">'idle'</span> | <span class="hljs-string">'dragging'</span> | <span class="hljs-string">'resizing'</span> | <span class="hljs-string">'selecting'</span> | <span class="hljs-string">'drawing'</span> | <span class="hljs-string">'erasing'</span> | <span class="hljs-string">'rotating'</span>; <span class="hljs-comment">// [修改] 添加 rotating</span><br><br>  <span class="hljs-comment">// [新增] 旋转相关状态</span><br>  <span class="hljs-attr">rotationInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, { <br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">rotation</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">cx</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素中心点 x</span><br>    <span class="hljs-attr">cy</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素中心点 y</span><br>  }&gt; | <span class="hljs-literal">null</span>;<br>  <span class="hljs-attr">rotationCenter</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 旋转中心（群组中心或单元素中心）</span><br>  <span class="hljs-attr">startRotationAngle</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 鼠标按下时的初始角度</span><br>}<br></code></pre></td></tr></table></figure>
<h3 id="第二步：实现旋转数学逻辑-辅助方法"><a href="#第二步：实现旋转数学逻辑-辅助方法" class="headerlink" title="第二步：实现旋转数学逻辑 (辅助方法)"></a>第二步：实现旋转数学逻辑 (辅助方法)</h3><p>在 StageManagerCore 类中添加一个用于计算旋转后坐标的辅助方法。</p>
<p>codeTypeScript</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore 类中添加</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算点绕中心旋转后的新坐标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x 点的 x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> y 点的 y</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cx 中心点 x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cy 中心点 y</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> angle 旋转角度 (弧度)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">rotatePoint</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">cx</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">cy</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">angle</span>: <span class="hljs-built_in">number</span></span>) {<br>  <span class="hljs-keyword">const</span> cos = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(angle);<br>  <span class="hljs-keyword">const</span> sin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(angle);<br>  <span class="hljs-keyword">const</span> nx = (cos * (x - cx)) - (sin * (y - cy)) + cx;<br>  <span class="hljs-keyword">const</span> ny = (sin * (x - cx)) + (cos * (y - cy)) + cy;<br>  <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: nx, <span class="hljs-attr">y</span>: ny };<br>}<br></code></pre></td></tr></table></figure>
<h3 id="第三步：处理-onHandleDown-开始旋转"><a href="#第三步：处理-onHandleDown-开始旋转" class="headerlink" title="第三步：处理 onHandleDown (开始旋转)"></a>第三步：处理 onHandleDown (开始旋转)</h3><p>你需要修改 onHandleDown 方法。首先，你需要在 TransformerRenderer 中定义一个 ID 为 rotate 的手柄。当捕获到该手柄时，初始化旋转状态。</p>
<p>codeTypeScript</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 修改 <span class="hljs-keyword">on</span>HandleDown 方法<br>private <span class="hljs-keyword">on</span>HandleDown = (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1' | 'rotate', elementId: string) =&gt; {<br>  this.triggerDebounceSnapshot();<br>  e.stopPropagation();<br><br>  // === [新增] 旋转逻辑分支 ===<br>  if (handle === 'rotate') {<br>    this.<span class="hljs-keyword">state</span>.mode = 'rotating';<br>    this.<span class="hljs-keyword">state</span>.currentId = elementId;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = useStore.getState();<br>    <span class="hljs-keyword">const</span> { elements, selectedIds } = <span class="hljs-keyword">state</span>;<br>    <span class="hljs-keyword">const</span> mouseP<span class="hljs-keyword">os</span> = e.getLocalPosition(this.viewport);<br><br>    // <span class="hljs-number">1</span>. 计算旋转中心（选中元素的包围盒中心）<br>    <span class="hljs-keyword">const</span> bounds = this.getSelectionBounds(selectedIds, elements);<br>    if (!bounds) return;<br>    <br>    <span class="hljs-keyword">const</span> centerX = bounds.x + bounds.width / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">const</span> centerY = bounds.y + bounds.height / <span class="hljs-number">2</span>;<br>    this.<span class="hljs-keyword">state</span>.rotationCenter = { x: centerX, y: centerY };<br><br>    // <span class="hljs-number">2</span>. 计算鼠标起始角度（相对于中心点）<br>    this.<span class="hljs-keyword">state</span>.startRotationAngle = Math.atan2(mouseP<span class="hljs-keyword">os</span>.y - centerY, mouseP<span class="hljs-keyword">os</span>.x - centerX);<br><br>    // <span class="hljs-number">3</span>. 记录所有选中元素的初始状态<br>    <span class="hljs-keyword">const</span> initialMap: Record<span class="hljs-variable">&lt;string, any&gt;</span> = {};<br>    selectedIds.<span class="hljs-keyword">for</span>Each(id =&gt; {<br>      <span class="hljs-keyword">const</span> el = elements[id];<br>      if (el) {<br>        initialMap[id] = {<br>          x: el.x,<br>          y: el.y,<br>          width: el.width,<br>          height: el.height,<br>          rotation: el.rotation || <span class="hljs-number">0</span>, // 确保你的 CanvasElement 类型里有 rotation<br>          // 记录元素自身的中心点，方便后续计算<br>          cx: el.x + el.width / <span class="hljs-number">2</span>,<br>          cy: el.y + el.height / <span class="hljs-number">2</span><br>        };<br>      }<br>    });<br>    this.<span class="hljs-keyword">state</span>.rotationInitialStates = initialMap;<br><br>    undoRedoManager.lock();<br>    console.<span class="hljs-keyword">log</span>('[StageManager] 开始旋转操作');<br>    return;<br>  }<br><br>  // ... 原有的 resizing 逻辑保持不变 ...<br>  this.<span class="hljs-keyword">state</span>.mode = 'resizing';<br>  // ...<br>}<br></code></pre></td></tr></table></figure>
<h3 id="第四步：处理-onPointerMove-旋转进行中"><a href="#第四步：处理-onPointerMove-旋转进行中" class="headerlink" title="第四步：处理 onPointerMove (旋转进行中)"></a>第四步：处理 onPointerMove (旋转进行中)</h3><p>修改 onPointerMove，增加 rotating 模式的处理逻辑。</p>
<p>codeTypeScript</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 修改 onPointerMove 方法</span><br><span class="hljs-keyword">private</span> onPointerMove = (e: PIXI.FederatedPointerEvent) =&gt; {<br>  <span class="hljs-keyword">this</span>.triggerDebounceSnapshot();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'idle'</span>) <span class="hljs-keyword">return</span>;<br>  <br>  <span class="hljs-keyword">const</span> currentPos = e.getLocalPosition(<span class="hljs-keyword">this</span>.viewport);<br>  <span class="hljs-keyword">const</span> state = useStore.getState();<br><br>  <span class="hljs-comment">// ... selecting, dragging, resizing 等现有逻辑 ...</span><br><br>  <span class="hljs-comment">// === [新增] 旋转逻辑 ===</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationInitialStates &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationCenter) {<br>    <span class="hljs-keyword">const</span> { x: cx, y: cy } = <span class="hljs-keyword">this</span>.state.rotationCenter;<br>    <br>    <span class="hljs-comment">// 1. 计算当前鼠标角度</span><br>    <span class="hljs-keyword">const</span> currentAngle = Math.atan2(currentPos.y - cy, currentPos.x - cx);<br>    <br>    <span class="hljs-comment">// 2. 计算旋转增量（当前角度 - 起始角度）</span><br>    <span class="hljs-keyword">const</span> deltaAngle = currentAngle - <span class="hljs-keyword">this</span>.state.startRotationAngle;<br><br>    <span class="hljs-comment">// 3. 更新每一个选中元素</span><br>    state.selectedIds.forEach(id =&gt; {<br>      <span class="hljs-keyword">const</span> initEl = <span class="hljs-keyword">this</span>.state.rotationInitialStates![id];<br>      <span class="hljs-keyword">if</span> (!initEl) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// A. 计算新的自转角度</span><br>      <span class="hljs-keyword">const</span> newRotation = initEl.rotation + deltaAngle;<br><br>      <span class="hljs-comment">// B. 计算新的位置 (公转)</span><br>      <span class="hljs-comment">// 将元素的中心点 (initEl.cx, initEl.cy) 绕着 组中心 (cx, cy) 旋转 deltaAngle</span><br>      <span class="hljs-keyword">const</span> newCenter = <span class="hljs-keyword">this</span>.rotatePoint(initEl.cx, initEl.cy, cx, cy, deltaAngle);<br><br>      <span class="hljs-comment">// C. 根据新的中心点反推 x, y (x = center.x - width/2)</span><br>      <span class="hljs-keyword">const</span> newX = newCenter.x - initEl.width / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">const</span> newY = newCenter.y - initEl.height / <span class="hljs-number">2</span>;<br><br>      <span class="hljs-comment">// D. 更新 Store</span><br>      state.updateElement(id, {<br>        x: newX,<br>        y: newY,<br>        rotation: newRotation<br>      });<br>    });<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// ... drawing 逻辑 ...</span><br>}<br></code></pre></td></tr></table></figure>
<h3 id="第五步：处理-onPointerUp-结束旋转并记录历史"><a href="#第五步：处理-onPointerUp-结束旋转并记录历史" class="headerlink" title="第五步：处理 onPointerUp (结束旋转并记录历史)"></a>第五步：处理 onPointerUp (结束旋转并记录历史)</h3><p>在 onPointerUp 中处理旋转结束，生成 Undo/Redo 命令。</p>
<p>codeTypeScript</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 修改 onPointerUp 方法</span><br><span class="hljs-keyword">private</span> onPointerUp = () =&gt; {<br>  <span class="hljs-keyword">this</span>.triggerDebounceSnapshot();<br>  <span class="hljs-keyword">const</span> state = useStore.getState();<br><br>  <span class="hljs-comment">// ... erasing, selecting, drawing, dragging 等逻辑 ...</span><br><br>  <span class="hljs-comment">// === [新增] 旋转结束逻辑 ===</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationInitialStates) {<br>    console.log(<span class="hljs-string">'[StageManager] 结束旋转操作'</span>);<br>    undoRedoManager.unlock();<br><br>    <span class="hljs-keyword">const</span> operations: any[] = [];<br><br>    Object.entries(<span class="hljs-keyword">this</span>.state.rotationInitialStates).forEach(([id, initialAttrs]) =&gt; {<br>      <span class="hljs-keyword">const</span> finalElement = state.elements[id];<br>      <span class="hljs-keyword">if</span> (!finalElement) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 获取最终状态</span><br>      <span class="hljs-keyword">const</span> finalAttrs = {<br>        x: finalElement.x,<br>        y: finalElement.y,<br>        rotation: finalElement.rotation || <span class="hljs-number">0</span><br>      };<br><br>      <span class="hljs-comment">// 检查是否有变化 (对比 x, y, rotation)</span><br>      <span class="hljs-comment">// 注意：即使只是自转，x/y 也可能因为精度问题微变，或者如果是多选旋转，x/y 必然变</span><br>      <span class="hljs-keyword">const</span> hasChanged = <br>        Math.abs(initialAttrs.x - finalAttrs.x) &gt; <span class="hljs-number">0.01</span> ||<br>        Math.abs(initialAttrs.y - finalAttrs.y) &gt; <span class="hljs-number">0.01</span> ||<br>        Math.abs(initialAttrs.rotation - finalAttrs.rotation) &gt; <span class="hljs-number">0.001</span>;<br><br>      <span class="hljs-keyword">if</span> (hasChanged) {<br>        operations.push({<br>          id,<br>          initialAttrs: { x: initialAttrs.x, y: initialAttrs.y, rotation: initialAttrs.rotation },<br>          finalAttrs<br>        });<br>      }<br>    });<br><br>    <span class="hljs-keyword">if</span> (operations.length &gt; <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">const</span> rotateCommand = new UpdateElementCommand(operations, <span class="hljs-string">'旋转元素'</span>);<br>      undoRedoManager.executeCommand(rotateCommand);<br>    }<br>  }<br><br>  <span class="hljs-comment">// ... resizing 逻辑 ...</span><br>  <br>  <span class="hljs-comment">// 清理状态</span><br>  <span class="hljs-keyword">this</span>.state.mode = <span class="hljs-string">'idle'</span>;<br>  <span class="hljs-keyword">this</span>.state.currentId = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.activeHandle = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialElementState = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialElementsMap = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialGroupBounds = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.resizeInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.dragInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// [新增] 清理旋转状态</span><br>  <span class="hljs-keyword">this</span>.state.rotationInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.rotationCenter = <span class="hljs-literal">null</span>;<br>}<br></code></pre></td></tr></table></figure>
<h3 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h3><ol>
<li><p><strong>公转与自转</strong>：</p>
<ul>
<li><p>如果是<strong>单个元素</strong>被选中，计算出的 rotationCenter 就是该元素中心，公式依然成立（点绕自己旋转位置不变，只有 rotation 属性在变）。</p>
</li>
<li><p>如果是<strong>多个元素</strong>，它们会围绕整体的包围盒中心（Group Center）进行旋转，这实现了符合直觉的群组旋转效果。</p>
</li>
</ul>
</li>
<li><p><strong>CanvasElement 类型</strong>：<br> 请确保你的 CanvasElement 接口定义里加入了 rotation?: number 字段。<br> 同时，在渲染器 ElementRenderer 中，渲染 Sprite 或 Container 时，需要应用这个 rotation：</p>
<p> codeTypeScript</p>
 <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 在 ElementRenderer.ts 中</span><br><span class="hljs-comment">// Pixi 的 rotation 是以弧度为单位，且默认绕左上角旋转。</span><br><span class="hljs-comment">// 为了让元素绕中心旋转，通常做法是：</span><br><span class="hljs-comment">// 1. 设置 anchor 为 0.5 (Sprite) 或 pivot 为 width/2, height/2 (Graphics/Container)</span><br><span class="hljs-comment">// 2. 将 position 设置为 x + width/2, y + height/2</span><br><span class="hljs-comment">// 或者保持现有逻辑 (x,y在左上角)，但渲染时做矩阵变换。</span><br><br><span class="hljs-comment">// 推荐做法（在 renderElements 循环中）：</span><br>elementContainer.rotation = element.rotation || <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 注意：如果单纯设置 rotation，它会绕着 (x, y) 即左上角旋转。</span><br><span class="hljs-comment">// 如果要绕中心旋转，需要设置 pivot:</span><br>elementContainer.pivot.<span class="hljs-built_in">set</span>(element.width / <span class="hljs-number">2</span>, element.height / <span class="hljs-number">2</span>);<br>elementContainer.position.<span class="hljs-built_in">set</span>(element.x + element.width / <span class="hljs-number">2</span>, element.y + element.height / <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
<p> 注意：如果你修改了渲染器的 pivot/position 逻辑，可能会影响到上面的 onPointerMove 里的坐标计算逻辑。我上面给出的 StageManagerCore 代码是基于 <strong>x, y 始终代表左上角坐标</strong> 这一假设编写的（这是最通用的做法）。只要渲染器能正确根据左上角坐标 + 旋转角度绘制出绕中心旋转的图形即可。</p>
</li>
<li><p><strong>TransformerRenderer</strong>：<br> 你需要去 TransformerRenderer 里添加绘制一个连接到包围盒顶部的线和小圆圈，并给这个小圆圈设置 label = ‘handle:rotate’ 或者在事件传递时传出 rotate 类型，以便 onHandleDown 能识别。</p>
</li>
</ol>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/15722.html">← Next 2025-11-22- 关于前端包管理器npm,pnpm,yarn和bun以及我为何选择后者</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/39691.html">2025-11-21-canvas设计项目杂记其二 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97%E5%92%8C%E6%92%A4%E9%94%80%E6%A0%88%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">操作序列和撤销栈状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">初始状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0A"><span class="toc-number">1.2.</span> <span class="toc-text">1. 创建元素A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%BB%E5%8A%A8A%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">2. 移动A到一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0B"><span class="toc-number">1.4.</span> <span class="toc-text">3. 创建元素B</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%A9%E6%94%BEB%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.5.</span> <span class="toc-text">4. 缩放B到一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%A7%BB%E5%8A%A8B%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.6.</span> <span class="toc-text">5. 移动B到一个位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">执行撤销操作时的状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E7%A7%BB%E5%8A%A8B%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">第一次撤销（移动B操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E7%BC%A9%E6%94%BEB%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">第二次撤销（缩放B操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E5%88%9B%E5%BB%BAB%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">第三次撤销（创建B操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E7%A7%BB%E5%8A%A8A%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">第四次撤销（移动A操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E5%88%9B%E5%BB%BAA%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">第五次撤销（创建A操作）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%EF%BC%88%E6%8B%96%E6%8B%BD%EF%BC%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">元素移动（拖拽）实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%BC%A9%E6%94%BE%EF%BC%88%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F%EF%BC%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">元素缩放（调整大小）实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">关键类和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">第一步：修改类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%A6%E9%80%BB%E8%BE%91-%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">第二步：实现旋转数学逻辑 (辅助方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86-onHandleDown-%E5%BC%80%E5%A7%8B%E6%97%8B%E8%BD%AC"><span class="toc-number">5.3.</span> <span class="toc-text">第三步：处理 onHandleDown (开始旋转)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86-onPointerMove-%E6%97%8B%E8%BD%AC%E8%BF%9B%E8%A1%8C%E4%B8%AD"><span class="toc-number">5.4.</span> <span class="toc-text">第四步：处理 onPointerMove (旋转进行中)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86-onPointerUp-%E7%BB%93%E6%9D%9F%E6%97%8B%E8%BD%AC%E5%B9%B6%E8%AE%B0%E5%BD%95%E5%8E%86%E5%8F%B2"><span class="toc-number">5.5.</span> <span class="toc-text">第五步：处理 onPointerUp (结束旋转并记录历史)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">5.6.</span> <span class="toc-text">关键点说明</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>