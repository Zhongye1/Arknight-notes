<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>2025-11-22-canvas状态管理杂记其三 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>2025-11-22-canvas状态管理杂记其三</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-11-22T08:43:45.000Z" id="date"> 2025-11-22</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-11-24T10:19:45.055Z" id="updated"> 2025-11-24</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><p>撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：</p>
<ol>
<li><p><strong>快照命令（SnapshotCommand）</strong>：</p>
<ul>
<li>用于记录整个画布状态的变化</li>
<li>通常用于添加元素、删除元素等较大范围的操作</li>
<li>保存完整的状态快照</li>
</ul>
</li>
<li><p><strong>更新元素命令（UpdateElementCommand）</strong>：</p>
<ul>
<li>用于记录特定元素的属性变化</li>
<li>主要用于拖拽移动和调整大小操作</li>
<li>只保存相关元素的特定属性变化</li>
</ul>
</li>
</ol>
<h2 id="操作序列和撤销栈状态变化"><a href="#操作序列和撤销栈状态变化" class="headerlink" title="操作序列和撤销栈状态变化"></a>操作序列和撤销栈状态变化</h2><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>撤销栈：空 重做栈：空</p>
<h3 id="1-创建元素A"><a href="#1-创建元素A" class="headerlink" title="1. 创建元素A"></a>1. 创建元素A</h3><p>当创建元素A时，系统会生成一个快照命令，记录整个画布状态的变化。</p>
<p>撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：空</p>
<h3 id="2-移动A到一个位置"><a href="#2-移动A到一个位置" class="headerlink" title="2. 移动A到一个位置"></a>2. 移动A到一个位置</h3><p>当移动元素A时，系统会生成一个更新元素命令（UpdateElementCommand），只记录A元素位置的变化。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：空</p>
<h3 id="3-创建元素B"><a href="#3-创建元素B" class="headerlink" title="3. 创建元素B"></a>3. 创建元素B</h3><p>当创建元素B时，系统会生成另一个快照命令，记录添加B元素后的状态。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：空</p>
<h3 id="4-缩放B到一个位置"><a href="#4-缩放B到一个位置" class="headerlink" title="4. 缩放B到一个位置"></a>4. 缩放B到一个位置</h3><p>当缩放元素B时，系统会生成一个更新元素命令，记录B元素尺寸和位置的变化。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：空</p>
<h3 id="5-移动B到一个位置"><a href="#5-移动B到一个位置" class="headerlink" title="5. 移动B到一个位置"></a>5. 移动B到一个位置</h3><p>当再次移动元素B时，系统会生成另一个更新元素命令，记录B元素位置的新变化。</p>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5) 重做栈：空</p>
<h2 id="执行撤销操作时的状态变化"><a href="#执行撤销操作时的状态变化" class="headerlink" title="执行撤销操作时的状态变化"></a>执行撤销操作时的状态变化</h2><h3 id="第一次撤销（移动B操作）"><a href="#第一次撤销（移动B操作）" class="headerlink" title="第一次撤销（移动B操作）"></a>第一次撤销（移动B操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB</li>
<li>执行该命令的undo()方法，将B元素恢复到缩放后的位置</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：[UpdateElementCommand_MoveB] (大小: 1)</p>
<h3 id="第二次撤销（缩放B操作）"><a href="#第二次撤销（缩放B操作）" class="headerlink" title="第二次撤销（缩放B操作）"></a>第二次撤销（缩放B操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB</li>
<li>执行该命令的undo()方法，将B元素恢复到刚创建时的尺寸和位置</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)</p>
<h3 id="第三次撤销（创建B操作）"><a href="#第三次撤销（创建B操作）" class="headerlink" title="第三次撤销（创建B操作）"></a>第三次撤销（创建B操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：SnapshotCommand_B</li>
<li>执行该命令的undo()方法，将整个画布状态恢复到创建B之前的状态（即只包含A元素的状态）</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)</p>
<h3 id="第四次撤销（移动A操作）"><a href="#第四次撤销（移动A操作）" class="headerlink" title="第四次撤销（移动A操作）"></a>第四次撤销（移动A操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA</li>
<li>执行该命令的undo()方法，将A元素恢复到初始位置</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)</p>
<h3 id="第五次撤销（创建A操作）"><a href="#第五次撤销（创建A操作）" class="headerlink" title="第五次撤销（创建A操作）"></a>第五次撤销（创建A操作）</h3><ol>
<li>从撤销栈弹出最后一个命令：SnapshotCommand_A</li>
<li>执行该命令的undo()方法，将整个画布状态恢复到初始状态（空画布）</li>
<li>将该命令推入重做栈</li>
</ol>
<p>撤销栈：空 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)</p>
<p><code>undoRedoManager.lock()</code> 锁定管理器</p>
<hr>
<p>redo问题</p>
<ol>
<li><p><strong>状态快照不完整</strong>：当创建元素时，状态快照可能在元素完全初始化之前就被捕获了，导致元素的width、height等属性为默认值（可能是0）。</p>
</li>
<li><p><strong>引用问题</strong>：虽然使用了深拷贝，但是在某些情况下，元素对象可能在快照创建后又被修改，导致快照中的数据不是预期的值。</p>
</li>
<li><p><strong>异步更新问题</strong>：元素创建和状态更新之间可能存在异步延迟，导致快照捕捉到了中间状态而非最终状态。</p>
</li>
</ol>
<p>需要确保在创建状态快照时，所有元素都已经完全初始化，并且使用可靠的方法进行深拷贝。</p>
<p>修复当用户执行 Undo 后再 Redo 时，恢复的是最初 width:0, height:0 的状态，导致元素不可见的问题，修复日志里“type: ‘未知操作’” 和 “重做无效”的问题，在绘制结束（onPointerUp）时，更新历史栈顶那个“创建命令”的 nextState，将其替换为绘制完成后的最终状态</p>
<hr>
<h2 id="元素移动（拖拽）实现"><a href="#元素移动（拖拽）实现" class="headerlink" title="元素移动（拖拽）实现"></a>元素移动（拖拽）实现</h2><p>元素的移动主要在 StageManagerCore.ts 文件中实现：</p>
<ol>
<li><p><strong>开始拖拽</strong>：</p>
<ul>
<li>在 onPointerDown 方法中检测到点击的是已选中的元素时，将模式设置为 dragging</li>
<li>记录所有选中元素的初始状态到 dragInitialStates 中</li>
</ul>
</li>
<li><p><strong>拖拽过程中</strong>：</p>
<ul>
<li>在 onPointerMove 方法中，当 mode 为 dragging 时，计算位移并更新元素位置</li>
<li>通过调用 <code>state.updateElement(id, { x: el.x + dx, y: el.y + dy })</code> 来更新元素坐标</li>
</ul>
</li>
<li><p><strong>结束拖拽</strong>：</p>
<ul>
<li>在 onPointerUp 方法中处理拖拽结束逻辑</li>
<li>创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中</li>
</ul>
</li>
</ol>
<h2 id="元素缩放（调整大小）实现"><a href="#元素缩放（调整大小）实现" class="headerlink" title="元素缩放（调整大小）实现"></a>元素缩放（调整大小）实现</h2><p>元素的缩放也在 StageManagerCore.ts 文件中实现：</p>
<ol>
<li><p><strong>开始缩放</strong>：</p>
<ul>
<li>在 onHandleDown 方法中处理控制点按下事件</li>
<li>将模式设置为 resizing</li>
<li>记录所有选中元素的初始状态到 resizeInitialStates 和 initialElementsMap 中</li>
<li>计算初始包围盒并存储在 initialGroupBounds 中</li>
</ul>
</li>
<li><p><strong>缩放过程中</strong>：</p>
<ul>
<li>在 onPointerMove 方法中，当 mode 为 resizing 时处理缩放逻辑</li>
<li>对于普通元素，基于初始包围盒和鼠标位移重新计算元素的位置和大小</li>
<li>对于线条和箭头等特殊元素，单独处理端点的拖拽</li>
</ul>
</li>
<li><p><strong>结束缩放</strong>：</p>
<ul>
<li>在 onPointerUp 方法中处理缩放结束逻辑</li>
<li>创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中</li>
</ul>
</li>
</ol>
<h2 id="关键类和文件"><a href="#关键类和文件" class="headerlink" title="关键类和文件"></a>关键类和文件</h2><ol>
<li><strong>StageManagerCore.ts</strong> - 核心逻辑实现</li>
<li><strong>TransformerRenderer.ts</strong> - 渲染选中元素的控制手柄</li>
<li><strong>UpdateElementCommand.ts</strong> - 撤销/重做命令实现</li>
<li><strong>UndoRedoManager.ts</strong> - 撤销/重做管理器</li>
</ol>
<p>总的来说，元素的移动和缩放操作都是通过 StageManagerCore 类统一管理和处理的，该类负责监听鼠标事件并根据当前模式执行相应的操作。</p>
<p>实现元素旋转功能需要涉及三个主要部分的修改：</p>
<ol>
<li><p><strong>数据模型与状态定义</strong>：支持 rotation 属性和旋转时的临时状态。</p>
</li>
<li><p><strong>交互逻辑 (Math)</strong>：处理单个元素旋转和多选组的旋转（组旋转需要处理“公转”和“自转”）。</p>
</li>
<li><p><strong>渲染器支持</strong>：虽然这里主要改 StageManagerCore，但你需要确保 TransformerRenderer 能渲染出旋转手柄（通常位于选中框顶部的延长线上）。</p>
</li>
</ol>
<p>以下是具体的实现步骤和代码修改。</p>
<h3 id="第一步：修改类型定义"><a href="#第一步：修改类型定义" class="headerlink" title="第一步：修改类型定义"></a>第一步：修改类型定义</h3><p>在 types.ts 或 StageManagerCore.ts 的状态定义中，增加旋转相关的临时状态。</p>
<p>codeTypeScript</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerState 接口中添加：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StageManagerState</span> {<br>  <span class="hljs-comment">// ... 原有属性</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">'idle'</span> | <span class="hljs-string">'dragging'</span> | <span class="hljs-string">'resizing'</span> | <span class="hljs-string">'selecting'</span> | <span class="hljs-string">'drawing'</span> | <span class="hljs-string">'erasing'</span> | <span class="hljs-string">'rotating'</span>; <span class="hljs-comment">// [修改] 添加 rotating</span><br><br>  <span class="hljs-comment">// [新增] 旋转相关状态</span><br>  <span class="hljs-attr">rotationInitialStates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, { <br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">rotation</span>: <span class="hljs-built_in">number</span>; <br>    <span class="hljs-attr">cx</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素中心点 x</span><br>    <span class="hljs-attr">cy</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素中心点 y</span><br>  }&gt; | <span class="hljs-literal">null</span>;<br>  <span class="hljs-attr">rotationCenter</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 旋转中心（群组中心或单元素中心）</span><br>  <span class="hljs-attr">startRotationAngle</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 鼠标按下时的初始角度</span><br>}<br></code></pre></td></tr></table></figure>
<h3 id="第二步：实现旋转数学逻辑-辅助方法"><a href="#第二步：实现旋转数学逻辑-辅助方法" class="headerlink" title="第二步：实现旋转数学逻辑 (辅助方法)"></a>第二步：实现旋转数学逻辑 (辅助方法)</h3><p>在 StageManagerCore 类中添加一个用于计算旋转后坐标的辅助方法。</p>
<p>codeTypeScript</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在 StageManagerCore 类中添加</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算点绕中心旋转后的新坐标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x 点的 x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> y 点的 y</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cx 中心点 x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cy 中心点 y</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> angle 旋转角度 (弧度)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">rotatePoint</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">cx</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">cy</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">angle</span>: <span class="hljs-built_in">number</span></span>) {<br>  <span class="hljs-keyword">const</span> cos = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(angle);<br>  <span class="hljs-keyword">const</span> sin = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(angle);<br>  <span class="hljs-keyword">const</span> nx = (cos * (x - cx)) - (sin * (y - cy)) + cx;<br>  <span class="hljs-keyword">const</span> ny = (sin * (x - cx)) + (cos * (y - cy)) + cy;<br>  <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: nx, <span class="hljs-attr">y</span>: ny };<br>}<br></code></pre></td></tr></table></figure>
<h3 id="第三步：处理-onHandleDown-开始旋转"><a href="#第三步：处理-onHandleDown-开始旋转" class="headerlink" title="第三步：处理 onHandleDown (开始旋转)"></a>第三步：处理 onHandleDown (开始旋转)</h3><p>你需要修改 onHandleDown 方法。首先，你需要在 TransformerRenderer 中定义一个 ID 为 rotate 的手柄。当捕获到该手柄时，初始化旋转状态。</p>
<p>codeTypeScript</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 修改 <span class="hljs-keyword">on</span>HandleDown 方法<br>private <span class="hljs-keyword">on</span>HandleDown = (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1' | 'rotate', elementId: string) =&gt; {<br>  this.triggerDebounceSnapshot();<br>  e.stopPropagation();<br><br>  // === [新增] 旋转逻辑分支 ===<br>  if (handle === 'rotate') {<br>    this.<span class="hljs-keyword">state</span>.mode = 'rotating';<br>    this.<span class="hljs-keyword">state</span>.currentId = elementId;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = useStore.getState();<br>    <span class="hljs-keyword">const</span> { elements, selectedIds } = <span class="hljs-keyword">state</span>;<br>    <span class="hljs-keyword">const</span> mouseP<span class="hljs-keyword">os</span> = e.getLocalPosition(this.viewport);<br><br>    // <span class="hljs-number">1</span>. 计算旋转中心（选中元素的包围盒中心）<br>    <span class="hljs-keyword">const</span> bounds = this.getSelectionBounds(selectedIds, elements);<br>    if (!bounds) return;<br>    <br>    <span class="hljs-keyword">const</span> centerX = bounds.x + bounds.width / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">const</span> centerY = bounds.y + bounds.height / <span class="hljs-number">2</span>;<br>    this.<span class="hljs-keyword">state</span>.rotationCenter = { x: centerX, y: centerY };<br><br>    // <span class="hljs-number">2</span>. 计算鼠标起始角度（相对于中心点）<br>    this.<span class="hljs-keyword">state</span>.startRotationAngle = Math.atan2(mouseP<span class="hljs-keyword">os</span>.y - centerY, mouseP<span class="hljs-keyword">os</span>.x - centerX);<br><br>    // <span class="hljs-number">3</span>. 记录所有选中元素的初始状态<br>    <span class="hljs-keyword">const</span> initialMap: Record<span class="hljs-variable">&lt;string, any&gt;</span> = {};<br>    selectedIds.<span class="hljs-keyword">for</span>Each(id =&gt; {<br>      <span class="hljs-keyword">const</span> el = elements[id];<br>      if (el) {<br>        initialMap[id] = {<br>          x: el.x,<br>          y: el.y,<br>          width: el.width,<br>          height: el.height,<br>          rotation: el.rotation || <span class="hljs-number">0</span>, // 确保你的 CanvasElement 类型里有 rotation<br>          // 记录元素自身的中心点，方便后续计算<br>          cx: el.x + el.width / <span class="hljs-number">2</span>,<br>          cy: el.y + el.height / <span class="hljs-number">2</span><br>        };<br>      }<br>    });<br>    this.<span class="hljs-keyword">state</span>.rotationInitialStates = initialMap;<br><br>    undoRedoManager.lock();<br>    console.<span class="hljs-keyword">log</span>('[StageManager] 开始旋转操作');<br>    return;<br>  }<br><br>  // ... 原有的 resizing 逻辑保持不变 ...<br>  this.<span class="hljs-keyword">state</span>.mode = 'resizing';<br>  // ...<br>}<br></code></pre></td></tr></table></figure>
<h3 id="第四步：处理-onPointerMove-旋转进行中"><a href="#第四步：处理-onPointerMove-旋转进行中" class="headerlink" title="第四步：处理 onPointerMove (旋转进行中)"></a>第四步：处理 onPointerMove (旋转进行中)</h3><p>修改 onPointerMove，增加 rotating 模式的处理逻辑。</p>
<p>codeTypeScript</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 修改 onPointerMove 方法</span><br><span class="hljs-keyword">private</span> onPointerMove = (e: PIXI.FederatedPointerEvent) =&gt; {<br>  <span class="hljs-keyword">this</span>.triggerDebounceSnapshot();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'idle'</span>) <span class="hljs-keyword">return</span>;<br>  <br>  <span class="hljs-keyword">const</span> currentPos = e.getLocalPosition(<span class="hljs-keyword">this</span>.viewport);<br>  <span class="hljs-keyword">const</span> state = useStore.getState();<br><br>  <span class="hljs-comment">// ... selecting, dragging, resizing 等现有逻辑 ...</span><br><br>  <span class="hljs-comment">// === [新增] 旋转逻辑 ===</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationInitialStates &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationCenter) {<br>    <span class="hljs-keyword">const</span> { x: cx, y: cy } = <span class="hljs-keyword">this</span>.state.rotationCenter;<br>    <br>    <span class="hljs-comment">// 1. 计算当前鼠标角度</span><br>    <span class="hljs-keyword">const</span> currentAngle = Math.atan2(currentPos.y - cy, currentPos.x - cx);<br>    <br>    <span class="hljs-comment">// 2. 计算旋转增量（当前角度 - 起始角度）</span><br>    <span class="hljs-keyword">const</span> deltaAngle = currentAngle - <span class="hljs-keyword">this</span>.state.startRotationAngle;<br><br>    <span class="hljs-comment">// 3. 更新每一个选中元素</span><br>    state.selectedIds.forEach(id =&gt; {<br>      <span class="hljs-keyword">const</span> initEl = <span class="hljs-keyword">this</span>.state.rotationInitialStates![id];<br>      <span class="hljs-keyword">if</span> (!initEl) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// A. 计算新的自转角度</span><br>      <span class="hljs-keyword">const</span> newRotation = initEl.rotation + deltaAngle;<br><br>      <span class="hljs-comment">// B. 计算新的位置 (公转)</span><br>      <span class="hljs-comment">// 将元素的中心点 (initEl.cx, initEl.cy) 绕着 组中心 (cx, cy) 旋转 deltaAngle</span><br>      <span class="hljs-keyword">const</span> newCenter = <span class="hljs-keyword">this</span>.rotatePoint(initEl.cx, initEl.cy, cx, cy, deltaAngle);<br><br>      <span class="hljs-comment">// C. 根据新的中心点反推 x, y (x = center.x - width/2)</span><br>      <span class="hljs-keyword">const</span> newX = newCenter.x - initEl.width / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">const</span> newY = newCenter.y - initEl.height / <span class="hljs-number">2</span>;<br><br>      <span class="hljs-comment">// D. 更新 Store</span><br>      state.updateElement(id, {<br>        x: newX,<br>        y: newY,<br>        rotation: newRotation<br>      });<br>    });<br>    <span class="hljs-keyword">return</span>;<br>  }<br><br>  <span class="hljs-comment">// ... drawing 逻辑 ...</span><br>}<br></code></pre></td></tr></table></figure>
<h3 id="第五步：处理-onPointerUp-结束旋转并记录历史"><a href="#第五步：处理-onPointerUp-结束旋转并记录历史" class="headerlink" title="第五步：处理 onPointerUp (结束旋转并记录历史)"></a>第五步：处理 onPointerUp (结束旋转并记录历史)</h3><p>在 onPointerUp 中处理旋转结束，生成 Undo/Redo 命令。</p>
<p>codeTypeScript</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 修改 onPointerUp 方法</span><br><span class="hljs-keyword">private</span> onPointerUp = () =&gt; {<br>  <span class="hljs-keyword">this</span>.triggerDebounceSnapshot();<br>  <span class="hljs-keyword">const</span> state = useStore.getState();<br><br>  <span class="hljs-comment">// ... erasing, selecting, drawing, dragging 等逻辑 ...</span><br><br>  <span class="hljs-comment">// === [新增] 旋转结束逻辑 ===</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> &amp;&amp; <span class="hljs-keyword">this</span>.state.rotationInitialStates) {<br>    console.log(<span class="hljs-string">'[StageManager] 结束旋转操作'</span>);<br>    undoRedoManager.unlock();<br><br>    <span class="hljs-keyword">const</span> operations: any[] = [];<br><br>    Object.entries(<span class="hljs-keyword">this</span>.state.rotationInitialStates).forEach(([id, initialAttrs]) =&gt; {<br>      <span class="hljs-keyword">const</span> finalElement = state.elements[id];<br>      <span class="hljs-keyword">if</span> (!finalElement) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 获取最终状态</span><br>      <span class="hljs-keyword">const</span> finalAttrs = {<br>        x: finalElement.x,<br>        y: finalElement.y,<br>        rotation: finalElement.rotation || <span class="hljs-number">0</span><br>      };<br><br>      <span class="hljs-comment">// 检查是否有变化 (对比 x, y, rotation)</span><br>      <span class="hljs-comment">// 注意：即使只是自转，x/y 也可能因为精度问题微变，或者如果是多选旋转，x/y 必然变</span><br>      <span class="hljs-keyword">const</span> hasChanged = <br>        Math.abs(initialAttrs.x - finalAttrs.x) &gt; <span class="hljs-number">0.01</span> ||<br>        Math.abs(initialAttrs.y - finalAttrs.y) &gt; <span class="hljs-number">0.01</span> ||<br>        Math.abs(initialAttrs.rotation - finalAttrs.rotation) &gt; <span class="hljs-number">0.001</span>;<br><br>      <span class="hljs-keyword">if</span> (hasChanged) {<br>        operations.push({<br>          id,<br>          initialAttrs: { x: initialAttrs.x, y: initialAttrs.y, rotation: initialAttrs.rotation },<br>          finalAttrs<br>        });<br>      }<br>    });<br><br>    <span class="hljs-keyword">if</span> (operations.length &gt; <span class="hljs-number">0</span>) {<br>      <span class="hljs-keyword">const</span> rotateCommand = new UpdateElementCommand(operations, <span class="hljs-string">'旋转元素'</span>);<br>      undoRedoManager.executeCommand(rotateCommand);<br>    }<br>  }<br><br>  <span class="hljs-comment">// ... resizing 逻辑 ...</span><br>  <br>  <span class="hljs-comment">// 清理状态</span><br>  <span class="hljs-keyword">this</span>.state.mode = <span class="hljs-string">'idle'</span>;<br>  <span class="hljs-keyword">this</span>.state.currentId = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.activeHandle = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialElementState = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialElementsMap = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.initialGroupBounds = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.resizeInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.dragInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// [新增] 清理旋转状态</span><br>  <span class="hljs-keyword">this</span>.state.rotationInitialStates = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">this</span>.state.rotationCenter = <span class="hljs-literal">null</span>;<br>}<br></code></pre></td></tr></table></figure>
<h3 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h3><ol>
<li><p><strong>公转与自转</strong>：</p>
<ul>
<li><p>如果是<strong>单个元素</strong>被选中，计算出的 rotationCenter 就是该元素中心，公式依然成立（点绕自己旋转位置不变，只有 rotation 属性在变）。</p>
</li>
<li><p>如果是<strong>多个元素</strong>，它们会围绕整体的包围盒中心（Group Center）进行旋转，这实现了符合直觉的群组旋转效果。</p>
</li>
</ul>
</li>
<li><p><strong>CanvasElement 类型</strong>：<br> 请确保你的 CanvasElement 接口定义里加入了 rotation?: number 字段。<br> 同时，在渲染器 ElementRenderer 中，渲染 Sprite 或 Container 时，需要应用这个 rotation：</p>
<p> codeTypeScript</p>
 <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 在 ElementRenderer.ts 中</span><br><span class="hljs-comment">// Pixi 的 rotation 是以弧度为单位，且默认绕左上角旋转。</span><br><span class="hljs-comment">// 为了让元素绕中心旋转，通常做法是：</span><br><span class="hljs-comment">// 1. 设置 anchor 为 0.5 (Sprite) 或 pivot 为 width/2, height/2 (Graphics/Container)</span><br><span class="hljs-comment">// 2. 将 position 设置为 x + width/2, y + height/2</span><br><span class="hljs-comment">// 或者保持现有逻辑 (x,y在左上角)，但渲染时做矩阵变换。</span><br><br><span class="hljs-comment">// 推荐做法（在 renderElements 循环中）：</span><br>elementContainer.rotation = element.rotation || <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 注意：如果单纯设置 rotation，它会绕着 (x, y) 即左上角旋转。</span><br><span class="hljs-comment">// 如果要绕中心旋转，需要设置 pivot:</span><br>elementContainer.pivot.<span class="hljs-built_in">set</span>(element.width / <span class="hljs-number">2</span>, element.height / <span class="hljs-number">2</span>);<br>elementContainer.position.<span class="hljs-built_in">set</span>(element.x + element.width / <span class="hljs-number">2</span>, element.y + element.height / <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
<p> 注意：如果你修改了渲染器的 pivot/position 逻辑，可能会影响到上面的 onPointerMove 里的坐标计算逻辑。我上面给出的 StageManagerCore 代码是基于 <strong>x, y 始终代表左上角坐标</strong> 这一假设编写的（这是最通用的做法）。只要渲染器能正确根据左上角坐标 + 旋转角度绘制出绕中心旋转的图形即可。</p>
</li>
<li><p><strong>TransformerRenderer</strong>：<br> 你需要去 TransformerRenderer 里添加绘制一个连接到包围盒顶部的线和小圆圈，并给这个小圆圈设置 label = ‘handle:rotate’ 或者在事件传递时传出 rotate 类型，以便 onHandleDown 能识别。</p>
</li>
</ol>
<p>在当前的 StageManagerCore.ts 代码中，关于<strong>组（Group）的缩放（Resizing）</strong>逻辑存在几个显著的问题。这些问题会导致嵌套组操作失效、视觉样式错乱以及撤销/重做数据不一致。</p>
<p>以下是具体的问题分析及解决方案：</p>
<h3 id="1-缺乏递归支持（不支持嵌套组）"><a href="#1-缺乏递归支持（不支持嵌套组）" class="headerlink" title="1. 缺乏递归支持（不支持嵌套组）"></a>1. 缺乏递归支持（不支持嵌套组）</h3><p><strong>问题描述：</strong><br>代码中处理组缩放时，只遍历了当前组的一级子元素（actualGroupElement.children.forEach）。<br>如果组内包含了另一个组（嵌套组），内部的组会被移动和缩放，但内部组的<strong>子元素</strong>（孙子节点）完全不会被处理。</p>
<p><strong>后果：</strong><br>缩放一个包含组的组时，最内层的元素会“留在原地”或大小不变，导致布局彻底崩坏。</p>
<p><strong>代码位置：</strong><br>onPointerMove 和 onPointerUp 中的 if (initEl.type === ‘group’) 块。</p>
<p><strong>修复方案：</strong><br>需要提取一个递归函数来处理子元素的更新。</p>
<p>codeTypeScript</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 伪代码示例：递归更新逻辑<br>private updateGroupChildren recursively(<br>  <span class="hljs-keyword">group</span>Id: string, <br>  scaleX: number, <br>  scaleY: number, <br>  <span class="hljs-keyword">group</span>NewX: number, <br>  <span class="hljs-keyword">group</span>NewY: number, <br>  <span class="hljs-keyword">group</span>InitState: CanvasElement<br>) {<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">group</span> = this.<span class="hljs-keyword">state</span>.initialElementsMap[<span class="hljs-keyword">group</span>Id];<br>  // 遍历子元素<br>  <span class="hljs-keyword">group</span>.children.<span class="hljs-keyword">for</span>Each(childId =&gt; {<br>    <span class="hljs-keyword">const</span> childInit = this.<span class="hljs-keyword">state</span>.initialElementsMap[childId];<br>    <br>    // <span class="hljs-number">1</span>. 计算子元素新位置/大小 (保持现有逻辑)<br>    // ... Math ...<br>    <br>    // <span class="hljs-number">2</span>. 更新 Store<br>    <span class="hljs-keyword">state</span>.updateElement(childId, newAttrs);<br>    <br>    // <span class="hljs-number">3</span>. 关键：如果子元素也是组，递归调用<br>    if (childInit.type === '<span class="hljs-keyword">group</span>') {<br>       this.updateGroupChildren_recursively(childId, scaleX, scaleY, newChildX, newChildY, childInit);<br>    }<br>  });<br>}<br></code></pre></td></tr></table></figure>
<h3 id="2-样式属性未跟随缩放（文字和描边）"><a href="#2-样式属性未跟随缩放（文字和描边）" class="headerlink" title="2. 样式属性未跟随缩放（文字和描边）"></a>2. 样式属性未跟随缩放（文字和描边）</h3><p><strong>问题描述：</strong><br>当前的缩放逻辑只计算了 x, y, width, height 和 points。<br>但是，文字的 fontSize 和形状的 strokeWidth（描边宽度）没有被缩放。</p>
<p><strong>后果：</strong></p>
<ul>
<li><p><strong>缩小：</strong> 组被缩得很小时，文字依然巨大（溢出），描边依然很粗（变成一团色块）。</p>
</li>
<li><p><strong>放大：</strong> 组被放很大时，文字显得很小，描边显得极细。</p>
</li>
</ul>
<p><strong>修复方案：</strong><br>在计算子元素更新时，加入样式缩放。通常取 scaleX 和 scaleY 的平均值或最小值作为字体/描边的缩放倍率。</p>
<p>codeTypeScript</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 在 onPointerMove 的子元素循环中</span><br><span class="hljs-type">const</span> avgScale = (Math.<span class="hljs-built_in">abs</span>(scaleX) + Math.<span class="hljs-built_in">abs</span>(scaleY)) / <span class="hljs-number">2</span>;<br><br><span class="hljs-type">const</span> updatePayload: any = {<br>  x: newChildX,<br>  y: newChildY,<br>  width: newChildW,<br>  height: newChildH,<br>};<br><br><span class="hljs-comment">// [修复] 缩放字体</span><br><span class="hljs-keyword">if</span> (childInitEl.fontSize) {<br>  updatePayload.fontSize = childInitEl.fontSize * avgScale;<br>}<br><br><span class="hljs-comment">// [修复] 缩放描边</span><br><span class="hljs-keyword">if</span> (childInitEl.strokeWidth) {<br>  updatePayload.strokeWidth = childInitEl.strokeWidth * avgScale;<br>}<br></code></pre></td></tr></table></figure>
<h3 id="3-旋转元素的非等比缩放问题（数学偏差）"><a href="#3-旋转元素的非等比缩放问题（数学偏差）" class="headerlink" title="3. 旋转元素的非等比缩放问题（数学偏差）"></a>3. 旋转元素的非等比缩放问题（数学偏差）</h3><p><strong>问题描述：</strong><br>当前的逻辑是基于<strong>轴对齐包围盒 (AABB)</strong> 的比例来计算子元素位置的：<br>newChildX = finalElX + childRelX * finalElW</p>
<p>如果组内的某个子元素本身带有<strong>旋转角度 (rotation !== 0)</strong>，且用户进行了<strong>非等比缩放</strong>（例如只拉长宽度，不拉高度）：</p>
<ol>
<li><p>简单地改变旋转元素的 width 和 height 会导致图形变形（圆变椭圆是预期的，但旋转的矩形会变成菱形/切变，而 Canvas/Pixi 的 width/height 属性通常不支持切变，只会重置包围盒）。</p>
</li>
<li><p>元素的位置计算会发生漂移，因为旋转后的局部坐标系和组的世界坐标系不再对齐。</p>
</li>
</ol>
<p><strong>后果：</strong><br>如果组内有旋转过的元素，拉伸组会导致这些元素“飘”出正确的位置，或者形状扭曲方式不符合直觉。</p>
<p><strong>解决方案（复杂）：</strong><br>这是一个复杂的图形学问题。简单的解决方案是：<strong>当组内存在旋转元素时，强制锁定纵横比，禁止非等比缩放</strong>；或者在非等比缩放时，不改变子元素的旋转角度，只改变位置（这会导致视觉上的分离）。</p>
<h3 id="4-撤销-重做-Undo-Redo-记录不完整"><a href="#4-撤销-重做-Undo-Redo-记录不完整" class="headerlink" title="4. 撤销/重做 (Undo/Redo) 记录不完整"></a>4. 撤销/重做 (Undo/Redo) 记录不完整</h3><p><strong>问题描述：</strong><br>在 onPointerUp 中，你手动构建了 UpdateElementCommand。<br>与问题 1 类似，这里也只处理了一层子元素。</p>
<p>codeTypeScript</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 原代码</span><br><span class="hljs-keyword">if</span> (finalElement.type === <span class="hljs-string">'group'</span>) {<br>  <span class="hljs-keyword">const</span> groupElement = finalElement <span class="hljs-keyword">as</span> GroupElement;<br>  groupElement.children.forEach(childId =&gt; {<br>     <span class="hljs-comment">// 只记录了一层子元素</span><br>  })<br>}<br></code></pre></td></tr></table></figure>
<p><strong>后果：</strong><br>如果你缩放了一个嵌套组，然后点击撤销：</p>
<ol>
<li><p>最外层组恢复大小。</p>
</li>
<li><p>中间层组恢复大小。</p>
</li>
<li><p><strong>最内层元素保持缩放后的大小/位置</strong>。<br> 导致撤销操作“损坏”了画布状态。</p>
</li>
</ol>
<p><strong>修复方案：</strong><br>同样需要递归地收集所有子孙节点的 initialAttrs 和 finalAttrs 并推入 operations 数组。</p>
<h3 id="5-翻转处理的潜在-Bug"><a href="#5-翻转处理的潜在-Bug" class="headerlink" title="5. 翻转处理的潜在 Bug"></a>5. 翻转处理的潜在 Bug</h3><p><strong>问题描述：</strong><br>代码中有处理翻转的逻辑：</p>
<p>codeTypeScript</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">if (finalR &lt;<span class="hljs-keyword"> final</span>L) { [finalL,<span class="hljs-keyword"> final</span>R] = [finalR,<span class="hljs-keyword"> final</span>L] }<br></code></pre></td></tr></table></figure>
<p>这保证了 Group 的包围盒始终为正。但是，计算子元素位置的 scaleX 会变成负数吗？<br>const scaleX = … newBoundsW / initBounds.width<br>因为你手动交换了 L 和 R，newBoundsW 永远是正的，所以 scaleX 永远是正的。</p>
<p><strong>后果：</strong><br>当你把右边的手柄拖到左边（翻转）时，组的框会变正，但<strong>内部的子元素不会镜像翻转</strong>，它们只会挤压到一起然后再变宽（仿佛没有翻转过一样），或者位置计算错误。</p>
<p><strong>修复方案：</strong><br>不应该手动交换 finalL 和 finalR 来计算 scale。应该允许 newBoundsW 为负数（或者手动标记 flipX），从而算出负的 scaleX。<br>PixiJS 支持负的 scale.x，但你的数据模型是用 width/height (通常为正) 来驱动的。</p>
<ul>
<li>如果数据模型只允许正宽高：你需要检测翻转，并在计算子元素位置时，用 1 - childRelX 来替代 childRelX（如果是水平翻转）。</li>
</ul>
<hr>
<h3 id="总结与建议代码"><a href="#总结与建议代码" class="headerlink" title="总结与建议代码"></a>总结与建议代码</h3><p>为了修复最严重的<strong>递归</strong>和<strong>样式</strong>问题，建议重构 onPointerMove 和 onPointerUp 的相关逻辑。</p>
<p>建议在 Class 内部增加一个通用的递归处理方法：</p>
<p>codeTypeScript</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 辅助方法：递归获取所有需要更新的子节点状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">getGroupResizeUpdates</span>(<br>  <span class="hljs-attr">groupId</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">scaleX</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">scaleY</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-comment">// 组的新位置</span><br>  <span class="hljs-attr">groupX</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">groupY</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-comment">// 组的原始尺寸（用于计算相对位置）</span><br>  <span class="hljs-attr">groupInitX</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">groupInitY</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">groupInitW</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">groupInitH</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">elementsSnapshot</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; <span class="hljs-comment">// 传入 initialElementsMap</span><br>): <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; {<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">updates</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">CanvasElement</span>&gt;&gt; = {};<br>  <span class="hljs-keyword">const</span> groupEl = elementsSnapshot[groupId] <span class="hljs-keyword">as</span> <span class="hljs-title class_">GroupElement</span>;<br><br>  <span class="hljs-keyword">if</span> (!groupEl || !groupEl.<span class="hljs-property">children</span>) <span class="hljs-keyword">return</span> updates;<br><br>  groupEl.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">childId</span> =&gt;</span> {<br>    <span class="hljs-keyword">const</span> childInit = elementsSnapshot[childId];<br>    <span class="hljs-keyword">if</span> (!childInit) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 1. 计算相对比例</span><br>    <span class="hljs-keyword">const</span> relX = (childInit.<span class="hljs-property">x</span> - groupInitX) / groupInitW;<br>    <span class="hljs-keyword">const</span> relY = (childInit.<span class="hljs-property">y</span> - groupInitY) / groupInitH;<br>    <span class="hljs-keyword">const</span> relW = childInit.<span class="hljs-property">width</span> / groupInitW;<br>    <span class="hljs-keyword">const</span> relH = childInit.<span class="hljs-property">height</span> / groupInitH;<br><br>    <span class="hljs-comment">// 2. 计算新属性</span><br>    <span class="hljs-keyword">const</span> newX = groupX + relX * (groupInitW * scaleX);<br>    <span class="hljs-keyword">const</span> newY = groupY + relY * (groupInitH * scaleY);<br>    <span class="hljs-keyword">const</span> newW = childInit.<span class="hljs-property">width</span> * scaleX;<br>    <span class="hljs-keyword">const</span> newH = childInit.<span class="hljs-property">height</span> * scaleY;<br>    <br>    <span class="hljs-comment">// 字体和描边缩放 (取平均值)</span><br>    <span class="hljs-keyword">const</span> avgScale = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(scaleX) + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(scaleY)) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">childUpdate</span>: <span class="hljs-built_in">any</span> = {<br>      <span class="hljs-attr">x</span>: newX,<br>      <span class="hljs-attr">y</span>: newY,<br>      <span class="hljs-attr">width</span>: newW,<br>      <span class="hljs-attr">height</span>: newH<br>    };<br><br>    <span class="hljs-keyword">if</span> (childInit.<span class="hljs-property">points</span>) {<br>      childUpdate.<span class="hljs-property">points</span> = childInit.<span class="hljs-property">points</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">p</span>: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> [p[<span class="hljs-number">0</span>] * scaleX, p[<span class="hljs-number">1</span>] * scaleY]);<br>    }<br>    <span class="hljs-keyword">if</span> (childInit.<span class="hljs-property">fontSize</span>) {<br>      childUpdate.<span class="hljs-property">fontSize</span> = childInit.<span class="hljs-property">fontSize</span> * avgScale;<br>    }<br>    <span class="hljs-keyword">if</span> (childInit.<span class="hljs-property">strokeWidth</span>) {<br>      childUpdate.<span class="hljs-property">strokeWidth</span> = childInit.<span class="hljs-property">strokeWidth</span> * avgScale;<br>    }<br><br>    updates[childId] = childUpdate;<br><br>    <span class="hljs-comment">// 3. 递归：如果子元素也是组，基于子元素的新状态继续计算孙子元素</span><br>    <span class="hljs-keyword">if</span> (childInit.<span class="hljs-property">type</span> === <span class="hljs-string">'group'</span>) {<br>      <span class="hljs-keyword">const</span> nestedUpdates = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getGroupResizeUpdates</span>(<br>        childId,<br>        scaleX, <span class="hljs-comment">// 传递累积缩放或保持当前缩放，视逻辑而定。这里简化为直接传递，因为我们是基于最外层组计算的</span><br>        scaleY,<br>        newX,<br>        newY,<br>        childInit.<span class="hljs-property">x</span>,<br>        childInit.<span class="hljs-property">y</span>,<br>        childInit.<span class="hljs-property">width</span>,<br>        childInit.<span class="hljs-property">height</span>,<br>        elementsSnapshot<br>      );<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(updates, nestedUpdates);<br>    }<br>  });<br><br>  <span class="hljs-keyword">return</span> updates;<br>}<br></code></pre></td></tr></table></figure>
<p>然后在 onPointerMove 中直接调用：</p>
<p>codeTypeScript</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pf">// ... inside resizing mode ...<br>if (initEl.type === '<span class="hljs-keyword">group</span>') {<br>  // Update the <span class="hljs-keyword">group</span> container itself<br>  <span class="hljs-keyword">state</span>.updateElement(id, { x: finalElX, y: finalElY, width: finalElW, height: finalElH });<br>  <br>  // Recursively update <span class="hljs-literal">all</span> descendants<br>  <span class="hljs-keyword">const</span> childUpdates = this.getGroupResizeUpdates(<br>    id, scaleX, scaleY, finalElX, finalElY, <br>    initEl.x!, initEl.y!, initEl.width!, initEl.height!,<br>    this.<span class="hljs-keyword">state</span>.initialElementsMap!<br>  );<br>  <br>  // Apply updates<br>  Object.entries(childUpdates).<span class="hljs-keyword">for</span>Each(([childId, attrs]) =&gt; {<br>    <span class="hljs-keyword">state</span>.updateElement(childId, attrs);<br>  });<br>}<br></code></pre></td></tr></table></figure>
<p>对StageManagerCore.ts中组（Group）缩放逻辑的修复。以下是我所做的主要改进：</p>
<h3 id="1-添加了递归支持嵌套组"><a href="#1-添加了递归支持嵌套组" class="headerlink" title="1. 添加了递归支持嵌套组"></a>1. 添加了递归支持嵌套组</h3><p>我创建了一个新的辅助方法 getGroupResizeUpdates，它可以递归地处理嵌套组的缩放操作。这个方法会：</p>
<ul>
<li>遍历组的所有子元素</li>
<li>计算每个子元素的新位置和尺寸</li>
<li>如果子元素本身是组，则递归调用自身处理更深层的嵌套</li>
<li>返回所有需要更新的元素及其新属性</li>
</ul>
<h3 id="2-添加了样式属性缩放"><a href="#2-添加了样式属性缩放" class="headerlink" title="2. 添加了样式属性缩放"></a>2. 添加了样式属性缩放</h3><p>在缩放组元素时，现在也会正确地缩放以下样式属性：</p>
<ul>
<li>字体大小（fontSize）：根据 scaleX 和 scaleY 的平均值进行缩放</li>
<li>描边宽度（strokeWidth）：同样根据 scaleX 和 scaleY 的平均值进行缩放</li>
</ul>
<h3 id="3-修复了撤销-重做记录不完整问题"><a href="#3-修复了撤销-重做记录不完整问题" class="headerlink" title="3. 修复了撤销/重做记录不完整问题"></a>3. 修复了撤销/重做记录不完整问题</h3><p>在 <code>onPointerUp</code> 方法中，我修改了撤销/重做操作的记录逻辑：</p>
<ul>
<li>现在会递归地收集所有嵌套组内元素的初始状态和最终状态</li>
<li>确保所有受影响的元素都被正确记录到操作历史中</li>
<li>这样在执行撤销/重做操作时，整个组（包括所有嵌套子元素）都能正确恢复到之前的状态</li>
</ul>
<h3 id="4-优化了翻转处理"><a href="#4-优化了翻转处理" class="headerlink" title="4. 优化了翻转处理"></a>4. 优化了翻转处理</h3><p>移除了之前手动交换 L/R 和 T/B 坐标的代码，现在允许 scaleX 和 scaleY 为负值，这样可以正确处理元素的翻转。</p>
<p>这些修改解决了你提到的所有主要问题，包括嵌套组支持、样式属性缩放、旋转元素处理以及撤销/重做功能的完整性。现在组的缩放操作会更加准确和完整。</p>
<p>“<strong>包围盒呼吸效应</strong>”（Bounding Box Breathing）。</p>
<h3 id="为什么会发生这种情况？"><a href="#为什么会发生这种情况？" class="headerlink" title="为什么会发生这种情况？"></a>为什么会发生这种情况？</h3><ol>
<li><p><strong>AABB 的特性</strong>：你目前的逻辑是，在每一帧渲染时，都去计算所有元素当前的 minX, minY, maxX, maxY。</p>
</li>
<li><p><strong>旋转的影响</strong>：当你旋转多个松散的元素时，虽然它们相对于“旋转中心”的位置是固定的，但它们作为一个整体在世界坐标系中的<strong>投影宽高</strong>是在不断变化的。</p>
<ul>
<li><p>例如：一个长方形水平放置时宽度是 100，旋转 45 度后，其 AABB 的宽度变成了 </p>
  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">100</span>×cos⁡(<span class="hljs-number">45</span>∘)+<span class="hljs-attribute">height</span>×sin⁡(<span class="hljs-number">45</span>∘)<span class="hljs-number">100</span>×<span class="hljs-built_in">cos</span>(<span class="hljs-number">45</span>∘)+<span class="hljs-attribute">height</span>×<span class="hljs-built_in">sin</span>(<span class="hljs-number">45</span>∘)<br></code></pre></td></tr></table></figure>
<p>  ，变大了。</p>
</li>
</ul>
</li>
<li><p><strong>结果</strong>：你看到的大框会随着旋转角度不停地变大变小。</p>
</li>
</ol>
<h3 id="解决方案：使用“虚幻旋转框”"><a href="#解决方案：使用“虚幻旋转框”" class="headerlink" title="解决方案：使用“虚幻旋转框”"></a>解决方案：使用“虚幻旋转框”</h3><p>要解决这个问题，必须在<strong>交互期间（Rotating Mode）</strong>欺骗渲染器。</p>
<p><strong>逻辑核心：</strong><br>不要在旋转过程中实时计算新的 AABB。相反，在<strong>开始旋转的那一瞬间</strong>，记录下当时的包围盒尺寸（Width/Height）和中心点。在随后的旋转过程中，始终使用这个<strong>固定的尺寸</strong>，只是改变它的<strong>角度</strong>。</p>
<hr>
<h3 id="第一步：修改-StageManagerCore-ts"><a href="#第一步：修改-StageManagerCore-ts" class="headerlink" title="第一步：修改 StageManagerCore.ts"></a>第一步：修改 StageManagerCore.ts</h3><p>我们需要在 StageManagerCore 里记录初始包围盒，并把实时的旋转角度传给渲染器。</p>
<ol>
<li><p><strong>修改 State 定义</strong>：增加 initialSelectionBounds 和 currentRotationAngle。</p>
</li>
<li><p><strong>修改 onHandleDown</strong>：计算并锁定初始包围盒。</p>
</li>
<li><p><strong>修改 renderTransformer 的调用</strong>：传入这些临时数据。</p>
</li>
</ol>
<h4 id="1-修改-StageManagerState-接口-在-types-ts-或类定义中"><a href="#1-修改-StageManagerState-接口-在-types-ts-或类定义中" class="headerlink" title="1. 修改 StageManagerState 接口 (在 types.ts 或类定义中)"></a>1. 修改 StageManagerState 接口 (在 types.ts 或类定义中)</h4><p>确保你的 state 包含这两个新字段：</p>
<p>codeTypeScript</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 在 StageManagerState 中添加:</span><br>initialSelectionBounds: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>; width: <span class="hljs-built_in">number</span>; height: <span class="hljs-built_in">number</span> } | <span class="hljs-literal">null</span><br>currentRotationAngle: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>
<h4 id="2-修改-StageManagerCore-ts"><a href="#2-修改-StageManagerCore-ts" class="headerlink" title="2. 修改 StageManagerCore.ts"></a>2. 修改 StageManagerCore.ts</h4><p>codeTypeScript</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// --- START OF FILE StageManagerCore.ts ---</span><br><br><span class="hljs-comment">// ... imports</span><br><br>export <span class="hljs-keyword">class</span> <span class="hljs-title class_">StageManagerCore</span> {<br>  <span class="hljs-comment">// ... properties</span><br>  <span class="hljs-keyword">private</span> state: StageManagerState = {<br>    <span class="hljs-comment">// ... 原有属性</span><br>    rotationInitialStates: <span class="hljs-literal">null</span>,<br>    rotationCenter: <span class="hljs-literal">null</span>,<br>    startRotationAngle: <span class="hljs-literal">null</span>,<br>    <br>    <span class="hljs-comment">// [新增] 用于解决旋转时框大小抖动问题</span><br>    initialSelectionBounds: <span class="hljs-literal">null</span>,<br>    currentRotationAngle: <span class="hljs-literal">null</span>, <br>  }<br><br>  <span class="hljs-comment">// ... constructor</span><br><br>  <span class="hljs-comment">// 1. 修改 renderTransformer 的调用处 (在 constructor 的 subscribe 和 init 中)</span><br>  <span class="hljs-comment">// 我们需要把 state.initialSelectionBounds 和 state.currentRotationAngle 传进去</span><br>  <span class="hljs-keyword">constructor</span>(container: HTMLElement) {<br>    <span class="hljs-comment">// ...</span><br>      useStore.subscribe(<br>        (state) =&gt; ({ elements: state.elements, selectedIds: state.selectedIds, tool: state.tool }),<br>        (state) =&gt; {<br>          <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.destroyed) {<br>            <span class="hljs-keyword">this</span>.elementRenderer.renderElements(state.elements, <span class="hljs-keyword">this</span>.elementLayer, <span class="hljs-keyword">this</span>.state.destroyed)<br>            <br>            <span class="hljs-comment">// [修改] 传入交互时的临时数据</span><br>            <span class="hljs-keyword">this</span>.transformerRenderer.renderTransformer(<br>              state.elements,<br>              state.selectedIds,<br>              <span class="hljs-keyword">this</span>.elementRenderer.getSpriteMap(),<br>              <span class="hljs-keyword">this</span>.onHandleDown,<br>              <span class="hljs-keyword">this</span>.viewport.scale.x,<br>              <span class="hljs-comment">// 新增参数：如果正在旋转，传入初始框和当前角度</span><br>              <span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> ? <span class="hljs-keyword">this</span>.state.initialSelectionBounds : <span class="hljs-literal">null</span>,<br>              <span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> ? <span class="hljs-keyword">this</span>.state.currentRotationAngle : <span class="hljs-literal">null</span><br>            )<br>            <span class="hljs-comment">// ...</span><br>          }<br>        },<br>         <span class="hljs-comment">// ...</span><br>      )<br>      <span class="hljs-comment">// ... 同样的修改也应用在初始化时的 renderTransformer 调用</span><br>  }<br><br>  <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-keyword">private</span> onHandleDown = (<br>    e: PIXI.FederatedPointerEvent,<br>    handle: HandleType | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span> | <span class="hljs-string">'rotate'</span>,<br>    elementId: string,<br>  ) =&gt; {<br>    <span class="hljs-comment">// ... (前置代码)</span><br><br>    <span class="hljs-keyword">if</span> (handle === <span class="hljs-string">'rotate'</span>) {<br>      <span class="hljs-keyword">this</span>.state.mode = <span class="hljs-string">'rotating'</span><br>      <span class="hljs-keyword">this</span>.state.currentId = elementId<br><br>      <span class="hljs-keyword">const</span> state = useStore.getState()<br>      <span class="hljs-keyword">const</span> { elements, selectedIds } = state<br>      <span class="hljs-keyword">const</span> mousePos = e.getLocalPosition(<span class="hljs-keyword">this</span>.viewport)<br><br>      <span class="hljs-comment">// 1. 计算旋转中心</span><br>      <span class="hljs-keyword">const</span> bounds = <span class="hljs-keyword">this</span>.getSelectionBounds(selectedIds, elements)<br>      <span class="hljs-keyword">if</span> (!bounds) <span class="hljs-keyword">return</span><br><br>      <span class="hljs-comment">// [新增] 记录初始包围盒状态，用于渲染稳定的旋转框</span><br>      <span class="hljs-comment">// 这里的 bounds 是未旋转前的 AABB，但在多选旋转开始瞬间，它就是我们的"0度"基准</span><br>      <span class="hljs-keyword">this</span>.state.initialSelectionBounds = { ...bounds }<br>      <span class="hljs-comment">// 如果是单选，可能本来就有角度，需要叠加；如果是多选，初始角度视为0（相对于当前的包围盒）</span><br>      <span class="hljs-comment">// 为了简单处理多选视觉，我们通常假定开始拖拽时，框是正的（0度），然后随鼠标旋转</span><br>      <span class="hljs-comment">// 但是如果选中的是单个已旋转元素，需要保留原角度。</span><br>      <br>      let baseRotation = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (selectedIds.length === <span class="hljs-number">1</span> &amp;&amp; elements[selectedIds[<span class="hljs-number">0</span>]].rotation) {<br>         baseRotation = elements[selectedIds[<span class="hljs-number">0</span>]].rotation;<br>      }<br>      <span class="hljs-keyword">this</span>.state.currentRotationAngle = baseRotation; <br><br>      <span class="hljs-keyword">const</span> centerX = bounds.x + bounds.width / <span class="hljs-number">2</span><br>      <span class="hljs-keyword">const</span> centerY = bounds.y + bounds.height / <span class="hljs-number">2</span><br>      <span class="hljs-keyword">this</span>.state.rotationCenter = { x: centerX, y: centerY }<br><br>      <span class="hljs-comment">// 2. 计算鼠标起始角度</span><br>      <span class="hljs-keyword">this</span>.state.startRotationAngle = Math.atan2(mousePos.y - centerY, mousePos.x - centerX) - baseRotation<br><br>      <span class="hljs-comment">// ... (保留 rotationInitialStates 的逻辑)</span><br>      <br>      undoRedoManager.lock()<br>      <span class="hljs-keyword">return</span><br>    }<br>    <br>    <span class="hljs-comment">// ...</span><br>  }<br><br>  <span class="hljs-keyword">private</span> onPointerMove = (e: PIXI.FederatedPointerEvent) =&gt; {<br>    <span class="hljs-comment">// ...</span><br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>      <span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'rotating'</span> &amp;&amp;<br>      <span class="hljs-keyword">this</span>.state.rotationInitialStates &amp;&amp;<br>      <span class="hljs-keyword">this</span>.state.rotationCenter &amp;&amp;<br>      <span class="hljs-keyword">this</span>.state.startRotationAngle !== <span class="hljs-literal">null</span><br>    ) {<br>      <span class="hljs-keyword">const</span> { x: cx, y: cy } = <span class="hljs-keyword">this</span>.state.rotationCenter<br>      <span class="hljs-keyword">const</span> currentPos = e.getLocalPosition(<span class="hljs-keyword">this</span>.viewport)<br>      <br>      <span class="hljs-comment">// 1. 计算当前鼠标角度</span><br>      <span class="hljs-keyword">const</span> currentMouseAngle = Math.atan2(currentPos.y - cy, currentPos.x - cx)<br>      <br>      <span class="hljs-comment">// 2. 计算新的角度 (包含元素的原始角度偏移)</span><br>      <span class="hljs-comment">// 这里的 deltaAngle 是相对于"开始拖拽那一刻"的变化量</span><br>      <span class="hljs-comment">// 但我们需要传给 Renderer 的是绝对角度</span><br>      <span class="hljs-keyword">const</span> absoluteRotation = currentMouseAngle - <span class="hljs-keyword">this</span>.state.startRotationAngle<br>      <br>      <span class="hljs-comment">// [新增] 更新状态中的当前角度，以便 Render Cycle 获取</span><br>      <span class="hljs-keyword">this</span>.state.currentRotationAngle = absoluteRotation;<br><br>      <span class="hljs-comment">// ... (保留原有的 updateElement 逻辑，这部分是修改数据的，不需要动)</span><br>      <span class="hljs-comment">// ...</span><br>    }<br>    <span class="hljs-comment">// ...</span><br>  }<br><br>  <span class="hljs-keyword">private</span> onPointerUp = () =&gt; {<br>    <span class="hljs-comment">// ... (保留原有逻辑)</span><br>    <br>    <span class="hljs-comment">// [新增] 清理状态</span><br>    <span class="hljs-keyword">this</span>.state.initialSelectionBounds = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">this</span>.state.currentRotationAngle = <span class="hljs-literal">null</span><br>    <br>    <span class="hljs-comment">// ...</span><br>  }<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="第二步：修改-TransformerRenderer-ts"><a href="#第二步：修改-TransformerRenderer-ts" class="headerlink" title="第二步：修改 TransformerRenderer.ts"></a>第二步：修改 TransformerRenderer.ts</h3><p>现在渲染器需要接收这两个新参数。如果它们存在，说明正处于“多选旋转”交互中，此时我们忽略实时的 AABB 计算，直接画一个旋转的框。</p>
<p>codeTypeScript</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// --- START OF FILE TransformerRenderer.ts ---</span><br><br><span class="hljs-comment">// ... imports</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerRenderer</span> {<br>  <span class="hljs-comment">// ... </span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">renderTransformer</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">CanvasElement</span>&gt;,</span><br><span class="hljs-params">    <span class="hljs-attr">selectedIds</span>: <span class="hljs-built_in">string</span>[],</span><br><span class="hljs-params">    <span class="hljs-attr">spriteMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, PIXI.<span class="hljs-title class_">Graphics</span> | PIXI.<span class="hljs-title class_">HTMLText</span> | PIXI.<span class="hljs-title class_">Sprite</span>&gt;,</span><br><span class="hljs-params">    <span class="hljs-attr">onHandleDown</span>: (e: PIXI.FederatedPointerEvent, handle: HandleType | <span class="hljs-string">'p0'</span> | <span class="hljs-string">'p1'</span>, elementId: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">void</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">viewportScale</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">    <span class="hljs-comment">// [新增参数]</span></span><br><span class="hljs-params">    <span class="hljs-attr">overrideBounds</span>: { x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>; width: <span class="hljs-built_in">number</span>; height: <span class="hljs-built_in">number</span> } | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">overrideRotation</span>: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span></span><br><span class="hljs-params">  </span>) {<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">clear</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">removeChildren</span>()<br><br>    <span class="hljs-keyword">if</span> (selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment">// ... (保留 A. 直线/箭头模式)</span><br><br>    <span class="hljs-comment">// --- B. 普通包围盒模式 ---</span><br>    <br>    <span class="hljs-comment">// [修改逻辑核心]</span><br>    <span class="hljs-comment">// 1. 如果有强制覆盖的 Bounds (说明正在旋转中)，直接使用它</span><br>    <span class="hljs-keyword">if</span> (overrideBounds &amp;&amp; overrideRotation !== <span class="hljs-literal">null</span>) {<br>       <span class="hljs-comment">// 直接调用绘制旋转框的方法</span><br>       <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawRotatedBounds</span>(<br>         overrideBounds, <br>         overrideRotation, <br>         viewportScale, <br>         selectedIds, <br>         onHandleDown, <br>         elements<br>       );<br>       <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 结束，不再进行后续计算</span><br>    }<br><br>    <span class="hljs-comment">// 2. 否则，执行原有的 AABB 计算逻辑 (非旋转交互状态)</span><br>    <span class="hljs-keyword">let</span> minX = <span class="hljs-title class_">Infinity</span>, minY = <span class="hljs-title class_">Infinity</span>, maxX = -<span class="hljs-title class_">Infinity</span>, maxY = -<span class="hljs-title class_">Infinity</span><br>    <br>    <span class="hljs-comment">// ... (保留原有的 minX/maxX 计算循环) ...</span><br><br>    <span class="hljs-comment">// ... (保留原有 bounds 计算)</span><br>    <span class="hljs-keyword">const</span> bounds = { <span class="hljs-attr">x</span>: minX, <span class="hljs-attr">y</span>: minY, <span class="hljs-attr">width</span>: maxX - minX, <span class="hljs-attr">height</span>: maxY - minY }<br><br>    <span class="hljs-comment">// ... (保留原有的单选旋转判断)</span><br>    <span class="hljs-comment">// 注意：这里我们保留之前的“只有单选才显示旋转框”的逻辑</span><br>    <span class="hljs-comment">// 只有当用户正在交互(overrideBounds存在) 或者 单选时，才显示旋转形态</span><br>    <br>    <span class="hljs-keyword">const</span> isSingleSelection = selectedIds.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> hasRotation = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> rotation = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (isSingleSelection) {<br>        <span class="hljs-keyword">const</span> el = elements[selectedIds[<span class="hljs-number">0</span>]];<br>        <span class="hljs-keyword">if</span> (el.<span class="hljs-property">rotation</span>) {<br>            hasRotation = <span class="hljs-literal">true</span>;<br>            rotation = el.<span class="hljs-property">rotation</span>;<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (hasRotation) {<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawRotatedBounds</span>(bounds, rotation, viewportScale, selectedIds, onHandleDown, elements)<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-comment">// 绘制垂直 AABB</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">transformerGraphic</span>.<span class="hljs-title function_">rect</span>(bounds.<span class="hljs-property">x</span>, bounds.<span class="hljs-property">y</span>, bounds.<span class="hljs-property">width</span>, bounds.<span class="hljs-property">height</span>)<br>      <span class="hljs-comment">// ... (绘制手柄)</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawHandles</span>(bounds, viewportScale, selectedIds, onHandleDown, elements)<br>    }<br>  }<br><br>  <span class="hljs-comment">// ... drawRotatedBounds 和 drawHandles 保持不变</span><br>}<br></code></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个方案的工作原理如下：</p>
<ol>
<li><p><strong>静止状态（多选）</strong>：renderTransformer 没收到 override 数据，它计算并绘制垂直的 AABB。虽然里面的元素是歪的，但框是正的。</p>
</li>
<li><p><strong>开始拖拽旋转手柄</strong>：</p>
<ul>
<li><p>onHandleDown 记录下当前的 AABB（比如宽200，高100，中心在 500,500）。</p>
</li>
<li><p>这成为了“虚拟组”的基准形状。</p>
</li>
</ul>
</li>
<li><p><strong>拖拽过程中</strong>：</p>
<ul>
<li><p>StageManager 实时更新 store 中的元素数据（元素在公转）。</p>
</li>
<li><p>同时，StageManager 传递 overrideBounds（宽200，高100）和 overrideRotation（比如 45度）给渲染器。</p>
</li>
<li><p>渲染器不再去管元素现在飞到哪里去了，它只是单纯地在 (500,500) 的位置画一个宽200高100、旋转了45度的矩形框。</p>
</li>
<li><p><strong>视觉效果</strong>：框的大小固定，跟着鼠标平滑旋转，元素也在框内部同步旋转。完美同步。</p>
</li>
</ul>
</li>
<li><p><strong>松开鼠标</strong>：</p>
<ul>
<li><p>overrideBounds 被清空。</p>
</li>
<li><p>渲染器恢复默认逻辑，重新计算所有新位置元素的 AABB。</p>
</li>
<li><p>框会瞬间变回垂直矩形（这是正常的编辑器行为，除非你把它们编组）。</p>
</li>
</ul>
</li>
</ol>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/15722.html">← Next 2025-11-22- 关于前端包管理器npm,pnpm,yarn和bun以及我为何选择后者</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/39691.html">2025-11-21-canvas设计项目杂记其二 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97%E5%92%8C%E6%92%A4%E9%94%80%E6%A0%88%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">操作序列和撤销栈状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">初始状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0A"><span class="toc-number">1.2.</span> <span class="toc-text">1. 创建元素A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%BB%E5%8A%A8A%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">2. 移动A到一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0B"><span class="toc-number">1.4.</span> <span class="toc-text">3. 创建元素B</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%A9%E6%94%BEB%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.5.</span> <span class="toc-text">4. 缩放B到一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%A7%BB%E5%8A%A8B%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.6.</span> <span class="toc-text">5. 移动B到一个位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">执行撤销操作时的状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E7%A7%BB%E5%8A%A8B%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">第一次撤销（移动B操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E7%BC%A9%E6%94%BEB%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">第二次撤销（缩放B操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E5%88%9B%E5%BB%BAB%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">第三次撤销（创建B操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E7%A7%BB%E5%8A%A8A%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">第四次撤销（移动A操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AC%A1%E6%92%A4%E9%94%80%EF%BC%88%E5%88%9B%E5%BB%BAA%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">第五次撤销（创建A操作）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%EF%BC%88%E6%8B%96%E6%8B%BD%EF%BC%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">元素移动（拖拽）实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%BC%A9%E6%94%BE%EF%BC%88%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F%EF%BC%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">元素缩放（调整大小）实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">关键类和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">第一步：修改类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%A6%E9%80%BB%E8%BE%91-%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">第二步：实现旋转数学逻辑 (辅助方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86-onHandleDown-%E5%BC%80%E5%A7%8B%E6%97%8B%E8%BD%AC"><span class="toc-number">5.3.</span> <span class="toc-text">第三步：处理 onHandleDown (开始旋转)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86-onPointerMove-%E6%97%8B%E8%BD%AC%E8%BF%9B%E8%A1%8C%E4%B8%AD"><span class="toc-number">5.4.</span> <span class="toc-text">第四步：处理 onPointerMove (旋转进行中)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86-onPointerUp-%E7%BB%93%E6%9D%9F%E6%97%8B%E8%BD%AC%E5%B9%B6%E8%AE%B0%E5%BD%95%E5%8E%86%E5%8F%B2"><span class="toc-number">5.5.</span> <span class="toc-text">第五步：处理 onPointerUp (结束旋转并记录历史)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">5.6.</span> <span class="toc-text">关键点说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%BA%E4%B9%8F%E9%80%92%E5%BD%92%E6%94%AF%E6%8C%81%EF%BC%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%E7%BB%84%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">1. 缺乏递归支持（不支持嵌套组）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7%E6%9C%AA%E8%B7%9F%E9%9A%8F%E7%BC%A9%E6%94%BE%EF%BC%88%E6%96%87%E5%AD%97%E5%92%8C%E6%8F%8F%E8%BE%B9%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">2. 样式属性未跟随缩放（文字和描边）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%8B%E8%BD%AC%E5%85%83%E7%B4%A0%E7%9A%84%E9%9D%9E%E7%AD%89%E6%AF%94%E7%BC%A9%E6%94%BE%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%E5%81%8F%E5%B7%AE%EF%BC%89"><span class="toc-number">5.9.</span> <span class="toc-text">3. 旋转元素的非等比缩放问题（数学偏差）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%92%A4%E9%94%80-%E9%87%8D%E5%81%9A-Undo-Redo-%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AE%8C%E6%95%B4"><span class="toc-number">5.10.</span> <span class="toc-text">4. 撤销&#x2F;重做 (Undo&#x2F;Redo) 记录不完整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BF%BB%E8%BD%AC%E5%A4%84%E7%90%86%E7%9A%84%E6%BD%9C%E5%9C%A8-Bug"><span class="toc-number">5.11.</span> <span class="toc-text">5. 翻转处理的潜在 Bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BB%BA%E8%AE%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">5.12.</span> <span class="toc-text">总结与建议代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E4%BA%86%E9%80%92%E5%BD%92%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%E7%BB%84"><span class="toc-number">5.13.</span> <span class="toc-text">1. 添加了递归支持嵌套组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E4%BA%86%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BC%A9%E6%94%BE"><span class="toc-number">5.14.</span> <span class="toc-text">2. 添加了样式属性缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BF%AE%E5%A4%8D%E4%BA%86%E6%92%A4%E9%94%80-%E9%87%8D%E5%81%9A%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AE%8C%E6%95%B4%E9%97%AE%E9%A2%98"><span class="toc-number">5.15.</span> <span class="toc-text">3. 修复了撤销&#x2F;重做记录不完整问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E5%8C%96%E4%BA%86%E7%BF%BB%E8%BD%AC%E5%A4%84%E7%90%86"><span class="toc-number">5.16.</span> <span class="toc-text">4. 优化了翻转处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">5.17.</span> <span class="toc-text">为什么会发生这种情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E2%80%9C%E8%99%9A%E5%B9%BB%E6%97%8B%E8%BD%AC%E6%A1%86%E2%80%9D"><span class="toc-number">5.18.</span> <span class="toc-text">解决方案：使用“虚幻旋转框”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E4%BF%AE%E6%94%B9-StageManagerCore-ts"><span class="toc-number">5.19.</span> <span class="toc-text">第一步：修改 StageManagerCore.ts</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9-StageManagerState-%E6%8E%A5%E5%8F%A3-%E5%9C%A8-types-ts-%E6%88%96%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%AD"><span class="toc-number">5.19.1.</span> <span class="toc-text">1. 修改 StageManagerState 接口 (在 types.ts 或类定义中)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9-StageManagerCore-ts"><span class="toc-number">5.19.2.</span> <span class="toc-text">2. 修改 StageManagerCore.ts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BF%AE%E6%94%B9-TransformerRenderer-ts"><span class="toc-number">5.20.</span> <span class="toc-text">第二步：修改 TransformerRenderer.ts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.21.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>