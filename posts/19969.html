<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构-树 | Notes|笔记站</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":90,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="/Arknight-notes/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/Arknight-notes/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23ct13Fb0b67x23wnT',
 clientSecret: 'f18ce69dd545e3c0f5e2456afde9c756fe8a254a',
 repo: 'Arknight-notes',
 owner: 'Zhongye1',
 admin: ['Zhongye1'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/Arknight-notes/rss.xml" title="Notes|笔记站" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>数据结构-树</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-04-29T18:19:06.000Z" id="date"> 2025-04-30</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-10-03T15:48:55.151Z" id="updated"> 2025-10-03</time></div></span><br><span id="busuanzi_container_page_pv">页面浏览: <span class="control" id="busuanzi_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><p>树是常用的数据结构之一，种类很多比如二叉树，二叉查找树，平衡二叉树，红黑树，B 树，B+树等，本身就是一种递归结构</p>
<h2 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h2><p>树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。</p>
<p>在计算机科学中，<strong>树</strong>是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点都只有有限个子节点或无子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
<li>树里面没有环路(cycle)</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；</li>
<li><strong>深度</strong>：对于任意节点 n,n 的深度为从根到 n 的唯一路径长，根的深度为 0；</li>
<li><strong>高度</strong>：对于任意节点 n,n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0；</li>
<li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由 m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ol>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs less">                    <span class="hljs-selector-tag">A</span> (根节点)<br>                   / \<br>                  <span class="hljs-selector-tag">B</span>   <span class="hljs-selector-tag">C</span><br>                 / \   \<br>                <span class="hljs-selector-tag">D</span>   <span class="hljs-selector-tag">E</span>   <span class="hljs-selector-tag">F</span><br>               /       / \<br>              <span class="hljs-selector-tag">G</span>       <span class="hljs-selector-tag">H</span>   <span class="hljs-selector-tag">I</span> (叶节点)<br>             / \<br>            <span class="hljs-selector-tag">J</span>   <span class="hljs-selector-tag">K</span> (叶节点)<br><br><br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">A</span>是根节点，没有父节点<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">B</span>是<span class="hljs-selector-tag">A</span>的子节点，<span class="hljs-selector-tag">A</span>是<span class="hljs-selector-tag">B</span>的父节点<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">B</span>和<span class="hljs-selector-tag">C</span>是兄弟节点（具有相同父节点<span class="hljs-selector-tag">A</span>）<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">G</span>是叶节点（度为<span class="hljs-number">0</span>）<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">B</span>是非终端节点（度不为<span class="hljs-number">0</span>，度为<span class="hljs-number">2</span>）<br><span class="hljs-selector-tag">-</span> 从<span class="hljs-selector-tag">A</span>到<span class="hljs-selector-tag">K</span>的路径长度为<span class="hljs-number">3</span>，<span class="hljs-selector-tag">K</span>的深度为<span class="hljs-number">3</span><br><span class="hljs-selector-tag">-</span> 树的度为<span class="hljs-number">2</span>（<span class="hljs-selector-tag">B</span>节点的度最大）<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">B</span>的度为<span class="hljs-number">2</span>（有两个子节点<span class="hljs-selector-tag">D</span>和<span class="hljs-selector-tag">E</span>）<br><span class="hljs-selector-tag">-</span> 整个结构是一个有序树（子节点有左右顺序）<br></code></pre></td></tr></table></figure>
<p>这个图示展示了以下树的基本概念：</p>
<ol>
<li><strong>根节点</strong>：A 节点，整棵树的起始点</li>
<li><strong>父节点与子节点关系</strong>：如 A 是 B 和 C 的父节点，B 和 C 是 A 的子节点</li>
<li><strong>兄弟节点</strong>：B 和 C 具有相同的父节点 A，所以它们是兄弟节点</li>
<li><strong>叶节点</strong>：G、H、I、J、K 这些没有子节点的节点</li>
<li><strong>内部节点</strong>：A、B、C、D、E、F 这些有子节点的节点</li>
<li><strong>节点的度</strong>：B 的度为 2（有两个子节点），G 的度为 2（有两个子节点）</li>
<li><strong>树的度</strong>：整棵树的最大节点度，这里是 2</li>
<li><strong>路径与深度</strong>：从根节点 A 到任意节点的路径，如 A-&gt;B-&gt;D-&gt;G 的路径长度为 3</li>
</ol>
<h2 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h2><p>有序/无序：</p>
<ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。</li>
<li>有序树/搜索树/查找树：树中任意节点的子节点之间有顺序关系，这种树称为有序树。即树的所有节点按照一定的顺序排列，这样进行插入、删除、查找时效率就会非常高</li>
</ul>
<p>平衡/不平衡：</p>
<ul>
<li>平衡树<ul>
<li>绝对平衡树：所有叶节点在同一层</li>
<li>非绝对平衡树</li>
</ul>
</li>
<li>不平衡树</li>
</ul>
<p>节点的分叉情况：</p>
<ul>
<li>等叉树：是每个节点的键值个数都相同、子节点个数也都相同<ul>
<li>二叉树：每个节点最多含有两个子树的树称为二叉树；<ul>
<li>完全二叉树：除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；<ul>
<li>满二叉树：所有叶节点都在最底层的完全二叉树；</li>
</ul>
</li>
<li>平衡二叉树、AVL 树：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树；</li>
<li>排序二叉树：也称二叉查找树、二叉搜索树、有序二叉树；</li>
</ul>
</li>
<li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>多叉树</li>
</ul>
</li>
<li>不等叉树：每个节点的键值个数不一定相同、子节点个数也不一定相同<ul>
<li>B 树：对不等叉树的节点键值数和插入、删除逻辑添加一些特殊的要求，使其能达到绝对平衡的效果。B 树全称 Balance Tree。如果某个 B 树上所有节点的分叉数最大值是 m，则把这个 B 数叫做 m 阶 B 树。</li>
</ul>
</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h2><p>二叉树就像它的名字一样，每个元素最多有两个节点，分别称为左节点和右节点。当然并不是每个元素都需要有两个节点，有的可能只有左节点，有的可能只有右节点。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less">        <span class="hljs-selector-tag">A</span> (根节点)<br>       / \<br>      <span class="hljs-selector-tag">B</span>   <span class="hljs-selector-tag">C</span><br>     / \   \<br>    <span class="hljs-selector-tag">D</span>   <span class="hljs-selector-tag">E</span>   <span class="hljs-selector-tag">F</span><br>   /       / \<br>  <span class="hljs-selector-tag">G</span>       <span class="hljs-selector-tag">H</span>   <span class="hljs-selector-tag">I</span> (叶节点)<br> / \<br><span class="hljs-selector-tag">J</span>   <span class="hljs-selector-tag">K</span> (叶节点)<br></code></pre></td></tr></table></figure>
<p>基于树的存储模式的不同，为了更好的利用存储空间，二叉树又分为完全二叉树和非完全二叉树：</p>
<p><strong>「完全二叉树」</strong>：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</p>
<h3 id="１、完全二叉树"><a href="#１、完全二叉树" class="headerlink" title="１、完全二叉树"></a><strong>１、完全二叉树</strong></h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less">                    <span class="hljs-selector-tag">A</span> (根节点)<br>                   / \<br>                  <span class="hljs-selector-tag">B</span>   <span class="hljs-selector-tag">C</span><br>                 / \   \<br>                <span class="hljs-selector-tag">D</span>   <span class="hljs-selector-tag">E</span>   <span class="hljs-selector-tag">F</span><br>               /       / \<br>              <span class="hljs-selector-tag">G</span>       <span class="hljs-selector-tag">H</span>   <span class="hljs-selector-tag">I</span> (叶节点)<br>             / \<br>            <span class="hljs-selector-tag">J</span>   <span class="hljs-selector-tag">K</span> (叶节点)<br><br>完全二叉树的顺序存储<br>数组索引: <span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[7]</span><span class="hljs-selector-attr">[8]</span><br>存储内容: <span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[7]</span><span class="hljs-selector-attr">[8]</span><span class="hljs-selector-attr">[9]</span><br></code></pre></td></tr></table></figure>
<h3 id="２、非完全二叉树"><a href="#２、非完全二叉树" class="headerlink" title="２、非完全二叉树"></a><strong>２、非完全二叉树</strong></h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs less">        <span class="hljs-number">1</span><br>       / \<br>      <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>     /     \<br>    <span class="hljs-number">4</span>       <span class="hljs-number">5</span><br>   /       / \<br>  <span class="hljs-number">6</span>       <span class="hljs-number">7</span>   <span class="hljs-number">8</span><br>         /<br>        <span class="hljs-number">9</span><br><br>非完全二叉树的顺序存储<br>数组索引: <span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[7]</span><span class="hljs-selector-attr">[8]</span><span class="hljs-selector-attr">[9]</span><span class="hljs-selector-attr">[10]</span><span class="hljs-selector-attr">[11]</span><span class="hljs-selector-attr">[12]</span><span class="hljs-selector-attr">[13]</span><span class="hljs-selector-attr">[14]</span><span class="hljs-selector-attr">[15]</span><span class="hljs-selector-attr">[16]</span><span class="hljs-selector-attr">[17]</span><span class="hljs-selector-attr">[18]</span><br>存储内容: <span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[7]</span><span class="hljs-selector-attr">[8]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[ ]</span><span class="hljs-selector-attr">[9]</span><br>存在大量空位，造成空间浪费<br><br></code></pre></td></tr></table></figure>
<h2 id="二叉树的存储模式"><a href="#二叉树的存储模式" class="headerlink" title="二叉树的存储模式"></a><strong>二叉树的存储模式</strong></h2><p>二叉树的存储模式有两种，一种是基于指针或者引用的<strong>二叉链式存储法</strong>，一种是基于数组的<strong>顺序存储法</strong></p>
<h3 id="二叉链式存储法"><a href="#二叉链式存储法" class="headerlink" title="二叉链式存储法"></a><strong>二叉链式存储法</strong></h3><p>链式存储法相对比较简单，理解起来也非常容易，每一个节点都有三个字段，一个字段存储着该节点的值，另外两个字段存储着左右节点的引用。我们顺着跟字节就可以很轻松的把整棵树串起来</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less">链式存储法结构示意图：<br><br>    节点<span class="hljs-selector-tag">A</span><br>   /     \<br>  ↓       ↓<br>节点<span class="hljs-selector-tag">B</span>    节点<span class="hljs-selector-tag">C</span><br>/   \     /   \<br>↓    ↓   ↓    ↓<br>...  ... ...  ...<br><br>每个节点的内存结构：<br>┌─────────────┬─────────────┬─────────────┐<br>│    <span class="hljs-selector-tag">data</span>     │    <span class="hljs-selector-tag">left</span>     │    <span class="hljs-selector-tag">right</span>    │<br>│  (节点值)   │  (左子节点) │  (右子节点) │<br>└─────────────┴─────────────┴─────────────┘<br>      ↓              ↓             ↓<br>    节点值       指向左子树    指向右子树<br>                   的指针        的指针<br><br></code></pre></td></tr></table></figure>
<p>链式存储法的 C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 二叉树节点定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span><br>    <span class="hljs-type">int</span> data;           <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span>;</span>   <span class="hljs-comment">// 左子节点指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span>;</span>  <span class="hljs-comment">// 右子节点指针</span><br>} TreeNode;<br><br><span class="hljs-comment">// 创建新节点</span><br>TreeNode* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> {<br>    TreeNode* newNode = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>    newNode-&gt;data = data;<br>    newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>}<br><br><span class="hljs-comment">// 示例：构建一个简单的二叉树</span><br>TreeNode* <span class="hljs-title function_">buildSampleTree</span><span class="hljs-params">()</span> {<br>    TreeNode* root = createNode(<span class="hljs-number">1</span>);<br>    root-&gt;left = createNode(<span class="hljs-number">2</span>);<br>    root-&gt;right = createNode(<span class="hljs-number">3</span>);<br>    root-&gt;left-&gt;left = createNode(<span class="hljs-number">4</span>);<br>    root-&gt;left-&gt;right = createNode(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> root;<br>}<br><br><span class="hljs-comment">// 释放链式存储的二叉树内存</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freeTree</span><span class="hljs-params">(TreeNode* root)</span> {<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    freeTree(root-&gt;left);<br>    freeTree(root-&gt;right);<br>    <span class="hljs-built_in">free</span>(root);<br>}<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">demonstrateStorageMethods</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"=== 二叉树两种存储方式演示 ===\n"</span>);<br><br>    <span class="hljs-comment">// 1. 链式存储法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n1. 链式存储法:\n"</span>);<br>    TreeNode* linkedTree = buildSampleTree();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"前序遍历结果: "</span>);<br>    preOrderLinked(linkedTree);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    freeTree(linkedTree);<br><br>    <span class="hljs-comment">// 2. 顺序存储法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n2. 顺序存储法:\n"</span>);<br>    buildCompleteBinaryTree();<br>    printArrayTree();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"前序遍历结果: "</span>);<br>    preOrderArray(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">对比两种存储方式：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1. 链式存储法：</span><br><span class="hljs-comment">   - 优点：灵活，不需要大片连续内存，插入删除节点方便</span><br><span class="hljs-comment">   - 缺点：需要额外空间存储指针，遍历时需要多次内存跳转</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2. 顺序存储法：</span><br><span class="hljs-comment">   - 优点：节省指针空间，访问节点速度快（通过数组下标直接访问）</span><br><span class="hljs-comment">   - 缺点：对于非完全二叉树会造成空间浪费，插入删除节点复杂</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    demonstrateStorageMethods();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>
<h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a><strong>顺序存储法</strong></h3><p>顺序存储法是基于数组实现的，数组是一段有序的内存空间，如果我们把跟节点的坐标定位<code>i</code>=1，左节点就是 2 <em> <code>i</code> = 2，右节点 2 </em> <code>i</code>+ 1 = 3，以此类推，每个节点都这么算，然后就将树转化成数组了，反过来，按照这种规则我们也能将数组转化成一棵树。</p>
<p>于是在这里我们就能发现一个问题：如果这是一颗不平衡的二叉树是不是会造成大量的空间浪费？这就是为什么需要分完全二叉树和非完全二叉树，分别来看看这两种树基于数组的存储模式。</p>
<p>顺序存储法的 C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-comment">// 用数组表示二叉树</span><br><span class="hljs-type">int</span> treeArray[MAX_TREE_SIZE];<br><span class="hljs-type">int</span> treeSize = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 初始化数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">initTreeArray</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_TREE_SIZE; i++) {<br>        treeArray[i] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// -1表示空节点</span><br>    }<br>}<br><br><span class="hljs-comment">// 在指定位置插入节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> data)</span> {<br>    <span class="hljs-keyword">if</span> (index &gt;= MAX_TREE_SIZE) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"数组越界\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    treeArray[index] = data;<br>    <span class="hljs-keyword">if</span> (index &gt;= treeSize) {<br>        treeSize = index + <span class="hljs-number">1</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 获取父节点索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getParentIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>    <span class="hljs-keyword">if</span> (index &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>}<br><br><span class="hljs-comment">// 获取左子节点索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getLeftChildIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>    <span class="hljs-type">int</span> leftIndex = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (leftIndex &lt; MAX_TREE_SIZE) ? leftIndex : <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-comment">// 获取右子节点索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getRightChildIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>    <span class="hljs-type">int</span> rightIndex = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> (rightIndex &lt; MAX_TREE_SIZE) ? rightIndex : <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-comment">// 示例：构建完全二叉树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildCompleteBinaryTree</span><span class="hljs-params">()</span> {<br>    initTreeArray();<br>    <span class="hljs-comment">// 构建一个简单的完全二叉树: 1, 2, 3, 4, 5</span><br>    <span class="hljs-comment">//       1</span><br>    <span class="hljs-comment">//      / \</span><br><span class="hljs-comment">    //     2   3</span><br>    <span class="hljs-comment">//    / \</span><br><span class="hljs-comment">    //   4   5</span><br>    insertNode(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 根节点</span><br>    insertNode(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 1的左子节点</span><br>    insertNode(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 1的右子节点</span><br>    insertNode(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 2的左子节点</span><br>    insertNode(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 2的右子节点</span><br>}<br><br><span class="hljs-comment">// 打印数组表示的二叉树（层序遍历）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArrayTree</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"数组存储的二叉树: "</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; treeSize; i++) {<br>        <span class="hljs-keyword">if</span> (treeArray[i] != <span class="hljs-number">-1</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, treeArray[i]);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NULL "</span>);<br>        }<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>}<br><br><span class="hljs-comment">// 前序遍历（数组实现）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preOrderArray</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>    <span class="hljs-keyword">if</span> (index &gt;= treeSize || treeArray[index] == <span class="hljs-number">-1</span>) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, treeArray[index]);<br>    preOrderArray(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 左子树</span><br>    preOrderArray(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>);  <span class="hljs-comment">// 右子树</span><br>}<br><br><span class="hljs-comment">// 前序遍历（链式存储）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preOrderLinked</span><span class="hljs-params">(TreeNode* root)</span> {<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);<br>    preOrderLinked(root-&gt;left);<br>    preOrderLinked(root-&gt;right);<br>}<br><br></code></pre></td></tr></table></figure>
<p>对比两种存储方式：</p>
<ol>
<li><p><strong>链式存储法</strong>：</p>
<ul>
<li>优点：灵活，不需要大片连续内存，插入删除节点方便</li>
<li>缺点：需要额外空间存储指针，遍历时需要多次内存跳转</li>
</ul>
</li>
<li><p><strong>顺序存储法</strong>：</p>
<ul>
<li>优点：节省指针空间，访问节点速度快（通过数组下标直接访问）</li>
<li>缺点：对于非完全二叉树会造成空间浪费，插入删除节点复杂</li>
</ul>
</li>
</ol>
<h3 id="完全二叉树顺序存储法"><a href="#完全二叉树顺序存储法" class="headerlink" title="完全二叉树顺序存储法"></a><strong>完全二叉树顺序存储法</strong></h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less">完全二叉树结构：<br>        <span class="hljs-number">1</span><br>       / \<br>      <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>     / \ / \<br>    <span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">6</span>  <span class="hljs-number">7</span><br>   /<br>  <span class="hljs-number">8</span><br><br>数组存储方式（索引从<span class="hljs-number">0</span>开始）：<br>索引:  <span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[7]</span><br>值:    <span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[7]</span><span class="hljs-selector-attr">[8]</span><br><br>父子节点关系：<br><span class="hljs-selector-tag">-</span> 父节点索引为 <span class="hljs-selector-tag">i</span>，则左子节点索引为 <span class="hljs-number">2</span>*<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span>，右子节点索引为 <span class="hljs-number">2</span>*<span class="hljs-selector-tag">i</span>+<span class="hljs-number">2</span><br><span class="hljs-selector-tag">-</span> 子节点索引为 <span class="hljs-selector-tag">j</span>，则父节点索引为 (j-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>（整数除法）<br><br>具体对应关系：<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">1</span>(索引<span class="hljs-number">0</span>): 左子节点<span class="hljs-number">2</span>(索引<span class="hljs-number">1</span>), 右子节点<span class="hljs-number">3</span>(索引<span class="hljs-number">2</span>)<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">2</span>(索引<span class="hljs-number">1</span>): 左子节点<span class="hljs-number">4</span>(索引<span class="hljs-number">3</span>), 右子节点<span class="hljs-number">5</span>(索引<span class="hljs-number">4</span>)<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">3</span>(索引<span class="hljs-number">2</span>): 左子节点<span class="hljs-number">6</span>(索引<span class="hljs-number">5</span>), 右子节点<span class="hljs-number">7</span>(索引<span class="hljs-number">6</span>)<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">4</span>(索引<span class="hljs-number">3</span>): 左子节点<span class="hljs-number">8</span>(索引<span class="hljs-number">7</span>), 无右子节点<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">5</span><span class="hljs-selector-tag">-8</span>(索引<span class="hljs-number">4</span>-<span class="hljs-number">7</span>): 均为叶节点，无子节点<br></code></pre></td></tr></table></figure>
<h3 id="非完全二叉树顺序存储法"><a href="#非完全二叉树顺序存储法" class="headerlink" title="非完全二叉树顺序存储法"></a><strong>非完全二叉树顺序存储法</strong></h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less">完全二叉树结构：<br>        <span class="hljs-number">1</span><br>       / \<br>      <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>     / \ / \<br>    <span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">6</span>  <span class="hljs-number">7</span><br>   /<br>  <span class="hljs-number">8</span><br><br>数组存储方式（索引从<span class="hljs-number">0</span>开始）：<br>索引:  <span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[7]</span><br>值:    <span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span><span class="hljs-selector-attr">[4]</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[6]</span><span class="hljs-selector-attr">[7]</span><span class="hljs-selector-attr">[8]</span><br><br>父子节点关系：<br><span class="hljs-selector-tag">-</span> 父节点索引为 <span class="hljs-selector-tag">i</span>，则左子节点索引为 <span class="hljs-number">2</span>*<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span>，右子节点索引为 <span class="hljs-number">2</span>*<span class="hljs-selector-tag">i</span>+<span class="hljs-number">2</span><br><span class="hljs-selector-tag">-</span> 子节点索引为 <span class="hljs-selector-tag">j</span>，则父节点索引为 (j-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>（整数除法）<br><br>具体对应关系：<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">1</span>(索引<span class="hljs-number">0</span>): 左子节点<span class="hljs-number">2</span>(索引<span class="hljs-number">1</span>), 右子节点<span class="hljs-number">3</span>(索引<span class="hljs-number">2</span>)<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">2</span>(索引<span class="hljs-number">1</span>): 左子节点<span class="hljs-number">4</span>(索引<span class="hljs-number">3</span>), 右子节点<span class="hljs-number">5</span>(索引<span class="hljs-number">4</span>)<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">3</span>(索引<span class="hljs-number">2</span>): 左子节点<span class="hljs-number">6</span>(索引<span class="hljs-number">5</span>), 右子节点<span class="hljs-number">7</span>(索引<span class="hljs-number">6</span>)<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">4</span>(索引<span class="hljs-number">3</span>): 左子节点<span class="hljs-number">8</span>(索引<span class="hljs-number">7</span>), 无右子节点<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">5</span><span class="hljs-selector-tag">-8</span>(索引<span class="hljs-number">4</span>-<span class="hljs-number">7</span>): 均为叶节点，无子节点<br></code></pre></td></tr></table></figure>
<p>从图中将树转化成数组之后可以看出，完全二叉树用数组来存储只浪费了一个下标为 0 的存储空间，非完全二叉树则浪费了大量的空间。<br><strong>「如果树为完全二叉树，用数组存储比链式存储节约空间，因为数组存储不需要存储左右节点的信息」</strong></p>
<hr>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a><strong>二叉树遍历</strong></h2><p>要了解二叉树的遍历，我们首先需要实例化出一颗二叉树，我们采用链式存储的方式来定义树，实例化树需要树的节点信息，用来存放该节点的信息，因为我们才用的是链式存储，所以我们的节点信息如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一棵树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* 树节点的定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">{</span><br>  TElemType data;<br>  <span class="hljs-type">int</span> parent; <span class="hljs-comment">/* 父节点位置域 */</span><br>} PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">{</span><br>  PTNode nodes[MAX_TREE_SIZE];<br>  <span class="hljs-type">int</span> n; <span class="hljs-comment">/* 节点数 */</span><br>} PTree;<br><br><span class="hljs-comment">/* 二叉树节点的定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span>;</span><br>} TreeNode;<br></code></pre></td></tr></table></figure>
<ol>
<li>使用  <code>PTNode</code>  结构体表示树的节点，包含：<ul>
<li><code>data</code>：存储节点数据（类型为  <code>TElemType</code>）</li>
<li><code>parent</code>：存储父节点在数组中的索引位置</li>
</ul>
</li>
<li>使用  <code>PTree</code>  结构体表示整棵树，包含：<ul>
<li><code>nodes</code>：节点数组，最多可容纳  <code>MAX_TREE_SIZE</code>  个节点</li>
<li><code>n</code>：实际节点数量</li>
</ul>
</li>
</ol>
<p>定义完节点信息之后，我们就可以初始化一颗树啦，下面是初始化树的过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">TreeNode* <span class="hljs-title function_">buildTree</span><span class="hljs-params">()</span> {<br><span class="hljs-comment">// 创建测试用的二叉树</span><br>TreeNode* t1 = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>TreeNode* t2 = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>TreeNode* t3 = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>TreeNode* t4 = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>TreeNode* t5 = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>TreeNode* t6 = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>TreeNode* t7 = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>TreeNode* t8 = (TreeNode\*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br><br>    t1-&gt;data = <span class="hljs-number">1</span>;<br>    t2-&gt;data = <span class="hljs-number">2</span>;<br>    t3-&gt;data = <span class="hljs-number">3</span>;<br>    t4-&gt;data = <span class="hljs-number">4</span>;<br>    t5-&gt;data = <span class="hljs-number">5</span>;<br>    t6-&gt;data = <span class="hljs-number">6</span>;<br>    t7-&gt;data = <span class="hljs-number">7</span>;<br>    t8-&gt;data = <span class="hljs-number">8</span>;<br><br>    t1-&gt;left = t2;<br>    t1-&gt;right = t3;<br>    t2-&gt;left = t4;<br>    t4-&gt;right = t7;<br>    t3-&gt;left = t5;<br>    t3-&gt;right = t6;<br>    t6-&gt;left = t8;<br><br>    t2-&gt;right = <span class="hljs-literal">NULL</span>;<br>    t3-&gt;left = t5;<br>    t3-&gt;right = t6;<br>    t4-&gt;left = <span class="hljs-literal">NULL</span>;<br>    t4-&gt;right = t7;<br>    t5-&gt;left = <span class="hljs-literal">NULL</span>;<br>    t5-&gt;right = <span class="hljs-literal">NULL</span>;<br>    t6-&gt;left = t8;<br>    t6-&gt;right = <span class="hljs-literal">NULL</span>;<br>    t7-&gt;left = <span class="hljs-literal">NULL</span>;<br>    t7-&gt;right = <span class="hljs-literal">NULL</span>;<br>    t8-&gt;left = <span class="hljs-literal">NULL</span>;<br>    t8-&gt;right = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> t1;<br><br>}<br><br></code></pre></td></tr></table></figure>
<p>经过上面步骤之后，我们的树就长成下图所示的样子，数字代表该节点的值。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less">构建的二叉树结构：<br><br>        <span class="hljs-number">1</span><br>       / \<br>      <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>     /   / \<br>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span>   <span class="hljs-number">6</span><br>     \     /<br>      <span class="hljs-number">7</span>   <span class="hljs-number">8</span><br><br><span class="hljs-selector-tag">t1-</span>&gt;<span class="hljs-selector-tag">left</span> = <span class="hljs-selector-tag">t2</span>; <span class="hljs-comment">// 节点1的左子节点是节点2</span><br><span class="hljs-selector-tag">t1-</span>&gt;<span class="hljs-selector-tag">right</span> = <span class="hljs-selector-tag">t3</span>; <span class="hljs-comment">// 节点1的右子节点是节点3</span><br><span class="hljs-selector-tag">t2-</span>&gt;<span class="hljs-selector-tag">left</span> = <span class="hljs-selector-tag">t4</span>; <span class="hljs-comment">// 节点2的左子节点是节点4</span><br><span class="hljs-selector-tag">t4-</span>&gt;<span class="hljs-selector-tag">right</span> = <span class="hljs-selector-tag">t7</span>; <span class="hljs-comment">// 节点4的右子节点是节点7</span><br><span class="hljs-selector-tag">t3-</span>&gt;<span class="hljs-selector-tag">left</span> = <span class="hljs-selector-tag">t5</span>; <span class="hljs-comment">// 节点3的左子节点是节点5</span><br><span class="hljs-selector-tag">t3-</span>&gt;<span class="hljs-selector-tag">right</span> = <span class="hljs-selector-tag">t6</span>; <span class="hljs-comment">// 节点3的右子节点是节点6</span><br><span class="hljs-selector-tag">t6-</span>&gt;<span class="hljs-selector-tag">left</span> = <span class="hljs-selector-tag">t8</span>; <span class="hljs-comment">// 节点6的左子节点是节点8</span><br><br>节点连接关系：<br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">1</span>是根节点，左子节点为<span class="hljs-number">2</span>，右子节点为<span class="hljs-number">3</span><br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">2</span>的左子节点为<span class="hljs-number">4</span>，右子节点为<span class="hljs-selector-tag">NULL</span><br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">3</span>的左子节点为<span class="hljs-number">5</span>，右子节点为<span class="hljs-number">6</span><br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">4</span>的左子节点为<span class="hljs-selector-tag">NULL</span>，右子节点为<span class="hljs-number">7</span><br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">5</span>的左子节点为<span class="hljs-selector-tag">NULL</span>，右子节点为<span class="hljs-selector-tag">NULL</span><br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">6</span>的左子节点为<span class="hljs-number">8</span>，右子节点为<span class="hljs-selector-tag">NULL</span><br><span class="hljs-selector-tag">-</span> 节点<span class="hljs-number">7</span>和<span class="hljs-number">8</span>都是叶节点，没有子节点<br></code></pre></td></tr></table></figure>
<p>有了树之后，我们就可以对树进行遍历<br>二叉树的遍历有三种方式，前序遍历，中序遍历，后续遍历三种遍历方式，三种遍历方式与节点输出的顺序有关系</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><strong>前序遍历</strong></h3><p><strong>「前序遍历」</strong>：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
<p class='item-img' data-src='https://pic1.zhimg.com/v2-8c5bca63a9ce3aa30a46e37942281684_b.webp'><img src="https://pic1.zhimg.com/v2-8c5bca63a9ce3aa30a46e37942281684_b.webp" alt="动图封面"></p>
<p>理解了前序遍历的概念和看完前序遍历执行流程动态图之后，你心里一定很想知道，在代码中如何怎么实现树的前序遍历？二叉树的遍历非常简单，一般都是采用递归的方式进行遍历，我们来看看前序遍历的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 先序遍历，递归实现 先打印本身，再打印左节点，在打印右节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode\* root)</span> {<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-comment">// 输出本身</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);<br><span class="hljs-comment">// 遍历左节点</span><br>preOrder(root-&gt;left);<br><span class="hljs-comment">// 遍历右节点</span><br>preOrder(root-&gt;right);<br>}<br><br></code></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><strong>中序遍历</strong></h3><p><strong>「中序遍历」</strong>：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
<p>跟前序遍历一样，我们来看看中序遍历的执行流程动态图。</p>
<p class='item-img' data-src='https://pic3.zhimg.com/v2-46511b7421ee1ce8534fcbd580d9a316_b.webp'><img src="https://pic3.zhimg.com/v2-46511b7421ee1ce8534fcbd580d9a316_b.webp" alt="动图封面"></p>
<p>中序遍历的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 中序遍历 先打印左节点，再输出本身，最后输出右节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode\* root)</span> {<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">return</span>;<br>}<br>inOrder(root-&gt;left);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);<br>inOrder(root-&gt;right);<br>}<br><br></code></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><strong>「后序遍历」</strong>：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
<p>跟前两种遍历一样，理解概念之后，我们还是先来看张图。</p>
<p class='item-img' data-src='https://pic2.zhimg.com/v2-99b3066d8e4f5d268302acea5e20568f_b.webp'><img src="https://pic2.zhimg.com/v2-99b3066d8e4f5d268302acea5e20568f_b.webp" alt="动图封面"></p>
<p>后序遍历的实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 后序遍历 先打印左节点，再输出右节点，最后才输出本身</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode\* root)</span> {<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">return</span>;<br>}<br>postOrder(root-&gt;left);<br>postOrder(root-&gt;right);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);<br>}<br><br></code></pre></td></tr></table></figure>
<p>二叉树有三种遍历方式，但都是一样的，只是输出的顺序不一样</p>
<p>接下来还有一种常用而且比较特殊的二叉树：<strong>「二叉查找树」</strong></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a><strong>二叉查找树</strong></h2><p>二叉查找树又叫二叉搜索树，从名字中我们就能够知道，这种树在查找方面一定有过人的优势，事实确实如此，二叉查找树确实是为查找而生的树，但是它不仅仅支持快速查找数据，还支持快速插入、删除一个数据</p>
<p><strong>「二叉查找树」</strong>：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值，下面定义了一颗二叉查找树</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less">        <span class="hljs-number">62</span><br>       /  \<br>      <span class="hljs-number">58</span>   <span class="hljs-number">88</span><br>     /  \ /  \<br>    <span class="hljs-number">47</span>  <span class="hljs-number">51</span> <span class="hljs-number">73</span>  <span class="hljs-number">99</span><br>   /           /<br>  <span class="hljs-number">35</span>          <span class="hljs-number">93</span><br>   \<br>    <span class="hljs-number">37</span><br>   /  \<br>  <span class="hljs-number">36</span>  <span class="hljs-number">39</span><br>       \<br>        <span class="hljs-number">42</span><br><br><span class="hljs-selector-tag">-</span> 对于任意节点，其左子树中的所有节点值都小于该节点值<br><span class="hljs-selector-tag">-</span> 其右子树中的所有节点值都大于该节点值<br><span class="hljs-selector-tag">-</span> 根节点 `<span class="hljs-number">62</span>`：左子树所有节点（<span class="hljs-number">58</span>, <span class="hljs-number">47</span>, <span class="hljs-number">35</span>, <span class="hljs-number">37</span>, <span class="hljs-number">36</span>, <span class="hljs-number">39</span>, <span class="hljs-number">42</span>, <span class="hljs-number">51</span>）都小于 <span class="hljs-number">62</span>；右子树所有节点（<span class="hljs-number">88</span>, <span class="hljs-number">73</span>, <span class="hljs-number">99</span>, <span class="hljs-number">93</span>）都大于 <span class="hljs-number">62</span><br><span class="hljs-selector-tag">-</span> 节点 `<span class="hljs-number">58</span>`：左子树（<span class="hljs-number">47</span>, <span class="hljs-number">35</span>, <span class="hljs-number">37</span>, <span class="hljs-number">36</span>, <span class="hljs-number">39</span>, <span class="hljs-number">42</span>）都小于 <span class="hljs-number">58</span>；右子树（<span class="hljs-number">51</span>）大于 <span class="hljs-number">58</span><br><span class="hljs-selector-tag">-</span> 节点 `<span class="hljs-number">88</span>`：左子树（<span class="hljs-number">73</span>）小于 <span class="hljs-number">88</span>；右子树（<span class="hljs-number">99</span>, <span class="hljs-number">93</span>）大于 <span class="hljs-number">88</span><br></code></pre></td></tr></table></figure>
<p>根据二叉查找树的定义，每棵树的左节点的值要小于这父节点，右节点的值要大于父节点<br>下面从二叉查找树的查找开始学习二叉查找树</p>
<h2 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a><strong>二叉查找树的查找操作</strong></h2><p>由于二叉查找树的特性，我们需要查找一个数据，先跟跟节点比较，如果值等于跟节点，则返回根节点，如果小于根节点，则必然在左子树这边，只要递归查找左子树就行，如果大于，这在右子树这边，递归右子树即可。这样就能够实现快速查找，因为每次查找都减少了一半的数据，跟二分查找有点相似，快速插入、删除都是居于这个特性实现的。</p>
<p>下面用一幅动态图来加强对二叉查找树查找流程的理解，在上面的这颗二叉查找树中找出值等于 37 的节点：</p>
<p class='item-img' data-src='https://pic1.zhimg.com/v2-dbca7edcda530ecf983b42216772dfae_b.webp'><img src="https://pic1.zhimg.com/v2-dbca7edcda530ecf983b42216772dfae_b.webp" alt="动图"></p>
<ul>
<li>1、先用 37 跟 62 比较，37 &lt; 62 ，在左子树中继续查找</li>
<li>２、左子树的节点值为 58，37 &lt; 58 ，继续在左子树中查找</li>
<li>３、左子树的节点值为 47，37 &lt; 47，继续在左子树中查找</li>
<li>４、左子树的节点值为 35，37 &gt; 35，在右子树中查找</li>
<li>５、右子树中的节点值为 37，37 = 37 ，返回该节点</li>
</ul>
<p>讲完了查找的概念之后，我们一起来看看二叉查找树的查找操作的代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在二叉查找树中查找指定值的节点</span><br><span class="hljs-comment"> * @param tree 二叉查找树的根节点</span><br><span class="hljs-comment"> * @param data 要查找的数据值</span><br><span class="hljs-comment"> * @return 找到的节点指针，如果未找到则返回NULL</span><br><span class="hljs-comment"> */</span><br>TreeNode* <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode* tree, <span class="hljs-type">int</span> data)</span> {<br>    <span class="hljs-comment">// 从根节点开始遍历</span><br>    TreeNode* current = tree;<br><br>    <span class="hljs-comment">// 当当前节点不为空时继续查找</span><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-comment">// 如果要查找的值小于当前节点值，在左子树中查找</span><br>        <span class="hljs-keyword">if</span> (data &lt; current-&gt;data) {<br>            current = current-&gt;left;<br>        }<br>        <span class="hljs-comment">// 如果要查找的值大于当前节点值，在右子树中查找</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; current-&gt;data) {<br>            current = current-&gt;right;<br>        }<br>        <span class="hljs-comment">// 如果值相等，找到了目标节点</span><br>        <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">return</span> current;<br>        }<br>    }<br><br>    <span class="hljs-comment">// 未找到目标节点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br><br></code></pre></td></tr></table></figure>
<h2 id="二叉查找树的插入操作"><a href="#二叉查找树的插入操作" class="headerlink" title="二叉查找树的插入操作"></a><strong>二叉查找树的插入操作</strong></h2><p>插入跟查找差不多，也是从根节点开始找，如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<p>假设我们要插入 63 ，我们用一张动态图来看看插入的流程。</p>
<p class='item-img' data-src='https://pica.zhimg.com/v2-a3bb96d446f90e825f758a560e740f8a_b.webp'><img src="https://pica.zhimg.com/v2-a3bb96d446f90e825f758a560e740f8a_b.webp" alt="动图封面"></p>
<ul>
<li>1、63 &gt; 62 ，在树的右子树继续查找.</li>
<li>2、63 &lt; 88 ，在树的左子树继续查找</li>
<li>3、63 &lt; 73 ,因为 73 是叶子节点，所以 63 就成为了 73 的左子树。</li>
</ul>
<p>我们来看看二叉查找树的插入操作实现代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在二叉查找树中查找指定值的节点</span><br><span class="hljs-comment"> * @param tree 二叉查找树的根节点</span><br><span class="hljs-comment"> * @param data 要查找的数据值</span><br><span class="hljs-comment"> * @return 找到的节点指针，如果未找到则返回NULL</span><br><span class="hljs-comment"> */</span><br>TreeNode* <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode* tree, <span class="hljs-type">int</span> data)</span> {<br>    <span class="hljs-comment">// 从根节点开始遍历</span><br>    TreeNode* current = tree;<br><br>    <span class="hljs-comment">// 当当前节点不为空时继续查找</span><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-comment">// 如果要查找的值小于当前节点值，在左子树中查找</span><br>        <span class="hljs-keyword">if</span> (data &lt; current-&gt;data) {<br>            current = current-&gt;left;<br>        }<br>        <span class="hljs-comment">// 如果要查找的值大于当前节点值，在右子树中查找</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; current-&gt;data) {<br>            current = current-&gt;right;<br>        }<br>        <span class="hljs-comment">// 如果值相等，找到了目标节点</span><br>        <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">return</span> current;<br>        }<br>    }<br><br>    <span class="hljs-comment">// 未找到目标节点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></table></figure>
<h2 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a><strong>二叉查找树的删除操作</strong></h2><p>删除的逻辑要比查找和插入复杂一些，删除分一下三种情况：</p>
<p><strong>「第一种情况」</strong>：如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 51。</p>
<p><strong>「第二种情况」</strong>：如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 35。</p>
<p><strong>「第三种情况」</strong>：如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 88</p>
<p>前面两种情况稍微简单一些，第三种情况，我制作了一张动态图，希望能对你有所帮助。</p>
<p class='item-img' data-src='https://picx.zhimg.com/v2-ee38bef7b1b648d935dfa0c4cc0882c5_b.webp'><img src="https://picx.zhimg.com/v2-ee38bef7b1b648d935dfa0c4cc0882c5_b.webp" alt="动图封面"></p>
<p>我们来看看二叉查找树的删除操作实现代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(TreeNode** tree, <span class="hljs-type">int</span> data)</span> {<br>    TreeNode* p = *tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span><br>    TreeNode* pp = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// pp记录的是p的父节点</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data != data) {<br>        pp = p;<br>        <span class="hljs-keyword">if</span> (data &gt; p-&gt;data) p = p-&gt;right;<br>        <span class="hljs-keyword">else</span> p = p-&gt;left;<br>    }<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span><br><br>    <span class="hljs-comment">// 要删除的节点有两个子节点</span><br>    <span class="hljs-keyword">if</span> (p-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 查找右子树中最小节点</span><br>        TreeNode* minP = p-&gt;right;<br>        TreeNode* minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span><br>        <span class="hljs-keyword">while</span> (minP-&gt;left != <span class="hljs-literal">NULL</span>) {<br>            minPP = minP;<br>            minP = minP-&gt;left;<br>        }<br>        p-&gt;data = minP-&gt;data; <span class="hljs-comment">// 将minP的数据替换到p中</span><br>        p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span><br>        pp = minPP;<br>    }<br><br>    <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span><br>    TreeNode* child; <span class="hljs-comment">// p的子节点</span><br>    <span class="hljs-keyword">if</span> (p-&gt;left != <span class="hljs-literal">NULL</span>) child = p-&gt;left;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;right != <span class="hljs-literal">NULL</span>) child = p-&gt;right;<br>    <span class="hljs-keyword">else</span> child = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (pp == <span class="hljs-literal">NULL</span>) *tree = child; <span class="hljs-comment">// 删除的是根节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp-&gt;left == p) pp-&gt;left = child;<br>    <span class="hljs-keyword">else</span> pp-&gt;right = child;<br><br>    <span class="hljs-built_in">free</span>(p); <span class="hljs-comment">// 释放被删除节点的内存</span><br>}<br></code></pre></td></tr></table></figure>
<p>二叉查找树在极端情况下会退化成链表，例如每个节点都只有一个左节点，这是时间复杂度就变成了 O(n)，为了避免这种情况，又出现了一种新的树叫「平衡二叉查找树」，之后再开坑讲</p>
<p>还有个前缀树，之后也会开坑讲一下</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/posts/41925.html">← 下一篇 利用chrome F12 测试应用实践详解</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/posts/33985.html">数据结构-栈 上一篇 →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">树的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%91%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">１、完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%92%E3%80%81%E9%9D%9E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.</span> <span class="toc-text">２、非完全二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">二叉树的存储模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">二叉链式存储法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">顺序存储法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">完全二叉树顺序存储法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">非完全二叉树顺序存储法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">6.</span> <span class="toc-text">二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">二叉查找树的查找操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">9.</span> <span class="toc-text">二叉查找树的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">10.</span> <span class="toc-text">二叉查找树的删除操作</span></a></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>