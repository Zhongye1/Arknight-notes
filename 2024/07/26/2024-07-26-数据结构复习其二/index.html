<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构复习其二 | Hexo</title><link rel="icon" type="image/x-icon" href="/Arknight-notes/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/Arknight-notes/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/Arknight-notes/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/Arknight-notes/font/Bender.ttf"), url("/Arknight-notes/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/Arknight-notes/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/Arknight-notes/","code_fold":15,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/Arknight-notes/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/Arknight-notes/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/Arknight-notes/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://pic2.zhimg.com/v2-6269d74b4dafe14781d03790e5a86b21_r.jpg');
 --light-background: url('https://pic1.zhimg.com/v2-233b64b583642fc4a6d77e69ced33150_r.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/Arknight-notes/js/arknights.js"></script><script defer src="/Arknight-notes/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/Arknight-notes/lib/encrypt/hbe.js"></script><script async src="/Arknight-notes/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/Arknight-notes/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/Arknight-notes/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Arknight-notes/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>数据结构复习其二</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-07-25T18:48:08.000Z" id="date"> 2024-07-26</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-07-31T03:58:47.890Z" id="updated"> 2024-07-31</time></div></span></div></div><hr><div id="post-content"><ul>
<li></li>
</ul>
<h3 id="——算法、线性表——"><a href="#——算法、线性表——" class="headerlink" title="——算法、线性表——"></a>——算法、线性表——</h3><h3 id="概念明晰：随机存取、顺序存取、随机存储和顺序存储"><a href="#概念明晰：随机存取、顺序存取、随机存储和顺序存储" class="headerlink" title="概念明晰：随机存取、顺序存取、随机存储和顺序存储"></a>概念明晰：随机存取、顺序存取、随机存储和顺序存储</h3><blockquote>
<p>随机存取、顺序存取、随机存储和顺序存储这四个概念是完全不一样的，切不可将之混淆</p>
<p>很多人包括我可能认为随机存取就是随机存储，顺序存取就是顺序存取，其实不是这样。</p>
</blockquote>
<p>下面完整的介绍一下这4个概念</p>
<h5 id="1、存取结构"><a href="#1、存取结构" class="headerlink" title="1、存取结构"></a>1、存取结构</h5><h5 id="分为随机存取和非随机存取（又称顺序存取）"><a href="#分为随机存取和非随机存取（又称顺序存取）" class="headerlink" title="分为随机存取和非随机存取（又称顺序存取）"></a>分为<code>随机存取</code>和<code>非随机存取</code>（又称顺序存取）</h5><blockquote>
<p>1、<code>随机存取</code>就是<code>直接存取</code>，可以通过<strong>下标直接访问</strong>的那种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>，与<strong>存储位置无关</strong>。例如数组。</p>
<p> <code>非随机存取</code>就是<code>顺序存取</code>，不能通过下标访问了，只能<strong>按照存储顺序存取</strong>，与<strong>存储位置有关</strong>，例如链表。</p>
<p>2、<code>顺序存取</code>就是存取第N个数据时，<strong>必须先访问</strong>前（N-1）个数据 （list）;</p>
<p> <code>随机存取</code>就是存取第N个数据时，<strong>不需要</strong>访问前（N-1）个数据，<strong>直接</strong>就可以对第N个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">数据操作</a> （array）。</p>
</blockquote>
<h5 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h5><h5 id="分为顺序存储和随机存储"><a href="#分为顺序存储和随机存储" class="headerlink" title="分为顺序存储和随机存储"></a>分为<code>顺序存储</code>和<code>随机存储</code></h5><h5 id="3、顺序存储结构"><a href="#3、顺序存储结构" class="headerlink" title="3、顺序存储结构"></a>3、顺序存储结构</h5><blockquote>
<ul>
<li><p>在计算机中用一组<strong>地址连续的存储单元</strong>依次存储线性表的各个数据元素，称作线性表的顺序存储结构。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>顺序存储结构是存储结构类型中的一种，该结构是把<span class="hljs-strong">**逻辑上相邻的节点**</span>存储在<span class="hljs-strong">**物理位置上相邻的存储单元**</span>中，结点之间的逻辑关系由存储单元的邻接关系来体现。 <br><span class="hljs-bullet">- </span>由此得到的储结构为顺序存储结构，通常顺序存储结构是借助于计算机程序设计语言（例如c/c++）的数组来描述的。<br>12<br></code></pre></td></tr></table></figure></li>
</ul>
<p> – <strong>主要优点</strong>：节省存储空间。</p>
<p> 因为分配给数据的存储单元全用存放结点的数据（不考虑c&#x2F;c++语言中数组需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。采用这种方法时，<strong>可实现对结点的随机存取</strong>，即每一个结点对应一个序号，由该序号可以<strong>直接计算出来结点的存储地址</strong>。</p>
<p> – <strong>主要缺点</strong>：不便于修改，对结点的插入、删除运算时可能要移动一系列的结点。</p>
</blockquote>
<h5 id="4、随机存储结构"><a href="#4、随机存储结构" class="headerlink" title="4、随机存储结构"></a>4、随机存储结构</h5><blockquote>
<p>在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。它不要求逻辑上相邻的元素在物理位置上也相邻。因此它没有顺序存储结构所具有的弱点，但也同时失去了顺序表可随机存取的优点。</p>
</blockquote>
<p> –随机存储<strong>最典型的代表</strong>为链式存储：</p>
<p>链式存储结构特点</p>
<p>1、比顺序存储结构的存储密度小 （每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多）。</p>
<p>2、逻辑上相邻的节点物理上不必相邻。</p>
<p>3、插入、删除灵活 （不必移动节点，只要改变节点中的指针）。</p>
<p>4、查找结点时链式存储要比顺序存储慢。</p>
<p>5、每个结点是由数据域和指针域组成</p>
<h4 id="一、数据结构的概念"><a href="#一、数据结构的概念" class="headerlink" title="一、数据结构的概念"></a>一、数据结构的概念</h4><h5 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念:"></a>1、基本概念:</h5><blockquote>
<ul>
<li>数据：描述客观事实的符号，是计算机中可以操作的对象，能被计算机识别，并输给计算机处理的符号集合。</li>
<li>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被成为记录。</li>
<li>数据对象：是性质相同数据元素的集合，是数据的一个子集。</li>
<li>数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。</li>
<li>数据结构：相互之间存在一种或者多种特定关系的数据元素的集合。可分为逻辑结构和物理结构。</li>
</ul>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f3aa801.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3aa801.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H2EEsw2b-1641217649127)(myReviewPicture&#x2F;数据结构的类别-16411800000834.jpg)]"></p>
<h5 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h5><h6 id="1-概念"><a href="#1-概念" class="headerlink" title="(1)概念"></a>(1)概念</h6><blockquote>
<p>解决特定问题的求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p>
</blockquote>
<h6 id="2-重要特性："><a href="#2-重要特性：" class="headerlink" title="(2)重要特性："></a>(2)重要特性：</h6><blockquote>
<p><strong>①输入</strong>：有零个输入或者多个输</p>
<p><strong>②输出</strong>：只有一个或者多个输出</p>
<p><strong>③有穷性</strong>：算法在执行有限个步骤时，会自动结束而不会陷入无限循环里面</p>
<p><strong>④确定性</strong>：算法的每一步都有确定的含义而不会出现二义性</p>
<p><strong>⑤可行性</strong>：算法的每一步都可以通过有限次数完成。</p>
</blockquote>
<h5 id="3、算法的评价标准-“好”的算法应该考虑达到以下目标"><a href="#3、算法的评价标准-“好”的算法应该考虑达到以下目标" class="headerlink" title="3、算法的评价标准(“好”的算法应该考虑达到以下目标)"></a>3、算法的评价标准(“好”的算法应该考虑达到以下目标)</h5><blockquote>
<p><strong>①正确性</strong>。算法能够正确地求解问题。</p>
<p><strong>②可读性</strong>。算法能具有良好的可读性，以帮助人们理解。</p>
<p><strong>③健壮性</strong>。输入非法数据时，算法能适当地做出反应或进行处理。而不会产生莫名其妙的输出结果。</p>
<p><strong>④效率与低存储量需求</strong>。效率指算法执行的时间，存储量需求是指算法执行过程中所需的最大存储空间。</p>
</blockquote>
<h5 id="4、算法的时空效率"><a href="#4、算法的时空效率" class="headerlink" title="4、算法的时空效率"></a>4、算法的时空效率</h5><h6 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h6><h6 id="根据算法写成的程序在执行时耗费时间的长度，记为T-n-O-n"><a href="#根据算法写成的程序在执行时耗费时间的长度，记为T-n-O-n" class="headerlink" title="根据算法写成的程序在执行时耗费时间的长度，记为T(n) &#x3D; O(n)"></a>根据算法写成的程序在执行时耗费时间的长度，记为T(n) &#x3D; O(n)</h6><h6 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h6><h6 id="根据算法写成的程序在执行时占用存储单元的长度记为S-n"><a href="#根据算法写成的程序在执行时占用存储单元的长度记为S-n" class="headerlink" title="根据算法写成的程序在执行时占用存储单元的长度记为S(n)"></a>根据算法写成的程序在执行时占用存储单元的长度记为S(n)</h6><h6 id="3-语句频度"><a href="#3-语句频度" class="headerlink" title="(3)语句频度"></a>(3)语句频度</h6><h6 id="一个算法中的语句执行次数称为语句频度或时间频度，记为T-n"><a href="#一个算法中的语句执行次数称为语句频度或时间频度，记为T-n" class="headerlink" title="一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)"></a>一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)</h6><blockquote>
<p>时间复杂度：时间复杂度实际上是一个函数，代表基本操作重复执行的次数，进而分析函数虽变量的变化来确定数量级，数量级用O表示，所以算法的时间复杂度为： T（n）&#x3D;O（f（n））</p>
</blockquote>
<blockquote>
<p>在一个算法存在最好、平均、最坏<strong>三种情况</strong>，我们一般关注的是<strong>最坏情况</strong>，原因是，最坏情况是任何输入实例在运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，从大体上来看，平均情况和最坏情况一样差。</p>
</blockquote>
<h6 id="4-一般O（n）的计算方法："><a href="#4-一般O（n）的计算方法：" class="headerlink" title="(4)一般O（n）的计算方法："></a>(4)一般O（n）的计算方法：</h6><blockquote>
<p>①用 1代替所有运行时间中出现的<strong>加法常数</strong>；</p>
<p>②在修改后的运行函数中**保留最高阶的项；</p>
<p>③如果<strong>最高阶</strong>的<strong>项系数不是1</strong>，则<strong>去除</strong>这个项系数。</p>
<p>④ <strong>递归算法</strong>的时间复杂度为：递归总次数每次递归中基本操作执行的次数。</p>
</blockquote>
<h6 id="5-常见的时间复杂度有以下七种："><a href="#5-常见的时间复杂度有以下七种：" class="headerlink" title="(5)常见的时间复杂度有以下七种："></a>(5)常见的时间复杂度有以下七种：</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f3338b6.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3338b6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fChDxRHo-1641217649129)(myReviewPicture&#x2F;时间复杂度的比较-16411800195595.png)]"></p>
<p><strong>① O（1）常数型；② O（log2N）对数型；③ O（N）线性型；④ O（Nlog2N）二维型；⑤ O（N^2)平方型；⑥ O（N^3)立方型；⑦ O（2^N）指数型。</strong></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">i=<span class="hljs-number">1</span>;①<br><span class="hljs-keyword">while</span> (i&lt;=n)<br>&#123;<br>	i=i*<span class="hljs-number">2</span>; ②<br>&#125;<br>解：语句<span class="hljs-number">1</span>的频度是<span class="hljs-number">1</span>, <br>设语句<span class="hljs-number">2</span>的频度是f(n),则：<span class="hljs-number">2</span>^f(n)&lt;=n;f(n)&lt;=log2n  <br>取最大值f(n)= log2n, T(n)=O(log2n )<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h3 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h3><h4 id="1、顺序存储"><a href="#1、顺序存储" class="headerlink" title="1、顺序存储"></a>1、顺序存储</h4><h5 id="1-结构体的定义"><a href="#1-结构体的定义" class="headerlink" title="(1)结构体的定义"></a>(1)结构体的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> * PtrToLNode;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span><br>&#123;<br>    ElmenetType Data[ MAXSIZE ];<br>    Position Last;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToLNode List;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h5 id="2-顺序表的初始化"><a href="#2-顺序表的初始化" class="headerlink" title="(2)顺序表的初始化"></a>(2)顺序表的初始化</h5><blockquote>
<p>1、构造一个空表</p>
<p>2、动态分配表结构所需的存储空间，然后将表中Last指针置为-1 表示表中没有数据。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">List <span class="hljs-title">MakeEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    List L;	<br>    L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>    L-&gt;Last = <span class="hljs-number">-1</span>;	<span class="hljs-comment">//Last 置为-1 表示表中没有数据元素</span><br>    Return L;<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure>

<ul>
<li>通过L我们可以访问相应线性表的内容。比如：下标为i 的元素：L-&gt;Data[i]</li>
<li>查询线性表的长度：L-&gt;Last+1;</li>
</ul>
<h5 id="3-顺序表的查找-时间复杂度为O-n"><a href="#3-顺序表的查找-时间复杂度为O-n" class="headerlink" title="(3)顺序表的查找(时间复杂度为O(n))"></a>(3)顺序表的查找(时间复杂度为O(n))</h5><blockquote>
<p>在线性表中<strong>查找与给定值 X 相等</strong>的数据元素。</p>
<p>由于线性表的元素都<strong>存储在数组Data</strong>中，所以这个查找的过程<strong>实际上就是在数组里顺序查找</strong>：</p>
<ul>
<li>从<strong>第 1 个元素 a1</strong> 起依次和 X 比较， 直到找到一个与 X <strong>相等</strong>的数据元素，返回它在顺序表中的<strong>存储下标</strong>；</li>
<li>或者<strong>查遍整个表</strong>都<strong>没有找到</strong>与 X 相等的元素，则返回错误信息 <strong>ERROR</strong>。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1  <span class="hljs-comment">/* 将错误信息 ERROR 的值定义为任一负数都可以 */</span></span><br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( List L, ElementType X )</span></span><br><span class="hljs-function"></span>&#123;<br>    Position i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">While</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X)<br>    	i++;<br>    <span class="hljs-keyword">if</span>( i &gt; L-&gt;Last)<br>    	<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">/* 如果没有找到，则返回错误信息 */</span><br>    <span class="hljs-keyword">else</span><br>    	<span class="hljs-keyword">return</span> i;	<span class="hljs-comment">/* 找到后返回的是存储位置 */</span><br>&#125;<br><span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure>

<h5 id="4）顺序表的插入-时间复杂度为O-n"><a href="#4）顺序表的插入-时间复杂度为O-n" class="headerlink" title="(4）顺序表的插入 (时间复杂度为O(n))"></a>(4）顺序表的插入 (时间复杂度为O(n))</h5><blockquote>
<p>在表的插入是指在表的第 i（1≤ i ≤ n + 1）个位序上<strong>插入一个值为 X 的新元素</strong>（也可以理解为在第 i 个元素之前插入新的元素）</p>
<p>插入后使得<strong>原来长度为 n</strong> 的序列，变为<strong>长度为 n+1</strong>的序列（i &#x3D; 1时插入序列的最前端，i &#x3D; n+1 时插入序列的最后）</p>
<ul>
<li>将ai~an<strong>顺序向后</strong>移动（移动次序是从 an 到ai)，<strong>为新元素让出位置</strong>；</li>
<li>将 X 放入空出的<strong>第 i 个位序</strong>；</li>
<li><strong>修改</strong> Last 指针（相当于修改表长）,使之指向<strong>最后一个元素</strong>。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">( List L, ElementType X, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 在 L 的指定位序 i 前插入一个新元素 X； 位序 i 元素数组位置下标为 i-1 */</span><br>    Postion j;<br>    <span class="hljs-keyword">if</span>(L-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>)<br>    &#123;<span class="hljs-comment">/* 表空间已满，不能插入 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满！\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>( i&lt;<span class="hljs-number">1</span> || i &gt; L-&gt;Last<span class="hljs-number">+2</span>)<br>    &#123;<span class="hljs-comment">/* 检查插入位序的合法性：是否在 1~n+1； n为当前元素个数，即Last+1 */</span><br>        printf（<span class="hljs-string">&quot;位序不合法！\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>( j = L-&gt;Last; j &gt;= i<span class="hljs-number">-1</span>; j--) <span class="hljs-comment">/*Last 指向序列最后元素an */</span><br>        L-&gt;Data[j<span class="hljs-number">+1</span>] = L-&gt;Data[j]; <span class="hljs-comment">/* 将位序为 i 及以后的元素顺序向后移动 */</span><br>   	L-&gt;Data[i<span class="hljs-number">-1</span>] = X;	<span class="hljs-comment">/* Last 仍指向最后一个元素 */</span><br>    L-&gt;Last++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure>

<h5 id="5-顺序表的删除（时间复杂度为O-n-）"><a href="#5-顺序表的删除（时间复杂度为O-n-）" class="headerlink" title="(5)顺序表的删除（时间复杂度为O(n)）"></a>(5)顺序表的删除（时间复杂度为O(n)）</h5><blockquote>
<p>将表中的位序为 i（1≤ i ≤ n + 1）的元素从线性表中去掉，删除后使原长度为 n 的数组元素序列,变为长度为 n-1 的序列</p>
<ul>
<li>将a[i+1]~a[n] <strong>顺序向前移动</strong> ，a[i] 元素被a[i+1]覆盖；</li>
<li><strong>修改</strong> Last 指针（相当于修改表长）使之仍指向<strong>最后一个元素</strong>。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Delete</span><span class="hljs-params">(List L, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">/*从 L 中删除指定位序 i 的元素，该元素数组下标为 i-1*/</span><br>	Position j;<br>	<br>	<span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L-&gt;Last + <span class="hljs-number">1</span>)<span class="hljs-comment">/* 检查空表及删除位序的合法性*/</span> <br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位序%d不存在元素&quot;</span>,i);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125; <br>    <br>	<span class="hljs-keyword">for</span>( j = i; i &lt;= L-&gt;Last; j++)<br>		L-&gt;Data[j<span class="hljs-number">-1</span>] = L-&gt;Data[j];<span class="hljs-comment">/*将位序 i+1 及以后的元素顺序向前移动*/</span> <br>	L-&gt;Last--;<span class="hljs-comment">/*Last 仍指向最后元素*/</span> <br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br><span class="hljs-number">123456789101112131415</span><br></code></pre></td></tr></table></figure>

<h4 id="2、链表存储"><a href="#2、链表存储" class="headerlink" title="2、链表存储"></a>2、链表存储</h4><h6 id="1）结构体的定义（时间复杂度为O-n-）"><a href="#1）结构体的定义（时间复杂度为O-n-）" class="headerlink" title="(1）结构体的定义（时间复杂度为O(n)）"></a>(1）结构体的定义（时间复杂度为O(n)）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> * PtrToLNode;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span><br>&#123;<br>    ElementType Data;<br>    PtrToLNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToLNode Position; <span class="hljs-comment">/*这里的位置是结点的地址 */</span><br><span class="hljs-keyword">typedef</span> PreToLNode List;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h6 id="2-求表长（时间复杂度为O-n-）"><a href="#2-求表长（时间复杂度为O-n-）" class="headerlink" title="(2)求表长（时间复杂度为O(n)）"></a>(2)求表长（时间复杂度为O(n)）</h6><blockquote>
<p>在<strong>顺序存储</strong>中求表长是很容易的，<strong>直接返回 Last+1</strong> 就可以了。但在<strong>链式存储</strong>中，需要将链表<strong>从头到尾遍历一遍</strong></p>
<ul>
<li>设一个<strong>移动指针p和计数器cnt</strong>，初始化后，p从表的第 1 个结点开始逐步往后移，同时计数器 cnt+1.</li>
<li>当后面不再有结点时，cnt 的值就是结点个数，即 表长。</li>
</ul>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f3dea89.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3dea89.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Length</span><span class="hljs-params">(List L)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//默认该链表是有头结点的   </span><br>	Position p;<br>	<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;  <span class="hljs-comment">/* 初始化计数器 */</span><br>    <br>    <span class="hljs-comment">//单向链表的遍历(三部曲)</span><br>	p = L-&gt;next; <span class="hljs-comment">/* p指向表的第 1 个结点 */</span><br>	<span class="hljs-keyword">while</span>(p)<br>	&#123; <span class="hljs-comment">/* 遍历单链表，统计结点数 */</span> <br>		p=p-&gt;next;  <br>		i++; <br>	&#125; <br>	<span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-number">1234567891011121314</span><br></code></pre></td></tr></table></figure>

<h6 id="3-判空"><a href="#3-判空" class="headerlink" title="(3)判空"></a>(3)判空</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(LinkList L)</span></span><br><span class="hljs-function"></span>&#123;	<span class="hljs-comment">//若 L 为空，则返回1，否侧返回 0</span><br>	<span class="hljs-keyword">if</span>(L-&gt;Next) <span class="hljs-comment">//非空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure>

<h6 id="4-查找（时间复杂度为O-n-）"><a href="#4-查找（时间复杂度为O-n-）" class="headerlink" title="(4)查找（时间复杂度为O(n)）"></a>(4)查找（时间复杂度为O(n)）</h6><blockquote>
<p>有两种 按序号查找（FindKth）和 按值查找（Find）</p>
</blockquote>
<h6 id="①按序号查找-FindKth（时间复杂度为O-n-）"><a href="#①按序号查找-FindKth（时间复杂度为O-n-）" class="headerlink" title="①按序号查找 FindKth（时间复杂度为O(n)）"></a>①按序号查找 FindKth（时间复杂度为O(n)）</h6><blockquote>
<p>对于<strong>顺序存储</strong>，按序号查找是很直接的事情，要得到<strong>第 K 个元素的值，直接取L-&gt;Data[K-1]即可</strong>。</p>
<p>但是对于<strong>链式存储</strong>则需要采用跟<strong>求表长类似的思路</strong>：</p>
<ul>
<li>从链表的<strong>第 1 个元素</strong>结点起，判断<strong>当前结点是否是第 K 个</strong>；</li>
<li>若<strong>是</strong>，则<strong>返回</strong>该结点的值，<strong>否</strong>则继续<strong>对比后一个</strong>，直到<strong>表结束为止</strong>。</li>
<li>如果<strong>没有</strong>第 K 个结点则返回<strong>错误信息</strong>。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1 <span class="hljs-comment">/* 一般定义为表中元素不可能取到的值 */</span></span><br><br><span class="hljs-function">ElementType <span class="hljs-title">FindKth</span><span class="hljs-params">(List L, <span class="hljs-type">int</span> K)</span> </span><br><span class="hljs-function"></span>&#123;	<span class="hljs-comment">/* 根据指定的位序 K， 返回 L 中相应的元素 */</span><br>	Position P;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 位序从 1 开始 */</span><br>	p = L; <span class="hljs-comment">/* p 指向 L的第 1 个结点 */</span><br>	<span class="hljs-keyword">while</span>(p &amp;&amp; cnt &lt; K)<br>	&#123;<br>		p = p-&gt;next;<br>		cnt++<br>	&#125; <br>	<br>	<span class="hljs-keyword">if</span>((cnt == K) &amp;&amp; p)<br>		<span class="hljs-keyword">return</span> p-&gt;Data;	<span class="hljs-comment">/* 返回第 K 个 */</span><br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> ERROR;	<span class="hljs-comment">/* 否则返回错误信息 */</span><br>&#125; <br><span class="hljs-number">123456789101112131415161718</span><br></code></pre></td></tr></table></figure>

<h6 id="②按值查找，即定位-Find（时间复杂度为O-n-）"><a href="#②按值查找，即定位-Find（时间复杂度为O-n-）" class="headerlink" title="②按值查找，即定位 Find（时间复杂度为O(n)）"></a>②按值查找，即定位 Find（时间复杂度为O(n)）</h6><blockquote>
<p>基本方法：也是从头到尾遍历，直到找到为止：</p>
<ul>
<li>从链表的<strong>第 1 个元素</strong>结点起，判断<strong>当前结点的值是否等于 X</strong>；</li>
<li>若<strong>是</strong>，<strong>返回</strong>该结点的<strong>位置</strong>，<strong>否</strong>则继续<strong>对比后一个</strong>，直到<strong>表结束位置为止</strong>；</li>
<li><strong>找不到</strong>时返回<strong>错误信息</strong>。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR NULL <span class="hljs-comment">/*空地址表示错误 */</span></span><br><br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( List L, ElementType X)</span></span><br><span class="hljs-function"></span>&#123;<br>    Position p = L;<span class="hljs-comment">/* p指向 L 的第 1 个元素 */</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;Data != x)<br>    &#123;<br>        p = p-&gt;Next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(p)<br>     	 <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br><span class="hljs-number">123456789101112131415</span><br></code></pre></td></tr></table></figure>

<h6 id="5-链表的插入（时间复杂度为O-n-）"><a href="#5-链表的插入（时间复杂度为O-n-）" class="headerlink" title="(5)链表的插入（时间复杂度为O(n)）"></a>(5)链表的插入（时间复杂度为O(n)）</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f4967cd.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f4967cd.png" alt="img"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f4db83a.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f4db83a.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">ListInsert_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i,ElementType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    p = L;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p&amp;&amp; j&lt;i<span class="hljs-number">-1</span>)<br>    &#123;<span class="hljs-comment">//寻找第 i-1 个结点</span><br>        p = p-&gt;next;<br>        ++=j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j &gt; i<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//</span><br>    s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<span class="hljs-comment">//生成新结点s</span><br>    s-&gt;data = e;		<span class="hljs-comment">//将结点s 的数据域的值 更新为 e</span><br>    s-&gt;next = p-&gt;next;  <span class="hljs-comment">//将结点s 插入 L 中</span><br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-number">1234567891011121314151617</span><br></code></pre></td></tr></table></figure>

<h6 id="6-创建链表（时间复杂度为O-n-）"><a href="#6-创建链表（时间复杂度为O-n-）" class="headerlink" title="(6)创建链表（时间复杂度为O(n)）"></a>(6)创建链表（时间复杂度为O(n)）</h6><h6 id="1、带头结点的【头插法】（时间复杂度为O-n-）"><a href="#1、带头结点的【头插法】（时间复杂度为O-n-）" class="headerlink" title="1、带头结点的【头插法】（时间复杂度为O(n)）"></a>1、带头结点的【头插法】（时间复杂度为O(n)）</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f3db996.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3db996.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 带头结点的插入创建 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">createListHead</span><span class="hljs-params">( Linklist L, <span class="hljs-type">int</span> n )</span><br>&#123; <br> 		<span class="hljs-comment">//建立头结点</span><br>    	L = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>    	L-&gt;Next = <span class="hljs-literal">NULL</span>;<br>    	<span class="hljs-comment">//建立单链表（头插法）</span><br>    	LNode *temp = <span class="hljs-literal">NULL</span>;<br>    	<span class="hljs-comment">//申请空间，写入数据</span><br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            tmp = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode)); <span class="hljs-comment">/* 申请、填装结点 */</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;tmp-&gt;Data);<span class="hljs-comment">//输入元素值</span><br>            <span class="hljs-comment">//插入到头结点的后面</span><br>       	 	tmp-&gt;Next = L-&gt;Next; <br>        	L-&gt;Next = tmp;	   <br>        &#125;<br>&#125;<br><span class="hljs-number">123456789101112131415161718</span><br></code></pre></td></tr></table></figure>

<h6 id="2、带尾结点的插入【尾插法】（时间复杂度为O-n-）"><a href="#2、带尾结点的插入【尾插法】（时间复杂度为O-n-）" class="headerlink" title="2、带尾结点的插入【尾插法】（时间复杂度为O(n)）"></a>2、带尾结点的插入【尾插法】（时间复杂度为O(n)）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*带尾结点的插入*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateList_L</span><span class="hljs-params">( Listlist &amp;L, <span class="hljs-type">int</span> n )</span><br>&#123; <span class="hljs-comment">//正位序数输入 n 个元素的值，建立带表头结点的单链表L</span><br>    	<span class="hljs-comment">//建立头结点</span><br>   	    L = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>   		L-&gt;Next = <span class="hljs-literal">NULL</span>;<br>    	<span class="hljs-comment">//建立单链表（尾插法）</span><br>   	 	LNode r = L; <span class="hljs-comment">//尾指针指向头结点</span><br>    	<span class="hljs-comment">//申请空间，写入数据</span><br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)<br>        &#123;<br>           	LNode *tmp = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode)); <span class="hljs-comment">/* 申请新结点 */</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;tmp-&gt;Data); <span class="hljs-comment">//输入元素</span><br>            tmp-&gt;Next = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">//插入到尾结点后面</span><br>        	r-&gt;next = temp; <br>        	r = tmp;	   <span class="hljs-comment">//r指向新的尾结点</span><br>        &#125;<br>&#125;<br><span class="hljs-number">12345678910111213141516171819</span><br></code></pre></td></tr></table></figure>

<h6 id="7-删除（时间复杂度为O-n-）"><a href="#7-删除（时间复杂度为O-n-）" class="headerlink" title="(7)删除（时间复杂度为O(n)）"></a>(7)删除（时间复杂度为O(n)）</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f6b05c3.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f6b05c3.png" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f75405a.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f75405a.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将线性表L 中第 i 个数据元素删除</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListDelete_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElementType &amp;e)</span><br>&#123;<br>    p=L;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="hljs-number">-1</span>)<br>    &#123;<span class="hljs-comment">//寻找第 i 个结点，并令p指向其前驱</span><br>        p = p&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next)||j &lt; i<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//删除位置不合理</span><br>    <br>    q = p-&gt;next;	<span class="hljs-comment">//临时保存被删除结点的地址以备释放</span><br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//改变被除结点的驱结点的指针域</span><br>    e = q-&gt;data;	<span class="hljs-comment">//保存被删除结点的数据域</span><br>    <span class="hljs-built_in">free</span>(q);		<span class="hljs-comment">//释放被删除结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-number">12345678910111213141516171819</span><br></code></pre></td></tr></table></figure>

<h4 id="3、二者时间复杂度和优缺点的比较"><a href="#3、二者时间复杂度和优缺点的比较" class="headerlink" title="3、二者时间复杂度和优缺点的比较"></a>3、二者时间复杂度和优缺点的比较</h4><h5 id="1、两者复杂度比较"><a href="#1、两者复杂度比较" class="headerlink" title="1、两者复杂度比较"></a>1、两者复杂度比较</h5><table>
<thead>
<tr>
<th></th>
<th>查找</th>
<th>插入</th>
<th>删除</th>
</tr>
</thead>
<tbody><tr>
<td>顺序表</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)通过下标直接找到待操作元素，主要时间花在移动元素上。</td>
</tr>
<tr>
<td>链表</td>
<td>O(n)</td>
<td>O(n)主要时间用于找到插入元素的位置</td>
<td>O(n)主要时间用于找到待删除元素的位置</td>
</tr>
</tbody></table>
<h5 id="2、两者优缺点比较"><a href="#2、两者优缺点比较" class="headerlink" title="2、两者优缺点比较"></a>2、两者优缺点比较</h5><table>
<thead>
<tr>
<th>数组</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>随机访问性强；查找速度快</td>
<td>插入和删除效率低；可能浪费内存；内存空间要求高，必须有足够的连续内存空间；数组大小固定，不能动态拓展</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>链表</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活。</td>
<td>不能随机查找，必须从第一个开始遍历，查找效率低</td>
</tr>
</tbody></table>
<blockquote>
<p>两者的区别在于<strong>顺序结构</strong>的要求一片连续的存储空间，而<strong>链式结构</strong>的不要求存储空间连续。</p>
</blockquote>
<h3 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h3><h4 id="1、栈的顺序存储实现"><a href="#1、栈的顺序存储实现" class="headerlink" title="1、栈的顺序存储实现"></a>1、栈的顺序存储实现</h4><blockquote>
<p>通常由一个<strong>一维数组</strong>和一个记录<strong>栈顶</strong>元素位置的变量组成。</p>
</blockquote>
<h5 id="1-顺序栈结构体的定义"><a href="#1-顺序栈结构体的定义" class="headerlink" title="(1)顺序栈结构体的定义"></a>(1)顺序栈结构体的定义</h5><blockquote>
<p><strong>当 Top &#x3D; -1时，表示栈空；当Top &#x3D; MaxSize -1 时，栈满！</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElementType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span></span><br><span class="hljs-class">&#123;</span><br>	ElementType * Data;  <span class="hljs-comment">/*存储元素的数组*/</span><br>	Position Top;		 <span class="hljs-comment">/*栈顶指针*/</span><br>	<span class="hljs-type">int</span> MaxSize;		 <span class="hljs-comment">/*堆栈最大容量*/</span> <br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToNode Stack;<br><span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>

<h5 id="2-顺序栈的创建"><a href="#2-顺序栈的创建" class="headerlink" title="(2)顺序栈的创建"></a>(2)顺序栈的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">(<span class="hljs-type">int</span> MaxSize)</span> <span class="hljs-comment">/*顺序栈的创建*/</span> <br>&#123;<br>	Stack S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>	S-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>	S-&gt;Top = <span class="hljs-number">-1</span>;		       <span class="hljs-comment">/*&quot;-1&quot;表示空栈  &quot;MaxSize-1&quot;表示满栈*/</span> <br>	S-&gt;MaxSize = MaxSize;      <span class="hljs-comment">/*指定栈的最大容量*/</span> <br>	<span class="hljs-keyword">return</span> S;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h5 id="3-判满"><a href="#3-判满" class="headerlink" title="(3)判满"></a>(3)判满</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">(Stack S)</span>		<span class="hljs-comment">/*判断栈是否满了*/</span> <br>&#123;<br>	<span class="hljs-keyword">return</span>(S-&gt;Top == S-&gt;MaxSize<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<h5 id="4-判空"><a href="#4-判空" class="headerlink" title="(4)判空"></a>(4)判空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(Stack S)</span>	<span class="hljs-comment">/*判断堆栈是否为空*/</span> </span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span>(S-&gt;Top == <span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<h5 id="5-入栈"><a href="#5-入栈" class="headerlink" title="(5)入栈"></a>(5)入栈</h5><blockquote>
<p>在执行堆栈 Push 操作时，先判断栈是否满；</p>
<ul>
<li>若不满，Top 加1，并将新元素放入 Data数组的Top位置上</li>
<li>若满，则返回错误标志</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(Stack S, ElementType X)</span>	<span class="hljs-comment">/*顺序栈的 入栈 操作*/</span> </span><br><span class="hljs-function"></span>&#123; <br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsFull</span>(S)) <br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈满！&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		S-&gt;Data[++(S-&gt;Top)] = X;	<span class="hljs-comment">/*若是栈不满，则Top加 1,并将新元素放入Data数组的Top位置中*/</span> <br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>&#125;<br><span class="hljs-number">12345678910111213</span><br></code></pre></td></tr></table></figure>

<h5 id="6-出栈"><a href="#6-出栈" class="headerlink" title="(6)出栈"></a>(6)出栈</h5><blockquote>
<p>执行Pop操作时，首先判别栈是否为空；</p>
<ul>
<li>若不为空，返回Data[Top]，同时将Top-1;</li>
<li>否则要返回错误标志</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">(Stack S)</span> <span class="hljs-comment">/*顺序栈 的 出栈 操作*/</span> <br>&#123;<br>	<span class="hljs-keyword">if</span>(IsEmpty(S))		<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空！&quot;</span>);<br>		<span class="hljs-keyword">return</span> ERROR;					<span class="hljs-comment">/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */</span> <br>	&#125;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span>(S-&gt;Data[(S-&gt;Top)--]);	<span class="hljs-comment">/*若不空，返回Data[Top]，同时将Top减 1*/</span>  <br>&#125;<br><span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>

<h4 id="2、栈的顺序存储实现"><a href="#2、栈的顺序存储实现" class="headerlink" title="2、栈的顺序存储实现"></a>2、栈的顺序存储实现</h4><blockquote>
<p>链栈与单链表类似，但其操作受限制，插入和删除操作<strong>只能在链栈的栈顶进行。</strong></p>
</blockquote>
<h5 id="1-顺序栈结构体的定义-1"><a href="#1-顺序栈结构体的定义-1" class="headerlink" title="(1)顺序栈结构体的定义"></a>(1)顺序栈结构体的定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToSNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElementType;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span></span><br><span class="hljs-class">&#123;</span><br>	ElementType Data;<br>	PtrToSNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToSNode Stack;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h5 id="2-顺序栈的创建-1"><a href="#2-顺序栈的创建-1" class="headerlink" title="(2)顺序栈的创建"></a>(2)顺序栈的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">()</span><br>&#123;	<span class="hljs-comment">/*构建一个堆栈的头结点，返回该结点指针*/</span> <br>	Stack S;<br>	S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>	S-&gt;Next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> S;<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure>

<h5 id="3-判空-1"><a href="#3-判空-1" class="headerlink" title="(3)判空"></a>(3)判空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(Stack S)</span></span><br><span class="hljs-function"></span>&#123;	<span class="hljs-comment">/*判断堆栈 S 是否为空，若是返回 true，否则返回 false*/</span> <br>	<span class="hljs-keyword">return</span>(S-&gt;Next == <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<h5 id="4-判满-注意：链栈，不必判断堆栈是否满"><a href="#4-判满-注意：链栈，不必判断堆栈是否满" class="headerlink" title="(4)判满 注意：链栈，不必判断堆栈是否满"></a>(4)判满 注意：链栈，不必判断堆栈是否满</h5><h5 id="5-入栈-1"><a href="#5-入栈-1" class="headerlink" title="(5)入栈"></a>(5)入栈</h5><blockquote>
<p>链栈，<strong>不必判断堆栈是否满</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(Stack S, ElementType X)</span></span><br><span class="hljs-function"></span>&#123;	<span class="hljs-comment">/*将元素 X 压入堆栈 S */</span> <br>	PtrToSNode TmpCell;<br>	TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));<br>	TmpCell-&gt;Data = X;<br>    <br>    <span class="hljs-comment">//头插法</span><br>	TmpCell-&gt;Next = S-&gt;Next;<br>	S-&gt;Next =TmpCell;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure>

<h5 id="6-出栈-1"><a href="#6-出栈-1" class="headerlink" title="(6)出栈"></a>(6)出栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">(Stack S)</span> ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">(Stack S)</span><br>&#123;	<span class="hljs-comment">/*删除并返回堆栈 S 的栈顶元素*/</span>  <br>	PtrToSNode FirstCell;<br>	ElementType TopElem;<br>	<br>	<span class="hljs-keyword">if</span>(IsEmpty(S))<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空！&quot;</span>);<br>		<span class="hljs-keyword">return</span> ERROR;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		FirstCell = S-&gt;Next;<br>		TopElem = FirstCell-&gt;Data;<br>		S-&gt;Next = FirstCell-&gt;Next;<br>		<span class="hljs-built_in">free</span>(FirstCell);<br>		<span class="hljs-keyword">return</span> TopElem;							<br>	&#125;<br>&#125;<span class="hljs-comment">/*顺序栈 的 出栈 操作*/</span> <br>&#123;<br>	<span class="hljs-keyword">if</span>(IsEmpty(S))		<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空！&quot;</span>);<br>		<span class="hljs-keyword">return</span> ERROR;					<span class="hljs-comment">/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */</span> <br>	&#125;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span>(S-&gt;Data[(S-&gt;Top)--]);	<span class="hljs-comment">/*若不空，返回Data[Top]，同时将Top减 1*/</span>  <br>&#125;<br><span class="hljs-number">12345678910111213141516171819202122232425262728</span><br></code></pre></td></tr></table></figure>

<h4 id="3、栈的应用"><a href="#3、栈的应用" class="headerlink" title="3、栈的应用"></a>3、栈的应用</h4><h3 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h3><h4 id="1、队列的顺序存储实现"><a href="#1、队列的顺序存储实现" class="headerlink" title="1、队列的顺序存储实现"></a>1、队列的顺序存储实现</h4><h5 id="1-循环队列的结构体定义"><a href="#1-循环队列的结构体定义" class="headerlink" title="(1) 循环队列的结构体定义"></a>(1) 循环队列的结构体定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType; <span class="hljs-comment">/* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="hljs-comment">/* 循环队列的顺序存储结构 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span></span><br><span class="hljs-class">&#123;</span><br>	QElemType data[MAXSIZE];<br>	<span class="hljs-type">int</span> front;    	<span class="hljs-comment">/* 头指针 */</span><br>	<span class="hljs-type">int</span> rear;		<span class="hljs-comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span><br>&#125;SqQueue;<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure>

<h5 id="2-生成空队列"><a href="#2-生成空队列" class="headerlink" title="(2)生成空队列"></a>(2)生成空队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 初始化一个空队列Q */</span><br>Status <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">(SqQueue *Q)</span><br>&#123;<br>    SqQueue *Q = (SqQueue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>    Q-&gt;data = (ElementType*)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));<br>	Q-&gt;front = Q-&gt;rear = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span>  OK;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h5 id="3-判空-2"><a href="#3-判空-2" class="headerlink" title="(3)判空"></a>(3)判空</h5><blockquote>
<p>队空的条件是：<strong>rear&#x3D;front</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">(SqQueue *Q)</span><br>&#123;<br>    <span class="hljs-keyword">return</span>(Q-&gt;front == Q-&gt;rear);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<h5 id="4-判满"><a href="#4-判满" class="headerlink" title="(4)判满"></a>(4)判满</h5><blockquote>
<p>队满的条件是：<strong>(rear+1)%数组的长度等于 front</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">(SqQueue *Q)</span><br>&#123;<br>    <span class="hljs-keyword">return</span>((Q-&gt;rear+<span class="hljs-number">1</span>)% MaxSize == Q-&gt;front);<br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<h5 id="5-入队"><a href="#5-入队" class="headerlink" title="(5)入队"></a>(5)入队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span><br>Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue *Q,QElemType e)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> ((Q-&gt;rear+<span class="hljs-number">1</span>)%MAXSIZE == Q-&gt;front)	<span class="hljs-comment">/* 队列满的判断 */</span><br>		<span class="hljs-keyword">return</span> ERROR;<br>	Q-&gt;data[Q-&gt;rear]=e;			<span class="hljs-comment">/* 将元素e赋值给队尾 */</span><br>	Q-&gt;rear=(Q-&gt;rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">/* rear指针向后移一位置， */</span><br>								<span class="hljs-comment">/* 若到最后则转到数组头部 */</span><br>	<span class="hljs-keyword">return</span>  OK;<br>&#125;<br><span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>

<h5 id="6-出队"><a href="#6-出队" class="headerlink" title="(6)出队"></a>(6)出队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span><br>Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue *Q,QElemType *e)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (Q-&gt;front == Q-&gt;rear)			<span class="hljs-comment">/* 队列空的判断 */</span><br>		<span class="hljs-keyword">return</span> ERROR;<br>	*e=Q-&gt;data[Q-&gt;front];				<span class="hljs-comment">/* 将队头元素赋值给e */</span><br>	Q-&gt;front=(Q-&gt;front+<span class="hljs-number">1</span>)%MAXSIZE;	<span class="hljs-comment">/* front指针向后移一位置， */</span><br>									<span class="hljs-comment">/* 若到最后则转到数组头部 */</span><br>	<span class="hljs-keyword">return</span>  OK;<br>&#125;<br><span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>

<h4 id="2、队列的链式存储实现"><a href="#2、队列的链式存储实现" class="headerlink" title="2、队列的链式存储实现"></a>2、队列的链式存储实现</h4><blockquote>
<p>队列与堆栈一样，也可以采用链式存储结构，但队列的头（front）必须指向链表的头结点，队列的尾（rear）指向链表的尾结点。</p>
</blockquote>
<h5 id="1-队列的链式存储结构体定义"><a href="#1-队列的链式存储结构体定义" class="headerlink" title="(1)队列的链式存储结构体定义"></a>(1)队列的链式存储结构体定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType; <span class="hljs-comment">/* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>	/* 结点结构 */</span><br><span class="hljs-class">&#123;</span><br>   QElemType data;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;QNode,*QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>			/* 队列的链表结构 */</span><br><span class="hljs-class">&#123;</span><br>   QueuePtr front,rear; <span class="hljs-comment">/* 队头、队尾指针 */</span><br>&#125;LinkQueue;<br><span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure>

<h5 id="2-生成空队列-1"><a href="#2-生成空队列-1" class="headerlink" title="(2)生成空队列"></a>(2)生成空队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 构造一个空队列Q */</span><br>Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue *Q)</span><br>&#123; <br>	Q-&gt;front=Q-&gt;rear=(QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>	<span class="hljs-keyword">if</span>(!Q-&gt;front)<br>		<span class="hljs-built_in">exit</span>(OVERFLOW);<br>	Q-&gt;front-&gt;next=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure>

<h5 id="3-判空-3"><a href="#3-判空-3" class="headerlink" title="(3)判空"></a>(3)判空</h5><blockquote>
<p>队空的条件是：<strong>rear&#x3D;front</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(LinkQueue Q)</span><br>&#123; <br>	<span class="hljs-keyword">if</span>(Q.front==Q.rear)<br>		<span class="hljs-keyword">return</span> TRUE;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure>

<h5 id="4-判满-链式队列，不必判断堆栈是否满"><a href="#4-判满-链式队列，不必判断堆栈是否满" class="headerlink" title="(4)判满 链式队列，不必判断堆栈是否满"></a>(4)判满 链式队列，不必判断堆栈是否满</h5><h5 id="5-入队-1"><a href="#5-入队-1" class="headerlink" title="(5)入队"></a>(5)入队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 插入元素e为Q的新的队尾元素 */</span><br>Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue *Q,QElemType e)</span><br>&#123; <br>	QueuePtr s=(QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>	<span class="hljs-keyword">if</span>(!s) <span class="hljs-comment">/* 存储分配失败 */</span><br>		<span class="hljs-built_in">exit</span>(OVERFLOW);<br>	s-&gt;data=e;<br>	s-&gt;next=<span class="hljs-literal">NULL</span>;<br>	Q-&gt;rear-&gt;next=s;	<span class="hljs-comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span><br>	Q-&gt;rear=s;		<span class="hljs-comment">/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span><br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure>

<h5 id="6-出队-1"><a href="#6-出队-1" class="headerlink" title="(6)出队"></a>(6)出队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span><br>Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue *Q,QElemType *e)</span><br>&#123;<br>	QueuePtr p;<br>	<span class="hljs-keyword">if</span>(Q-&gt;front==Q-&gt;rear)<br>		<span class="hljs-keyword">return</span> ERROR;<br>	p=Q-&gt;front-&gt;next;		<span class="hljs-comment">/* 将欲删除的队头结点暂存给p，见图中① */</span><br>	*e=p-&gt;data;				<span class="hljs-comment">/* 将欲删除的队头结点的值赋值给e */</span><br>	Q-&gt;front-&gt;next=p-&gt;next;<span class="hljs-comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span><br>	<span class="hljs-keyword">if</span>(Q-&gt;rear==p)		<span class="hljs-comment">/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span><br>		Q-&gt;rear=Q-&gt;front;<br>	<span class="hljs-built_in">free</span>(p);<br>	<span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-number">1234567891011121314</span><br></code></pre></td></tr></table></figure>

<h3 id="五、栈和队列操作的特点"><a href="#五、栈和队列操作的特点" class="headerlink" title="五、栈和队列操作的特点"></a>五、栈和队列操作的特点</h3><table>
<thead>
<tr>
<th></th>
<th>相同点</th>
<th>不同点</th>
</tr>
</thead>
<tbody><tr>
<td>堆栈(FILO)</td>
<td>只允许在端点处插入和删除元素；</td>
<td>栈是先进后出或者后进先出；栈是只能在表的一端进行插入和删除操作的线性表</td>
</tr>
<tr>
<td>队列(FIFO)</td>
<td>只允许在端点处插入和删除元素；</td>
<td>队列是先进先出；队列是只能在表的一端进行插入，然后在另外一端进行删除操作的线性表</td>
</tr>
</tbody></table>
<h3 id="六、数组存储地址的计算"><a href="#六、数组存储地址的计算" class="headerlink" title="六、数组存储地址的计算"></a>六、数组存储地址的计算</h3><table>
<thead>
<tr>
<th>数组类型</th>
<th>存储地址的计算（a是数组首地址，len是每个数组元素所占长度）</th>
</tr>
</thead>
<tbody><tr>
<td>一维数组</td>
<td>a[i]的存储地址：a+i*len</td>
</tr>
<tr>
<td>二维数组:a[m] [n]</td>
<td>按行存储：a+(i * n+j) * len；按列存储：a+(j * m+i) * len</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>例子</strong>：数组存储地址的计算示例：<br>1）已知一维数组a中每个元素占用2个字节，求a[10]的存储地址？<br>答：a[10]的存储地址为：a+10*2&#x3D;a+20<br>2）已知二维数组a[4][5]中, 每个元素占用2个字节，求元素a[3][2]按行为主序存储的存储地址和按列为主序存储的存储地址？<br>答： 按行存储：a+(35+2) *2 &#x3D; a+34<br>按列存储：a+(24+3) *2 &#x3D; a+22</p>
</blockquote>
<h2 id="———————树———————"><a href="#———————树———————" class="headerlink" title="———————树———————"></a>———————树———————</h2><h3 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><blockquote>
<p>二叉树是每个节点最多有两个子树的树结构。</p>
<p>它有五种基本形态:</p>
<ul>
<li>二叉树可以是空集;</li>
<li>根可以有空的左子树或右子树；</li>
<li>或者左、右子树皆为空。</li>
</ul>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f604bd3.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f604bd3.png" alt="在这里插入图片描述"></p>
<h4 id="2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度"><a href="#2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度" class="headerlink" title="2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度"></a>2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度</h4><h5 id="a-结点、叶子、树的度"><a href="#a-结点、叶子、树的度" class="headerlink" title="a.结点、叶子、树的度"></a>a.结点、叶子、树的度</h5><blockquote>
<ul>
<li><strong>结点的度</strong>：结点拥有的子树的数目。</li>
<li><strong>叶子</strong>：度为零的结点。</li>
<li><strong>树的度</strong>：树中结点的最大的度</li>
</ul>
</blockquote>
<h5 id="b-孩子、双亲、兄弟、子孙、祖先"><a href="#b-孩子、双亲、兄弟、子孙、祖先" class="headerlink" title="b.孩子、双亲、兄弟、子孙、祖先"></a>b.孩子、双亲、兄弟、子孙、祖先</h5><blockquote>
<ul>
<li><strong>双亲</strong>：若一个结点有子树，该结点称为子树根的”双亲”。</li>
<li><strong>孩子</strong>：子树的根是该结点的”孩子”。</li>
<li><strong>兄弟</strong>：有相同双亲的结点互为”兄弟”。</li>
<li><strong>子孙</strong>：一个结点的所有子树上的任何结点都是该结点的子孙。</li>
<li><strong>祖先</strong>：从根结点到某个结点的路径上的所有结点都是该结点的祖先。</li>
</ul>
</blockquote>
<h5 id="c-无序树、有序树、森林"><a href="#c-无序树、有序树、森林" class="headerlink" title="c.无序树、有序树、森林"></a>c.无序树、有序树、森林</h5><blockquote>
<ul>
<li><strong>无序树</strong>：如果树中结点的各子树之间的次序是无次序的，<strong>可以交换位置</strong>。</li>
<li><strong>有序树</strong>：如果树中结点的各子树之间的次序是有次序的, <strong>不可以交换位置</strong>。</li>
<li><strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</li>
</ul>
</blockquote>
<h5 id="d-层次、高度"><a href="#d-层次、高度" class="headerlink" title="d.层次、高度"></a>d.层次、高度</h5><blockquote>
<p><strong>层次</strong>：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br><strong>树的深度和高度</strong>：二叉树中节点的最大层次称为二叉树的深度或高度。</p>
</blockquote>
<h4 id="2、性质"><a href="#2、性质" class="headerlink" title="2、性质"></a>2、性质</h4><blockquote>
<p><strong>性质1</strong>：二叉树第 i 层上最多为 2^(i-1) (i≥1)个结点。</p>
<p><strong>性质2</strong>：深度为k的二叉树至多有2^k - 1个结点(k≥1)。</p>
<p><strong>性质3</strong>：具有n个结点的【完全二叉树】的高度k为(log&lt;2&gt;n) +1）（<strong>[log2n]表示不大于与其的整数</strong>）</p>
<p><strong>性质4</strong>：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</p>
<p><strong>性质5</strong>：如果对一棵有 n个结点的完全二叉树（其深度为(log&lt;2&gt;n) +1）的结点按 【层序】编号（从第1层到第(log&lt;2&gt;n) +1） 层，每层从左到右），对任一结点 i （1≤ i ≤ n）有：</p>
<ul>
<li>如果 i &#x3D; 1，则结点 i是二叉树的根，无双亲；如果 i ＞ 1，则其双亲是结点 [i&#x2F;2];</li>
<li>如果2i ＞n，则结点 i 无左孩子（即结点 i 为叶子结点）；否则其左孩子是结点 2i；</li>
<li>如果 2i+1 ＞n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li>
</ul>
</blockquote>
<h4 id="3、满二叉树、完全二叉树和二叉排序树"><a href="#3、满二叉树、完全二叉树和二叉排序树" class="headerlink" title="3、满二叉树、完全二叉树和二叉排序树"></a>3、满二叉树、完全二叉树和二叉排序树</h4><h5 id="a-满二叉树"><a href="#a-满二叉树" class="headerlink" title="a.满二叉树"></a>a.满二叉树</h5><blockquote>
<p><strong>定义</strong>：高度为h，并且由2{h} –1个结点的二叉树，被称为满二叉树。</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f6ddd79.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f6ddd79.png" alt="img"></p>
<h5 id="b-完全二叉树"><a href="#b-完全二叉树" class="headerlink" title="b.完全二叉树"></a>b.完全二叉树</h5><blockquote>
<p><strong>定义</strong>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。</p>
<p><strong>特点</strong>：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f80cde1.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f80cde1.png" alt="img"></p>
<h5 id="c-二叉查找树"><a href="#c-二叉查找树" class="headerlink" title="c.二叉查找树"></a>c.二叉查找树</h5><blockquote>
<p><strong>定义</strong>：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。左小右大，任意结点的左、右子树也是二叉查找树</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f8bd638.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f8bd638.png" alt="img"></p>
<blockquote>
<p>在二叉查找树中：<br>(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>(03) 任意节点的左、右子树也分别为二叉查找树。<br>(04) 没有键值相等的节点（no duplicate nodes）。</p>
</blockquote>
<h3 id="二、静态查找"><a href="#二、静态查找" class="headerlink" title="二、静态查找"></a>二、静态查找</h3><h4 id="1、顺序存储结构"><a href="#1、顺序存储结构" class="headerlink" title="1、顺序存储结构"></a>1、顺序存储结构</h4><blockquote>
<p>指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标i－1的分量中。</p>
</blockquote>
<h4 id="2、顺序查找"><a href="#2、顺序查找" class="headerlink" title="2、顺序查找"></a>2、顺序查找</h4><blockquote>
<p>从表的一端开始，逐个将记录的关键字和给定值比较，若找到一个记录的关键字与给定值相等，则查找成功；若整个表中记录均比较过，仍未找到关键字等于给定值的记录，则查找失败。</p>
</blockquote>
<p><strong>缺点</strong>：查找表的长度越长，查找效率越低。</p>
<p><strong>优点</strong>：简单、适应面广，对查找表结构没有要求，对顺序存储和链式存储都适用。</p>
<h4 id="3、二分查找（也称“折半查找”，是一棵“二叉排序树”）"><a href="#3、二分查找（也称“折半查找”，是一棵“二叉排序树”）" class="headerlink" title="3、二分查找（也称“折半查找”，是一棵“二叉排序树”）"></a>3、二分查找（也称“折半查找”，是一棵“二叉排序树”）</h4><blockquote>
<p>设查找表元素存储在一维数组r[1,…,n]中，在表中的元素已经<strong>按关键字递增方式排序的</strong>情况下，</p>
<p>进行[折半查找]的方法是：首先将待查元素的关键字（key）值与表r中间位置上（下标为mid）记录的关键字关键字进行比较，</p>
<ul>
<li>若相等，则查找成功；</li>
<li>若key&gt;r[mid].key,则说明待查记录只可能在后半个子表r[mid+1,…,n]中；</li>
<li>若key&lt;r[mid].key，则说明待查记录只可能在前半个子表r[1,…,mid-1]中；</li>
</ul>
<p>这样逐步缩小范围，直到<strong>查找成功</strong>或<strong>子表为空时失败</strong>为止。</p>
</blockquote>
<p><strong>注意：每次缩小范围后，改变的下标是哪个</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//递增的方式排序，则折半查找的算法为</span><br><span class="hljs-comment">//在数组r[low...high],在数组r中找值为key的元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> r[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high,<span class="hljs-type">int</span> key)</span><br>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)<br>    &#123;<br>        mid = (low + high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(key == r[mid])<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; r[mid])<br>            high = mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>            low = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-comment">//折半查找，递归算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Bsearch_rec</span><span class="hljs-params">(<span class="hljs-type">int</span> r[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high,<span class="hljs-type">int</span> key)</span><br>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">if</span>(low &lt;= high)<br>    &#123;<br>        mid = (low + high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(key == r[mid])<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; r[mid])<br>            <span class="hljs-keyword">return</span> Bsearch_rec(r,low,mid<span class="hljs-number">-1</span>,key);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> Bsearch_rec(r,mid+<span class="hljs-number">1</span>,high,key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-number">12345678910111213141516171819202122232425262728293031323334</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3f97218f.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f97218f.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VgJbPWx2-1641217649130)(myReviewPicture&#x2F;带有11个结点的二分查找判定书.png)]"></p>
<p>折半查找的过程可以用一颗二叉树来描述，以当前查找区域间的中间位置序号作为根，左半个子表和右半个子表中的记录序号分别分别作为根的左子树和右子树上的结点，这样构造的二叉树称为折半查找判定树，从树上可以看出：</p>
<p> 查找成功时，折半查找的过程恰好走了一条从根结点到被查找结点的路径，与关键字进行比较的次数即为被查找结点在树中的层数。因此，折半查找判定树在查找成功时进行比较的关键字个数最多不超过树的深度，而具有n个结点的判定树的深度为；所以折半查找在查找成功时和给定值进行比较的关键字个数最多为。</p>
<p><strong>优点</strong>：查找效率更高，但它要求查找表进行顺序存储并按关键字进行排序。<br><strong>缺点</strong>：对表进行插入或删除时，需要移动大量元素。<br><strong>适用</strong>：表不易变动，且又经常进行查找的情况</p>
<h4 id="4、二分查找判定树ASL计算"><a href="#4、二分查找判定树ASL计算" class="headerlink" title="4、二分查找判定树ASL计算"></a>4、二分查找判定树ASL计算</h4><blockquote>
<p><strong>折半查找的过程看，可用二叉树来描述，二叉树中的每个结点对应有序表中的一个记录，结点中的值为该记录在表中的位置。通常称这个描述折半查找二叉树的过程称为折半查找判定树。</strong></p>
</blockquote>
<p><strong>例如：顺序存储的序列{1,2,3,4,5,6,7,8,9,10} 来构建二叉判定树，计算其ASL</strong></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fa00a68.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fa00a68.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-giB8nBKX-1641217649131)(myReviewPicture&#x2F;二分查找判定书ASL成功-16411799392662.png)]"><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3faf1191.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rHJdmL7J-1641217649131)(myReviewPicture&#x2F;二分查找判定书ASL不成功-16411799619963.png)]"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">例如：长度为<span class="hljs-number">10</span>的折半查找判定树的具体生成过程：<br>	都遵循这个规律，左孩子结点&lt;根结点&lt;右孩子结点 【左小右大】<br><br>    （<span class="hljs-number">1</span>）在长度为<span class="hljs-number">10</span>的有序表中进行折半查找，不论查找哪个记录，都必须和中间记录进行比较，而中间记录为<br>（<span class="hljs-number">1</span>+<span class="hljs-number">10</span>）/<span class="hljs-number">2</span> =<span class="hljs-number">5</span>  (注意要取整)   即判定数的的根结点为<span class="hljs-number">5</span>，如图<span class="hljs-number">7</span><span class="hljs-number">-2</span>（a）所示。<br><br>     （<span class="hljs-number">2</span>）考虑判定树的左子树，即将查找区域调整到左半区，此时的查找区间为[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],那么中间值为（<span class="hljs-number">1</span>+<span class="hljs-number">4</span>）/<span class="hljs-number">2</span> =<span class="hljs-number">2</span> (注意要取整) ，所以做孩子根结点为<span class="hljs-number">2</span>,如图<span class="hljs-number">7</span><span class="hljs-number">-2</span>（b）所示。<br><br>     （<span class="hljs-number">3</span>）考虑判定树的右子树，即将查找区域调整到右半区，此时的查找区间为[<span class="hljs-number">6</span>,<span class="hljs-number">10</span>],那么中间值为（<span class="hljs-number">6</span>+<span class="hljs-number">10</span>）/<span class="hljs-number">2</span> =<span class="hljs-number">8</span> (注意要取整) ，所以做孩子根结点为<span class="hljs-number">8</span>,如图<span class="hljs-number">7</span><span class="hljs-number">-2</span>（c）所示。<br><br>       (<span class="hljs-number">4</span>)重复以上步骤，依次去确定左右孩子、<br><br><span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<blockquote>
<p>1.折半查找是一棵<strong>二叉排序树</strong>，每个根结点的值都大于左子树的所有结点的值，小于右子树所有结点的值。</p>
<p>2.折半查找判定数中的结点都是查找成功的情况，将每个结点的空指针指向一个实际上不存在的结点————<strong>外结点</strong>，所有外界点都是查找不成功的情况，如图7-2（e）所示。<strong>如果有序表的长度为n,则外结点一定有n+1个。</strong></p>
</blockquote>
<h5 id="（1）查找成功的ASL"><a href="#（1）查找成功的ASL" class="headerlink" title="（1）查找成功的ASL"></a>（1）查找成功的ASL</h5><blockquote>
<p><strong>折半查找判定数中，某结点所在的层数就是即将要比较的次数，整个判定树代表的有序表的平均查找长度即为查找每个结点的比较次数之和除以有序表的 长度。</strong></p>
</blockquote>
<p><strong>ASL成功 &#x3D; 每层结点所在高度×每层结点数 之和 除以 总结点数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"> 例如：长度为<span class="hljs-number">10</span>的有序表的平均查找长度为<br><br>	ASL=(<span class="hljs-number">1</span>×<span class="hljs-number">1</span>+<span class="hljs-number">2</span>×<span class="hljs-number">2</span>+<span class="hljs-number">3</span>×<span class="hljs-number">4</span>+<span class="hljs-number">4</span>×<span class="hljs-number">3</span>)/<span class="hljs-number">10</span>=<span class="hljs-number">29</span>/<span class="hljs-number">10</span>;<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<h5 id="（2）查找不成功的ASL"><a href="#（2）查找不成功的ASL" class="headerlink" title="（2）查找不成功的ASL"></a>（2）查找不成功的ASL</h5><blockquote>
<p><strong>折半查找判定数中，查找不成功的次数即为查找相应外结点(定义在上方）与内结点的比较次数。整个判定树代表的有序表的平均查找长度。查找失败时的有序表的平均查找长度即为查找每个外结点的比较次数之和除以外结点的个数。</strong></p>
</blockquote>
<p><strong>ASL失败 &#x3D; （每层【补上的】结点所在高度-1）×每层【补上的】结点数 之和 除以 【补上的】总结点数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">例如：查找失败时，长度为<span class="hljs-number">10</span>的有序表的平均查找长度为：<br><br>	ASL=(<span class="hljs-number">3</span>×<span class="hljs-number">5</span>+<span class="hljs-number">4</span>×<span class="hljs-number">6</span>)/<span class="hljs-number">11</span>=<span class="hljs-number">39</span>/<span class="hljs-number">11</span>;<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<h3 id="三、动态查找"><a href="#三、动态查找" class="headerlink" title="三、动态查找"></a>三、动态查找</h3><h4 id="1、二叉树链表结构描述如下："><a href="#1、二叉树链表结构描述如下：" class="headerlink" title="1、二叉树链表结构描述如下："></a>1、二叉树链表结构描述如下：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span> *<span class="hljs-title">Position</span>;</span><br><span class="hljs-keyword">typedef</span> Position BinTree; <span class="hljs-comment">/* 二叉树类型 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span></span><br><span class="hljs-class">&#123;</span><span class="hljs-comment">/*树结点定义 */</span><br>    ElementType Data; <span class="hljs-comment">/* 结点数据*/</span><br>    BinTree Left; <span class="hljs-comment">/*指向左子树*/</span><br>    BinTree Right;<span class="hljs-comment">/*指向右子树*/</span><br>&#125;;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<p><strong>二叉链表至少包含3个域：数据域 data、左指针域 lchild和右指针域 rchild</strong></p>
<p><strong>指针域</strong>： n个结点有2n个指针域。</p>
<p><strong>空指针域</strong>：n 个结点的二叉链表中含有 n+1 个空指针域。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fb17daa.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fb17daa.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PqXCTOH8-1641217649132)(myReviewPicture&#x2F;二叉树的链式存储结构.png)]"><br class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fbb6b3f.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fbb6b3f.png" alt="img"></p>
<h4 id="2、二叉搜索（排序、查找）树的构造过程"><a href="#2、二叉搜索（排序、查找）树的构造过程" class="headerlink" title="2、二叉搜索（排序、查找）树的构造过程"></a>2、二叉搜索（排序、查找）树的构造过程</h4><h5 id="1-构造过程"><a href="#1-构造过程" class="headerlink" title="(1)构造过程"></a>(1)构造过程</h5><blockquote>
<p>构造二叉排序树的过程，就是从空二叉树开始，逐个向树中插入节点的过程。</p>
<p>设记录的关键码序列为：63,90,70,55,67,42,98,83,10,45,58</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fb8e575.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fb8e575.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HIN82LwY-1641218126672)(myReviewPicture&#x2F;二叉搜索树的排序.png)]"></p>
<h5 id="2-插入过程算法及其代码"><a href="#2-插入过程算法及其代码" class="headerlink" title="(2)插入过程算法及其代码"></a>(2)插入过程算法及其代码</h5><blockquote>
<p>设待插入节点关键码值为 X ：</p>
<p>（1）先在树中查找值为 X 的节点，若查找成功，说明节点已存在，无需插入；</p>
<p>（2）若查找失败，说明节点不存在，则将其插入到树中</p>
<p>因此，<strong>新插入节点一定是作为叶子节点插入的。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Insert</span><span class="hljs-params">(Bintree BST, ElmentType X)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(!BST)<br>    &#123;<span class="hljs-comment">/*若原来树为空，生成并返回一个结点的二叉搜索树*/</span><br>        BST = (BinTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TNode));<br>        BST-&gt;Data = X;<br>        BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">/*开始查找插入元素的位置*/</span><br>        <span class="hljs-keyword">if</span>(X &lt; BST-&gt;Data)<br>            BST-&gt;Left = Insert(BST-&gt;Left, X);<span class="hljs-comment">/*递归插入左子树*/</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X &gt; BST-&gt;Data)<br>            BST-&gt;Right = Insert(BST-&gt;Right, X);<span class="hljs-comment">/*递归插入右子树*/</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br><span class="hljs-number">1234567891011121314151617</span><br></code></pre></td></tr></table></figure>

<h5 id="2-删除过程算法及其代码"><a href="#2-删除过程算法及其代码" class="headerlink" title="(2)删除过程算法及其代码"></a>(2)删除过程算法及其代码</h5><blockquote>
<p>二叉搜索树的删除操作比其它操作更为复杂，要删除结点在<strong>树中的位置</strong>决定了操作所采用的<strong>策略</strong>。</p>
</blockquote>
<p>a.若要删除的结点是<strong>叶子结点</strong></p>
<p> 可以直接删除，然后再修改其父结点的指针。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fc03da7.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc03da7.png" alt="在这里插入图片描述"></p>
<p>b.若要删除的结点<strong>只有一个孩子结点</strong>（该结点不一定是叶结点，可以是子树的根）</p>
<p> 删除之前需要改变父结点的指针，指向要删除结点的孩子结点。<br class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fc7c15f.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc7c15f.png" alt="在这里插入图片描述"></p>
<p>c.若要删除的结点有左、右两棵子树，有两种选择：</p>
<p> <strong>基本原则：保持二叉搜索树的有序性</strong></p>
<p> 1、取其右子树中的最小元素；</p>
<p> 2、取其左子树中的最大元素。</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fc95c9e.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc95c9e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Wzu1zptj-1641217649133)(myReviewPicture&#x2F;具有两个子树的结点删除.png)]"></p>
<h5 id="3-查找过程算法及其代码"><a href="#3-查找过程算法及其代码" class="headerlink" title="(3)查找过程算法及其代码"></a>(3)查找过程算法及其代码</h5><blockquote>
<p>BST树的查找思想:</p>
<p>首先将<strong>给定的K值</strong>与二叉排序树的<strong>根节点</strong>的关键字进行比较：</p>
<ul>
<li>若<strong>相等</strong>，则<strong>查找成功</strong>；</li>
<li>若给定的K值<strong>小于</strong>BST树的根节点的关键字：继续在该节点的<strong>左子树上进行查找</strong>；</li>
<li>若给定的K值大于BST树的根节点的关键字：继续在该节点的<strong>右子树上进行查找</strong>。</li>
</ul>
</blockquote>
<h6 id="a-二叉搜索树的递归查找函数"><a href="#a-二叉搜索树的递归查找函数" class="headerlink" title="a.二叉搜索树的递归查找函数"></a>a.二叉搜索树的递归查找函数</h6><blockquote>
<p>在二叉排序树上进行查找，则是从<strong>根结点</strong>出发走了一条从根到待查结点的路径；</p>
<p>若查找不成功，则是从根结点出发走了一条从跟到某一叶结点的路径。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Position <span class="hljs-title function_">Find</span><span class="hljs-params">(BinTree BST,ElementType X)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(!BST-&gt;Data)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/* 查找失败 */</span><br>    <span class="hljs-keyword">if</span>(X &gt; BST-&gt;Data)<br>        <span class="hljs-keyword">return</span> Find(BST-&gt;Right, X);<span class="hljs-comment">/* 在 右子树 中递归查找 */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X &lt; BST-&gt;Data)<br>        <span class="hljs-keyword">return</span> Find(BST-&gt;Left, X);<span class="hljs-comment">/* 在 左子树 中递归查找 */</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> BST;<span class="hljs-comment">/* 在当前结点查找成功，返回当前结点的地址*/</span><br>&#125;<br><span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure>

<h6 id="b-迭代查找算法"><a href="#b-迭代查找算法" class="headerlink" title="b.迭代查找算法"></a>b.迭代查找算法</h6><blockquote>
<p>由于非递归函数的执行效率高，一般采用非递归的迭代来实现查找。很容易将递归函数改为迭代函数</p>
<p>while循环 代替 Find递归调用即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">Position <span class="hljs-title function_">Find</span><span class="hljs-params">(BinTree BST,ElementType X)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(BST)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(X &gt; BST-&gt;Data)<br>            BST = BST-&gt;Right;<span class="hljs-comment">/* 向 右子树 中移动，继续查找 */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X &lt; BST-&gt;Data)<br>            BST = BST-&gt;Left; <span class="hljs-comment">/* 向 右子树 中移动，继续查找 */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">/* X == BST-&gt;Data;*/</span><br>            <span class="hljs-keyword">break</span>;<span class="hljs-comment">/* 在当前结点查找成功，跳出循环 */</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> BST;<span class="hljs-comment">/* 返回找到的结点地址，或是NULL */</span><br>&#125;<br><span class="hljs-number">12345678910111213</span><br></code></pre></td></tr></table></figure>

<h5 id="4-查找最大值和最小值"><a href="#4-查找最大值和最小值" class="headerlink" title="(4)查找最大值和最小值"></a>(4)查找最大值和最小值</h5><blockquote>
<p>根据二叉搜索树的性质，<strong>最小元素</strong>一定是在树的<strong>最左分支的端点上</strong>。最左分支的端点：最左分支上无左孩子的结点。</p>
<p><strong>最大元素</strong>一定在<strong>最右分支的端结点上。</strong></p>
<ul>
<li>从根结点开始，当其不为空时，沿左分支或者右分支逐个判断各结点的指针，直到遇到空指针为止。</li>
<li>当左分支逐层推下来查找到的是最小元素。</li>
<li>反之，当右分支逐层推下来查找到的是最大元素。</li>
</ul>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fca30a0.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fca30a0.png" alt="img"></p>
<h6 id="a-最小元素的递归函数"><a href="#a-最小元素的递归函数" class="headerlink" title="a.最小元素的递归函数"></a>a.最小元素的递归函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">Position <span class="hljs-title function_">FindMin</span><span class="hljs-params">(BinTree BST)</span><br>&#123; <span class="hljs-comment">/* 最小元素在最左端点 */</span><br>    <span class="hljs-keyword">if</span>(!BST)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/* 空的二叉搜素树，返回NULL */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!BST-&gt;Left)<br>        <span class="hljs-keyword">return</span> BST;	<span class="hljs-comment">/* 找到最左端点并返回 */</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FindMin(BST-&gt;Left); <span class="hljs-comment">/*沿左分支递归查找 */</span><br>&#125;<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure>

<h6 id="b-查找最大元素的迭代函数"><a href="#b-查找最大元素的迭代函数" class="headerlink" title="b.查找最大元素的迭代函数"></a>b.查找最大元素的迭代函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Position <span class="hljs-title function_">FindMax</span><span class="hljs-params">(BinTree BST)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(BST)<br>        <span class="hljs-keyword">while</span>(BST-&gt;Right);<br>    		BST = BST-&gt;Right; <span class="hljs-comment">/*沿右分支一直向下，直到最右端点 */</span><br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure>

<h3 id="四、二叉树的遍历"><a href="#四、二叉树的遍历" class="headerlink" title="四、二叉树的遍历"></a>四、二叉树的遍历</h3><blockquote>
<p>指按照某种次序访问二叉树的所有结点，并且每个结点仅访问一次，得到一个线性序列。</p>
</blockquote>
<h4 id="1、先序遍历"><a href="#1、先序遍历" class="headerlink" title="1、先序遍历"></a>1、先序遍历</h4><blockquote>
<p>（1）访问根结点<br>（2）先序遍历左子树<br>（3）先序遍历右子树</p>
<p>-中序、后序遍历相似</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fcd7ec4.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fcd7ec4.png" alt="img"></p>
<blockquote>
<p>先序遍历：A → B → D → C<br>中序遍历：B → D → A → C<br>后续遍历：D → B → C → A<br>层序遍历：A → B → C → D</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>    <span class="hljs-comment">//链式二叉树先序遍历递归算法</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>)<br>	&#123;<br>		printf_s(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;data);    <span class="hljs-comment">//访问根结点</span><br>		PreOrderTraverse(T-&gt;lchild);    <span class="hljs-comment">//先序遍历左子树</span><br>		PreOrderTraverse(T-&gt;rchild);    <span class="hljs-comment">//先序遍历右子树</span><br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//链式二叉树中序遍历递归算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span> <br>&#123;<br>	<span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;<br>		InOrderTraverse(T-&gt;lchild);<br>		printf_s(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;data);<br>		InOrderTraverse(T-&gt;rchild);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//链式二叉树后序遍历递归算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span> <br>&#123;<br>	<span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;<br>		PostOrderTraverse(T-&gt;lchild);<br>		PostOrderTraverse(T-&gt;rchild);<br>		printf_s(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;data);<br>	&#125;<br>&#125;<br><br><span class="hljs-number">123456789101112131415161718192021222324252627282930</span><br></code></pre></td></tr></table></figure>

<h4 id="2、层序遍历-队列实现）"><a href="#2、层序遍历-队列实现）" class="headerlink" title="2、层序遍历(队列实现）"></a>2、层序遍历(队列实现）</h4><blockquote>
<p>仔细看看层序遍历过程，其实就是从上到下，从左到右依次将每个数放入到队列中，然后按顺序依次打印就是想要的结果。</p>
</blockquote>
<blockquote>
<p>实现过程</p>
<ul>
<li>从队列中取出一个元素；</li>
<li>访问该元素所指结点；</li>
<li>若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。</li>
</ul>
<p>不断执行这三步操作，直到队列为空，再无元素可取，二叉树的程序遍历就完成了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LevelorDerTraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>    Queue Q;<br>    BinTree T;<br>    <br>    <span class="hljs-keyword">if</span>(!BT)<br>        <span class="hljs-keyword">return</span>;<span class="hljs-comment">/* 若是空树则直接返回 */</span><br>    <br>    Q = CreatQueue();	<span class="hljs-comment">/* 创建空队列 */</span><br>    AddQ(Q, BT);<br>    <span class="hljs-keyword">while</span>(!IsEmpty(Q))<br>    &#123;<br>        T = DeteleQ(Q);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span><br>        <span class="hljs-keyword">if</span>(T-&gt;Left)<br>            AddQ(Q, T-&gt;Left);<br>        <span class="hljs-keyword">if</span>(T-&gt;Right)<br>            AddQ(Q, T-&gt;Right);<br>    &#125;<br>&#125;<br><span class="hljs-number">1234567891011121314151617181920</span><br></code></pre></td></tr></table></figure>

<h5 id="3、由遍历序列还原二叉树"><a href="#3、由遍历序列还原二叉树" class="headerlink" title="3、由遍历序列还原二叉树"></a>3、由遍历序列还原二叉树</h5><blockquote>
<p>已知<strong>先</strong>序遍历和<strong>中</strong>序遍历，<strong>可以还原</strong>二叉树；<br>已知<strong>中</strong>序遍历和<strong>后</strong>序遍历，<strong>可以还原</strong>二叉树；<br>已知<strong>先序遍历和后序遍历，不可以</strong>还原二叉树.</p>
</blockquote>
<p>a.已知先序遍历和中序遍历还原二叉树</p>
<blockquote>
<p>算法思路：<br>1、根据先序遍历结果确定根节点。先序遍历的第一个节点为根节点。<br>2、 在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。<br>3、 将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。</p>
</blockquote>
<p>例如：已知先序遍历的结果为：ABDHIEJKCFLMGNO,中序遍历的结果为：HDIBJEKALFMCNGO</p>
<p>则二叉树为以下结构：</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fd8636e.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fd8636e.png" alt="img"></p>
<p>其后序遍历结果为：HIDJKEBLMFNOGCA</p>
<h6 id="b-已知后序遍历和中序遍历还原二叉树"><a href="#b-已知后序遍历和中序遍历还原二叉树" class="headerlink" title="b.已知后序遍历和中序遍历还原二叉树"></a>b.已知后序遍历和中序遍历还原二叉树</h6><blockquote>
<p><strong>算法思路</strong>：<br>1、根据后序遍历结果确定根节点。<br>后序遍历的最后一个节点为根节点。<br>2、在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。<br>3、将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。</p>
</blockquote>
<p>例如：已知后序遍历的结果为：HIDJKEBLMFNOGCA,中序遍历的结果为：HDIBJEKALFMCNGO</p>
<p>则二叉树为以下结构：</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fd86d86.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fd86d86.png" alt="img"></p>
<p>其先序遍历结果为：ABDHIEJKCFLMGNO</p>
<h3 id="五、递归遍历算法的应用"><a href="#五、递归遍历算法的应用" class="headerlink" title="五、递归遍历算法的应用"></a>五、递归遍历算法的应用</h3><h5 id="1、求二叉树的深度"><a href="#1、求二叉树的深度" class="headerlink" title="1、求二叉树的深度"></a>1、求二叉树的深度</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求树的深度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">TreeDeep</span><span class="hljs-params">(BiTree T)</span> <br>&#123;<br>    <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-type">int</span> leftDeep = TreeDeep(T-&gt;lchild);<br>        <span class="hljs-type">int</span> rightDeep = TreeDeep(T-&gt;rchild);<br>        deep = leftDeep &gt;= rightDeep ? leftDeep + <span class="hljs-number">1</span> : rightDeep + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> deep;<br>&#125;<br><span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure>

<h5 id="2、求二叉树的叶子树"><a href="#2、求二叉树的叶子树" class="headerlink" title="2、求二叉树的叶子树"></a>2、求二叉树的叶子树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求叶子树</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LeafCount</span><span class="hljs-params">(BinTree T,<span class="hljs-type">int</span> num)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!T-&gt;Left &amp;&amp; !T-&gt;Right)<br>        &#123;<br>            nm++;<br>        &#125;<br>        TreeDeep(T-&gt;lchild, num);<br>        TreeDeep(T-&gt;rchild, num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> num; <br>&#125;<br><span class="hljs-number">1234567891011121314</span><br></code></pre></td></tr></table></figure>

<h5 id="3、交互（换）左、右子树"><a href="#3、交互（换）左、右子树" class="headerlink" title="3、交互（换）左、右子树"></a>3、交互（换）左、右子树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(BiTree *&amp;right,BiTree *&amp;left)</span><br>&#123;<br>	BiTree *temp=right;<br>	right=left;<br>	left=temp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SwapSubtrees</span><span class="hljs-params">(BiTree *T)</span><br>&#123;<br>	<span class="hljs-keyword">if</span>(!T)<br>		<span class="hljs-keyword">return</span> ;<br>	SwapSubtrees(T-&gt;rchild);<br>	SwapSubtrees(T-&gt;lchild);<br>	Swap(T-&gt;rchild,T-&gt;lchild);<br>&#125;<br><span class="hljs-number">123456789101112131415</span><br></code></pre></td></tr></table></figure>

<h3 id="六、静态查找和动态查找的根本区别"><a href="#六、静态查找和动态查找的根本区别" class="headerlink" title="六、静态查找和动态查找的根本区别"></a>六、静态查找和动态查找的根本区别</h3><ul>
<li>上述基于二叉排序树的动态查找，它的基本原理和基于线性表的静态二分查找很相似，都是利用有序性不断缩小查找空间。</li>
<li>而之所以有静态和动态之分，主要是为了适应不同的应用需求。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>适合用于</th>
</tr>
</thead>
<tbody><tr>
<td>静态查找</td>
<td>数据一旦建立好，不需要或者很少进行 删除 和 插入 操作</td>
</tr>
<tr>
<td>动态查找</td>
<td>频繁的数据变化，插入 和 删除 是基本操作</td>
</tr>
</tbody></table>
<h3 id="七、树-森林与二叉树的转换"><a href="#七、树-森林与二叉树的转换" class="headerlink" title="七、树&#x2F;森林与二叉树的转换"></a>七、树&#x2F;森林与二叉树的转换</h3><h4 id="1、树、森林与二叉树的转换"><a href="#1、树、森林与二叉树的转换" class="headerlink" title="1、树、森林与二叉树的转换"></a>1、树、森林与二叉树的转换</h4><p>由于二叉树是有序的，为了避免混淆，对于无序树，我们约定树中的每个结点的孩子结点按从左到右的顺序进行编号。</p>
<blockquote>
<p>将树转换成二叉树的步骤是：<br>（1）加线。就是在<strong>所有兄弟结点</strong>之间加一条连线；<br>（2）抹线。就是对<strong>树中的每个结点</strong>，只<strong>保留</strong>他与<strong>第一个孩子结点</strong>之间的连线，<strong>删除</strong>它与<strong>其它孩子</strong>结点之间的连线；<br>（3）旋转。就是<strong>以树的根结点为轴心</strong>，将整棵树顺时针旋转一定角度，使之结构层次分明。<br class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fe6e3a9.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe6e3a9.png" alt="img"></p>
</blockquote>
<h4 id="2、森林转换为二叉树"><a href="#2、森林转换为二叉树" class="headerlink" title="2、森林转换为二叉树"></a>2、森林转换为二叉树</h4><p>森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。</p>
<blockquote>
<p>将森林转换为二叉树的步骤是：<br>（1）<strong>先把每棵树转换为二叉树</strong>；<br>（2）第一棵二叉树<strong>不动</strong>，从第二棵二叉树<strong>开始</strong>，依次把<strong>后一棵</strong>二叉树的根结点作为<strong>前一棵</strong>二叉树的<strong>根结点的右孩子结点</strong>，<strong>用线连接起来</strong>。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fe7ed50.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe7ed50.png" alt="img"></p>
<h4 id="3、二叉树转换为树"><a href="#3、二叉树转换为树" class="headerlink" title="3、二叉树转换为树"></a>3、二叉树转换为树</h4><blockquote>
<p><strong>二叉树转换为树</strong>是<strong>树转换为二叉树</strong>的<strong>逆过程</strong>，其步骤是：<br>（1）若<strong>某结点</strong>的<strong>左孩子结点存在</strong>，将<strong>左孩子结点的右孩子结点、右孩子结点的右孩子结点</strong>……都作为<strong>该结点</strong>的孩子结点，将该结点与这些<strong>右孩子结点用线连接</strong>起来；<br>（2）<strong>删除原二叉树</strong>中所有结点与其右孩子结点的连线；<br>（3）整理（1）和（2）两步得到的树，使之结构层次分明。<br class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9c5ca.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9c5ca.png" alt="img"></p>
</blockquote>
<h4 id="4、二叉树转换为森林"><a href="#4、二叉树转换为森林" class="headerlink" title="4、二叉树转换为森林"></a>4、二叉树转换为森林</h4><blockquote>
<p>二叉树转换为森林比较简单，其步骤如下：<br>（1）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；<br>（2）把分离后的每棵二叉树转换为树；<br>（3）整理第（2）步得到的树，使之规范，这样得到森林。</p>
</blockquote>
<h4 id="5、转换以后的特点："><a href="#5、转换以后的特点：" class="headerlink" title="5、转换以后的特点："></a>5、转换以后的特点：</h4><p> (1、 根据树与二叉树的转换关系以及二叉树的遍历定义可以推知：</p>
<ul>
<li>树的先序遍历与其转换的相应的二叉树的先序遍历的结果序列相同；</li>
<li>树的后序遍历与其转换的二叉树的中序遍历的结果序列相同；</li>
<li>树的层序遍历与其转换的二叉树的后序遍历的结果序列相同。</li>
</ul>
<p>（2、 由森林与二叉树的转换关系以及森林与二叉树的遍历定义可知：</p>
<p> 森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同。</p>
<h3 id="八、线索二叉树"><a href="#八、线索二叉树" class="headerlink" title="八、线索二叉树"></a>八、线索二叉树</h3><blockquote>
<p>传统的二叉链表仅能体现出一种父子关系，不能直接得到结点在遍历中的前驱或后继。引入【线索二叉树】正是为了<strong>加快查找结点前驱和后继的速度。</strong><br><strong>（1、定义</strong>：</p>
<ul>
<li><strong>前驱与后继</strong>：在二叉树的<code>先序、中序或后序遍历序列</code>中的两个<code>相邻的结点</code>；</li>
<li><strong>线索</strong>：指向前驱或后继的<code>结点的指针</code>；</li>
<li><strong>线索二叉树</strong>：<code>加上线索</code>的<code>二叉链表</code>的<code>二叉树</code>；</li>
<li><strong>线索化</strong>：对二叉树按<code>某个遍历次序</code>使其<code>变为线索二叉树</code>的过程。</li>
</ul>
<p><strong>（2、规定</strong>：<strong>【口诀：左前右后，0孩1前后】</strong></p>
<ul>
<li>若<code>无左子树</code>，令<code>lchild</code>指向其<code>前驱</code>结点；</li>
<li>若<code>无右子树</code>，令<code>rchild</code>执行指向其<code>后继</code>结点</li>
<li>增加<code>两个标志域标</code>识是指<code>左/右孩子</code>还是指向<code>前驱/后继</code>。</li>
</ul>
</blockquote>
<h4 id="1、存储结构"><a href="#1、存储结构" class="headerlink" title="1、存储结构"></a>1、存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//线索二叉树存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span>&#123;</span><br>	<span class="hljs-type">char</span> data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span>	<span class="hljs-comment">// 左右孩子指针</span><br>	<span class="hljs-type">int</span> ltag, rtag;	<span class="hljs-comment">// 左右线索标志</span><br>&#125;ThreadNode, *ThreadTree;<br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fea5ad1.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fea5ad1.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fXyUjz8c-1641217649133)(myReviewPicture&#x2F;线索二叉树的结构.png)]"></p>
<h4 id="2、如何判断是孩子还是线索"><a href="#2、如何判断是孩子还是线索" class="headerlink" title="2、如何判断是孩子还是线索"></a>2、如何判断是孩子还是线索</h4><p><strong>其标志位含义如下：</strong> <strong>【口诀：左前右后，0孩1前后】</strong></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9e318.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9e318.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gl66MqHn-1641217649134)(myReviewPicture&#x2F;线索二叉树的标识符含义.png)]"></p>
<ul>
<li>这种加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。</li>
<li>根据线索性质的不同， 线索二叉树可分为<strong>前序线索二叉树、 中序线索二叉树和后序线索二叉树</strong>三种。</li>
</ul>
<h4 id="3、三种遍历"><a href="#3、三种遍历" class="headerlink" title="3、三种遍历"></a>3、三种遍历</h4><blockquote>
<p>因为线索化后， 各个结点指向有变化， 因此原来的遍历方式不能使用， 需要使用新的方式遍历线索化二叉树。</p>
<p>中序线索二叉树的结点中<strong>隐含</strong>了线索二叉树的<strong>前驱和后继信息</strong>。</p>
<p>在对其遍历时，需要找到第一个具有前驱结点的左结点，然后依次找结点的后继。</p>
<p>在中序线索二叉树中找结点后继的规律是:</p>
<ul>
<li>若其<strong>右标志为1</strong>，则<strong>右链为线索</strong>，指示其<strong>后继</strong>;</li>
<li>否则遍历<strong>右子树中第一个访问</strong>的结点（右子树中最左下的结点）为其后继。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BiThrTree T)</span>&#123; <span class="hljs-comment">// 中序输出</span><br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        InOrderTraverse(T-&gt;lchild); <span class="hljs-comment">//中序遍历左子树</span><br>        <span class="hljs-built_in">cout</span>&lt;&lt; T-&gt;data;<br>        InOrderTraverse(T-&gt;rchild); <span class="hljs-comment">//中序遍历右子树</span><br>    &#125;<br>&#125;<br><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h3 id="九、哈夫曼树"><a href="#九、哈夫曼树" class="headerlink" title="九、哈夫曼树"></a>九、哈夫曼树</h3><h4 id="1、带权路径长度WPL"><a href="#1、带权路径长度WPL" class="headerlink" title="1、带权路径长度WPL"></a>1、带权路径长度WPL</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3fee2941.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fee2941.png" alt="img"></p>
<h4 id="2、哈夫曼树的构造（算法）"><a href="#2、哈夫曼树的构造（算法）" class="headerlink" title="2、哈夫曼树的构造（算法）"></a>2、哈夫曼树的构造（算法）</h4><blockquote>
<p>构造 Huffman 树的基本思想：权值大的结点用短路径，权值小的结点用长路径。</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9b85.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9b85.png" alt="img"></p>
<blockquote>
<p>构造过程</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9963.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9963.png" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b4000e0f6.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4000e0f6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S9xCYfbA-1641217649135)(myReviewPicture&#x2F;huffmantree2.png)]"></p>
<h4 id="3、哈夫曼树的性质"><a href="#3、哈夫曼树的性质" class="headerlink" title="3、哈夫曼树的性质"></a>3、哈夫曼树的性质</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b400ae7d3.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400ae7d3.png" alt="img"></p>
<h4 id="4、哈夫曼编码"><a href="#4、哈夫曼编码" class="headerlink" title="4、哈夫曼编码"></a>4、哈夫曼编码</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b400d4c84.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400d4c84.png" alt="img"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b400f253d.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400f253d.png" alt="img"></p>
<h2 id="———散列查找———"><a href="#———散列查找———" class="headerlink" title="———散列查找———"></a>———散列查找———</h2><h3 id="一、散列查找"><a href="#一、散列查找" class="headerlink" title="一、散列查找"></a>一、散列查找</h3><h4 id="1、基本概念-1"><a href="#1、基本概念-1" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><ul>
<li><strong>散列函数</strong></li>
</ul>
<p> 在进行查找时，在记录的存储位置与它的关键字之间建立一个确定的对应关系h,以线性表中每个元素的关键字K为自变量，通过函数h(K)计算出该元素的存储位置，我们将h函数称为散列函数或哈希函数。h(K)的值称为散列地址或哈希地址。</p>
<ul>
<li><strong>冲突</strong></li>
</ul>
<p> 在实际应用中，通常可能出现一个待插入元素的散列地址单元已被占用情况，使得该元素无法直接存入此单元，这种情况称为冲突。</p>
<ul>
<li><p><strong>同义词</strong></p>
<p> 具有不同关键字而具有相同散列地址的元素称为同义词，即key1≠key2，但h(key1)&#x3D;h(key2)。由同义词引起的冲突称作同义词冲突。</p>
</li>
<li><p><strong>装填因子(α)</strong></p>
<p>指散列表中已存入的元素数n与散列表空间大小m的比值,即：α&#x3D;n&#x2F;m。当α越小时，冲突可能性就越小，但同时，存储空间利用率就越低。</p>
</li>
</ul>
<p>散列表：根据设定的哈希函数及处理冲突的方法将一组关键字映象到一个有限的连续的地址集上，即把记录存放在表中映象的位置上，这种表便称为散列表(哈希表)。</p>
<ul>
<li>一个散列表的好坏与三个因素有关：1.装填因子 2、所采用的散列函数 3、解决冲突的方法</li>
</ul>
<blockquote>
<p>假定一个线性表为A&#x3D;(18,75,60,43,54,90,46)，选取散列函数为：h(K)&#x3D;K%m 取m&#x3D;13<br>则得每个元素散列地址：<br>h(18)&#x3D;18 % 13&#x3D;5<br>h(75)&#x3D;75 % 13&#x3D;10<br>h(60)&#x3D;60 % 13&#x3D;8<br>h(43)&#x3D;43 % 13&#x3D;4<br>h(54)&#x3D;54 % 13&#x3D;2<br>h(90)&#x3D;90 % 13&#x3D;12<br>h(46)&#x3D;46 % 13&#x3D;7<br>根据散列地址，实现元素的存储映象H[m]：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>H</td>
<td></td>
<td></td>
<td>54</td>
<td></td>
<td>43</td>
<td>18</td>
<td></td>
<td>46</td>
<td>60</td>
<td></td>
<td>75</td>
<td></td>
<td>90</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>例：如向下表中再插入元素70时，70%13&#x3D;5，则出现了冲突</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>H</td>
<td></td>
<td></td>
<td>54</td>
<td></td>
<td>43</td>
<td>18</td>
<td></td>
<td>46</td>
<td>60</td>
<td></td>
<td>75</td>
<td></td>
<td>90</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="2、散列函数"><a href="#2、散列函数" class="headerlink" title="2、散列函数"></a>2、散列函数</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OtlYI1uv-1641217649135)(myReviewPicture&#x2F;散列函数.png)]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"> 构造散列函数的目标是使散列地址尽可能均匀分布在散列空间上，同时使计算尽可能简单，以节省计算时间。<br>1<br></code></pre></td></tr></table></figure>

<h5 id="（1、关键词为数字时："><a href="#（1、关键词为数字时：" class="headerlink" title="（1、关键词为数字时："></a>（1、关键词为数字时：</h5><h6 id="a-直接定址法"><a href="#a-直接定址法" class="headerlink" title="a.直接定址法"></a>a.直接定址法</h6><p class='item-img' data-src='https://i-blog.csdnimg.cn/blog_migrate/4a426e7c26d23a12abae842ecc2e1ace.png'><img src="https://i-blog.csdnimg.cn/blog_migrate/4a426e7c26d23a12abae842ecc2e1ace.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VlxRhB6x-1641217649136)(myReviewPicture&#x2F;直接定址法.png)]"></p>
<h6 id="b-除留余数法-常用"><a href="#b-除留余数法-常用" class="headerlink" title="b.除留余数法(常用)"></a>b.除留余数法(常用)</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b401eef26.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b401eef26.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fZm4ezqe-1641217649136)(myReviewPicture&#x2F;除留余数法.png)]"></p>
<h6 id="c-数字分析法"><a href="#c-数字分析法" class="headerlink" title="c.数字分析法"></a>c.数字分析法</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址，如电话号码、身份证号码某几位会比较随机；<br>1<br></code></pre></td></tr></table></figure>

<blockquote>
<p>**例：**有一组关键字如下：</p>
<p> 92326875</p>
<p> 92739628</p>
<p> 92343634</p>
<p> 92706816</p>
<p> 92774638</p>
<p> 92381262</p>
<p> 92394220</p>
<p>通过分析：每个关键字从左到右第1、2、3位和第6位取值较集中，不宜作散列地址，其余的第4、5、7、8位取值分散，可以选择，若取最后两位作散列地址，得：<strong>(2,75,28,34,16,38,62,20)</strong></p>
</blockquote>
<h6 id="d-平方取中法"><a href="#d-平方取中法" class="headerlink" title="d.平方取中法"></a>d.平方取中法</h6><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">key</span>取平方再取中间几位<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h5 id="（2、关键词为字符时："><a href="#（2、关键词为字符时：" class="headerlink" title="（2、关键词为字符时："></a>（2、关键词为字符时：</h5><h6 id="a、ASCII码加和法"><a href="#a、ASCII码加和法" class="headerlink" title="a、ASCII码加和法"></a>a、ASCII码加和法</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">h</span><span class="hljs-params">(key)</span></span>=(求和key<span class="hljs-selector-attr">[i]</span>)mod TableSize<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h6 id="b、前3个字符移位法"><a href="#b、前3个字符移位法" class="headerlink" title="b、前3个字符移位法"></a>b、前3个字符移位法</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">h</span>(key)=(key[<span class="hljs-number">0</span>]*<span class="hljs-number">27</span>*<span class="hljs-number">27</span>+key[<span class="hljs-number">1</span>]*<span class="hljs-number">27</span>+key[<span class="hljs-number">2</span>])mod TableSize<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure>

<h3 id="二、处理冲突的方法"><a href="#二、处理冲突的方法" class="headerlink" title="二、处理冲突的方法"></a>二、处理冲突的方法</h3><h4 id="1、开放定址法"><a href="#1、开放定址法" class="headerlink" title="1、开放定址法"></a>1、开放定址法</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b4022f739.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4022f739.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-w3vCRkqI-1641217649137)(assets&#x2F;开放定址法2.png)]"></p>
<h6 id="a-线性探测法"><a href="#a-线性探测法" class="headerlink" title="a.线性探测法"></a>a.线性探测法</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b402672fe.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402672fe.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CKgRc9iU-1641217649138)(myReviewPicture&#x2F;线性探测法.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b402c6fc3.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402c6fc3.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dRJEytI9-1641217649139)(myReviewPicture&#x2F;开放定址法.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b402edf95.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402edf95.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-s9TU3kVj-1641217649139)(myReviewPicture&#x2F;ASL.png)]"></p>
<p><strong>注意</strong>：查找某个值时，用散列函数计算完后，如果那个结果位置上的数字与关键词不一样时，并不能断定关键词不存在，还应该按照冲突解决策略继续找，直到找到空位置了还没找到，才能断定该关键词不存在。</p>
<h6 id="b、平方探测（二次探测）"><a href="#b、平方探测（二次探测）" class="headerlink" title="b、平方探测（二次探测）"></a>b、平方探测（二次探测）</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b40381e62.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b40381e62.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tK3J9VUv-1641217649140)(myReviewPicture&#x2F;平方探测法5.png)]"></p>
<blockquote>
<p>举例：h(key)&#x3D;key mod 11;</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b4039a89b.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4039a89b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jyTvTfbw-1641217649140)(myReviewPicture&#x2F;平方探测法.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b403ddb6c.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b403ddb6c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XTqZBJVG-1641217649140)(myReviewPicture&#x2F;平方探测法2.png)]"></p>
<p>**注意：**取素数是为了减少公因子（减少冲突）</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b4049a4b5.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4049a4b5.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RL4wdkRn-1641217649142)(myReviewPicture&#x2F;散列表的装填因子.png)]"></p>
<h6 id="c-在散列法"><a href="#c-在散列法" class="headerlink" title="c.在散列法"></a>c.在散列法</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b4047fb3b.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4047fb3b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sXqpjUkM-1641217649142)(myReviewPicture&#x2F;再散列法.png)]"></p>
<h4 id="2、分离链接法"><a href="#2、分离链接法" class="headerlink" title="2、分离链接法"></a>2、分离链接法</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b404ef82b.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b404ef82b.png" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b405908a6.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b405908a6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QpGllGXr-1641217649142)(myReviewPicture&#x2F;链地址法.png)]"></p>
<h2 id="———————————————图————————————————"><a href="#———————————————图————————————————" class="headerlink" title="———————————————图————————————————"></a>———————————————图————————————————</h2><h3 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h3><blockquote>
<p><strong>集合只有同属于一个集合；线性结构存在一对一的关系；树形结构存在一对多的关系；图状结构存在多对多的关系</strong>。</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b4059a033.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4059a033.png" alt="img"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b50ea5e8c.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50ea5e8c.png" alt="img"></p>
<h4 id="1、简单图"><a href="#1、简单图" class="headerlink" title="1、简单图"></a>1、简单图</h4><blockquote>
<p>简单图满足以下两条内容：</p>
<p><strong>1）不存在重复边</strong></p>
<p><strong>2）不存在顶点到自身的边</strong></p>
</blockquote>
<h4 id="2、完全图"><a href="#2、完全图" class="headerlink" title="2、完全图"></a>2、完全图</h4><blockquote>
<p>任意两顶点之间都存在边</p>
</blockquote>
<h4 id="3、连通分量"><a href="#3、连通分量" class="headerlink" title="3、连通分量"></a>3、连通分量</h4><blockquote>
<p>在无向图中，两顶点有路径存在，就称为连通的。若图中任意两顶点都连通，同此图为连通图。无向图中的极大连通子图称为连通分量。</p>
</blockquote>
<h4 id="4、强连通分量"><a href="#4、强连通分量" class="headerlink" title="4、强连通分量"></a>4、强连通分量</h4><blockquote>
<p>在有向图中，两顶点两个方向都有路径，两顶点称为<strong>强连通</strong>。</p>
<p>若任一顶点都是强连通的，称为强连通图。有向图中极大强连通子图为有向图的强连通分量。</p>
</blockquote>
<h4 id="5-顶点的度、入度和出度"><a href="#5-顶点的度、入度和出度" class="headerlink" title="5.顶点的度、入度和出度"></a>5.顶点的度、入度和出度</h4><blockquote>
<p><strong>顶点的度</strong>为以该顶点为一个端点的<strong>边的数目</strong>。</p>
<p>对于<strong>无向图</strong>，顶点的边数为度，<strong>度数之和是顶点边数的 2 倍</strong>。</p>
<p>对于<strong>有向图</strong>，入度是以顶点为终点，出度相反。有向图的<strong>全部顶点入度之和等于出度之和且等于边数</strong>。<strong>顶点的度等于入度与出度之和</strong></p>
</blockquote>
<p><strong>注意</strong>：入度与出度是针对有向图来说的</p>
<h3 id="二、图的存储"><a href="#二、图的存储" class="headerlink" title="二、图的存储"></a>二、图的存储</h3><h4 id="1、数组（邻接矩阵）表示法"><a href="#1、数组（邻接矩阵）表示法" class="headerlink" title="1、数组（邻接矩阵）表示法"></a>1、数组（邻接矩阵）表示法</h4><ul>
<li><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）。</p>
</li>
<li><p>设图A&#x3D;（V，E）有n个顶点，则</p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b50e89c5e.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50e89c5e.png" alt="åœ¨è¿™é‡Œæ’å ¥å›¾ç‰‡æè¿°"></p>
</li>
<li><p>图的邻接矩阵是一个二位数组A.arcs[n] [n]，定义为：</p>
</li>
</ul>
<p>åœ¨è¿™é‡Œæ’å<br>¥å›¾ç‰‡æè¿°</p>
<h5 id="a-无向图的邻接矩阵表示法"><a href="#a-无向图的邻接矩阵表示法" class="headerlink" title="a.无向图的邻接矩阵表示法"></a>a.无向图的邻接矩阵表示法</h5><blockquote>
<p>分析1：<strong>无向图</strong>的邻接矩阵是<strong>对称</strong>的；<br>分析2：顶点i的度&#x3D;第i行（列）中1的个数；<br><strong>特别：完全图的邻接矩阵中，对角元素为0，其余1。</strong></p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b50e9cb15.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50e9cb15.png" alt="åœ¨è¿™é‡Œæ’å ¥å›¾ç‰‡æè¿°"></p>
<h5 id="b-有向图的邻接矩阵表示法"><a href="#b-有向图的邻接矩阵表示法" class="headerlink" title="b.有向图的邻接矩阵表示法"></a>b.有向图的邻接矩阵表示法</h5><blockquote>
<p>注：在有向图的邻接矩阵中，<br>第 i <strong>行</strong>含义：以结点vi为尾的弧（即<strong>出度边</strong>）<br>第 i <strong>列</strong>含义：以结点vi为头的弧（即<strong>入度边</strong>）<br>分析1：有向图的邻接矩阵<strong>可能是不对称</strong>的；<br>分析2：<strong>顶点的出度 &#x3D; 第 i 行元素之和</strong><br><strong>顶点的入度 &#x3D; 第 i 列元素之和</strong><br><strong>顶点的度 &#x3D; 第 i 行元素之和 + 第 i 列元素之和</strong></p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b50ed60f0.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50ed60f0.png" alt="在这里插入图片描述"></p>
<h5 id="c-有权图（网）的邻接矩阵表示法"><a href="#c-有权图（网）的邻接矩阵表示法" class="headerlink" title="c.有权图（网）的邻接矩阵表示法"></a>c.有权图（网）的邻接矩阵表示法</h5><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b50eb310f.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50eb310f.png" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b50f02fc2.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50f02fc2.png" alt="在这里插入图片描述"></p>
<h4 id="2-邻接表（顺序存储与链式存储结合）"><a href="#2-邻接表（顺序存储与链式存储结合）" class="headerlink" title="2.邻接表（顺序存储与链式存储结合）"></a>2.邻接表（顺序存储与链式存储结合）</h4><p>![<img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50f9e1aa.png" alt="åœ¨è¿™é‡Œæ’å"><br class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b50fd32c4.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50fd32c4.png" alt="在这里插入图片描述"></p>
<h5 id="a-无向图的邻接表"><a href="#a-无向图的邻接表" class="headerlink" title="a.无向图的邻接表"></a>a.无向图的邻接表</h5><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5105fedc.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5105fedc.png" alt="img"></p>
<h5 id="b-有向图的邻接表与逆邻接表"><a href="#b-有向图的邻接表与逆邻接表" class="headerlink" title="b.有向图的邻接表与逆邻接表"></a>b.有向图的邻接表与逆邻接表</h5><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5108eb3f.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5108eb3f.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-trpuTIAt-1641217649145)(myReviewPicture&#x2F;有向图的邻接表.jpeg)]"></p>
<h5 id="c-带权值的网图"><a href="#c-带权值的网图" class="headerlink" title="c.带权值的网图"></a>c.带权值的网图</h5><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b510a808e.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b510a808e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ah5zBlPv-1641217649146)(myReviewPicture&#x2F;网图的邻接表.png)]"></p>
<h3 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h3><h5 id="1、深度优先遍历算法"><a href="#1、深度优先遍历算法" class="headerlink" title="1、深度优先遍历算法"></a>1、深度优先遍历算法</h5><blockquote>
<p>深度优先搜索类似于树的先序遍历。</p>
<p>其基本思想是：</p>
<ul>
<li>首先访问起始顶点v，然后由v出发，访问与<strong>v 邻接且未被访问</strong>的任一顶点w1，再访问<strong>与w1 邻接且未被</strong>访问的任一顶点W2……重复上述操作。</li>
<li>当<strong>不能再继续向下访问</strong>时，依次<strong>退回到最近被访问的顶点</strong>，若它还有邻接顶点<strong>未被访问过</strong>，则从该点开始<strong>继续上述搜索过程</strong>，直至图中所有顶点均被访问过为止。</li>
</ul>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5107057c.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5107057c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tAlBFL32-1641217649146)(myReviewPicture&#x2F;深度优先遍历.png)]"></p>
<blockquote>
<p>从顶点a 出发，进行深度优先遍历，可以得到的一种顶点序列为：a e d f c b</p>
</blockquote>
<h5 id="2、广度优先遍历算法"><a href="#2、广度优先遍历算法" class="headerlink" title="2、广度优先遍历算法"></a>2、广度优先遍历算法</h5><blockquote>
<p>广度优先搜索类似于二叉树的层序遍历算法。</p>
<p>其基本思想是：</p>
<ul>
<li>首先访问起始顶点v，接着由ν出发，依次访问v 的各个<strong>未访问过的邻接顶点</strong>W1，W2，…，Wi，然后依次访问W1，W2，…，Wi的<strong>所有未被访问过的邻接顶点</strong>；</li>
<li>再从<strong>这些访问过的顶点</strong>出发，访问它们<strong>所有未被访问过的邻接顶点</strong>，直至图中的<strong>所有顶点都被访问过为止</strong>。</li>
<li>若此时图中<strong>尚有顶点未被访问</strong>，则另选图中的<strong>一个未被访问的顶点作为始点</strong>，重复上述过程，直至图中<strong>所有顶点都被访问到为止</strong>。</li>
</ul>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b510a84bf.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b510a84bf.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4dDjFgZo-1641217649147)(myReviewPicture&#x2F;广度优先遍历.png)]"></p>
<blockquote>
<p>从顶点1 出发，按照广度优先规则遍历，可以得到的一种顶点序列是： 1234576</p>
</blockquote>
<h3 id="二、最小生成树"><a href="#二、最小生成树" class="headerlink" title="二、最小生成树"></a>二、最小生成树</h3><h5 id="1、性质"><a href="#1、性质" class="headerlink" title="1、性质"></a>1、性质</h5><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51135fb1.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51135fb1.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hfg0lPhL-1641217649147)(myReviewPicture&#x2F;最小生成树的性质.png)]"></p>
<h5 id="2、Prim算法"><a href="#2、Prim算法" class="headerlink" title="2、Prim算法"></a>2、Prim算法</h5><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5117aae2.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5117aae2.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uhZfCQrh-1641217649147)(myReviewPicture&#x2F;Prim算法.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b511db373.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b511db373.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hrqqoFVo-1641217649148)(myReviewPicture&#x2F;最小生成树Prim算法.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b511dbe59.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b511dbe59.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-te5iPtxy-1641217649149)(myReviewPicture&#x2F;最小生成树Prim算法2.png)]"></p>
<h5 id="3、Kruskal算法"><a href="#3、Kruskal算法" class="headerlink" title="3、Kruskal算法"></a>3、Kruskal算法</h5><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51210bca.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51210bca.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-l7q0KxrC-1641217649149)(myReviewPicture&#x2F;Kruskal算法.png)]"></p>
<h4 id="三、拓扑排序"><a href="#三、拓扑排序" class="headerlink" title="三、拓扑排序"></a>三、拓扑排序</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51278094.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51278094.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UnFfZk1Y-1641217649149)(myReviewPicture&#x2F;拓扑排序.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b512b3ab5.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b512b3ab5.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zr1pgvkl-1641217649150)(myReviewPicture&#x2F;拓扑排序例题.png)]"></p>
<h5 id="四、最短路径"><a href="#四、最短路径" class="headerlink" title="四、最短路径"></a>四、最短路径</h5><h6 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h6><blockquote>
<p>通过迪杰斯特拉算法计算图G中的最短路径时，需要指定起点s。</p>
<p> 此外，需要引进两个集合S和U。</p>
<ul>
<li>S的作用：记录<strong>已求出最短路径的顶点</strong>（以及<strong>相应的最短路径长度</strong>），</li>
<li>U的作用：记录<strong>还未求出最短路径的顶点</strong>（以及<strong>该顶点到起点s的距离</strong>）。</li>
<li>初始时，S中只有起点s；</li>
<li>U中是除s之外的顶点，并且U中顶点的路径是“起点s到该顶点的路径”。</li>
<li>然后，从U中找到路径最短的顶点，并将其加入到S中；<ul>
<li>接着，更新U中的顶点和顶点对应的路径。</li>
<li>然后，再从U中找到路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。</li>
<li>重复上述操作，直到遍历完所有顶点。</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h6><p><strong>1、初始化，所有顶点的距离初始化为无穷大（INFINITY)</strong></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51308072.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51308072.png" alt="img"></p>
<p><strong>2、选定点A，更新（A-A距离设为0)</strong></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b514afd17.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514afd17.png" alt="img"></p>
<p><strong>3、S集合为{A,B}，考察B的所有邻接点</strong></p>
<blockquote>
<p><strong>为什么选定B加入集合S？</strong><br><strong>因为不可能还有其他路径比2还短，我不管经过C到B还是D到B都不可能是路径小于2，所以我们得到了A-&gt;B的最短路径</strong></p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b514ca7e1.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514ca7e1.png" alt="img"></p>
<blockquote>
<p>做完这一步，下一步加入集合S的是D<br>因为目前A-&gt;D的路径长度最短，为3（我已经知道了A直接到D和A经过B到D的路径长度）<br>如果A-&gt;B-&gt;X-&gt;D小于min{A-&gt;D,A-&gt;B-&gt;D},那么A-&gt;B-&gt;X小于min{A-&gt;D,A-&gt;B-&gt;D}，那么加入集合的应该是X，这是矛盾的（接下来的操作都是一样的道理</p>
</blockquote>
<p><strong>4、S集合为{A,B,D}，在U中没有D的邻接点，不操作</strong></p>
<p><strong>5、S集合为{A,B,D,C}，在U中没有C的邻接点，不操作</strong></p>
<p><strong>6、S集合为{A,B,D,C,F}，更新</strong></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5151bee3.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5151bee3.png" alt="img"></p>
<p><strong>7、S集合为{A,B,D,C,F,E}，在U中没有E的邻接点，不操作</strong></p>
<p><strong>8、S集合为{A,B,D,C,F,E,G}，在U中没有G的邻接点，不操作</strong></p>
<p><strong>9、最终结果如上图</strong>。</p>
<h2 id="———排序———"><a href="#———排序———" class="headerlink" title="———排序———"></a>———排序———</h2><h3 id="一、排序的类别"><a href="#一、排序的类别" class="headerlink" title="一、排序的类别"></a>一、排序的类别</h3><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b515628d0.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b515628d0.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBiNgFub-1641217649151)(myReviewPicture&#x2F;排序.png)]"></p>
<h3 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h3><h4 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5159f561.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5159f561.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W5Hwkv7f-1641217649151)(assets&#x2F;插入排序基本思想.png)]"></p>
<h5 id="【1】直接插入排序"><a href="#【1】直接插入排序" class="headerlink" title="【1】直接插入排序"></a>【1】直接插入排序</h5><h6 id="（1、基本思想："><a href="#（1、基本思想：" class="headerlink" title="（1、基本思想："></a>（1、基本思想：</h6><blockquote>
<p>1）、将待排序的一组序列（有N个数）分为<strong>已排好的</strong>和<strong>未排好的</strong> 2个部分；</p>
<p>2）、初始状态时，已排序序列<strong>仅包含第1 个元素</strong>，未排序序列中的元素为除去<strong>第1 个元素意外的N-1 个元素</strong>；</p>
<p>3）、此后，将未排序序列中的元素逐一插入到已排序的序列中；</p>
<p>4）、如此往复，经过<strong>N-1 次</strong>插入后，未排序序列中元素个数为0 ，则排序完成。</p>
</blockquote>
<h6 id="（2、执行过程"><a href="#（2、执行过程" class="headerlink" title="（2、执行过程"></a>（2、执行过程</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b514dae70.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514dae70.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7EB0PiaP-1641217649152)(myReviewPicture&#x2F;直接插入排序例题1.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b516309b7.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b516309b7.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-59uBl571-1641217649152)(myReviewPicture&#x2F;直接插入排序2.png)]"></p>
<h6 id="（3、时空效率及稳定性"><a href="#（3、时空效率及稳定性" class="headerlink" title="（3、时空效率及稳定性"></a>（3、时空效率及稳定性</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5165dced.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5165dced.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SxUpnfwg-1641217649152)(myReviewPicture&#x2F;直接插入时空效率.png)]"></p>
<h5 id="【2】希尔排序"><a href="#【2】希尔排序" class="headerlink" title="【2】希尔排序"></a>【2】希尔排序</h5><h6 id="（1、基本思想：-1"><a href="#（1、基本思想：-1" class="headerlink" title="（1、基本思想："></a>（1、基本思想：</h6><blockquote>
<p>1）、将带排序序列的一组元素按<strong>一定间隔</strong>分为<strong>若干序列</strong>分别进行<strong>插入排序</strong>；</p>
<p>2）、开始时设置的“<strong>间隔</strong>”较大，在每轮排序中，将**”间隔“逐步缩小**</p>
<p>3）、直到“间隔”为 1，也就到了最后一步，做<strong>简单插入排序</strong>。</p>
</blockquote>
<h6 id="（2、执行过程-1"><a href="#（2、执行过程-1" class="headerlink" title="（2、执行过程"></a>（2、执行过程</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51667024.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51667024.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-auVhyLOw-1641217649153)(myReviewPicture&#x2F;希尔排序2.png)]"></p>
<h6 id="（3、时空效率及稳定性-1"><a href="#（3、时空效率及稳定性-1" class="headerlink" title="（3、时空效率及稳定性"></a>（3、时空效率及稳定性</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5168aecd.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5168aecd.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ux0GsKAK-1641217649153)(myReviewPicture&#x2F;希尔排序3.png)]"></p>
<h3 id="2、交换排序"><a href="#2、交换排序" class="headerlink" title="2、交换排序"></a>2、交换排序</h3><h4 id="基本思想：-1"><a href="#基本思想：-1" class="headerlink" title="基本思想："></a>基本思想：</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5172f337.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5172f337.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZgGwNJn5-1641217649154)(myReviewPicture&#x2F;交换排序基本思想.png)]"></p>
<h5 id="【1】冒泡排序"><a href="#【1】冒泡排序" class="headerlink" title="【1】冒泡排序"></a>【1】冒泡排序</h5><h6 id="（1、基本思想：-2"><a href="#（1、基本思想：-2" class="headerlink" title="（1、基本思想："></a>（1、基本思想：</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5172fa98.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5172fa98.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zJfYxzHa-1641217649155)(myReviewPicture&#x2F;冒泡排序基本思想.png)]"></p>
<h6 id="（2、执行过程-2"><a href="#（2、执行过程-2" class="headerlink" title="（2、执行过程"></a>（2、执行过程</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b5177290b.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5177290b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-95qkCnr1-1641217649155)(myReviewPicture&#x2F;冒泡排序执行过程.png)]"></p>
<h6 id="（3、时空效率及稳定性-2"><a href="#（3、时空效率及稳定性-2" class="headerlink" title="（3、时空效率及稳定性"></a>（3、时空效率及稳定性</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51775f1e.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51775f1e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xRUZHEtW-1641217649155)(myReviewPicture&#x2F;冒泡排序时空效率.png)]"></p>
<h5 id="【2】快速排序"><a href="#【2】快速排序" class="headerlink" title="【2】快速排序"></a>【2】快速排序</h5><h6 id="（1、基本思想：-3"><a href="#（1、基本思想：-3" class="headerlink" title="（1、基本思想："></a>（1、基本思想：</h6><blockquote>
<p>1)、将未排序元素根据一个作为<strong>基准</strong>的“主元（pivot）分为<strong>两个子序列</strong>；</p>
<p>2）、其中一个子序列的记录<strong>均大于</strong>“主元”，另一个序列则<strong>均小于</strong>“主元；</p>
<p>3）、<strong>递归</strong>地对两个子序列用<strong>类似的方法</strong>进行排序。</p>
</blockquote>
<h6 id="（2、执行过程-3"><a href="#（2、执行过程-3" class="headerlink" title="（2、执行过程"></a>（2、执行过程</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51776a58.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51776a58.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8y2pVgAJ-1641217649155)(myReviewPicture&#x2F;快速排序例题1.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b517d5abc.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b517d5abc.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Q4MhHTt1-1641217649156)(myReviewPicture&#x2F;插入排序例题2.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51915b7d.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51915b7d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YNkG7K8J-1641217649156)(myReviewPicture&#x2F;插入排序3.png)]"></p>
<h6 id="（3、时空效率及稳定性-3"><a href="#（3、时空效率及稳定性-3" class="headerlink" title="（3、时空效率及稳定性"></a>（3、时空效率及稳定性</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51986b15.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51986b15.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E3u9CHCI-1641217649156)(myReviewPicture&#x2F;插入排序时空效率.png)]"></p>
<h3 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h3><h4 id="基本思想：-2"><a href="#基本思想：-2" class="headerlink" title="基本思想："></a>基本思想：</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b519c39ea.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519c39ea.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6WCpUUz3-1641217649157)(myReviewPicture&#x2F;选择排序的基本思想.png)]"></p>
<h4 id="【1】简单选择排序"><a href="#【1】简单选择排序" class="headerlink" title="【1】简单选择排序"></a>【1】简单选择排序</h4><h6 id="（1、基本思想：-4"><a href="#（1、基本思想：-4" class="headerlink" title="（1、基本思想："></a>（1、基本思想：</h6><blockquote>
<p>1）、在未排序的序列中选出最小元素和序列的<strong>首位元素</strong>交换，</p>
<p>2）、再在剩下的排序序列中再选出最小元素与序列的第2 个位置元素交换</p>
<p>3）、以此类推，最后形参从小到大的已排序序列。</p>
</blockquote>
<h6 id="（2、执行过程-4"><a href="#（2、执行过程-4" class="headerlink" title="（2、执行过程"></a>（2、执行过程</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b519bfb9d.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519bfb9d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eenzDDlH-1641217649158)(myReviewPicture&#x2F;简单选择排序执行过程.png)]"></p>
<h6 id="（3、时空效率及稳定性-4"><a href="#（3、时空效率及稳定性-4" class="headerlink" title="（3、时空效率及稳定性"></a>（3、时空效率及稳定性</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b519d7fa4.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519d7fa4.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HhrGBaPc-1641217649158)(myReviewPicture&#x2F;简单选择排序3.png)]"></p>
<h4 id="【2】堆排序"><a href="#【2】堆排序" class="headerlink" title="【2】堆排序"></a>【2】堆排序</h4><h6 id="（1、基本思想：-5"><a href="#（1、基本思想：-5" class="headerlink" title="（1、基本思想："></a>（1、基本思想：</h6><blockquote>
<p>1）、利用**最大堆（或最小堆）*<em>输出*<em>堆顶元素</em></em>，即最大值（或最小值）；</p>
<p>2）、将剩余元素重新生成<strong>最大堆（或最小堆）</strong>，继续输出<strong>堆顶元素</strong>；</p>
<p>3）、重复此过程，知道全部元素都已输出，得到的输出元素序列即为有序序列</p>
</blockquote>
<h6 id="（2、执行过程要点"><a href="#（2、执行过程要点" class="headerlink" title="（2、执行过程要点"></a>（2、执行过程要点</h6><h6 id="初始化堆的过程"><a href="#初始化堆的过程" class="headerlink" title="&lt;1&gt;初始化堆的过程"></a>&lt;1&gt;初始化堆的过程</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b519d2889.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519d2889.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BUmqOTks-1641217649159)(myReviewPicture&#x2F;执行过程.png)]"></p>
<p class='item-img' data-src='https://i-blog.csdnimg.cn/blog_migrate/da8a3cffadcfae675e33943af636920d.png'><img src="https://i-blog.csdnimg.cn/blog_migrate/da8a3cffadcfae675e33943af636920d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-amUvD16w-1641217649159)(myReviewPicture&#x2F;堆排序.png)]"></p>
<blockquote>
<p><strong>下面是构建初始堆的过程</strong></p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51b18889.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b18889.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WbussFeE-1641217649160)(myReviewPicture&#x2F;堆排序2.png)]"></p>
<blockquote>
<p>下面是堆排序的过程</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51b3f894.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b3f894.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jBlnfC3t-1641217649160)(myReviewPicture&#x2F;堆排序1.png)]"></p>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c648.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c648.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sWcyGiCK-1641217649160)(assets&#x2F;image-20220103210541040.png)]"></p>
<h6 id="（3、时空效率及稳定性-5"><a href="#（3、时空效率及稳定性-5" class="headerlink" title="（3、时空效率及稳定性"></a>（3、时空效率及稳定性</h6><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c652.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c652.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GOajy21Q-1641217649161)(myReviewPicture&#x2F;堆排序空间效率.png)]"></p>
<h4 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h4><p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51bacb3c.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51bacb3c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-g1lLA8Bd-1641217649161)(myReviewPicture&#x2F;归并排序.png)]"></p>
<h4 id="二、各种排序的比较"><a href="#二、各种排序的比较" class="headerlink" title="二、各种排序的比较"></a>二、各种排序的比较</h4><h4 id="口诀：快选堆希不稳，选堆归基不变"><a href="#口诀：快选堆希不稳，选堆归基不变" class="headerlink" title="口诀：快选堆希不稳，选堆归基不变"></a>口诀：快选堆希不稳，选堆归基不变</h4><blockquote>
<p>不稳：说的是 算法不稳定</p>
<p>不变：说的是 关于移动次数和关键字顺序无关的排序</p>
</blockquote>
<p class='item-img' data-src='https://free-img.400040.xyz/4/2024/07/31/66a9b51c46944.png'><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51c46944.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Srey30WJ-1641217649161)(myReviewPicture&#x2F;各种排序的比较.png)]"></p>
<p>end</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/Arknight-notes/2024/07/26/2024-07-26-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A8%E6%B1%87%E6%80%BB/">← Next 高代知识点全汇总</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/Arknight-notes/2024/07/26/2024-07-26-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E7%9B%B8%E5%85%B3/">数据结构复习其一 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="#18d1ff" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" autoplay loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/Arknight-notes/" id="logo"><img src="https://pic4.zhimg.com/80/v2-d9884f32711e19e80979eac58e943897_720w.webp" alt="Logo" style="margin:20;border-radius:0;"></a><h1 id="Dr"><a href="zhongye">柊野</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94"><span class="toc-number">1.</span> <span class="toc-text">——算法、线性表——</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E6%98%8E%E6%99%B0%EF%BC%9A%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%8F%96%E3%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.</span> <span class="toc-text">概念明晰：随机存取、顺序存取、随机存储和顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%8F%96%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.1.</span> <span class="toc-text">1、存取结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E4%B8%BA%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%92%8C%E9%9D%9E%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%EF%BC%88%E5%8F%88%E7%A7%B0%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%8F%96%EF%BC%89"><span class="toc-number">2.0.2.</span> <span class="toc-text">分为随机存取和非随机存取（又称顺序存取）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.3.</span> <span class="toc-text">2、存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E4%B8%BA%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8"><span class="toc-number">2.0.4.</span> <span class="toc-text">分为顺序存储和随机存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.5.</span> <span class="toc-text">3、顺序存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.6.</span> <span class="toc-text">4、随机存储结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">一、数据结构的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">1、基本概念:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">2、算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">(1)概念</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">(2)重要特性：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86-%E2%80%9C%E5%A5%BD%E2%80%9D%E7%9A%84%E7%AE%97%E6%B3%95%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E8%BE%BE%E5%88%B0%E4%BB%A5%E4%B8%8B%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.3.</span> <span class="toc-text">3、算法的评价标准(“好”的算法应该考虑达到以下目标)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E6%95%88%E7%8E%87"><span class="toc-number">2.1.4.</span> <span class="toc-text">4、算法的时空效率</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">(1)时间复杂度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%AE%97%E6%B3%95%E5%86%99%E6%88%90%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%8C%E8%AE%B0%E4%B8%BAT-n-O-n"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">根据算法写成的程序在执行时耗费时间的长度，记为T(n) &#x3D; O(n)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">(2)空间复杂度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%AE%97%E6%B3%95%E5%86%99%E6%88%90%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E5%8D%A0%E7%94%A8%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E7%9A%84%E9%95%BF%E5%BA%A6%E8%AE%B0%E4%B8%BAS-n"><span class="toc-number">2.1.4.4.</span> <span class="toc-text">根据算法写成的程序在执行时占用存储单元的长度记为S(n)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E8%AF%AD%E5%8F%A5%E9%A2%91%E5%BA%A6"><span class="toc-number">2.1.4.5.</span> <span class="toc-text">(3)语句频度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0%E7%A7%B0%E4%B8%BA%E8%AF%AD%E5%8F%A5%E9%A2%91%E5%BA%A6%E6%88%96%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6%EF%BC%8C%E8%AE%B0%E4%B8%BAT-n"><span class="toc-number">2.1.4.6.</span> <span class="toc-text">一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E4%B8%80%E8%88%ACO%EF%BC%88n%EF%BC%89%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.1.4.7.</span> <span class="toc-text">(4)一般O（n）的计算方法：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%B8%83%E7%A7%8D%EF%BC%9A"><span class="toc-number">2.1.4.8.</span> <span class="toc-text">(5)常见的时间复杂度有以下七种：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">二、线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1、顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">(1)结构体的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">(2)顺序表的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n"><span class="toc-number">3.1.3.</span> <span class="toc-text">(3)顺序表的查找(时间复杂度为O(n))</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n"><span class="toc-number">3.1.4.</span> <span class="toc-text">(4）顺序表的插入 (时间复杂度为O(n))</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.1.5.</span> <span class="toc-text">(5)顺序表的删除（时间复杂度为O(n)）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2、链表存储</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">(1）结构体的定义（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%B1%82%E8%A1%A8%E9%95%BF%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">(2)求表长（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%88%A4%E7%A9%BA"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">(3)判空</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E6%9F%A5%E6%89%BE%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">(4)查找（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%8C%89%E5%BA%8F%E5%8F%B7%E6%9F%A5%E6%89%BE-FindKth%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">①按序号查找 FindKth（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%8D%B3%E5%AE%9A%E4%BD%8D-Find%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.6.</span> <span class="toc-text">②按值查找，即定位 Find（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.7.</span> <span class="toc-text">(5)链表的插入（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.8.</span> <span class="toc-text">(6)创建链表（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E3%80%90%E5%A4%B4%E6%8F%92%E6%B3%95%E3%80%91%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.9.</span> <span class="toc-text">1、带头结点的【头插法】（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E5%B8%A6%E5%B0%BE%E7%BB%93%E7%82%B9%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%90%E5%B0%BE%E6%8F%92%E6%B3%95%E3%80%91%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.10.</span> <span class="toc-text">2、带尾结点的插入【尾插法】（时间复杂度为O(n)）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-%E5%88%A0%E9%99%A4%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%89"><span class="toc-number">3.2.0.11.</span> <span class="toc-text">(7)删除（时间复杂度为O(n)）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E8%80%85%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.</span> <span class="toc-text">3、二者时间复杂度和优缺点的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%B8%A4%E8%80%85%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.1.</span> <span class="toc-text">1、两者复杂度比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%A4%E8%80%85%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.2.</span> <span class="toc-text">2、两者优缺点比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">三、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1、栈的顺序存储实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">(1)顺序栈结构体的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.2.</span> <span class="toc-text">(2)顺序栈的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A4%E6%BB%A1"><span class="toc-number">4.1.3.</span> <span class="toc-text">(3)判满</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A4%E7%A9%BA"><span class="toc-number">4.1.4.</span> <span class="toc-text">(4)判空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%85%A5%E6%A0%88"><span class="toc-number">4.1.5.</span> <span class="toc-text">(5)入栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%87%BA%E6%A0%88"><span class="toc-number">4.1.6.</span> <span class="toc-text">(6)出栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">2、栈的顺序存储实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">(1)顺序栈结构体的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">(2)顺序栈的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A4%E7%A9%BA-1"><span class="toc-number">4.2.3.</span> <span class="toc-text">(3)判空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A4%E6%BB%A1-%E6%B3%A8%E6%84%8F%EF%BC%9A%E9%93%BE%E6%A0%88%EF%BC%8C%E4%B8%8D%E5%BF%85%E5%88%A4%E6%96%AD%E5%A0%86%E6%A0%88%E6%98%AF%E5%90%A6%E6%BB%A1"><span class="toc-number">4.2.4.</span> <span class="toc-text">(4)判满 注意：链栈，不必判断堆栈是否满</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%85%A5%E6%A0%88-1"><span class="toc-number">4.2.5.</span> <span class="toc-text">(5)入栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%87%BA%E6%A0%88-1"><span class="toc-number">4.2.6.</span> <span class="toc-text">(6)出栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3、栈的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">四、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1、队列的顺序存储实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">(1) 循环队列的结构体定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%9F%E6%88%90%E7%A9%BA%E9%98%9F%E5%88%97"><span class="toc-number">5.1.2.</span> <span class="toc-text">(2)生成空队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A4%E7%A9%BA-2"><span class="toc-number">5.1.3.</span> <span class="toc-text">(3)判空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A4%E6%BB%A1"><span class="toc-number">5.1.4.</span> <span class="toc-text">(4)判满</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%85%A5%E9%98%9F"><span class="toc-number">5.1.5.</span> <span class="toc-text">(5)入队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%87%BA%E9%98%9F"><span class="toc-number">5.1.6.</span> <span class="toc-text">(6)出队</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">2、队列的链式存储实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">(1)队列的链式存储结构体定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%9F%E6%88%90%E7%A9%BA%E9%98%9F%E5%88%97-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">(2)生成空队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A4%E7%A9%BA-3"><span class="toc-number">5.2.3.</span> <span class="toc-text">(3)判空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A4%E6%BB%A1-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%EF%BC%8C%E4%B8%8D%E5%BF%85%E5%88%A4%E6%96%AD%E5%A0%86%E6%A0%88%E6%98%AF%E5%90%A6%E6%BB%A1"><span class="toc-number">5.2.4.</span> <span class="toc-text">(4)判满 链式队列，不必判断堆栈是否满</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%85%A5%E9%98%9F-1"><span class="toc-number">5.2.5.</span> <span class="toc-text">(5)入队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%87%BA%E9%98%9F-1"><span class="toc-number">5.2.6.</span> <span class="toc-text">(6)出队</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">五、栈和队列操作的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">7.</span> <span class="toc-text">六、数组存储地址的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%A0%91%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number"></span> <span class="toc-text">———————树———————</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">一、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%E3%80%81%E5%AD%A9%E5%AD%90%E3%80%81%E5%8F%8C%E4%BA%B2%E3%80%81%E6%B7%B1%E5%BA%A6%E3%80%81%E6%9C%89%E5%BA%8F%E6%A0%91%E3%80%81%E6%97%A0%E5%BA%8F%E6%A0%91%E3%80%81%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E7%BB%93%E7%82%B9%E3%80%81%E5%8F%B6%E5%AD%90%E3%80%81%E6%A0%91%E7%9A%84%E5%BA%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">a.结点、叶子、树的度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%AD%A9%E5%AD%90%E3%80%81%E5%8F%8C%E4%BA%B2%E3%80%81%E5%85%84%E5%BC%9F%E3%80%81%E5%AD%90%E5%AD%99%E3%80%81%E7%A5%96%E5%85%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">b.孩子、双亲、兄弟、子孙、祖先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E6%97%A0%E5%BA%8F%E6%A0%91%E3%80%81%E6%9C%89%E5%BA%8F%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">c.无序树、有序树、森林</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%E5%B1%82%E6%AC%A1%E3%80%81%E9%AB%98%E5%BA%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">d.层次、高度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.</span> <span class="toc-text">2、性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">3、满二叉树、完全二叉树和二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">a.满二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">b.完全二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.4.3.</span> <span class="toc-text">c.二叉查找树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">2.</span> <span class="toc-text">二、静态查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">1、顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.</span> <span class="toc-text">2、顺序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B9%9F%E7%A7%B0%E2%80%9C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E2%80%9D%EF%BC%8C%E6%98%AF%E4%B8%80%E6%A3%B5%E2%80%9C%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E2%80%9D%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">3、二分查找（也称“折半查找”，是一棵“二叉排序树”）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91ASL%E8%AE%A1%E7%AE%97"><span class="toc-number">2.4.</span> <span class="toc-text">4、二分查找判定树ASL计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E6%89%BE%E6%88%90%E5%8A%9F%E7%9A%84ASL"><span class="toc-number">2.4.1.</span> <span class="toc-text">（1）查找成功的ASL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E6%89%BE%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84ASL"><span class="toc-number">2.4.2.</span> <span class="toc-text">（2）查找不成功的ASL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">3.</span> <span class="toc-text">三、动态查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">1、二叉树链表结构描述如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%EF%BC%88%E6%8E%92%E5%BA%8F%E3%80%81%E6%9F%A5%E6%89%BE%EF%BC%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2、二叉搜索（排序、查找）树的构造过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">(1)构造过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">(2)插入过程算法及其代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.3.</span> <span class="toc-text">(2)删除过程算法及其代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.4.</span> <span class="toc-text">(3)查找过程算法及其代码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">a.二叉搜索树的递归查找函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E8%BF%AD%E4%BB%A3%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">b.迭代查找算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">3.2.5.</span> <span class="toc-text">(4)查找最大值和最小值</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E7%9A%84%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">a.最小元素的递归函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">b.查找最大元素的迭代函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.</span> <span class="toc-text">四、二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.1.</span> <span class="toc-text">1、先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2、层序遍历(队列实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.1.</span> <span class="toc-text">3、由遍历序列还原二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E5%B7%B2%E7%9F%A5%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">b.已知后序遍历和中序遍历还原二叉树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">五、递归遍历算法的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">5.0.1.</span> <span class="toc-text">1、求二叉树的深度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E6%A0%91"><span class="toc-number">5.0.2.</span> <span class="toc-text">2、求二叉树的叶子树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BA%A4%E4%BA%92%EF%BC%88%E6%8D%A2%EF%BC%89%E5%B7%A6%E3%80%81%E5%8F%B3%E5%AD%90%E6%A0%91"><span class="toc-number">5.0.3.</span> <span class="toc-text">3、交互（换）左、右子树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">六、静态查找和动态查找的根本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%A0%91-%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">七、树&#x2F;森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.1.</span> <span class="toc-text">1、树、森林与二叉树的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.2.</span> <span class="toc-text">2、森林转换为二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="toc-number">7.3.</span> <span class="toc-text">3、二叉树转换为树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">7.4.</span> <span class="toc-text">4、二叉树转换为森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">7.5.</span> <span class="toc-text">5、转换以后的特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">八、线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">1、存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%AD%A9%E5%AD%90%E8%BF%98%E6%98%AF%E7%BA%BF%E7%B4%A2"><span class="toc-number">8.2.</span> <span class="toc-text">2、如何判断是孩子还是线索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86"><span class="toc-number">8.3.</span> <span class="toc-text">3、三种遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">九、哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6WPL"><span class="toc-number">9.1.</span> <span class="toc-text">1、带权路径长度WPL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">2、哈夫曼树的构造（算法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">9.3.</span> <span class="toc-text">3、哈夫曼树的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">9.4.</span> <span class="toc-text">4、哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number"></span> <span class="toc-text">———散列查找———</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="toc-number">1.</span> <span class="toc-text">一、散列查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.1.</span> <span class="toc-text">1、基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2、散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%E3%80%81%E5%85%B3%E9%94%AE%E8%AF%8D%E4%B8%BA%E6%95%B0%E5%AD%97%E6%97%B6%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">（1、关键词为数字时：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">a.直接定址法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95-%E5%B8%B8%E7%94%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">b.除留余数法(常用)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#c-%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">c.数字分析法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#d-%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">d.平方取中法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%E3%80%81%E5%85%B3%E9%94%AE%E8%AF%8D%E4%B8%BA%E5%AD%97%E7%AC%A6%E6%97%B6%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">（2、关键词为字符时：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a%E3%80%81ASCII%E7%A0%81%E5%8A%A0%E5%92%8C%E6%B3%95"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">a、ASCII码加和法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b%E3%80%81%E5%89%8D3%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%A7%BB%E4%BD%8D%E6%B3%95"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">b、前3个字符移位法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、处理冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">1、开放定址法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">a.线性探测法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b%E3%80%81%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%EF%BC%88%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%EF%BC%89"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">b、平方探测（二次探测）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#c-%E5%9C%A8%E6%95%A3%E5%88%97%E6%B3%95"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">c.在散列法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2、分离链接法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%9B%BE%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number"></span> <span class="toc-text">———————————————图————————————————</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E5%8D%95%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">1、简单图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">2、完全图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3、连通分量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4、强连通分量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6%E3%80%81%E5%85%A5%E5%BA%A6%E5%92%8C%E5%87%BA%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">5.顶点的度、入度和出度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.</span> <span class="toc-text">二、图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">1、数组（邻接矩阵）表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">a.无向图的邻接矩阵表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">b.有向图的邻接矩阵表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E6%9C%89%E6%9D%83%E5%9B%BE%EF%BC%88%E7%BD%91%EF%BC%89%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">c.有权图（网）的邻接矩阵表示法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E5%90%88%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.邻接表（顺序存储与链式存储结合）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">a.无向图的邻接表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B8%8E%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">b.有向图的邻接表与逆邻接表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E5%B8%A6%E6%9D%83%E5%80%BC%E7%9A%84%E7%BD%91%E5%9B%BE"><span class="toc-number">2.2.3.</span> <span class="toc-text">c.带权值的网图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">三、图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.0.1.</span> <span class="toc-text">1、深度优先遍历算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.0.2.</span> <span class="toc-text">2、广度优先遍历算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">二、最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%80%A7%E8%B4%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">1、性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81Prim%E7%AE%97%E6%B3%95"><span class="toc-number">4.0.2.</span> <span class="toc-text">2、Prim算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">4.0.3.</span> <span class="toc-text">3、Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">三、拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">4.1.1.</span> <span class="toc-text">四、最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">迪杰斯特拉算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">具体过程</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E2%80%94"><span class="toc-number"></span> <span class="toc-text">———排序———</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">一、排序的类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">1、插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">基本思想：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">【1】直接插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">（1、基本思想：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">（2、执行过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%E3%80%81%E6%97%B6%E7%A9%BA%E6%95%88%E7%8E%87%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">（3、时空效率及稳定性</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">【2】希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">（1、基本思想：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">（2、执行过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%E3%80%81%E6%97%B6%E7%A9%BA%E6%95%88%E7%8E%87%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7-1"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">（3、时空效率及稳定性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">2、交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-1"><span class="toc-number">3.1.</span> <span class="toc-text">基本思想：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">【1】冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-2"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">（1、基本思想：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-2"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">（2、执行过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%E3%80%81%E6%97%B6%E7%A9%BA%E6%95%88%E7%8E%87%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7-2"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">（3、时空效率及稳定性</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">【2】快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-3"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">（1、基本思想：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-3"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">（2、执行过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%E3%80%81%E6%97%B6%E7%A9%BA%E6%95%88%E7%8E%87%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7-3"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">（3、时空效率及稳定性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">3、选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-2"><span class="toc-number">4.1.</span> <span class="toc-text">基本思想：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%901%E3%80%91%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">【1】简单选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-4"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">（1、基本思想：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-4"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">（2、执行过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%E3%80%81%E6%97%B6%E7%A9%BA%E6%95%88%E7%8E%87%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7-4"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">（3、时空效率及稳定性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%902%E3%80%91%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">【2】堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-5"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">（1、基本思想：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%A6%81%E7%82%B9"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">（2、执行过程要点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">&lt;1&gt;初始化堆的过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%E3%80%81%E6%97%B6%E7%A9%BA%E6%95%88%E7%8E%87%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7-5"><span class="toc-number">4.3.0.4.</span> <span class="toc-text">（3、时空效率及稳定性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4、归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.5.</span> <span class="toc-text">二、各种排序的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A3%E8%AF%80%EF%BC%9A%E5%BF%AB%E9%80%89%E5%A0%86%E5%B8%8C%E4%B8%8D%E7%A8%B3%EF%BC%8C%E9%80%89%E5%A0%86%E5%BD%92%E5%9F%BA%E4%B8%8D%E5%8F%98"><span class="toc-number">4.6.</span> <span class="toc-text">口诀：快选堆希不稳，选堆归基不变</span></a></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">GZHU</span><span class="icp-content">193001-0001</span></nobr><br><nobr><span class="icp-title">OUTPOST</span><span class="icp-content">169-2025-0331</span></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>