[{"title":"LiteLoaderQQNT","url":"/Arknight-notes/posts/12035.html","content":"LiteLoaderQQNTLiteLoaderQQNT 是 QQNT 的插件加载器，一般在 QQNT 的环境内简称为 LiteLoader。它可以让你自由地为 QQNT 添加各种插件，并实现例如美化主题、增加功能等各种功能。\n（比如防撤回，设置动态背景啥的\n\n（波奇可爱捏\n安装此文档为 LiteLoaderQQNT 1.1.x 编写\n\n（法一）（推荐）第三方工具一些社区开发的安装工具来帮助你快速安装，或跳过此条目来阅读官方安装教程\n link LiteLoaderQQNT 快速安装, https://github.com/Mzdyl/LiteLoaderQQNT_Install/, https://avatars.githubusercontent.com/u/95263282?v=4 \n\n（法二）你需要先下载 LiteLoaderQQNT 到任意位置，以下有两种方式\n\n通过 Release\n前往 LiteLoaderQQNT 仓库，在 Release 中 Latest 内，下载 LiteLoaderQQNT.zip 文件，将压缩包内 LiteLoaderQQNT 目录解压到任意位置\nLiteLoaderQQNT：https://github.com/LiteLoaderQQNT/LiteLoaderQQNT\n\n通过 Clone\n使用 Git 工具将 LiteLoaderQQNT 仓库 Clone 到本地任意位置\nshell\ngit clone --depth 1 https://github.com/LiteLoaderQQNT/LiteLoaderQQNT.git\n\n\n找到 QQNT 安装目录，编辑 resources\\app\\app_launcher\\index.js 文件，在最前端插入一行require(String.raw此处为你 LiteLoaderQQNT 目录路径);\njavascript\nrequire(String.raw`C:\\LiteloaderQQNT`); // 此处换成你 LiteLoaderQQNT 目录位置require('./launcher.node').load('external_index', module);\n请确保拥有 QQNT 安装目录的读写权限！如果不想给予 QQNT 安装目录读写权限\n\n按照下文 存储位置 一节进行设置\n将 LiteLoaderQQNT/src/preload.js 复制到 QQNT/resources/app/versions/此处为版本号/application/preload.js\n\nLiteLoaderQQNT 会在第二步骤的文件不一致或没有文件时自动复制，也就是说在更新本体后需再进行一次这步骤\n\n插件此文档为 LiteLoaderQQNT 1.1.x 编写\n安装方式一：手动安装如果你有现成的插件，请先确保是与 LiteLoaderQQNT 兼容的，并且拥有对应依赖插件\n将插件目录移动到 LiteLoaderQQNT/plugins 文件夹内，如果插件是压缩包请先解压\n方式二（推荐）：LiteLoaderQQNT Plugin 插件安装助手可以先手动安装第三方插件市场类插件，在其中安装插件\nhttps://github.com/ltxhhz/LL-plugin-list-viewer/功能\n插件列表查看\n插件检查更新\n插件安装（支持镜像）\n插件卸载\n插件查找\n\n\n\n依赖查找\n\n\n使用方法法一：下载发行版https://github.com/ltxhhz/LL-plugin-list-viewer/releases/tag/v1.3.1\n\n下载发行版并解压\n将文件夹移动至 LiteLoaderQQNT数据目录/plugins/ 下面\n重启 QQNT\n\n法二：使用 git clone\nclone 本仓库 git clone https://github.com/ltxhhz/LL-plugin-list-viewer.git\n运行以下命令\n\nnpm inpm run build\n\n如果clone到了 plugins 目录下，修改 manifest.json 中 inject 为\n\n\"injects\": {    \"main\": \"./dist/main/index.js\",    \"preload\": \"./dist/preload/index.js\",    \"renderer\": \"./dist/renderer/index.js\"}\n\n否则可以将 dist 目录移动到 LiteLoaderQQNT数据目录/plugins/ 目录下\n\n使用安装完后打开QQ打开设置页面选择插件列表即可\n\n附录寻找插件插件列表官方维护着一份插件列表，收录了已知的大部分插件，可在官网首页中查看详情\n通过搜索LiteLoaderQQNT 的插件基本发布在 GitHub，善用搜索可以快速的找到所需插件\n比如在搜索框键入关键词LiteLoader和插件，即可找到大量LiteLoaderQQNT生态的插件\n官网首页LiteLoaderQQNt 官网下面已列出全部已收录插件，点击卡片即可跳转至对应仓库\n插件市场有一些第三方插件市场，手动安装后可列出大量插件\n修补此条目仅需 Windows 用户查看，其他系统无需继续阅读此条目\n由于 Windows 系统平台 QQNT 被添加文件完整性验证，你需要额外步骤来解除限制,有下列四种方式：\n\nDLLHijackMethod\n在 Release 下载 dll 文件，重命名为 dbghelp.dll 放入 QQ.exe 同级目录下即可https://github.com/LiteLoaderQQNT/QQNTFileVerifyPatch/tree/DLLHijackMethod\n\nQQNTFileVerifyPatch\n在 Release 下载 exe 文件，运行将弹出文件选择框，进入 QQNT 安装目录选择 QQ.exe 开始修补，每次更新都需要重新修补https://github.com/LiteLoaderQQNT/QQNTFileVerifyPatch\n\nPatcherNFixer\n在 Release 下载 zip 文件，解压后运行 exe 将弹出图形化界面，根据软件界面提示选择相应选项与修补方式，每次更新都需要重新修补https://github.com/xh321/LiteLoaderQQNT-PatcherNFixer\n\nV8Killer\n此方式目前过于麻烦，且需要自行寻找对应的 RVA 偏移量，只说明此方式的可行性，需自行探索使用方式https://github.com/ShellWen/v8_killer\n\n\n检查按照上述教程完成安装后，有两种方法检查 LiteLoaderQQNT 是否成功安装\n\n运行 QQNT 并打开设置，查看左侧列表是否出现 LiteLoaderQQNT 选项\n使用终端运行 QQNT 查看是否有 LiteLoaderQQNT 相关内容输出显示\n\n如果有显示，即安装成功，玩的开心！\n存储目录支持设置 LITELOADERQQNT_PROFILE 环境变量指定 data plugins config.json 存储位置，即可不在本体目录进行读写操作，比如 MacOS 与 Linux 平台 QQNT，以及类似于 flatpak 打包的 QQNT，让其实现成为可能\n如果你想将本体与存储目录合并在一起（便携软件）需将 LITELOADERQQNT_PROFILE 环境变量删除，将 data plugins config.json 移动回本体根目录下\n更新QQNT每次更新 QQNT 都需要重新根据上述教程重新修补\n版本支持支持 QQNT 桌面端 全架构 最低 20667 版本到官网最新版更老的版本也支持，只是设置界面样式会崩坏，不介意也可以用\n外部链接Telegram群聊：https://t.me/LiteLoaderQQNT频道：https://t.me/LiteLoaderQQNT_Channel\nLiteLoaderQQNT框架本体：https://github.com/LiteLoaderQQNT/LiteLoaderQQNT插件模板：https://github.com/LiteLoaderQQNT/Plugin-Template插件列表：https://github.com/LiteLoaderQQNT/Plugin-List\nist\n","categories":["Github项目"]},{"title":"IP签名","url":"/Arknight-notes/posts/60087.html","content":"\n\n\n\n\nd/)\n","categories":["博客美化"],"tags":["美化"]},{"title":"GitHub贡献图表📊","url":"/Arknight-notes/posts/14584.html","content":"在博客网站等地方引用 Github 贡献图表Github 的提交记录，总的来说能够回顾这一年，看看你的工作效率是一种很棒的感觉，而这个小绿色日历实际上是我最喜欢的数据可视化之一。但是没有理由让它只限于出现在 Github 网站上\n来看一下 Github “提交狂魔” @ruanyf 的提交记录\n\n\n以上是如何做到的呢？这可不是截图，而是现成的 API，官网地址：https://ghchart.rshah.org/\n源码在 Github 上开源，仓库地址：https://github.com/2016rshah/githubchart-api\n感谢作者2016rshah提供此 API\n使用怎么使用这个 API 呢？很简单，使用img标签引用即可\n&lt;img src=\"https://ghchart.rshah.org/Zhongye1\" /&gt;\n将src中的Zhongye1使用自己的 Github 用户名替换即可\n也支持修改配色，只需在用户名前加上所需的十六进制颜色代码即可。例如，如果想要一个基于十六进制颜色的蓝色主题图表#409ba5\n自定义颜色例如，如果你想要一个基于十六进制颜色的蓝色主题图表 #409ba5，只需在用户名前加上所需的十六进制颜色代码即可。例如，如果想要一个基于十六进制颜色的蓝色主题图表#409ba5\n&lt;img src=\"https://ghchart.rshah.org/409ba5/Zhongye1\" /&gt;\n效果是这样的\n\nZhongye1's Github Chart \n\n附上HTML拾色器\n link HTML 取色器/拾色器, https://www.runoob.com/tags/html-colorpicker.html, https://picx.zhimg.com/80/v2-7c046fc439e9fab342cda2e9291febdb_720w.webp?source=d16d100b \n如果有任何可以改进的内容，\n可以给作者在 Github 上提交 issue/PR（\n=15% &gt;\n"},{"title":"何加盐｜中文互联网正在加速崩塌","url":"/Arknight-notes/posts/14940.html","content":"何加盐｜中文互联网正在加速崩塌05/23/2024\n1先问你一个小问题：\n如果我们在百度上搜索“马云”这两个字，把时间设定在1998年到2005年，能搜出来的信息，大概有多少条呢？是1亿条，还是1000万条，还是100万条？\n我在几个群问过，大家普遍的猜想是，应该是百万或者千万的级别。毕竟，互联网信息如此浩如烟海。马云作为那个时代的风云企业家，在网上留下的痕迹肯定是非常多的。\n但实际上用百度搜索，选定日期范围为“1998年5月22日到2005年5月22日”，含有马云的信息，总共是1条（2024年5月22日数据）。\n而仅有的这一条信息，也是虚假的。点进去会发现，文章的发布时间其实是2021年，不属于上面限定的时间段，只是不知怎么回事，它被莫名其妙地搜索出来。\n也就是说，如果我们想要了解那一段时间关于马云的经历、报道、人们对他的讨论、他的讲话、公司的发展史等等，我们能得到的有效的原始信息量，是零。\n你可能会觉得，这是不是百度的问题啊？如果换必应或谷歌，会不会能搜出来？\n我测试过，这两个网站搜出来的有效信息，和百度没有太大区别，比百度略多一些，但也只是个位数。更多的也都是时间紊乱的无效信息，只不过不知道是什么技术原因，被错误地抓取出来。\n你可能还会觉得，是不是因为马云属于比较有争议的人，由于某种不可描述的原因，所以他的信息才无法搜到？\n但实际上，不仅仅是马云的情况如此，我们去搜马化腾、雷军、任正非等，甚至是罗永浩和芙蓉姐姐这样在那个时候红极一时的网红，或周杰伦、李宇春那样曾经火遍全网的明星，结果也都一样的。\n在测试过不同网站、不同人名、不同时间段之后，我发现一个令人震惊的现象：\n几乎所有在那个年代曾经红火过的中文网站，如网易、搜狐、校园BBS、西祠胡同、凯迪猫眼、天涯论坛、校内网（人人网）、新浪博客、百度贴吧、以及大量的个人网站等，在一定年份之前的信息都已经完全消失不见了，甚至大部分网站是所有年份的信息都消失了。唯一例外的是新浪网，还能找到一些十几年前的信息，但也是极少数的寥寥几条，其他99.9999%以上的内容，全都消失了。\n大家都没有意识到一个严重的问题：中文互联网正在迅速崩塌，移动互联网出现之前的中文互联网内容，已经几乎消失殆尽。\n我们原以为，互联网是有记忆的，但没有想到，这种记忆，原来是像金鱼一样的记忆。\n2我之所以注意到这个问题，是因为何加盐公众号的主题是研究牛人，所以我需要经常查找他们的资料。\n这两年来，我有一个非常明显的感觉：网上能找到的原始资料，每年都以断崖式的速度在锐减。之前还能看到一些原始的报道，后来慢慢没有了；之前还能找到主人公的演讲或者他们写的文章，后来慢慢找不到了；之前还能看到很多采访或对谈的视频，后来慢慢消失了。\n似乎有一个吞噬网页的怪兽，它沿着历史的时间线，从过去向着现在吞噬，先是小口小口，然后大口大口，把中文互联网的一切内容，以五年、十年为单位，一口吞掉。\n等我们回过神来，会发现，在移动互联网之前曾经存在过的中文互联网的一切，不管是门户网站、机构官方网站、个人网页，还是校园BBS、公众论坛，还是新浪博客、百度贴吧，还是文件、照片、音乐、视频等，都已消失不见。\n记得十几年前，我曾经因为换电脑，把一些照片和文章打成一个压缩包，存在某BBS上，几年之后发现，那整个BBS都没有了。我曾经用过hotmail的邮箱，里面有很多很珍贵的邮件，后来全都没有了。我还写过人人网、MySpace，后来全都没有了。\n我们曾经以为互联网可以保留一切，但结果是一切都没能保留。\n这让我想起刘慈欣《三体》里面提到过的“二向箔”。歌者文明发现了太阳系有智慧生物的存在，出于宇宙先进文明的清除本能，他们向太阳系扔出一张二向箔，于是，整个太阳系以光的速度从三维坍塌成二维，变化成一张酷似梵高“星空”的画片。一切生命、一切文明的痕迹，从此都不复存在。\n在互联网上，我们已经处于二向箔的吞噬之中。这种二向箔可以称之为“时间的二向箔”，它吞噬的是时间那一维。\n太阳系被歌者文明的二向箔拍扁之后，好歹还留下了一幅《星空》图，而互联网被时间的二向箔吞噬后，只留下一片虚空。\n3为什么会出现这种情况呢？我猜想，主要原因可能是两个：\n一是经济原因。\n网站的存在，需要服务器、需要带宽、需要机房、需要人员运维，还有很多杂七杂八的监管和维护费用，这些都是成本。如果是有战略价值（例如需要向外展示公司想要展示的信息），或者有短期流量价值（例如还时不时有较多的人上来看），同时公司账上也不差钱，那么还会有动力去维持。\n但是如果公司在商业上走了弯路，没钱了，整个网站就会直接死掉。例如人人网就是典型代表。\n即便公司还有钱，从运营的角度来看，如果一个网页一年到头都没有几个人来点击，对公司来说，就成了一笔负担，从经济上最理性的方法，就是直接关掉。搜狐、网易早年的内容大量丢失，以及以天涯论坛为代表的BBS集体消亡，都是这个原因。\n二是监管原因。\n总体而言，互联网信息的监管，是从无到有，从宽到严，从严到更严的过程。以前可以合法存在的内容，后来不符合监管要求了；或者是以前可以灰色存在的内容，后来被定义为黑色了。这些内容都会直接被咔嚓掉。\n还有一些是随着时代的变化，舆论的两极分化越来越极端，以前“只道是平常”的内容，在后来的舆论环境中显得非常尖锐、敏感，尽管不违法，但是可能激化矛盾，形成混乱，监管方也有可能会要求处理掉。\n除了官方部门之外，愤怒的网友，也时时充当着舆论监管员的角色。他们会翻出十几年前某人无意中说的某句话，揪着不放，把人网暴至“社会性死亡”。\n但监管上最重要的影响，还不是监管部门的处理或愤怒网友的攻击，而是它们会造成公司与个人的“自我审查”。\n因为谁也不知道，网站上存在的哪一条内容，某人曾说过的哪一句话，会不会在若干年后，给当事人带来灭顶之灾。最好的办法，就是直接把这些潜在的“定时炸弹”全部清除，也就是把网站关掉或者把内容全部删除。\n当然，除了上述两个原因之外，还会有其他很多原因。\n例如，在南斯拉夫解体之后不久，所有“yu”（南斯拉夫国名Yugoslavia的缩写）这个国际域名之下的网页内容全部消失了。又如，随着版权保护的加强，曾经随处可下载的音乐和电影网站，就都消失了。还有一些机构和个人，纯粹是由于自己的原因，不想在对外展示信息了，就把官网或个人主页关掉等等。\n但这些原因都是次要的、局部的。整个互联网内容系统性的、大规模的消失，主要就是由于经济规律和自我审查。\n本质上，互联网内容和生命一样，也受进化论的支配。其存在的标准只有一条：以尽可能低的成本争取尽可能多的注意力。\n当一个内容能够在互联网上的海量内容中争取到足够多的注意力，而维持这个内容的成本（包括经济成本、监管成本和对抗监管的成本）比其他方式更低时，这个内容就有可能存活在互联网上。只不过它有可能会换一种呈现方式，例如从文字变为图片，从静图变为动图，从动图变为视频，未来可能从二维视频变为三维全息视频等等。承载这个内容的平台也会变迁，从门户网站到BBS，到个人博客，到微博微信，到抖音视频号，到未来可能一个我们不知道什么平台。\n当一个内容不能再吸引到足够多的注意力，或者维持这个内容的成本比其他方式更高时，这个内容就会从互联网上消失。以电脑为浏览端、以网页为载体的传统互联网的集体消亡，只不过是这种“信息进化竞争”的必然结果而已。\n生物的进化秘诀是“物竞天择，适者生存”，而互联网内容的进化秘诀是“信息竞，注意力择，适者生存”。由于网络效应，这种竞争比自然界还要猛烈万倍，残酷万倍。传统互联网不是单个物种式的灭绝，而是几乎所有内容的整体性灭绝。\n每一代新的互联网崛起，旧的互联网必将崩塌，时间二向箔是所有网站、所有内容无可逃避的宿命。\n4如果未来的文明是互联网的文明。我们这一代人，将是没有历史的。因为互联网没有留下我们的痕迹。\n“没有历史”，这件事情重要吗？\n当然很重要。\n我曾经为了写邵亦波的文章，想尽了一切办法，试图找到邵亦波2007年参加《波士堂》节目的原始视频，以及他妻子鲍佳欣以“文爱妈咪”网名在宝宝树社区发了好几年的帖子。最终还是没有找到，只能深深遗憾。\n虽然《红尘已忘邵亦波》那篇文章，依然很受大家欢迎，短短一周就有70多万人阅读，2万多人转发，但我十分肯定，我一定还是错过了某些非常重要的信息。如果它们能呈现在那篇文章里，文章质量会更好。\n但是我找不到，就只能让文章以不完美的方式呈现。\n你可能会觉得：这只是对何加盐这样的研究者和写作者有用，我又不写这样的文章，互联网信息没有就没了，对我又没什么影响。\n真的吗？\n如果我们已经看不到马云的所有演讲，看不到任正非的以《我的父亲母亲》和《一江春水向东流》为代表的所有文章，看不到段永平在雪球的所有发帖，你会不会觉得有点可惜？\n好吧，你说你并不觉得可惜。\n那如果我们已经搜不到黄峥的公众号，看不到张一鸣的微博，上不了王兴的饭否，你会不会觉得有点遗憾？\n好吧，你说你也并不觉得遗憾。\n那如果某一天，知乎如同天涯论坛一样没了，豆瓣就像人人网一样消失，B站好比新浪博客一样已无人问津，你会不会有点心痛？\n如果某一天，你喜欢的微博博主所有的微博只显示“作者已设置只展示半年内微博，此微博已不可见”，你常看的公众号只显示“此账号已被屏蔽，内容无法查看”，你在抖音或小红书搜索某些信息，结果显示“作者已清空全部内容”……\n甚至，微博、公众号、抖音、小红书，就像曾经存在过的bbs、贴吧、空间、博客一样，全部消亡……\n你会不会为此难过哪怕是短短的一分钟？\n作为传统互联网的一代人，七零后、八零后已经找不回我们的历史。因为它们已经全部消失了。\n新生代也许还能看看朋友圈，但是朋友圈也越来越多“三天可见”，越来越沉默不语。\n唯一还在热情发圈的，只剩下一水的营销信息。\n未来就连这些营销信息，也终将消亡。\n5如果一件事对我们很重要，而它正在消亡，我们有什么办法挽救它吗？\n有人曾作出这样的尝试。美国有一个网站叫做“Internet Archive”，中文译作“互联网档案馆”，保存了很多原始网页。但是我试过，中文的原始网页，保存的很少，而且使用非常麻烦，搜索功能十分原始低效，和没保存差不多。\n从技术层面来讲，保存从中国有互联网以来，到移动互联网兴起的十来年时间的所有网页，应该并不难，成本也不高，毕竟比起现在的视频时代，原始互联网的那些图文网页，占的空间几乎可以忽略不计。\n问题是，谁来做这件事，有什么动机？\n商业机构不会做。因为没有任何商业利益。\n政府或许可以像建图书馆、博物馆一样，搞一个能保存所有网页的档案馆。但是政府为什么要花钱费力干这件事？除了保存历史之外，似乎也没有其他理由。再说了，就算是政府做了这件事，对普通网民也没有任何意义，因为这个档案馆肯定也会需要一定的登陆权限，以免信息被滥用。\n况且，就算是有机构愿意做这件事，现在也晚了。移动互联网兴起之后，传统互联网的中文内容，几乎已经消失殆尽了。粗略估算，99%以上应该都已经没有了。\n从某种意义上，何加盐写的牛人系列文章，也为保存这些牛人们存在过的历史，做出了一点贡献。如果我没有写他们，很多历史就已经在网上找不到了。但毕竟这也不是原始信息，只是经我整合过的二手信息。\n现在的中文互联网上，这个世纪前十年发生过的所有重大事件，所有留下过深深痕迹的名人，目前还能找到的信息，几乎已经全是经自媒体编辑过的二手信息，甚至是传过多手，早已面目全非的信息。\n关于它们的原始报道没有了，原始视频没有了，原始讲话没有了，原始的网友目击没有了，原始的评论没有了……\n再过一些年，这些二手信息和N手信息，也都会消失。就像那些事件从未发生过、那些人从未存在过一样。\n我们已经无能为力，只能接受现实。\n在未来的互联网时代里，回首看21世纪的前二十年，将是没有历史记录的二十年。\n我们是互联网时代消失的一代人。\n如果你现在还能看到一些中文互联网的古早信息，那只是夕阳的最后一抹余晖。\n如果你明白了它们的转瞬即逝，可能会像临死前的浮士德一样感叹：\n你真美啊，请停留一下吧。\n但那抹余晖，很快将和你这句感叹一起，被时间的二向箔吞没，陷入虚空。\n《三体》中，程心和艾AA还能有幸乘坐唯一的一艘曲率飞船，逃离正在二维化的太阳系。\n而我们，连曲率飞船都没有。\n逃无可逃。\n现在你所看到的、你所创造的几乎所有内容，连同这篇文章，这个平台，终究也会淹没在虚空中。\n—end—\n�**\n"},{"title":"近期CDN状况分析","url":"/Arknight-notes/posts/19085.html","content":"原博主在 V2EX 发声, 表示其被威胁删帖: https://www.v2ex.com/t/1057993原博主首次在 V2EX 发帖: 《供应链投毒后，我们的选择还剩下哪些？》 https://v2ex.com/t/1056428\n原博文: https://www.54yt.net/435.html\n原博客文章备份: https://web.archive.org/web/https://www.54yt.net/435.html\n为了防止丢失并出于公共利益, 以下是全图文转载, 如有不妥可删除\n-\n-\n-\nBootCDN/Staticfile投毒分析供应链投毒后，我们的选择还剩下哪些？病毒分析分区附件样本、网址谨慎下载点击，可能对计算机产生破坏，仅供安全人员在法律允许范围内研究，禁止非法用途！\n禁止求非法渗透测试、非法网络攻击、获取隐私等违法内容，即使对方是非法内容，也应向警方求助！\n\n前言从早前的LNMP、OneinStack到XZ Utils，再到现在的Staticfile、BootCDN；供应链攻击总是让人猝不及防。纵观这些被攻击的项目，往往都是无处不在，经常被大家所使用，但是却并没有给提供者带来什么收入。 在突然有一天，提供者感到疲惫不堪，却又迫于用户们的压力无法关停服务的情况下，突然有新的组织/个人来帮助一起进行开发或提供服务，甚至是直接的现金收购/服务赞助；在这种情况下，接受帮助自然是首选的方案。 我认为建立有效的捐助途径不失为缓解这一问题的良方，正如AlmaLinux、RockyLinux或是cdnjs、jsdelivr一样，这些服务背后都有着可靠的企业长期提供捐助承诺，也帮助项目不断成长和有效地提供服务。序幕和WDCP、LNMP、OneinStack一样，这次的Staticfile、BootCDN、Polyfill事件也是背后指向同一个组织[[1]]。更进一步的研究表明这些组织似乎会恶意攻击其他提供类似服务的供应商，同时采取接触洽谈来并入攻击目标。 在这种做法下，曾经由七牛云提供服务的Staticfile.org被易手，而原先由个人提供服务、由又拍云提供接入服务的BootCSS也同样被易手。 但是这些背后的交易在事件发生前却没有人进行公开，也许是原来的提供者厌倦了日复一日付出却看不到回报的生活，也许是这些组织瞒天过海许下了虚假的承诺，让原本积累了大量用户的基础服务成为了这些组织用来攻击用户们的利刃。\n探究大多数关于这次攻击的报道集中于一个星期之前，然而事件的开始却远早于这个时间。一年以前，V2EX社区就有用户发文表示BootCSS的静态资源被投毒[2]。通过查阅记录可以发现，BootCSS.com由王赛于2012年底批量注册，建站初期主要提供的是BootStrap介绍和交流[3,4,5]。于此同时进行批量注册的还有golaravel.com等一系列技术栈的中文网，猜测是想使用站群方式来进行项目文档的本地化，同时积累受众用户。在2013年十一月初，BootStrap中文网上线了OpenCDN加速服务，由又拍云赞助，提供cdnjs的国内镜像[6]。也许是由于用户的增长又拍云难以承担高额的成本，又或者是又拍觉得收益无法Cover成本，这段关系一直持续到了2017年年底[7]。自此之后的一段时间，提供服务的CDN便开始快速变更，从白山云到京东云，最终到了10月份由于账单压力或是其他原因出现了大面积的服务中断[8]。在恢复后，原先的服务开始由猫云提供，自此开始BootCDN的服务出现了一些不连续的中断事件[9]。2019年3月、10月、2020年1月陆续出现小规模的中断，尽管如此，但是在接下来的几年时间中，猫云一直为BootCDN提供加速服务，只是加速域名从cdn.bootcss.com更换为了cdn.bootcdn.net；而于此同时百度静态资源公共库则彻底停止了服务。时间来到2022年，在1月份经历了中断后，2月份猫云或许是基于和又拍云同样的原因停止了赞助，服务商也从此开始变更为了极兔云[10]。或许是由于极兔云本身是融合CDN服务，与上一家同样类型的赞助商服务相冲突的原因，BootCDN发布公告表示将下线cdn.bootcss.com域名。在此期间，jsDelivr的备案被关停、解析被污染，从此基本断绝了在中国大陆的使用。\n梦醒2023年4月份，BootCDN的三个关联域名[bootcdn.net,bootcdn.cn,bootcss.com]ICP备案变更为郑州紫田网络科技有限公司，同时域名注册商也从阿里云转入腾讯云，由此揭幕了噩梦的来临[11]。2023年6月份，开始有用户陆续发现部分静态资源内存在投毒行为[12]。即便到现在，投毒行为仍在继续，大量用户反馈存在资源被投毒[13]。自此BootCDN这个拥有十多年历史的国内静态资源加速服务彻底沦为了攻击者的工具，恶意代码随意被嵌入无数正在使用的网站中。而由于BootCDN历史久远，以至于许多生产环境甚至都不知道他们曾经引入了该服务。而这样的攻击相信还会继续持续下去，直到大家渐渐意识到…又或是仍旧…\n巧合无独有偶，原本由七牛云提供服务的Staticfile CDN于2023年10月进行了备案信息变更和注册局转移[14]。两个关联域名staticfile.org和staticfile.net被转入河南泉磐网络科技有限公司。而先前BootCDN所转入的公司名称为郑州紫田网络科技有限公司，两者同为河南省郑州市的相同类型公司。而先前Ze-Zheng Wu所发现的几个域名由统一组织控制高度符合[15]。通过天眼查查询可知紫田科技旗下知名的一个产品为51.La站点统计平台。通过Bing搜索不难发现在2023年集中出现大量使用该统计平台遇到劫持的案例。通过天眼查对紫田科技股东徐征进行查询，发现其曾担任郑州帝恩爱斯网络科技有限公司法定代表人及高管，也曾担任河南云打包网络科技有限公司高管和股东。而Staticfile域名持有公司河南图网信息技术有限公司的法人申石磊同时任职郑州帝恩爱斯网络科技有限公司法定代表人。而Staticfile的域名注册商商中在线也与紫田科技关联的公司存在着说不清道不明的关系。自此可以确定这两个原本由不同云厂商所赞助的静态资源加速服务已经被同一组织所控制，与上述Ze-Zheng Wu的调查一致。看似似乎这只是一个名不见经传的小公司所为，然而这只不过是挡在云层前的迷雾。通过查阅可以发现郑州紫田网络科技有限公司总经理李跃磊同时担任河南亿恩科技股份有限公司股东。\n通过天眼查透视链可以查看到企业彼此之间的关联信息。故事到这里似乎就结束了，然而还有收购polyfill服务的那家公司Funnull需要进行调查。通过查询域名注册和备案信息可以发现背后的公司为南京妙彩文化传播有限公司。这家公司的主营业务则是为博彩网站提供国内优化CDN服务，与上述的劫持行为不谋而合。不过更为危险的是这家公司同时还提供诈骗、钓鱼、色站等令人发指的服务，将供应链攻击提升到了新的高度。\n答案这就像一张巨大的关系网，串联起了利益链中的彼此。每一家公司都看似运营者合规可靠的服务，背后进行的确实见不得人的勾当。\n郑州紫田网络科技有限公司商中在线科技股份有限公司河南亿恩科技股份有限公司南京妙彩文化传播有限公司河南图网信息技术有限公司河南云打包网络科技有限公司北京新网互联软件服务有限公司郑州帝恩爱斯网络科技有限公司\n镇痛从来没有什么疼痛能够有效缓解，更何况是这种绝症。目前最为可靠的同类服务为字节跳动静态资源公共库你可以将以下地址进行修改\ncdn.bootcss.comcdn.bootcdn.net/ajax/libscdn.staticfile.netcdn.staticfile.org\n替换为\n//zstatic.net 又拍云赞助s4.zstatic.net/ajax/libs//本站提供，回源南科大，使用火山云CDNcdnjs.snrat.com/ajax/libs\n或者你可以尝试其他的提供商\n//7EDuse.sevencdn.com/ajax/libs//Web缓存网cdnjs.webstatic.cn/ajax/libs///字节跳动 最后更新于2022年lf3-cdn-tos.bytecdntp.com/cdn/expire-1-Mlf6-cdn-tos.bytecdntp.com/cdn/expire-1-Mlf9-cdn-tos.bytecdntp.com/cdn/expire-1-Mlf26-cdn-tos.bytecdntp.com/cdn/expire-1-M//360奇舞团，长期未更新https://lib.baomitu.com///晓白云sf.akass.cn//泽瑶网络 jsDelivr镜像cdn.jsdmirror.com\n目前已经收到相关企业的威胁邮件*\n[1]https://www.bleepingcomputer.com/news/security/polyfillio-bootcdn-bootcss-staticfile-attack-traced-to-1-operator/[2]https://www.v2ex.com/t/950163[3]https://web.archive.org/web/20121206014141/http://www.bootcss.com/[4]https://ip.sb/whois/bootcss.com[5]https://www.icpapi.com/%E4%BA%ACICP%E5%A4%8711008151%E5%8F%B7/[6]https://web.archive.org/web/20131103022433/http://open.bootcss.com/[7]https://web.archive.org/web/20171230183848/http://www.bootcdn.cn/[8]https://global.v2ex.com/t/494375[9]https://web.archive.org/web/20190119210705/https://www.bootcdn.cn/[10]https://web.archive.org/web/20220208201547/https://www.bootcdn.cn/[11]https://whoisfreaks.com/tools/whois/history/lookup/bootcss.com[12]https://www.v2ex.com/t/950163[13]https://github.com/Tencent/vConsole/issues/683[14]https://www.icpapi.com/staticfile.net/[15]https://x.com/mdmck10/status/1806349965733544160\n\n附：\n\n\n\n\n\n发表于 2024-7-17 19:03**本帖最后由 你好，再见 于 2024-7-18 14:32 编辑\n\n\n\n\n\n这样说来到让我想起平时手机上搜索一些资料会访问到一些个人博客，也都是加载完成后过一会跳转到垃圾网站 以前我以为是运营商在搞鬼，现在看来还真有可能是这个公共库的问题 看了一下，我自己的博客也引用了bootcdn的资源，bootcdn用的人太多太多了 个人博客真的是重灾区，很多主题作者在开发的时候就已经把这些公共库资源写死了   ————————————————————————————————\n\n\n\n\n\n\n\n\n\n\n\n\n) |\n","categories":["随记"],"tags":["CDN"]},{"title":"广州大学选课脚本","url":"/Arknight-notes/posts/20869.html","content":"-\n项目地址：\nhttps://github.com/Acring/gzhu-course-seizer\n广大选课脚本\n 本脚本只做学习使用, 禁止用作商业用途\n\n\nversion: 1.0.1\nauthor: acring\n\n简介:\n\n\n广大选课脚本, 可多线程自动选全校性选课和体育选课的课程\n\nusage:\n\n\n安装python3\n安装第三方库\npip install requests\npip install beautifulsoup4\n\n\n点开run.py, 按提示修改上面的学号,密码,目标老师等信息\n\ndata = {    \"tag\": \"xxx\",  # 标志    \"username\": \"xxx\",  # 学号    \"password\": \"xxx\",  # 密码    \"cour_type\": \"whole\",  # 选课类型 sport/whole    \"teacher\": \"方碧真\",  # 目标老师    \"index\": 1  # 相同老师,选第几个}\n\npython run.py 运行脚本\n\n\npackage:\nrequests\nbs4\n\n\n运行截图\n\n\n\nbp)\n","categories":["Github项目"]},{"title":"数据结构复习其二","url":"/Arknight-notes/posts/42108.html","content":"-\n——算法、线性表——概念明晰：随机存取、顺序存取、随机存储和顺序存储\n随机存取、顺序存取、随机存储和顺序存储这四个概念是完全不一样的，切不可将之混淆\n很多人包括我可能认为随机存取就是随机存储，顺序存取就是顺序存取，其实不是这样。\n\n下面完整的介绍一下这4个概念\n1、存取结构分为随机存取和非随机存取（又称顺序存取）\n1、随机存取就是直接存取，可以通过下标直接访问的那种数据结构，与存储位置无关。例如数组。\n 非随机存取就是顺序存取，不能通过下标访问了，只能按照存储顺序存取，与存储位置有关，例如链表。\n2、顺序存取就是存取第N个数据时，必须先访问前（N-1）个数据 （list）;\n 随机存取就是存取第N个数据时，不需要访问前（N-1）个数据，直接就可以对第N个数据操作 （array）。\n\n2、存储结构分为顺序存储和随机存储3、顺序存储结构\n\n在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素，称作线性表的顺序存储结构。\n- 顺序存储结构是存储结构类型中的一种，该结构是把**逻辑上相邻的节点**存储在**物理位置上相邻的存储单元**中，结点之间的逻辑关系由存储单元的邻接关系来体现。 - 由此得到的储结构为顺序存储结构，通常顺序存储结构是借助于计算机程序设计语言（例如c/c++）的数组来描述的。12\n– 主要优点：节省存储空间。\n因为分配给数据的存储单元全用存放结点的数据（不考虑c/c++语言中数组需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。采用这种方法时，可实现对结点的随机存取，即每一个结点对应一个序号，由该序号可以直接计算出来结点的存储地址。\n– 主要缺点：不便于修改，对结点的插入、删除运算时可能要移动一系列的结点。\n\n\n\n4、随机存储结构\n在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。它不要求逻辑上相邻的元素在物理位置上也相邻。因此它没有顺序存储结构所具有的弱点，但也同时失去了顺序表可随机存取的优点。\n\n —随机存储最典型的代表为链式存储：\n链式存储结构特点\n1、比顺序存储结构的存储密度小 （每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多）。\n2、逻辑上相邻的节点物理上不必相邻。\n3、插入、删除灵活 （不必移动节点，只要改变节点中的指针）。\n4、查找结点时链式存储要比顺序存储慢。\n5、每个结点是由数据域和指针域组成\n一、数据结构的概念1、基本概念:\n\n数据：描述客观事实的符号，是计算机中可以操作的对象，能被计算机识别，并输给计算机处理的符号集合。\n数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被成为记录。\n数据对象：是性质相同数据元素的集合，是数据的一个子集。\n数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。\n数据结构：相互之间存在一种或者多种特定关系的数据元素的集合。可分为逻辑结构和物理结构。\n\n\n\n2、算法(1)概念\n解决特定问题的求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。\n\n(2)重要特性：\n①输入：有零个输入或者多个输\n②输出：只有一个或者多个输出\n③有穷性：算法在执行有限个步骤时，会自动结束而不会陷入无限循环里面\n④确定性：算法的每一步都有确定的含义而不会出现二义性\n⑤可行性：算法的每一步都可以通过有限次数完成。\n\n3、算法的评价标准(“好”的算法应该考虑达到以下目标)\n①正确性。算法能够正确地求解问题。\n②可读性。算法能具有良好的可读性，以帮助人们理解。\n③健壮性。输入非法数据时，算法能适当地做出反应或进行处理。而不会产生莫名其妙的输出结果。\n④效率与低存储量需求。效率指算法执行的时间，存储量需求是指算法执行过程中所需的最大存储空间。\n\n4、算法的时空效率(1)时间复杂度根据算法写成的程序在执行时耗费时间的长度，记为T(n) = O(n)(2)空间复杂度根据算法写成的程序在执行时占用存储单元的长度记为S(n)(3)语句频度一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)\n时间复杂度：时间复杂度实际上是一个函数，代表基本操作重复执行的次数，进而分析函数虽变量的变化来确定数量级，数量级用O表示，所以算法的时间复杂度为： T（n）=O（f（n））\n在一个算法存在最好、平均、最坏三种情况，我们一般关注的是最坏情况，原因是，最坏情况是任何输入实例在运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，从大体上来看，平均情况和最坏情况一样差。\n\n(4)一般O（n）的计算方法：\n①用 1代替所有运行时间中出现的加法常数；\n②在修改后的运行函数中**保留最高阶的项；\n③如果最高阶的项系数不是1，则去除这个项系数。\n④ 递归算法的时间复杂度为：递归总次数每次递归中基本操作执行的次数。\n\n(5)常见的时间复杂度有以下七种：\n① O（1）常数型；② O（log2N）对数型；③ O（N）线性型；④ O（Nlog2N）二维型；⑤ O（N^2)平方型；⑥ O（N^3)立方型；⑦ O（2^N）指数型。\n例如：\ni=1;①while (i&lt;=n){\ti=i*2; ②}解：语句1的频度是1, 设语句2的频度是f(n),则：2^f(n)&lt;=n;f(n)&lt;=log2n  取最大值f(n)= log2n, T(n)=O(log2n )12345678\n二、线性表1、顺序存储(1)结构体的定义typedef int Position;typedef struct LNode * PtrToLNode;struct LNode{    ElmenetType Data[ MAXSIZE ];    Position Last;};typedef PtrToLNode List;12345678\n(2)顺序表的初始化\n1、构造一个空表\n2、动态分配表结构所需的存储空间，然后将表中Last指针置为-1 表示表中没有数据。\n\nList MakeEmpty(){    List L;\t    L = (List)malloc(sizeof(struct LNode));    L-&gt;Last = -1;\t//Last 置为-1 表示表中没有数据元素    Return L;}1234567\n\n通过L我们可以访问相应线性表的内容。比如：下标为i 的元素：L-&gt;Data[i]\n查询线性表的长度：L-&gt;Last+1;\n\n(3)顺序表的查找(时间复杂度为O(n))\n在线性表中查找与给定值 X 相等的数据元素。\n由于线性表的元素都存储在数组Data中，所以这个查找的过程实际上就是在数组里顺序查找：\n\n从第 1 个元素 a1 起依次和 X 比较， 直到找到一个与 X 相等的数据元素，返回它在顺序表中的存储下标；\n或者查遍整个表都没有找到与 X 相等的元素，则返回错误信息 ERROR。\n\n\n#define ERROR -1  /* 将错误信息 ERROR 的值定义为任一负数都可以 */Position Find( List L, ElementType X ){    Position i = 0;    While( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X)    \ti++;    if( i &gt; L-&gt;Last)    \treturn ERROR;\t/* 如果没有找到，则返回错误信息 */    else    \treturn i;\t/* 找到后返回的是存储位置 */}1234567891011\n(4）顺序表的插入 (时间复杂度为O(n))\n在表的插入是指在表的第 i（1≤ i ≤ n + 1）个位序上插入一个值为 X 的新元素（也可以理解为在第 i 个元素之前插入新的元素）\n插入后使得原来长度为 n 的序列，变为长度为 n+1的序列（i = 1时插入序列的最前端，i = n+1 时插入序列的最后）\n\n将ai~an顺序向后移动（移动次序是从 an 到ai)，为新元素让出位置；\n将 X 放入空出的第 i 个位序；\n修改 Last 指针（相当于修改表长）,使之指向最后一个元素。\n\n\nbool Insert( List L, ElementType X, int i){ /* 在 L 的指定位序 i 前插入一个新元素 X； 位序 i 元素数组位置下标为 i-1 */    Postion j;    if(L-&gt;Last == MAXSIZE-1)    {/* 表空间已满，不能插入 */        printf(\"表满！\\n\");        return false;    }        if( i&lt;1 || i &gt; L-&gt;Last+2)    {/* 检查插入位序的合法性：是否在 1~n+1； n为当前元素个数，即Last+1 */        printf（\"位序不合法！\\n\");        return false;    }        for( j = L-&gt;Last; j &gt;= i-1; j--) /*Last 指向序列最后元素an */        L-&gt;Data[j+1] = L-&gt;Data[j]; /* 将位序为 i 及以后的元素顺序向后移动 */   \tL-&gt;Data[i-1] = X;\t/* Last 仍指向最后一个元素 */    L-&gt;Last++;    return true;}123456789101112131415161718192021\n(5)顺序表的删除（时间复杂度为O(n)）\n将表中的位序为 i（1≤ i ≤ n + 1）的元素从线性表中去掉，删除后使原长度为 n 的数组元素序列,变为长度为 n-1 的序列\n\n将a[i+1]~a[n] 顺序向前移动 ，a[i] 元素被a[i+1]覆盖；\n修改 Last 指针（相当于修改表长）使之仍指向最后一个元素。\n\n\nbool Delete(List L, int i){  /*从 L 中删除指定位序 i 的元素，该元素数组下标为 i-1*/\tPosition j;\t\tif(i &lt; 1 || i &gt; L-&gt;Last + 1)/* 检查空表及删除位序的合法性*/ \t{\t\tprintf(\"位序%d不存在元素\",i);\t\treturn false;\t}     \tfor( j = i; i &lt;= L-&gt;Last; j++)\t\tL-&gt;Data[j-1] = L-&gt;Data[j];/*将位序 i+1 及以后的元素顺序向前移动*/ \tL-&gt;Last--;/*Last 仍指向最后元素*/ \treturn true; }123456789101112131415\n2、链表存储(1）结构体的定义（时间复杂度为O(n)）typedef struct LNode * PtrToLNode;struct LNode{    ElementType Data;    PtrToLNode Next;};typedef PtrToLNode Position; /*这里的位置是结点的地址 */typedef PreToLNode List;12345678\n(2)求表长（时间复杂度为O(n)）\n在顺序存储中求表长是很容易的，直接返回 Last+1 就可以了。但在链式存储中，需要将链表从头到尾遍历一遍\n\n设一个移动指针p和计数器cnt，初始化后，p从表的第 1 个结点开始逐步往后移，同时计数器 cnt+1.\n当后面不再有结点时，cnt 的值就是结点个数，即 表长。\n\n\n\nint Length(List L){//默认该链表是有头结点的   \tPosition p;\tint i=0;  /* 初始化计数器 */        //单向链表的遍历(三部曲)\tp = L-&gt;next; /* p指向表的第 1 个结点 */\twhile(p)\t{ /* 遍历单链表，统计结点数 */ \t\tp=p-&gt;next;  \t\ti++; \t} \treturn i;}1234567891011121314\n(3)判空int ListEmpty(LinkList L){\t//若 L 为空，则返回1，否侧返回 0\tif(L-&gt;Next) //非空        return 0;    else        return 1;}1234567\n(4)查找（时间复杂度为O(n)）\n有两种 按序号查找（FindKth）和 按值查找（Find）\n\n①按序号查找 FindKth（时间复杂度为O(n)）\n对于顺序存储，按序号查找是很直接的事情，要得到第 K 个元素的值，直接取L-&gt;Data[K-1]即可。\n但是对于链式存储则需要采用跟求表长类似的思路：\n\n从链表的第 1 个元素结点起，判断当前结点是否是第 K 个；\n若是，则返回该结点的值，否则继续对比后一个，直到表结束为止。\n如果没有第 K 个结点则返回错误信息。\n\n\n#define ERROR -1 /* 一般定义为表中元素不可能取到的值 */ElementType FindKth(List L, int K) {\t/* 根据指定的位序 K， 返回 L 中相应的元素 */\tPosition P;    int cnt = 1; /* 位序从 1 开始 */\tp = L; /* p 指向 L的第 1 个结点 */\twhile(p &amp;&amp; cnt &lt; K)\t{\t\tp = p-&gt;next;\t\tcnt++\t} \t\tif((cnt == K) &amp;&amp; p)\t\treturn p-&gt;Data;\t/* 返回第 K 个 */\telse\t\treturn ERROR;\t/* 否则返回错误信息 */} 123456789101112131415161718\n②按值查找，即定位 Find（时间复杂度为O(n)）\n基本方法：也是从头到尾遍历，直到找到为止：\n\n从链表的第 1 个元素结点起，判断当前结点的值是否等于 X；\n若是，返回该结点的位置，否则继续对比后一个，直到表结束位置为止；\n找不到时返回错误信息。\n\n\n#define ERROR NULL /*空地址表示错误 */Position Find( List L, ElementType X){    Position p = L;/* p指向 L 的第 1 个元素 */    while(p &amp;&amp; p-&gt;Data != x)    {        p = p-&gt;Next;    }        if(p)     \t return p;    else        return ERROR;}123456789101112131415\n(5)链表的插入（时间复杂度为O(n)）\n\nint  ListInsert_L(LinkList &amp;L, int i,ElementType e){    p = L;    j = 0;    while(p&amp;&amp; j&lt;i-1)    {//寻找第 i-1 个结点        p = p-&gt;next;        ++=j;    }    if(!p || j &gt; i-1)        return ERROR;//    s = (LinkList)malloc(sizeof(LNode));//生成新结点s    s-&gt;data = e;\t\t//将结点s 的数据域的值 更新为 e    s-&gt;next = p-&gt;next;  //将结点s 插入 L 中    p-&gt;next = s;    return OK;}1234567891011121314151617\n(6)创建链表（时间复杂度为O(n)）1、带头结点的【头插法】（时间复杂度为O(n)）\n/* 带头结点的插入创建 */void createListHead( Linklist L, int n ){  \t\t//建立头结点    \tL = (LNode*)malloc(sizeof(struct LNode));    \tL-&gt;Next = NULL;    \t//建立单链表（头插法）    \tLNode *temp = NULL;    \t//申请空间，写入数据    \tfor(int i = 0; i &lt; n; i++)        {            tmp = (LNode*)malloc(sizeof(struct LNode)); /* 申请、填装结点 */            scanf(\"%d\",&amp;tmp-&gt;Data);//输入元素值            //插入到头结点的后面       \t \ttmp-&gt;Next = L-&gt;Next;         \tL-&gt;Next = tmp;\t           }}123456789101112131415161718\n2、带尾结点的插入【尾插法】（时间复杂度为O(n)）/*带尾结点的插入*/void CreateList_L( Listlist &amp;L, int n ){ //正位序数输入 n 个元素的值，建立带表头结点的单链表L    \t//建立头结点   \t    L = (LNode*)malloc(sizeof(struct LNode));   \t\tL-&gt;Next = NULL;    \t//建立单链表（尾插法）   \t \tLNode r = L; //尾指针指向头结点    \t//申请空间，写入数据    \tfor(int i = 0;i &lt; n; i++)        {           \tLNode *tmp = (LNode*)malloc(sizeof(struct LNode)); /* 申请新结点 */            scanf(\"%d\",&amp;tmp-&gt;Data); //输入元素            tmp-&gt;Next = NULL;            //插入到尾结点后面        \tr-&gt;next = temp;         \tr = tmp;\t   //r指向新的尾结点        }}12345678910111213141516171819\n(7)删除（时间复杂度为O(n)）\n\n//将线性表L 中第 i 个数据元素删除int ListDelete_L(LinkList &amp;L, int i, ElementType &amp;e){    p=L;    int j=0;    while(p-&gt;next &amp;&amp; j &lt; i-1)    {//寻找第 i 个结点，并令p指向其前驱        p = p&gt;next;        ++j;    }    if(!(p-&gt;next)||j &lt; i-1)        return ERROR;//删除位置不合理        q = p-&gt;next;\t//临时保存被删除结点的地址以备释放    p-&gt;next = q-&gt;next; //改变被除结点的驱结点的指针域    e = q-&gt;data;\t//保存被删除结点的数据域    free(q);\t\t//释放被删除结点的空间    return OK;}12345678910111213141516171819\n3、二者时间复杂度和优缺点的比较1、两者复杂度比较\n\n\n\n\n查找\n插入\n删除\n\n\n\n\n顺序表\nO(1)\nO(1)\nO(n)通过下标直接找到待操作元素，主要时间花在移动元素上。\n\n\n链表\nO(n)\nO(n)主要时间用于找到插入元素的位置\nO(n)主要时间用于找到待删除元素的位置\n\n\n\n\n2、两者优缺点比较\n\n\n\n数组\n优点\n缺点\n\n\n\n\n\n随机访问性强；查找速度快\n插入和删除效率低；可能浪费内存；内存空间要求高，必须有足够的连续内存空间；数组大小固定，不能动态拓展\n\n\n\n\n\n\n\n\n链表\n优点\n缺点\n\n\n\n\n\n插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活。\n不能随机查找，必须从第一个开始遍历，查找效率低\n\n\n\n\n\n两者的区别在于顺序结构的要求一片连续的存储空间，而链式结构的不要求存储空间连续。\n\n三、栈1、栈的顺序存储实现\n通常由一个一维数组和一个记录栈顶元素位置的变量组成。\n\n(1)顺序栈结构体的定义\n当 Top = -1时，表示栈空；当Top = MaxSize -1 时，栈满！\n\ntypedef int Position;typedef int ElementType;typedef struct SNode *PtrToNode;struct SNode{\tElementType * Data;  /*存储元素的数组*/\tPosition Top;\t\t /*栈顶指针*/\tint MaxSize;\t\t /*堆栈最大容量*/ };typedef PtrToNode Stack;12345678910\n(2)顺序栈的创建Stack CreateStack(int MaxSize) /*顺序栈的创建*/ {\tStack S = (Stack)malloc(sizeof(struct SNode));\tS-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\tS-&gt;Top = -1;\t\t       /*\"-1\"表示空栈  \"MaxSize-1\"表示满栈*/ \tS-&gt;MaxSize = MaxSize;      /*指定栈的最大容量*/ \treturn S;}12345678\n(3)判满bool IsFull(Stack S)\t\t/*判断栈是否满了*/ {\treturn(S-&gt;Top == S-&gt;MaxSize-1);}1234\n(4)判空bool IsEmpty(Stack S)\t/*判断堆栈是否为空*/ {\treturn(S-&gt;Top == -1);}1234\n(5)入栈\n在执行堆栈 Push 操作时，先判断栈是否满；\n\n若不满，Top 加1，并将新元素放入 Data数组的Top位置上\n若满，则返回错误标志\n\n\nbool Push(Stack S, ElementType X)\t/*顺序栈的 入栈 操作*/ { \tif(IsFull(S)) \t{\t\tprintf(\"堆栈满！\");\t\treturn false;\t}\telse\t{\t\tS-&gt;Data[++(S-&gt;Top)] = X;\t/*若是栈不满，则Top加 1,并将新元素放入Data数组的Top位置中*/ \t\treturn true;\t}}12345678910111213\n(6)出栈\n执行Pop操作时，首先判别栈是否为空；\n\n若不为空，返回Data[Top]，同时将Top-1;\n否则要返回错误标志\n\n\nElementType Pop(Stack S) /*顺序栈 的 出栈 操作*/ {\tif(IsEmpty(S))\t\t\t{\t\tprintf(\"堆栈空！\");\t\treturn ERROR;\t\t\t\t\t/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */ \t}\telse\t\treturn(S-&gt;Data[(S-&gt;Top)--]);\t/*若不空，返回Data[Top]，同时将Top减 1*/  }12345678910\n2、栈的顺序存储实现\n链栈与单链表类似，但其操作受限制，插入和删除操作只能在链栈的栈顶进行。\n\n(1)顺序栈结构体的定义typedef struct SNode *PtrToSNode;typedef int ElementType;struct SNode{\tElementType Data;\tPtrToSNode Next;};typedef PtrToSNode Stack;12345678\n(2)顺序栈的创建Stack CreateStack(){\t/*构建一个堆栈的头结点，返回该结点指针*/ \tStack S;\tS = (Stack)malloc(sizeof(struct SNode));\tS-&gt;Next = NULL;\treturn S;}1234567\n(3)判空bool IsEmpty(Stack S){\t/*判断堆栈 S 是否为空，若是返回 true，否则返回 false*/ \treturn(S-&gt;Next == NULL);}1234\n(4)判满 注意：链栈，不必判断堆栈是否满(5)入栈\n链栈，不必判断堆栈是否满\n\nbool Push(Stack S, ElementType X){\t/*将元素 X 压入堆栈 S */ \tPtrToSNode TmpCell;\tTmpCell = (PtrToSNode)malloc(sizeof(struct SNode));\tTmpCell-&gt;Data = X;        //头插法\tTmpCell-&gt;Next = S-&gt;Next;\tS-&gt;Next =TmpCell;\treturn true;}1234567891011\n(6)出栈ElementType Pop(Stack S) ElementType Pop(Stack S){\t/*删除并返回堆栈 S 的栈顶元素*/  \tPtrToSNode FirstCell;\tElementType TopElem;\t\tif(IsEmpty(S))\t{\t\tprintf(\"堆栈空！\");\t\treturn ERROR;\t}\telse\t{\t\tFirstCell = S-&gt;Next;\t\tTopElem = FirstCell-&gt;Data;\t\tS-&gt;Next = FirstCell-&gt;Next;\t\tfree(FirstCell);\t\treturn TopElem;\t\t\t\t\t\t\t\t}}/*顺序栈 的 出栈 操作*/ {\tif(IsEmpty(S))\t\t\t{\t\tprintf(\"堆栈空！\");\t\treturn ERROR;\t\t\t\t\t/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */ \t}\telse\t\treturn(S-&gt;Data[(S-&gt;Top)--]);\t/*若不空，返回Data[Top]，同时将Top减 1*/  }12345678910111213141516171819202122232425262728\n3、栈的应用四、队列1、队列的顺序存储实现(1) 循环队列的结构体定义typedef int Status; typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int *//* 循环队列的顺序存储结构 */typedef struct QNode{\tQElemType data[MAXSIZE];\tint front;    \t/* 头指针 */\tint rear;\t\t/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */}SqQueue;123456789\n(2)生成空队列/* 初始化一个空队列Q */Status CreateQueue(SqQueue *Q){    SqQueue *Q = (SqQueue)malloc(sizeof(struct QNode));    Q-&gt;data = (ElementType*)malloc(MaxSize * sizeof(ElementType));\tQ-&gt;front = Q-&gt;rear = 0;\treturn  OK;}12345678\n(3)判空\n队空的条件是：rear=front\n\nbool IsEmpty(SqQueue *Q){    return(Q-&gt;front == Q-&gt;rear);}1234\n(4)判满\n队满的条件是：(rear+1)%数组的长度等于 front\n\nbool IsFull(SqQueue *Q){    return((Q-&gt;rear+1)% MaxSize == Q-&gt;front);}1234\n(5)入队/* 若队列未满，则插入元素e为Q新的队尾元素 */Status EnQueue(SqQueue *Q,QElemType e){\tif ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)\t/* 队列满的判断 */\t\treturn ERROR;\tQ-&gt;data[Q-&gt;rear]=e;\t\t\t/* 将元素e赋值给队尾 */\tQ-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */\t\t\t\t\t\t\t\t/* 若到最后则转到数组头部 */\treturn  OK;}12345678910\n(6)出队/* 若队列不空，则删除Q中队头元素，用e返回其值 */Status DeQueue(SqQueue *Q,QElemType *e){\tif (Q-&gt;front == Q-&gt;rear)\t\t\t/* 队列空的判断 */\t\treturn ERROR;\t*e=Q-&gt;data[Q-&gt;front];\t\t\t\t/* 将队头元素赋值给e */\tQ-&gt;front=(Q-&gt;front+1)%MAXSIZE;\t/* front指针向后移一位置， */\t\t\t\t\t\t\t\t\t/* 若到最后则转到数组头部 */\treturn  OK;}12345678910\n2、队列的链式存储实现\n队列与堆栈一样，也可以采用链式存储结构，但队列的头（front）必须指向链表的头结点，队列的尾（rear）指向链表的尾结点。\n\n(1)队列的链式存储结构体定义typedef int Status; typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */typedef struct QNode\t/* 结点结构 */{   QElemType data;   struct QNode *next;}QNode,*QueuePtr;typedef struct\t\t\t/* 队列的链表结构 */{   QueuePtr front,rear; /* 队头、队尾指针 */}LinkQueue;123456789101112\n(2)生成空队列/* 构造一个空队列Q */Status InitQueue(LinkQueue *Q){ \tQ-&gt;front=Q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));\tif(!Q-&gt;front)\t\texit(OVERFLOW);\tQ-&gt;front-&gt;next=NULL;\treturn OK;}123456789\n(3)判空\n队空的条件是：rear=front\n\nStatus QueueEmpty(LinkQueue Q){ \tif(Q.front==Q.rear)\t\treturn TRUE;\telse\t\treturn FALSE;}1234567\n(4)判满 链式队列，不必判断堆栈是否满(5)入队/* 插入元素e为Q的新的队尾元素 */Status EnQueue(LinkQueue *Q,QElemType e){ \tQueuePtr s=(QueuePtr)malloc(sizeof(QNode));\tif(!s) /* 存储分配失败 */\t\texit(OVERFLOW);\ts-&gt;data=e;\ts-&gt;next=NULL;\tQ-&gt;rear-&gt;next=s;\t/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */\tQ-&gt;rear=s;\t\t/* 把当前的s设置为队尾结点，rear指向s，见图中② */\treturn OK;}123456789101112\n(6)出队/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */Status DeQueue(LinkQueue *Q,QElemType *e){\tQueuePtr p;\tif(Q-&gt;front==Q-&gt;rear)\t\treturn ERROR;\tp=Q-&gt;front-&gt;next;\t\t/* 将欲删除的队头结点暂存给p，见图中① */\t*e=p-&gt;data;\t\t\t\t/* 将欲删除的队头结点的值赋值给e */\tQ-&gt;front-&gt;next=p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */\tif(Q-&gt;rear==p)\t\t/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */\t\tQ-&gt;rear=Q-&gt;front;\tfree(p);\treturn OK;}1234567891011121314\n五、栈和队列操作的特点\n\n\n\n\n相同点\n不同点\n\n\n\n\n堆栈(FILO)\n只允许在端点处插入和删除元素；\n栈是先进后出或者后进先出；栈是只能在表的一端进行插入和删除操作的线性表\n\n\n队列(FIFO)\n只允许在端点处插入和删除元素；\n队列是先进先出；队列是只能在表的一端进行插入，然后在另外一端进行删除操作的线性表\n\n\n\n\n六、数组存储地址的计算\n\n\n\n数组类型\n存储地址的计算（a是数组首地址，len是每个数组元素所占长度）\n\n\n\n\n一维数组\na[i]的存储地址：a+i*len\n\n\n二维数组:a[m] [n]\n按行存储：a+(i  n+j)  len；按列存储：a+(j  m+i)  len\n\n\n\n\n\n例子：数组存储地址的计算示例：1）已知一维数组a中每个元素占用2个字节，求a[10]的存储地址？答：a[10]的存储地址为：a+102=a+202）已知二维数组a[4][5]中, 每个元素占用2个字节，求元素a[3][2]按行为主序存储的存储地址和按列为主序存储的存储地址？答： 按行存储：a+(35+2) 2 = a+34按列存储：a+(24+3) *2 = a+22\n\n———————树———————一、二叉树1、定义\n二叉树是每个节点最多有两个子树的树结构。\n它有五种基本形态:\n\n二叉树可以是空集;\n根可以有空的左子树或右子树；\n或者左、右子树皆为空。\n\n\n\n2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度a.结点、叶子、树的度\n\n结点的度：结点拥有的子树的数目。\n叶子：度为零的结点。\n树的度：树中结点的最大的度\n\n\nb.孩子、双亲、兄弟、子孙、祖先\n\n双亲：若一个结点有子树，该结点称为子树根的”双亲”。\n孩子：子树的根是该结点的”孩子”。\n兄弟：有相同双亲的结点互为”兄弟”。\n子孙：一个结点的所有子树上的任何结点都是该结点的子孙。\n祖先：从根结点到某个结点的路径上的所有结点都是该结点的祖先。\n\n\nc.无序树、有序树、森林\n\n无序树：如果树中结点的各子树之间的次序是无次序的，可以交换位置。\n有序树：如果树中结点的各子树之间的次序是有次序的, 不可以交换位置。\n森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。\n\n\nd.层次、高度\n层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。树的深度和高度：二叉树中节点的最大层次称为二叉树的深度或高度。\n\n2、性质\n性质1：二叉树第 i 层上最多为 2^(i-1) (i≥1)个结点。\n性质2：深度为k的二叉树至多有2^k - 1个结点(k≥1)。\n性质3：具有n个结点的【完全二叉树】的高度k为(log&lt;2&gt;n) +1）（[log2n]表示不大于与其的整数）\n性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。\n性质5：如果对一棵有 n个结点的完全二叉树（其深度为(log&lt;2&gt;n) +1）的结点按 【层序】编号（从第1层到第(log&lt;2&gt;n) +1） 层，每层从左到右），对任一结点 i （1≤ i ≤ n）有：\n\n如果 i = 1，则结点 i是二叉树的根，无双亲；如果 i ＞ 1，则其双亲是结点 [i/2];\n如果2i ＞n，则结点 i 无左孩子（即结点 i 为叶子结点）；否则其左孩子是结点 2i；\n如果 2i+1 ＞n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。\n\n\n3、满二叉树、完全二叉树和二叉排序树a.满二叉树\n定义：高度为h，并且由2{h} –1个结点的二叉树，被称为满二叉树。\n\n\nb.完全二叉树\n定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。\n特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。\n\n\nc.二叉查找树\n定义：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。左小右大，任意结点的左、右子树也是二叉查找树\n\n\n\n在二叉查找树中：(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；(03) 任意节点的左、右子树也分别为二叉查找树。(04) 没有键值相等的节点（no duplicate nodes）。\n\n二、静态查找1、顺序存储结构\n指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标i－1的分量中。\n\n2、顺序查找\n从表的一端开始，逐个将记录的关键字和给定值比较，若找到一个记录的关键字与给定值相等，则查找成功；若整个表中记录均比较过，仍未找到关键字等于给定值的记录，则查找失败。\n\n缺点：查找表的长度越长，查找效率越低。\n优点：简单、适应面广，对查找表结构没有要求，对顺序存储和链式存储都适用。\n3、二分查找（也称“折半查找”，是一棵“二叉排序树”）\n设查找表元素存储在一维数组r[1,…,n]中，在表中的元素已经按关键字递增方式排序的情况下，\n进行[折半查找]的方法是：首先将待查元素的关键字（key）值与表r中间位置上（下标为mid）记录的关键字关键字进行比较，\n\n若相等，则查找成功；\n若key&gt;r[mid].key,则说明待查记录只可能在后半个子表r[mid+1,…,n]中；\n若key&lt;r[mid].key，则说明待查记录只可能在前半个子表r[1,…,mid-1]中；\n\n这样逐步缩小范围，直到查找成功或子表为空时失败为止。\n\n注意：每次缩小范围后，改变的下标是哪个\n//递增的方式排序，则折半查找的算法为//在数组r[low...high],在数组r中找值为key的元素int Bsearch(int r[],int low,int high,int key){    int mid;    while(low &lt;= high)    {        mid = (low + high)/2;        if(key == r[mid])            return mid;        else if(key &lt; r[mid])            high = mid-1;        else            low = mid+1;    }    return -1;} //折半查找，递归算法int Bsearch_rec(int r[],int low,int high,int key){    int mid;    if(low &lt;= high)    {        mid = (low + high)/2;        if(key == r[mid])            return mid;        else if(key &lt; r[mid])            return Bsearch_rec(r,low,mid-1,key);        else            return Bsearch_rec(r,mid+1,high,key);    }    return -1;}12345678910111213141516171819202122232425262728293031323334\n\n折半查找的过程可以用一颗二叉树来描述，以当前查找区域间的中间位置序号作为根，左半个子表和右半个子表中的记录序号分别分别作为根的左子树和右子树上的结点，这样构造的二叉树称为折半查找判定树，从树上可以看出：\n 查找成功时，折半查找的过程恰好走了一条从根结点到被查找结点的路径，与关键字进行比较的次数即为被查找结点在树中的层数。因此，折半查找判定树在查找成功时进行比较的关键字个数最多不超过树的深度，而具有n个结点的判定树的深度为；所以折半查找在查找成功时和给定值进行比较的关键字个数最多为。\n优点：查找效率更高，但它要求查找表进行顺序存储并按关键字进行排序。缺点：对表进行插入或删除时，需要移动大量元素。适用：表不易变动，且又经常进行查找的情况\n4、二分查找判定树ASL计算\n折半查找的过程看，可用二叉树来描述，二叉树中的每个结点对应有序表中的一个记录，结点中的值为该记录在表中的位置。通常称这个描述折半查找二叉树的过程称为折半查找判定树。\n\n例如：顺序存储的序列{1,2,3,4,5,6,7,8,9,10} 来构建二叉判定树，计算其ASL\n\n例如：长度为10的折半查找判定树的具体生成过程：\t都遵循这个规律，左孩子结点&lt;根结点&lt;右孩子结点 【左小右大】    （1）在长度为10的有序表中进行折半查找，不论查找哪个记录，都必须和中间记录进行比较，而中间记录为（1+10）/2 =5  (注意要取整)   即判定数的的根结点为5，如图7-2（a）所示。     （2）考虑判定树的左子树，即将查找区域调整到左半区，此时的查找区间为[1,4],那么中间值为（1+4）/2 =2 (注意要取整) ，所以做孩子根结点为2,如图7-2（b）所示。     （3）考虑判定树的右子树，即将查找区域调整到右半区，此时的查找区间为[6,10],那么中间值为（6+10）/2 =8 (注意要取整) ，所以做孩子根结点为8,如图7-2（c）所示。       (4)重复以上步骤，依次去确定左右孩子、123456789101112\n特点：\n\n1.折半查找是一棵二叉排序树，每个根结点的值都大于左子树的所有结点的值，小于右子树所有结点的值。\n2.折半查找判定数中的结点都是查找成功的情况，将每个结点的空指针指向一个实际上不存在的结点————外结点，所有外界点都是查找不成功的情况，如图7-2（e）所示。如果有序表的长度为n,则外结点一定有n+1个。\n\n（1）查找成功的ASL\n折半查找判定数中，某结点所在的层数就是即将要比较的次数，整个判定树代表的有序表的平均查找长度即为查找每个结点的比较次数之和除以有序表的 长度。\n\nASL成功 = 每层结点所在高度×每层结点数 之和 除以 总结点数\n 例如：长度为10的有序表的平均查找长度为\tASL=(1×1+2×2+3×4+4×3)/10=29/10;123\n（2）查找不成功的ASL\n折半查找判定数中，查找不成功的次数即为查找相应外结点(定义在上方）与内结点的比较次数。整个判定树代表的有序表的平均查找长度。查找失败时的有序表的平均查找长度即为查找每个外结点的比较次数之和除以外结点的个数。\n\nASL失败 = （每层【补上的】结点所在高度-1）×每层【补上的】结点数 之和 除以 【补上的】总结点数\n例如：查找失败时，长度为10的有序表的平均查找长度为：\tASL=(3×5+4×6)/11=39/11;123\n三、动态查找1、二叉树链表结构描述如下：typedef struct TNode *Position;typedef Position BinTree; /* 二叉树类型 */struct TNode{/*树结点定义 */    ElementType Data; /* 结点数据*/    BinTree Left; /*指向左子树*/    BinTree Right;/*指向右子树*/};12345678\n二叉链表至少包含3个域：数据域 data、左指针域 lchild和右指针域 rchild\n指针域： n个结点有2n个指针域。\n空指针域：n 个结点的二叉链表中含有 n+1 个空指针域。\n\n2、二叉搜索（排序、查找）树的构造过程(1)构造过程\n构造二叉排序树的过程，就是从空二叉树开始，逐个向树中插入节点的过程。\n设记录的关键码序列为：63,90,70,55,67,42,98,83,10,45,58\n\n\n(2)插入过程算法及其代码\n设待插入节点关键码值为 X ：\n（1）先在树中查找值为 X 的节点，若查找成功，说明节点已存在，无需插入；\n（2）若查找失败，说明节点不存在，则将其插入到树中\n因此，新插入节点一定是作为叶子节点插入的。\n\nBinTree Insert(Bintree BST, ElmentType X){    if(!BST)    {/*若原来树为空，生成并返回一个结点的二叉搜索树*/        BST = (BinTree)malloc(sizeof(struct TNode));        BST-&gt;Data = X;        BST-&gt;Left = BST-&gt;Right = NULL;    }    else    {/*开始查找插入元素的位置*/        if(X &lt; BST-&gt;Data)            BST-&gt;Left = Insert(BST-&gt;Left, X);/*递归插入左子树*/        else if(X &gt; BST-&gt;Data)            BST-&gt;Right = Insert(BST-&gt;Right, X);/*递归插入右子树*/    }    return BST;}1234567891011121314151617\n(2)删除过程算法及其代码\n二叉搜索树的删除操作比其它操作更为复杂，要删除结点在树中的位置决定了操作所采用的策略。\n\na.若要删除的结点是叶子结点\n 可以直接删除，然后再修改其父结点的指针。\n\nb.若要删除的结点只有一个孩子结点（该结点不一定是叶结点，可以是子树的根）\n 删除之前需要改变父结点的指针，指向要删除结点的孩子结点。\nc.若要删除的结点有左、右两棵子树，有两种选择：\n 基本原则：保持二叉搜索树的有序性\n 1、取其右子树中的最小元素；\n 2、取其左子树中的最大元素。\n\n(3)查找过程算法及其代码\nBST树的查找思想:\n首先将给定的K值与二叉排序树的根节点的关键字进行比较：\n\n若相等，则查找成功；\n若给定的K值小于BST树的根节点的关键字：继续在该节点的左子树上进行查找；\n若给定的K值大于BST树的根节点的关键字：继续在该节点的右子树上进行查找。\n\n\na.二叉搜索树的递归查找函数\n在二叉排序树上进行查找，则是从根结点出发走了一条从根到待查结点的路径；\n若查找不成功，则是从根结点出发走了一条从跟到某一叶结点的路径。\n\nPosition Find(BinTree BST,ElementType X){    if(!BST-&gt;Data)        return NULL;/* 查找失败 */    if(X &gt; BST-&gt;Data)        return Find(BST-&gt;Right, X);/* 在 右子树 中递归查找 */    else if(X &lt; BST-&gt;Data)        return Find(BST-&gt;Left, X);/* 在 左子树 中递归查找 */    else        return BST;/* 在当前结点查找成功，返回当前结点的地址*/}1234567891011\nb.迭代查找算法\n由于非递归函数的执行效率高，一般采用非递归的迭代来实现查找。很容易将递归函数改为迭代函数\nwhile循环 代替 Find递归调用即可\n\nPosition Find(BinTree BST,ElementType X){    while(BST)    {        if(X &gt; BST-&gt;Data)            BST = BST-&gt;Right;/* 向 右子树 中移动，继续查找 */        else if(X &lt; BST-&gt;Data)            BST = BST-&gt;Left; /* 向 右子树 中移动，继续查找 */        else /* X == BST-&gt;Data;*/            break;/* 在当前结点查找成功，跳出循环 */    }     return BST;/* 返回找到的结点地址，或是NULL */}12345678910111213\n(4)查找最大值和最小值\n根据二叉搜索树的性质，最小元素一定是在树的最左分支的端点上。最左分支的端点：最左分支上无左孩子的结点。\n最大元素一定在最右分支的端结点上。\n\n从根结点开始，当其不为空时，沿左分支或者右分支逐个判断各结点的指针，直到遇到空指针为止。\n当左分支逐层推下来查找到的是最小元素。\n反之，当右分支逐层推下来查找到的是最大元素。\n\n\n\na.最小元素的递归函数Position FindMin(BinTree BST){ /* 最小元素在最左端点 */    if(!BST)        return NULL;/* 空的二叉搜素树，返回NULL */    else if(!BST-&gt;Left)        return BST;\t/* 找到最左端点并返回 */    else        return FindMin(BST-&gt;Left); /*沿左分支递归查找 */}123456789\nb.查找最大元素的迭代函数Position FindMax(BinTree BST){    if(BST)        while(BST-&gt;Right);    \t\tBST = BST-&gt;Right; /*沿右分支一直向下，直到最右端点 */    return BST;}1234567\n四、二叉树的遍历\n指按照某种次序访问二叉树的所有结点，并且每个结点仅访问一次，得到一个线性序列。\n\n1、先序遍历\n（1）访问根结点（2）先序遍历左子树（3）先序遍历右子树\n-中序、后序遍历相似\n\n\n\n先序遍历：A → B → D → C中序遍历：B → D → A → C后续遍历：D → B → C → A层序遍历：A → B → C → D\n\nvoid PreOrderTraverse(BiTree T)    //链式二叉树先序遍历递归算法{\tif (T != NULL)\t{\t\tprintf_s(\"%d \", T-&gt;data);    //访问根结点\t\tPreOrderTraverse(T-&gt;lchild);    //先序遍历左子树\t\tPreOrderTraverse(T-&gt;rchild);    //先序遍历右子树\t}}//链式二叉树中序遍历递归算法void InOrderTraverse(BiTree T) {\tif (T != NULL) {\t\tInOrderTraverse(T-&gt;lchild);\t\tprintf_s(\"%d \", T-&gt;data);\t\tInOrderTraverse(T-&gt;rchild);\t}}//链式二叉树后序遍历递归算法void PostOrderTraverse(BiTree T) {\tif (T != NULL) {\t\tPostOrderTraverse(T-&gt;lchild);\t\tPostOrderTraverse(T-&gt;rchild);\t\tprintf_s(\"%d \", T-&gt;data);\t}}123456789101112131415161718192021222324252627282930\n2、层序遍历(队列实现）\n仔细看看层序遍历过程，其实就是从上到下，从左到右依次将每个数放入到队列中，然后按顺序依次打印就是想要的结果。\n实现过程\n\n从队列中取出一个元素；\n访问该元素所指结点；\n若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。\n\n不断执行这三步操作，直到队列为空，再无元素可取，二叉树的程序遍历就完成了。\n\nvoid LevelorDerTraversal(BinTree BT){    Queue Q;    BinTree T;        if(!BT)        return;/* 若是空树则直接返回 */        Q = CreatQueue();\t/* 创建空队列 */    AddQ(Q, BT);    while(!IsEmpty(Q))    {        T = DeteleQ(Q);        printf(\"%d\",T-&gt;Data); /* 访问取出队列的结点 */        if(T-&gt;Left)            AddQ(Q, T-&gt;Left);        if(T-&gt;Right)            AddQ(Q, T-&gt;Right);    }}1234567891011121314151617181920\n3、由遍历序列还原二叉树\n已知先序遍历和中序遍历，可以还原二叉树；已知中序遍历和后序遍历，可以还原二叉树；已知先序遍历和后序遍历，不可以还原二叉树.\n\na.已知先序遍历和中序遍历还原二叉树\n\n算法思路：1、根据先序遍历结果确定根节点。先序遍历的第一个节点为根节点。2、 在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。3、 将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。\n\n例如：已知先序遍历的结果为：ABDHIEJKCFLMGNO,中序遍历的结果为：HDIBJEKALFMCNGO\n则二叉树为以下结构：\n\n其后序遍历结果为：HIDJKEBLMFNOGCA\nb.已知后序遍历和中序遍历还原二叉树\n算法思路：1、根据后序遍历结果确定根节点。后序遍历的最后一个节点为根节点。2、在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。3、将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。\n\n例如：已知后序遍历的结果为：HIDJKEBLMFNOGCA,中序遍历的结果为：HDIBJEKALFMCNGO\n则二叉树为以下结构：\n\n其先序遍历结果为：ABDHIEJKCFLMGNO\n五、递归遍历算法的应用1、求二叉树的深度//求树的深度int TreeDeep(BiTree T) {    int deep = 0;    if (T != NULL)     {        int leftDeep = TreeDeep(T-&gt;lchild);        int rightDeep = TreeDeep(T-&gt;rchild);        deep = leftDeep &gt;= rightDeep ? leftDeep + 1 : rightDeep + 1;    }    return deep;}123456789101112\n2、求二叉树的叶子树//求叶子树int LeafCount(BinTree T,int num){    if(T)    {        if(!T-&gt;Left &amp;&amp; !T-&gt;Right)        {            nm++;        }        TreeDeep(T-&gt;lchild, num);        TreeDeep(T-&gt;rchild, num);    }    return num; }1234567891011121314\n3、交互（换）左、右子树void Swap(BiTree *&amp;right,BiTree *&amp;left){\tBiTree *temp=right;\tright=left;\tleft=temp;}void SwapSubtrees(BiTree *T){\tif(!T)\t\treturn ;\tSwapSubtrees(T-&gt;rchild);\tSwapSubtrees(T-&gt;lchild);\tSwap(T-&gt;rchild,T-&gt;lchild);}123456789101112131415\n六、静态查找和动态查找的根本区别\n上述基于二叉排序树的动态查找，它的基本原理和基于线性表的静态二分查找很相似，都是利用有序性不断缩小查找空间。\n而之所以有静态和动态之分，主要是为了适应不同的应用需求。\n\n\n\n\n\n\n适合用于\n\n\n\n\n静态查找\n数据一旦建立好，不需要或者很少进行 删除 和 插入 操作\n\n\n动态查找\n频繁的数据变化，插入 和 删除 是基本操作\n\n\n\n\n七、树/森林与二叉树的转换1、树、森林与二叉树的转换由于二叉树是有序的，为了避免混淆，对于无序树，我们约定树中的每个结点的孩子结点按从左到右的顺序进行编号。\n\n将树转换成二叉树的步骤是：（1）加线。就是在所有兄弟结点之间加一条连线；（2）抹线。就是对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；（3）旋转。就是以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。\n\n2、森林转换为二叉树森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。\n\n将森林转换为二叉树的步骤是：（1）先把每棵树转换为二叉树；（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。\n\n\n3、二叉树转换为树\n二叉树转换为树是树转换为二叉树的逆过程，其步骤是：（1）若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；（2）删除原二叉树中所有结点与其右孩子结点的连线；（3）整理（1）和（2）两步得到的树，使之结构层次分明。\n\n4、二叉树转换为森林\n二叉树转换为森林比较简单，其步骤如下：（1）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；（2）把分离后的每棵二叉树转换为树；（3）整理第（2）步得到的树，使之规范，这样得到森林。\n\n5、转换以后的特点： (1、 根据树与二叉树的转换关系以及二叉树的遍历定义可以推知：\n\n树的先序遍历与其转换的相应的二叉树的先序遍历的结果序列相同；\n树的后序遍历与其转换的二叉树的中序遍历的结果序列相同；\n树的层序遍历与其转换的二叉树的后序遍历的结果序列相同。\n\n（2、 由森林与二叉树的转换关系以及森林与二叉树的遍历定义可知：\n 森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同。\n八、线索二叉树\n传统的二叉链表仅能体现出一种父子关系，不能直接得到结点在遍历中的前驱或后继。引入【线索二叉树】正是为了加快查找结点前驱和后继的速度。（1、定义：\n\n前驱与后继：在二叉树的先序、中序或后序遍历序列中的两个相邻的结点；\n线索：指向前驱或后继的结点的指针；\n线索二叉树：加上线索的二叉链表的二叉树；\n线索化：对二叉树按某个遍历次序使其变为线索二叉树的过程。\n\n（2、规定：【口诀：左前右后，0孩1前后】\n\n若无左子树，令lchild指向其前驱结点；\n若无右子树，令rchild执行指向其后继结点\n增加两个标志域标识是指左/右孩子还是指向前驱/后继。\n\n\n1、存储结构//线索二叉树存储结构typedef struct ThreadNode{\tchar data;\tstruct ThreadNode *lchild, *rchild;\t// 左右孩子指针\tint ltag, rtag;\t// 左右线索标志}ThreadNode, *ThreadTree;123456\n\n2、如何判断是孩子还是线索其标志位含义如下： 【口诀：左前右后，0孩1前后】\n\n\n这种加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。\n根据线索性质的不同， 线索二叉树可分为前序线索二叉树、 中序线索二叉树和后序线索二叉树三种。\n\n3、三种遍历\n因为线索化后， 各个结点指向有变化， 因此原来的遍历方式不能使用， 需要使用新的方式遍历线索化二叉树。\n中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。\n在对其遍历时，需要找到第一个具有前驱结点的左结点，然后依次找结点的后继。\n在中序线索二叉树中找结点后继的规律是:\n\n若其右标志为1，则右链为线索，指示其后继;\n否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。\n\n\nvoid InOrderTraverse(BiThrTree T){ // 中序输出    if(T)    {        InOrderTraverse(T-&gt;lchild); //中序遍历左子树        cout&lt;&lt; T-&gt;data;        InOrderTraverse(T-&gt;rchild); //中序遍历右子树    }}12345678\n九、哈夫曼树1、带权路径长度WPL\n2、哈夫曼树的构造（算法）\n构造 Huffman 树的基本思想：权值大的结点用短路径，权值小的结点用长路径。\n\n\n\n构造过程\n\n\n\n3、哈夫曼树的性质\n4、哈夫曼编码\n\n———散列查找———一、散列查找1、基本概念\n散列函数\n在进行查找时，在记录的存储位置与它的关键字之间建立一个确定的对应关系h,以线性表中每个元素的关键字K为自变量，通过函数h(K)计算出该元素的存储位置，我们将h函数称为散列函数或哈希函数。h(K)的值称为散列地址或哈希地址。\n\n冲突\n在实际应用中，通常可能出现一个待插入元素的散列地址单元已被占用情况，使得该元素无法直接存入此单元，这种情况称为冲突。\n\n同义词\n 具有不同关键字而具有相同散列地址的元素称为同义词，即key1≠key2，但h(key1)=h(key2)。由同义词引起的冲突称作同义词冲突。\n\n装填因子(α)\n指散列表中已存入的元素数n与散列表空间大小m的比值,即：α=n/m。当α越小时，冲突可能性就越小，但同时，存储空间利用率就越低。\n\n\n散列表：根据设定的哈希函数及处理冲突的方法将一组关键字映象到一个有限的连续的地址集上，即把记录存放在表中映象的位置上，这种表便称为散列表(哈希表)。\n\n一个散列表的好坏与三个因素有关：1.装填因子 2、所采用的散列函数 3、解决冲突的方法\n\n\n假定一个线性表为A=(18,75,60,43,54,90,46)，选取散列函数为：h(K)=K%m 取m=13则得每个元素散列地址：h(18)=18 % 13=5h(75)=75 % 13=10h(60)=60 % 13=8h(43)=43 % 13=4h(54)=54 % 13=2h(90)=90 % 13=12h(46)=46 % 13=7根据散列地址，实现元素的存储映象H[m]：\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n\nH\n\n\n54\n\n43\n18\n\n46\n60\n\n75\n\n90\n\n\n\n\n例：如向下表中再插入元素70时，70%13=5，则出现了冲突\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\nH\n\n\n54\n\n43\n18\n\n46\n60\n\n75\n\n90\n\n\n\n\n\n2、散列函数[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OtlYI1uv-1641217649135)(myReviewPicture/散列函数.png)]\n 构造散列函数的目标是使散列地址尽可能均匀分布在散列空间上，同时使计算尽可能简单，以节省计算时间。1\n（1、关键词为数字时：a.直接定址法\nb.除留余数法(常用)\nc.数字分析法分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址，如电话号码、身份证号码某几位会比较随机；1\n\n例：有一组关键字如下：\n 92326875\n 92739628\n 92343634\n 92706816\n 92774638\n 92381262\n 92394220\n通过分析：每个关键字从左到右第1、2、3位和第6位取值较集中，不宜作散列地址，其余的第4、5、7、8位取值分散，可以选择，若取最后两位作散列地址，得：(2,75,28,34,16,38,62,20)\n\nd.平方取中法key取平方再取中间几位1\n（2、关键词为字符时：a、ASCII码加和法h(key)=(求和key[i])mod TableSize1\nb、前3个字符移位法h(key)=(key[0]*27*27+key[1]*27+key[2])mod TableSize1\n二、处理冲突的方法1、开放定址法\na.线性探测法\n\n\n注意：查找某个值时，用散列函数计算完后，如果那个结果位置上的数字与关键词不一样时，并不能断定关键词不存在，还应该按照冲突解决策略继续找，直到找到空位置了还没找到，才能断定该关键词不存在。\nb、平方探测（二次探测）\n\n举例：h(key)=key mod 11;\n\n\n\n注意：取素数是为了减少公因子（减少冲突）\n\nc.在散列法\n2、分离链接法\n\n———————————————图————————————————一、图的基本概念\n集合只有同属于一个集合；线性结构存在一对一的关系；树形结构存在一对多的关系；图状结构存在多对多的关系。\n\n\n\n1、简单图\n简单图满足以下两条内容：\n1）不存在重复边\n2）不存在顶点到自身的边\n\n2、完全图\n任意两顶点之间都存在边\n\n3、连通分量\n在无向图中，两顶点有路径存在，就称为连通的。若图中任意两顶点都连通，同此图为连通图。无向图中的极大连通子图称为连通分量。\n\n4、强连通分量\n在有向图中，两顶点两个方向都有路径，两顶点称为强连通。\n若任一顶点都是强连通的，称为强连通图。有向图中极大强连通子图为有向图的强连通分量。\n\n5.顶点的度、入度和出度\n顶点的度为以该顶点为一个端点的边的数目。\n对于无向图，顶点的边数为度，度数之和是顶点边数的 2 倍。\n对于有向图，入度是以顶点为终点，出度相反。有向图的全部顶点入度之和等于出度之和且等于边数。顶点的度等于入度与出度之和\n\n注意：入度与出度是针对有向图来说的\n二、图的存储1、数组（邻接矩阵）表示法\n建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）。\n\n设图A=（V，E）有n个顶点，则\n\n\n图的邻接矩阵是一个二位数组A.arcs[n] [n]，定义为：\n\n\nåœ¨è¿™é‡Œæ’å¥å›¾ç‰‡æè¿°\na.无向图的邻接矩阵表示法\n分析1：无向图的邻接矩阵是对称的；分析2：顶点i的度=第i行（列）中1的个数；特别：完全图的邻接矩阵中，对角元素为0，其余1。\n\n\nb.有向图的邻接矩阵表示法\n注：在有向图的邻接矩阵中，第 i 行含义：以结点vi为尾的弧（即出度边）第 i 列含义：以结点vi为头的弧（即入度边）分析1：有向图的邻接矩阵可能是不对称的；分析2：顶点的出度 = 第 i 行元素之和顶点的入度 = 第 i 列元素之和顶点的度 = 第 i 行元素之和 + 第 i 列元素之和\n\n\nc.有权图（网）的邻接矩阵表示法\n\n2.邻接表（顺序存储与链式存储结合）![\na.无向图的邻接表\nb.有向图的邻接表与逆邻接表\nc.带权值的网图\n三、图的遍历1、深度优先遍历算法\n深度优先搜索类似于树的先序遍历。\n其基本思想是：\n\n首先访问起始顶点v，然后由v出发，访问与v 邻接且未被访问的任一顶点w1，再访问与w1 邻接且未被访问的任一顶点W2……重复上述操作。\n当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。\n\n\n\n\n从顶点a 出发，进行深度优先遍历，可以得到的一种顶点序列为：a e d f c b\n\n2、广度优先遍历算法\n广度优先搜索类似于二叉树的层序遍历算法。\n其基本思想是：\n\n首先访问起始顶点v，接着由ν出发，依次访问v 的各个未访问过的邻接顶点W1，W2，…，Wi，然后依次访问W1，W2，…，Wi的所有未被访问过的邻接顶点；\n再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中的所有顶点都被访问过为止。\n若此时图中尚有顶点未被访问，则另选图中的一个未被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。\n\n\n\n\n从顶点1 出发，按照广度优先规则遍历，可以得到的一种顶点序列是： 1234576\n\n二、最小生成树1、性质\n2、Prim算法\n\n\n3、Kruskal算法\n三、拓扑排序\n\n四、最短路径迪杰斯特拉算法\n通过迪杰斯特拉算法计算图G中的最短路径时，需要指定起点s。\n 此外，需要引进两个集合S和U。\n\nS的作用：记录已求出最短路径的顶点（以及相应的最短路径长度），\nU的作用：记录还未求出最短路径的顶点（以及该顶点到起点s的距离）。\n初始时，S中只有起点s；\nU中是除s之外的顶点，并且U中顶点的路径是“起点s到该顶点的路径”。\n然后，从U中找到路径最短的顶点，并将其加入到S中；\n接着，更新U中的顶点和顶点对应的路径。\n然后，再从U中找到路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。\n重复上述操作，直到遍历完所有顶点。\n\n\n\n\n具体过程1、初始化，所有顶点的距离初始化为无穷大（INFINITY)\n\n2、选定点A，更新（A-A距离设为0)\n\n3、S集合为{A,B}，考察B的所有邻接点\n\n为什么选定B加入集合S？因为不可能还有其他路径比2还短，我不管经过C到B还是D到B都不可能是路径小于2，所以我们得到了A-&gt;B的最短路径\n\n\n\n做完这一步，下一步加入集合S的是D因为目前A-&gt;D的路径长度最短，为3（我已经知道了A直接到D和A经过B到D的路径长度）如果A-&gt;B-&gt;X-&gt;D小于min{A-&gt;D,A-&gt;B-&gt;D},那么A-&gt;B-&gt;X小于min{A-&gt;D,A-&gt;B-&gt;D}，那么加入集合的应该是X，这是矛盾的（接下来的操作都是一样的道理\n\n4、S集合为{A,B,D}，在U中没有D的邻接点，不操作\n5、S集合为{A,B,D,C}，在U中没有C的邻接点，不操作\n6、S集合为{A,B,D,C,F}，更新\n\n7、S集合为{A,B,D,C,F,E}，在U中没有E的邻接点，不操作\n8、S集合为{A,B,D,C,F,E,G}，在U中没有G的邻接点，不操作\n9、最终结果如上图。\n———排序———一、排序的类别\n1、插入排序基本思想：\n【1】直接插入排序（1、基本思想：\n1）、将待排序的一组序列（有N个数）分为已排好的和未排好的 2个部分；\n2）、初始状态时，已排序序列仅包含第1 个元素，未排序序列中的元素为除去第1 个元素意外的N-1 个元素；\n3）、此后，将未排序序列中的元素逐一插入到已排序的序列中；\n4）、如此往复，经过N-1 次插入后，未排序序列中元素个数为0 ，则排序完成。\n\n（2、执行过程\n\n（3、时空效率及稳定性\n【2】希尔排序（1、基本思想：\n1）、将带排序序列的一组元素按一定间隔分为若干序列分别进行插入排序；\n2）、开始时设置的“间隔”较大，在每轮排序中，将”间隔“逐步缩小\n3）、直到“间隔”为 1，也就到了最后一步，做简单插入排序。\n\n（2、执行过程\n（3、时空效率及稳定性\n2、交换排序基本思想：\n【1】冒泡排序（1、基本思想：\n（2、执行过程\n（3、时空效率及稳定性\n【2】快速排序（1、基本思想：\n1)、将未排序元素根据一个作为基准的“主元（pivot）分为两个子序列；\n2）、其中一个子序列的记录均大于“主元”，另一个序列则均小于“主元；\n3）、递归地对两个子序列用类似的方法进行排序。\n\n（2、执行过程\n\n\n（3、时空效率及稳定性\n3、选择排序基本思想：\n【1】简单选择排序（1、基本思想：\n1）、在未排序的序列中选出最小元素和序列的首位元素交换，\n2）、再在剩下的排序序列中再选出最小元素与序列的第2 个位置元素交换\n3）、以此类推，最后形参从小到大的已排序序列。\n\n（2、执行过程\n（3、时空效率及稳定性\n【2】堆排序（1、基本思想：\n1）、利用最大堆（或最小堆）\\输出*堆顶元素*，即最大值（或最小值）；\n2）、将剩余元素重新生成最大堆（或最小堆），继续输出堆顶元素；\n3）、重复此过程，知道全部元素都已输出，得到的输出元素序列即为有序序列\n\n（2、执行过程要点&lt;1&gt;初始化堆的过程\n\n\n下面是构建初始堆的过程\n\n\n\n下面是堆排序的过程\n\n\n\n（3、时空效率及稳定性\n4、归并排序\n二、各种排序的比较口诀：快选堆希不稳，选堆归基不变\n不稳：说的是 算法不稳定\n不变：说的是 关于移动次数和关键字顺序无关的排序\n\n\nend\nend\n","categories":["笔记"]},{"title":"数据结构复习其一","url":"/Arknight-notes/posts/49533.html","content":"大一下数据结构泡图书馆战斗几个星期从日到夜好不容易勉强过了\n艹\n\n\n第一章：数据结构绪论一、数据1.数据是信息的载体，是描述客观事物的数、字符、以及所有能输入到计算机中，被计算机程序识别和处理的符号的集合。\n2.数据分为：数值性数据和非数值性数据。\n二、数据元素1.数据元素是数据的基本单位，是数据集合的个体。\n2.一个数据元素可以由若干数据项组成（此时数据元素被称为记录）。\n3.数据元素又称为元素、结点、记录。\n三、数据项1.数据项是具有独立含义的最小标识单位。\n2.数据项是数据的最小单位。\n四、数据对象1.数据对象是具有相同性质的数据元素的集合，是数据的一个子集。\n（整数数据对象，字母字符数据对象）\n五、结构1.结构是元素之间的。\n2.结构包含空间位置关系，相互作用和依赖关系。\n3.四种基本结构：集合结构、线性结构、树形结构、图形结构。\n(1)集合结构：结构中的数据元素之间除“同属一个集合”外，别无其他关系。\n(2)线性结构：数据元素一对一关系。\n(3)树形结构：一对多。\n(4)图形结构：多对多。\n六、数据结构1.形式定义：某一数据对象的所有数据成员之间的关系。记为：\nData_Structure={D,S}\n其中,D是某一数据对象，即数据元素的有限集合，S是该对象中所有数据成员之间的关系的有限集合。\n2.数据结构是相互之间存在一种或多种特点关系的数据元素的集合。\n3.数据结构包含三方面的内容：逻辑结构，存储结构和数据的运算。\n2.线性数据结构：L={K,R}（其中K为点集，R为关系&lt;&gt;）\n3.树形数据结构：T={K,R}（其中K为点集，R为关系&lt;&gt;）\n4.图形数据结构：G={K,R}（其中K为点集，R为关系() ）\n七、数据结构要解决的问题1.从广义上讲，数据结构描述现实世界实体的数学模型及其上的操作在计算机中的表示和实现。\n八、逻辑结构1.逻辑结构描述数据元素之间的关系。\n2.逻辑结构包括线性结构和非线性结构。\n（1）线性结构包括线性表（表、栈、队列、串）。栈、队列、串是受限线性表。\n（2）非线性结构包括树（二叉树、赫夫曼树、二叉排序树）和图（有向图、无向图）。\n九、物理结构（存储结构）1.物理结构是数据结构在计算机中的表示（或映像）。（存储结构是逻辑结构在计算机中的存储映像，包括数据元素映像和关系映像，但是逻辑结构是独立于存储结构的。）\n2.物理结构包括：顺序存储表示、非顺序存储（链式存储表示、索引存储表示、散列存储表示）。\n注意：有序表属于逻辑结构；顺序表、哈希表、单链表属于存储结构\n(1)顺序存储：逻辑上相邻的元素，存储的物理位置也相邻。优点：随机存取，每个元素占用最少的存储空间；缺点：只能使用相邻的一整块存储单元，可能产生较多的外部碎片。\n(2)链式存储：不要求逻辑上相邻的元素，存储的物理位置也相邻。借助指针表示元素之间的逻辑关系。优点：不会出现碎片现象，充分利用所有存储单元；缺点：每个元素因存储指针占用额外的存储空间，且只能实现顺序存取。\n(3)索引存储：建立附加索引表。优点：检索速度快；缺点：附加的索引表占内存，增加和删除数据也会修改索引表，花费较多时间。\n(4)散列存储：根据关键字直接计算存储地址。优点：检索、删除、增加都很快；缺点：会发生冲突，花费时间。\n十、数据类型1.数据类型是一个值的集合和定义在这个值集上的一组操作的总称。\n（如int整型变量，其值集为某个区间上的整数，定义在其上的操作为+、-、x、/等)\n2.原子数据类型是不可分解的数据类型（如int、float、char、*等等）。\n3.结构数据类型\n（1）由若干成分（原子类型或结构类型）按照某种结构组成的数据类型）\n（2）结构数据类型可以看做是一种数据结构和定义在其上的一组操作组成的整体。\n（3）如数组，由若干个分量组成，每个分量可以是整数，也可以是数组（int A[10]）。\n4.抽象数据类型\n（1）由用户定义，用以表示应用问题的数据模型。\n（2）由基本的数据类型组成，并包括一组相关的操作。\n（3）信息隐蔽和数据封装，使用与现实相分离。\n（4）抽象数据类型ADT是一个数学模型以及定义在该模型上的一组操作。\n（5）抽象数据类型=数据结构+定义在此数据结构上的一组操作。\n（6）（D，S，P）三元组表示。（D是数据对象，S是D上的关系集，P是对D的基本操作集）\n（7）ADT定义：\nADT 抽象数据类型名{\n数据对象：&lt;数据对象的定义&gt;\n数据关系：&lt;数据关系的定义&gt;\n基本操作：&lt;基本操作（函数）的定义&gt;\n}ADT 抽象数据类型名\n例子：\nADT Triplet {\n数据对象：D = {e1,e2,e3 | e1,e2,e3∈ElemSet}\n数据关系：R = {&lt;e1,e2&gt;, &lt;e2,e3&gt;}基本操作：Max(T, &amp;e)                           \n初始条件：三元组T已存在。\n操作结果：用e返回T的3个元素中的最大值。　　\n　　　　 Min(T, &amp;e)\n初始条件：三元组T已存在。\n操作结果：用e返回T的3个元素中的最小值。　\n} ADT Triplet\n（7）抽象数据类型可以通过固有的数据类型来实现：\n抽象数据类型：类class\n数据对象：数据成员\n基本操作：成员函数（方法）\n十一、算法1.算法是对特定问题求解步骤的一种描述。\n2.算法是一有限长的操作序列。\n3.算法特性：\n（1）有穷性：算法在执行有穷步后能结束。\n（2）确定性：每步定义都是确切、无歧义，相同输入相同输出。\n（3）可行性：每一条运算应足够基本（已验算正确）。\n（4）输入：有0个或多个输入。\n（5）输出：有1个或多个输出。\n4.算法设计要求（目标）：\n（1）正确性：满足具体题目的需求。\n（2）可读性：便于理解和修改。\n（3）健壮性：当输入数据非法时，也能适当反应。\n（4）效率高：执行时间少。\n（5）空间省:执行中需要的最大存储空间少。\n十二、时间复杂度1.算法效率的度量是通过时间复杂度和空间复杂度来描述的。\n衡量算法的效率，主要依据算法执行所需要的时间，即时间复杂度。\n注意：算法分析的目的：分析算法的效率以求改进。\n2.事后统计法：计算算法开始时间与完成时间差值。\n缺点：（必须执行程序；其它因素遮盖算法本质）\n3.事前统计法：依据算法选用何种策略及问题的规模n，是常用的方法。\n4.（事前统计法）和算法执行时间相关的因素：\n（1）算法选用的策略（主要）\n（2）问题的规模（主要）\n（3）编写的语言\n（4）编译程序产生的机器代码的质量\n（5）计算机执行指令的速度\n5.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，算法的时间量度记作 T(n)=O(f(n))，称作算法的渐近时间复杂度,简称时间复杂度。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。\n（1）加法规则：T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))\n（2）乘法规则：T(n)=T1(n)T2(n)=O(f(n))  O(g(n))=O(f(n)*g(n))\n6.时间复杂度除常量阶[O(1)], 线性阶[O(n)], 平方阶[O(n^2)]外，还有对数阶[O(logn)]，排列阶[O(n!)]，指数阶[O(2^n)]等，是相对于问题规模n的增长率的表示方法。\n（1）多项式：O(1)&lt;O(log2(n))&lt;O(n)&lt;O(nlog2(n))&lt;O(n^2)&lt;O(n^3)\n（2）指数时间：O(2^n)&lt;O(n!)&lt;O(n^n)\ni=1;while(i&lt;=n)i=i*2;//令执行x次，2^x=n，x=log2(n)，即时间复杂度为O(log2(n))//递归算法，时间复杂度是O(n) int rec(int n)   {      if (n==1) return 1;                       else return (n*rec(n-1));   }\n7.如果算法的执行有多种可能的操作顺序，则求其平均时间复杂度。\n如果无法求取平均时间复杂度，则采用最坏情况下的时间复杂度。\n时间复杂度是衡量算法好坏的一个最重要的标准。\nvoid bubble-sort(int a[]，int n){    for(i=n-1,change=TURE;i&gt;1 &amp;&amp; change;--i)      {           change=false;           for(j=0;j&lt;i;++j)               if (a[j]&gt;a[j+1]) {                     a[j] ←→a[j+1];                    change=TURE}       }     }//最好情况：0次（全部升序排列）//最坏情况：n*(n-1)/2次（全部降序排列）//5 4 3 2 1（5要比较（n-1）次，1被移到最前面了，比较0次，共有n个元素，使用求和公式0+1+...+(n-1)=n*(n-1+0)/2//平均时间复杂度：O(n^2)\n十三、空间复杂度1.空间复杂度指算法执行时，所需要存储空间的量度，它也是问题规模的函数，即：S(n) = O(f(n))。\n2.算法的存储量包括：\n（1）程序本身所占空间（与算法无关）\n（2）输入数据所占空间（与算法无关）\n（3）辅助变量所占空间（若所需额外空间相对于输入数据量来说是常数，则称此算法为原地工作。否则,按最坏情况分析）\n注意：只有辅助变量所占空间与算法有关\n第二章：线性表一、线性数据结构的特点在数据元素的非空有限集中 ：\n1.存在惟一的一个被称作“第一个”的数据元素。\n2.存在惟一的一个被称作“最后一个”的数据元素。\n3.除第一个元素外，每个数据元素均只有一个前驱 。\n4.除最后一个元素外，每个数据元素均只有一个后继 。\n二、线性表1.线性表是最简单的一类线性数据结构。\n2.线性表是由n个数据元素组成的有限序列，相邻数据元素之间存在着序偶关系，可以写为：(a1, a2,…ai-1, ai, ai+1,…an-1, an)其中,ai是表中元素,i表示元素ai的位置,n是表的长度。\n3.线性表中的元素具有相同的特性，属于同一数据对象，如：1.26个字母的字母表: (A,B,C,D,…,Z)2.近期每天的平均温度:(30℃, 28℃, 29℃,…)。\n三、顺序表1.顺序表是线性表的顺序表示。（线性表的顺序存储称为顺序表）\n2.用一组地址连续的存储单元依次存储线性表的数据元素。逻辑相邻，物理也相邻。\n3.顺序表数据元素的位置：\nloc(a[i])=loc(a[i-1])+length\nloc(a[i])=loc(a[1])+(i-1)*length\n其中length表示元素占用的内存单元数。\n4.顺序表的插入操作：\n（1）顺序表的插入操作是指在顺序表的第i-1个数据元素和第i个数据元素之间插入一个新的数据元素，即将长度为n的顺序表：(a1,…ai-1, ai, …, an) 变成长度为n+1的顺序表：(a1,…ai-1, e, ai, …, an)\n（2）在顺序表中的第i个位置插入一个元素，需要向后移动的元素个数为：n-i+1\n（3）平均移动元素数为（假设在第i个元素之间插入的概率为pi）：Eis = ∑ pi x (n-i+1) 其中i从1到n+1。\n（4）当插入位置等概率时pi=1/(n+1)，因为可以插在最后面。因此：\nEis = ∑ [1/(n+1)] x (n-i+1) = n/2其中i从1到n+1。\n\n注意：顺序表插入平均移动元素数为n/2\n（5） 顺序表插入操作的时间复杂度为O(n)。\n5.顺序表的删除操作：\n（1）顺序表的删除操作是指将顺序表的第i个数据元素删除，即将长度为n的顺序表：(a1,…ai-1, ai, ai+1,…, an) 变成长度为n-1的顺序表：(a1,…ai-1, ai+1, …, an)\n（2）在顺序表中删除一个元素，需要向前移动元素个数为：n-i（不用加一）\n（3）平均移动元素数为：Edl = ∑ qi x (n-i) 其中i从1到n。\n\n（4）当删除位置等概率时qi=1/n，因为只有n个元素可以删除。因此：\nEdl = ∑ [1/n] x (n-i) = (n-1)/2其中i从1到n。\n\n注意：顺序表删除平均移动元素数为(n-1)/2\n（5）顺序表删除操作的时间复杂度为O(n)。\n6.顺序表的其它操作:\n（1）查找第i个位置的元素值。\n（2）查找元素所在位置。\n（3）得到表长。\n（4）置空表。\n（5）销毁表(析构函数~SqList())。\n7.顺序表的优缺点：\n（1）优点：元素可以随机存取；元素位置可用一个简单、直观的公式表示并求取。通过首地址和元素序号,O(1)内找到指定元素。存储密度高，每个结点只存储数据元素。\n（2）缺点：在作插入或删除操作时，需要移动大量元素 。\n注意：一个顺序表的第一个元素存储地址为2001,每个元素占用4个地址单元，第6个元素的存储地址为：2001+（6-1）5=2021；对于顺序存储的线性表，删除、增加结点的时间复杂度为O(n)\n四、链表1.链表是线性表的链式存储表示。\n2.链表中逻辑关系相邻的元素不一定在存储位置上相连，用指针表示元素之间的邻接关系。\n3.线性表的链式存储表示主要有三种形式：线性链表、循环链表、双向链表。\n4.线性链表：\n（1）线性链表的元素称为结点。\n（2）结点除包含数据元素信息的数据域外，还包含指示直接后继的指针域。\n（3）每个结点，在需要时动态生成，在删除时释放。\n（4）N个结点(ai(1≤i ≤ n)的存储映像)链结成一个链表,即为线性表的链式存储结构。\n（5）链表的每个结点中只包含一个指针域,故又称线性链表或单链表。\n（6）线性链表可由头指针惟一确定。\n（7）以线性表中的第一个数据元素a1的存储地址作为线性表的地址，称作线性表的头指针。\n（8）有时为了操作方变，在第一个节点之前虚加一个”头结点“，以指向头结点的指针为链表的头指针。\nLNode *head;//头指针head = new LNode;//生成头结点  head-&gt;[ |^]//head-&gt;[ |-]-&gt;[a|-]-&gt;[b|-]-&gt;....\n注意：头结点和头指针区分：不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中第一个结点，结点内通常不存储信息。增加头结点的目的是为了方便运算。\n头结点的优点:(1)由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理；(2)无论链表是否为空，其头指针都指是向头结点的非空指针（空表中头结点的指针域为空）\n单链表的头指针为head，不带头结点的判空条件：head==NULL\n带头结点的判空条件：head-&gt;next==NULL (L -&gt;[ |^] (head-&gt;next==NULL))\n（9）找第i个元素getelement：在线性链表中找到第i个元素，并返回指针；从头结点开始，顺链一步步查找；查找第i个数据元素的基本操作为：移动指针，比较k和i（k为当前指针所指向的结点序号）。时间复杂度为O(n)。\n（10）线性链表的插入：在线性链表的第i-1个元素与第i和元素之间插入一个新元素。s-&gt;next=p-&gt;next;p-&gt;next=s。（其中s为新元素）时间复杂度主要取决于getelement的时间复杂度，getelement的时间复杂度为O(n)，因此线性链表插入的时间复杂度为O(n)。\n注意：在单链表中第i个结点之前进行插入的基本操作：找到线性表中的第i-1个结点p，创建新结点s，然后修改第i-1个结点和s结点的后继指针。s-&gt;next=p-&gt;next;p-&gt;next=s\n（11）线性链表的删除：将线性链表的第i个元素删除。\n找到线性表中第i-1个结点p，修改其指向后继的指针。\nq=p-&gt;next;p-&gt;next=q-&gt;next;(e=q-&gt;data)delete q;（删除p-&gt;next这个结点）时间复杂度主要取决于getelement的时间复杂度，getelement的时间复杂度为O(n)，因此线性链表删除的时间复杂度为O(n)。\n（12）线性链表的创建：链表是一个动态的结构，不需要预分配空间，生成链表的过程是一个结点”逐个插入“的过程。依次调用insert即可，时间复杂度O(n^2)。n个结点，每个结点每次插入Insert函数，头指针指向最后，表尾插入故为n*n。\n（13）线性链表的创建-头插法：即表头不断插入新结点。逆序输入数据值。头插法时间复杂度O(n)。\n（14）线性链表的创建-尾插法：即表尾不断插入新结点。按链表序输入数据值。为记录尾结点，增加一个尾指针tail，指向最后一个结点。尾插法时间复杂度O(n)\n（15）单链表的合并：将两个有序链表合并成一个有序链表。\n（16）拷贝构造函数被调用的三种情况：一个对象以值传递的方式传入函数体；一个对象以值传递的方式从函数返回；一个对象需要通过另一个对象进行初始化。\n（17）赋值函数被调用的时机：当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。\n（18）拷贝构造函数与赋值函数比较：\n调用拷贝构造函数来初始化一个对象：\nA a;A b(a); A b=a;\n都是拷贝构造函数来创建对象b（b还不存在）\n调用赋值函数对对象复制：\nA a;A b;b=a;\n强调：这里a,b对象是已经存在的，是用a 对象来赋值给b的！！\n5.静态链表：线性链表也可以采用静态数组实现。\n与顺序表有两点不同：\n（1）每个元素包括数据域和指针域。\n（2）元素的逻辑关系由指针确定。\n与单链表的区别：\n（1）静态链表暂时不用结点，链成一个备用链表。\n（2）插入时，从备用链表中申请结点。\n（3）删除结点时，将结点放入备用链表。\n6.循环链表：\n（1）循环链表是一种特别的线性链表。\n（2）循环链表中最后一个结点的指针域指向头结点，整个链表形成一个环。\n（3）在只有尾指针的单循环链表中：\n表头插入结点：在只有尾指针的情况下，要在表头插入结点，首先需要找到尾结点，然后将新结点插入到尾结点之后。因此，表头插入结点的时间复杂度为 O(1)（常数时间），因为无论链表有多长，插入操作所需的时间都是相对固定的。\n虽然在只有尾指针的情况下，插入结点时需要找到尾结点，但这并不会导致时间复杂度变为 O(n)。在单循环链表中，尾结点指向头结点，因此我们可以直接通过尾指针找到头结点，然后在头结点之后插入新结点。\n因此，表头插入结点的时间复杂度仍然是 O(1)，因为无论链表有多长，插入操作所需的时间都是相对固定的。\n表尾插入结点：由于只有尾指针，直接在尾结点之后插入新结点即可。因此，表尾插入结点的时间复杂度同样为 O(1)。\n（4）查找、插入和删除：与线性链表基本一致，差别仅在于算法中的循环条件不是p-&gt;next或p是否为空（^)，而是它们是否等于头指针(L)。\n注意循环链表带头结点判空：head-&gt;next==head\n7.双向链表\n（1）双向链表是一种特殊的线性链表：每个结点有两个指针，一个指针指向直接后继(next)，另一个指针指向直接前驱(prior)。\n（2）对于任何一个中间节点有：p=p-&gt;next-&gt;prior/p=p-&gt;prior-&gt;next。\n（3）插入操作需要改变两个方向的指针：s-&gt;next=p;s-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=s;p-&gt;prior=s;\n（4）删除操作需要改变两个方向的指针：p-&gt;prior-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=p-&gt;prior;\n8.双向循环链表\n（1）存在两个环：一个是直接后继环，另一个是直接前驱环。\n五、一元多项式1.pn (x) = p0 + p1x + p2 x^ 2 + … + pn x^ n\n在计算机中，可以用一个线性表来表示：P = (p0 , p1 , …，pn)\n2.pn(x)=p1x^e1+p2x^e2+…+pmx^em\n线性表示((p1,e1),(p2,e2),…,(pm,em))\n六、顺序表与链表的比较1.基于空间的比较\n（1）存储分配的方式：顺序表的存储空间是静态分配的，链表的存储空间是动态分配的。\n（2）存储密度=结点数据本身所占的存储量/结点结构所占的存储总量\n顺序表的存储密度=1，链表的存储密度&lt;1\n2.基于时间的比较\n（1）存取方式：顺序表可以随机存取也可以顺序存取，链表必须顺序存取。\n（2）插入、删除时移动元素个数：顺序表平均需要移动近一半元素，链表不需要移动元素只需要修改指针。\n3.基于应用的比较 （1）线性表主要是存储大量数据，并用于查找时，采用顺序表比较好。\n（2）若线性表存储的数据元素要经常插入和删除，采用链表比较好。\n注意：某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用带尾指针的单循环链表最节省时间。\n仅有尾指针的单循环链表，可以非常方便地找到尾结点，尾结点后面的第一个结点往往是头结点，头结点的下一个结点就是线性表的第一个结点。对最后一个元素和第一个元素操作对带尾指针的单循环链表是非常方便的\n循环链表是线性表，它是线性表的链表存储结构之一。\n在一个以h为头的单循环链表中，p指针指向链尾的条件是p-&gt;next=h。\n第三章：栈和队列一、栈1.栈是限定仅在表尾(top)进行插入或删除操作的线性表。\n2.允许插入和删除的一端称为栈顶(top，表尾)，另一端称为栈底(bottom，表头）\n3.特点：后进先出 (LIFO)\n4.栈的存储结构：顺序栈和链式栈。\n5.顺序栈：\n（1）顺序栈是栈的顺序存储结构。\n（2）利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。\n（3）指针top指向栈顶元素在顺序栈中的下一个位置，base为栈底指针，指向栈底的位置。\n（4）top=0 或top=base 表示空栈。\n（5）base=NULL表示栈不存在。\n（6）当插入新的栈顶元素时,指针top+1。\n（7）删除栈顶元素时，指针top-1。\n（8）当top&gt;stacksize时，栈满，溢出。\n注意：向顺序表中压入新元素，应当先移动栈顶指针，再入栈，出栈时先取栈顶元素再移动指针\n6.链栈：\n（1）栈的链式存储结构称为链栈，它是运算受限的单链表，可插入和删除操作仅限制在表头位置上进行。\n（2）由于只能在链表头部进行操作，故链表没有必要像单链表那样附加头结点。栈顶指针就是链表的头指针。\n（3）链栈中为何不设头指针？因为链栈只在链表头插入和删除结点,不可能在链表中间插入或删除结点,算法实现很简单,所以一般不设置头结点。\n（4）链栈对比顺序栈主要优点在于，通常不会栈满的情况\n7.C++中栈容器：\n（1）stack 模板类的定义在头文件中。\n（2）定义stack 对象的示例代码如下：stack s1;stack s2;\n（3）stack 的基本操作有：\n入栈，如例：s.push(x);\n出栈，如例：s.pop();注意，出栈操作只是删除栈顶元素，并不返回该元素。\n访问栈顶，如例：s.top()\n判断栈空，如例：s.empty()，当栈空时，返回true。\n访问栈中的元素个数，如例：s.size()。\n8.栈的应用举例\n（1）数值转换：\n将十进制转换为其他进制（d）：N=(Nd)d+N mod d\n（计算顺序与输出顺序相反）\n（2）行编辑程序\n（3）迷宫求解（用一个栈来记录已走过的路径）\n设定当前位置为入口位置　\ndo {若当前位置可通，则 {\n　将该位置插入栈顶(Push)；若该位置是出口，则结束\n　否则切换当前位置的东邻方块为当前位置；\n} 否则 {      　\n若栈不空则｛\n    　  如果栈顶位置的四周均不可通,则删除栈顶位置(Pop)      　并重新测试新的栈顶位置\n　　如果找到栈顶位置的下一方向未经探索，则将该方向\n　　方块设为当前位置}}}while(栈不空)；找不到路径；\n（4）表达式求值：表达式由操作数、运算符和界限符组成，它们皆称为单词。\n操作数：常数或变量。运算符：+, -, *, / 等。界限符：(, ), #(表达式开始及结束符)。\n计算步骤：假设操作数栈NS和运算符栈OS，\n—（1）依次读取表达式，若为操作数，则直接进栈；\n若为运算符(记为op2)，转（2）\n—（2）将op2与运算符栈顶元素(记为op1)按P53的表3.13 比较优先权，并按如下规则进行操作：\n若prec(op1) &lt; prec(op2), 则op2入OS;\n若prec(op1) = prec(op2), 则op1出栈，回到（1）；\n若prec(op1) &gt; prec(op2), 则NS出2个操作数 num2,num1,op1出栈，\n计算num2 op1 num2，结果入NS；回到(2) 。\n—（3）重复（1）、（2）直至整个表达式求值完毕。\n\n例如: Exp = a x b + (c - d / e) x f\n前缀式: + x a b x - c / d e f\n中缀式: a x b + c - d / e x f\n后缀式: a b x c d e / - f x +\n前缀式的运算规则为:连续出现的两个操作数和在它们之前且紧靠它们的运算符构成一个最小表达式;\n中缀式丢失了括弧信息,致使运算的次序不确定;（编译系统中：中缀转后缀进行计算）\n后缀式的运算规则为: 运算符在式中出现的顺序恰为表达式的运算顺序; 每个运算符和在它之前出现 且 紧靠它的两个操作数构成一个最小表达式。\n结论：操作数之间的相对次序不变；运算符的相对次序不同。\n得到后缀表达式后，我们在计算表达式时，可以设置一个栈，从左到右扫描后缀表达式，每读到一个操作数就将其压入栈中；每到一个运算符时，则从栈顶取出两个操作数进行运算，并将结果压入栈中，一直到后缀表达式读完。最后栈顶就是计算结果。\n\n9.栈与递归的实现\n（1）当在一个函数的运行期间调用另一个函数时，在运行该被调用函数之前，需先完成三项任务：将所有的实在参数、返回地址等信息传递给被调用函数保存；为被调用函数的局部变量分配存储区；将控制转移到被调用函数的入口。\n（2）从被调用函数返回调用函数之前，应该完成下列三项任务：保存被调函数的计算结果；释放被调函数的数据区；依照被调函数保存的返回地址将控制转移到调用函数\n（3）多个函数嵌套调用：后调用先返回！此时的内存管理实行“栈式管理”。\n（4）递归函数执行的过程可视为同一函数进行嵌套调用。\n注意：n个不同元素进栈，出栈元素不同排列个数为：(1/(n+1))C(2n,n)其中C为组合数，从2n个选n个\n二、队列1.队列是只允许在表的一端进行插入，而在另一端删除元素的线性表。\n2.在队列中，允许插入的一端叫队尾（rear），允许删除的一端称为对头(front)。特点：先进先出 (FIFO)\n3.顺序队列：采用一组地址连续的存储单元依次存储从队列头到队列尾的元素。顺序队列有两个指针：队头指针front和队尾指针rear\n4.顺序队列的进队和出队原则：进队时，新元素按rear指针位置插入，然后队尾指针增一，即 rear = rear + 1；出队时，将队头指针位置的元素取出，然后队头指针增一，即 front = front + 1；队头指针始终指向队列头元素；队尾指针始终指向队列尾元素的下一个位置。\n5.顺序队列存在的问题：\n（1）当队尾指针指向队列存储结构中的最后单元时，如果再继续插入新的元素，则会产生溢出当队列发生溢出时。\n（2）不能用rear==maxsize判断队满。\n（3）队列存储结构中可能还存在一些空白位置（已被取走数据的元素），假上溢。(前面还有空位)\n\n（3）解决办法之一：将队列存储结构首尾相接，形成循环(环形)队列。\n6.循环队列：\n（1）循环队列采用一组地址连续的存储单元。\n（2）将整个队列的存储单元首尾相连。\n（3）判断对空和队满：\n对循环队列而言，无法通过front==rear来判断队列“空”还是“满”。 解决此问题的方法至少有三种：\n其一是另设一个布尔变量以匹别队列的空和满；\n其二是少用一个元素的空间，约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满（注意：rear所指的单元始终为空！！）；\nfront = rear，（都指向空）循环队列空；(rear+1) % MAXQSIZE = front，循环队列满。\n\n其三是使用一个计数器记录队列中元素的总数（实际上是队列长度）。\n（4）循环队列：\n初始时：front=rear=0\n出队，队首指针加一：front=(front+1)%maxsize\n进队，队尾指针加一：rear=(rear+1)%maxsize\n队列长度：(rear-front+maxsize)%maxsize\n若牺牲一个单元来区分队列空和队列满，队列少用一个队列单元：\n队满：(rear+1)%maxsize==front\n队空：front==rear\n题目：假设Q[ 11] (下标为从0到10)是一个循环队列,初始状态为front=rear=0;画出分别做完下列操作后队列的头尾指针的装填变化情况,若不能入队,请指出其元素,说明理由..(采用少用一个元素空间的方式)\nd,e,b,g,h入队\nd,e出队\ni,j,k,l,m入队\nb 出队\nn,o,p,q,r 入队\n\n(上述答案采用front指向空，应改为rear时刻指向空！)\n7.链队列\n（1）链队列采用链表存储单元链队列中，有两个分别指示队头和队尾的指针。\n（2）链式队列在进队时无队满问题，但有队空问题。\n（3）链队列是链表操作的子集。\n设长度为n的链队列用单循环链表表示，若只设头指针，则入度时间复杂度为O(n)，出队时间复杂度为O(1);若只设尾指针，则入队时间复杂度和出队时间复杂度都为O(1)，出队队头之间是tail-&gt;next即可。\n删除一个结点，即出队时的指针操作为：front=front-&gt;next\n8.C++中的队列容器\n（1）queue 模板类的定义在头文件中。\n（2）定义queue 对象的示例代码如下：queue q1;queue q2;\n（3）queue 的基本操作有：\n入队，如例：q.push(x); 将x 接到队列的末端。\n出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。\n访问队首元素，如例：q.front()，即最早被压入队列的元素。\n访问队尾元素，如例：q.back()，即最后被压入队列的元素。\n判断队列空，如例：q.empty()，当队列空时，返回true。\n访问队列中的元素个数，如例：q.size()\n9.C++中的map容器\n（1）map是c++的一个标准容器，提供了key和value的映射。map 模板类定义在头文件中。\n（2）map对象定义：map&lt;string , int &gt; mapstring;\n（3）map添加数据：map&lt;int ,string&gt; maplive; -1.maplive.insert(pair(102,“aclive”));\n-2.maplive.insert(map::value_type(321,“hai”));\n-3.maplive[112]=”April”;//map中最简单最常用的插入添加！\n（4）map中查找数据：\n-1.使用map的下标运算符重载\nmap&lt; std::string,int&gt; mapTest;\ncout&lt;&lt;mapTest[“index”]&lt;&lt;endl;\n-2.使用map的find接口。\nmap&lt; std::string,int&gt; mapTest;\nmap&lt; std::string,int&gt;::iterator it = mapTest.find(“index”);\nif(it!=mapTest.end()) cout&lt;&lt; it-&gt;second&lt;&lt;endl;\n大题重点：表达式求值\n\n(同种符号比较，先出现的优先级高)\n第四章：串一、字符串1.字符串是n个字符的有限序列。\n2.字符串术语：\n（1）空串：不含任何字符的串，串长度=0。\n（2）空格串：仅由一个或多个空格组成的串。\n（3）子串：由串中任意个连续的字符组成的子序列。\n（4）主串：包含子串的串。\n（5）位置：字符在主串中的序号。子串在主串中的位置以子串第一个字符在主串中的位置来表示。\n（6）串相等的条件：当两个串的长度相等且各个对应位置的字符都相等时才相等。\n（7）模式匹配：确定子串在主串中首次出现的位置的运算\n3.字符串与线性表的关系\n—-串的逻辑结构和线性表极为相似：\n（1）它们都是线性结构。\n（2）串中的每个字符都仅有一个前驱和一个后继。\n—-串与线性表又有区别，主要表现为：\n（1）串的数据对象约定是字符集。\n（2）在线性表的基本操作中，以“单个元素”作为操作对象。\n（3）在串的基本操作中，通常以“串的整体”作为操作对象，如：在串中查找某个子串、在串的某个位置上插入一个子串等。\n4.字符串的操作\n13种操作中的最小操作子集(五种)：串赋值StrAssign;串比较StrCompare;求串长StrLength;串联接Concat;求子串SubString。\n最小操作集：\n这些操作不可能利用其他串操作来实现，反之，其他串操作（除串清除ClearString和串销毁DestroyString外）可在这个最小操作子集上实现。\n5.字符串的操作(index)\n（1）串匹配(查找)的定义: INDEX (S, T, pos)\n（2）初始条件：串S和T存在，T是非空串，1≤pos≤StrLength(S)。\n（3）操作结果：若主串S中存在和串T值相同的子串返回它在主串S中第pos个字符之后第一次出现的位置；否则函数值为0。\n二、串的表示和实现1.定长顺序存储表示（静态存储分配）\n（1）用一组地址连续的存储单元存储字符序列。\n（2）如C语言中的字符串定义(以“\\0”为串结束标志) char Str[MAXSTRLEN+1];\n（3）定义了长度为MAXSTRLEN字符存储空间字符串长度可以是小于MAXSTRLEN的任何值（最长串长度有限制，多余部分将被截断）\n（4）隐含：一般可使用一个不会出现在串中的特殊字符在串值的尾部来表示串的结束。\n优点:便于系统自动实现。\n缺点:不利于某些操作(如合并).\n例如，C语言中以字符‵\\0′表示串值的终结，这就是为什么在上述定义中，串空间最大值maxstrlen为256，但最多只能存放255个字符的原因。\n（5）显式：若不设终结符，可用一个整数来表示串的长度，那么该长度减1的位置就是串值的最后一个字符的位置（下标）。\n优点:便于在算法中用长度参数控制循环过程。\n2.堆分配存储表示\n（1）在程序执行过程中，动态分配（malloc）一组地址连续的存储单元存储字符序列。\n（2）在C++语言中，由new和delete动态分配与回收的存储空间称为堆。\n（3）堆分配存储结构的串既有顺序存储结构的特点，处理方便,操作中对串长又没有限制,更显灵活。\n3.链存储表示\n（1）采用链表方式存储串值。\n（2）每个结点中，可以存放一个字符，也可以存放多个字符。\n（3）存储密度=数据元素所占存储位/实际分配的存储位。\n三、串的匹配算法1.求子串位置函数Index()\n（1）子串的定位操作通常称做串的模式匹配。\n（2）算法（穷举法，朴素算法，BF(Brute-Force)算法）：\n从主串的指定位置开始，将主串与模式（要查找的子串）的第一个字符比较：\n若相等，则继续逐个比较后续字符；若不等，从主串的下一个字符起再重新和模式的字符比较。\n（3）在最好的情况下，除比较成功的位置外，其余位置仅需比较一次（模式第一个字符），其时间复杂度为：O(n+m)(n，m分别为主串和模式的长度)\n（4）但在最坏的情况下，如模式为‘00000001’，主串为‘0000000000000000000000000000000001’,则每次模式的前7个0都要与主串逐一比较，因此，其时间复杂度为：O(n*m)\n2.KMP算法（时间复杂度O(n+m))\n（1）当一趟匹配过程中出现字符比较不等(失配)时\n—1.不需回溯i指针\n—2.利用已经得到的“部分匹配”的结果\n—3.将模式向右“滑动”尽可能远的一段距离(next[j])后，继续进行比较\n（2）在模式串中第j个字符“失配”时,模式串第k个字符再同主串中对应的失配位置(i)的字符继续进行比较 ：‘p1p2…pk-1’ = ‘pj-k+1pj-k+2…pj-1’\nk值可以在做串的匹配之前，求出一般用next函数求取k值。\n（3）next函数定义为（下标从1开始）：\n—当j=1时next[j] = 0；\n—next[j] = max{k | 0&lt;k&lt;j且‘p1…pk-1’=‘pj-k+1…pj-1’}；(直接等于0~j-1的字符串的最长公共前后缀的长度+1)\n—当其它情况时next[j]=1。\n\n（4）next函数定义为（下标从0开始）：\n—当j=0时next[j] = -1；\n—next[j] = max{k | 0&lt;k&lt;j且‘p0…pk-1’=‘pj-k…pj-1’}；(直接等于0~j-1的字符串的最长公共前后缀的长度)\n—当其它情况时next[j]=0。\n\n即寻找当前j前可相互重叠（不完全重叠）的最长真子串的长度。从第一个字符开始的子串的下一个元素的下标，指示出，如果j所指示的模式串的字符与目标串中的当前字符不相等时，j应回退的位置。\n\n（5）求next[j]值的算法：\n—1. j的初值为0, next[0]=-1, k=-1\n—2. While(j&lt;模式串长度-1) {\n—(1).若k=-1或者Tj=Tk,则j++,k++,next[j]=k\n—(2).否则,k=next[k]\n}\n这实际上也是一个匹配的过程，不同在于：主串和模式串是同一个串。\n（6）KMP算法：\n—1.令i的初值为pos,j的初值为0\n—2. While((i&lt;主串长度)且(j&lt;模式串长度)) {\n—(1).若j=－1或者si=pj,则i++, j++\n—(2).否则,j=next[j]\n}//j=－1表示第一个字符失配\n（7）时间复杂度：\nKMP()函数的时间复杂度为O(n)，为了求模式串的next值,其算法与KMP很相似,其时间复杂度为O(m)，因此,KMP算法的时间复杂度为O(n+m)。\n（8）nextval：\n—1.首先计算next\n—2.比较当前字符t.ch[j]与其next值k所指字符 t.ch[k]\n—（1）不等： nextval[j]=next[j]（即维持不变）\n—（2）相等： nextval[j]=nextval[k]\n\nvoid getnext(string p){    int j,k;    j=0,k=-1;    next[0]=-1;//!    while(j&lt;p.size()-1)    {        if(k==-1||T[j]==T[k])            next[++j]=++k;        else            k=next[k];    }}\n大题题目重点：字符串匹配\n题目：求串eefegeef的next值。写出计算过程。假设主串为eefeefegeebeefegeeb，写出KMP算法查找串eefegeef的过程。\n\n第五章：数组和广义表一、数组的定义1.数组\n数组是相同类型的数据元素的集合\n数组是一种定长的线性表\n数组一般不作插入和删除操作\n一旦建立了数组，则结构中的数据元素个数和数据元素之间的关系就不再发生变动\n判断：“数组的处理比其它复杂的结构要简单”，对吗？\n答：对的。因为——① 数组中各元素具有统一的类型；② 数组元素的下标一般具有固定的上界和下界，即数组一旦被定义，它的维数和维界就不再改变。③数组的基本操作比较简单，除了结构的初始化和销毁之外，只有存取元素和修改元素值的操作。\n2.一维数组\n一维数组是一种简单的定长线性表\n一维数组中的每个数据元素是一个(数)值\n(原子)如：int A[8]={8,7,5,4,6,1,3,2} b=8，有8个数据元素，每个元素都是一个数值\n3.二维数组\n二维数组是这样一个定长线性表，其每个数据元素也是一个定长线性表(一维数组)\n\nAmxn= ((a00 a01…a0,n-1), (a10 a11…a1,n-1),…,(am-1,0 …am-1,n-1))\n4.多维数组\n多维数组是这样一个定长线性表，其每个数据元素也是一个定长线性表(降一维)\n如果其数据元素不是一维数组，则其数据元素的每个数据元素也是一个定长线性表\n一直到最后一个定长线性表是一维数组，其每个数据元素为一个(数)值\n二、数组的表示1.数组的顺序表示\n顺序存储：数组由相同类型的数据组成，且一般不作插入和删除操作，一般采用顺序存储结构表示数组\n次序约定：计算机中，存储单元是一维结构，而数组为多维结构，则用一组连续的存储单元存放数组的数据元素时，有一个次序约定问题\n\nAmxn= ((a00 a01…a0,n-1), (a10 a11…a1,n-1),…,(am-1,0 …am-1,n-1))\nAmxn= ((a00 a10…am-1,0), (a01 a11…am-1,1),…,(a0,n-1 …am-1,n-1))\n（1）行序（m行n列）\nLOC(aij) = LOC(a00) + (i x n + j) x L\nLOC(a00)是二维数组的起始存储地址\nL为每个数据元素占用存储单元的长度(数目)\nLoc(aij)=Loc(a11)+[(j-1) +(i-1)  n ]K\n（2）列序（m行n列）\nLOC(aij) = LOC(a00) + (i + j x m) x L\nLOC(a00)是二维数组的起始存储地址\nL为每个数据元素占用存储单元的长度(数目)\nLoc(aij)=Loc(a11)+[(j-1)  m+(i-1)]K\n注意：已知二维数组Am,m按行存储的元素地址公式是： Loc(aij)= Loc(a11)+[(i-1) * m+(j-1)]K , 请问按列存储的公式相同吗？\n答：尽管是方阵，但公式仍不同。应为： Loc(aij)=Loc(a11)+[(j-1) * m+(i-1)]K\n2.多维数组的顺序表示\n（1）以行序为主序存储,多(K)维数组元素存储位置\nLOC(aj1,j2,..,jk) = LOC(a00 0) + ((b2xb3x…xbkxj1)+(b3x…xbkxj2)+…+jk) x L\n（2）以列序为主序存储,多(K)维数组元素存储位置\nLOC(aj1,j2,..,jk) = LOC(a00 0) + ((b1xb2x…xbk-1xjk)+(b1x…xbk-2xjk-1)+…+j1)xLp\n三、矩阵的压缩存储1.矩阵的压缩存储\n（1）如果矩阵中有许多值相同的元素或者零元素(特殊矩阵、稀疏矩阵)，为了节省存储空间，可以对这类矩阵进行压缩存储\n（2）压缩存储：为多个值相同的元素只分配一个存储空间；对零元素不分配空间\n2.特殊矩阵\n（1）特殊矩阵：矩阵中，值相同的元素或者零元素的分布有一定规律\n（2）对称矩阵：矩阵中，对角线两边对应位置上元素的值相同(aij=aji)\n（3）三角矩阵：矩阵中，对角线上(下)边元素值为常数(或者0)，称下(上)三角矩阵\n（4）如果只存储对称矩阵对角线上的值和对角线以上部分的值，则与上三角矩阵存储方法相同；如果只存储对称矩阵对角线上的值和对角线以下部分的值，则与下三角矩阵存储方法相同。\n\nLOC(aij) = LOC(a00) + ((i+1)i/2+j) L\n若i&gt;=j，数组元素a[i] [j]在数组B中的存放位置为：1+2+..+i+j=(i+1)*i/2+j\n(i+1)*i/2为前i行元素总数，j为第i行第j个元素前元素个数（因为下标都从0开始）\n若 i &lt; j，数组元素 a[i] [j] 在矩阵的上三角部分, 在数组 B 中没有存放，可以找它的对称元素a[j] [i]：= j *(j +1) / 2 + i (在上则找对称到下)\n\n若i &lt;= j，数组元素A[i] [j]在数组B中的存放位置为 n + (n-1) + (n-2) + … + (n-i+1) + j-i=(2n-i-1)  i/2+j-i\n其中(2n-i-1) i/2为前i行元素总数，j-i为第i行第j个元素前元素个数\n若i &gt; j，数组元素A[i] [j]在矩阵的下三角部分，在数组 B 中没有存放。因此，找它的对称元素A[j] [i]。 A[j] [i]在数组 B 的第 (2n-j-1)  j / 2 + i 的位置中找到。\n3.稀疏矩阵\n（1）稀疏矩阵：矩阵中有许多值相同的元素或者零元素，而且分布没有任何规律\n假设在mxn的矩阵中，有t个非零元素，令：\nδ= t /(m x n)\n如果稀疏因子δ≤0.05，则称该矩阵为稀疏矩阵\n（2）用三元组存储稀疏矩阵中的非零元素\n三元组(i,j,aij)表示矩阵中i行、j列位置的值为aij\n\n（3）转置\n设矩阵列数为m，对矩阵三元组表扫描m次\n第k次扫描，找寻所有列号为k的项\n将其行号变列号、列号变行号，顺次存于转置矩阵三元组表中\n\n四、广义表1.广义表的定义\n（1）广义表：由n(≥0)个表元素组成的有限序列：\nLS = (a0, a1, a2, …, an-1)\n（2）LS是广义表的名称\n（3）ai是广义表的元素，既可以是表(称为子表)，也可以是数据元素(称为原子)\n（4）n为广义表的长度(n=0的广义表为空表)\n2.广义表的举例\nA=( ); //表A是一个空表\nB=(e); //表B有一个原子\nC=(a,(b,c,d)); //两个元素，分别为原子a和子表(b,c,d)\nD=(A,B,C); //有三个元素均为列表\nE=(a,E); //递归的列表\n其中，“表”以及“列表”，均指广义表\n3.广义表的存储\n广义表一般采用链式存储结构\n表结点[Tag=1|hp|tp]；原子结点[Tag=0|atom]；hp表示表头，tp表示表尾\n\n4.广义表的表头\n表头(head)：广义表的第一个元素\n表头既可以是原子，也可以是列表(广义表)\nGetHead(B) = e；GetHead(D) = A；GetHead((B,C)) = B\n5.广义表的表尾\n表尾(tail)：广义表中，除表头外的部分\n注意：表尾一定是列表，要加括号！\nGetTail(B) = ()；GetTail(D) = (B,C)；GetTail((B,C)) = (C)\n\nGetTail【(b, k, p, h)】＝ （k,p,h） ;\nGetHead【( (a,b), (c,d) )】＝ （a,b） ;\nGetTail【( (a,b), (c,d) )】＝（(c,d)） ;\nGetTail【 GetHead【((a,b),(c,d))】】＝（b）;\nGetTail【（e）】＝（）;\nGetHead 【 ( ( ) )】＝（）；\nGetTail【 ( ( ) ) 】＝ （）；\n\n第六章：树与二叉树一、树的概念与基本术语1.树的定义(Tree)\n（1）树是有n(n≥0)个结点的有限集合。\n（2）如果 n=0，称为空树；\n（3）如果 n&gt;0,称为非空树,对于非空树,有且仅有一个特定的称为根(Root)的节点(无直接前驱)\n（4）如果 n&gt;1，则除根以外的其它结点划分为 m (m&gt;0)个互不相交的有限集 T1, T2 ,…, Tm，其中每个集合本身又是一棵树，并且称为根的子树(SubTree)。(此为递归定义)\n（5）每个结点都有唯一的直接前驱，但可能有多个后继。\n2.树的基本术语\n（1）结点：包含一个数据元素及若干指向其子树的分支；（包括分支！）\n（2）结点的度：结点拥有的子树数；结点的深度是从根结点开始自顶向下逐层累加；结点的高度是从叶节点开始自底向上逐层累加。\n（3）叶结点：度为0的结点[没有子树的结点] (终端结点 )\n（4）分支结点：度不为0的结点[包括根结点]，也称为非终端结点。除根外称为内部结点。\n注意：除根之外都是内部结点！\n（5）孩子：结点的子树的根[直接后继，可能有多个]\n（6）双亲：孩子的直接前驱[最多只能有一个]\n（7）兄弟：同一双亲的孩子\n（8）子孙：以某结点为根的树中的所有结点\n（9）祖先：从根到该结点所经分支上的所有结点\n（10）层次：根结点为第一层，其孩子为第二层，依此类推\n（11）深度：树中结点的最大层次（从根算第一层），也为树的高度。\n（12）有序树：子树之间存在确定的次序关系。\n（13）无序树：子树之间不存在确定的次序关系。\n（14）森林：互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。任何一棵非空树是一个二元组 Tree = （root，F）其中：root 被称为根结点 ，F 被称为子树森林。\n3.树型结构与线性结构的区别在于：一个元素可以有多个后继。\n4.树的相关性质：\n（1）树中的结点数等于所有结点的度数加一\n（2）度为m的树中第i层上至多有m^(i-1)个结点\n（3）高度为h的m叉树至多有(m^h-1)/(m-1)个结点\n（4）具有n个结点的m叉树的最小高度为logm(n(m-1)+1)\n二、二叉树1.二叉树是一种特殊的树，每个结点最多有2棵子树，子树有左右之分。\n2.在二叉树的第i层上最多有2^(i-1)个结点。\n3.深度为k的二叉树最多有2^k-1个结点。\n4.如果二叉树终端结点数为n0(也为叶子结点数),度为2的结点数为n2,则n0=n2+1\n三、满二叉树1.一个深度为k且有2^k-1个结点的二叉树。\n2.每层上的结点数都是最大数。\n3.可以自上而下、自左至右连续编号。\n四、完全二叉树1.当且仅当每一个结点都与深度相同的满二叉树中编号从1到n的结点一一对应的二叉树。\n2.叶子结点只在最大两层上出现。\n3.左子树深度与右子树深度相等或大１。\n4.具有n个结点的完全二叉树,其深度为floor(log2(n)) +1\n5.在完全二叉树中，结点i的双亲为 i/2;\n结点i的左孩子LCHILD(i)=2i;\n结点i的右孩子RCHILD(i)=2i+1.\n五、二叉树的顺序存储结构1.用一组连续的存储单元依次自上而下,自左至右存储结点。\n\n六、二叉树的链式存储结构1.二叉链表：二叉链表结点由一个数据域和两个指针域组成，采用数据域加上左、右孩子指针。\n\n2.三叉链表：采用数据域加上左、右孩子指针及双亲指针。\n\n七、遍历二叉树1.遍历二叉树：树的遍历就是按某种次序访问树中的结点，要求每个结点访问一次且仅访问一次（非线性结构线性化）。\n2.一个二叉树由根节点与左子树和右子树组成，设访问根结点用D表示，遍历左、右子树用L、R表示，如果规定先左子树后右子树，则共有三种组合\n（1）DLR [先序遍历]\n（2）LDR [中序遍历]\n（3）LRD [后序遍历]\n\n八、线索二叉树1.利用空指针\n（1）在有n个结点的二叉树中，必定存在n+1个空链域；\n（2）因为每个结点有两个链域（左、右孩子指针），因此共有2n个链域；\n（3）除根结点外，每个结点都有且仅有一个分支相连，即n-1个链域被使用。\n\n十、树与森林1.树的存储结构\n（1）双亲表示法：采用一组连续的存储空间；由于每个结点只有一个双亲，只需要一个指针。\n\n（2）孩子表示法：可以采用多重链表，即每个结点有多个指针，最大缺点是空链域太多[(d-1)n+1个]。将每个结点的孩子排列起来，用单链表表示；将每个结点排列成一个线性表。\n\n（3）孩子兄弟表示法（常用）：采用二叉链表左边指针指向第一个孩子，右边指针指向兄弟。\n\n2.树与二叉树的对于关系\n（1）树与二叉树都可以采用二叉链表作存储结构。\n（2）任意给定一棵树，可以找到一个唯一的二叉树(没有右子树)。\n\n3.森林与二叉树的对应关系\n\n4.树的遍历：\n（1）先根（次序）遍历（树的先根——-二叉树的先序）\n\n（2）后根（次序）遍历（树的后根——-二叉树的中序）\n\n5.森林的遍历：\n（1）先序遍历：依次从左至右对森林中的每一棵树进行先根遍历。\n（2）中序遍历：依次从左至右对森林中的每一棵树进行后根遍历。\n\n十一、赫夫曼树及其应用1.最优二叉树\n（1）路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径\n（2）路径长度：路径上的分支数目\n（3）树的路径长度：从树根到每个结点的路径长度之和\n（4）结点的带权路径长度：从结点到树根之间的路径长度与结点上权的乘积\n（5）树的带权路径长度(WPL)：树中所有叶子结点的带权路径长度之和（是叶子结点！）\n（6）最优二叉树：假设二叉树有n个叶子，其每个叶子结点带权wi，则带权路径长度WPL最小的二叉树称为最优二叉树\n（7）赫夫曼(Huffman)树就是一棵最优二叉树\n2.赫夫曼树\n（1）在Huffman树中，权值最大的结点离根最近；权值最小的结点离根最远。\n（2）构建算法：\n—-1.根据给定的n个权值(w1, w2, …, wn)构成n棵二叉树的集合F={T1, T2, …, Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，左右子树为空。\n—-2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置其根结点的权值为其左右子树根结点的权值之和。\n—-3.在F中删除这两棵树，同时将新得到的二叉树加入F中。\n—-4.重复2, 3，直到F只含一棵树为止。\n\n注意：画图时每一次要把所有点都画出来！\n（3）编码算法：（从叶子开始！）\n—-1.从Huffman树的每一个叶子结点开始\n—-2、依次沿结点到根的路径，判断该结点是父亲结点的左孩子还是右孩子，如果是左孩子则得到编码‘0’，否则得到编码‘1’，先得到的编码放在后面\n——3、直到到达根结点，编码序列即为该叶子结点对应的Huffman编码\n（4）译码算法：\n—-1.指针指向Huffman树的根结点，取第一个Huffman码\n—-2、如果Huffman码为‘0’，将指针指向当前结点的左子树的根结点；如果Huffman码为‘1’，将指针指向当前结点的右子树的根结点\n—-3、如果指针指向的当前结点为叶子结点，则输出叶子结点对应的字符；否则，取下一个Huffman码，并返回2\n—-4、如果Huffman码序列未结束，则返回1继续译码\n题目：（4）设给出一段报文：GOODGOOD_GOOD_GOOOOOOOO_OFF字符集合是 { O, G, , D, F}，各个字符出现的频度(次数)是 W＝{ 15, 4, 4, 3, 2}。\n若给每个字符以等长编码 O: 000 G: 001 _: 010 D: 011 F: 100\n则总编码长度为 (15+4+4+3+2) * 3 = 84.\n若按各个字符出现的概率不同而给予不等长编码，可望减少总编码长度。\n各字符{ O, G, _, D, F }出现概率为\n{ 15/28, 4/28, 4/28, 3/28, 2/28 },化整为 { 15, 4, 4, 3, 2 }\n令左孩子分支为编码‘0’，右孩子分支为编码‘1’将根结点到叶子结点路径上的分支编码，组合起来，作为该字符的Huffman码，则可得到：　\n\nO:1 _:011 G:010 D:001 F:000\n则总编码长度为 151+(2+3+4+4) 3 = 54 &lt; 84\nHuffman是一种前缀编码，解码时不会混淆\n如GOOD编码为：01011001\n如Huffman编码序列01011001，译码后的字符串为GOOD\n（5）前缀编码：指的是，任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀。利用赫夫曼树可以构造一种不等长的二进制编码，并且构造所得的赫夫曼编码是一种最优前缀编码，即使所传电文的总长度最短。\n题目：（1）设有字符集{A, B, C, D}，各字符在电文中出现的次数集为{1, 3, 5, 7}，则哈夫曼树构造过程如下图所示：\n\n\n（最终哈夫曼树的构造结果如上，一定要记得写结果！）\n\n（2）已知一颗完全二叉树第7层有20个结点，则整棵树的结点数？\n83\n（3）在二叉树中，指针p指向的结点是叶子，则p满足条件？\np-&gt;leftChild==NULL&amp;&amp;p-&gt;rightChild==NULL\n（4）由3个结点组成的二叉树最多有多少种形态？\n5\n（5）已知一棵完全二叉树有100个结点，根节点编号为1，按层次遍历编号，则结点45的父亲编号为？结点50的孩子编号情况如何？\n22;100,101\n第七章：图一、图的定义与术语1.图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构： Graph＝( V, E )\n其中V = {x | x属于数据对象}是顶点的有穷非空集合\nE是顶点之间关系的有穷集合，包括E1 = {(x, y) | x, y 属于 V } 边的集合或E2 = { | x, y 属于 V } 弧的集合\n注意：在一个图中，所有顶点的度数之和等于边数的2倍！\n2.无向图（无向图的邻接矩阵是对称矩阵）\n用(x,y)表示两个顶点x,y之间的一条边(edge)N={V,E}，V={0,1,2,3,4,5}，E={(0,1), (0,4), (0,5), (1,2), (1,3), (1,5), (2,3), (3,4), (3,5), (4,5)}\n（1）邻接点：如果(x,y)属于E,称x,y互为邻接点，即x,y相邻接\n（2）依附：边(x,y)依附于顶点x,y\n（3）相关联：边(x,y)与x,y相关联\n（4）顶点的度：和顶点相关联的边的数目，记为TD(x)\n3.无向图（完全图）：如果无向图有n(n-1)/2条边，则称为无向完全图。\n4.有向图\n用表示从x到y的一条弧(Arc)，且称x为弧尾，y为弧头，N={V,E}，V={0,1,2,3,4}，E={&lt;0,1&gt;，&lt;0,3&gt;，&lt;0,4&gt;，&lt;1,2&gt;，&lt;2,4&gt;，&lt;3,2&gt; }\n（1）邻接：如果属于E,称x邻接到y,或y邻接\n（2）自x相关联：弧与x,y相关联\n（3）入度：以顶点为头的弧的 数目，记为ID(x)\n（4）出度：以顶点为尾的弧的 数目，记为OD(x)\n（5）度：TD(x)=ID(x)+OD(x)\n4.有向图（完全图）：如果有向图有n(n-1)条边，则称为有向完全图。\n5.路径：是一个从顶点x到y的顶点序列(x, vi1, vi2,…, vin, y)其中，(x,vi1),(vij-1,vij),(vin,y)皆属于E。\n6.回路：\n（1）回路或环：路径的开始顶点与最后一个顶点相同，即路径中(x, vi1, vi2,…, vin, y)，x=y\n（2）简单路径：路径的顶点序列中，顶点不重复出现\n7.连通：\n（1）连通：如果顶点x到y有路径，称x和y是连通的\n（2）连通图：图中所有顶点都连通\n8.子图：\n设有两个图 G＝(V, E) 和 G’＝(V’, E’)。\n若 V’包含于 V 且 E’包含于E, 称图G’是图G的子图\n9.生成树\n一个连通图的生成树是一个极小连通子图，它含图中全部n个顶点，但只有足以构成一棵树的n-1条边。\n二、图的存储结构图的存储结构有4种：邻接矩阵，邻接表，十字链表（有向），邻接多重表（无向）\n1.邻接矩阵\n（1）邻接矩阵：记录图中各顶点之间关系的二维数组。\n（2）对于不带权的图，以1表示两顶点存在边(或弧)(相邻接)，以0表示两顶点不邻接，即 如果(i,j)属于E 或 属于E，A[ i ] [ j ] =1 否则等于0。\n（3）无向图的邻接矩阵为对称矩。\n（4）其第i行1的个数等于顶点i的出度OD(i)，第j列1的个数等于顶点j的入度ID(j)。\n2.邻接矩阵（网络）\n在网络中，两个顶点如果不邻接，则被视为距离为无穷大；如果邻接，则两个顶点之间存在一个距离值(即权值)，即如果(i,j)属于E 或 属于E，A[ i ] [ j ] =wi,j 否则等于∞。\n\n3.邻接表\n（1）邻接表是图的一种链式存储结构。\n（2）在邻接表中，每个顶点设置一个单链表，其每个结点都是依附于该顶点的边（或以该顶点为尾的弧）。\n\n无向图中，注意左侧的表格数组！\n\n（邻接表（有向网络））\n（3）在一个无向图的邻接表表示中，每个顶点对应一个链表，链表中包含该顶点相邻的其他顶点。每条边在邻接表中对应两个链表结点，因为无向图的边是双向的。给定图包含 10 个顶点和 20 条边，那么每个顶点的平均度数是 2×边数/顶点数=4。\n由于每个链表结点对应一条边，总的链表结点数是 2×边数。所以，邻接表包含 2×20=40 个链表结点。\n注意：n个结点，e条边的无向图邻接表中，有n个头结点和2e个表结点\n（4）在有向图的邻接表中不易找到指向该顶点的弧。\n（5）对于有向图的邻接表，其第i个链表中结点的个数只是该顶点的出度；如果要计算入度，必须遍历整个邻接表[也可以建立一个逆邻接表]要判定两个顶点i和j是否有边（或弧），必须搜索整个第i个和第j个链表，不及邻接矩阵方便。\n在有向图的逆邻接表找每个结点入度：\n\n（5）无向邻接表所需存储空间O(|V|+2|E|)，有向邻接表所需存储空间O(|V|+|E|)\n（6）对于稀疏图，采用邻接表能极大节省空间。\n4.十字链表（有向图！）\n（1）十字链表是有向图的另一种存储结构\n（2）十字链表是将有向图的邻接表和逆邻接表结合起来的一种存储结构\n\n\n绿色代表：相同弧尾（邻接表）\n红色代表：相同弧头（逆邻接表）\n5.邻接多重表（无向图！）\n（1）邻接多重表是无向图的另一种存储结构\n（2）在无向图中，一条边要用2个结点表示(分别从2个顶点的角度看)\n（3）在邻接多重表中，一条边只用一个结点表示\n（4）将所有具有某顶点的结点，全部用链连结起来，链所在的域为该顶点对应的指针域\n\n三、图的遍历1.从图的某一顶点开始，访遍图中其余顶点，且使每一个顶点仅被访问一次\n2.图的遍历主要应用于无向图\n3.深度优先搜索DFS\n（1）图的深度优先搜索是树的先根遍历的推广\n（2）图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。\n（3）为了避免重复访问，可设置一个标志顶点是否被访问过的辅助数组 visited [ ]\n（4）算法：\n所有顶点访问标志visited[]设置为FALSE\n从某顶点v0开始，设v=v0\n—1.如果visited[v]=FALSE，则访问该顶点，且设visited[v]=TRUE\n—2.如果找到当前顶点的一个新的相邻顶点w,设v=w,重复1\n—3.否则(说明当前顶点的所有相邻顶点都已被访问过，或者当前顶点没有相邻顶点)，如果当前顶点是v0，退出；否则返回上一级顶点，重复2\n（5）存储结构未定，则遍历顺序不确定。\n\n4.广度优先搜索（BFS）\n（1）广度优先搜索(BFS)是一种分层搜索方法\n（2）BFS每向前走一步可能访问一批顶点, 不存在往回退的情况\n（3）BFS不是一个递归的过程。\n（4）算法：\n所有顶点访问标志visited[]设置为FALSE\n从某顶点v0开始，访问v0，visited[v0]=TRUE，将v0插入队列Q\n—1.如果队列Q不空，则从队列Q头上取出一个顶点v,否则结束\n—2.依次找到顶点v的所有相邻顶点v’，如果visited[v’]=FALSE，访问该顶点v’，visited[v’]=TRUE，将v’插入队列Q\n—3.重复1,2\n5.结论\n（1）如果图为连通图，则从该图的任意一个顶点开始执行一次深度优先遍历或广度优先遍历，即可访问该连通图的所有顶点。\n（2）如果图为非连通图，则依次从未访问过的顶点开始执行深度优先遍历或广度优先遍历，直至所有的顶点均被访问。\n（3）事实上执行一次深度优先可以遍历一个连通分支。图有多少个连通分支，就调用多少次深度优先遍历。\n6.时间复杂度\n（1）可以看出无论是深度优先遍历还是广度优先遍历,其实质都是透过边或弧找邻接点的过程,只是访问的顺序不同。\n（2）两者的时间复杂度相同，取决于采取的存储结构，若用邻接矩阵为O(N^2),若 用邻接表则为O(N+E) 即O(n)。\n注意：深度优先搜索遍历类似于树的先根遍历，广度优先搜索遍历类似于树的层次遍历。\n题目：假设用邻接表存储，下图中边上序号表示边输入顺序(链表头插入)，画出该图邻接表，写出用该邻接表存储时其深度优先顺序和广度优先顺序。\n\n四、图的连通性问题1.无向图的连通性\n如果无向图中，存在不连通的顶点，则该图称为非连通图。\n2.无向图的连通分量\n（1）非连通图的极大连通子图叫做连通分量。\n（2）若从无向图的每一个连通分量中的一个顶点出发进行DFS或BFS遍历，可求得无向图的所有连通分量的生成树(DFS或BFS生成树)。\n（3）所有连通分量的生成树组成了非连通图的生成森林。\n（4）连通分量是无向图的极大连通子图，其中极大的含义是将依附于连通分量中顶点的所有边都加上，所以连通分量中可能存在回路。\n（5）生成树是一个连通图的极小连通子图，包含连通图的所有顶点，且使其连通的边数最少。\n（6）极大连通子图是无向图（不一定连通）的连通分量。极小连通子图是连通无向图的生成树。\n（7）任何连通图的连通分量只有一个，即使其自身。\n3.无向图的生成树\n（1）由DFS遍历，求得连通分量称为DFS生成树\n（2）由BFS遍历，求得连通分量称为BFS生成树\n4.有向图的强连通分量\n强连通图是指在有向图中，对于每一对不同的顶点u和v，都存在从u到v及v到u的路径，n个顶点用弧向同一方向连接形成一个环时，就是强连通图，需要弧最少。\n（1）深度优先搜索算法是求有向图的强连通分量的有效方法。\n（2）在有向图G上，从某个顶点出发沿该顶点为尾的弧进行深度优先搜索，并按其所有邻接点的搜索都完成（即退出dfs函数）的顺序将顶点排列起来。\n（3） 在有向图G上，从最后搜索的顶点出发，沿着以该顶点为头的弧作逆向的深度优先搜索遍历。若此次遍历不能访问到有向图中的所有顶点，则从余下顶点中最后完成搜索的顶点出发继续进行逆向的深度优先搜索遍历。\n（4）每次调用dfs作逆向深度优先遍历所访问到的顶点集便是有向图G中的一个强连通分量的顶点集。\n（5）为了实现以上遍历，需要对深度优先遍历算法作以下修改\n—1.在进入DFStraverse函数时，对计数变量count进行初始化，count=0\n—2.在退出DFS函数之前，将完成搜索的顶点号记录在另一个辅助数组finish【vernum】中，在DFS函数结束之前加上finished【++count】=v\n5.最小生成树\n（1）如果无向图中，边上有权值，则称该无向图为无向网\n（2）如果无向网中的每个顶点都相通，称为连通网\n（3）最小生成树(Minimum Cost Spanning Tree)是代价最小的连通网的生成树，即该生成树上的边的权值和最小\n（4）准则：必须使用且仅使用连通网中的n-1条边来联结网络中的n个顶点；不能使用产生回路的边；各边上的权值的总和达到最小。常用于道路建设、线路铺设等应用中计算成本。\n6.Prim普里姆算法生成最小生成树\n（1）假设N=(V,E)是连通网\n（2）TE是N上最小生成树中边的集合\n—1.U={u0}，(u0属于V), TE={}\n—2.在所有u属于U,v属于V-U的边(u,v)属于E中找一条代价最小的边(u,v0)并入集合TE，同时v0并入U\n—3.重复2，直到U=V。T=(V，TE)即为所求最小生成树。\n\n（记得每一次画上所有点！）\n\n（Prim V1-Vn mindis flag U)\n（3）在生成树的构造过程中，图中 n 个顶点分属两个集合：已落在生成树上的顶点集 U 和尚未落在生成树上的顶点集V-U，应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边逐渐加入TE,相应顶点加入U中。\n7.Kruscal克鲁斯卡尔算法生成最小生成树\n（1）假设N=(V,E)是连通网\n—1.非连通图T={V,{}}，图中每个顶点自成一个连通分量\n—2.在E中找一条代价最小，且其两个顶点分别依附不同的连通分量的边，将其加入T中\n—3.重复2，直到T中所有顶点都在同一连通分量上\n\n（2）把边按照从小到大的顺序排序；\n判断边的顶点不在同一个联通分支-》并查集。\n8.生成最小生成树：\n当为稠密图（邻接矩阵）prim算法 O(n^2)\n当为稀疏图（邻接表）Kruscal算法O(eloge)\n\n五、最短路径1.最短路径\n（1）最短路径是求从图（或网）中某一顶点，到其余各顶点的最短路径\n（2）最短路径与最小生成树主要有三点不同：\n—1.最短路径的操作对象主要是有向图(网)，而最小生成树的操作对象是无向图\n—2.最短路径有一个始点，最小生成树没有（Prim算法有起点）\n—3.最短路径关心的是始点到每个顶点的路径最短，而最小生成树关心的是整个树的代价最小\n2.基本概念\n（1）路径长度:一条路径上所经过的边的数目\n（2）带权路径长度:路径上所经过边的权值之和\n（跟树的带权路径长度区分好！）\n（3）最短路径:(带权)路径长度(值)最小的那条路径\n（4）最短路径长度或最短距离:最短路径长度\n3.Dijkstra算法(O(n^3))\n（1）Dijkstra算法思想：采用按路径长度递增的次序产生最短路径\n—1.设置两个顶点的集合U和T，集合U中存放已找到最短路径的顶点，集合T中存放当前还未找到最短路径的顶点。\n—2.初始状态时，集合U中只包含源点，设为v0；\n—3.然后从集合T中选择到源点v0路径长度最短的顶点u加入到集合U中；\n—4.集合U中每加入一个新的顶点u都要修改源点v0到集合T中剩余顶点的当前最短路径长度值，集合T中各顶点的新的当前最短路径长度值，为原来的当前最短路径长度值与从源点过顶点u到达该顶点的路径长度中的较小者。\n—5.转到3，此过程不断重复，直到集合T中的顶点全部加入到集合U中为止。\n（2）在Dijkstra算法中，引进了一个辅助向量D\n每个分量D[i]表示当前所找到的从始点到每个终点vi的最短路径长度。\nD[i]初值为始点v0到各终点vi的直接距离，即若从始点到某终点有(出)弧，则为弧上的权值，否则为∞。\n（3）得到路径：\n—1.设置另一个辅助向量path[]，用来存放得到的从源点v0到其余各顶点的最短路径上到达目标顶点的前一顶点下标。\n—2.为每一个顶点i设置辅助向量pathi，用来存放得到的从源点v0到该顶点的最短路径中依次访问过的顶点。第一个值是路径上的顶点数。\n题目：对下图求从V0出发到各顶点的最短路径。\n\n\n（最后的过程5“无”一定要加，且要补充最后最短路径的结果!)\n4.求n个顶点之间的最短路径\n（1）用Dijkstra算法也可以求得有向图G=(V，E)中每一对顶点间的最短路径。\n方法是： 设置二维数组D [i] [j]，数组每一行D[i]表示从顶点vi出发到其它顶点的最短路径，即每次以一个不同的顶点vi为源点重复Dijkstra算法便可求得每一对顶点间的最短路径，时间复杂度是O(n^3) 。\n（2）弗罗伊德(Floyd)算法，其时间复杂度仍是O(n^3) ， 但算法形式更为简明，步骤更为简单，数据结构是基于图的邻接矩阵。\n\n将图中一个顶点Vk 加入到S中，修改A[i] [j]的值，修改方法是：\nA[i] [j] = Min{ A[i] [j] , (A[i] [k]+A[k] [j]) }\n找路径：定义二维数组Path[n] [n] (n为图的顶点数) ，元素Pathi保存从Vi到Vj的最短路径所经过的顶点。若Path[i] [j]=k：从Vi到Vj 经过Vk ，最短路径序列是(Vi , …, Vk , …, Vj) ，则路径序列：(Vi , …, Vk)和(Vk , …, Vj)一定是从Vi到Vk和从Vk到Vj 的最短路径。从而可以根据Path[i] [k]和Path[k] [j]的值再找到该路径上所经过的其它顶点，…依此类推。\n初始时令Path[i] [j]=-1，表示从Vi到Vj 不经过任何(S中的中间)顶点。当某个顶点Vk加入到S中后使A[i] [j]变小时，令Path[i] [j]=k。\n六、有向无环图及其应用1.AOV网（有向图！）\n（1）如果用有向图的顶点表示活动，用弧表示活动间的优先关系，则称该有向图为顶点表示活动的网AOV(Activity On Vertex Network)\n（2）AOV的应用包括流程图、工程安排等。对AOV网，应判定图中不存在环，因为存在环意味着某项活动应以自己为先决条件。\n2.有向无环图(DAG)Directed Acycline Graph\n3.检查有向图中是否有回路：\n（1）深度优先搜索 ：从某个顶点v出发，进行DFS，如果存在一条从顶点u到v的回边，则有向图中存在环。\n（2）拓扑排序：由严格偏序定义得到的拓扑有序的操作称拓扑排序。\n若集合X上的关系R是：⑴.自反的：x R x⑵.反对称的：x R y =&gt; y R x⑶.传递的：xRy &amp; yRz =&gt; xRz 则称R是集合X上的偏序关系。\n全序：设关系R是集合X上的偏序，如果对每个x,y属于X，必有xRy或者yRx，则称R是X上的全序关系。\n偏序：指集合中仅有部分成员之间可比较。\n全序：指集合中全体成员之间均可比较\n算法：⑴.在有向图中选一个没有前驱的顶点(无入度)且输出之⑵.从图中删除该顶点和所有以它为尾的弧；重复⑴⑵两步，直到所有顶点输出为止或跳出循环。\n（3）拓扑排序与AOV网：\n拓扑排序可检测AOV网是否存在环。如果通过拓扑排序能将AOV网络的所有顶点都排入一个拓扑有序的序列中, 则该网络中必定不会出现有向环。反之其中存在环。\n4.拓扑排序实现\n（1）没有前驱的顶点 == 入度为零的顶点\n（2）删除顶点及以它为尾的弧 == 弧头顶点的入度减1\n题目:写出某AOV网的邻接表存储结构如下，写出分别用队列和栈存储入读为零的顶点时的拓扑排序序列。\n\n栈的拓扑：C4,C0,C2,C1,C3,C5\n队列的拓扑：C2,C4,C0,C1,C5,C3\n5.AOV-网\n（1）如果用有向图的顶点表示事件，用弧表示活动，则称该有向图为边表示活动的网AOE(Activity On Edge)\n（2）AOE应该同样是DAG，AOE包括估算工程的完成时间。\n注意：AOE网和AOV网都是有向无环图，不同在于AOE网中的边有权值；而AOV网中的边无权值，仅表示顶点之间的前后关系。\n6.关键路径\n（1）工程问题的AOE网中，从工程开始(顶点)到工程结束(顶点)之间路径长度最长的路径叫关键路径（最长路径！）\n（2）提前完成关键路径上的活动，工程进度会加快\n（3）提前完成非关键路径上的活动，对工程无帮助\n7.关键活动\n（1）关键路径上的所有活动称为关键活动\n（2）找到工程AOE中的所有关键活动，即找到了关键路径\n8.关键活动有关的量\n（1）e(i)：活动ai最早开始时间\n（2）l(i)：活动ai最迟开始时间\n（3）l(i)-e(i)：活动ai开始时间余量\n（4）如果l(i)=e(i)，则称活动ai为关键活动\n（5）ve(j)：事件vj最早开始时间\n（6）vl(j)：事件vj最迟开始时间\n（7)e(i)=ve(j)\n（8）l(i)=vl(k)-dut() 　\ndut()为活动ai的持续时间\n（9）活动的最早开始时间是活动的弧尾事件的最早发生时间，\n活动的最晚发生时间是活动的弧头事件的最晚发生时间减去活动的持续时间。\nj———&gt;k(此边即活动的编号为i)\n（10）从ve(0)=0开始向前递推（事件的最早发生时刻）\n事件的最早发生时间是以其为弧头事件的所有弧尾事件的最早发生时间与对应弧活动的持续时间之和的最大值\n（11）从vl(n-1)=ve(n-1)起向后递推（事件的最晚发生时刻）\n事件的最晚发生时间是以其为弧尾事件的所有弧头事件的最晚发生时间与对应弧活动的持续时间之差的最小值。\n9.求关键活动算法（先计算事件，再计算活动）\n（1）从始点v0出发，令ve[0]=0（源点），按拓扑有序求ve[j]\n即vk为vj的任意后续\nve[k]=max{ve[j]+Weight(vj,vk)}\n（2）从终点vn-1出发，令vl[n-1]=ve[n-1]（汇点），按逆拓扑有序求vl[i]\n即vk为vj的任意前驱\nvl[k]=min{ vl[j]-Weight(vk,vj)}\n（简单记忆：我们都想晚点开学早点放假，晚点开学即最早开始取max，早点放假即最晚开始取min)\n（3）根据各顶点的ve和vl值，求每条弧(活动)ai的最早开始时间e[ai]和最迟开始时间l[ai]\n若边表示活动ai,则e(i)=ve[k]\nl[i]=vl[j]-Weight(vk,vj)\n（4）如果e[ai]=l[ai]，则ai为关键活动(e[i]-l[i]==0)\n（5）如果ve[i]=vl[i]，则vi为关键路径上的事件\n题目：下表给出了某工程各工序之间的优先关系和各工序所需的时间。\n\n\n\n\n工序代号\nA\nB\nC\nD\nE\nF\nG\nH\n\n\n\n\n所需时间\n3\n2\n2\n3\n4\n3\n2\n1\n\n\n先驱工序\n-\n-\nA\nA\nB\nB\nC,E\nD\n\n\n\n\n问: 该工程是否能够顺利进行? 如果能，请问要花多长时间？ 缩短那些工序可以缩短整个工程的完工时间？\n\n第九章：查找一、查找的概念1.查找表\n（1）查找表是由同一类型的数据元素(或记录)构成的集合\n（2）对查找表的操作:\n—1.查询某个“特定的”数据元素是否在查找表中；\n—2.检索某个“特定的”数据元素的各种属性；\n—3.在查找表中插入一个数据元素；\n—4.从查找表中删去某个数据元素\n（3）静态查找表：仅作查询和检索操作的查找表。\n（4）动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素。\n2.关键字\n（1）关键字是数据元素（或记录）中某个数据项的值，用以标识（识别）一个数据元素（或记录\n注意：关键字是某个数据项的值！不是数据元素\n（2）主关键字：可以识别唯一的一个记录的关键字\n（3）次关键字：能识别若干记录的关键字\n3.查找\n（1）查找是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。\n（2）查找成功：在查找表中查找到指定的记录。\n（3）查找不成功：在查找表中没有找到指定记录。\n4.衡量查找算法的标准\n（1）时间复杂度\n（2）空间复杂度\n（3）平均查找长度ASL\n5.平均查找长度ASL\n（1）平均查找长度定义为确定记录在表中的位置所进行的和关键字比较的次数的平均值。\n（2）ASL = ∑ PiCi （i为1到n）\n\nn为查找表的长度，即表中所含元素的个数；Pi为查找第i个元素的概率(∑Pi=1)；Ci是查找第i个元素时同给定值K比较的次数。\n二、静态查找表（顺序、折半、分块）1.顺序查找\n（1）顺序查找算法是顺序表的查找方法。\n（2）在顺序查找算法中，以顺序表或线性链表表示静态查找表。\n（3）顺序查找算法：\n—1.从表中最后一个记录开始\n—2.逐个进行记录的关键字和给定值的比较\n—3.若某个记录比较相等，则查找成功\n—4.若直到第1个记录都比较不等，则查找不成功\n（4）算法性能分析\n对顺序表而言，Ci=n-i+1\n在等概率查找的情况下，Pi=1/n\nASL（成功）=n*P1 +(n-1)P2 +…+ 2Pn-1+ Pn = (n+1)/2\n（5）顺序查找(不等概率)\n如果被查找的记录概率不等时，取 Pn≥Pn-1≥···≥P2≥P1；\n若查找概率无法事先测定，则查找过程采取的改进办法是，在每次查找之后，将刚刚查找到的记录直接移至表尾的位置上。\n（6）特点：\n优点：1.简单2.适应面广(对表的结构无任何要求)\n缺点：1.平均查找长度较大2.特别是当n很大时，查找效率很低。\n2.折半查找（有序表！）\n（1）折半查找算法是有序表的查找方法。\n（2）在折半查找算法中，静态查找表按关键字大小的次序，有序地存放在顺序表中。\n（3）折半查找的原理是：1.先确定待查记录所在的范围(前部分或后部分)2.逐步缩小(一半)范围直到找(不)到该记录为止。\n（4）算法：\n—1.n个对象从小到大存放在有序顺序表ST中，k为给定值\n—2.设low、high指向待查元素所在区间的下界、上界，即low=1, high=n\n—3.设mid指向待区间的中点，即mid=(low+high)/2\n—4.让k与mid指向的记录比较若k=ST[mid].key，查找成功\n若k&lt;ST[mid].key，则high=mid-1 [上半区间]\n若k&gt;ST[mid].key，则low=mid+1 [下半区间]\n—5.重复3,4操作，直至low&gt;high时，查找失败。（严格大于）\n（5）折半查找（判定树）\n判定树：描述查找过程的二叉树。\n有n个结点的判定树的深度为floor(log2(n)) +1（与含有 n 个结点的完全二叉树的深度相同）\n折半查找法在查找过程中进行的比较次数最多不超过floor(log2(n)) +1\n题目：假设某有序表查找中有12个元素，请问该查找表查找成功时的平均查找长度为多少？（查找失败的ASL：为白块到根结点的路径长度之和/白块个数；ASL=1/2  成功+1/2 失败）\n\n（6）性能分析\n设有序表的长度n=2^h-1（即h=log2(n+1)）,则描述折半查找的判定树是深度为h的满二叉树。\n树中层次为1的结点有1个，层次为2的结点有2个，层次为h的结点有2^(h-1)个。\n假设表中每个记录的查找概率相等，则查找成功时折半查找的平均查找长度：ASL（成功）=[(n+1)/n]*log2(n+1)-1\n（7）特点\n折半查找的效率比顺序查找高(特别是在静态查找表的长度很长时)。\n折半查找只能适用于有序表，并且以顺序存储结构存储。\n3.分块查找\n（1）分块查找是一种索引顺序表(分块有序表)查找方法，是折半查找和顺序查找的简单结合。\n（2）索引顺序表(分块有序表)将整个表分成几块，块内无序，块间有序。\n（3）所谓块间有序是指后一块表中所有记录的关键字均大于前一块表中的最大关键字。\n（4）分块查找(分块有序表)\n主表：用数组存放待查记录,每个数据元素至少含有关键字域。\n索引表：每个结点含有最大关键字域和指向本块第一个结点的指针。\n（5）采用折半查找方法在索引表中找到块[第2块]，用顺序查找方法在主表对 应块中找到记录[第3记录]。\n（6）性能分析：\n若将长度为n的表分成b块，每块含s个记录，并设表中每个记录查找概率相等。\n用折半查找方法在索引表中查找索引块，ASL块间≈log2(n/s+1)\n用顺序查找方法在主表对应块中查找记录，ASL块内=s/2\nASL(成功)≈log2(n/s+1) + s/2\n三、动态查找表1.动态查找表\n（1）表结构本身是在查找过程中动态生成的\n（2）若表中存在其关键字等于给定值key的记录,表明查找成功；\n（3）否则插入关键字等于key的记录。\n2.二叉排序树（将判定树的结点信息从下标改为数据即为二叉排序树）\n（1）空树或者是具有如下特性的二叉树：\n—⑴.若它的左子树不空，则左子树上所有结点的值均小于根结点的值；\n—⑵.若它的右子树不空，则右子树上所有结点的值均大于根结点的值；\n—⑶.它的左、右子树也都分别是二叉排序树。\n（2）二叉排序树又称二叉查找树\n查找算法： 给定值与根结点比较：—1.若相等，查找成功—2.若小于，查找左子树—3.若大于，查找右子树\n生成举例：\n题目：画出在初始为空的二叉排序树中依次插入56,64,92,80,88,75时该树的生长全过程\n\n（3）二叉排序树(插入)\n二叉排序树是一种动态树表；\n当树中不存在查找的结点时，作插入操作；\n新插入的结点一定是叶子结点（只需改动一个结点的指针）；\n该叶子结点是查找不成功时路径上访问的最后一个结点左孩子或右孩子(新结点值小于或大于该结点值)。（最后一个！）\n（4）中序遍历二叉排序树，可得到一个关键字的有序序列。\n（5）二叉排序树(删除)\n删除二叉排序树中的一个结点后，必须保持二叉排序树的特性（左子树的所有结点值小于根结点，右子树的所有结点值大于根结点）也即保持中序遍历后，输出为有序序列。\n被删除结点具有以下三种情况：1.是叶子结点（直接删除结点，并让其父结点指向该结点的指针变为空）；2.只有左子树或右子树（删除结点,让其父结点指向该结点的指针指向其左子树(或右子树),即用孩子结点替代被删除结点即可）；3.同时有左、右子树。（以中序遍历时的直接前驱s替代被删除结点p，然后再删除该直接前驱（只可能有左孩子））\n\n（6）性能分析\n\n（注意根算1！）\n对于每一棵特定的二叉排序树，均可按照平均查找长度的定义来求它的 ASL 值。\n显然，由值相同的 n 个关键字，构造所得的不同形态的各棵二叉排序树的平均查找长度的值不同，甚至可能差别很大。\n在最坏的情况下，二叉排序树为近似线性表时(如以升序或降序输入结点时)，其查找深度为n量级，即其时间复杂性为O(n)\n（7）特性\n一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列（通过中序遍历）。\n插入新记录时，只需改变一个结点的指针，相当于在有序序列中插入一个记录而不需要移动其它记录。\n二叉排序树既拥有类似于折半查找的特性，又采用了链表作存储结构。\n但当插入记录的次序不当时(如升序或降序)，则二叉排序树深度很深，增加了查找的时间。\n3.平衡二叉树\n（1）平衡二叉树是二叉排序(查找)树的另一种形式\n（2）平衡二叉树又称AVL树(Adelsen-Velskii and Landis)\n（3）其特点为：树中每个结点的左、右子树深度之差的绝对值不大于1，即|hL-hR|≤1\n（4）平衡因子：每个结点附加一个数字, 给出该结点左子树的高度减去右子树的高度所得的高度差,这个数字即为结点的平衡因子balance （左减右！）\n（5）AVL树任一结点平衡因子只能取 -1, 0, 1\n（6）平衡二叉树(删除)与二叉排序树相同\n如果被删结点A最多只有一个孩子，那么将结点A从树中删去，并将其双亲指向它的指针指向它的唯一的孩子，并作平衡化处理。\n如果被删结点A没有孩子，则直接删除之，并作平衡化处理。\n如果被删结点A有两个子女，则用该结点的直接前驱S替代被删结点，然后对直接前驱S作删除处理(S只有一个孩子或没有孩子)。\n4.AVL平衡化旋转\n（1）如果在一棵平衡的二叉查找树中插入一个新结点，造成了不平衡。此时必须调整树的结构，使之平衡化。\n（2）平衡化旋转(处理)有两类：\n—1.单向旋转 (单向右旋和单向左旋)\n\n—2.双向旋转 (先左后右旋转和先右后左旋转)\n\n（3）每插入一个新结点时, AVL树中相关结点的平衡状态会发生改变。\n—1.在插入一个新结点后，需要从插入位置沿通向根的路径回溯，检查各结点的平衡因子。\n—2.如果在某一结点发现高度不平衡，停止回溯。(出现2或者-2)\n—3.从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点。（做旋转操作）\n题目：画出在初始为空的AVL树中依次插入64,5,13,21,19,80,75,37,56时该树的生长过程，并在有旋转时说出旋转的类型。\n\n四、哈希表1.哈希表（散列表）\n（1）哈希(Hash)表又称散列表散列表，是一种直接计算记录存放地址的方法，它在关键码与存储位置之间直接建立了映象。\n（2）哈希函数是从关键字空间到存储地址空间的一种映象。\n（3）哈希函数在记录的关键字与记录的存储地址之间建立起一种对应关系。可写成：addr(ai)= H(keyi)，H(·)为哈希函数k，eyi是表中元素ai关键字,addr(ai)是存储地址。\n2.哈希表(查找)\n（1）哈希查找也叫散列查找，是利用哈希函数进行查找的过程。\n—1.首先利用哈希函数及记录的关键字计算出记录的存储地址.。\n—2.然后直接到指定地址进行查找\n—3.不需要经过比较，一次存取就能得到所查元素\n3.哈希表(冲突)\n（1）不同的记录，其关键字通过哈希函数的计算，可能得到相同的地址。把不同的记录映射到同一个散列地址上，这种现象称为冲突。\n4.哈希表(定义)\n（1）根据设定的哈希函数 H(key) 和所选中的处理冲突的方法\n（2）将一组关键字映象到一个有限的、地址连续的地址集 (区间) 上\n（3）并以关键字在地址集中的“象”作为相应记录在表中的存储位置\n（4）如此构造所得的查找表称之为“哈希表”\n5.哈希函数(均匀性)\n（1）哈希函数实现的一般是从一个大的集合（部分元素，空间位置上一般不连续）到一个小的集合（空间连续）的映射\n（2）一个好的哈希函数，对于记录中的任何关键字，将其映射到地址集合中任何一个地址的概率应该是相等的\n（3）即关键字经过哈希函数得到一个“随机的地址“\n6.哈希函数(要求)\n（1）哈希函数应是简单的，能在较短的时间内计算出结果。\n（2）哈希函数的定义域尽可能包括需要存储的全部关键字，如果散列表允许有 m 个地址时，其值域必须在 0 到 m-1 之间。\n（3）散列函数计算出来的地址应能均匀分布在整个地址空间中。\n7.哈希函数(直接定址法)\n（1）直接定址法中，哈希函数取关键字的线性函数： H(key) = a x key + b（其中a和b为常数）\n（2）直接定址法仅适合于地址集合的大小与关键字集合的大小相等的情况\n（3）当a=1时，H(key)=key，即用关键字作地址\n（4）在实际应用中能使用这种哈希函数的情况很少\n8.哈希函数(数字分析法)\n（1）假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)。\n（2）分析关键字集中的全体\n（3）从中提取分布均匀的若干位或它们的组合作为地址\n\n（4）数字分析法仅适用于事先明确知道表中所有关键码每一位数值的分布情况\n（5）数字分析法完全依赖于关键码集合\n（6）如果换一个关键码集合，选择哪几位要重新决定\n9.哈希函数(平方取中法)\n（1）以关键字的平方值的中间几位作为存储地址。\n（2）求“关键字的平方值” 的目的是“扩大差别”\n（3）同时平方值的中间各位又能受到整个关键字中各位的影响。\n（4）此方法在词典处理中使用十分广泛。它先计算构成关键码的标识符的内码的平方, 然后按照散列表的大小取中间的若干位作为散列地址。\n\n（5）平方取中法是较常用的构造哈希函数的方法\n（6）适合于关键字中的每一位都有某些数字重复出现且频度很高的情况\n（7）中间所取的位数，由哈希表长决定\n10.哈希函数(折叠法)\n（1）将关键字分割成位数相同的若干部分(最后部分的倍数可以不同)，然后取它们的叠加和(舍去进位)为哈希地址。\n（2）移位叠加:将分割后的几部分低位对齐相加。\n（3）间界叠加:从一端沿分割界来回折送，然后对齐相加。\n\n（4）折叠法适合于关键字的数字位数特别多，而且每一位上数字分布大致均匀的情况。\n11.哈希函数(除留余数法)\n（1）取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址： H(key) = key MOD p ( p≤m )\nm为表长 p为不大于m的素数或是不含20以下的质因子\n（2）除留余数法是一种最简单、最常用的构造哈希函数的方法\n（3）不仅可以对关键字直接取模(MOD)，也可在折叠、平方取中等运算之后取模\n12.处理冲突的方法\n“处理冲突” 的实际含义是：为产生冲突的地址寻找下一个哈希地址。\n处理冲突的方法主要有三种：1.开放定址法2.再哈希法3.链地址法\n13.处理冲突的方法(开放定址法)\n（1）为产生冲突的地址 H(key) 求得一个地址序列： H0, H1, H2, …, Hs，1≤s≤m-1\n（2）Hi = [H(key)+di] MOD m\ni=1,2,…,s\nH(key)为哈希函数\nm为哈希表长\n（3）开放定址法－线性探测：\n当di取1,2,3,…,m-1时，称这种开放定址法为线性探测再散列\n\n（4）开放定址法－二次探测：\n当di取= 1^2, -1^2，2^2, -2^2，3^2,…时，称这种开放定址法为二次探测再散列\n（5）特性\n当di取= 1^2, -1^2，2^2, -2^2，3^2,…时，称这种开放定址法为二次探测再散列；\n二次探测再散列：m=4j+3的素数时总能找到。\n缺点：易产生“二次聚集”，即在处理同义词的冲突过程中，又添加了非同义词的冲突，对查找不利\n14.处理冲突的方法(再哈希法)\n（1）构造若干个哈希函数，当发生冲突时，计算下一个哈希地址，直到冲突不再发生，即：Hi = Rhi(key) i=1,2,……k\nRhi—不同的哈希函数\n（2）特点：不易产生聚集，但增加计算时间\n15.处理冲突的方法(链地址法)\n（1）将所有哈希地址相同的记录都链接在同一链表中\n（2）表头插入和表后插入\n题目：已知一组关键字(19,14,23,1,68,20,84,27,55,11,10,79)哈希函数为： H(key)=key MOD 13,用链地址法处理冲突[表头插入]\n（注意左侧数组表示和空符号^)\n\n16.哈希表的实现\n17.哈希表的性能分析\n（1）虽然哈希表在关键字与记录的存储位置之间建立了直接映象，但由于“冲突”的产生，使得哈希表的查找过程仍然是一个给定值和关键字进行比较的过程\n（2）因此，仍需以平均查找长度(ASL)作为衡量哈希表的查找效率的量度\n（3）决定哈希表查找的ASL的因素：\n—1.选用的哈希函数\n—2.选用的处理冲突的方法\n—3.哈希表的装填因子：哈希表的装填因子是哈希表中填入的记录数与哈希表的长度的比值，即：α = 哈希表中填入的记录数 / 哈希表的长度。装填因子α标志哈希表的装满程序。\n注意：散列表的平均查找长度依赖于装填因子，不直接依赖于n或m\n（4）装填因子α越小，发生冲突的可能性就越小；装填因子α越大，发生冲突的可能性就越大。\n（5）平均查找长度ASL:\n线性探测再散列的哈希表查找成功时：ASL ≈ (½)(1 + 1/(1-α))\nASL(成功)=(1/2)*(1+1/(1-记录数/哈希表长度))\n二次探测再散列的哈希表查找成功时：ASL ≈ -(1/α)ln(1-α)\nASL(成功)=-(1/(记录数/哈希表长度))ln(1-记录数/哈希表长度)\n链地址法处理冲突的哈希表查找成功时：ASL ≈ (1 + α/2)\nASL(成功)=(1+(记录数/哈希表长度)/2)\n五、B-树[结点结构]1.B-树是一种特殊的多路平衡查找树\n2.R.Bayer和E.Maccreight于1970年提出\n3.B-树是一种在外存文件系统中常用的动态索引\n4.技术磁盘中文件的读写以“盘块”为单位进行\n5.将关键字索引信息，放在盘块中，可以加快数据的查找速度\n6.结点结构：\n（1）Ki是关键字，且Ki&lt;Ki+1\n（2）Ai是指向子树根结点的指针\n（3）Ai-1所指子树中所有结点的关键字均小于Ki\n（4）Ai 所指子树中所有结点的关键字均大于Ki\n（5）对于m阶B-树，ceil(m/2) -1≤n≤m-1 (分支数比关键字数目多一)\n\n7.m阶B-树定义:\n（1）树中每个结点至多有m棵子树（m-1个关键字）\n（2）若根结点不是叶子结点，则至少有两棵子树\n（3）除根之外的所有非终端结点至少有 ceil(m/2) 棵子树\n（4）所有叶子结点，都出现在同一层次上，且不带信息（可以看作是查找失败的结点，指向这些结点的指针为空指针）\n题目:3阶B-树（11个结点）\n\n(1)关键字比分支数少一（B-）,m=3(3阶)\n(2)关键字数目为n,ceil(3/2)-1&lt;=n&lt;=3-1即1&lt;=n&lt;=2\nceil(m/2)-1&lt;=n&lt;=m-1\n(3)如图深度为3，结点数最少(所有都是关键字n=1,分支为2)：2^3-1=7;结点数最多(所有都是关键字n=2,分支为3)：1+3+3^2=13\n结点数最少：2^h-1;结点数最多：1+m+m^2+..+m^(h-1)\n第十章：内部排序一、排序1.排序\n（1）排序：将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列\n（2）内部排序：在排序期间数据对象全部存放在内存的排序；\n（3）外部排序：在排序期间全部对象个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。\n2.排序基本操作：\n（1）比较：比较两个关键字的大小\n（2）移动：将记录从一个位置移动至另一个位置\n3.排序时间复杂度\n排序的时间复杂度可用算法执行中的记录关键字比较次数与记录移动次数来衡量。\n4.排序方法的稳定性\n（1）如果在记录序列中有两个记录r[i]和r[j], 它们的关键字 key[i] == key[j] , 且在排序之前, 记录r[i]排在r[j]前面。\n（2）如果在排序之后, 记录r[i]仍在记录r[j]的前面, 则称这个排序方法是稳定的, 否则称这个排序方法是不稳定的。\n二、插入排序1.直接插入排序\n（1）当插入第i(i≥1)个对象时, 前面的r[0], r[1], …, r[i-1]已经排好序。\n（2）用r[i]的关键字与r[i-1], r[i-2], …的关键字顺序进行比较(和顺序查找类似)，如果小于，则将r[x]向后移动(插入位置后的记录向后顺移)\n（3）找到插入位置即将r[i]插入\n（4）每步将一个待排序的对象, 按其关键字大小, 插入到前面已经排好序的有序表的适当位置上, 直到对象全部插入为止。\n\n（5）关键字比较次数和记录移动次数与记录关键字的初始排列有关。\n（6）最好情况下, 排序前记录已按关键字从小到大有序, 每趟只需与前面有序记录序列的最后一个记录比较1次, 移动2次记录, 总的关键字比较次数为 n-1, 记录移动次数为 2(n-1)。\n（7）最坏情况下, (i从1开始，下标从0开始)第i趟时第i个记录必须与前面i个记录都做关键字比较, 并且每做1次比较就要做1次数据移动。则总关键字比较次数KCN和记录移动次数RMN分别为\n\n（8）在平均情况下的关键字比较次数和记录移动次数约为 n^2/4。\n（9）直接插入排序的时间复杂度为O(n^2)。\n（10）直接插入排序是一种稳定的排序方法。\n（11）直接插入排序最大的优点是简单，在记录数较少时，是比较好的办法。\n2.折半插入排序\n（1）折半插入排序在查找记录插入位置时，采用折半查找算法\n（2）折半查找比顺序查找快, 所以折半插入排序在查找上性能比直接插入排序好\n（3）但需要移动的记录数目与直接插入排序相同(为O(n2))\n（4）折半插入排序的时间复杂度为O(n^2)。\n（5）折半插入排序是一种稳定的排序方法\n3.希尔排序\n（1）从直接插入排序可以看出，当待排序列为正序时，时间复杂度为O(n)\n（2）若待排序列基本有序时，插入排序效率会提高希尔排序方法是先将待排序列分成若干子序列分别进行插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序\n（3）希尔排序又称为缩小增量排序。\n\n（4）算法：\n首先取一个整数 gap &lt; n(待排序记录数) 作为间隔, 将全部记录分为 gap 个子序列, 所有距离为 gap 的记录放在同一个子序列中。（gap为组数！）\n在每一个子序列中分别施行直接插入排序。然后缩小间隔 gap, 例如取 gap = gap/2。\n重复上述的子序列划分和排序工作，直到最后取gap = 1, 将所有记录放在同一个序列中排序为止。\n（5）算法分析：\n开始时 gap 的值较大, 子序列中的记录较少, 排序速度较快。\n随着排序进展, gap 值逐渐变小, 子序列中记录个数逐渐变多,由于前面大多数记录已基本有序, 所以排序速度仍然很快。\nGap的取法有多种。 shell 提出取 gap = n/2，gap = gap/2，直到gap = 1。\n对特定的待排序记录序列，可以准确地估算关键字的比较次数和记录移动次数。\n希尔排序所需的比较次数和移动次数约为n^1.3\n当n趋于无穷时可减少到n x(log2 n)^2\n希尔排序的时间复杂度约为O(n x(log2 n)^2)\n希尔排序是一种不稳定的排序方法\n三、快速排序1.冒泡排序\n（1）设待排序记录序列中的记录个数为n(下标从1到n)。\n（2）一般地，第i趟起泡排序从1到n-i+1依次比较相邻两个记录的关键字，如果发生逆序，则交换之\ni=1时，为第一趟排序，关键字最大的记录将被交换到最后一个位置\ni=2时，为第二趟排序，关键字次大的记录将被交换到最后第二个位置\n关键字小的记录不断上浮(起泡)，关键字大的记录不断下沉(每趟排序最大的一直沉到底)\n（3）其结果是这n-i+1个记录中，关键字最大的记录被交换到第n-i+1的位置上，最多作n-1趟。\n（4）最好情况：在记录的初始排列已经按关键字从小到大排好序时,此算法只执行一趟起泡,做n-1次关键字比较,不移动记录。\n（5）最好情况：在记录的初始排列已经按关键字从小到大排好序时,此算法只执行一趟起泡,做n-1次关键字比较,不移动记录\n\n（6）起泡排序的时间复杂度为O(n^2)\n（7）起泡排序是一种稳定的排序方法\n（8）每一趟可以确定一个数的位置（从后往前）\n2.快速排序\n（1）任取待排序记录序列中的某个记录(例如取第一个记录)作为基准(枢),按照该记录的关键字大小,将整个记录序列划分为左右两个子序列\n（2） 左侧子序列中所有记录的关键字都小于或等于基准记录的关键字\n（3）右侧子序列中所有记录的关键字都大于基准记录的关键字\n（4）基准记录则排在这两个子序列中间(这也是该记录最终应安放的位置)。\n（5）然后分别对这两个子序列重复施行上述方法，直到所有的记录都排在相应位置上为止。\n（6）基准记录也称为枢轴（或支点）记录。\n（7）算法：\n取序列第一个记录为枢轴记录，其关键字为Pivotkey。\n指针low指向序列第一个记录位置。\n指针high指向序列最后一个记录位置。\n一趟排序(某个子序列)过程：\n—1.从high指向的记录开始,向前找到第一个关键字的值小于Pivotkey的记录,将其放到low指向的位置,low+1\n—2.从low指向的记录开始,向后找到第一个关键字的值大于Pivotkey的记录,将其放到high指向的位置,high-1\n—3.重复1,2，直到low=high，将枢轴记录放在low(high)指向的位置\n对枢轴记录前后两个子序列执行相同的操作，直到每个子序列都只有一个记录为止。\n\n（8）性能分析：\n快速排序是一个递归过程。\n利用序列第一个记录作为基准，将整个序列划分为左右两个子序列。只要是关键字小于基准记录关键字的记录都移到序列左侧。\n如果每次划分对一个记录定位后, 该记录的左侧子序列与右侧子序列的长度相同, 则下一步将是对两个长度减半的子序列进行排序, 这是最理想的情况。\n可以证明, 快速排序的平均计算时间也是O(nlog2 n)。\n实验结果表明: 就平均计算时间而言, 快速排序是所有内排序方法中最好的一个。\n但快速排序是一种不稳定的排序方法。\n（9）在最坏情况下, 即待排序记录序列已经按其关键字从小到大排好序, 其递归树成为单支树, 时间复杂度达O(n2)\n每次划分只得到一个比上一次少一个记录的子序列。\n必须经过n-1 趟才能把所有记录定位,\n而且第 i 趟需要经过 n-i 次关键字比较才能找到第 i 个记录的安放位置，总的关键字比较次数将达到：\n\n（10）改进：枢轴记录取low、high、(low+high)/2三者指向记录关键字居中的记录。\n四、选择排序1.简单选择排序\n（1）每一趟(例如第i趟,i=0,1,…,n-2)在后面n-i个待排序记录中选出关键字最小的记录,与第i个记录交换。\n\n（2）每趟可确定一个数（从前往后）\n算法中的几个表示关系的缩写EQ 就是 EQUAL等于\nNE 就是 NOT EQUAL不等于\nGT 就是 GREATER THAN大于　\nLT 就是 LESS THAN小于\nGE 就是 GREATER THAN OR EQUAL 大于等于\nLE 就是 LESS THAN OR EQUAL 小于等于\n（2）性能分析：\n直接选择排序的关键字比较次数 KCN 与记录的初始排列无关。\n设整个待排序记录序列有n个记录,则第i趟选择具有最小关键字记录所需的比较次数总是 n-i-1次。总的关键字比较次数为：\n\n记录的移动次数与记录序列的初始排列有关。\n当这组记录的初始状态是按其关键字从小到大有序的时候,记录的移动次数RMN=0,达到最少。\n最坏情况是每一趟都要进行交换，总的记录移动次数为 RMN = 3(n-1)。\n直接选择排序是一种不稳定的排序方法。\n2.堆排序\n（1）设有一个关键字集合，按完全二叉树的顺序存储方式存放在一个一维数组中。对它们从根开始，自顶向下，同一层自左向右从 1 开始连续编号。若满足 Ki &gt;=K2i &amp;&amp; Ki &gt;=K2i+1则称该关键字集合构成一个堆(最大堆)\n注意：只对根有要求，对左右节点大小关系顺序无要求\n（2）最大堆（筛选）：\n输出根结点\n用最后结点代替根结点值（最后的！）\n比较根结点与两个子结点的值，如果小于其中一个子结点，则选择大的子结点与根结点交换\n继续将交换的结点与其子结点比较\n直到叶子结点或者根节点值大于两个子结点\n（2）创建初始堆：\n根据给定的序列，从1至n按顺序创建一个完全二叉树\n由最后一个非终端结点(第n/2个结点)开始至第1个结点，逐步做筛选（第n/2个！）\n（3）性能排序\n对于长度为n的序列，其对应的完全二叉树的深度为k(2^(k-1) &lt;= n &lt;= 2^k)\n对深度为k的堆，筛选算法中进行的关键字比较次数至多为2(k-1)次\n堆排序时间主要耗费在建初始堆和调整建新堆(筛选)上\n建初始堆最多做n/2次筛选\n对长度为n的序列，排序最多需要做n-1次调整建新堆(筛选)\n因此共需要O(nxk)量级的时间k = log2n\n堆排序时间复杂度为O(nlog2n)\n堆排序是一个不稳定的排序方法\n记录数较多时，推荐堆排序\n\n五、归并排序1.归并（有序！）\n（1）归并是将两个或两个以上的有序表合并成一个新的有序表。\n（2）两路归并\n假设待归并两个有序表长度分别为m和n，则两路归并后，新的有序表长度为m+n\n两路归并操作至多只需要m+n次移位和m+n次比较\n因此两路归并的时间复杂度为O(m+n)\n2.2路－归并排序\n（1）将n个记录看成是n个有序序列\n（2）将前后相邻的两个有序序列归并为一个有序序列(两路归并)（前后相邻！）\n（3）重复做两路归并操作，直到只有一个有序序列为止\n\n（4）性能分析：\n如果待排序的记录为n个，则需要做log2n趟两路归并排序\n每趟两路归并排序的时间复杂度为O(n)\n因此2路－归并排序的时间复杂度为O(nlog2n)\n归并排序是一种稳定的排序方法\n\n六、基数排序1.多关键字的排序(最低位优先法LSD)\n（1）从最低位关键字kd起进行排序，\n（2）然后再对高一位的关键字排序，……\n（3）依次重复，直至对最高位关键字k1排序后，便成为一个有序序列\n\n2.链式基数排序\n（1）基数排序：借助“分配”和“收集”对单逻辑关键字进行排序的一种方法\n（2）链式基数排序方法：用链表作存储结构的基数排序\n（3）设置10个队列，f[i]和e[i]分别为第i个队列的头指针和尾指针\n（4）第i趟分配：根据第i位关键字的值，改变记录的指针，将链表中记录分配至10个链队列中，每个队列中记录关键字的第i位关键字相同\n（5）第i趟收集：改变所有非空队列的队尾记录的指针域，令其指向下一个非空队列的队头记录，重新将10个队列链成一个链表\n（6）从最低位至最高位，逐位执行上述两步操作，最后得到一个有序序列\n\n\n（7）性能分析\n若每个关键字有 d 位,关键字的基数为radix 。\n需要重复执行d 趟“分配”与“收集”。\n每趟对 n 个对象进行“分配”，对radix个队列进行“收集”。\n总时间复杂度为O(d(n+radix))。\n若基数radix相同, 对于对象个数较多而关键字位数较少的情况, 使用链式基数排序较好。\n基数排序需要增加n+2radix个附加链接指针。\n基数排序是稳定的排序方法。\n七、各种排序方法比较\n注意：在插入和选择排序中，若初始数据基本正序，则选用插入排序。\n1.时间性能\n（1）\n时间复杂度为 O(nlogn)：快速排序、堆排序和归并排序\n时间复杂度为 O(n^2)：直接插入排序、冒泡排序、简单选择排序\n时间复杂度为 O(n): 基数排序\n（2）当待排记录序列按关键字顺序有序时\n直接插入排序和起泡排序能达到O(n)的时间复杂度；\n快速排序的时间性能蜕化为O(n^2) 。\n（3）简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。\n2.空间性能\n（1）指的是排序过程中所需的辅助空间大小\n（2）所有的简单排序方法(包括：直接插入、起泡和简单选择) 和堆排序的空间复杂度为O(1)\n（3）快速排序为O(logn)，为递归程序执行过程中，栈所需的辅助空间；\n（4）归并排序所需辅助空间最多，其空间复杂度为 O(n);\n（5）链式基数排序需附设队列首尾指针，则空间复杂度为 O(rd)。\n3.排序方法的稳定性能\n口诀：考试情绪不稳定，就快些选堆朋友吧！\n（不稳定：快-&gt;快速排序，些-&gt;希尔排序，选-&gt;直接选择排序，堆-&gt;堆排序）\n（1）稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。\n\n（2） 当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。\n（3）对于不稳定的排序方法，只要能举出一个实例说明即可。\n（4）快速排序、堆排序和希尔排序是不稳定的排序方法。\n（5）所有时间复杂度为O(n^2) 的简单排序算法都是稳定的（直接选择排序算法除外）。\n（6）归并排序和基数排序是稳定的。\n所有排序整理：\n\neg)\n","categories":["笔记"]},{"title":"数学分析笔记其二","url":"/Arknight-notes/posts/27543.html","content":"数分思维导图（分块对比版）\n\n\n\n\n\n\n\n\n\n\n\n\n\n一些公式和解题方法\n\n\n\n\n\n编辑于 2024-07-2707-27 \n","categories":["笔记"]},{"title":"typora图床设置","url":"/Arknight-notes/posts/39599.html","content":"兰空图床安装可以去看另一篇文章 搭建一个属于自己的图床\n一、安装和配置picgo\n首先到picgo的官方仓库下载安装包 Molunerfinn/PicGo: A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder (github.com) 安装过程一路next就ok，安装完成后的界面：\n\n\n安装兰空图床插件\n这里可以直接到picgo的插件设置里面搜索兰空安装插件，或者是直接到官方github下载并且手动安装，链接：hellodk34/picgo-plugin-lankong: A PicGo uploader for 兰空图床 lsky-pro，支持 V1 和 V2。 (github.com)教程在链接里面有。\n\n\n获取兰空图床token\n这里使用postman请求一个token，信息按照图片里的填就ok，记得把域名换成你自己图床的域名。\n\n\n设置picgo\n\n打开图床设置，选择lankong，照着写即可。\n\n\n检测效果\n图床选lankong，随便上传一张图片，看看能不能成功。\n\n\n\n\n二、对接typora打开typora，前往偏好设置，进行如下设置：\n\n并点击验证图片上传选项：\n\n能出现如图界面说明成功了。\n现在你往typora拖拽图片能自动上传到兰空图床图床\n","categories":["博客美化"]},{"title":"博客文章阅读数统计","url":"/Arknight-notes/posts/17688.html","content":"不蒜子 | 给网站、博客文章添加阅读次数统计效果演示：-\n\n\n\n\n本站总访问量次\n\n\n-\n\n\n本站访客数人次\n\n\n-\n一行脚本+一行标签，搞定一切。追求极致的用户可以进行任意DIY。\n不蒜子官网：http://busuanzi.ibruce.info/\n一、安装脚本（必选）要使用不蒜子必须在页面中引入busuanzi.js，目前最新版如下。\n&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;\n不蒜子可以给任何类型的个人站点使用，如果你是用的hexo，打开themes/你的主题/layout/_partial/footer.ejs添加上述脚本即可，当然你也可以添加到 header 中。\n二、安装标签（可选）\n只需要复制相应的html标签到你的网站要显示访问量的位置即可。您可以随意更改不蒜子标签为自己喜欢的显示效果，内容参考第三部分扩展开发。根据你要显示内容的不同，这分几种情况。\n1、显示站点总访问量要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选：\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。\n本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次\n算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。\n本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次\n如果你是用的hexo，打开themes/你的主题/layout/_partial/footer.ejs添加即可。\n实例效果参考：\nhttps://blog.ccswust.org/busuanzi/\n2、显示单页面访问量要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。\n算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。\n本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次\n代码中文字是可以修改的，只要保留id正确即可。\n注意：不蒜子为保持极简，暂不支持在站点文章摘要列表中（如首页）逐个显示每篇文章的阅读次数，如果您非常需要这一功能，可以留言。根据需要程度再考虑开发相应的功能。\n实例效果参考：\nhttps://blog.ccswust.org/busuanzi/pv.html\n注意：不蒜子为保持极简，暂不支持在站点文章摘要列表中（如首页）逐个显示每篇文章的阅读次数，如果您非常需要这一功能，可以留言。根据需要程度再考虑开发相应的功能。\n3、显示站点总访问量和单页面访问量本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次\n实例效果参考：\nhttps://blog.ccswust.org/busuanzi/ip.html\n4、只计数不显示只安装脚本代码，不安装标签代码。\n至此，不蒜子已经可以正常运行\n附录：扩展开发（自定义）不蒜子之所以称为极客的算子，正是因为不蒜子自身只提供标签+数字，至于显示的style和css动画效果，任你发挥。\n\n**busuanzi_value_site_pv** 的作用是异步回填访问数，这个id一定要正确。\n**busuanzi_container_site_pv**的作用是为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示，带来更好的体验。这个id可以省略。\n\n因此，你也可以使用极简模式：\n本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次本站访客数  &lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;  人次本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次\n或者个性化一下：\nTotal &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; views.您是xxx的第&lt;/span&gt;个小伙伴 Hits\n1、我只要统计不显示？ 只引入busuanzi.js，不引入显示标签即可。\n2、你的标签太丑了，我想美化一下可以么？ 可以的，您可以用自己站点的css进行控制，只要内层span的id正确以便回填访问次数即可，甚至标签都可以不是span。\n3、中文字体太丑了，我的主题不适合？ 您可以将本站总访问量xxx次改成view xxx times等英文以获得更和谐的显示效果。\n4、在访问量数据未取回来之前，我不想让页面显示为诸如“本站总访问量 次”，显得太low，怎么办？ 只需要如下css，不蒜子执行完毕会自动将标签显示出来，其他以此类推：\n `本站总访问量次`&lt;/span&gt;\n上面的做法还是很low？！看下这个https://blog.ccswust.org/busuanzi/diy.html 右键看下源码，没加载出来前就显示个菊花转转转: 首先，你要引入font-awesome字体：\n&lt;link rel=\"stylesheet\" href=\"//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css\"&gt;或&lt;link rel=\"stylesheet\" href=\"//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css\"&gt;\n其次，修改不蒜子标签：\n&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;i class=\"fa fa-spinner\"&gt;&lt;/i&gt;&lt;/span&gt; Hits或（旋转效果）&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;i class=\"fa fa-spinner fa-spin\"&gt;&lt;/i&gt;&lt;/span&gt; Hits\n Hits或（旋转效果） Hits\ns\n","categories":["博客美化"],"tags":["美化"]},{"title":"高代知识点全汇总","url":"/Arknight-notes/posts/16207.html","content":" folding cyan open, CSDN上的一些知识点合集（点击折叠） \n第一章——矩阵及初等变换§1.1. 矩阵及其运算\n线性代数学习笔记——第一讲——线性代数课程绪论\n线性代数学习笔记——第二讲——矩阵的定义及示例\n线性代数学习笔记——第三讲——矩阵加法及数乘\n线性代数学习笔记——第四讲——矩阵乘法的定义\n线性代数学习笔记——第五讲——矩阵乘法的性质\n线性代数学习笔记——第六讲——矩阵的转置§1.2. 高斯消元法与矩阵的初等变换\n线性代数学习笔记——第八讲——矩阵的初等变换\n线性代数学习笔记——第九讲——初等矩阵\n§1.3. 逆矩阵\n线性代数学习笔记——第十讲——逆矩阵的定义\n线性代数学习笔记——第十一讲——逆矩阵的计算（利用初等变换求逆矩阵）\n线性代数学习笔记——第十二讲——求解矩阵方程§1.4. 分块矩阵\n线性代数学习笔记——第七讲——分块矩阵\n第二章——行列式§2.1. n阶行列式的定义\n线性代数学习笔记——第十三讲——行列式的定义\n§2.2. n阶行列式的性质\n线性代数学习笔记——第十四讲——行列式的性质§2.3. Laplace定理\n线性代数学习笔记——第十五讲——行列式按行（列）展开\n线性代数学习笔记——第十六讲——行列式的计算\n线性代数学习笔记——第十七讲——伴随矩阵与逆矩阵\n线性代数学习笔记——第十八讲——抽象矩阵的可逆性§2.4. Cramer法则\n线性代数学习笔记——第十九讲——克拉默法则§2.5. 矩阵的秩\n线性代数学习笔记——第二十讲——矩阵秩的定义、\n线性代数学习笔记——第二十一讲——矩阵秩的等式\n 线性代数学习笔记——第二十二讲——矩阵秩的不等式\n第三章——几何空间§3.1. 空间直角坐标系与向量\n线性代数学习笔记——第二十三讲——空间直角坐标系\n线性代数学习笔记——第二十四讲——向量及其线性运算\n线性代数学习笔记——第二十五讲——向量在轴上的投影\n 线性代数学习笔记——第二十六讲——向量线性运算的几何意义\n线性代数学习笔记——第二十七讲——向量的方向余弦§3.2. 向量的乘法\n线性代数学习笔记——第二十八讲——向量内积的概念与性质\n线性代数学习笔记——第二十九讲——向量内积的坐标形式\n线性代数学习笔记——第三十讲——向量外积的概念与性质\n线性代数学习笔记——第三十一讲——向量外积的坐标形式\n线性代数学习笔记——第三十二讲——向量混合积的概念与性质\n线性代数学习笔记——第三十三讲——向量混合积的几何意义\n第四章——n维向量空间§4.1. n维向量空间的概念\n线性代数学习笔记——第四十讲——n维向量空间的概念\n线性代数学习笔记——第四十一讲——n维向量空间的子空间§4.2. 向量组的线性相关性\n线性代数学习笔记——第四十二讲——向量组的线性组合\n线性代数学习笔记——第四十三讲——向量组之间的线性表出\n线性代数学习笔记——第四十四讲——线性相关性的概念\n线性代数学习笔记——第四十五讲——线性相关性的判定\n线性代数学习笔记——第四十六讲——线性相关基本定理§4.3. 向量组的秩与最大无关组\n线性代数学习笔记——第四十七讲——向量组的秩与最大无关组的概念\n线性代数学习笔记——第四十八讲——矩阵的列秩和行秩\n线性代数学习笔记——第四十九讲——向量组之间的线性表出和秩\n线性代数学习笔记——第五十讲——最大无关组的性质和等价叙述§4.4. 线性方程组解的结构\n线性代数学习笔记——第五十一讲——n维向量空间的基、维数与坐标\n线性代数学习笔记——第五十二讲——齐次方程组解的性质和基础解系\n线性代数学习笔记——第五十三讲——齐次方程组求解实例\n线性代数学习笔记——第五十四讲——非齐次方程组解的性质\n线性代数学习笔记——第五十五讲——非齐次方程组求解实例\n第五章——特征值与特征向量5.1 特征值与特征向量的概念与计算\n线性代数学习笔记——第五十六讲——特征值及特征向量的定义\n线性代数学习笔记——第五十七讲——特征子空间\n线性代数学习笔记——第五十八讲——特征值与特征向量的判定\n线性代数学习笔记——第五十九讲——特征值与特征向量的计算\n 线性代数学习笔记——第六十讲——特征多项式\n线性代数学习笔记——第六十一讲——矩阵函数、逆矩阵、伴随矩阵的特征值与特征向量§5.2 矩阵的相似对角化\n线性代数学习笔记——第六十二讲——矩阵的相似对角化引例\n线性代数学习笔记——第六十三讲——相似的定义与性质\n线性代数学习笔记——第六十四讲——相似对角化的判定（1）\n线性代数学习笔记——第六十五讲——相似对角化的判定（2）\n线性代数学习笔记——第六十六讲——矩阵方幂的计算\n§5.3 n维向量空间的正交性\n线性代数学习笔记——第六十七讲——向量的内积\n线性代数学习笔记——第六十八讲——柯西—施瓦兹（Cauchy-Schwarz）不等式\n线性代数学习笔记——第六十九讲——正交向量组与标准正交基\n线性代数学习笔记——第七十讲——格拉姆—施密特（Gram-Schmidt）正交化方法\n线性代数学习笔记——第七十一讲——正交矩阵\n线性代数学习笔记——第七十二讲——共轭矩阵\n§5.4实对称矩阵的相似对角化\n线性代数学习笔记——第七十三讲——实对称矩阵的特征值与特征向量\n线性代数学习笔记——第七十四讲——实对称矩阵的相似对角化\n第六章——二次型与二次曲面§6.1.实二次型\n线性代数学习笔记——第七十五讲——二次型及其矩阵表示\n线性代数学习笔记——第七十六讲——矩阵的合同\n线性代数学习笔记——第七十七讲——用配方法化二次型为标准型\n线性代数学习笔记——第七十八讲——用正交变换化二次型为标准型§6.2. 正定二次型\n线性代数学习笔记——第七十九讲——正定二次型的概念\n线性代数学习笔记——第八十讲——正定二次型的性质（1）\n线性代数学习笔记——第八十一讲——正定二次型的性质（2）\n线性代数学习笔记——第八十二讲——二次型的其它类型\n endfolding \n一些总结，可能较零碎。\n\n本节是线代某些知识点总结，可能较零碎。\n对于简单的知识点，例如“两行对应成比例，行列式为0”就不讲了。暂时不举例题，有时间会继续补充！\n一.初等行/列变换1.计算行列式时，行列变换都可因为，所以不论动行/列都是等价的。\n\n变换规则：\n1.“倍乘”：行列式的某行(列)乘某个元素k。相应的，若行列式中某行(列)元素有公因子k(k≠0)，则k可提到行列式外面，即:\n\n2.”互换”：行列式中两行(列)互换，行列式变号。\n3.“倍加”：某行(列)的k倍加到另一行(列)，行列式不变。\n\n2.求矩阵的秩时，行列变换都可因为初等变换不改变某个矩阵非零子式的最高阶数，秩指的就是非零子式的最高阶数。\n\n初等变换的规则：\n1.”倍乘”：一个非零常数乘矩阵矩阵的某一行(列)。\n2.”互换”：互换矩阵中某两行(列)的位置。\n3.”倍加”：将矩阵的某一行(列)的k倍加到令一行(列)。\n注意：\n某矩阵乘元素k，是矩阵中的每个元素都成k，要与行列式区分。\n也就是。\n\n3.解线性方程组时，仅能使用初等行变换因为矩阵的每一种初等行变换都对应着线性方程组的同解变换，而作列变换会改变原来的方程。\n\n4.判定解的情况，单纯求r(A),r(A,b)的过程行列变换都可注：将r(A,b)化行阶梯求秩时，往往我们需要同时得到r(A)，如果想用列变换的话，只能对A单独列变换，千万不要将b列和A的列混合运算，这样r(A)就不准了。(但r(A,b)是准的)。\n但是，如果涉及到求通解或唯一解，那么就只能做行变换化行阶梯了，所以建议一开始就只做行变换。\n\n总结：求解的过程，就只进行初等行变换化行阶梯求秩，并且顺势化为行最简型求解。\n\n5.求向量组极大无关组、线性表出关系，则仅行变换因为初等行变换不改变列向量组的线性表出关系。例如下图，矩阵中，，矩阵同样有这样的关系。\n\n6.求向量组的秩时，行列变换都可求向量组的秩，其实最后会转化为求矩阵的秩，原理就是“矩阵的秩=行向量组的秩=列向量组的秩”，所以求向量组的秩也是行列变换都可。\n\n但是一般求向量组的秩后面会继续求解极大无关组/线性表出关系，这时只能做行变换，所以还是建议从开头就只使用行变换。\n7.求特征值时，行列变换都可因为特征多项式本质上是行列式，求行列式时，行列都可以换。\n\n8.求特征向量时，仅做行变换因为求特征向量时，本质是在解线性方程组，只能进行初等行变换。\n\n9.求逆矩阵时，对(A,E)仅做初等行变换因为以A−1𝐴−1左乘A得到E，以A−1𝐴−1左乘E得到A−1𝐴−1，以A−1𝐴−1左乘的过程就是做初等行变换的过程。\n\n所以怎么体现A和E做了完全一样的A−1𝐴−1所带来的初等行变换，就是将A，E横着拼在一起，此时做的初等行变换就是同步的了。\n\n 总结：\n除了① 求行列式的值（求特征值本质上就是求行列式的值）和 ② 单纯求秩，行列变换都可，其余情况通通只做行变换。\n\n二.要牢记先写那么多，后面有再补充：\n\n一些推导：\n\n对于AB ≠ BA的补充：\n\n\n1.矩阵的逆\n\n推导如下：\n\n初等矩阵的逆：\n2.矩阵的伴随\n\n三.某某子式1.余子式在n阶行列式中，去掉元素a所在的第i行、第j列元素，由剩下的元素按原来的位置与顺序组成的n-1阶行列式称为元素a的余子式，记作Mij𝑀𝑖𝑗。\n2.代数余子式余子式Mij𝑀𝑖𝑗乘(−1)i+j(−1)𝑖+𝑗后称为a的代数余子式，记作AAij𝐴𝑖𝑗\n\n3.k阶子式给定一个矩阵，任取k行，任取k 列，共k2𝑘2个数构成的行列式，出现在矩阵的秩中，定义如下：\n设A是mxn矩阵，则若存在k阶子式不为零，而任意k+1阶子式(如果有的话)全为零，则r(A)=k，且若A为nxn矩阵，则：\n\n 4.k阶主子式指在行列式中选k行k列，但要求行和列的下标相同。如：行为r1、r2、r3，列必须为c1、c2、c3；行为r2、r3、r5，列必须为c2、c3、c5。因此，k阶主子式不唯一。\n这在矩阵相似会用到，下面会讲。\n5.顺序主子式顺序主子式是在主子式上再加限定，顺序主子式是由 1~k 行和 1~k 列所确定的子式。\n\n例如：\n1阶时：取第1行，第1列\n2阶时：取第1、2行，第1、2列\n3阶时：取第1、2、3行，第1、2、3列\n4阶时：取第1、2、3、4行，第1、2、3、4列\n实际上，主子式的主对角线元素是原 n 阶行列式的主对角线元素的一部分，且顺序相同。\n所以k 阶主子式是不唯一的，而 k 阶顺序主子式是唯一的。\n\n用在判断二次型正定上，下面会讲。\n四.矩阵的秩 ① 0 &lt;= r(A) &lt;= min{m,n}\n② r(kA)=r(A)(k ≠ 0)\n③ r(AB) &lt;= min{r(A),r(B)}\n④ r(A+B) &lt;=r(A)+r(B)\n⑤ \n\nr(A)=n-1,r(A*)=1的证明：\n\n进而可得出一个重要结论：\n\n*\\*****************A************m****∗****n********************B************n****∗****s**************=****0************𝐴𝑚∗𝑛𝐵𝑛∗𝑠=0******，则r(A)+r(B)&lt;=n**\n\n所以，看到A*B就要想到两个结论：\n\n⑥ 设A是m*n矩阵，P,Q分别是m阶，n阶可逆矩阵，则\n\nr(A)=r(PA)=r(AQ)=r(PAQ)\n\n⑦ r(A)=r(AT)𝑟(𝐴𝑇)=r(AAT𝐴𝐴𝑇)=r(ATA𝐴𝑇𝐴)\n关于⑤的例题：\n\n为什么Ax=b有n-r+1个线性无关的解：\n\n 五.常用特征值与特征向量\n注意这样一道例题：\n\n\n\n\n关于特征值的一些提示：\n\n六.矩阵，向量组，方程组矩阵，向量组\n\n① 向量组是由有限个相同维数的行向量或者列向量组成，其中向量是由n个实数组成的有序数组,是一个n1的矩阵(n维列向量)或是一个1n的矩阵(n维行向量)。\n ② 矩阵是由m*n个数排列成m行n列的数表。\n一个向量组可以看作是一个矩阵的列（或行）向量集合。如果一个矩阵有n列，那么这n列就可以看作是一个由n个向量组成的向量组。反过来，一个矩阵也可以看作是由其列（或行）向量组成的向量组。\n\n1.怎么判断两个矩阵等价\n矩阵等价的前提：A与B是\\同型**矩阵，即A,B行数，列数相同\n矩阵等价的充要条件：\n① r(A)=r(B)\n② PAQ=B，P,Q可逆\n\n2.怎么判断两个向量组是等价向量组\n向量组等价的前提：A，B矩阵\\同维**\n若r( Ⅰ )=r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4….) r(Ⅱ)=r(β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4….)    \n向量组等价的充要条件：① r(Ⅰ)=r(Ⅱ)，且(Ⅰ)可由(Ⅱ)线性表出（单向表出即可）\n② r(Ⅱ)=r(Ⅰ)，且(Ⅱ)可由(Ⅰ)线性表出（单向表出即可）\n③ r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4….) =r(β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4….) =r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4…,β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4…)，即\nr(Ⅰ)=r(Ⅱ)=r(Ⅰ，Ⅱ)\n④ Ⅰ和Ⅱ能够相互线性表示。\n总结：① 两个矩阵A与B等价指的是A可以通过有限次初等变换变成B。两个不同型矩阵是不可能等价乡② 两个向量组等价只指的是它们能够互相线性表示，它们各自所含向量的个数可能是不一样的。\n\n例题：\n\n\nD.即使Ⅰ 和 Ⅱ 同为n维向量组，但是s与t的关系未知，也就是行数相等，列数未知，所以A，B两个矩阵可能不同型，不能等价。\nB.(Ⅰ)可由（Ⅱ）表示，缺少其他条件，如果① 加上(Ⅱ)可由(Ⅰ)线性表出 或者② r(Ⅰ)=r(Ⅱ)就对了\nC正确\nD r(A)=r(B)，只能推出两个向量组秩相同，缺少其他条件，如果加上① 加上(Ⅱ)可由(Ⅰ)线性表出 或者②加上(Ⅰ )可由(Ⅱ)线性表出或者③ r(Ⅰ)=r(Ⅱ)=r(Ⅰ，Ⅱ)，就对了。\n\n3.矩阵和向量等价的比较\n例题：\n\nA.(α1,α2,α3,0𝛼1,𝛼2,𝛼3,0)能与(α1,α2,α3𝛼1,𝛼2,𝛼3)相互线性表示，但是(α1,α2,α3,0𝛼1,𝛼2,𝛼3,0)不是Ax=0的基础解系\nB.基础解系一定是线性无关的，但是B选项3个向量是线性相关的（3个向量相加=0）\nC.像上面举的例子一样，α1α2𝛼1𝛼2，β1β2𝛽1𝛽2等秩，但是α1α2𝛼1𝛼2与β1β2𝛽1𝛽2不能相互线性表示。\nD.\n在(α1,α2,α3𝛼1,𝛼2,𝛼3)的右边乘可逆矩阵，不改变原来矩阵的秩，且(β1,β2,β3𝛽1,𝛽2,𝛽3)与(α1,α2,α3𝛼1,𝛼2,𝛼3)能相互线性表示\n所以，求Ax=0的另一个基础解析，需要满足与(\\******************α********1**********,**********α********2**********,**********α********3******************𝛼1,𝛼2,𝛼3*****)等价且等秩。*\n\n 4.同解方程组若两个方程组Am∗nx=0𝐴𝑚∗𝑛𝑥=0与Bs∗nx=0𝐵𝑠∗𝑛𝑥=0有完全相同的解，则称它们为同解方程组\n\n充要条件：\n① Ax=0的解满足Bx=0，且Bx=0的解满足Ax=0(互相把解代入求出结果即可)\n② r(A)=r(B)，且Ax=0的解满足Bx=0(或Bx=0的解满足Ax=0)\n③ r(A)=r(B)=r([AB][𝐴𝐵])(三秩相同)\n\n例1：\n\n例2：\n\n例3：\n\n 七.齐次线性方程组和非齐次线性方程组\n齐次线性方程组有解的条件：\n① r(A)=n时，方程组有唯一零解。\n② r(A)=r&lt;n时，方程组有非零解（无穷多解），且有n-r个线性无关解\n齐次方程组其实就是解和系数的正交，例如，给你一个条件：\nα1=2α2+α3𝛼1=2𝛼2+𝛼3——&gt;α1−2α2−α3+0α4=0𝛼1−2𝛼2−𝛼3+0𝛼4=0\n\n则(1 -2 -1 0)就是齐次方程组的基础解系\n非齐次线性无关组有解的条件：\n① 若r(4)≠r([A,b])，则方程组无解；② 若r(A)=r([A,b])=n，则方程组有唯一解；③ r(A)=r([A,b])=r&lt;n，则方程组有无穷多解。\n非齐次方程组的通解的求法：\n①求Ax=0的解\n② 求Ax=b的一个特解\n③ 非齐次方程组的通解=齐次方程组的解+一个非齐次的特解\n\n\n\n如果A行满秩，则r(A)=r(A|b)，那么方程组一定有解。\n如果A列满秩，则r(A)与r(A|b)的关系不确定：\n① r(A)&lt;r(A|b)，则无解\n② r(A)=r(A|b)&lt;n，有无穷多解\n③ r(A)=r(A|b)=n，有唯一解\n\n非齐次方程组解的性质：\n\n若η1η2η3𝜂1𝜂2𝜂3是非齐次线性方程组Ax=b的解，ξ𝜉是对应齐次方程组Ax=0的解，则：(1) η1−η2𝜂1−𝜂2是Ax=0的解；（2）kξ+η𝑘𝜉+𝜂是Ax=b的解\n\n扩展：\n\n\n解释：\n1.p个解的任意组合，都是齐次线性方程组的解\n2.非齐次的解线性组合也能得到齐次线性方程组的解，但是需要满足k1+k2+…+kp=0，例如，α1−α2𝛼1−𝛼2=0(1-1=0),α1−α2𝛼1−𝛼2就是齐次线性方程组的解。\n3.非齐次的解线性组合也能得到非齐次线性方程组的解，但是需要满足k1+k2+…+kp=1，例如，(α1+α2)/2(𝛼1+𝛼2)/2，就是非齐次线性方程组的一个解。\n4.齐次线性方程组的解与非齐次线性方程组的解相加，得到的是非齐次线性方程组的解。\n5.r(A)=r，A就有n-r个线性无关的解，而x1,x2,….xn−r𝑥𝑛−𝑟刚好是Ax=0的n-r个线性无关解，所以\nk1x1+k2x2+….+kn−rxn−r𝑘𝑛−𝑟𝑥𝑛−𝑟是Ax=0的解。\n\n例题：\n\n\nA.α1−α2𝛼1−𝛼2是组合系数是1-1=0，α1−α2𝛼1−𝛼2是Ax=0的解\nB.3α1−2α23𝛼1−2𝛼2是Ax=b的解，C,D同理。\n\n 八.对比记忆1.\n\n矩阵A的tr(A)：tra(A)=矩阵A的迹=对角线元素之和\n2.对于秩为1的n阶矩阵A或A=αβT𝛼𝛽𝑇(或βTα𝛽𝑇𝛼)（a,β都是n维非零列向量），其特征值为λ1λ2λ3….λn−1𝜆1𝜆2𝜆3….𝜆𝑛−1=0，λn=∑ni=1aii=βTα𝜆𝑛=∑𝑖=1𝑛𝑎𝑖𝑖=𝛽𝑇𝛼（或αTβ𝛼𝑇𝛽） \n\n3.\n\n例题1：\n\n例题2：\n\n九.相似与正交存在n阶可逆矩阵P，使得P−1AP=B𝑃−1𝐴𝑃=𝐵,则称A相似于B，记为A~B\n\n若A~B\n① |A|=|B|\n② r(A)=r(B)\n③ tr(A)=tr(B)\n④ λA=λB𝜆𝐴=𝜆𝐵（|λE−A|=|λE−B||𝜆𝐸−𝐴|=|𝜆𝐸−𝐵|）\n⑤ r(λE−A)=r(λE−B)𝑟(𝜆𝐸−𝐴)=𝑟(𝜆𝐸−𝐵)\n\\⑥ A，B各阶主子式之和分别相同**\n\n\n也就是说，A与B即使特征值相同，但也不一定相似。但是如果A，B都是实对称矩阵，那么相似，则一定特征值相同（实对称矩阵一定能相似对角化，特征值相同一定能相似于同一个对角矩阵，根据传递性A~B）。\n那么怎么判定矩阵相似呢？\n\n① 定义法\n存在n阶可逆矩阵P，使得P−1AP=B𝑃−1𝐴𝑃=𝐵\n② 传递法\nA~ΛΛ，ΛΛ~B，则A~B，其中ΛΛ为对角阵\n这就要说到矩阵的相似对角化\n\n矩阵可相似对角化的条件：\n\n充要条件：\n① n阶矩阵A可相似对角化↔有n个线性无关的特征向量。\n② n阶矩阵A可相似对角化↔A对应于每个k重特征值都有k个线性无关的特征向量\n必要条件：\n③ n阶矩阵A有n个不同特征值→A可相似对角化\n④ n阶矩阵为实对称矩阵→A可相似对角化\n\n对于矩阵相似对角化的步骤：\n\n① 求特征值\n② 求特征向量\n③ 正交化（如果需要的话），单位化η1η2η3….ηn𝜂1𝜂2𝜂3….𝜂𝑛\n④ 令Q=[η1η2η3….ηn𝜂1𝜂2𝜂3….𝜂𝑛],则Q为正交矩阵，且Q−1AQ=QTAQ=Λ𝑄−1𝐴𝑄=𝑄𝑇𝐴𝑄=Λ\n\n上面提到了实对称矩阵，实对称矩阵就是组成A的元素都是实数。对于实对称矩阵（AT=A𝐴𝑇=𝐴）要记住：\n\n\n对于正交，你需要记住：① αTβ=0𝛼𝑇𝛽=0，则，是正交向量\n② 若满足ATA=E𝐴𝑇𝐴=𝐸，则A是正交矩阵\nATA=E𝐴𝑇𝐴=𝐸↔A−1=AT𝐴−1=𝐴𝑇\n\n例题：\n\n不可对角化的矩阵怎么判断相似：\n 例题：\n\n\n如果A与B相似，那么：\n对于任意实数k和整数n，有(A+kE)n(𝐴+𝑘𝐸)𝑛与(B+kE)n(𝐵+𝑘𝐸)𝑛相似\n对于上面这道题，取k=-1，n=1，判断哪两个矩阵相似。\n\n矩阵相似还可得出：\n\n① A~B，Ak=Bk𝐴𝑘=𝐵𝑘，f(A)=f(B)\n② 若A~B，且A可逆，则A−1𝐴−1~B−1𝐵−1，f(A−1𝐴−1)=f(B−1𝐵−1)\n③ 若A~B，A∗𝐴∗~B∗𝐵∗\n④ 若A~B，AT𝐴𝑇~BT𝐵𝑇\n\n\n注： \n 十.合同设A，B为n阶矩阵，若存在可逆矩阵C，使得CTAC=B𝐶𝑇𝐴𝐶=𝐵，则称A与B合同，即A≅B𝐴≅𝐵。A与B合同，就是指同一个二次型在可逆线性变换下的两个不同状态的联系。\n\n\n\n注：由于我们已经规定，对称矩阵才是二次型矩阵，所以二次型矩阵都是对称矩阵，相应的和对称矩阵合同的矩阵也是对称矩阵。\n例题：\n\n\n\n\n 十一.二次型关于二次型化标准型或规范型的方法：配方法，正交变化有总结如下：\n\n所以我们可以进一步得到\n等价，合同和相似的关系：\n注：相似一定合同的前提条件是A，B都是实对称矩阵\n\n例题：\n\n\n关于配方法和正交变换分别给一个例题：配方法：\n\n正交变换：\n\n\n① 若λ1=λ2𝜆1=𝜆2，那么两个同一特征值对应的特征向量需要正交化，如果本来就正交可以不做这一步，所以在计算特征值的时候，可以将两个特征向量写为正交的，这样就免去了施密特正交化，直接进入单位化即可。\n② λ1≠λ2≠λ3𝜆1≠𝜆2≠𝜆3，那么不用进行施密特正交，直接单位化即可。\n\n常见题型：\n\n\n这里记录一个例题：\n\n\n若二次型中只有混合项，没有平方项，要怎么做？\n\n十二.二次型正定\n二次型正定的充要条件：n元二次型f=xTAx𝑓=𝑥𝑇𝐴𝑥正定↔对任意x≠0，有xTAx𝑥𝑇𝐴𝑥&gt;0（定义）\n① ↔f的正惯性指数p=n\n② ↔存在可逆矩阵D，使得A=DTD𝐴=𝐷𝑇𝐷\n③ ↔A≅E𝐴≅𝐸，A与E合同\n② ③推导：\n\n④↔A的特征值λ𝜆&gt;0\n⑤↔A的全部顺序主子式&gt;0\n二次型正定的必要条件：\n① aii𝑎𝑖𝑖&gt;0，对角线元素全部大于0\n② |A|&gt;0\n\n最好是使用充要条件① ④ ⑤判断二次型是否正定，如果非要用定义法，来看个例题：\n\n注意上题，不能直接将f判定为正定：\n因为将二次型化为标准型的过程一定要做可逆线性变换\n\n例题1：\n\n\n例题2：\n\n\n\n.png)\n","categories":["笔记"]},{"title":"自定义VSCode背景图片","url":"/Arknight-notes/posts/31443.html","content":"关于如何自定义VSCode背景图片1.以管理员身份运行VS Code，安装background插件\n2.打开setting，在搜索框中输入background，选择扩展中的plugin background，选择在setting.json中编辑\n3.在用户设置中输入以下代码，修改完后保存，会提示重启VS Code，点击确定后即可完成修改//background 的相关配置    \"update.enableWindowsBackgroundUpdates\": true,    \"background.customImages\": [        \"file:///F:/Picture/Yukino/vs_background.png\"//图片地址（支持http    ],    \"background.style\": {        \"content\":\"''\",        \"pointer-events\":\"none\",        \"position\":\"absolute\",//图片位置        \"width\":\"100%\",        \"height\":\"100%\",        \"z-index\":\"99999\",        \"background.repeat\":\"no-repeat\",        \"background-size\":\"25%,25%\",//图片大小        \"opacity\":0.2 //透明度    },    \"background.useFront\": true,    \"background.useDefault\": false,//是否使用默认图片\n\n效果如下：\n.webp)\n","categories":["随记"]},{"title":"（旧）创建一个网络包解码器分析DEVP2P协议","url":"/Arknight-notes/posts/30370.html","content":"\n本项目最新版本\n link 本项目最新版本, https://zhongye1.github.io/posts/1104.html, https://pic1.zhimg.com/80/v2-593dd0a3b84d023b3827b97e81e0242a_720w.webp \n附注：此页面使用wsl构建不可行\n\n\n\n安装配置WSL2（ubuntu20.04）Windows Subsystem for Linux（简称WSL），Windows下的Linux子系统，是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。\n1.安装Windows TerminalWindow Terminal 安装以及使用(2021最新) - 知乎\n一个目前在用的windows命令行工具\n可以直接从 Microsoft Store 下载安装，而且Github仓库上发布有内部版本。 \n2.安装wslWindows 10 安装配置WSL2（ubuntu20.04）教程 超详细_win10安装wsl2-CSDN博客\n对于windows10版本可以直接命令符安装\nwsl --install\n设置 WSL 开发环境见微软官方文档设置 WSL 开发环境 | Microsoft Learn完成后打开Windows Terminal找到：\n\n\n3.Docker 安装\nDocker -&gt; 虚拟化容器技术。Docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。\n\n\n官网地址\n公共仓库\n安装文档\n\n下载Docker Desktop安装程序：\n\n访问Docker官网下载页面：https://www.docker.com/get-started/\n选择对应版本点击下载安装程序。\n没猜错的话应该被墙了可以找我要安装包\n\n\n\n\n\n运行安装程序：\n\n双击下载的Docker Desktop安装文件。\n在安装向导中，你可以根据个人喜好勾选是否希望建立Docker Desktop的快捷方式或者是否希望Docker Desktop随Windows启动等选项。\n\n\n\n\n完成安装并重启：\n\n完成安装向导后，重启计算机确保设置正确应用。\n\n\n启动Docker Desktop：\n\n在重启后，运行Docker Desktop。当它启动时，Docker图标会出现在系统托盘中。\n系统托盘中的Docker图标表明Docker正在运行，并可能需要一点时间来启动服务。\n电脑要开VM虚拟化\nWindows 10 |VMware开启虚拟化的最全面说明_vmware虚拟化引擎-CSDN博客\n开VM时BIOS不懂的不要瞎搞\n\n\n配置Docker设置：\n\n你可以右键点击系统托盘中的Docker图标，选择“Settings”来调整Docker的配置，如更改镜像存储位置、设置代理服务器等。\n\n\n\n国内网络环境拉不下镜像的话就配置别的源\n\n我用的这几个镜像站配置环境要慎重\n我的配置文件\n{  \"builder\": {    \"gc\": {      \"defaultKeepStorage\": \"20GB\",      \"enabled\": true    }  },  \"experimental\": false,  \"registry-mirrors\": [    \"https://docker.m.daocloud.io\",    \"https://huecker.io\",    \"https://dockerhub.timeweb.cloud\",    \"https://noohub.ru\"  ]}\n\n通过命令行界面测试Docker安装：\n\n打开命令提示符、Powershell或任何你喜欢的终端。\n输入命令 docker --version 来检查Docker版本，确保它已正确安装。\n运行 docker run hello-world 来下载一个测试镜像，并在容器中运行，这可以验证Docker Daemon是否已正确启动并且可以创建容器。\n\n\n\n环境安装准备材料\n\nLua-devp2p-wireshark-dissector: GitHub链接\nPYDEVP2P: GitHub链接\nLunatic-Python: GitHub链接\nGo-Ethereum: GitHub链接\nGETH-Docker: GitHub链接\n\n1 安装Wireshark和特定版本的LUAlinux的python版本要为3.10\nsudo apt-get update &amp;&amp; sudo apt-get upgradesudo apt-get install lua5.2 liblua5.2-dev wireshark python3.10\n2 更改权限并复制Lunatic Python LUA ⇔ Python桥接二进制文件python.so为文章最开始编译得来的\nsudo chmod +x python.socp python.so /usr/local/lib/lua/5.2/\n关于python.so是从哪来的：python在linux编译后的文件为.so这个由编译Lunatic-Python: GitHub链接得来不会编译的可以找我要我编译好的（\n如何编译见项目文档：\nLunatic Python 是一个双向桥接项目，它允许Python和Lua两种语言互相通信。这意味着你可以在Lua中调用Python代码，也可以在Python中调用Lua代码，甚至可以嵌套调用（如Lua中的Python再调用Lua）。这个项目的主要用途之一是为 LUA-devp2p-dissector 提供必要的工具，使其能够调用 pydevp2p 中的函数。\n项目起源\n这个项目是一个fork版本，原始项目来自 labix-lunatic-python。\n另一个相关的版本由 bastibe 维护。\n\n开始使用克隆仓库git clone https://github.com/jmkemp20/lunatic-python.git &amp;&amp; cd lunatic-python\n确保安装了LUA 5.3通过运行 lua5.3 来检查是否已经安装了正确的LUA版本\n查找你的Python版本ldconfig -p | grep python\n这条命令会列出系统中所有可用的Python库路径。你需要找到与你的Python版本相对应的路径。\n准备编译（构建）根据上一步输出的Python版本信息来配置CMake：\ncmake -B./build -H. -DPYTHON_INCLUDE_DIR=/usr/include/python3.10 \\  -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.10.so\n使用的是Python 3.10\n编译（构建）cmake --build ./build\n使用定位二进制文件构建完成后，你会在 build/bin/ 目录下找到两个重要的文件：\n\npython.so 用于在Lua中调用Python\nlua.so 用于在Python中调用Lua\n找不到直接搜\n\n\n然后把编译好的文件移到论文提到的目录下（见上文\n3 克隆LUA解码器和PYDEVP2P项目git clone https://github.com/jmkemp20/lua-devp2p-wireshark-dissector.gitgit clone https://github.com/jmkemp20/pydevp2p.git\n4 从源代码安装PYDEVP2P PIP包cd pydevp2ppip install -e .sudo pip install -e .\n5 创建Wireshark插件目录（本地用户和root）mkdir -p ~/.local/lib/wireshark/pluginssudo mkdir -p /usr/local/lib/wireshark/plugins\nStep 6) 符号链接或复制.lua解码器文件到Wireshark插件目录ln -s &lt;location of cloned dissector&gt;/rlpx.lua ~/.local/lib/wireshark/plugins/rlpx.lualn -s &lt;location of cloned dissector&gt;/discovery.lua ~/.local/lib/wireshark/plugins/discovery.luasudo ln -s &lt;location of cloned dissector&gt;/rlpx.lua /usr/local/lib/wireshark/plugins/rlpx.luasudo ln -s &lt;location of cloned dissector&gt;/discovery.lua /usr/local/lib/wireshark/plugins/discovery.lua\n可以直接复制这些.lua文件而不是创建符号链接。终端里找不到文件用文件资源管理器搜\n\n好的，你提供的步骤是安装自定义的 Go Ethereum 客户端。以下是详细的步骤来从头开始安装和运行自定义的 Go Ethereum 客户端：\nLive GETH Docker StartupStep 1) 确保Docker和Docker Compose已安装并正在运行检查Docker版本：\ndocker --version\n\n检查Docker Compose版本：\ndocker-compose --version\n\nStep 2) 克隆GETH-Docker存储库git clone https://github.com/jmkemp20/geth-docker.gitcd geth-docker\nStep 3) 构建自定义docker镜像./build-dockers.sh\nStep 4) 启动路由器容器docker-compose up -d bridge-router\nStep 5) 打开Wireshark并连接到网络接口sudo wireshark\nStep 6) 依次启动每个GETH节点/客户端容器docker-compose up -d geth-ubuntu-bootnodedocker-compose up -d geth-client-1docker-compose up -d geth-client-2docker-compose up -d geth-client-3\n\n\n接下来新开一个命令行窗口来做论文原文操作：\n7.5 Installing the Custom GO Ethereum Client from ScratchStep 1) 克隆自定义GO Ethereum源代码git clone https://github.com/jmkemp20/go-ethereum.git\nStep 2) 编译GETH或其他所有GO Ethereum工具编译GETH是个大坑，出问题的话可以看文档后面有讲\ncd go-ethereummake geth\nStep 3) 运行GETH文档是\ngeth\n就行，看终端geth编译完后的输出来定，我这边的是\n./build/bin/geth\n不出问题的话终端没报错这里就成功了（一般不太可能，出问题见下\n我的操作：\n编译geth1. 克隆自定义的 Go Ethereum 源代码克隆自定义的 Go Ethereum 源代码仓库。\ngit clone https://github.com/jmkemp20/go-ethereum.git\n2. 安装 Geth 或所有 Go Ethereum 工具进入克隆的 go-ethereum 目录，并编译 geth 或所有工具。\n安装 Go 1.20（版本好像会影响编译，翻了下issue，我当时用的1.20确保你已经安装了 Go 1.20 或更高版本。如果没有，请按照以下步骤安装：\n# 下载 Go 1.20wget https://mirrors.aliyun.com/golang/go1.20.6.linux-amd64.tar.gz# 解压并安装sudo tar -C /usr/local -xzf go1.20.6.linux-amd64.tar.gz# 设置环境变量nano ~/.bashrc# 或者nano ~/.zshrc# 添加以下内容export GOROOT=/usr/local/goexport GOPATH=$HOME/goexport PATH=$GOPATH/bin:$GOROOT/bin:$PATH# 使配置生效source ~/.bashrc# 或者source ~/.zshrc# 验证 Go 版本go version\n编译 geth 或所有工具进入 go-ethereum 目录并编译 geth 或所有工具。\ncd go-ethereum# 清理 Go 模块缓存go clean -modcache# 更新 Go 模块go mod tidy# 编译 gethmake geth# 如果你想编译所有工具make all\n如果没猜错的话国内网络环境go下载依赖会卡住卡在这里\n我看的教程\n解决 go get golang.org/x 包失败\nGOPROXY我们知道从 Go 1.11 版本开始，官方支持了 go module 包依赖管理工具。其实还新增了 GOPROXY 环境变量。如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。这无疑对我等无法科学上网的开发良民来说是最大的福音。更可喜的是，goproxy.io 这个开源项目帮我们实现好了我们想要的。该项目允许开发者一键构建自己的 GOPROXY 代理服务。同时，也提供了公用的代理服务 https://goproxy.io，我们只需设置该环境变量即可正常下载被墙的源码包了：\n\nexport GOPROXY=https://goproxy.io\n也可以通过置空这个环境变量来关闭，export GOPROXY=。\n对于 Windows 用户，可以在 PowerShell 中设置：\n$env:GOPROXY = \"https://goproxy.io\"\n我这边这样做能正常下载\n3. 运行 Geth编译完成后，你可以运行 geth。确保 geth 可执行文件在你的 PATH 中，或者直接在 go-ethereum/build/bin 目录下运行它。\n# 如果 geth 在 PATH 中geth# 如果 geth 不在 PATH 中./build/bin/geth\n成功安装并运行自定义的 Go Ethereum 客户端\n\n\n最后的截图\n\ng)\n","categories":["笔记"]},{"title":"日志2024.9.25（待解决）","url":"/Arknight-notes/posts/13872.html","content":"\n在解析rlpx时出现lua错误在帧列表中，有一个帧（编号 1561）出现了 Lua 错误。具体来说，错误信息是：“Lua Error: /root/local/lib/wireshark/plugins/rlpx.lua:97: attempt to index local ‘dec_msg’ (a nil value)”。在解码器脚本 rlpx.lua 的第 97 行尝试访问一个名为 dec_msg 的局部变量，但它是一个空值（nil），导致解码器无法成功解析数据包\n\n\nrlpx.lua代码如下，lua版本为Lua 5.4.7 ：\nlocal python = require 'python'-- Temporary for development-- local sys = python.import 'sys'-- sys.path.append('/home/jkemp/cs700/pydevp2p/')-- End of Temporary for developmentlocal rlpxBridge = python.import 'pydevp2p.bridge'-- create a new dissectorlocal NAME = \"rlpx\"local PORT = 30305local rlpx = Proto(NAME, \"Ethereum RLPx Protocol\")local fields = rlpx.fieldsfields.auth_size = ProtoField.uint16(NAME .. \".auth_size\", \"Auth Size\")fields.ack_size = ProtoField.uint16(NAME .. \".ack_size\", \"Ack Size\")fields.body = ProtoField.bytes(NAME .. \".body\", \"Data\")fields.frame_header = ProtoField.bytes(NAME .. \".frame_header\", \"Frame Header\")fields.frame_body = ProtoField.bytes(NAME .. \".frame_body\", \"Frame Body\")local known_ports = { 30303, 30304, 30305, 30306, 30307, 30308 }local function table_has_value(tab, val)    for _, value in ipairs(tab) do        if value == val then            return true        end    end    return falseendlocal function array_iterator(array, len)    -- This lets us iterate over a c object (like a python array)    local index = 0    local count = len    -- The closure function is returned    return function()        index = index + 1        if index &lt;= count        then            -- return the current element of the iterator            return array[index]        end    endend-- main dissect packet functionfunction rlpx.dissector(tvb, pinfo, tree)    local subtree = tree:add(rlpx, tvb())    local offset = 0    -- show protocol name in protocol column    pinfo.cols.protocol = rlpx.name    local srcaddr = tostring(pinfo.src)    local dstaddr = tostring(pinfo.dst)    local payload = tostring(tvb:bytes())    -- dissect field one by one, and add to protocol tree    local auth_size = tvb(offset, 2)    if (tvb:len() - auth_size:int() == 2) then        if (table_has_value(known_ports, pinfo.src_port)) then            -- This is most likely a handshake AUTH-ACK packet            offset = offset + 2            subtree:add(fields.ack_size, auth_size)            pinfo.cols.info:set(pinfo.src_port .. \" → \" .. pinfo.dst_port .. \" [HANDSHAKE] AUTH ACK\")            -- print(payload, dstNode)            local dec_msg = rlpxBridge.handleRLPxHandshakeMsg(srcaddr, dstaddr, payload, pinfo.visited, pinfo.number)            local payloadtree = subtree:add(fields.body, tvb(offset))            payloadtree:set_text(\"Handshake AUTH ACK\")            for element in array_iterator(dec_msg, dec_msg[0]) do                payloadtree:add(element)            end        elseif (table_has_value(known_ports, pinfo.dst_port)) then            -- This is most likely a handshake AUTH packet            offset = offset + 2            subtree:add(fields.auth_size, auth_size)            pinfo.cols.info:set(pinfo.src_port .. \" → \" .. pinfo.dst_port .. \" [HANDSHAKE] AUTH INIT\")            -- print(payload, dstNode)            local dec_msg = rlpxBridge.handleRLPxHandshakeMsg(srcaddr, dstaddr, payload, pinfo.visited, pinfo.number)            local payloadtree = subtree:add(fields.body, tvb(offset))            for element in array_iterator(dec_msg, dec_msg[0]) do                payloadtree:add(element)            end        else            subtree:add(fields.body, tvb(offset))        end    else        local dec_msg = rlpxBridge.handleRLPxMsg(srcaddr, dstaddr, payload, pinfo.visited, pinfo.number)        local frame_header = dec_msg[0]        local frame_body = dec_msg[1]        local frame_type = dec_msg[2]        -- Set the column information to the Frame Type        if frame_type ~= nil then            pinfo.cols.info:set(pinfo.src_port .. \" → \" .. pinfo.dst_port .. \" \" .. frame_type)        end        -- Show the frame header information (if available) in Wireshark        if frame_header ~= nil then            local frame_header_tree = subtree:add(fields.frame_header, tvb(0, frame_header.headerSize))            frame_header_tree:add(\"Decrypted Header Data:\", frame_header.header)            frame_header_tree:add(\"Header MAC:\", frame_header.headerMac)            frame_header_tree:add(\"Frame Body MAC:\", frame_header.frameMac)            frame_header_tree:add(\"Frame Size:\", frame_header.frameSize)            frame_header_tree:add(\"Read Size:\", frame_header.readSize)            frame_header_tree:add(\"Header Data:\", frame_header.headerData)            pinfo.cols.info:append(\" Len=\" .. frame_header.readSize)        end        -- Show the frame body information (if available) in Wireshark        if frame_header ~= nil and frame_type ~= nil and frame_body ~= nil and frame_body[0] &gt; 0 then            local frame_body_tree = subtree:add(fields.frame_body, tvb(frame_header.headerSize))            for element in array_iterator(frame_body, frame_body[0]) do                frame_body_tree:add(element)            end        end    endend-- register this dissectorDissectorTable.get(\"tcp.port\"):add(PORT, rlpx)DissectorTable.get(\"tcp.port\"):add(\"30303\", rlpx)DissectorTable.get(\"tcp.port\"):add(\"30304\", rlpx)DissectorTable.get(\"tcp.port\"):add(\"30305\", rlpx)DissectorTable.get(\"tcp.port\"):add(\"30306\", rlpx)DissectorTable.get(\"tcp.port\"):add(\"30307\", rlpx)DissectorTable.get(\"tcp.port\"):add(\"30308\", rlpx)\n不知道怎么改，不懂lua\n可能是lua版本问题，改天看下文档\n\n\n.webp)\n"},{"title":"将博客CDN从jsDelivr切换至自建反向代理源","url":"/Arknight-notes/posts/4746.html","content":"快速将Butterfly主题的CDN从jsDelivr切换至自建反向代理源最新版的Butterfly取消了原来设置在_config.yml里的默认CDN，导致不能快速替换掉现在极不稳定的jsDelivr CDN。本文的默认Butterfly版本为4.1.0。\n配置现在的默认CDN地址被放在了主题的/scripts/events/config.js中：\n/** * Butterfly * 1. Merge CDN * 2. Capitalize the first letter of comment name */'use strict'hexo.extend.filter.register('before_generate', () =&gt; {  const themeConfig = hexo.theme.config  /**   * Merge CDN   */  const defaultCDN = {    main_css: '/css/index.css',    main: '/js/main.js',    utils: '/js/utils.js',    // pjax    pjax: 'https://cdn.jsdelivr.net/npm/pjax/pjax.min.js',    // comments    gitalk: 'https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js',    gitalk_css: 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css',    blueimp_md5: 'https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js',    valine: 'https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js',    disqusjs: 'https://cdn.jsdelivr.net/npm/disqusjs@1/dist/disqus.js',    disqusjs_css: 'https://cdn.jsdelivr.net/npm/disqusjs@1/dist/disqusjs.css',    utterances: 'https://utteranc.es/client.js',    twikoo: 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',    waline: 'https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js',    giscus: 'https://giscus.app/client.js',    // share    addtoany: 'https://static.addtoany.com/menu/page.js',    sharejs: 'https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js',    sharejs_css: 'https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css',    // search    local_search: '/js/search/local-search.js',    algolia_js: '/js/search/algolia.js',    algolia_search_v4: 'https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js',    instantsearch_v4: 'https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js',    // math    mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',    katex: 'https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css',    katex_copytex: 'https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js',    katex_copytex_css: 'https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css',    mermaid: 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',    // count    busuanzi: '//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js',    // background effect    canvas_ribbon: 'https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js',    canvas_fluttering_ribbon: 'https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js',    canvas_nest: 'https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js',    lazyload: 'https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js',    instantpage: 'https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js',    typed: 'https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js',    pangu: 'https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js',    // photo    fancybox_css_v4: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css',    fancybox_v4: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',    medium_zoom: 'https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js',    // snackbar    snackbar_css: 'https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css',    snackbar: 'https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js',    // effect    activate_power_mode: 'https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js',    fireworks: 'https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js',    click_heart: 'https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js',    ClickShowText: 'https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js',    // fontawesome    fontawesomeV6: 'https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css',    // Conversion between Traditional and Simplified Chinese    translate: '/js/tw_cn.js',    // flickr-justified-gallery    flickr_justified_gallery_js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',    flickr_justified_gallery_css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css',    // aplayer    aplayer_css: 'https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css',    aplayer_js: 'https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js',    meting_js: 'https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js',    // Prism.js    prismjs_js: 'https://cdn.jsdelivr.net/npm/prismjs/prism.min.js',    prismjs_lineNumber_js: 'https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js',    prismjs_autoloader: 'https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js'  }  // delete null value  const deleteNullValue = obj =&gt; {    for (const i in obj) {      obj[i] === null &amp;&amp; delete obj[i]    }    return obj  }  themeConfig.CDN = Object.assign(defaultCDN, deleteNullValue(themeConfig.CDN))  /**   * Capitalize the first letter of comment name   */  let { use } = themeConfig.comments  if (!use) return  if (typeof use === 'string') {    use = use.split(',')  }  const newArray = use.map(item =&gt; item.toLowerCase().replace(/\\b[a-z]/g, s =&gt; s.toUpperCase()))  themeConfig.comments.use = newArray})\n所以只要快速替换掉这里的CDN，就可以切换到我们自建的CDN上。\n成果将cdn.jsdelivr.net全部替换为自己的反代源后，成果就诞生了：\n/** * Butterfly * 1. Merge CDN * 2. Capitalize the first letter of comment name */'use strict'hexo.extend.filter.register('before_generate', () =&gt; {  const themeConfig = hexo.theme.config  /**   * Merge CDN   */  const defaultCDN = {    main_css: '/css/index.css',    main: '/js/main.js',    utils: '/js/utils.js',    // pjax    pjax: 'https://jsdelivr.pai233.top/npm/pjax/pjax.min.js',    // comments    gitalk: 'https://jsdelivr.pai233.top/npm/gitalk@latest/dist/gitalk.min.js',    gitalk_css: 'https://jsdelivr.pai233.top/npm/gitalk/dist/gitalk.min.css',    blueimp_md5: 'https://jsdelivr.pai233.top/npm/blueimp-md5/js/md5.min.js',    valine: 'https://jsdelivr.pai233.top/npm/valine/dist/Valine.min.js',    disqusjs: 'https://jsdelivr.pai233.top/npm/disqusjs@1/dist/disqus.js',    disqusjs_css: 'https://jsdelivr.pai233.top/npm/disqusjs@1/dist/disqusjs.css',    utterances: 'https://utteranc.es/client.js',    twikoo: 'https://jsdelivr.pai233.top/npm/twikoo/dist/twikoo.all.min.js',    waline: 'https://jsdelivr.pai233.top/npm/@waline/client/dist/Waline.min.js',    giscus: 'https://giscus.app/client.js',    // share    addtoany: 'https://static.addtoany.com/menu/page.js',    sharejs: 'https://jsdelivr.pai233.top/npm/social-share.js/dist/js/social-share.min.js',    sharejs_css: 'https://jsdelivr.pai233.top/npm/social-share.js/dist/css/share.min.css',    // search    local_search: '/js/search/local-search.js',    algolia_js: '/js/search/algolia.js',    algolia_search_v4: 'https://jsdelivr.pai233.top/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js',    instantsearch_v4: 'https://jsdelivr.pai233.top/npm/instantsearch.js@4/dist/instantsearch.production.min.js',    // math    mathjax: 'https://jsdelivr.pai233.top/npm/mathjax@3/es5/tex-mml-chtml.js',    katex: 'https://jsdelivr.pai233.top/npm/katex@latest/dist/katex.min.css',    katex_copytex: 'https://jsdelivr.pai233.top/npm/katex@latest/dist/contrib/copy-tex.min.js',    katex_copytex_css: 'https://jsdelivr.pai233.top/npm/katex@latest/dist/contrib/copy-tex.css',    mermaid: 'https://jsdelivr.pai233.top/npm/mermaid/dist/mermaid.min.js',    // count    busuanzi: '//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js',    // background effect    canvas_ribbon: 'https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js',    canvas_fluttering_ribbon: 'https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js',    canvas_nest: 'https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/canvas-nest.min.js',    lazyload: 'https://jsdelivr.pai233.top/npm/vanilla-lazyload/dist/lazyload.iife.min.js',    instantpage: 'https://jsdelivr.pai233.top/npm/instant.page/instantpage.min.js',    typed: 'https://jsdelivr.pai233.top/npm/typed.js/lib/typed.min.js',    pangu: 'https://jsdelivr.pai233.top/npm/pangu/dist/browser/pangu.min.js',    // photo    fancybox_css_v4: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css',    fancybox_v4: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js',    medium_zoom: 'https://jsdelivr.pai233.top/npm/medium-zoom/dist/medium-zoom.min.js',    // snackbar    snackbar_css: 'https://jsdelivr.pai233.top/npm/node-snackbar/dist/snackbar.min.css',    snackbar: 'https://jsdelivr.pai233.top/npm/node-snackbar/dist/snackbar.min.js',    // effect    activate_power_mode: 'https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js',    fireworks: 'https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/fireworks.min.js',    click_heart: 'https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/click-heart.min.js',    ClickShowText: 'https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/click-show-text.min.js',    // fontawesome    fontawesomeV6: 'https://jsdelivr.pai233.top/npm/@fortawesome/fontawesome-free@6/css/all.min.css',    // Conversion between Traditional and Simplified Chinese    translate: '/js/tw_cn.js',    // flickr-justified-gallery    flickr_justified_gallery_js: 'https://jsdelivr.pai233.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',    flickr_justified_gallery_css: 'https://jsdelivr.pai233.top/npm/flickr-justified-gallery@2/dist/fjGallery.min.css',    // aplayer    aplayer_css: 'https://jsdelivr.pai233.top/npm/aplayer/dist/APlayer.min.css',    aplayer_js: 'https://jsdelivr.pai233.top/npm/aplayer/dist/APlayer.min.js',    meting_js: 'https://jsdelivr.pai233.top/gh/metowolf/MetingJS@1.2/dist/Meting.min.js',    // Prism.js    prismjs_js: 'https://jsdelivr.pai233.top/npm/prismjs/prism.min.js',    prismjs_lineNumber_js: 'https://jsdelivr.pai233.top/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js',    prismjs_autoloader: 'https://jsdelivr.pai233.top/npm/prismjs/plugins/autoloader/prism-autoloader.min.js'  }  // delete null value  const deleteNullValue = obj =&gt; {    for (const i in obj) {      obj[i] === null &amp;&amp; delete obj[i]    }    return obj  }  themeConfig.CDN = Object.assign(defaultCDN, deleteNullValue(themeConfig.CDN))  /**   * Capitalize the first letter of comment name   */  let { use } = themeConfig.comments  if (!use) return  if (typeof use === 'string') {    use = use.split(',')  }  const newArray = use.map(item =&gt; item.toLowerCase().replace(/\\b[a-z]/g, s =&gt; s.toUpperCase()))  themeConfig.comments.use = newArray})\n替换完后，运行hexo cl &amp;&amp; hexo g -d部署后，就成功切换到了你的反代源上。你也可以直接复制博主的成果进行使用\n\n原帖： https://cloud.tencent.com/developer/article/1987454 \n发表于2022-02-277**\n","categories":["博客美化"],"tags":["CDN"]},{"title":"关于Jupyter汉化问题","url":"/Arknight-notes/posts/26795.html","content":"解决新版Jupyter notebook(v7.0.0及以上)汉化、默认保存路径等问题一. Jupyter notebook v7.0.0及以上汉化注意！在环境变量中添加如下用户变量仅适用于Jupyter v6及以下版本，不再适用于Jupyter v7Jupyter v7汉化方法如下\n1.打开命令行或者Anaconda Prompt，运行如下代码\npip install jupyterlab-language-pack-zh-CN\n2.运行Jupyter notebook，选择settings中的Language，替换中文\n二. 修改Jupyter notebook默认保存路径这里先介绍一种万能（不嫌麻烦）的方法1.打开命令行或者Anaconda Prompt，运行如下代码，其中D:\\JupyterWorkspace可以修改成你想要Jupyter保存的任意路径\njupyter notebook D:\\JupyterWorkspace\n这种方法的优点是很灵活缺点是每次启动都需要用命令行或者Anaconda Prompt\n下面介绍一种一本万利（fu za）的方法1.打开命令行或者Anaconda Prompt，运行如下代码\njupyter notebook --generate-config\n2.运行后会提示创建完jupyter_notebook_config.py文件，以及它所在的路径，我们直接复制路径找到这个.py文件3.用记事本打开它，CTRL+F查找notebook_dir，会搜索到这一行（适用旧版）3.用记事本打开它，CTRL+F查找root_dir，会搜索到这一行（适用新版）\n\n#c.NotebookApp.notebook_dir = ‘path’ # 旧版查找这一行#c.ServerApp.root_dir = ‘path’ # 更正，最新版应该查找这一行\n\n有些电脑搜到的可能是#c.ServerApp.notebook_dir = ‘path’，不过没什么影响4.将path替换成自己想要保存的路径，直接复制文件夹路径的话一定要将 \\ 改成 // ，并将这一行前面的#去掉**，保存文件5.右键Jupyter notebook选择属性，按下图设置即可a.png)\n"},{"title":"创建一个针对Ethereum网络的协议解包器","url":"/Arknight-notes/posts/57783.html","content":"Enabling security analysis and education of the Ethereum platform本篇论文旨在探讨如何通过创建一个Wireshark网络包解码器来分析和教育以太坊平台的安全性。使用了定制化的私人以太坊Docker网络来促进Go Ethereum执行客户端之间的通信，并使Wireshark解码器能够捕获实时网络数据。最后，作者还使用了解码器来比较DiscoveryV4和DiscoveryV5的区别，并跟踪RLPx协议中的交易在网络上的传输过程。本文的研究方法包括创建Wireshark解码器、使用定制化的私人以太坊Docker网络以及对比不同版本的DiscoveryV4和DiscoveryV5协议。最终结果表明，该解码器可以有效地帮助人们理解和分析以太坊平台的安全性和网络流量。 \n方法描述该论文提出了一种新的网络包解码器（dissector），用于分析以太坊DEVP2P协议套件中的数据包。该解码器能够解析UDP基的DiscoveryV4、DiscoveryV5以及RLPx协议，并支持其子协议ETH和SNAP的消息能力。这个解码器使用Wireshark作为平台来实现，通过拦截网络流量并提供实时视图，可以识别协议、解码数据、跟踪流和对话、计算统计信息等。\n方法改进传统的网络包解码器通常用于调试、协议分析、安全性和可扩展性分析以及教育目的。目前有两种已知的以太坊DEVP2P协议解码器：一个是基于Wireshark插件引擎使用LUA编程语言构建的；另一个是使用C编程语言编译Wireshark源代码而构建的。然而，这两种解码器都存在一些限制，只支持加密发现V4，而不支持在EIP-868中于2019年10月发布的新型数据包类型。此外，它们也不支持DiscoveryV5和RLPx及其任何子协议，如ETH和SNAP。\n这两个项目都已经被放弃，原因是复杂度高，需要社区完成这项工作。由于RLPx的数据包解码过程比较复杂，因为TCP连接是使用ECIES（椭圆曲线集成加密方案）加密的，因此需要私钥才能解密通信。私钥因素包括我们的私钥、节点的公钥以及一个随机生成的临时密钥。\n解决的问题该解码器解决了现有的解码器无法处理新型数据包类型的问题，同时也填补了DiscoveryV5和RLPx及其子协议的安全性和性能分析方面的空白。此外，该解码器还可以帮助证明其价值，为社区和教育者提供更深入的分析，包括安全性和性能差异的比较，以及交易和块传播等方面的研究。\n 论文实验本文介绍了作者使用Wireshark创建一个针对Ethereum网络的协议解包器，并对不同协议进行了分析和展示。在实验中，作者构建了一个私有开发网络，并通过MetaMask连接了该网络上的账户，演示了如何在两个节点之间进行交易。以下是每个实验的详细介绍：\n\n实验目的：创建Wireshark解包器并分析不同协议\n在这个实验中，作者的主要目的是创建一个Wireshark解包器来解析Ethereum网络中的不同协议。这包括DiscoveryV4、DiscoveryV5和RLPx协议以及它们的子协议ETH和SNAP。作者还创建了一个名为PYDEVP2P的Python库作为后台支持，提供大部分解码、解密和数据布局工具，以帮助Wireshark显示数据包信息。\n\n实验步骤：构建私有开发网络并进行交易\n在这个实验中，作者构建了一个私有开发网络，其中包括一个Bootnode和三个节点。每个节点都运行在一个Docker容器中，并且使用GETH客户端。作者使用MetaMask连接到该网络，并从不同的账户向另一个账户发送了200个ETH。整个过程被记录下来并在后续章节中进行分析。\n\n实验结果：性能和安全性的分析\n在这个实验中，作者分析了DiscoveryV4和DiscoveryV5协议的性能和安全性，并比较了它们与RLPx协议的不同之处。此外，作者还对实际交易进行了详细的分析，以了解在网络层面上发生了什么。\n\n\n总的来说，本文旨在展示如何使用Wireshark创建一个用于Ethereum网络的协议解包器，并展示了如何在私有开发网络上进行交易。作者还对不同协议的性能和安全性进行了分析，以便更好地理解Ethereum网络的工作原理。\n\n\n总结该论文主要介绍了以太坊网络及其相关协议，并通过两个现有分解器的比较，探讨了如何使用分解器来解析网络数据包以及理解底层协议。该论文的优点包括：\n\n全面深入地介绍了以太坊网络及协议，包括公共和私人网络、节点类型、网络协议等。\n提供了两种现有的分解器的比较，帮助读者了解它们之间的差异和优缺点。\n论文作者在介绍过程中提供了大量的代码示例和详细的解释，使读者更容易理解和应用所学知识。\n\n方法创新点该论文的方法创新点在于，通过对已有分解器的比较，提出了一些改进和完善的想法，例如可以将ENRRequest和ENRResponse添加到C dissector中，以便更好地支持新版本的DiscoveryV4协议。此外，该论文还提出了一个基于用户界面的演示应用程序，可以帮助用户更直观地观察和理解以太坊网络中的数据传输过程。\n未来展望随着以太坊网络的发展和技术的进步，未来的展望包括：\n\n进一步完善已有的分解器，使其能够更好地支持新的协议和功能。\n开发更加高效和智能的分解器，能够自动识别和解析更多的数据包类型和协议。\n利用机器学习和人工智能技术，实现对以太坊网络数据的自动化分析和预测，为用户提供更好的服务和支持。\n\n\n附1：实现方式项目概述该项目通过构建一个自定义的 Docker 网络环境来模拟以太坊节点之间的通信，并使用 Wireshark 和自定义的 Lua 解析器插件来捕获和分析这些通信。具体来说，它包括以下组件：\n\nGo-Ethereum (Geth) 定制源代码：用于暴露私有会话密钥。\nDocker 环境：包含多个 Geth 节点和一个路由器容器，用于模拟小型私有以太坊网络。\nLua 解析器插件：用于在 Wireshark 中解剖 DEVP2P 协议的数据包。\nPYDEVP2P 库：用于 Python 和 Lua 之间的交互。\n\n操作与实现步骤1. 环境设置确保安装了必要的软件和库：\nsudo apt-get update &amp;&amp; sudo apt-get upgradesudo apt-get install lua5.2 liblua5.2-dev wireshark python3.10\n2. 设置 Lunatic-Python 桥接Lunatic-Python 是一个双向桥接库，允许 Lua 和 Python 之间的交互。\n# 克隆 Lunatic-Python 仓库git clone https://github.com/jmkemp20/lunatic-python.gitcd lunatic-python# 确保 Lua 5.3 已安装lua5.3# 查找 Python 版本ldconfig -p | grep python# 准备构建cmake -B./build -H. -DPYTHON_INCLUDE_DIR=/usr/include/python3.10 \\  -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.10.so# 构建cmake --build ./build# 复制生成的库文件到 Lua 目录sudo chmod +x build/bin/python.sosudo cp build/bin/python.so /usr/local/lib/lua/5.2/\n3. 克隆并安装 LUA Dissector 和 PYDEVP2P# 克隆 LUA Dissector 和 PYDEVP2Pgit clone https://github.com/jmkemp20/lua-devp2p-wireshark-dissector.gitgit clone https://github.com/jmkemp20/pydevp2p.git# 安装 PYDEVP2P PIP 包cd pydevp2ppip install -e .sudo pip install -e .# 创建 Wireshark 插件目录（如果不存在）mkdir -p ~/.local/lib/wireshark/plugins# 符号链接或复制 .lua 解析器文件（也可以直接复制到该目录sudo ln -s &lt;location_of_cloned_dissector&gt;/rlpx.lua ~/.local/lib/wireshark/plugins/rlpx.luasudo ln -s &lt;location_of_cloned_dissector&gt;/discovery.lua ~/.local/lib/wireshark/plugins/discovery.lua# 对于 root 用户（如果使用 sudo 运行 Wireshark）（也可以直接复制到该目录sudo mkdir -p /usr/local/lib/wireshark/pluginssudo ln -s &lt;location_of_cloned_dissector克隆的地址&gt;/rlpx.lua /usr/local/lib/wireshark/plugins/rlpx.luasudo ln -s &lt;location_of_cloned_dissector克隆的地址&gt;/discovery.lua /usr/local/lib/wireshark/plugins/discovery.lua\n\n使用本地 .pcapng 文件测试：\nwireshark-r final.pcapng\n这将运行 Wireshark 并加载捕获的 .pcapng 文件。您可以查看解剖后的 DEVP2P 数据包。\n\n实时捕获网络流量：\n\n启动 Wireshark 并选择适当的接口捕获数据包。\n观察和分析捕获的数据包，特别是 RLPx 握手和 DiscoveryV5 数据包。\n\n\n\n\n4. 构建 Docker 环境# 克隆 GETH-Docker 仓库git clone https://github.com/jmkemp20/geth-docker.gitcd geth-docker# 构建自定义 Docker 镜像./build-dockers.sh# 启动路由器容器docker-compose up -d bridge-router# 打开 Wireshark 并附加到 10.1.0.1 或任何 10.1.X.X 网络sudo wireshark# 启动每个 GETH 节点/客户端容器docker-compose up -d geth-ubuntu-bootnodedocker-compose up -d geth-client-1docker-compose up -d geth-client-2docker-compose up -d geth-client-3\n5.安装编译和运行自定义的 Go Ethereum 客户端：1. 克隆自定义的 Go Ethereum 源代码首先，你需要克隆自定义的 Go Ethereum 源代码仓库。\ngit clone https://github.com/jmkemp20/go-ethereum.git\n2. 安装 Geth 或所有 Go Ethereum 工具进入克隆的 go-ethereum 目录，并编译 geth 或所有工具。\n安装 Go 1.20确保你已经安装了 Go 1.20 或更高版本。如果没有，请按照以下步骤安装：\n# 下载 Go 1.20wget https://mirrors.aliyun.com/golang/go1.20.6.linux-amd64.tar.gz# 解压并安装sudo tar -C /usr/local -xzf go1.20.6.linux-amd64.tar.gz# 设置环境变量nano ~/.bashrc# 或者nano ~/.zshrc# 添加以下内容export GOROOT=/usr/local/goexport GOPATH=$HOME/goexport PATH=$GOPATH/bin:$GOROOT/bin:$PATH# 使配置生效source ~/.bashrc# 或者source ~/.zshrc# 验证 Go 版本go version\n编译 geth 或所有工具进入 go-ethereum 目录并编译 geth 或所有工具。\ncd go-ethereum# 清理 Go 模块缓存go clean -modcache# 更新 Go 模块go mod tidy# 编译 gethmake geth# 如果你想编译所有工具make all\n3. 运行 Geth编译完成后，你可以运行 geth。确保 geth 可执行文件在你的 PATH 中，或者直接在 go-ethereum/build/bin 目录下运行它。\n# 如果 geth 在 PATH 中geth# 如果 geth 不在 PATH 中./build/bin/geth\n成功安装并运行自定义的 Go Ethereum 客户端\n项目结构\nDockerfile：用于构建 Docker 镜像的配置文件。\ndocker-compose.yml：用于启动和管理 Docker 容器。\nlua-devp2p-wireshark-dissector：Lua 解析器插件，用于在 Wireshark 中解剖 DEVP2P 数据包。\npydevp2p：Python 库，用于处理以太坊 DEVP2P 协议中的 ECIES 和其他加密操作。\nlunatic-python：Lua 和 Python 之间的桥接库。\n\n总结通过上述步骤，设置并运行一个自定义的 Docker 环境来模拟以太坊节点之间的通信，并使用 Wireshark 和自定义的 Lua 解析器插件来捕获和分析这些通信。有助于进行安全分析和教育，深入理解以太坊网络的工作原理。\n附2：原文翻译（结论篇）6.1 引言和回顾本论文提出了一种为以太坊的 DEVP2P 点对点协议套件创建 Wireshark 剖析器的新方法，包括带有 ETH 和 SNAP 子协议的 DiscoveryV4、DiscoveryV5 和 RLPx。正如我们所讨论的，以太坊网络促进了以太坊网络节点之间的相互通信，为去中心化的应用程序和账户提供了便利。因此，为了满足创建支持 RLP 解码和 ECIES 解密的 Wireshark 剖析器插件的要求，涵盖了许多贡献。首先，讨论了利用自定义的 Go Ethereum 源创建一个私有的 Ethereum docker 网络。接下来，介绍了 LUA Wireshark 插件的实际实现;首先是支持 DEVP2P 发现协议的 “discovery.lua” 插件，然后是 “rlpx.lua”，它允许剖析 RLPx，包括 ETH 和 SNAP 子协议。然后，我们深入研究了 PYDEVP2P，这是一个基于 python 的最小第三方依赖库，为 RLP 解码、ECIES 解密和解剖辅助函数提供了工具。最后，利用剖析器和PYDEVP2P分析了椭圆曲线数字签名算法 （ECDSA） 椭圆曲线 Diffie-Hellman 背后的技术细节。\nWireshark 是一种广泛使用的网络分析工具，允许用户检查和解码网络数据包。但是，Wireshark 本身不支持以太坊的 DEVP2P 协议，这限制了研究人员和开发人员监控和理解以太坊节点行为的能力。最重要的是，Wireshark 支持使用解剖插件，这些插件是 Wireshark 解剖功能的插件。正如我们所讨论的，当前由 BCSEC Org 和 ConsenSys 提供的两个剖析器插件并不完全支持 DiscoveryV4 的最新消息结构，并且对 DiscoveryV5 和 RLPx 的支持为零。为了解决这一差距，本论文在 LUA 中开发了一个自定义 Wireshark 剖析器插件，该插件可以以用户友好的格式解析和显示 DEVP2P 数据包。该插件利用 PYDEVP2P，这是一个基于 python 的库，用于协助解码 RLP（递归长度前缀）和解密 DEVP2P 协议使用的 ECIES（椭圆曲线集成加密方案）。\n此外，本论文还创建了一个具有自定义 Go Ethereum 映像的私有 docker 网络，该网络可生成真实的 DEVP2P 流量，用于开发、测试和分析目的。使用这个剖析器插件和环境，本论文演示了 Wireshark 剖析器如何分析 DEVP2P 数据包流的各个方面，例如跟踪交易在整个网络中的传播、分析 DiscoveryV4 椭圆曲线数字签名算法 （ECDSA） 和 DiscoveryV5 对椭圆曲线 Diffie-Hellman （ECDH） 的使用。本论文为研究以太坊的点对点通信层和增强去中心化应用程序的透明度和安全性提供了实用工具，为区块链研究领域、以太坊社区成员和教育工作者做出了贡献。\n6.2 解剖和分析结果本论文介绍了 Wireshark 剖析器插件的设计和实现，用于剖析 DEVP2P 的 DiscoveryV4、DiscoveryV5 和 RLPx 协议。剖析器插件可以解码和显示以太坊节点之间交换的各种消息，这些消息要么是实时网络，要么是事后捕获数据包。此外，剖析器插件还支持使用从握手过程中派生的会话密钥来解码 DiscoveryV5 和 RLPx 消息。\n创建剖析器的过程和剖析器的众多功能在第 4 章中展示。具体来说，DEVP2P 剖析器支持在 DiscoveryV4 中找到的所有消息，如第 4.3.1 章所述，包括 Ping、Pong、FindNode、Neighbors、ENRRequest 和 ENRResponse。由于新的“enr-seq”字段，以前的剖析器（包括 BSECORG 的 LUA 剖析器插件和 ConsenSys 的 C 剖析器）无法完全剖析 Ping 和 Pong 消息的较新消息架构。这些以前的剖析器也不支持 EIP-868 中描述的最新 ENRRequest 和 ENRResponse 数据包，这些数据包已于 2019 年 10 月添加到协议中。\n接下来，新的剖析器支持第 4.3.2 章中讨论的 DiscoveryV5 的最新实现，包括 Ping、Pong、FindNode、Nodes、TalkReq 和 TalkResp。以前的剖析器不支持此功能，因为协议的性质会混淆数据包标头信息和 ECDH 握手以交换会话密钥以进行加密通信。但是，这种新的 DEVP2P 剖析器提供了维护在网络上的已知节点之间创建的会话的所有功能，从而无缝解密和破译捕获的网络数据。\nDEVP2P 剖析器插件可以分析和破译 RLPx 促进的以太坊节点之间经过身份验证和加密的通信。这包括使用 AuthInit 和 AuthAck RLPx 消息在节点之间创建会话密钥的握手过程，然后是内置的 RLPx 功能“P2P”Hello 消息，如第 4.4 章所示。剖析器支持其他 RLPx P2P 消息、Ping、Pong 和 Disconnect。由于 RLPx 用作多种功能的 TCP 传输，因此剖析器可以解码、解密和剖析 RLPx 下的两个主要子协议或功能 ETH 和 SNAP。这些协议支持区块传播、链同步和交易，然后是状态管理和 SNAP 同步。剖析器支持 2 条 RLPx 握手消息、4 条 RLPx P2P 消息、13 条 ETH 功能消息和 6 条 SNAP 功能消息。\n关于区块链状态和交易的 Connected Peer 节点。剖析器还可以显示消息格式的详细信息，例如 RLP 编码和解码、数据包标头和尾部以及消息类型和内容。该工具允许轻松访问 DEVP2P 的内部工作原理，并为研究人员、一般区块链社区和类似领域的教育工作者提供帮助。\n6.3 限制与未来工作剖析器是对以太坊网络分析的新颖贡献，因为它是第一个在统一且用户友好的界面中剖析所有三种 DEVP2P 协议的工具。剖析器可以帮助研究人员和开发人员了解 Ethereum 网络的行为和性能，并识别和缓解潜在的安全威胁。剖析器还可以通过使椭圆曲线密码学在实际应用中更易于访问来帮助教育工作者，同时帮助开发和测试以太坊网络的新协议或功能，同时提供可靠的\n为未来改进和扩展对现有协议的支持奠定了基础。\n但是，剖析器也有一些局限性和缺点，必须在未来的工作中解决：\n剖析器需要自定义 Go Ethereum 源代码，其中包括每个节点在 RLPx 握手期间生成的随机私钥，用于会话密钥共享和后续数据包的加密。剖析器不支持使用官方 GETH 或 Ethereum 客户端进行 RLPx 剖读。\n剖析需要 Python 配合 PYDEVP2P 使用， 在幕后处理剖析、解码和解密的主要逻辑。这增加了剖析器设置和执行的复杂性和开销，需要安装 Python PIP 包的 PYDEVP2P 以及 LUA 和 Lunatic-Python 桥。\n剖析器存在不完整的消息错误，当某些消息大于特定大小时，会导致它们被截断或跳过。此错误会影响捕获握手数据包或格式错误的数据包时剖分结果的准确性和完整性。\n剖析器不会在 Wireshark 显示屏上以清晰的人类可读格式显示 DiscoveryV5 消息的未屏蔽“authdata”，其中包含节点 ID、签名和临时公钥等基本信息。\n随着以太坊及其底层网络的复杂性不断增长并随着时间的推移而发展，未来工作可能会有一些可能的改进或扩展：\n在权益证明环境中使用剖析器，查看权益证明共识算法网络中的执行客户端中使用了哪些 DEVP2P 协议和消息。看看哪些 DEVP2P RLPx 功能消息被新协议改编或未使用，以进行权益证明，这将是一件有趣的事情。\n剖析 LIBP2P 并将其与 DEVP2P 进行比较。LIBP2P 是以太坊共识客户端使用的另一个点对点网络堆栈。在功能、性能和安全性方面对 LIBP2P 和 DEVP2P 进行比较和对比会很有用。\n添加 LES、PIP、WIP 和其他 RLPx 子协议的剖析。剖析器目前仅支持 ETH 和 SNAP 子协议。这些其他子协议用于不同的目的，例如轻以太坊子协议 （LES） 支持、奇偶校验轻协议 （PIP） 支持和以太坊见证协议 （WIT）。剖析器也应该扩展以支持这些子协议。\n调查网络发现泄漏，这是 DiscoveryV4 中发现的问题。网络发现泄漏是一个问题，即为特定链/网络 ID 设置的 Ethereum 节点会错误地通信并发现其他 Ethereum 网络上的节点。\n实施 DiscoveryV4 和 DiscoveryV5 拒绝服务 （DoS） 攻击。DiscoveryV4 协议容易受到拒绝服务 （DoS） 攻击，这些攻击可能会用虚假的 ping 或 pong 消息淹没节点。这些消息会消耗节点的带宽和处理资源，并可能阻止它们响应合法消息。剖析器可以通过捕获网络上的此类恶意数据包来帮助检测和监控此类攻击。\n实施 RLPx 已知明文攻击。RLPx 协议使用 AES-CTR 加密，每条消息使用固定的 IV（初始化向量）。这使得它容易受到已知的明文攻击，如果攻击者知道一些明文-密文对，该攻击可以恢复加密密钥。剖析器可以通过随机化每条消息的 IV 或使用不同的加密方案来帮助避免这种攻击。\n执行 Wireshark 统计分析。Wireshark 提供各种统计网络流量分析工具，例如图形、图表、表格、过滤器等。剖析器可以利用这些工具对 DEVP2P 协议进行更高级和全面的分析，例如吞吐量、延迟、数据包丢失、消息分发、节点行为等。\n6.4 最后的思考解剖器的设计、实现及其结果的分析证明了它对社区、教育工作者、开发者和研究者的有用性。LUA Wireshark 解析插件和 PYDEVP2P 库为教育工作者、研究人员及开发者提供了理解以太坊网络内部运作所需的所有工具。该解析器还允许可视化流行的密码学概念，利用椭圆曲线密码学（ECC），同时帮助理解递归长度前缀（RLP）编码的工作方式。在创建此解析器的过程中克服了许多障碍，无论是更新文档还是实现以太坊特有的ECIES技术细节。本文档中穿插的大多数技术细节直接来自以太坊DEVP2P GitHub规范页面以及最常用的执行客户端源代码Go Ethereum。因此，这些方法对于更广泛的以太坊社区成员、分析师尤其是教育者来说并不容易获得。\n本文讨论的贡献使得进入以太坊节点网络通信变得更加容易，并且克服了由大型区块链技术解决方案公司ConsenSys指出的一些障碍。这包括可以使用单个命令启动一个完整的私有以太坊网络的Go Ethereum Docker网络，随后是只需几个简单步骤即可安装的LUA Wireshark插件和PYDEVP2P库。正如所讨论的那样，PYDEVP2P库还提供了易于理解的椭圆曲线加密实现，让教育工作者和学生能够在一个实际环境中亲身体验并理解这些底层概念。\n本文档的主要目标是提供所有必要的工具来支持未来的改进，为教育者提供一种轻松访问的工具来展示ECIES密码技术，同时也为了安全分析师能够进一步增强点对点区块链网络的健壮性。\n。\n","categories":["笔记"]},{"title":"创建一个网络包解码器分析DEVP2P协议","url":"/Arknight-notes/posts/20624.html","content":"\n      \n        960de352cbbf61610f6ac860516fb694f1227b845aaa710f9957fd3fa0fa612cd78a4a8b69688d3de3258e59c9185e22e54bae3dda57c9506554f6d306bb0bc42c60764e3d8d74fd5e6364880bebb7e6a58a9c0ea41fc6c829b94689b162c9239afc8008b8e60241d493edef741981bede5caaa97b5f9eddd65600702977f396eba76ff5b138076a37cdcdf83de1552930985c82b6e58bec35a1ff31d98fd7c3bbacf7ecea0d5d153d4101a8ffb02da4aa5c5b23ab507bcbfdc30c0d76d64d09639e6c8d3f626e44ddc40ebf431cef8838d9222f225a8dc2094a52dbadd7d613d28f32e43e3e7f75e376bf85bf2bec52f1845f5c8e48f116dbba34534cb894b7d9dc4489c52e91e5c69589ebf278c1ec0bcc95d17a0a1b7c52c02879fd46b22a793382ef791b100f23965cc36b3067208b5b9c67a29f4021017af79d6453eef4df7b6e15dc3965057a71c3be05a909cbce7a96197baab1c9ea6d983f7a24e491a46f81cab6e8c9d40e77282d3fa9da159ebd1498ccfc1de5cc6e6f38c8983dfce3681208d7775b8af8faff2ad1c7e1bab01273a0f1c23f46e7b778eef02ac319905356ecdeb5695b7c0ab4622bc5a9045fe8d6e980dd42fadc34fe5ac32c5088a4aed52f674a8565a5b4467d70a16971803ce67eefd614d6ffa7d127c5975126a1d2c5b0f9a1b345f3898803957dc624b05eb41b8029f850bdda7757958a3db0e2ceb20c4ef32269fac1b6fc98cca55ba920127b249d0c1869fc572c49c779fc7d4873252ce455058d316df025c0086beb7b885be369edb87d200a634f84572f03ca3a339d5b2740b4abb22b4166e7a92c024a76cf1559b7f85ad023a9623bce8169d1468bc9d437d169ab07f360fb47912db2ce7231562ff10bd6c3c433c591c277ba0caed189772854f95df3abd77fe757fb99f6cfad201fcb57743e56afa3035f01cff072b45b1a11bfbea8790357f3f6a4c097df87372489e1ed3fe10add44535f92007781361d011a0bc100484760e4691ae1a255a1cd2dd06db4ff0499c70bacc717b24544102befb7c749208879629b3df7ae3936c60e9709da0b10866ba1d9810fb8b6fe25520362bb223f5489253946edc150c1f3e3a14febdff1199170983c4fb46683df120e5cc9b8a112977976697902f284d6f0672fb538f4de4584cb5dd50228b56f9783c0d21983b2e6b9668706b24239989034fd92b7555f4937dc14f7d8c408bd72408592c1a8695d043062c2b12d26db897465795c449629a3f029399e13dcd487e8d0040955058cc8aeda31825274797842be69273a6117c4162457223068f10eb41af9a330e48c0fbf9dcc270b48e61070135828cbb3d92eddc0f2d5ac02940597d1dc0e5027c27e0a83bcd0a65f3f04beff665cb043cd9869229adaf0939fd2d4e2c7bb037758b37f2d33fa9f1eb6a1de3326c8c85e33da8bafa0d885e2eca8d040c076a350fea9469c42c34f4624a86db39f5853e9dd3564053465161c23f21819414a982515fc8a3a61c6eb059370e98bb0941ef4408325721bf694f90bed289f04e885cfaa899a89f8c9443b12a450196c88c87ca85b1b7f770e2547287ffb69b632d1f5ba399f430a7c72b7521d61cf7f4bc3e9cbce15c556ee6ce4780f0fed0bc8f4d04f21716e565f546088c95db4ed458af2a919fd667e29a1ebf121a574922bf9008a3689b9737d7df9d9e43bd3262d98e903e348824cd0c656614140441682a41bf34d11cd0a6a6d8f7d0620db34099101fed22d098ec84f113925d97d4c4403dfc83c83b1a2c47b37b987cf52c20459620f9c83df9c1842ae3883a8fd8085491687c55fe0bca2a13742e8e763e88f4255209aefda2e02f0b7fac01e4cb9eb38c7fc851c878352825a480364a63b22d714666f1c7baa96330db39233a9d3166466414ca725d83156bd231f9a8f9a57885b291b4fe715dcc35f70aa569039543e6f6086612e5f073d2aa428505220b2980ca349224b904644d52b72237d41639a1572d8f64110b98ae4268a3aadaafd78464af0dc8b0440c26245b6d06c4a41b3954d01314897211e57d4b3215ed6924fa88c97bbe87c2a0a913c482e9fe8b2de434466347682bc8056872dc96510d4f6997684596506f011482c23e139fa7761833556e657ef0ed21eb48b9680fbfc29ccc3d552a997ec27d9ebbb43e49079ff7d598f11709f0a8633207335e79a2a58563826c02d84cf6d229538aaad4ef6ff18c47deb2b21f02b4bffc6a1320b855bc7686783a28f8a530aee7c525a56dbe56804d4a6121e8ada95488a7c0e9f46c16352f3484184fff86c0d97a2a7d90a4277b2526b02ce9cff67b69d0542ba6af422eb88b632caf5a9d9dfc4f5940ba56e208d571d94f03b754853c96a8763e3aa78b68056bd4bf3868c9fd69d8c4752a1a992ad6185a2f67981d4ec066e0ae1d781a72c1cffbf94020217573fb5ca463037550cf3bfc6722f65b5470b27879a35c09f9ee01bd0f5e681e31d592dad6da15a3b727774af3d08af76c6d029ce7c70483e3503c45782c8103232b965e1f584b4468dc397a87b977947d1007a63fd986468a7be3d8c0a07ef9abd7e9590ae434778f3ff8e589c6363c172dbfdda0c53822d8e56cd063c2f349cd00d3c035e25014237a5bd23d77a42a688c830fd3cddc33b3523263a47c54a59ee8378abe94700d1062d6a04f2ee7597dfe795a209928542a93676f79d03edc6ebd3724676d7fc290f740d53e372afb07efc44146049a28ba57e3880e1026bc9d78aba850c702a7c3965c7263f980338b405bbd3dd4d5c2d47d27f045668729501067c2f56e455947d518346a2935778e70ca2ebe50e03bf19700538f476eabab6ab9bfcf5f652d6c63d63bc38efaf41a4786503d4eb9e3d40b06092495f0a81430ac988a473fc05d0046df27d96be3ff289dc3ad6663e62be1cc294c9a91beca2385a58f42418dafdf0022cbde52014bbc007f9e0bff0aab753c9d428a979f029dcd070d0480494b58399767921e2c4b1b014cd0bf2212b38ea9a45d0bfb432ad092a2defe05a920225bb09c47fab442d808e3796d27804621e4971d34a02c3c715bf4ade4c360c1d525e3edd13cc5185958663ffe21263fe4a8596b84605a26869a3c0113074a9bcd9a8539bd4b0ba5691474daa9e4145cb04511a0d8bbbefb93364e6489aa2f5c40bf52f3e3d81c6c774793a503fed55f562e7cdcdbaba101105aa93d42a4889365ebca29f05c7d191cf48387a942ba245944241acd02a2ad2d7ffb300df3925f494cf3776ec1dec5d8828a9e1d8c24dfa08ebbd0bab0632554452ecb11a579fb3beef83ce8dcf01867740d2d96b8eadef7526789d30c542837df9b4fdafd6031f6e370950570bafae6dd7b4f2702a4d2ef35d18b18ae205d42b8d49dcb10ca7d49ba1782e13029fca5b9d9c19de0962bfbaa3676346ec5856978d680f5f0917a63043302bd870c78bcdf276cbd2721face682ddfce2244a588d6daf87363df9def09ee4ac05815a40e99d587327654d9777fc4e74d42b3bb321905e092325e47924816d6f71933782dcfa8bf13f6eb2ea1ff4bf997e65f71523660cd6f399cdd36dd5daaa5962bc261c6b5a4fe6fb69ce28c1248267558fb71a79774d96f9edc2099fe3f88dd63b9bdf664bc35a8995c63ae69d06820a4ec2abbf56f8ec7710a1613dd750a2cba5562e68f33008d5c7bff06fc3b4927a014ef073601b7f46dbf0c390c0522d9537b268be8c350c47d82970bc5996b92158ef75ae0380dd14882ec1870145be84cecf6e158443a1ff477492e869dc79a317348f982324a96ed88c4a5f3c44524900d0435b6b5a6106e6471951846e7b5184de4c671236f37b8e6d150e7fc629eb2fedc158e35e0c9b87e5e63a27507ea5fb0c909baafd0b380fa4d02d7370adeebb3730b536c89c83cd7c8d75d8d3477803ad0df3808461a2f2385b802ad0d13e959836ec19c33f26fd9634d0d203c31831a6f22662714d8e235859118d8a398db3656b848406ee4ab32871b8c5b909f142e6348227614b95f512cdddaa2fc1674e8375ca3be2849e3c3fec39197980097c329cd4b0a5bfe2506c5849cc04288a5501059df5a3f370399bfcb7d6f5787cced13d31fcf3838a417094eb47c59d1b3372deba61cc2dc16ccb1376322ea2633b279c0dfc2564c8f47dc3544625b6f4357c15cc8826c7ab51f27eb36f47bac4343d3b60693eae7c1600d5de1867a5dd7bb3e68b63e2c093b000760bfcdf7f9ebc3b68be651663300a40b3b4cce822c87ae55c4f4c7e20e4c79a8e994d9df26460e9826d10b69a1dcee5d54de2ae8aefa4561938795eca9d0b09539436a19d176912a83db8eb9a40848a8e728c7263bbd9d3291f58be64eb6dc8fe1a1faed102e402d87bc26c3ac3693fd4b24db1553a76c8cd1306d47232b46257f379ab5e4d6727069251324b137efee7bb05a3d16d57f5f26aec28911bc2411e2d2fa2c746a1b813a8854403f00f536f82566cc9bb5d6ebef8a6c95a409011022aab0050b0aca0d4ced2da1f32de4ffd3ee25efe1ed90bf2095d8bf6c0983aa4199ce225cf24249945c1edf972e2c465fb5b5a47bce66426a284670d4e4e876cb2b7d0da096ebe2bebf3d0113e3840ed6ececcaea97d167e4e09e9f7d4005a328984b78fbd79d67c6acff9713c3fa830a8da168626f3bfef16574ebf274a9d2815aaf37bbb0c259f3d04415fb305eb2ba34a04547c3650d7e7cdf00da25aff89c4b8c7d6363b57bafd480596cb6c3d220e3ad525ccef9b6c19d8ff871c867b4e75ae82e3f7b7859948e78d799e0491c43aa0bc0df26f35187ce047f167ad64b5921d5988f003600cce8957d2267fd919519d0b69d99c2365277789de74b58dee0f0daba668650a2439fcda6210c4687df22edb66e0550c51cb302134085c45749e8b449ac5e8a112729988b39e79f20f08344df870e904287488954823d0176a943f27146a6f91c146418f54ae6340f234cebcce724553b27ec06797841b9550484f97cc630c03866119ab27f69c50bbb22454d69fda7f89481cab2c951ccd17372dea5a5109642bbf3b70afc95dc97f2b2f3f01aba49de601afc56fc0e1a1e5aa5ec36cf9dcba54af45762afb96f2ca8bd2f433f67c029e9ae7c5eab8d6d99a6af19d823cd8ce6f621deeb62698c7cf5d44ca88a2108ed14e869cf0e0746381bca25d6de4af45b843875d95914e4de9c89af0c3bee100cc11317d8b27d37c1a6cf0e77ac2aa5472ba21bdfe8a2eee3832461b3419dc3d0e106a19db4cdd148db4ebe701395a4bd18c4ac228d51349cd3eafa4b6af2e3fc48170612640a1d90b633c38075ebed3059700fb1baeb9406a1e65c3664978f0ed4fbee9eb9fe019ecdaef59a5c64478ad8cf53d15056bc71f1c8fa2995af3f17833674770a19887e4b53ad294fbf204471cb5c82d483d0f2b53287c79d8780b1b5ae072eee430a71f2f34fb8489b3c9a40e55cf2f545230e4b35ec3f8caed93e50823b3b3aac288cbf0c39f2460cc9b598dff8ca29f36dad4b1035649ca3dc2892578682a0851c8d4ec8261d6e589d9e8411520238b445b65315ebd2670fdca58e42403592052f709536a940c2f3c6dcfe59c9b9ec5a6ab0493ea02a9e6790289f9d0ea37da85d476ca6953d278adc8a1716bff61cca0cf83fa82da15dd6d567c0452d96125115d11d1727330b8bb479baa8c52b00e0e0b8e44e09f23a9bc597cdacef447f8a4c97e575d647ebd7ff5d1de513c2cfc2fcf36e054623613ecb2cda26792faeeeb1bf5fe7d2f7428c526ced69908098cd4c6930586e7b875d0a0b38f9bb5de7a585ad761e7002859179c5a6abf0187dbbe74df6acc18bc07a6b9afa9c8a57d52f0c7eb310eb5ceea89e5b006819141545337d1f7ca5a8234b51531d0aef5e0231194fc24dd9d8cc293adda1daa297f5b222d465017ee1d1e19423d8a1a9a6c58f642be3ee16f4ad34aae3953533b0dabc4bca328e98fa576ad7e3b2a0e491120b1a40ddc9fa8d72e90f834df83df16012757fcb3f3a3407d41371ccc5b400d2c0e720c9c6e2fafc3691e21edea439dc64481631aa392208bf4e2da5ffcd1e0d674f0d687d8e02409ba17aa323698d3d4abd055e37a1475a122326983d46bca363859bc8f923948c48a3de6d9a80ef4e621a41b7a556a678864a1f0c938d7d8bcea12e38bd06e7f71221359c3c2af14e48dc899a68de17ef6ff14a08cfc9e5f60032a2aaa4c9188347647448341f070bf0d7fd209281144a817edb359dd73b0690fcc807fb7502aa45387d3f07d0affb0b41f2386ee8ec41c4e78be1f3bf5feca54d95645ac8de324e6171c7f7667fc3b096dc521a92f48107ccfaf0ac2b5113cd5b3edc4bacf431414ca606acd8fc8edce31fa802ee4f33fb0a413be4fedc453cfdee38c5d81086d6c0abeda6cab7050954a6c69c69e0d6c7c63ba1c866a5e7fca97381abdd9556e48b37dccff9b2cc9b80e37a7a53e42b9d2cae08d3fd0db4e02e76d7d76e8a29e61f030346b384e0ef33a150ddbd425852801ff884de4d67e0edb5e819fca21496514e1efbfbb7b183349d0cdeabe3ffeba35d2c7f9918b02834134b180d85084384ca743d4b36b9f803d99ba9af51b920c680bca2a104326f818abffc2682bedcea2becdd87ea80d1ff6d26e0d51904b10f029c5722771e74b9b3b55222752f6b451d7b087c404acc73223eb572212924379790bd157c63f9fe19aa385bfe3906d9656404471e5ca26051b1d4b0c0477a977696bba17eb6390586828c83569ca8b64016369e99b748c0d0e200ce375d80969aa281514b8f5ed8228775faa7831569e6c59b738c2deec2a32a498a1cbc855960476b1558066cb9a84cfc7c05000b52122f39c8fd0d24359726a50040ea303c457cea809457c32382c6d3a2edc88a8fd88a5a37747d5be61a6ab193ef053ff316ec043ab498b572154f0293ff92f0ed5acf73975b3d835b5befd96575be38a92f69e8bf0060e649975244e15b084c03a19b5009d5a4e6b7c4bb4323896570bbcc6bcdd0bdbc2496aef9e9fc75a65917e2da14e3c5ad9a89e53bde7fe5da115ce439f42d56b1eec6b35844afd52200c3667b25630f9191c869d3b47c398369787f017a2bee3ecec15bc21e1f5aab34209f2b45610893183eb91f9d08e99b5c8f29a2de78acf6e0b57a1e8e607b3ab9fecf496479ad6e9aea1f8d137f02ea964df04c93951589d558353a01d38eb997090e14897a886c745b6f74b6b1519543f38e57546a85bdc84d817444845085bd1bdefb31c9db5339b49266dcb26b53a4543b9de891a7fd935d6bac23fa509f6d098e966aedbb3c7bb99fbb04268976642cb16148198872961bba43423ca43c917681118feff72978d44f2b5288c03cc8564cba5dc4b56e1054b6f23017b16298df6890e99a2ecaf0e193fc249fbe67f2881ead1b11e159347f410508f62fda995304dee03a70621be9548b1c14e2b1d2a3473aafd139bd87eea9d3883c91afabf81fdf14cfde2e79a98230de8620be73eff10a454731eef7727451f9ebbca39c819fff4bff53927b031272ae7aab4392812c461c945240262238e8adc48231deaa56ccb3adda1e6cb27101f6dda4b759b650d78eb5904fa3c3c2055fd72756df8aac925a4775673694ad9ec114c62157a7cb3c12af0775be6e3ca7a34097b50a481e625cdd1ea2500d59e77ff19e6165f9faa440561c93d69d0239977895967bc98867d674c14bea7993e838e52aa1dac166e70ece004fa47e07643ab672713879a8dc7fe9f346840f181c5288da937e0397387c82c32615bcb3d5e94778ddc22a6681d7ef7c793df7ea1531177387de7eff7357a0a9b64e43c5cb9e4874e3b3a549e21eed8561071a95fb375e3204cf31663f945c9f78aa43f2f0a13e50324840b5086189b0e1d0ad54665667494b437a7c848206d263616b39a47f39d0d1979252c83eadfa81bbfd79b5179b300ecc8b28ba7cd6833f1cccef12604bd096c10a33abeeff1f3a9c4cad152596b9bc4d5c7db2e2c6286807a4311cda191ccddd641951b903416d3b0a2b241af8e37985dcb8ed066afa7da340dffe6c42669520f21acec0b065349499072833b93a1de8b95d0e0a48963946acd67ce633c9c3b98dfd4cc88ba6a1be0299bebb4f5f52e75540260061731f64eaca9ab6c5874536998e4ab0b33fb799d0fcbe661b0809feaa7a093a971bebf5373f0f54b63099be385e4457ca8262a9d60521730f5269dcde95c46c2da42bd6705203ce438bfbd80ab644fa5a85e9bb3f1a4f80e245b570ca2d5f2e5c275f1ef586c4609dc5518d0419b3877af03a62ac12990566c28ab96e4babc30c0be1c0749c15c115be78846f63477d470a8cd7202c14adad9e01aab9f561e0ac4e4d1c3fbe94015bc28fce8ab49f23145bc4913a7ed5016ea617422de293482b21154105413ec094fe8d53628fedd7b4873550d5b3c7ebf93b1ef23e1ec911696039d3855adc96d5aa6c4e6382d85b005d9feab4c1724095eb2417065d37f763a3fbe73453ac2abb1826d4bf720e546f909a317f2f8035499d697befac231cf2e240b9de9863d9e7d9728d540c468119cfb904a087965bb19a817a6bc9ceef12f7fccb520f4b1eea12d3f7a5c87453f6e0a88fbd0316776a6f16457cc3d801076aef2bacf5f3ecfb4905c34b9fc05523ad977232cc1dde1eeb7db7621fbc09ce3cb1c83e5130775e7c3cd78105193753176dbf6c66c84fc1378377428fccf8c57ffa87beb8529ab565b5749b1a86bb6c8cf6455bdf17f80df4ce99893ae471be41423251011f59a9cd9f1f9156f87256239bb3272ede628c4489a370b0f22ce863a51355c8e3ec8b9ef112425e9504a48264cadfd2ea49a6dee15a10960b3b051cae8da93ee8363ec7b469e2ebe8fce7b8d9f922c0b0355c83ad5bf3570aacff1564fea88860174708b9d8647f6a325b4368df9a2fafe5a5ede868a1e81dbef289301fb657ac4b5397b24737e2b733c30edcbf311be9b04312329a698dae30e0f0184ddf68e61aa030794dc61d46ef14959e350b1cd796ab7d79359bef4f19a997762766da47f925088de0647026696001ebd2b44447efbbe73c689e451c6967060f089c642b68f48d1436b1d56d9a71f8ae6ad7e904ffa2a5c77f7ec7374375ff8f8d8ea554d3adbb592a0ac682d72048af3b2e77e1dd6a2282ace23dae24a69396624dea80a7e7f18ef9f0a3f7c81f10716f2c0bf7987275ab79ae05212ea647dc475c42e0363a92976e67be0a57d98dac951aa25ef97910024f02b330901b9c42fa1f905b2b28e6b7edc706f8935743eb9a4cb1a79399b5fd4cd695762dd78747f9a9c72a4b34d7c71e3805e58ac3a0fe2e52d07ed35156741c8fc4d528542f10048ec0f47209fa894a31250dee0776de7f7abf2dd694afdb80adb510b2e44818b3a3851eb2f9f2325c27929cd4b29234e753015660d14699988ded1f0982744c6257de4b8783943a62f80bc777949b0cbd9fabc58c8023f64da8ffdcd139c8f7b20f972442433dc35896de281641b2786a1e688d84cab2fc1b80424503bc3e501ae4d388bda7a096b4e3e3f1f3f3225ef336269996d44527e47f206a3e4aa739e2b52458f0a865648526cd408dbc94a6a9e1677bfe2fbd0bf1510f36804d23020156fcb5a1d2239389db49fbc0e87f08d2b3a8d1fae57695339c5f4cab5096029003be2061512680c1322308e0349daa50a061d3358f997b8236848881e82d3b70a4f0f5fab64b77a6d6a50db1f06642b8120047553704255aadf56943c21bad9c0e84e20b4f30b55c8f9543df682a09eead63728ea592b98039f042157d1b6a74515139cf00bf2058a63ebd4633ad68fd9eee3a57206a22efe6453d557445cbfdacea262f161f6aad7bf848aaef2795debdf4187ee55a54044a7f7d53bb21444624f295aae8059aa7249e38f5ee262a5593aa0660d61467ab2d419772dd1079f4768a8f3c1e8bfd0f9d95d2b9f2c909d1bb7d699f52734862e65a31a7dca52b397efb5f1456cf9d3d7c2dea8b3f1310eba98a2e4194690284fbd670fe61df51345c02e0526c2aae2c1b9b1c1ea18e18ef6213ef8383335645ad620dc0aa9a63b914e09afb4df625c4d1b1a127496140862191ab1fabe039084b101ab06ba4bdb8c9a3b536cd18adbd3b45d6500c23409bb33a221fbdfabb9270a4d6d452da341cbf77e962e49737e819da3ea999a7a739c07b50cc33e88a779f1cb97c0da4c59a6ac54ed3577dec3e00fa0597ef547ffaec269771254f148dfe5f7327cd70140d4215442fe6f5993cb650017956df5cff82e1aaaba5d4547185dba3cdafc6efae0439145a45f224d21beeef0082d912e369df5a01d89a2b3737838a76bda63050520d94441e6a5ab731acd67826ad716412bdb16d4432814c569c7888ea132cd5377972427e9b9b36c43da833a1b3e5134832d1d262158c11473ee322c113a443c1b95e6c501360206312766eeb54193d1d167760994288d8a3cb73c38b482339f2b020870e54b4e905b1398ac244965c57985f19aceeb6e18c098bae65d75bf09569f1eed8f6140d57f12972ef1c157ef308dc464b5871c6d5179d918a8e4eb7fd5253c8ff38554eb859c2c681eb40b9458661df35c49b059f54f33c98ff8d0a0691f769c2d6fc7f755ae790f1c3f593cd04ade63e437e95ab628933cb6fb650063cd6db4acf1c18eeb5db3245f0b4a6553644b343a80fa5cfb5457f861d8e46abe81c90a8eebd77a91790ce0065014caa0884d0bf420e572a72a052a722aa0489d8eeb5ea0e84c703b5f25ccf316dd969785c358019a488c2e9f65afddb5aeeaeeb8eb45f23dce836a87824ecea17e7cc1702929855543e03de7b9e007f16200a37bb291a713340865461c664792c3cead2f98b60324615c54e10b27a34d62abe349f78658e2cb005a5ad5c25c6ff8fdfa30b3561cf69fc69925bd577823e8c9863dd11e14aea73230e15d5dc10f983e18c220e4f1b9939ec777c656d8d6b3ddd52a8eac7a3446c07e078dfa06ed797f0c86657b6fec181572f34ab1dfa76d7807c458850e2262c26f46fd3404730dae9be286528cc4bc0bb0f241ac95442b3bf85c3d683291c13fab5107e4e1cb2f9115455206be9d8ee1ff28c2a1064d428884e5ff8c6682496ee43276e367485c92d786fcd4aed03d695582c67c53bb6b575230bbf0a12c9fa59e86d0cecfb3ee52913dba0c3bce0ef3321e135c9a3272d38fa7289fc077832031cf59d5f7ec349ced157ec581a0a35fe98aac43907014369c929dcf15ef9c5ffdcce5a2d8d0a7eb4aee27778739eb1463c2bd5f252439023909a276fc3d155d80f8155f20d361107af7d3a3fcbcc2e189fedba160a7d78b12542121e69fce6d82920c58cd594cd2dc84b26a22be083b223874330c0eb6439bd557101396abe68cbde355d275fba036374ff20f2a3ba2351a78d9d3b14e4d31db448253cd1fa299230dd3f8ed729fcabd330638f7e546007ff7db504f7d500857eb52a99f20e565b6445eb2c86010e658c84ca5bc30bd93e2e27facc05d1cc67f1c2ce613131fc15a506761fbd1a372bba96a527364ffe9779fcc4d3470652f443a22ccbf90ca72042a24e3cf8b35fc1d553f0be326fa70439761a99d4aaa9a8506133a8685258b4f544c9173d005ab77d414e40fd2ac92e656d69467162e8466596aec1a6966e8a52d37ee04311fbf6a07a17e61cdc744a847a6da2d06fdfca2e865d69b2d2e78d3a5cbfd681351da92e36ea571f10b9e04c4874b61e0debdc6e0fed42f42e3b4c9ae8906654341639d617ed7ccc8a97ebc6610c98c579eda9b06f448b2ba727860afb732dee31bd26ce1aa1b4442f096a1a47d8b8179764d7d6d7197ca2b711487a857cae924756bcc6a7847a559b5c2cba59ec8d5e14de386c65c67a028b72a79ebe6ce11f05f27d69f684df684f3625d789a020569b2512596ed280e3b1beb24cbe4ca2713bbbd487b5531d012af196cf11267e3aa9815626fb5fe6ee16a9a4a2cfaa1325bc9ee174fbc72140ebe5c90daff2d7cb54c81c67abe482fa42d64726b119f65a0f271d1c793a945403b00e7ad359da0c94f86e1f19abd0b3b0e7a5d619fde6fdffe3ba30c38fcd9388507475dc57d5e318fce65a32495eb97725125897f64abc5eeee031ede7959679052f3915420ba8824204306648c0763740fc160030355e3165058fa60c8e285534c44ee177e0f8b388c3764837901d8a95f90ccdb72d2dd3751bac412a234eede8ddee6383f030f6a82180264f568e895286934fa43931d57fd79670f0711521293528794bd10f44f04bdb99c5a22efc8f65d2124c9bda6a6a750fcf3e7f66fb85f822927d78cb207d6bf4b99a5044e938a60efd271b6d0c338b5e7a87c5c8a08f0ab37d90aa2529603a1b9d458b33d41fe0f13805927a0defccfaae54e24f5b24807e3e09c5a9b2ef7a1127e09b75ff3d9aa07e8dcf75dd28f1cdb4c257f0e7ac3e247a171d60e4d03ac3ef0bb3a4b4a98141beb38acc6aa673a6bb0e2c6595db24a7215191108b29617a325deb968b41d4d5e2f14691fff8d5bfb25ed7996874d23443dacef4b3225bf0e6887fccea470738c974f58f33ffaeea57f6fa72b3886273e918aa69ce4404f4821fdba62375fa0728845ada47b927816589aa2639cffbbdad6c34ed697f1b95f65c8535c6e7b049b666aa9a8f9730fefeeed4338154944964fbe322b57d1c0495d803931ce669a008d1dbca2d788474001576be12d9841294e38e18c5e6643c8275be8b1e4365576215e8c3300e1b10ce35b3282483f24955f53b42fa9bc56c9a1efa556302cf4f226f30bff4ab373340ebb9dbbc3664e553bd1723b1e1347a0fef2d43e2efe78a058bc620bb5cdc390334a6ea46573ef2240bf4dd13c329d1d657f6decfa68e2a50912a95461b0b381c3b522e6b9d519f4e205b95ea4a006a521889a2d96639ed7f2d9b255b4db0bd500b24335808b1d278dc4b033ddd8993cd0702bc92a498dbe6f02d61de0c12843c908975f37fce3ac76d140d290b5099a56208769e5a0af71129a61fc757f336e2015dbf1560a3a599cffcc96320e59e3b5033ea8c604c10cd9aa6ec7dd223a12b3f5a8743308aaffc50aa2d72a1f4e03a1fc68e186dc8a2cd9d13d0900a8a8c0eca392751ec70b199b8bd8106fb1a569ef9356d2f66bbf2c28f120ae652091f57e6e8ed21fa79a418d55f1f5fb5f74a0430e7a4fe5a31382ce6a3d2df8636c9663cc3a15f7e482411e44d4f7135b3a499195940e9dbabdad460f40fa1f9ae8eebc3904d3914b7683a0cf1c2a60b381cd799d3185f778fd4c0797ba20392d378518c77a806612dae0c55d662ed1385cf48ae07587ad7b9945d956d78d0bf78df25f32fc62261b63dc1ef591e9524a87d95c47746a706361304a5b5ec78cb461ef8fe247f5ab9f58aa26992968ef02f8b502167e852007c9264a12c02be2b6f4389dc6784c576cb78c692318841a12d7a5e1937bad02854784169609f9f19fc40b1eb1548cbfb07d00acb199a048507758b0a566e3665208ab2c430c984336d867a4cda5d76098896df4d49e11afb5c2d1c4a73e85ad1551686ffbe2bb8a5b23a5ad9fee96e9b6329ab0eecf2a2e919afb870ac30141603588e6f3c834959f9011ff30501a194f81df062bebd0f94c62d88083852d1add006a04ac38fe35c5e8dce6ec297379de3a45a0f5ab75c8b041c7e0858b49af5d564f85e6233e3c0671b8deebe204fd2660ca664bd4a9c3a389a3eb6a6e11b39083e83049a8a04df5763876da5531140765efed77eb28477dc446578e50067e88aafba082317c3526f4ccc56d84f1119e7e7eeb1bbf2c31566b15c39c32d6bf29b4cd257ec5769b0b708cadefad58e32499d5114b48ca3cfdab1477412e060e6823810ec24521f87a51a2b9e6a7d75fafcb32315dbf8c58facba827fd96410373e284cb16485177ced8aade29e3288fbaff339f9fcf9f1000cea62979f68d675afc730bd8e5e9b658566de4140087241f720501abdcd5ce41cfa74e0e01e69fb458cabc7897b0f72eea9039bac5a17810fe84182d0864d431c42859fda974aa38ff594717a8b91e65520b5f0d7c4a2bf2447c1b26f3305e60c3fd5e132a295eff050d9b448d0b8799451aa06d3fcaa14cf1e08bfc80cba39932fd5838c3f0f25802f9bc6e2c9357b61c6487d785219b6d1feac65356053a0f9214fb90fc35ec9449001af856e28bbbf95dfb0d50903271cf197736cee61a7c504a1813729d12d98879297f1f15dbc6d5168de200cf5a3158833c4cb22ab6be6e396b3c7a291b21ddfdba18ca4cf658618fdf7cd78c19c973e9c8898244e87fe18d8dfc86761745d316a8d7c2d7b354a7a7b575486e7d57e184ac9a5c23e7d9ce5d70c9faa84996d842b763e20f7cb74fb713490435ab2231677444c49a801c60aba822e093c0f087dc9c26903934c6ea840515a2bef6229ba75804f6b3b83efa8e056ce8ba6c63197796fa3f8fb448a71b51579142bfb86cc9fc0251b7c45b156c0605ebb2265f44467d844c168e0056b43454263c23af5903297555f00ae052fdc9bc6d595365f59a50f53d0dd0470aa237543b66e2d0232d38a910fcf6a0ac7df12aaac03e67b2c42399ed1b13ce854bd51331b3b731580d46ed2a374bbb13e675018991a36162a484fd60219e2604853bfa6edb270b816d7896df1a52d46ec0481839b0653f52ad7a27b288e5a5f8444fca4e87b2fee86f0318ff733d426d141f85d5c444bc3f29261cbd3c72955b0400cc5fc35b25c155ae258c489b03718ed13f52f169090b61c31889dc188288d3ce3e1bb40644d826a512b6770d104befcbdd9628bd3b0fae37079334af3900b295d2f3119a92110da60612c3c42f40ba3c77fb9129db8d58e04e4ad5bb5d35ae6435a8d2393df0e5bc0ba5a171301f23dc6a169c94bf7d95a2706521d88f2d62558e5c58ecb505ca09a12d76ffb3806586c19a189727f674b8863b2b78b18bffc9d78a7e6349dab13ea6583a948b7f1056b40d0a616ef6cc11cbfd8c43f4bdc7b6c94e732854e5ce887e35e0420cdcaafcee6fdf9f85c6e7a2b3b85c45cae6bb8b2fb779892ffc785e94ecf8ea7cfc0bf17edabc7f3ded9f535566a540bd34bec988db00a4f6843db5a8dd005cc0233bea594586b861ff79ff2a9d1d6086437293a2945e5342faa547f71ca712588ddf93b5d19f1674f6a25a40d8ebc123a1deb808f77f74b32b5fabd0130fb33364ce961be83a889e1194775de97646a6ed889c731dd5163a3cfa0313ee24f7d9a86d03bf65d3048d790fee14210d5682411a8dc9b0c6e53b0b3815f57e4a7bc280ee6bd38fc7a8322cffde84398f5577c52156f85046fc9bdfb68b121b1d7fd1fb7b2b174713cc611f39b5dbcd9190c7da86d8b83e236fe4b6eeecdaee6f31f1c2855c27e9324173f74fbb0d6d08e1174f49839914d8f493cc5e5c9abc6a27f70d860a8a460a89e91cb92f524ce6b9131ef6f7d535b61c5a343523827a34bd542b0fffb4c56cf33f4b9264c80e04e48f26ed8ca15bb51d89519e99d9769199d928480025d71f03e1cd3a45890555f23d163fdfb27e8532c1d67cc38eca4b77225ed04a20bc1d2a7b2efc5611db5e65610abfa796cb3fa67408e14aa9d1417e78da1fff2f9747e0deb7638341b758e9c63bc4a35850bcfdf79789bb98f31120ab1504b29531f68fa2b0654fa3dd9bbc9744ac929e3efd0fe991e0081ec538a195d8049025568305b57501a17b27a40e29ba7e0794c68f95d215a904aac913329bd66fc5cda821de8d756a334148379587ec7457e40386dc268eea338f23d1f7c1c66f79f6b75973cdef17410467efc2b1eb4b77b4a3a190e060fc83dc9432bd510b5c2f51debe0ef5eae2486b3ea946cc57e7b3e434a227bad8af6fe8b96228bc87ca8edaa3d0f5a255095c02cd01895fcb4dbfbd0ad70311ae472fbf083bf518b8ae0e2cf4d40bd0a0510cb51f9d01d8c86fbd689268b113cbdb095bddc33b7b6aac29cead814054b82e624026dcd66f96c196bcee573f6a8d1b95b92228f979143fdb72c7656e53975f7db9ecb691b3dc96e2d376f7e6b93fd9585020f04a136758b500cd753a2896f6f58f86a44ee5fa2fd5372bdd7dd47514a349f504d3f0302898e8c795bb28f7a77e0f2c66096870e61291d3a7ab21e63708c5795f4cfd195c91fefa1f4c49764c743405b0b99bceb5452f7130e6f9c92b304cec0b808f0bf121d75651c9e3230343787875c5ef43f684ec67ffe457b95c0eb6399d86d044cfea0475d5f4f9f1a19dac5da194564c37dc486d5406fe1b1dd6ed5c26ec76db2bc4ac206880a6b83003739a64c9c2ed244834916aa2e5d6ada1f2e956be912c3e7736c89bf3aa27696863797352894899f14c487c6b720b29677c8ddeef7065d047c52d187a3e377bc569cb036f2363298cfbb588523801a351a6a9d0496e906091227784f7fae5abb4ccc627852b7a1e7a839ad9def11360e530440f457b8398e65cec0fceea56eb0edad3d223ab6164a1bb654b42e2af54f1fb8a19625963d0914f29f53f0c5c9155593af3f4b3c11e3740a97c7efc2758b9b600765965b2f382ae01ba83dff3df7c2a4d8ce162826be73d677c7599e0125b1b493622e0366c65b858e3c335fbb505879591b58164593aec6f78d53beca511e0d65ea52c2dca7e4e61baa42904b925c61ff77edd6a8077a69453ccee27bdab2c9e416cb15f7a3d72a1ca36aca7a44667bda02a91894bc7ca6aa8fb257c09c5d02793509cfe475c110d38235d57b4cf3fd0bdba50febd303d18f43bbd9cb492c120eeee9b3a9431d6f07a5b697eb84506c252909980c1abb6dd51e141a8f549adca210a94bcb993cb821bc06111f78c2ca166036237058137e552e34beeca62741531b068f44b7680750ac4c2353ac26b17e35ea349e61696d02dd67bede21e4cfecde0a6e41816b85e7acee6e0ff2c7da0255006cdbfd1ce28ed30d734e27da7141db3d65048aea7c3f428fd179b939ecfac811ebd6e28107f39b9c1e8d3f435162c72904c16a19389ed998b395d848cf7a76650c5cfe1419613b1ce2d57857e6996e7e430f6a66a743435109743e2336b97de3cb9c543a52818cf05356117c2f8ccfc1a9ab8ac9ec57a3679a815b0b4cc7b200fe6b423c4d857c75860732a170fdb18c8646510a9925de194fd123c657072b12341c85e43699b01a4dfed7b409d76395ab633bd582fa625c1ecd50cde3cd35cceae4e8d9d8455783022e574174a7b9092012053ff25cd30e5642dd667d55e5aa27a620c2490cc71d924c92ba5e65d4aba069d85b7817dd8069cf300a98e629d2455313f219ae2426c75aeafb267eee0a26faaffc451503c39e82404c2cf8cb403e7c959e5cc8d9fbaa2a2d251f08bede7084ffe424a0e1e6c03457fc9e2737b8fd6f3b02693372fb9daf676e51799640de1a04ab4456c4fc78465a4fec7f793bb5a68d2ce7ee552e57fc74333aabce16950ac73a521a831f6cd2bd6c7536623be5e5c2e458c280ef107b90b0823acd347fd1cacb1a57009a5368c0b994ec70c03c79e7f8def72e3eba9f5af62dbafd94fb20e0b55cfde73676cbc2f469b520e71e85fe5159a22d1c97fab042fbd7998b2d0256ee844f88b90d122c7bfe408c853654a6a4667ad3ab69cbc262f9d14b942ee105a6b9bd4fc8323278e6dbef082d86e9a2a5a04d6ff5f12776cd934c34836fe89a2ea5850b04cbd8bfcf38908cc2802c7a76eaa7b51857c86e9d0df491ced26697010eb141b2ba895a272a54dbb3f04cf435f877444906e04393f592a09d570e032e95eed73064cb46279191ef76208e1dd6c9f4079d711b9d19004fa9b9900c2f257e28733ce55599abab50405b86657e69ee801173287699ff32f6b6ed568fee43807c752a070f9417e33c3e14b0e51ffbbe48f1f58594e9a55589cb5de9a4880748d3bc6490a2619793f14918ea93bfb6776b113bcdc1b79c960d06f30944fd8790a477ed86a9fb577d20d063256bcd36f250f1a68bbd947bc38aeea87fd51df40e623b9bf67c5b4b3c9d81da8a207f149680c03af1271bda7b4c1ade7f44f94c3108dd398940a5a4ce8c08338317f182d1093a3a7acc108f0b32722b71ebef5b983bb5a33f90d2b23ec0d4c874c1fd4a0b46d1e98ee7d96e8812f11cafa85d04595035a29545ba42e97557cb28369e2a3eb097d8a9968343bef6bffce43f80901c301d4665dbf638d97227f7c922c3c02550ef49d1845623128013f90abcd44a32beebfda79bc0b357ca3650cf80f4bcc6deac9d40f1d25c672da6e66a49819daf6b56a9c2992d7c8c963d0b8e051ce40cf601f75ff17a7129ce011a5668ee94e4b28b64639a93cc66a2fab7886bbed8b780fa1519e6098fac81a961f8ae54f7c84fb38742f61786467045bdf43851eb5574409514715c594e6bef3a2c1a47895549324e2be829366bd6ed782f7e587ae992e216a800f2aef9957867d814ac6136fbca50de9f08df31d4dc15429adc1bf650e4b1cc4ccd17c30a4b5b3885eaa33c12e0722714654c26ad95948edd749e8b624e2e4cfeb125e3ab944c9d2e6c51eff3285f8eb7d428f5a5f2e3e9686edebd7a0ed29b68749d4afe831c274790310a0a678ecc9514f831d5e71b96e06c70c2c2df61c88714589f0ca075ea6c9238289a05c2603abe0bbfc64148ff425f933e8607fb9c68551f5e24b43c8fa8fca10798a27b20283219c9b7e1ba928e93161a96a02f93feef9ceb201ed5903053190a62fba68382b232aee33a640415602104c6d59291bfeb47af203e7de1570a6e18ee5175b544f76baf6e3851597d9dfd9d8ca4baf1803f518c9957bd525744b2bbbe17c54c3c820f1bb55523182cfb169e2af12541825050022f5b83a273ac536c8d1698c010f890adff179809492923c3658e2411f743accc0cbd953787517d04de37a6d62c4c4806e4cdf5b1a0f49e6726c6182272674ba62468385218186b38b0ecefc6b4188caeba12f4fd192e3fc2828f2cc0e1ef82bb06ff53b045d03c687e26991fd0b9cec2e202ab9f1f709471894ecff3b5f8d3c6f5ec721865fb8547dae79ca537eccf8ea0b8faa8319be80eb9665a90d11d8522a901da913c0abec04de4165d6e460ada9c6d612299f3351d915107c400183f485be44a2c8227518d4758315f17970380801385256c51669c52d683ac8265843ce1458aacf8ffaef1566d662b393226e4f30048fa7b6604818d2cc1b43a3143971ade6c85241608c00a816b6ef61ac4dbb328fabe17947ea34b5940f7e4e02b9300aa1ce1f56dc26a0e3995ed4e6264cc54eb5c0f8013fe9a7e8c78e687e18a15369259a0d93334dc7cabc93d554df2469de27e10d7f9afae1d01e810aa3d8751c87385cc93aaae5ca21a491001d359ce1a07b05f269a3d12b1671d1db6719f1478ff3425be722531664a80c4e85af1caed46859d6857c80ecb4be09667c07fb61e538fa5aa4bf491fb9195fab0cdd1b4d8f86984fe293e31c357eaa3b6a4213d6eeff5648e4fa9a6de5ec09fcfac00f7131fb747e90d29f0513fc9c6e85b09ccfb0fc58d9a42d6676cc648609f3c2f09b9914cc4a003a9d564da994432602ee365511fba0f56e1824258f10f8342e34384eb97e3d5509ff92222827c314e94d57e96eaf4f3d47beb06fc0b839d6a969c39253fca918c8da859f80eb79a8f36b8a7a5d96fe1ca40a812e062c3a8eead955d25f71e1bd16987b691b70c5ded62b6062489f53b150a37f147e28478205357e7a2de8381624ee67c686b709ac6dd670b7b079e9192d796c1c975bf86fb34774fb5c23941477e9f098e2d230e6c787fd01a094d1b6c45028c816c614dff1fb0b13199315690977d9a545549255bb460340a4bbfa6d33bea76814e7e1ade0e32a297f9d7dd611f0db21ad0e51159d4db339dce49028a65b845bed88a34d72a6bcf47b1715e718326987244e7b3e5bf90b33f5c16d531f1cf27b219e33b8bf6d2932820eab00dba14ccf781192d1942e570960e7035b70b3bdccb2db275ef60e5ef1c176dbd2e7bc932d9be54978ca280e89c0ca04a75de1e230b26aaece0935603583e6eee928339f19e62cadeca9fd62f61659028ae11186b624183e86ea70ac8b17966be03e22f3e410ac6312e07929c179f74efc4d766ad4a4eb1ab6376daf626df2c84a0e95326688f0087b38e0046e978600b58f6ab29daaff98705d1c1081a9b8d607f5e8c7bf12f894c647af9c6a26e60fd498058f63c7aaf96bf4b2a7ea5865b12f61af9ffdd2ba5550caa57e4e393905fbd890c61f4fc44507b6b85cf403767b1054f0aa19d601b6768b2c17392cd41a1ea22a42e00a8ec0479db44281404783b1ed827afb26c7cd8f312246f92898b7d974cf8028bda12d3b011c77f00f29deb6cb78929e06cdaec38bd740475e0847a9a116b52a490403268199bd9d2343833d8d38c6d9254973631cc574f3201a09b8574cd5b2a20ea0fc5061b71c638798134d74588c21ebcb9654bac9ee71e23e920e967156864c4c0de667fb0b4613a87728894e9fc6b15fc481b18e15cea69e432516c1a79f04eabb9a056fa15cf1c1acc310c53fa6a5813cb3bd42842261687b5a7a0da834ef51bcf9032c4111de2856f8dfa29d22e94fc4dddc133ad28b628dbf73a0c3e26e1f3f00aa839e0ca5becf09f6c39275cf11d5a887573f71fecef9d236822fbc3222c14c02f3e2a8dc6e45db10924173bd3af6edd01f36affcf55675f4b1bb0d7f4cc27e21d78986700116cc4f608b9195c239ff602c0be1146324af63611cac7c68a32e4eed7da74c3eb896bc5d0950201d911b3b229f2b11ab4a4221f71be06248a5ff3f6cd867f3586646f69de44bf4911a6c13736a184584c49f71c89d0cbe3b4fedef691dae887e0ab83f44e588dc45763fc319172b68d81c54646122e870fdf3f7d1d463c52276a3f553a3dde2328e917f69a7e36586052dc7eda85faec847976a1970ab1b0853fb2f9d6b105698f27af0550ebba3fc38f22a7c0fd045ae6731389c59a3b85127ecf79d72f2ada001fa032b227cb845c34aad3dfccb2a2ff07db736459659c8f0a6ece6926582d7c904bcbd11036a25e9f561e98264887b7ea022b0da3984099dac21bddff87899567969475362f848a0833156a2440e6a38592c4e785e259cfddd4bfa4953d5c14488ae41ac332cb11540f8bc9815b17a2ed700d9d9e94862765f12f878537d5f881e7e73be9e746374d71f000f49a8add3ce533b9d25e7de47085957ddf239e169c70c87abe32d85fdc2313929b77292617b97c0ce9a2bce120fd30e83acaa818c62de5e4e0ad0ef4b42adb4631a6a40bbcca3388cfdcace141fc6bf9292eef8c0298dbb22432d7ae1937741480715e57def281c56c80b58681b8975c0bb4b4fad8a64f00c5da11017ba47e43c4ed10bb54a3647577d35767f2edca0e4f6ce2dac0adb741c1c6b397a70f19eed267ed89fd8bb6cff74b8ab0041b795a706fd71ef70337b41b908a01aebce6379f4d65a455e01e8b365718a36b97c6fc1fa4c1bc8e0633b8f7a96bd05179def5c1e1c8f311b5cfa10cbc9d0716df854b56f4264a8a5ac6bd78a57cd23bbcec8eef83d899e7bc1f4d6238970062b41c14a2ce50da5474b7bac408e860375fa3a0ea814e3c9aded6cf93283c54caac26f98d146dfaaf538733db57234723d63d47834b4895f76ce31f622c8d483c770b884903b755fa8c5fe6b599011763015864b5fefdba9f844566109ee375f5934ebeeda10706d50a465cfc9d00bd25b690c13019d38805e85428c255303b60ddf4c1db4358be14f23c43bcc45c7f5314b60d7bfa65c291348b49f48c76688f8caf2f4c41c05977a6730e61d909805922e61a2d47eb213b0c2bb6b38b2d1b2e6c438ca386aac5d6d81838597614f77b94afd87c443807a57826cac7f4c3d19120406266a4e2f79a1cb3554faaf6ee48dbb2c566e7ff0d0728faefaa98f6438f3d0f357c4aab7c2328477f5989741da3d53a66e061fa304ad58f83d68d402d5ea95493177246f37261ef9ae7ef071b9854d48169738fdec63a2449f9ce2df2c37e678481475e3b799fb7dec7b5c8c69309d9a7e1284c875815e58bc3f68bf3a66aad143aec6302f9089d90c89b20e499385b5d4b35b0edaf244d2b76daf5ea322155385ed1de3fdb886dd9d127221dca980a9caafb2ed647460c43e9fecc70dabb7701e05f9f65d4765fff52f009e8d4938101194d49da2d037ff64e6311c5a39c5b020b864454112b43151d986266687c9022e424f91a66bf4e05031e62c285ee2eb53496190b365280f0f22bdc85347c6148fd34a000c59c01f381c296c7e8cee33016fc6596153a8ab558691f03625faf818014d8ccb1e810fd7b9085a470053a1df3c927b21b893cabc26b3d3e51da1d724d8dce1f6008d58b82c586a2e6dda2c9d89c0a39c16f888e3e12e953053c6b2bcbbc84408f29c541955da71f18677fd26cd2235d3bfed7ffe1e38c03bab9001b7556e7794a859728eb5513c6dc08d6587f22a7d5b6f70ed281e07cc195e5ccc655f3b7d45f90bf3cd16e87870224b2e2547dc3e25f441a42d1c69d6d4f3d5c234c68b92d9de7addde989373f71dd28e28e5fedc04d052f61246d3bb86760c717f63715237878835b544967006c086cd27675a2c56d767abab39eeb4cfbb0b648b37166447361b793a9d6e744eb0d3e5fcdcd0208355841bc30f817d3bc23a0d73355e3c937c6dc36553957d7367f07cc2209a1fd36f326dca8f4fa3bce9aa25e8a6c229578bf3cca01471463e9d6a90aeaa3d7159b68e6de470899e7ff4cc3e074437a519bf739cf45c291d6f095ce823d8dac779f790be872130b5492fd4a60ef7e36bc03acdabb840a1f66122c00e268f0c153cff0a1dd281e4fa85f8adad1419bf120489787d0b03990cffd3f9f059de3e203edd4394b6491db245ee964d9a459c5e6ab0bb289eb4fdfaf81b5d52689dbe5a90a9aa6eee7ffc5012a5d4e77dbbbcd4597d01d9402b81f506531a020b4450d4bf2209b16469c1b467fd1c9beca507784ed356d8092e72d7a64833541e1fb8a0e7cbcab08dc77340ba1526aec9f0a954c2c87561249b3aafc00b351caca3ee3b00919c2339fad85b8f27b5bb7cd7d7cf193d1aece3858ebdf46b979831b5d906704e4b234a4d47b991cc86c0aa9f3da4b9501ef35c7c5d655660a955600c50705e7353ef7d795ed9adbda937307d5d5250ad873a8ca780da1a1cedd0b6c360de1d0f3a374422757edbbfdfcc3c23e046e5ad9532e8d6618ae1a0e33b6b995281292da618d4d60878315e6346f6311cc61db80c5bc60105b7786e738c1f51b3f409e4009b7fcb68bede92a959a4d8b783987238aa3f5564dace03f289fc613b548b815eaca707919770b5c74976bbbb7377d11c867e6e0e5aa46b57bd20af5b516f301c82bc16f358d9410aa137fa2723501272d89eaa55946ebf587050ab47cca94266ce55d7f36c1faaf5b6a3e6e0287231cf3c2e39f5561a9a4409b951b94278f16acffc2b7c568a959fad4db8f8a1de89bc2acca21133f0c2cc259ad8117b40a27297c19b6d5576ef122acdba67a386df4dd2ae9433a5c35d9eb37a6e0f8d204d81a8c1c71dc08ccd9d0c857517474b2b9ff83d6fa23f85c89f7392ad394192dca1730c20d062d9785af0ef3d4d3a8c3b1b5e441f76650a337256d3b92d16bb49384935138a2e01896d4bc109df17bbf1bd30b26438f840c0f567e6437e7e0c38bc732b61fb024d4570602cb1947855e525c8235f0c3533f630e6cbf3e5b7805332725d3a6e0f944947d5947804502a0145b1107676a410a0ff9d736735dee87a77df78cd3642fe8088a1fa35b18d641c85b29daedc7477f581280b46ffdea85aec8e0daf970d2e6ff1bd843dd3f0ec94f492bfaf1509a6fc81d74c8b09aea588029deca433c16c5659a87bcc0ade14b30f83879fd2a45b1210d5036c707e5e5d1ae4d252170b96a8a3480f020b1892c618a7700060897a7fea7c8e9adef64cfa59e3f513beaf6b6734e3a421befdb3fe7fcd5986fb443b714fb2f7a89904fda03b6a3993dc8d4e2de24662d230ca69b0690daf0fde55dbb7533f5eab92bc7a277f9c8783c7d8029cadf7585000b37f5e5909a1bb45f22dcc53ca9a057e239b1884ccb0321bfbac3dd7eaf7d6a75b4ac058075aa4fc3e1c2d788c63b6279d1430ac94db40cdf82a8eb5e4cb9d95abdb1a02f960869207ffb5726530e38134d4a72ec65aac8c416e531d08348c6314fead5f09082149d70930e930b2198741a6333a4938adaf3e1fb2fa79673b4555b811d089efd29877bbb2ce60a241ce7f84ff7d294f64f9e37dc9eb35dbf03f5c05a2ef4765c78663246c58f0c3202d722ae9d3b1075009685a41a8cc7ebf0577938e9aee52672a185a266429412a985eaaa9c1b6cfa61b2c67cf04149b39e8c0d121419b3ffcca69eae7f69010011d60494d8d55e3d8ea25c3ad8ea199399985ffb466f83e005caf926086ab07db84e4a02aad26254f13be27dfd00968ce0560d5b02808c32c664ee8b3b83e5322523ff41ef56ddc97b3b3b012714c54af3c398f8c15d594556e5d6753953f10e4aec6e76b3446f407c06ee0fb88484056a8f46628f5f1c4f0a8240ca8c285b5dd86d36eda288eb74f9b5b17ecea2f3efe6f268bb3f6ab02d3a894d5fee4cef0765d17fb619468a75f036bb990dfe8ccff52a2a80491353c593bbdaf026960dd78beaec451a7dc046dba78e73c8d8e10d5d3975d4347f44f664dd2ecde573d95223d6760c57bf359cf361bbb739ee6139d56ea80362f50b03ba221decc08b6560e9ec836ad996f0432f20c80e60699ad5aa991d7abbb248da8e1ceaad6761eff7d7835b35fda79bb9010e3076aa044ecf41bfb60848bd84df6310fc331b1ad439bd0a57719fbc682b1cc4c4c55f540ad640959f2d762880fcafd818f9413a8a003330f3c0e4832d06129e79c60b16456b4024ff779e9e9416ea1738a65c5926876568e7f516c9bcced1107402e841e8d3a80c895fb7459395041e3b5f0adcf5e96cd0e3eac5ad4a438b372d7731e6a1f7ea18ebe58e1f4a0d4be9786de44b2e39bca3cee2cc5fea9da9b6c2e0414ad76ba1e1218a0e77c41ba245bbe8ca5a3674174dca3ad6c7ecd4bc72337c325dc8cf9ef908cb8a001ecabc341c21e880f18986d12354380ac2c66b61b2d1ffa13fcf27dc93e3e4ac2d02c0e1f3e32b9c2d26ee8b07ddda15321acd5ae29271b68f2d8a45912c63ebd5d16984b1f7a90e1c396ca3e6cdcbd865092f87cc982455e6ae056a143247a6673b95363f6fe33e3e60171c0f010507c0a95b0148d8034c9a92dd66239ddfe5c6f204f784f542bfc8c9aaf84d3c8e938f49dba389e217fefcbd86c6bd7e4ddd9af6809761faf1d66622ebc31edeca39fd35ee5adc630c5685c771dbabaca9fc91e07cdd038a76d2629373fa88ad1b71a98e35c6cacba55def2d525f4ea0a991fed22d8176cf84341ae1c2272d81b0a5338c5c63103b85d652f6a47d638d97192eff26c3e911d0dfe4550fc6472c6f2a398787bd2dfac83bfd79a31eac0018ea0283ea4d53d9bd243288b922e9aa08617e154fe288f36733bbbc1a3b16b71c93d2ebcb762ff833955f4ed71c516cca58acab8333ea898b8e4f9112e45514a6a3f66e3da1977763059d0069f3b742c7b0dbec559b75eb1b365f2fc20134690d054782d61826a0d582506d0e263637936ceb1fea5f286f84593e5525c17f83c5d032155bbe65b41ae83a905ef01c73471e0454a35848983ab2d57386ee8dec19c3a36b73cb107a04ecaaa69c8249b38181b5c42a8d837aaf745fe3fb5731fcb33ca0f14e0fd9b4207f12c31b9b1094696a2e9664235f1314f15bf1b5880d247c04daed69d750a0096ec38e5cc6c254fc720fa45eaa48879ca1907f24507b4221ff103b5114e0f4761164efda49974249242c0df4327e71e3e2f27fa3c51f7e52221591b1f826a4952928ee35c06cb5f4d238a3e33860e1df0e6b418a5937764a66052ac03f557c980f1201b569bdab3eddda58e43b05031004c95a18e0e93ce215baf675865143e15dbd8bd34e4bec551ce5bf7d150625e88ad533b5bf675db62d664d55814b503e0ebf0de184a8ae76f0508e9d0f8c88b2e17231864c60bdf74ad02e77bdd051431eddfcab6fe412f5b6abd37b422a569e2b5cdcbbe9607e0fe6a1b01472d83fa53dda703bf0957a9072dddbbdf525daea8d60f8bd1f3ab372be61be387923c84bdd2ae8c4b631954b72fb1c79974514010c37b7e0830e37296a0a970483299bd28115012bbff62a0d3fe2c592f52ed2d405d11ceee0417aefabe296829a4c1c86ec5ff7dd5139a0303b48bdc0903aaa96a203f43ea39b1dc7074f8016bbb4b2ebff3526c227670c02f95520dba7322978eb0a7cb576d2370b5f282c82b2e6f52a8d1a28f0d985cb62701e99788270897a9bae714e229f28de64697eb4aa282cace53229bce22522f45185821546ab2b7844e450675efc6486de314971bb58321ae9b4ffa94e8d5dfce899599180db25dbeac54a42348dbe7487fd39d9d552bf4636748a18a960b207b79e79ad8fd2c20d5111c8403bddea3adeef84aea6cbf4e8e74644fc312ca88b25f43781c04adbbf1b80b382dbbc40777dec75541b38c1d126bbf0e8a9f487cb052466c4254c745c41f50e5c26e32454eebcd748db600fb32466fe13369fb37d34a125f1938088a42ecf4fcb172071a592c0a59938deac78823fd52ebd9a81762fea4148837e9dbe6510eee605b0268ca8ff9f5e13fd34f3ed8442e060e99be96028f86a85a61f4e5751ae48e5f9828c566b2504224d5eb6e1c7694c811f60b8ec22b050c1bcc4b31cb10d4dae4607c7da590b76ce53b62ba5764a6fb93e912c9d38fdcfcefeeb5d70fd3b0bfdbf7200205f3ab86cb79802393a67e5d0f4a5ff1ba2885b62108cbac2edbf59ae033f45a9ada7c96e593da31ef8e30e0a552b104108bff9e7c94aa5c0d7a0043f5c94dd8e5d172cb5133b3697691241e6653c77a3a13aa9c779b9390876736dfba6e1ea573b00018b1fc5f53bd120bac2ea09f74da309bb0d6f21e879989845e78d0b7b20a034cf88ac2f411735f66d716e0d488505345835f8879f8a2f781fbaa7ab30700432014b6628aa1de47fc23b4073fc401699b4221feb8c5dcaaae16f70c6a6be30e6e4aef69f550434060a8797d15a6d74ebd46f58a4a97a5f7c251aa04fade1d62a7b8a17c772349feba7156f9e47ee26c06b7c59bcabe7abc4602b96bd12b2491651161641ae4c9cc159a332627799a8c8a05787b4d9dc49899040ca3210e11b85c761c7e765aca3ea249750e04bfd29cde6c250c6dcfbf407ba263e4ad9a4ed57f481f240c2e3be7611bd232c5b4f590304f00da2474d1440d36d574c651b8ab8f53477800469079a005565d4391c2a14db3a9b46fd8c4e44ab1bb7faecae4d2a5f41802c29d74bbf1a0c17a65d9d7f3cef6a46a16af86492a9493e98b16859b7d57b636b493c71dbae2ba37b6a6400cd609322c4f110b16c8f6ebea940a2a758c0f88d60da97e670f0374346b1cdfe0928397f6e94f189d55798483b37e0af6170a25e13c7775df2e5234692d9793aeb7226f7934244ebff6335e0817a7dc504be3dbf613259dc1ea8cc1effea7765d9c216500c320af900834a6d259ec4954779405aee6dd6b6b6b029dde67425364065d394fe8071386de82db212a73457dd08a7c18a8f14129b29da68e50a45e9ccaf72c777d703d3910face1614bfd8b438f8e3f6d8ba80d22acd647fbfae15d3f2fd459411d69da1b0695b47958e7e0c5c5fc842fe0133894f2038e35d3f0ac98d0f8644f69fd3d1a4f2962d678ac5f9b7e0ad75296c3f708eeea0a7d9f2bd8e420dad7bef8a0b0727b6c5e81b3c2a6d12cb8d0f498e047a273d1c87443c397d65562c163041024a5a0928f29565e75ea483641322b065a4c9d4f85c5cee57d798a75083258c0decf024dfeb7ed82739f6ee957ad3e4bf22b6fcfda567086960d405b8fbb8dfd9878f600b9c7d5a1b0e0a735639f8145348b829ef23694586a1b5d2259f353040997597e576ef94ba8762286803d3c72a08b44579f964d7056198b894f67141f19cfe1e9ad403daa27c5db321585dc5aec47b550e2c25cf441b0dcc22fd7cd27b5682df91cabeef53d0b4cf04c59f1ab036f228cf54241a386585623dfdbe3b887d9404cc4a7dbe83c320cc3688891c386694326215a526429b600119b6321ff142f0d70b9c04a3679ed3bcdad66ff109a8cc2a6b38da98dad486c22d993414806ca7382e374b73fc95b94059f9589a395d196b07a70822d1d937d3b4f75f78ebcb52b160396913a52809479168217d4cc4f9432d3920cde08b49cefcb9920ae9e082f090c8810f0144d96f52abd79cdaf168c23e55b346e3da387869a2b6c6a60d326528ae35c05abe95d49f6ea7a35020d877ea8dd1cbbcf0646148ea0e1da025e999c25a97e74ea3bd061c0ca849516e6f2c79b34e6b05bc35d11d923188f48b59c1ad8665721cc443a148e2069cf19bbe541b27a1d8ad94ba937cfeb25ec7a26bf819284154f442c58e48a3843d8a80108e6b2ce2eec35c505cc25462acc84086d043571686722d0d35de4557348b0997b3b55c1d08ef31a73be6f834f245a80fd4411bb585aa1e0684ba40fd809399cda1ffe9c3603c4723881755483dfdf9e0d7ced788a3f1f1a7a994954613b9cc6cb13008dcf0f5a7390a18cd678dbff812a65412b13f325701a142bf5437ae7fcda88a5134b11fd80ba519900ea3c0c273e879eb944b3d0a9c3f1834fab646d2cde35c0b843ed25e435081b513e161dae6cfecfd5993cfe61f2425f6de2c10fd1c64bc180d581c4da75d7f090502a11a3ea3fcb01c9b15bb323b8c7214dabe6e8e3fdfa501b3dffbe79724b49d2e9b2168149e60bba35d9e945984ab025c7bfc1ea57ccaa31d8a003d3c3850c4387ecd9f6dd7a8a8f2cf87d6f578cbd82580656cfc5a23ea40c230dc8d7601538458e297642d9491c886cec17f383cd455e57fc482712b6eb2261f00baa59839a4859d4eda11818ce608be17ef780ff1e692b0bf3121eead64472a338c1e21e115bfb7678890b419410697d9281b435770f3909d50fa4a096f211b6449f3f08ff374ab2b9c861101e4148c7447e80d767a110b549cc25582132946f80575821f9fd7a0a76a818096feeb427d525b3431cfbb4a550fe40d58f831eb2e016121b626a27c2ade38f735734d15cc3c19bd14e5593a43d516414b792cca830e228146e3a90c9604508bd978d53da5241c53fd363c6a8954fb8dae0c70af5b0627c03fecc6d2680b6eca8c58320932e8ca27ddd79a12349e3cff2b2e99ac5c7879fbb4d9b249654c2b1165c85e38e1256658381dc15e31e9b50439b07cda2f8334a0781a1762bba17b70dabae3429473722e010cda903a9d4cab130166844bf7e344475b2584caac11b284e1824e6d058ce0d30ac8305a54401f89ebdabd1d11a1b8b75658d2dd3b969e759a0e05bc6bcc2d6b2a882b32d1edbcfb2fd8c128a07ca014e02f092ae167750ec46ddccf3a9b79aecc04b961c51157c1e06ace254dc261cc25163f010a5766909cabf8cc501aae3712b83574c3a58cc0fb176acb67fd42c616a29268f94e3badcb664be8d5e5f4e80409ace8cb1b818d4a1100ac0b3bdfd02fc0a2147fe8ce5f1d2f34daedabf2190d60e0c2784e53f95ded9079b3729ba51cc258365cc386a7bc6d652aa6f4b38a118c26e7152a2efcc83f783919b82ba447c0f33c3bdffaafd16f1c48c9d90006b91f6844dc26e207b5e145f4256b0fc09a393400ce0960cc74d93b16cc05e3d032b99f8e13bffe364e1c6d3147725279e4c3be3d527fa80e2c1f93c81662fd8a9076a67e83647968da17624453aa889f4630e89197365503dd56bafc0c62a8c179ea516d1909369580adb8dec1fe5d6d5350076a4481c2d9b398abead024c73ac8b03d2bd6393738836f4ceb142a34672b67c47a2362fe121e584fa9cd0dacf2db86de016e43d5ef14139e143f852f1fa2c67745c914a159a0614575d10aeb8cf6c03ae019fabf18da4424eb98a2060e3085571d314b8704542ea53693707aea25c15d8436944e660fbce3016f5d0083b0674e55d7de71b351435458288904b9ae16bc3eb54f6e39d8b045601c35a61945477fa54789339f2d1d35204f5465b9d8813b5dab56111eda8eeafe8ac86cf846a5655d521230c61dff600a4e5664aaa1e442d3f22edccdcb63f22422c7d745eedb19ef8758a06a0c111730c646782cdd826b2a187938c09ffa3d16b7f8eb0e7c8bc92a92860e04c731374d623dfbe52e16b91f729bd58185a134baf1ea9df9ac37d8cad9362c354f59640114c375e86e5cd8e3f5be11993cc2ab8904205cd00bb91a7448c83161d39c0d54609be31f12076006950880036718b2260fdffde154a00398589b4f14d480f48fd42bd5cf4a29a293ffbdd20528dce3b77636a718a0039142562e9c1a6087aee7ccef5657b633b336141c066f5203d51ebfb66d53f957f042de0e01177d1bcbaaf67f8818db13694c5dcfd67addebe579cce8dcdc58fcdfd15640aad4f684a2235a7f39bcf49420ff692e6ae2db1fc7213c45af6d26a3a336e55a5b5baf5423dc954d440ae0dfe2d9d7bbc363fedd4400dc4c597e588ed2d7eb5b92b9916561c82771f930fb6ee5429bbdd6303e473bfd3a9e60696fd5c30befa3c473cc675f0c128f6c55f5a9508773717b2113cc91f1f1317dac5a677c93949ef8117e6d76cd5fad5c03a47336a26479680a86aaa202a14a8d0606f51debce9547c9357846b8d70ff3d970f48550525a775928739bc885a4a259989272dccbddbb94eaf05cd10380645b5481e28623d3f6d29da6f7721d0e64e379bc375552eadbfd24aa90ca34ecc63a20d882ca772824fdbbf2019660df10b352cef0cae0674fb8922f514dfaa9423db4ac70af514f5e5649ee86c0bf2309500cf6e5ed31391128fa85f969aeeccb76ccdda3f271ff6fc9446ec236da817236f154999cfb6d848814730a4c4cb2a93a54075be0650a38b133e1e26ac2601a0ede02d1b59795140b6a1fdf6f4cabbed3101a0b8605860cd056f2818d93b248e9058f15a69c9c5b52ad4cd08c1a71718556a902fb47d730cafc73743380d2017527c18c6d776b3b00dffe30dac148ae4912c9c7c88d05804194ab49b3854151c186215cc8b239924090df6d8ebc4a1143e65ad2508aa3f003bf95638320cf31e5476a68aac51fca47d531e3b22e9db24d5975c84853b8e5ebcbd522fce06a3c2b82734ec069e579c909dda8b266e603876f50d42125f630df9b100f7931140687d95181fb226408079559b853d9bbbfd50a0663a8f0c5e3cab94c2d9a136ef580a825e2b9a011c173d26705acb20976ac7d3f6b9776d7e971e158cd91fe5eccec17a7c4f6092f28c035c498e25561e3c0c5b10b2abecb0fbe3e19a577fa053c782006d44a73f417539ef7083f1353101911b799d38b43844cff50a74816afdeb74c44966e42fa7ba8c9fa1944f1ddd937ea3050f445a65b1d2e89e46751cebeb69659d95f085bef5e7285464b7035772d601c9941e6b2cee532d62816cf1b81be1e9d0d5fff4ee234eb997df2cd25c2a21b1f98efff9e6f81229fe44d07a58ddae4d407ad8e744485f77b6bde374870ad2f70006e360df80327195b61a43320b32fdcf9a5e21651a2f19f24b3714684099a5222dc3531a592925df7cf8cc01eb492add1b31303f81881e186fd5f907b35a90afb95063ba7eff6c3ed8e14823666583138cc55133c4337befc24f99f7b240697ed83da1e34aff69ef4d3d8c53e298455f3dcbc00e7bb71f4032fe955fa0bdf4cedb5b066f4536c416423e721a979f7797b229bcb0894b7aacb8878e2dadb6985624700e688c27ef27bb8ae074fe27bf40b21d9c24b1356259a246b2edce5453f45034b2d54d686dc652acdf610073084baabd2b2f58b5f60753c5c249b5b73671758568a007e6f6b01ae4433930bfe94acb7212c6c33a437735747d9379941af8987f73e7e1f1bf2314977952fef2df4341c147a01a959a61fddabf31b6efe08ca8cf9274074816cd93e20c0a63f0263b3d87fc7b025f73c473328501e1dba4914cb40c5bd7a9121c314651a16886bd642493d1bf70edc8d41ba198534872c8a998a45b861a297994cd027f97a96bbbec61a137ac11f9d772dea7b27ba3933594846258d2b93e0469a912abb27c61ce3f60c97220be0372079aeb9df539a053f9ed57da4175b61b4e99644502a0e9b75a78b0c5832d2399131f7e20ced2dc3bb2bd5a4d1417df7c1cda70a9147035c18d50cdea3f141e0a7aca4abdd552aaa67794248e7cd58a704577dce3911c0fedc647fae3c23824ac0f1cafd29f52078bd873ffd1cb00d43440bd055c0f2064b043626266e015dbed5ca5eae3e8d4c3dd8621577be00d3f9688de0647d47931e854d98024bc496572c1632e7ffb1abf06ea2d2c54dbbe64640fec0133fbf26a084d02a6f286db70e7336e8eae8ab7821f90ccb6e945d338e678c0e66becacc98fc0b98e7447426c8fdb68f0898b727b6ba2133467c414c5220626233d54ca0f05ef02eedaa9009eb739b10fe3d9d3ea63be116f053d892991d607b16e129830d6326e40fc6849db613ec12296c6bcf451c4913692cfc683393c8587b83ca2697a0db40e4d8c5987efb4b7e7636554bfe35cb0b1b7ad66e3faf781c60d7463f2a47133a5f2a7aad6c8cdfe66d3f15afe802ab21c17cd882151b3e55284a9bcc41a98db684eb5d6a5ae51afa84093ea9817ab74b8d61cd5fc53363845d7e5645d56ce0e94c7b9ee7129dff8f6769fb6469d1b05b9ba2a31872d34d1b0b52d5ed0e02cf91aed32dfd4f772aa822e4b18e630621d1c3915759bd9dd898ee6c9d21b0fd520889746770a22931502c763522fe4f063e8cbf5db58cae95e1d9b215e421a2b4b394d279160eabd1008fafbfe96f5140ddadde9c8409d62b0672e32a50ffef16408cac9271c815f8d21c5abb3b30c2bea96efe9d3a69ddde09dd3ed2a8a82f4a1c9c5b42f2141a3a52d401392bdeb8a9c85b34d18c733a4e44a3212f1d59a9db354fb17faaa4a2d21115c02d863afa3cf7cebaccb2c965a8fc57b0b8a1aac83d1001322a6e46716cb46556b4005f00e651ca793e607761417a89831cc2d1ce9d985dd1e3a526d7a51dd9a8062d444eb63bfc51480e12e238ad2521bcfe9ba4cc4b2e3dbe61646a1a546746ca05158642b6ab42da12968a68186bd017948d4a0346ec41bfba1a7f79b602534fa16938f83f3a527c35691ef550f9af2c83978cd381fa0c4dd2665ffeb7b3639d2157a7a9df4cabeb2e543e59cf2542bc340f933ecfacfd47352f64d95e67559d5942eba4335e8a42c84f65016ab483353f269848d04ce49478a68e5c796ad7d657d14b2be94e2e2623b10b136b135ed6dfe01208d4c4cd8154a4e82b409571b52956cc29d69468428613375068fa0b5ae1f98cd2aeb8fa5e0df2756e83d81855367f7994165f0b0c1fb867327f453f1579338875a19f38c16b24267f5fd03ceb8ba05f13ca7a9b8639a59cb3662c8028eea36e6c1bf732e8c659e0cd1ede343b971bbde8ec15301cdfbdf5a9d4a40cb12e75862f68854329877bb46af2b4b8dba963bc2ec92916fa6064b807c8f32ed53cdd7194ffa6f8afee84908224916c8f4089039309eca4b9048ea2e72df49dcb1b66d3120c46ca5b89a19db910415f956dd55a81ec399d986295171e0c88c09cd3308d015b7667148d2dde90cf5607dce1ae86f0f79473f9810151ec7d3a7a60b0e814b207152077f36bcad73e145063453f99e703e7abf8806bbbe9096169ad5b1ae5dfc2392b4900bdb5969d670db17de6acb63a61c9c818615549ff9ea42770b66b252af6b4866947c5ccd360296bd3c56cabaf585d1451bbf07fe11717f20a5d457c152084de1e055adb5add8b592e5f63a6b69bca987e046956c63ddfc9c26ad595dc498d720ba99d28c65a8f0070b25d796c01e104a7e9107be94de058c71308a382835e2fcee0bc80aa63fbaabe59df78ca24e99010a6609c8f785a806471a89f02f6430f8f31ee28780627f2e5d3788074207764dc6fd056e49283d9bf8e4432773534da33e084577b38bec3a3b4089d304a993bee928eb4e865b2e275aefc8e882838460262e5953183e78f44934a9fb410a983f8bf799dcad53c180ddb96b74b7bab8ea17dda8df2397f4f435cbd002018209658baa8bc63dd25a38c9c1ae7715f8bae989d0bae2c0b6ed410393acd06e95d87a1e2b176d27a7adb47e25437242d67383df6d021edf3aea79367e9cb742f55bdb746f70138b9c893b26a3f369e01fb2de10f5a3010bfe89eff0976e434d896a2a15ddb62ce52b04f616bd4fa7f5f8432412706c8d9e50418212d8c497707781fc669a8561d47ff9a3efccfceb7a3ccffe1673bdf7bf663f0cbdc9da9551bf736ad4d5bea1fb0042af9a3767a97472c56d68b323c9a01f3449ae98b421fedbe8dcf1b5b29a809a4df7cab8d703a1069d1c126795a82f6b1d7ec883a1378db44004899f91a0277952286782c25bb49624ddcbc3aa488e3f4ff9d6035847a10048a0c3a9c5ae45104ed566fb9c28096dd0a2f1247a203ba9f6b02f59206539447cdeb124bf958749f82c2b574fe059a70c88b67c038451fe27cec315e921a002954bba01700e9f30752fce690deed270615bbcfd8bdebcd0c6fbac2d017a772bfda98dcf96baf0b07059183af1c31b5fe49f1b3469e15e672149ae861bb3fbddead6c4f845aeb39799d742afcb31f2e61b6123da6235efa62d13a8645c7a876c43ce6db6a4da3acb73e717a871d608f9b330f5859e4b9b015ccee8c8899850315445bfc2b7a7af2d93819662184f1fe1e4ad0ce7b9c0c7b9262c709b2b45566520605448f00e210567e0f068aafc782434adf4a9f492e11d43303fc021e7e1701f1e024a6cc8e8d96ffa3fe76df36d7da70dd17132d44434092c758386209fd151ca5e3c1ce39ada402933df9dcd2bcb1b193993936f51fb5a1573132ea46b57f8b2568dc2b01a5e23ac78a1cb17f5309dbd28319544edcbed2528c1d87a136e1dacbedaf11a75cbc787fe38bf406a5a031883acc852ab4aaf35e957096ac5faf59b9c2e543535328bc22002012ace07b585e32253732eafc2d11449d34f695e465bf5994c5246506c70bfb2d8e180b15d42c394f6dba3b7bb5816b77d4fb483a6589a8449e8aa4811d5a0df2687abdd0f6aa2a9b7841d6fbda6da7b5a449917f13145eb19868e14cf755cd7e3a4802a107d82ef6e5a37c263c900d4f4afcec6b2c93dc69d8078b1b7999482210dcf345c3ed1771a4102f3e60bd5a2ab0b65c78d2fc73379358b577df47e4e2bcc17a0b80f6acfb439113b9019c8e99ff383d6fedbec1996b4a44688d0bcb114321cb72bbc2279d28e94a8688dc71c6cd82228155925c75e5f6f27865dad799fcf49ae0ba60f0e8ffddeb6ca70cc25fbe80b36f556da301d70394e506602a437c9f9eea2349832160d501db9d832eb1e72eb1feb58c4431ffb892ad601b8d141aae9b5e4fd4655560002676886ca2d82289dd8aa37c935e174340fcde0bbbc4b50ba4bdb678a8f0aa6f8f960a6efb1657713d3c8e16b6a8fa773ecb6d07979b69f8d31acc4be319dbbaeeb468af271d9dd585b946088f0aa1567f9fe495bf6345dd88bb857d4eef2284e1a27a417c99e35f4075ccc4e097cc00e4762d0a12d5ca14050c75a4b7ee3b879e244ffacb3c8b04c86c12da1cb954152cd43b60ca0f6f8a05fb631b6dc42128490349b741e3e1a4a503d562242eb4a18b67b769a4cfc4d11d66febde75302a08c967cf45074d598b0593089d487df98dfd2ac859bffc4a568243875ad30287063d5ff444ab890e2f223dabc51fa4dc3c97b12aa0ebfaacfc21baabb90c59e8bc128f8baeb2834b3d7a1f6bef10007f129149d9441c5c167f95ec77418b8936cf4a738eb7ede030923f381ea6e0a2e348a4305ec1330e19ef17de8df82a9ed2b5d153d6b4c2223d14d5c2afdcdd000f4956ca6f62a946e359966d4f9a9ec10906a8f6b59f9ae079b4100a0df8ce6318c931e2a871f09832bdc3d97476f3835d38c5dd51faa6331fcd9a003e24ba2f4d96543e8962907302fdebc3e350ffe6e52b0666c29ce983b99a2b77e26d24fd21dab72c8baadcfab33ba9e96be10b373f1ed7e829109f091359ef717fbd4c0d635a07835ca7477c0527e042dae8e6d18b189efae77062a30af3389609ba846813ac66f9c20155035637834ba1c9826bb51fb0ec29097e555a9a1b2a07c065533881dfcccf182557dcb325aa1253948eb049f8d2af03ce849221b74d57c43f8f53cbf46f0997e3073adce1386efdd4d07af9441e2c1a3a055552398e078f3d6ea722d8a6f7f62ccf916a6e375580def8521941cba527c4d8ffd195e37c47bcfc9553b75a401741d955153d781ec8db4d687f6e1be2c93ce4c0ee69ed3d5552a4117e5e68fbb4ab6b11a0d10275103f4c88ee9e4afd6b6b34241a8fbaea8a5df68511c8c190bd76b787bfbbca4e4147cd0a378bf974f6cecf3bf400416051b8fc13380e489cbd075d445b5bf538314e72c704dae1a968ed131d7266fa0538bda9cb69df4e51813bbf825bdd6745f60147939eb087b105ec9d016f96b1baec4787d815775cb6f1e5c778031ac50f6608e99f4c0b82caa8201c98499c2a143815b4950698dff11f6b0b4ef9cf571c51f40e78df54214999656825e43ae5f52a8ef5a28730353f1f697a38022d7bfeae0f47efa227c65add548fda192667799209a72f21bdc2c896de495c91de86e9ed0c283ba4320f27265cfd818d124f2687d216a0141aab591a6eba1460321e5a853ed5198bf30ddae2e41690701c0d0d7af567923651085a79df951dc386732af0cfa2ad932c8e0338b6d902b0e8d8f5c646ab041d7780e69e5e68950b9ce251e0e2a21cbfc1b3dbd99a58374b970fbf66baa6c6482336dec4e07ac2bcda8bb8e637190d5900bd511a101f8d290ea5d2636ecf0545c5802b6d35e108067008e5e1b5ee973654761739720018bdd52834462781e6a1417bb99e35a689b8b79b1cf1e150417c94ec18186d5e3e8eb4427855fda6efd5bb4aa4a68e70b01dd1858aa8284be2a45e23da797820c643da0a5c0e0d19c6123063f23e8a56ccc92bc431416800955832e6f8365a905238add7c8f911479caeb26f9ce28e07dab1767ea09cf5d09280e1018ff95ce94e0bff7540fd9626b55a9a6cd94543f33dcb5dfdb4f6795ccdae566c7c97df7b709f22d926e52cc9cc06488b815d41a3fc0dc7b2e56faeea98962c051a0d232185b52eccfa4f6c0d531a2cf538632abcef306115d52701be70d8ebab0c972c50d5bb980d01273754bdf3b48030486b14d1e7c12e30020541c6cd529ea9c6b0e5ad5646d3fbd4ae471127c37c3f5476bcc5078c2eeb91c700271b1db1e169e40bcf656983b304d9c74bae240ccdb36ac6432b4fcb1c2bba64e0acf71aca43e6609206bc37d4278d37d96e1831fdfbf9bd4dd4b560a3b106ee38aac4f72d94937d0eae3ad146aeb63d8d2f0d85b57624aed06be4c8140da918a0891d1c91e6c793ffb27fbcd0dcdfc676375b7ae86b43cfc855d0b8c8398bc40cdb19997b90200ab0c3157fd3ee80d0cb2331284aa851ce865959e3ad983fbfa8ec692c7fdcb430ad99bbe29dff4372c223c03be0651d860fa0d43622add8c7a406a1f657cef2fe7a677bc07e0d48232095636328de1e6f166d94c39a63e313c42f08442412d88554dd6186a432a0a81338a6b154e612458bcb6b1103b3682716a88cda6553b0628e84d64a6fa3bc1f54984e50cdba2f9a68ec4515e7e8ae7bb85fa07b3d0d159059a0f025de0afc2d96fe645bc2e33481e09ffe1f09b1a6aede3b0d2324100a016775a00abfb810d9189aa65b5f2e2f3a130acd25f07a21b48ba0c562e98d843dcf4e3e35904d99f612d96a6b9bb02d979ef8ceec02243066ff207f4d757792712519d968d6db652dbb2a53f0e88469066aa26f42266be60a4d00446de13c0b4234b452ea93a9e34ff981bdbec85f156d091a5d6a4a3b81fcc11e528960c5cc2bf14929c7772b6ed9172a35aaef65adb2994546c130ffa2632521c5f4aff49cc8d112e6e70969f4fc867cf4cf7e490613fb5a1cf87cd7259b1c9ac88fea1537284dde20a955a4291c2ef00f46ed3afe5c418007fe26d6fd2ec385b7fe1a1809477cbaa42a48867b49ab3937b0d1c84010c8e85c64f9ecf444e793017a84cfd186e2cc8f20a6ec9db104199214cf804e457a60b55db861444f6218387121b2d9e37c78cfd168aa84a8484858b0097d0564e25d70848d8c23700d21861ddecf1bd67e57311b51aa7e0363c9fda25678dd0b2d18e9953c46c0bb855350b3cdb3de5a87b7d5ba0c84b4d4818483a0e96fe50a3846726698f3f51cac02748472509ffef6277963cc878283b6a7827a747b8d88b9ba6f466a8d5de59c228e685b4a336e175631fd82bfc205bc4aa7d990de8e576ca367bb921212469fabadef145940a160591e8bfe71b45f7239524390adfe6200a5558c3c0e3e68da31f24392764552594570153ce126f723f213173e663179894f5de724ce9e249199adc9831ff4cca52aacaffafd05d5668f540274d6abc33aed7aa59307e7b2d79871ca14cf410c596d615cd46479c0a1c068b608446ce78faaad522ef046d6582f0d0a4db59f32595758e5d6485163fad427e68318b0048c2e78b159c4e0c035b71517d0a8e6fd84a4a37c3eb2d6140a40b7324d2f5e15662b94285493fb4250571cff0fe2cc0b4d47fb9490883c311b44382318bac4a26d1516f0dd72035f52541322bbeadee405cefb3138c6a05e283907d4343cdb941c61df00d92b4d1362551c504457757e593380470efa8f22b7908090a3edb24d9f155d1b6e4f3b9c2f65bedaf7d5c101ecb5661b8f1f0fbc9849b54b1f9c738950a8af0d6d874daf26e1e0a3f77651cc0413919f044c72b56b9a0486af6daece7e1d3d1048de2bb1449fe77995d4a59c5d6634774dddf05fe06880dc9d2dc1d19fd1d27ebc15a5a8f591b1f2f76b714bd26dc5b7f018322f1adcc7c0bd5ab7d2bc0b38ef33bc609500f70400ca114cc89c8b8bada8bc4c911939033af887a06b4b6600b5e2f83b35caff016e184506b506e33625f206c88e8b5a14010d47c725a32844a85e30a126a53abc37a774a7eeacf711a8a501307c738001165858667183175d0ca16e477fbe4d91b9ab32acddf83380ff27fe6abaca67e4145d39995b5a63e5304f4b420c9fe4500b6778b40ce79a12a53e68dcfd6eef01837cf37bfb656fe84c503edf5efe42e2c974221c707067996182cefb1a20dc0ee09dbeb537f7dea951b519729dee62afc2471f9f9f3eda79daeacaf9a90645e71552dd0125d5948c537200932d1ffac49ab1a960cd14ad6e3c1f8badba6fade4760e44270d979dd1138f5608571093682665673fa8c496fdc05e6cb038e62405130558213ae88c63fdb83f17cc604b36d1256a5f0e43ac071f353084d6af6f9cddc4495dcceb6773bc3a798a105a378817121af807f1fd7b3a833305e71fed30c5fb907c749505a4a5e4c910bb9b7b896d42e1be8fc1bed9afeee3337c5425421570f4f242686f46684fb18e360f418ee1260fbba79cc8670c3eca31385aa5556e61b3781c748ae3661c0588fbf72cc1b301eec300cc413996cca918e4fb5ac39fc9b4764fa9ca5d1a9280a24721703fdc323bcc5f981f93346c2fc3c71a7771fbb68d51cdbce2d47f3595cd9332e9f5ae3130ee92b9b2f32ec1dd43ae4c800b31fbce2d201380a99a3aae3d13124b6126e01fa90a256d4731d211fd19d250b4a868f5e42684467348d1e3648822348cd895fa2fbe7769abfdbde33e905cdafe04368bf31d74596805cde9a54a6fb22a993d1d55f2e4c030de9d886b708c1630023f60afbf85b8a0fd26e081e2746fd497977cc7197fa54e67c7136b7ab312e9c633a3ec8744930a7184165173fac1a44a89e9f11a504929c0c01d48436792ed789cbe14601312876017776edf81a87d4788a1b8861bcf210ab566f185b8b70b7b80e98c70709966dbb7b26a4e32e51b470814cc43ff9af71c994ea2e341626870b157b472a2cc5899035457347a1129794bc02c0238d7d7f13eba58176197ed1a083dfc17ff0b5ea1365bf9e4e5530dfd4e4dd3e916bcfadbf37f6e6488756b2f8f2730df562c78e672ae7d4c1edcd8e19580a95a1b760b418aeacf3ebd4389daf1662610397b76447c944c099cf9bc636bd0841212795509d0d9ba7b6d0660679c1a31fd037b46e543eb44ecbfc125088c4f4e9ae33770d6aa61726a703e195ea9b7bcacff31c76273bfc5c29e69671b7c4e9141b05f60ae667ab7fb0a42d3f1d9bf87f52a1ffb91e69173c46b659d47d20e504c2e4e271e9d077abcebe68e516d5b44acb977356a0a744ff8115c8dbf87c90601eddd2f8c43066f520c7775d16ea9fd926b6cd3be6dbe796fde4ead1941c07e7bad3866da0655f639978634e3c75e57b7c2cf94286061e694595d6b9bc74527311a63acf5cac048ab800f8c49abf2a82c316d4a7deeb76825ba580b0f9cd891d3dc53875f6ee9db0da80c302037aa4c118cb803bb51547d231ffe51b4a605b8dea5e47cf3a4950b910518e6c4769c418101744286dd41e749ce5282c82a3f475b9e0893441f7e60f551c56e323accf81b53f158d8dcda328e02cd1793a561dd501dbe2fefab42842c3619adb6bf2784af1d3db1d6b723179dcefe6abba4b0ad5fef26abccd22b3792edc0a4c0c51f9142845917e5adfbd31d1fc3a5391afc7ac2dc69a89888b655a140b944c81f650a44eed9ee33d86867a35e460112db42a3904d75a617815d5f9b62d5d6e0731971e47a8b2f7cbc64699798495729a11af24f93275a3a4c0a89366f074622c2e4a9b72d36120bde413eba6e7812cbd1c3f291066285a54d05f6577205e1753c1015edff11c15178da36eb306a19409f5a1473807a430aa4fe2f66ab65663c4adc2e57bb85082b3c4e040cd8dff768fecb684edd44cab709db6cd9be8972a006ef348936afee147d6eef562b2dc99dc825bd236a8cc49fa54fbc36fa1e808e3363407a607463381085e3cd02e47bafe31462d23da2c360db45624d0a3346c1d8c022036ae9884ca9428f9125145f43653cb6cc0a5500752b2997921bd660dad6c8a08172d3472a5a7f9e5ac39b7736594ef796067431d107ceda6c83099a34878aac00128c5487a7029a14f831faa139ba07dc00babfe83b2d0cf369afab10ff72a603fd515fbd3e07ba4e66281f668eca8e7f5149d777add65270a193de5316773112aa030b889e1ddaaafe7b52fed0c0f33ad13a07dc01b8f5e686a7c09c51a0720cebb6562824d60a6ec702efffda72ba76cb72b96599f23bdd5e6236cff6b816ba617762b11e2f7161ef961cd104111594077ed2facc48f6f74ac01557c17e13343a0b8f89b1d25799d1a8e37e3dbc926f6c31a5379276010092bf81a9e3755161070c09fde474611e9fe70a9b3b88a95a44513a830638fc36903e9b02f709576cc84cd5af104c8346dbef98564e5e626279a3b62a29af53ebfa5\n      \n      \n        \n          \n          \n            联系站长以查看密码\n          \n        \n        \n      \n    \n    ","categories":["笔记"]},{"title":"关于WSL Docker清理","url":"/Arknight-notes/posts/33014.html","content":"Windows下释放Docker所占用的WSL磁盘空间使用下面的命令清理镜像：\ndocker system prune\n在Linux下面可以释放磁盘空间，但是在Windows下却并不能够真正的释放硬盘。\n搜寻了一下，发现有一个文件超级大：\nC:\\Users\\{用户名}\\AppData\\Local\\Docker\\wsl\\data\\ext4.vhdx\n这是WSL的虚拟机文件。这个文件看起来是只增长，不回收硬盘空间的，所以，需要手动回收硬盘空间。\n1. 停止wsl2wsl --shutdown\n2. 运行diskpart释放空间# 代码来自 https://github.com/microsoft/WSL/issues/4699#issuecomment-627133168diskpartselect vdisk file=\"C:\\Users\\&lt;你的用户名&gt;\\AppData\\Local\\Docker\\wsl\\data\\ext4.vhdx\"attach vdisk readonlycompact vdiskdetach vdiskexit\n参考资料\nWSL2 Docker释放磁盘空间\nwsl2 下清理 docker 占用空间\nWSL 2 should automatically release disk space back to the host OS168)\n\n","categories":["笔记"]},{"title":"2024一些笔记（常微分）","url":"/Arknight-notes/posts/40883.html","content":"2024的一些笔记（常微分）（共20张）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nebp)\n","categories":["笔记"],"tags":["常微分"]},{"title":"制作自己的校园网路由器","url":"/Arknight-notes/posts/25450.html","content":"\n怎么制作自己的校园网路由器（广州大学版）\n2024年更\n庆已使用web端进行校园网认证，路由器已经不再需要使用插件登录模拟登录\n但是同时一个账户只能有一台设备通过web登录，包括无感登录的设备，即最多只有两台设备可以直接接入校园网\n而使用锐捷认证的不记在内，也就是说可以同时有3台设备直接接入校园网，如果带多台设备上课的话体验有比较大的提升\n对于多人使用的情况，使用插件登录也不会占用某人的校园网账号，导致某人无法使用校园网wifi，有利于宿舍和谐\n我现在是使用方式是在宿舍的电脑用web登录，在教学区通过手机热点让其他设备接入，勉强能用（校园网本来就烂，经过手机转发雪上加霜，导致远程桌面延时明显提升）\n最后，这项技术对于普通的同学意义已经不是很大了，但也算是10年代技术大佬为后人留下的丰碑吧\n\n庆用的是锐捷的系统，你能买到的锐捷校园网路由器都大同小异，直接购买即可\n此文主要是写给愿意折腾的同学，将我本人组all in one服务器踩到的一些坑分享给大家，如果你想用树莓派软路由、x86虚拟机软路由抑或是自行刷机，甚至是想做路由器赚钱，都可以参考此文\n不多bb，我们所要做的就是在路由器上安装一个插件，用这个插件客户端进行认证，以此来接入校园网\n\nhyrathb/mentohust: mentohust加入v4支持 (github.com)\n和其算法开发的minieap\nupdateing/minieap: 可扩展的 802.1x 客户端，带有锐捷 v3 (v4) 算法插件支持 (github.com)\nminieap庆内亲测可用，以下以minieap为例\n一、装系统主流的开源路由器系统为openwrt，各种插件也是基于此开发的，先给你的机子安装上openwrt，方法各异自行百度，也可以直接买刷好op的\n二、搞到插件openwrt是基于linux的，不同的处理器都可以安装openwrt，但编译好的固件只能用于一种架构的处理器，如果网上找不到，只能自行编译插件（编译环境的处理器架构和最终成品的处理器架构没关系）\n我们需要编译minieap-gzhu、luci-proto-minieap，前者为认证插件本体，后者为其界面，openwrt的软件包是ipk文件\n\n个人编译的x86架构插件，x86软路由或者x86虚拟机可直接用\n链接：https://pan.baidu.com/s/16GR_BS3LvcJf1Y4KcQuuDA提取码：6tmt\n本文参考 动手编译适合自己路由器的 ipk | 雪山深处 (talaxy.site) 另一位学长的教程\n\n0. 准备好魔法环境dddd\n1. 安装linux环境推荐使用wsl或者其他虚拟机（虚拟机网络请使用nat模式）方法自行百度\n1.5 推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）安装ssh服务\nsudo apt-get install openssh-server\n宿主机推荐使用winscp客户端连接虚拟机ssh\n2. 安装编译环境依赖终端钟敲入以下代码\nsudo apt-get updatesudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzipgawk subversion mercurialsudo apt-get install ccache\n3. 下载openwrt sdk（openwrt编译工具）并解压推荐解压目录到~目录，否则有报错的可能，注意，不可使用root账户编译\ncd ~wget https://downloads.openwrt.org/releases/21.02.0/targets/x86/64/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar.xzxz -dk openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar.xztar xvf openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar\n该命令目的在于把文件sdk文件解压到~/目录，如果上述命令执行失败，可以手动将压缩包解压后上传linux\n4. 开始编译a. 编译minieap-gzhucd ~/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64\n\n进入sdk目录下\ngit clone https://github.com/ysc3839/openwrt-minieap.git -b gzhu package/minieap\n\n将插件源码克隆到本地\nmake menuconfig\n\n进入编译菜单，依次选择 “Network” “minieap” “save” “OK” 然后退出到命令行\nmake package/minieap/compile V=s\n\n开始编译\nipk 文件就在 bin/packages/(处理器架构)/base/\nb. 编译luci-proto-minieapcd ~/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64\n进入sdk目录下\n./scripts/feeds update luci./scripts/feeds install-a\n安装 luci feed\ngit clone https://github.com/ysc3839/luci-proto-minieap.git package/luci-proto-minieap\n将插件源码克隆到本地\nmake menuconfig\n进入编译菜单，依次选择依次选择 “LuCI” “Protocols” “luci-proto-minieap” “save” “OK” 然后退出\nmake package/luci-proto-minieap/compile V=s\n开始编译\nipk 文件就在 bin/packages/(处理器架构)/base/\n三、 安装插件将刚刚得到的ipk包传入openwrt系统中，如果你的openwrt安装了文件传输插件，那可以直接用，如果没有，也可以用ssh传上去，以下演示假设传到了根目录上\n\n菜单栏选择“系统”&gt;&gt; “软件包”（外观不同，但是选项应该是一样的）\n\n直接点击安装即可，如果没有文件管理插件或者是你的文件管理插件没有这个功能\n\n\n点击确认即可安装\n四、 使用插件\n点击“网络”&gt;&gt; “接口”\n\n选择“新接口”\n\n协议选择“MiniEAP client”，名字随便，接口选择你的wan口，每个接口对应一个物理接口或者虚拟接口，需要根据自己的实际情况选择，该接口要连接到宿舍校园网网口\n\n账户密码就是你校园网的，Packet plugins选我这个\n\n然后将DHCP type改成我这个\n不出意外的话就可以愉快使用了\n转自：怎么制作自己的校园网路由器（广州大学版） - carry blogavb6x)\n","categories":["笔记"],"tags":["校园网"]},{"title":"爬虫实战-爬取广州大学课程表","url":"/Arknight-notes/posts/33971.html","content":"大二上在学python，所以想要用python实现一下课表爬取。\n（虽然python开课爬虫不怎么讲的都\n本文仅供学习使用。 \n广州大学课程信息查询脚本1. 概述本脚本用于自动化登录广州大学教务系统，获取当前学期课程信息，主要功能包括：\n\n通过浏览器自动化（Selenium）模拟用户登录，绕过滑块验证。\n使用获取的Cookie通过requests库发送API请求，获取课程数据。\n结构化处理课程信息，并导出为JSON和CSV格式文件。\n\n\n2. 环境依赖2.1 运行环境\nPython 3.7+\n\n依赖库\npip install selenium requests pandas\n\n\n2.2 配置\n手动输入学号密码（脚本运行时会提示），查询时段的配置请求参数\n后期待完善（\n\n\n3. 功能模块3.1 登录模块功能描述\n通过Selenium启动浏览器，访问教务系统登录页面。\n自动填充学号、密码，并绕过滑块验证。\n判断登录状态，成功后保存Cookie供后续请求使用。\n\n输入参数\n学号（login_username）\n密码（login_password）\n\n关键逻辑\n浏览器配置：禁用自动化检测标志（excludeSwitches: ['enable-automation']），防止被识别为爬虫。\n滑块验证绕过：通过执行JavaScript代码navigator.webdriver = false。\n登录状态检查：通过页面元素或关键词（如登录成功）判断是否登录成功。\n\n\n3.2 课程数据获取模块功能描述\n使用requests库发送POST请求，携带登录后的Cookie和参数，获取课程数据。\n\n数据接口：http://jwxt.gzhu.edu.cn/jwglxt/kbcx/xskbcx_cxXsgrkb.html（F12大法\n\n\n\n\n请求参数data = {    \"xnm\": \"2024\",     # 学年（2024表示2023-2024学年）    \"kzlx\": \"ck\",      # 查询类型（ck=查看）    \"xsdm\": \"\",        # 学生代码（留空）    \"xqm\": \"3\"         # 学期码（3表示秋季学期）}\n请求头（Headers）headers = {    \"User-Agent\": \"Mozilla/5.0 ...\",  # 模拟浏览器请求    \"Referer\": \"http://jwxt.gzhu.edu.cn/...\",  # 来源页面    \"X-Requested-With\": \"XMLHttpRequest\"       # 标识AJAX请求}\n\n3.3 数据处理与导出模块功能描述\nJSON数据处理\n\n从原始响应中提取关键字段（如课程名称kcmc、教室cdmc、节次jc）。\n映射星期代码（xqjmcMap）为中文（如1 → 周一）。\n保存结构化的JSON文件（extracted_courses.json）。\n\n\nCSV导出\n\n使用pandas将JSON数据转换为表格形式。\n\n添加中文表头（如“课程名称”、“教室”）。\n\n导出为CSV文件（courses.csv），兼容Excel打开。\n\n\n\n\n\n字段映射表\n\n\n\n原始字段\n中文表头\n说明\n\n\n\n\nkcmc\n课程名称\n课程全称\n\n\ncdmc\n教室\n上课地点\n\n\njc\n节数\n课程节次（如1-2节）\n\n\nxqjmc\n日期\n星期几（周一至日）\n\n\nkcxszc\n课时安排\n周次范围（如1-16周）\n\n\n\n\n\n4. 代码详解4.1 登录流程# 防止打开浏览器后闪退options = webdriver.ChromeOptions()options.add_experimental_option('detach', True)# options.add_argument('--headless')  # 无头模式# 开发者模式，防止被各大网站识别出来使用了Seleniumoptions.add_experimental_option('excludeSwitches', ['enable-automation'])# 启动浏览器browser = webdriver.Chrome(options=options)browser.get(login_url)# 绕过滑块验证browser.execute_script('Object.defineProperties(navigator,{webdriver:{get:()=&gt;false}})')# 查找用户名和密码输入框所在元素username_input = browser.find_element(By.ID, 'un')username_input.click()username_input.send_keys(login_username)\n# 等待响应time.sleep(2)# 输入信息模拟登录password_input = browser.find_element(By.XPATH, \"//input[@name='pd']\")password_input.click()password_input.send_keys(login_password)login_button = browser.find_element(By.ID, 'index_login_btn')login_button.click()time.sleep(5)# 检查登录是否成功if '登录成功' in browser.page_source or 'index_login_btn' not in browser.page_source:    print(\"登录成功\")else:    print(\"登录失败\")cookies = browser.get_cookies()print(\"Cookies:\", cookies)cookie_dict = {cookie['name']: cookie['value'] for cookie in cookies}# 关闭浏览器browser.quit()\n4.2 数据请求# 请求头headers = {    \"Accept\": \"*/*\",    \"Accept-Encoding\": \"gzip, deflate\",    \"Accept-Language\": \"zh-CN,zh;q=0.9\",    \"Connection\": \"keep-alive\",    \"Content-Length\": \"28\",    \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\",    \"Host\": \"jwxt.gzhu.edu.cn\",    \"Origin\": \"http://jwxt.gzhu.edu.cn\",    \"Referer\": \"http://jwxt.gzhu.edu.cn/jwglxt/kbcx/xskbcx_cxXskbcxIndex.html?gnmkdm=███████&amp;layout=default\",    \"User-Agent\": \"Mozilla/███████ (Windows NT ███████; Win64; x64) AppleWebKit/███████ (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36\",    \"X-Requested-With\": \"XMLHttpRequest\"}# 表单数据(学年和学期)data = {    \"xnm\": \"2024\",    \"kzlx\": \"ck\",    \"xsdm\": \"\",    \"xqm\": \"3\"}session = requests.Session()for name, value in cookie_dict.items():    session.cookies.set(name, value)# POST请求response = session.post(target_url, headers=headers, data=data)# 检查请求是否成功if response.status_code == 200:    try:        response_data = response.json()        formatted_data = json.dumps(response_data, indent=4, ensure_ascii=False)        with open('course_schedule.json', 'w', encoding='utf-8') as file:            file.write(formatted_data)            print(\"返回的数据已经保存至course_schedule.json\")    except ValueError:        print(\"无法解析JSON数据\")else:    print(f\"请求失败，状态码: {response.status_code}\")\n4.3 JSON数据处理# 提取字段并重构数据courses = []for course in data['kbList']:    course_info = {        \"课程名称\": course.get('kcmc', ''),        \"教室\": course.get('cdmc', ''),        # ... 其他字段映射    }    courses.append(course_info)\n4.4 CSV导出逻辑# 使用pandas转换并导出df = pd.DataFrame(courses)df.to_csv('courses.csv', index=False, encoding='utf-8-sig')  # 兼容Excel中文编码\n \n滑块验证更新：若教务系统更新滑块验证逻辑，需调整JavaScript绕过代码。\n\n接口稳定性：课程查询接口（xskbcx_cxXsgrkb.html）若变更URL，需同步更新。\n\n\n\n6. 输出示例6.1 JSON文件（extracted_courses.json）和谐了部分隐私信息（\n{            \"bklxdjmc\": \"无\",            \"cd_id\": \"1015170\",            \"cdlbmc\": \"多媒体\",            \"cdmc\": \"███████517\",            \"cxbj\": \"0\",            \"cxbjmc\": \"无\",            \"date\": \"二○二四年十一月十五日\",            \"dateDigit\": \"2024年11月15日\",            \"dateDigitSeparator\": \"2024-11-15\",            \"day\": \"15\",            \"jc\": \"3-4节\",            \"jcor\": \"3-4\",            \"jcs\": \"3-4\",            \"jgh_id\": \"104119\",            \"jgpxzd\": \"1\",            \"jxb_id\": \"1850E3A697E512CAE06███████ACA210\",            \"jxbmc\": \"(2024-2025-1)-216███████-01\",            \"jxbsftkbj\": \"0\",            \"jxbzc\": \"███████\",            \"kcbj\": \"主修\",            \"kch\": \"███████\",            \"kch_id\": \"███████\",            \"kclb\": \"专业课程平台\",            \"kcmc\": \"常微分方程1\",            \"kcxszc\": \"理论:48\",            \"kcxz\": \"专选\",            \"kczxs\": \"48\",            \"khfsmc\": \"考试\",            \"kkzt\": \"1\",            \"lh\": \"███████楼\",            \"listnav\": \"false\",            \"localeKey\": \"zh_CN\",            \"month\": \"11\",            \"oldjc\": \"12\",            \"oldzc\": \"65280\",            \"pageTotal\": 0,            \"pageable\": true,            \"pkbj\": \"1\",            \"px\": \"1\",            \"qqqh\": \"无\",            \"queryModel\": {                \"currentPage\": 1,                \"currentResult\": 0,                \"entityOrField\": false,                \"limit\": 15,                \"offset\": 0,                \"pageNo\": 0,                \"pageSize\": 15,                \"showCount\": 10,                \"sorts\": [],                \"totalCount\": 0,                \"totalPage\": 0,                \"totalResult\": 0            },            \"rangeable\": true,            \"rk\": \"12\",            \"rsdzjs\": 0,            \"sfjf\": \"0\",            \"skfsmc\": \"无\",            \"sxbj\": \"1\",            \"totalResult\": \"0\",            \"userModel\": {                \"monitor\": false,                \"roleCount\": 0,                \"roleKeys\": \"\",                \"roleValues\": \"\",                \"status\": 0,                \"usable\": false            },            \"xf\": \"3\",            \"xkbz\": \"无\",            \"xm\": \"███████\",            \"xnm\": \"2024\",            \"xqdm\": \"0\",            \"xqh1\": \"1,2,\",            \"xqh_id\": \"1\",            \"xqj\": \"1\",            \"xqjmc\": \"星期一\",            \"xqm\": \"3\",            \"xqmc\": \"███████\",            \"xsdm\": \"01\",            \"xslxbj\": \"*\",            \"year\": \"2024\",            \"zcd\": \"9-███████周\",            \"zcmc\": \"███████\",            \"zfjmc\": \"主讲\",            \"zhxs\": \"3\",            \"zxs\": \"48\",            \"zxxx\": \"无\",            \"zyfxmc\": \"███████\",            \"zyhxkcbj\": \"否\",            \"zzrl\": \"███████\"        },\n6.2 CSV文件（courses.csv）\n\n\n\n课程名称\n教室\n节数\n日期\n课时安排\n\n\n\n\n常微分方程1\n███████\n3-4\n周一\n1-16周\n\n\n\n\n\n7. todo\n可视化界面：集成tkinter或Web框架（如Flask）提供GUI操作。\n全校课表爬虫\n\n�**\n","categories":["笔记"]},{"title":"记一次配置Obsidian配合Hexo写博客","url":"/Arknight-notes/posts/t2zf3s.html","content":"测试，现在新写了个插件，晚上回来整\n看网上教程又是整Templates又是整quickadd太麻烦，遂自己写了一个插件\n地址 https://github.com/Zhongye1/obsidian-with-hexo\n\n\n首先使用 obsidian 打开现有Hexo项目的 source/_posts 作为文章目录，然后什么博客文章操作一键完成就行了\n差不多，没啥好水的\n","categories":["笔记"],"tags":["日志"]},{"title":"2024一些笔记（概率论）","url":"/Arknight-notes/posts/20561.html","content":"2024的一些笔记（概率论）（共18张）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbp)\n","categories":["笔记"],"tags":["概率论"]},{"title":"hexo集成gitalk时的Error Validation Failed问题","url":"/Arknight-notes/posts/18261.html","content":"hexo集成gitalk时Error: Validation Failed问题Hexo集成Gitalk后，某些文章下方的评论显示Error: Validation Failed\nGitalk会限制Label name的长度，有些文章生成的URL长度会超过限制，所以导致这个问题\n\n解决方案可以集成一个对文章生成唯一id的插件\nhexo-abbrlink在博客根目录下安装\nnpm install --save hexo-abbrlink\n并修改配置文件_config.yml\npermalink: [EveryWordsYouWant]/:abbrlink/\n再 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 即可\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"数据结构-图","url":"/Arknight-notes/posts/18076.html","content":"图是一种比线性表和树更为复杂的数据结构。在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。\n图结构在计算机科学和算法设计中有广泛的应用。例如，在社交网络分析中，可以使用图结构来表示用户之间的关系；在路线规划中，可以使用图结构来表示道路网络和城市之间的连接关系；在人工智能领域中，图结构可以用于表示知识图谱和推荐系统等。\n在离散数学中，图论是专门研究图的性质的数学分支，而在数据结构中，则应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若干图的操作的实现。\n一、定义图（Graph）由两个集合和组成，记为，其中是顶点的有穷非空集合，是中顶点偶对的有穷集合，这些顶点偶对称为边。和通常分别表示图的顶点集合和边集合，可以为空集。若为空，则图只有顶点而没有边。\n\n如上图所示，左图为有向图，右图为无向图。\n对于图，若边集为有向边的集合，则称该图为有向图；若边集为无向边的集合，则称该图为无向图。\n在有向图中，顶点对$是有序的，它称为从顶点到顶点的一条有向边。因此，与是不同的两条边。顶点对用一对尖括号括起来，是有向边的始点，是有向边的终点。$也称作一条弧，其中 x 为弧尾，y 为弧头。\nA ──→ B\n│     │\n↓     ↓\nC ──→ D\n\n 表示从顶点 A 到顶点 B 的有向边\n 表示从顶点 A 到顶点 C 的有向边\n 表示从顶点 B 到顶点 D 的有向边\n 表示从顶点 C 到顶点 D 的有向边\n箭头表示方向， ≠ \n\n在无向图中，顶点对是无序的，它称为与顶点 x 和顶点 y 相关联的一条边。这条边没有特定的方向，与是同一条边。为了有别于有向图，无向图的顶点对用一对圆括号括起来。\nA ---- B\n|      |\n|      |\nC ---- D\n\n(A,B) 表示顶点 A 和顶点 B 之间的无向边\n(A,C) 表示顶点 A 和顶点 C 之间的无向边\n(B,D) 表示顶点 B 和顶点 D 之间的无向边\n(C,D) 表示顶点 C 和顶点 D 之间的无向边\n没有方向性，(A,B) = (B,A)\n\n二、基本术语下面介绍图结构中的一些基本术语（注：n 表示图中顶点数目，e 表示边的数目）。\n\n子图：假设右两个图  和 ，如果   且   ，则称  为  的子图。如下图所示，图（b）是图（a）的子图。\n\n\n\n无向完全图和有向完全图：对于无向图，若具有  条边，则称为无向安全图。对于有向图，若具有  条弧，则称为有向完全图。\n稀疏图和稠密图：边或弧很少（如   ​ ）的图称为稀疏图，反之称为稠密图。\n权和网：若在图的每条边上标上具有某种含义的数值，该数值称为该边上的权值。这些权值可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。\n邻接点：对于无向图 G，如果图的边   ，则称顶点  和  互为邻接点，即 v 和 v’相邻接。边依附于顶点  和 ，或者说边与顶点  和  相关联。\n度、入度和出度：顶点  的度是指和  相关联的边的数目，记为 。例如，下图（b）中的顶点 ​ 的度是 2。\n对于有向图，顶点 v 的度分为入度和出度。入度是以顶点 v 为头的弧的数目，记为 ；出度是以顶点 v 为尾的弧的数目，记为  。顶点 v 的度为 。\n例如，下图（a）中的顶点   ​ 的入度 ，出度 ，度 \n\n\n\n\n路径和路径长度：在无向图  中，从顶点  到顶点  的路径是一个顶点序列 ​  ，其中 ​  ，  ​。\n如果 G 是有向图，则路径也是有向的，顶点序列应满足  $∈E，1≤j≤m$ ​。路径长度是一条路径上经过的边或弧的数目。\n回路或环：第一个顶点和最后一个顶点相同的路径称为回路或环。\n简单路径、简单回路或简单环：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。\n连通、连通图和连通分量：在无向图  中，如果从顶点  到顶点  有路径，则称  和  是连通的。如果对于图中任意两个顶点 ​  ，​   和   ​ 都是连通的，则称  是连通图。而所谓连通分量，指的是无向图中的极大连通子图。例如，下图（a）就是一个连通图，而图（b）则是非连通图，但它有 3 个连通分量，见图（c）。\n\n\n\n强连通图和强连通分量：在有向图  中，如果对于每一对 ​  ，​  ，从 ​   到 ​   和从 ​   到 ​   都存在路径，则称  是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。例如，下图（a）就是一个强连通图，而图（b）则不是强连通图，但它有两个强连通分量，见图（c）。\n\n\n\n连通图的生成树：一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的 n-1 边，这样的连通子图称为连通图的生成树。例如，下图（c）是图（a）的最大连通分量的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。\n\n\n\n有向树和生成森林：有一个顶点的入度为 0，其余顶点的入度均为 1 的有向图称为有向树。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。例如，下图（a）是一棵有向树，图（b）是一个有向图，它的森林是图（c）。\n\n\n三、存储结构由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。\n另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有邻接表、十字链表和邻接多重表，应根据实际需要的不同选择不同的存储结构。\n3.1、邻接矩阵3.1.1、表示法邻接矩阵（Adjacency Matrix）是表示顶点之间相邻关系的矩阵。设 是具有 n 个顶点的图，则  的邻接矩阵是具有如下性质的 n 阶方阵：\n或其他\n例如，下图为一个有向图和它的邻接矩阵:\n\n若 G 是网，则邻接矩阵可以定义为：\n或其他\n其中，​  表示边上的权值，​ ∞  表示计算机允许的、大于所有边上权值的数。例如，下图为一个有向网和它的邻接矩阵:\n\n用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。在 C 语言中，图的邻接矩阵类型描述如下：\n// 表示极大值#define MaxInt 32767// 最大顶点数#define MVNum 100​// 假设顶点的数据类型为字符型typedef char VerTexType;​// 假设边的权值类型为整型typedef int ArcType;​typedef struct {    // 顶点表    VerTexType vexs[MVNum];    // 邻接矩阵    ArcType arcs[MVNum][MVNum];    // 图的当前顶点数和边数    int vexnum, arcnum;}AMGraph;\n3.1.2、创建无向网已知一个图的顶点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。该算法的步骤为：\n\n输入总顶点数和总边数。\n依次输入顶点的信息存入顶点表中。\n初始化邻接矩阵，使每个权值初始化为极大值。\n构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。\n\n相应的算法描述为：\n// 采用邻接矩阵表示法，创建无向网GStatus CreateUDN(AMGraph &amp;G) {    // 输入总顶点数和总边数    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;​    // 依次输入顶点信息    for(i=0; i&lt;G.vexnum; ++i)        cin&gt;&gt;G.vexs[i]​    // 初始化邻接矩阵，边的权值均为极大值MaxInt    for(i=0; i&lt;G.vexnum; ++i)        for(j=0; j&lt;G.vexnum; ++j)            G.arcs[i][j]=MaxInt;​    // 构造邻接矩阵    for(k=0;k&lt;G.arcnum;++k) {        // 输入一条边依附的顶点和其权值        cin&gt;v1&gt;&gt;v2&gt;&gt;w;        // 确定v1和v2在G中的位置，即顶点数组的下标        i=LocateVex(G,v1);        j=LocateVex(G,v2);        // 边&lt;v1, v2&gt;的权值置为w        G.arcs[i][j]=w;        // 置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值置为w        G.arcs[j][i]=G.arcs[i][j];    }​    return OK;}\n该算法的时间复杂度是   ​\n若要建立无向图，只需对上述算法做两处小的改动：一是初始化邻接矩阵时，将边的权值均初始化为 0；二是构造邻接矩阵时，将权值 w 改为常量值 1 即可。同样，将该算法稍做修改即可建立一个有向网或有向图。\n3.1.3、优缺点邻接矩阵表示法的优点是：\n\n便于判断两个顶点之间是否有边，即根据  或 1 来判断。\n便于计算各个顶点的度。对于无向图，邻接矩阵第 i 行元素之和就是顶点 i 的度；对于有向图，第 i 行元素之和就是顶点 i 的出度，第 i 列元素之和就是顶点 i 的入度。\n\n邻接矩阵表示法的缺点是：\n\n不便于增加和删除顶点。\n不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为 ​ O(n2) 。\n空间复杂度高。如果是有向图，n 个顶点需要 ​ n2  个单元存储边。如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要  个单元即可。但无论以何种方式存储，邻接矩阵表示法的空间复杂度均为   ​，这对于稀疏图而言尤其浪费空间。\n\n3.2、邻接表3.2.1、表示法邻接表（Adjacency List）是图的一种链式存储结构。\n在邻接表中，对图中每个顶点 ​ 建立一个单链表，把与  vi ​ 相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：表头结点表和边表。\n表头结点表，由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域（data）和链域（firstarc）两部分，如下图（a）所示。其中，数据域用于存储顶点 ​ vi  的名称或其他信息；链域用于指向链表中第一结点（即与顶点 ​ vi  相邻接的第一个邻接点）。\n边表，由表示图中顶点间关系的 2n 个边链表组成。边链表中边结点包括邻接点域、数据域和链域三部分，如下图（b）所示。其中，邻接点域指示与顶点  vi ​ 相邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点 ​ vi  相邻接的下一个邻接点。\n\n例如，在下图（a）中有两个图，图（b）则是它们对应的邻接表。\n\n在无向图的邻接表中，顶点 ​   的度恰为第 i 个链表中的结点数；而在有向图中，第 i 个链表中的结点个数只是顶点 ​ 的出度，为求入度，必须遍历整个邻接表。在所有链表中，其邻接点域的值为 i 的结点的个数就是顶点    ​ 的入度。有时，为了便于确定顶点的入度，可以建立一个有向图的逆邻接表，即对每个顶点 ​    建立一个链接所有进入 ​    的边的表。例如，下图（c）为有向图 ​ 的逆邻接表。\n\n根据上述讨论，要定义一个邻接表，需要定义存放顶点的头结点和表示边的边结点。在 C 语言中，图的邻接表存储结构的类型描述如下：\n// 最大顶点数#define MVNum 100​// 边结点typedef struct ArcNode {    // 该边所指向的顶点的位置（邻接点域）    int adjvex;    // 指向下一条边的指针（链域）    struct ArcNode *nextarc;    // 和边相关的信息（数据域）    OtherInfo info;}ArcNode;​// 顶点信息typedef struct VNode {    VerTexType data;    // 指向第一条依附该顶点的边的指针    ArcNode *firstarc;}VNode, AdjList[MVNum];​// 邻接表typedef struct {    AdjList vertices;    // 图的当前顶点数和边数    int vexnum, arcnum;}ALGraph;\n3.2.2、创建无向图基于邻接表表示法创建一个图，需要创建其相应的顶点表和边表。下面以一个无向图为例来说明创建图的算法。该算法步骤为：\n\n输入总顶点数和总边数。\n依次输入顶点的信息存入顶点表中，使每个表头结点的指针域初始化为 NULL。\n创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号 i 和 j 之后，将此边结点分别插入 ​    和    ​ 对应的两个边链表的头部。\n\n相应的算法描述为：\n// 采用邻接表表示法，创建无向图GStatus CreateUDG(ALGraph &amp;G) {    // 输入总顶点数，总边数    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;​    // 输入顶点信息，构造表头结点表    for(i=0; i&lt;G.vexnum; ++i) {        // 输入顶点的值        cin&gt;&gt;G.vertices[i].data;        // 初始化表头结点的指针域为NULL        G.vertices[i].firstarc=NULL;    }​    // 输入各边，构造邻接表    for(k=0; k&lt;G.arcnum; ++k) {        // 输入一条边依附的两个顶点        cin&gt;&gt;v1&gt;&gt;v2;        // 确定v1和v2在G中的位置，即顶点在G.vertices中的下标        i=LocateVex(G,v1);        j=LocateVex(G,v2);​        // 生成一个新的边结点*p1        p1=new ArcNode;        // 邻接点序号为j        p2-&gt;adjvex=j;        // 将新结点*p1插入到顶点vi的边表头部        p1-&gt;nextarc=G.vertices[i].firstarc;        G.vertices[i].firstarc=p1;​        // 生成另一个对称的新边结点*p2        p2=new ArcNode;        // 邻接点序号为i        p2-&gt;adjvex=i;        // 将新结点*p2插入到顶点vj的边表头部        p2-&gt;nextarc=G.vertices[j].firstarc;        G.vertices[j].firstarc=p2;    }​    return OK;}\n该算法的时间复杂度是 。\n建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号，仅需生成一个邻接点序号为 j 的边表结点，并将其插入到 ​   的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在 info 域中。\n需要注意的是，一个图的邻接矩阵表示是唯一的，但其邻接表表示不唯一，这是因为在邻接表表示中，各边表结点的链接次序取决于建立邻接表的算法，以及边的输入次序。\n3.2.3、优缺点邻接矩阵和邻接表是图的两种最常用的存储结构，它们各有所长。与邻接矩阵相比，邻接表有其自己的优缺点。其优点是：\n\n便于增加和删除顶点。\n便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为 O(n+e)。\n空间效率高。对于一个具有 n 个顶点 e 条边的图 G，若 G 是无向图，则在其邻接表表示中有 n 个顶点表结点和 2e 个边表结点；若 G 是有向图，则在它的邻接表表示或逆邻接表表示中均有 n 个顶点表结点和 e 个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为 O(n+e)，适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。\n\n其缺点是：\n\n不便于判断顶点之间是否有边，要判定 ​ 和 ​ 之间是否有边，就需扫描第 i 个边表，最坏情况下要耗费 O(n)时间。\n不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点 ​ 的度是第 i 个边表中的结点个数。在有向图的邻接表中，第 i 个边表上的结点个数是顶点 ​ vi  的出度，但求  vi ​ 的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。\n\n3.3、十字链表十字链表（Orthogonal List）是有向图的另一种链式存储结构。它可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构形式如下图所示。\n\n在弧结点中有 5 个域：其中尾域 tailvex 和头域 headvex 分别指示弧尾和弧头这两个顶点在图中的位置，链域 hlink 指向弧头相同的下一条弧，而链域 tlink 指向弧尾相同的下一条弧，info 域指向该弧的相关信息。弧头相同弧在同一链表上，弧尾相同的弧也在同一链表上。而它们的头结点即为顶点结点。\n顶点结点由 3 个域组成：其中 data 域存储和顶点相关的信息，如顶点的名称等；firstin 和 firstout 为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。\n例如，下图（b）是下图（a）所示图的十字链表。\n\n若将有向图的邻接矩阵看成是稀疏矩阵的话，则十字链表也可以看成是邻接矩阵的链式存储结构，在图的十字链表中，弧结点所在的链表非循环链表，结点之间相对位置自然形成，不一定按顶点序号有序，表头结点即顶点结点，它们之间不是链接，而是顺序存储。\n在 C 语言中，有向图的十字链表存储结构的类型描述如下：\n#define MAX_VERTEX_NUM 20​typedef struct ArcBox {    // 该弧的尾和头结点的位置    int tailvex,headvex;    // 分别为弧头相同和弧尾相同的弧的链域    struct ArcBox *hlink,*tlink;    // 该弧相关信息的指针    InfoType *info;}ArcBox;​typedef struct VexNode {    VertexType data;    // 分别指向该顶点的第一条入弧和出弧    ArcBox *firstin, *firstout;}VexNode;​typedef struct {    // 表头向量    VexNode xlist[MAX_VERTEX_NUM];    // 有向图的当前顶点数和弧数    int vexnum, arcnum;}QLGraph;\n只要输入 n 个顶点的信息和 e 条弧的信息，便可建立该有向图的十字链表。建立十字链表的时间复杂度和建立邻接表是相同的。在十字链表中既容易找到以 ​ vi  为尾的弧，也容易找到以  vi ​ 为头的弧，因而容易求得顶点的出度和入度（或需要，可在建立十字链表的同时求出）。在某些有向图的应用中，十字链表是很有用的工具。\n3.4、邻接多重表邻接多重表（Adjacency Multilist）是无向图的另一种链式存储结构。虽然邻接表是无向图的一种很有效的存储结构，在邻接表中容易求得顶点和边的各种信息。但是，在邻接表中每一条边  (vi,vj)  有 ​ 两个结点，分别在第 i 个和第 j 个链表中，这给某些图的操作带来不便。例如，在某些图的应用问题中，需要对边进行某种操作，如对已被搜索过的边作记号或删除一条边等，此时需要找到表示同一条边的两个结点。因此，在进行这一类操作的无向图的问题中采用邻接多重表作存储结构更为适宜。\n\n邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示，它由 6 个域组成。其中，mark 为标志域，可用以标记该条边是否被搜索过；ivex 和 jvex 为该边依附的两个顶点在图中的位置；ilink 指向下一条依附于顶点 ivex 的边；jlink 指向下一条依附于顶点 jvex 的边；info 指向和边相关的各种信息的指针域。\n每一个顶点也用一个结点表示，它由两个域组成。其中，data 域存储和该顶点相关的信息，firstedge 域指示第一条依附于该顶点的边。\n例如，下图（b）是下图（a）所示图的邻接多重表。\n\n在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，则每个边结点同时链接在两个链表中。可见，对无向图而言，其邻接多重表和邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。因此，除了在边结点中增加一个标志域外，邻接多重表所需的存储量和邻接表相同。\n在 C 语言中，邻接多重表的类型描述如下：\n#define MAX_VERTEX_NUM 20​typedef enum{unvisited, visited} VisitIf;​typedef struct EBox {    // 访问标记    VisitIf mark;    // 该边依附的两个顶点的位置    int ivex, jvex;    // 分别指向依附这两个顶点的下一条边    struct EBox *ilink, *jlink;    // 该边信息指针    InfoType *info;}Ebox;​typedef struct VexBox {    VertexType data;    // 指向第一条依附该顶点的边    EBox *firstedge;}VexBox;​typedef struct {    VexBox adjmulist[MAX_VERTEX_NUM];    // 无向图的当前顶点数和边数    int vexnum, edgenum;}AMLGraph;\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"数据结构-树","url":"/Arknight-notes/posts/19969.html","content":"树是常用的数据结构之一，种类很多比如二叉树，二叉查找树，平衡二叉树，红黑树，B 树，B+树等，本身就是一种递归结构\n什么是树？树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。\n在计算机科学中，树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n\n每个节点都只有有限个子节点或无子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n树里面没有环路(cycle)\n\n术语\n节点的度：一个节点含有的子树的个数称为该节点的度；\n树的度：一棵树中，最大的节点度称为树的度；\n叶节点或终端节点：度为零的节点；\n非终端节点或分支节点：度不为零的节点；\n父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；\n兄弟节点：具有相同父节点的节点互称为兄弟节点；\n节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；\n深度：对于任意节点 n,n 的深度为从根到 n 的唯一路径长，根的深度为 0；\n高度：对于任意节点 n,n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0；\n堂兄弟节点：父节点在同一层的节点互为堂兄弟；\n节点的祖先：从根到该节点所经分支上的所有节点；\n子孙：以某节点为根的子树中任一节点都称为该节点的子孙。\n森林：由 m（m&gt;=0）棵互不相交的树的集合称为森林；\n\n                    A (根节点)                   / \\                  B   C                 / \\   \\                D   E   F               /       / \\              G       H   I (叶节点)             / \\            J   K (叶节点)- A是根节点，没有父节点- B是A的子节点，A是B的父节点- B和C是兄弟节点（具有相同父节点A）- G是叶节点（度为0）- B是非终端节点（度不为0，度为2）- 从A到K的路径长度为3，K的深度为3- 树的度为2（B节点的度最大）- B的度为2（有两个子节点D和E）- 整个结构是一个有序树（子节点有左右顺序）\n这个图示展示了以下树的基本概念：\n\n根节点：A 节点，整棵树的起始点\n父节点与子节点关系：如 A 是 B 和 C 的父节点，B 和 C 是 A 的子节点\n兄弟节点：B 和 C 具有相同的父节点 A，所以它们是兄弟节点\n叶节点：G、H、I、J、K 这些没有子节点的节点\n内部节点：A、B、C、D、E、F 这些有子节点的节点\n节点的度：B 的度为 2（有两个子节点），G 的度为 2（有两个子节点）\n树的度：整棵树的最大节点度，这里是 2\n路径与深度：从根节点 A 到任意节点的路径，如 A-&gt;B-&gt;D-&gt;G 的路径长度为 3\n\n树的种类有序/无序：\n\n无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。\n有序树/搜索树/查找树：树中任意节点的子节点之间有顺序关系，这种树称为有序树。即树的所有节点按照一定的顺序排列，这样进行插入、删除、查找时效率就会非常高\n\n平衡/不平衡：\n\n平衡树\n绝对平衡树：所有叶节点在同一层\n非绝对平衡树\n\n\n不平衡树\n\n节点的分叉情况：\n\n等叉树：是每个节点的键值个数都相同、子节点个数也都相同\n二叉树：每个节点最多含有两个子树的树称为二叉树；\n完全二叉树：除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；\n满二叉树：所有叶节点都在最底层的完全二叉树；\n\n\n平衡二叉树、AVL 树：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树；\n排序二叉树：也称二叉查找树、二叉搜索树、有序二叉树；\n\n\n霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；\n多叉树\n\n\n不等叉树：每个节点的键值个数不一定相同、子节点个数也不一定相同\nB 树：对不等叉树的节点键值数和插入、删除逻辑添加一些特殊的要求，使其能达到绝对平衡的效果。B 树全称 Balance Tree。如果某个 B 树上所有节点的分叉数最大值是 m，则把这个 B 数叫做 m 阶 B 树。\n\n\n\n二叉树二叉树就像它的名字一样，每个元素最多有两个节点，分别称为左节点和右节点。当然并不是每个元素都需要有两个节点，有的可能只有左节点，有的可能只有右节点。\n        A (根节点)       / \\      B   C     / \\   \\    D   E   F   /       / \\  G       H   I (叶节点) / \\J   K (叶节点)\n基于树的存储模式的不同，为了更好的利用存储空间，二叉树又分为完全二叉树和非完全二叉树：\n「完全二叉树」：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大\n１、完全二叉树                    A (根节点)                   / \\                  B   C                 / \\   \\                D   E   F               /       / \\              G       H   I (叶节点)             / \\            J   K (叶节点)完全二叉树的顺序存储数组索引: [0][1][2][3][4][5][6][7][8]存储内容: [1][2][3][4][5][6][7][8][9]\n２、非完全二叉树        1       / \\      2   3     /     \\    4       5   /       / \\  6       7   8         /        9非完全二叉树的顺序存储数组索引: [0][1][2][3][4][5][6][7][8][9][10][11][12][13][14][15][16][17][18]存储内容: [1][2][3][4][ ][ ][5][6][ ][ ][ ][ ][ ][7][8][ ][ ][ ][9]存在大量空位，造成空间浪费\n二叉树的存储模式二叉树的存储模式有两种，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法\n二叉链式存储法链式存储法相对比较简单，理解起来也非常容易，每一个节点都有三个字段，一个字段存储着该节点的值，另外两个字段存储着左右节点的引用。我们顺着跟字节就可以很轻松的把整棵树串起来\n链式存储法结构示意图：    节点A   /     \\  ↓       ↓节点B    节点C/   \\     /   \\↓    ↓   ↓    ↓...  ... ...  ...每个节点的内存结构：┌─────────────┬─────────────┬─────────────┐│    data     │    left     │    right    ││  (节点值)   │  (左子节点) │  (右子节点) │└─────────────┴─────────────┴─────────────┘      ↓              ↓             ↓    节点值       指向左子树    指向右子树                   的指针        的指针\n链式存储法的 C 语言实现：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 二叉树节点定义typedef struct TreeNode {    int data;           // 节点数据    struct TreeNode* left;   // 左子节点指针    struct TreeNode* right;  // 右子节点指针} TreeNode;// 创建新节点TreeNode* createNode(int data) {    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));    newNode-&gt;data = data;    newNode-&gt;left = NULL;    newNode-&gt;right = NULL;    return newNode;}// 示例：构建一个简单的二叉树TreeNode* buildSampleTree() {    TreeNode* root = createNode(1);    root-&gt;left = createNode(2);    root-&gt;right = createNode(3);    root-&gt;left-&gt;left = createNode(4);    root-&gt;left-&gt;right = createNode(5);    return root;}// 释放链式存储的二叉树内存void freeTree(TreeNode* root) {    if (root == NULL) {        return;    }    freeTree(root-&gt;left);    freeTree(root-&gt;right);    free(root);}// 使用示例void demonstrateStorageMethods() {    printf(\"=== 二叉树两种存储方式演示 ===\\n\");    // 1. 链式存储法    printf(\"\\n1. 链式存储法:\\n\");    TreeNode* linkedTree = buildSampleTree();    printf(\"前序遍历结果: \");    preOrderLinked(linkedTree);    printf(\"\\n\");    freeTree(linkedTree);    // 2. 顺序存储法    printf(\"\\n2. 顺序存储法:\\n\");    buildCompleteBinaryTree();    printArrayTree();    printf(\"前序遍历结果: \");    preOrderArray(0);    printf(\"\\n\");}/*对比两种存储方式：1. 链式存储法：   - 优点：灵活，不需要大片连续内存，插入删除节点方便   - 缺点：需要额外空间存储指针，遍历时需要多次内存跳转2. 顺序存储法：   - 优点：节省指针空间，访问节点速度快（通过数组下标直接访问）   - 缺点：对于非完全二叉树会造成空间浪费，插入删除节点复杂*/int main() {    demonstrateStorageMethods();    return 0;}\n顺序存储法顺序存储法是基于数组实现的，数组是一段有序的内存空间，如果我们把跟节点的坐标定位i=1，左节点就是 2  i = 2，右节点 2  i+ 1 = 3，以此类推，每个节点都这么算，然后就将树转化成数组了，反过来，按照这种规则我们也能将数组转化成一棵树。\n于是在这里我们就能发现一个问题：如果这是一颗不平衡的二叉树是不是会造成大量的空间浪费？这就是为什么需要分完全二叉树和非完全二叉树，分别来看看这两种树基于数组的存储模式。\n顺序存储法的 C 语言实现：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_TREE_SIZE 100// 用数组表示二叉树int treeArray[MAX_TREE_SIZE];int treeSize = 0;// 初始化数组void initTreeArray() {    for (int i = 0; i &lt; MAX_TREE_SIZE; i++) {        treeArray[i] = -1; // -1表示空节点    }}// 在指定位置插入节点void insertNode(int index, int data) {    if (index &gt;= MAX_TREE_SIZE) {        printf(\"数组越界\\n\");        return;    }    treeArray[index] = data;    if (index &gt;= treeSize) {        treeSize = index + 1;    }}// 获取父节点索引int getParentIndex(int index) {    if (index &lt;= 0) return -1;    return (index - 1) / 2;}// 获取左子节点索引int getLeftChildIndex(int index) {    int leftIndex = 2 * index + 1;    return (leftIndex &lt; MAX_TREE_SIZE) ? leftIndex : -1;}// 获取右子节点索引int getRightChildIndex(int index) {    int rightIndex = 2 * index + 2;    return (rightIndex &lt; MAX_TREE_SIZE) ? rightIndex : -1;}// 示例：构建完全二叉树void buildCompleteBinaryTree() {    initTreeArray();    // 构建一个简单的完全二叉树: 1, 2, 3, 4, 5    //       1    //      / \\    //     2   3    //    / \\    //   4   5    insertNode(0, 1);  // 根节点    insertNode(1, 2);  // 1的左子节点    insertNode(2, 3);  // 1的右子节点    insertNode(3, 4);  // 2的左子节点    insertNode(4, 5);  // 2的右子节点}// 打印数组表示的二叉树（层序遍历）void printArrayTree() {    printf(\"数组存储的二叉树: \");    for (int i = 0; i &lt; treeSize; i++) {        if (treeArray[i] != -1) {            printf(\"%d \", treeArray[i]);        } else {            printf(\"NULL \");        }    }    printf(\"\\n\");}// 前序遍历（数组实现）void preOrderArray(int index) {    if (index &gt;= treeSize || treeArray[index] == -1) {        return;    }    printf(\"%d \", treeArray[index]);    preOrderArray(2 * index + 1);  // 左子树    preOrderArray(2 * index + 2);  // 右子树}// 前序遍历（链式存储）void preOrderLinked(TreeNode* root) {    if (root == NULL) {        return;    }    printf(\"%d \", root-&gt;data);    preOrderLinked(root-&gt;left);    preOrderLinked(root-&gt;right);}\n对比两种存储方式：\n\n链式存储法：\n\n优点：灵活，不需要大片连续内存，插入删除节点方便\n缺点：需要额外空间存储指针，遍历时需要多次内存跳转\n\n\n顺序存储法：\n\n优点：节省指针空间，访问节点速度快（通过数组下标直接访问）\n缺点：对于非完全二叉树会造成空间浪费，插入删除节点复杂\n\n\n\n完全二叉树顺序存储法完全二叉树结构：        1       / \\      2   3     / \\ / \\    4  5 6  7   /  8数组存储方式（索引从0开始）：索引:  [0][1][2][3][4][5][6][7]值:    [1][2][3][4][5][6][7][8]父子节点关系：- 父节点索引为 i，则左子节点索引为 2*i+1，右子节点索引为 2*i+2- 子节点索引为 j，则父节点索引为 (j-1)/2（整数除法）具体对应关系：- 节点1(索引0): 左子节点2(索引1), 右子节点3(索引2)- 节点2(索引1): 左子节点4(索引3), 右子节点5(索引4)- 节点3(索引2): 左子节点6(索引5), 右子节点7(索引6)- 节点4(索引3): 左子节点8(索引7), 无右子节点- 节点5-8(索引4-7): 均为叶节点，无子节点\n非完全二叉树顺序存储法完全二叉树结构：        1       / \\      2   3     / \\ / \\    4  5 6  7   /  8数组存储方式（索引从0开始）：索引:  [0][1][2][3][4][5][6][7]值:    [1][2][3][4][5][6][7][8]父子节点关系：- 父节点索引为 i，则左子节点索引为 2*i+1，右子节点索引为 2*i+2- 子节点索引为 j，则父节点索引为 (j-1)/2（整数除法）具体对应关系：- 节点1(索引0): 左子节点2(索引1), 右子节点3(索引2)- 节点2(索引1): 左子节点4(索引3), 右子节点5(索引4)- 节点3(索引2): 左子节点6(索引5), 右子节点7(索引6)- 节点4(索引3): 左子节点8(索引7), 无右子节点- 节点5-8(索引4-7): 均为叶节点，无子节点\n从图中将树转化成数组之后可以看出，完全二叉树用数组来存储只浪费了一个下标为 0 的存储空间，非完全二叉树则浪费了大量的空间。「如果树为完全二叉树，用数组存储比链式存储节约空间，因为数组存储不需要存储左右节点的信息」\n\n二叉树遍历要了解二叉树的遍历，我们首先需要实例化出一颗二叉树，我们采用链式存储的方式来定义树，实例化树需要树的节点信息，用来存放该节点的信息，因为我们才用的是链式存储，所以我们的节点信息如下。\n/** * 定义一棵树 *//* 树节点的定义 */#define MAX_TREE_SIZE 100typedef struct{  TElemType data;  int parent; /* 父节点位置域 */} PTNode;typedef struct{  PTNode nodes[MAX_TREE_SIZE];  int n; /* 节点数 */} PTree;/* 二叉树节点的定义 */typedef struct TreeNode {    int data;    struct TreeNode* left;    struct TreeNode* right;} TreeNode;\n\n使用  PTNode  结构体表示树的节点，包含：\ndata：存储节点数据（类型为  TElemType）\nparent：存储父节点在数组中的索引位置\n\n\n使用  PTree  结构体表示整棵树，包含：\nnodes：节点数组，最多可容纳  MAX_TREE_SIZE  个节点\nn：实际节点数量\n\n\n\n定义完节点信息之后，我们就可以初始化一颗树啦，下面是初始化树的过程:\nTreeNode* buildTree() {// 创建测试用的二叉树TreeNode* t1 = (TreeNode*)malloc(sizeof(TreeNode));TreeNode* t2 = (TreeNode*)malloc(sizeof(TreeNode));TreeNode* t3 = (TreeNode*)malloc(sizeof(TreeNode));TreeNode* t4 = (TreeNode*)malloc(sizeof(TreeNode));TreeNode* t5 = (TreeNode*)malloc(sizeof(TreeNode));TreeNode* t6 = (TreeNode*)malloc(sizeof(TreeNode));TreeNode* t7 = (TreeNode*)malloc(sizeof(TreeNode));TreeNode* t8 = (TreeNode\\*)malloc(sizeof(TreeNode));    t1-&gt;data = 1;    t2-&gt;data = 2;    t3-&gt;data = 3;    t4-&gt;data = 4;    t5-&gt;data = 5;    t6-&gt;data = 6;    t7-&gt;data = 7;    t8-&gt;data = 8;    t1-&gt;left = t2;    t1-&gt;right = t3;    t2-&gt;left = t4;    t4-&gt;right = t7;    t3-&gt;left = t5;    t3-&gt;right = t6;    t6-&gt;left = t8;    t2-&gt;right = NULL;    t3-&gt;left = t5;    t3-&gt;right = t6;    t4-&gt;left = NULL;    t4-&gt;right = t7;    t5-&gt;left = NULL;    t5-&gt;right = NULL;    t6-&gt;left = t8;    t6-&gt;right = NULL;    t7-&gt;left = NULL;    t7-&gt;right = NULL;    t8-&gt;left = NULL;    t8-&gt;right = NULL;    return t1;}\n经过上面步骤之后，我们的树就长成下图所示的样子，数字代表该节点的值。\n构建的二叉树结构：        1       / \\      2   3     /   / \\    4   5   6     \\     /      7   8t1-&gt;left = t2; // 节点1的左子节点是节点2t1-&gt;right = t3; // 节点1的右子节点是节点3t2-&gt;left = t4; // 节点2的左子节点是节点4t4-&gt;right = t7; // 节点4的右子节点是节点7t3-&gt;left = t5; // 节点3的左子节点是节点5t3-&gt;right = t6; // 节点3的右子节点是节点6t6-&gt;left = t8; // 节点6的左子节点是节点8节点连接关系：- 节点1是根节点，左子节点为2，右子节点为3- 节点2的左子节点为4，右子节点为NULL- 节点3的左子节点为5，右子节点为6- 节点4的左子节点为NULL，右子节点为7- 节点5的左子节点为NULL，右子节点为NULL- 节点6的左子节点为8，右子节点为NULL- 节点7和8都是叶节点，没有子节点\n有了树之后，我们就可以对树进行遍历二叉树的遍历有三种方式，前序遍历，中序遍历，后续遍历三种遍历方式，三种遍历方式与节点输出的顺序有关系\n前序遍历「前序遍历」：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。\n\n理解了前序遍历的概念和看完前序遍历执行流程动态图之后，你心里一定很想知道，在代码中如何怎么实现树的前序遍历？二叉树的遍历非常简单，一般都是采用递归的方式进行遍历，我们来看看前序遍历的代码：\n// 先序遍历，递归实现 先打印本身，再打印左节点，在打印右节点void preOrder(TreeNode\\* root) {if (root == NULL) {return;}// 输出本身printf(\"%d \", root-&gt;data);// 遍历左节点preOrder(root-&gt;left);// 遍历右节点preOrder(root-&gt;right);}\n中序遍历「中序遍历」：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。\n跟前序遍历一样，我们来看看中序遍历的执行流程动态图。\n\n中序遍历的代码：\n// 中序遍历 先打印左节点，再输出本身，最后输出右节点void inOrder(TreeNode\\* root) {if (root == NULL) {return;}inOrder(root-&gt;left);printf(\"%d \", root-&gt;data);inOrder(root-&gt;right);}\n后序遍历「后序遍历」：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。\n跟前两种遍历一样，理解概念之后，我们还是先来看张图。\n\n后序遍历的实现代码：\n// 后序遍历 先打印左节点，再输出右节点，最后才输出本身void postOrder(TreeNode\\* root) {if (root == NULL) {return;}postOrder(root-&gt;left);postOrder(root-&gt;right);printf(\"%d \", root-&gt;data);}\n二叉树有三种遍历方式，但都是一样的，只是输出的顺序不一样\n接下来还有一种常用而且比较特殊的二叉树：「二叉查找树」\n二叉查找树二叉查找树又叫二叉搜索树，从名字中我们就能够知道，这种树在查找方面一定有过人的优势，事实确实如此，二叉查找树确实是为查找而生的树，但是它不仅仅支持快速查找数据，还支持快速插入、删除一个数据\n「二叉查找树」：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值，下面定义了一颗二叉查找树\n        62       /  \\      58   88     /  \\ /  \\    47  51 73  99   /           /  35          93   \\    37   /  \\  36  39       \\        42- 对于任意节点，其左子树中的所有节点值都小于该节点值- 其右子树中的所有节点值都大于该节点值- 根节点 `62`：左子树所有节点（58, 47, 35, 37, 36, 39, 42, 51）都小于 62；右子树所有节点（88, 73, 99, 93）都大于 62- 节点 `58`：左子树（47, 35, 37, 36, 39, 42）都小于 58；右子树（51）大于 58- 节点 `88`：左子树（73）小于 88；右子树（99, 93）大于 88\n根据二叉查找树的定义，每棵树的左节点的值要小于这父节点，右节点的值要大于父节点下面从二叉查找树的查找开始学习二叉查找树\n二叉查找树的查找操作由于二叉查找树的特性，我们需要查找一个数据，先跟跟节点比较，如果值等于跟节点，则返回根节点，如果小于根节点，则必然在左子树这边，只要递归查找左子树就行，如果大于，这在右子树这边，递归右子树即可。这样就能够实现快速查找，因为每次查找都减少了一半的数据，跟二分查找有点相似，快速插入、删除都是居于这个特性实现的。\n下面用一幅动态图来加强对二叉查找树查找流程的理解，在上面的这颗二叉查找树中找出值等于 37 的节点：\n\n\n1、先用 37 跟 62 比较，37 &lt; 62 ，在左子树中继续查找\n２、左子树的节点值为 58，37 &lt; 58 ，继续在左子树中查找\n３、左子树的节点值为 47，37 &lt; 47，继续在左子树中查找\n４、左子树的节点值为 35，37 &gt; 35，在右子树中查找\n５、右子树中的节点值为 37，37 = 37 ，返回该节点\n\n讲完了查找的概念之后，我们一起来看看二叉查找树的查找操作的代码实现\n/** * 在二叉查找树中查找指定值的节点 * @param tree 二叉查找树的根节点 * @param data 要查找的数据值 * @return 找到的节点指针，如果未找到则返回NULL */TreeNode* find(TreeNode* tree, int data) {    // 从根节点开始遍历    TreeNode* current = tree;    // 当当前节点不为空时继续查找    while (current != NULL) {        // 如果要查找的值小于当前节点值，在左子树中查找        if (data &lt; current-&gt;data) {            current = current-&gt;left;        }        // 如果要查找的值大于当前节点值，在右子树中查找        else if (data &gt; current-&gt;data) {            current = current-&gt;right;        }        // 如果值相等，找到了目标节点        else {            return current;        }    }    // 未找到目标节点    return NULL;}\n二叉查找树的插入操作插入跟查找差不多，也是从根节点开始找，如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。\n假设我们要插入 63 ，我们用一张动态图来看看插入的流程。\n\n\n1、63 &gt; 62 ，在树的右子树继续查找.\n2、63 &lt; 88 ，在树的左子树继续查找\n3、63 &lt; 73 ,因为 73 是叶子节点，所以 63 就成为了 73 的左子树。\n\n我们来看看二叉查找树的插入操作实现代码\n/** * 在二叉查找树中查找指定值的节点 * @param tree 二叉查找树的根节点 * @param data 要查找的数据值 * @return 找到的节点指针，如果未找到则返回NULL */TreeNode* find(TreeNode* tree, int data) {    // 从根节点开始遍历    TreeNode* current = tree;    // 当当前节点不为空时继续查找    while (current != NULL) {        // 如果要查找的值小于当前节点值，在左子树中查找        if (data &lt; current-&gt;data) {            current = current-&gt;left;        }        // 如果要查找的值大于当前节点值，在右子树中查找        else if (data &gt; current-&gt;data) {            current = current-&gt;right;        }        // 如果值相等，找到了目标节点        else {            return current;        }    }    // 未找到目标节点    return NULL;}\n二叉查找树的删除操作删除的逻辑要比查找和插入复杂一些，删除分一下三种情况：\n「第一种情况」：如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 51。\n「第二种情况」：如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 35。\n「第三种情况」：如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 88\n前面两种情况稍微简单一些，第三种情况，我制作了一张动态图，希望能对你有所帮助。\n\n我们来看看二叉查找树的删除操作实现代码\nvoid delete(TreeNode** tree, int data) {    TreeNode* p = *tree; // p指向要删除的节点，初始化指向根节点    TreeNode* pp = NULL; // pp记录的是p的父节点    while (p != NULL &amp;&amp; p-&gt;data != data) {        pp = p;        if (data &gt; p-&gt;data) p = p-&gt;right;        else p = p-&gt;left;    }    if (p == NULL) return; // 没有找到    // 要删除的节点有两个子节点    if (p-&gt;left != NULL &amp;&amp; p-&gt;right != NULL) { // 查找右子树中最小节点        TreeNode* minP = p-&gt;right;        TreeNode* minPP = p; // minPP表示minP的父节点        while (minP-&gt;left != NULL) {            minPP = minP;            minP = minP-&gt;left;        }        p-&gt;data = minP-&gt;data; // 将minP的数据替换到p中        p = minP; // 下面就变成了删除minP了        pp = minPP;    }    // 删除节点是叶子节点或者仅有一个子节点    TreeNode* child; // p的子节点    if (p-&gt;left != NULL) child = p-&gt;left;    else if (p-&gt;right != NULL) child = p-&gt;right;    else child = NULL;    if (pp == NULL) *tree = child; // 删除的是根节点    else if (pp-&gt;left == p) pp-&gt;left = child;    else pp-&gt;right = child;    free(p); // 释放被删除节点的内存}\n二叉查找树在极端情况下会退化成链表，例如每个节点都只有一个左节点，这是时间复杂度就变成了 O(n)，为了避免这种情况，又出现了一种新的树叫「平衡二叉查找树」，之后再开坑讲\n还有个前缀树，之后也会开坑讲一下\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"2025-11-02 组会朝花夕拾","url":"/Arknight-notes/posts/26939.html","content":"设定：\n存在两个独立的、我们无法直接观测的泊松过程  和 。它们分别服从泊松分布：：参数为 ：参数为 我们唯一能观测到的是它们的总和 \n由于泊松分布的可加性， 本身也服从泊松分布：现在引入了另一个可观测的变量 于是同时拥有了两个可观测变量： 和 \n\n目标：利用  的联合观测数据，来估计出那些未知的参数：, , 以及可能的 \n\n\n\n\n\n，\n构造 \n可观测的对象：，\n现在需要对  做推断/检验，看有无区间严格保证 \n两个方法：\n\n参考之前文章的 idea 直接推\n用随机加权的 IM 方法\n\n随机加权的 IM 方法的话就是：\n利用随机加权的 IM 方法为参数 构造置信区间\n差不多研究下相关的文献之后再研究\nY = B + S S ~ P(lambda) B ~ P(b) ==&gt; Y ~ P(STA) STA = lambda + b\n构造 W ~ P(m * b)\n可观测 obser： Y = y ， W = w问题 QUS：对 lambda 做推断/检验 看有无区间严格保证 1- a 属于 I\n两个方法：\n\n参考之前文章的 idea 直接推\n用随机加权的 ificent model\n\n随机加权的 ificent model：\nstep1：\nQ： Y~P(STA) STA = lambda + b\nF_STA(Y-1) &lt;= u &lt; F_STA(Y)u,v ~ Unif(0,1)\nF_mb(w-1) &lt;= v &lt;= F_mb(w)\nstep2:\nG(STA): w_1: F_STA(Y-1)+(1-w_1)F_STA(Y) = u (关于 STA 的递减函数)H(mb): w_2: F_mb(w-1) + (1-w_2)F_mb(w) =v\nstep3:\nSTA = [G(u)]^(-1) , b = [H(v)]^(-1)/m ==&gt;lambda = [G(u)]^(-1)-[H(v)]^(-1)\nstep4:\n模拟验证：\n对 U,V ~ Unif(0,1) -&gt; 生成 10000 个样本\nW1，W2 ~ Unif(0,1) -&gt; 10000\nfor 循环 for u,v,W_1,W_2\nlambda = [G(u)]^(-1)-[H(v)]^(-1) -&gt; 10000 个解\n得到[lambda上区间，lambda下区间] = [lambda_0.025，lambda_0.095] lambda 的上分位数下分位数\n10000 次样本有无落入其中： true lambda = STA - b\n关注作差后覆盖率好不好 N/ 10000 (能否保证)\n结果如何\n好-》 成功不好—》 h 函数继续优化\n","categories":["归档"],"tags":["日志"]},{"title":"2025-10-24-10.20课题","url":"/Arknight-notes/posts/45309.html","content":"设定：​​\n存在两个独立的、我们无法直接观测的随机过程 B和 S。它们分别服从泊松分布：\nB ~ Poisson(b)： 参数为 b\nS ~ Poisson(q)： 参数为 q\n我们唯一能观测到的是它们的总和 Y = B + S由于泊松分布的可加性，Y本身也服从泊松分布：Y ~ Poisson(b + q)现在引入了另一个可观测的变量 W ~ Poisson(m * b)于是同时拥有了两个可观测变量：Y和 W\n目标是利用 (Y, W)的联合观测数据，来估计出那些未知的参数：b, q, 以及可能的 m​\n含隐变量的模型​​复合分布问题​​参数估计问题​​解决这类问题最常用的方法是 ​​最大似然估计​​ 和 ​​期望最大化算法​​\n","categories":["归档"],"tags":["日志"]},{"title":"2025-11-09-关于软考高项网规","url":"/Arknight-notes/posts/53411.html","content":"\n\n早八去东风路考试，上午选择大概考了网络基础概念 OSI 模型、编码传输之类，另外就是问企业内部网络规划（VLAN、路由交换）、路由协议（OSPF、BGP）、传输应用层（TCP/IP、DNS）及网络管理（SNMP），差不多还有广域网接入、无线与 IPv6，问了下网络安全解决方案（防火墙、VPN、加密认证）、服务器存储与容灾技术，网络规划设计与实施能力，加上一些操作系统、项目管理，专业英语之类的八股\n然后案例分析问了网络安全、无线网络规划和存储容灾之类的内容，第一题问一家公司网络中存在大量用户敏感信息，还不进行网络安全等级保护测评，业务烂的要死被勒索病毒攻击事件还不立马断网还查资料把整个单位崩了之类的情况让你分析 （安全问题加钱就完了，开月薪 3000 谁给你写 waf）\n第二题问在图书馆、教学楼、宿舍、操场、体育馆等不同场景下进行无线网络部署的工作，​ 比较 2.4G、5G、6G 等不同无线频段的特性（答了穿透性、速率、干扰、信道数量），再问设备选型之类（密集放装型、面板型、室外定向天线），还问怎么写一万人使用的网络设计方案\n第三题问某公司的数据备份和存储架构规划，问备份策略（全量/增量通过 IPSec VPN 传输）的不足（一眼带宽占用大、恢复时间长），提出改进措施（如改用专线、增量永久合成等技术，一时半会没想到都），然后就是问提升集中式存储可靠性的技术（如 RAID、双控制器、快照、镜像等）。再问技术选型，对比集中式存储和分布式存储在架构、冗余机制、扩展性和性能等方面的差异，比较堆叠和 MLAG 这两种提高网络可靠性的技术差异之类。\n论文是讲国家教育数字化战略，推进智慧校园建设相关的内容，“论智慧校园网络规划与设计”，比如智慧校园要如何满足同城双校区网络互联，无线网络覆盖，智慧教室专网，校园安防专网等基本需求。说是要结合自身参与规划、设计和实施的智慧校园网络建设项目，详细论述规划和设计方案，包括项目整体规划，网络架构，设备选型等，再结合自身参与实施的项目，分析智慧校园网络规划与设计中的难点和创新点。（哪个大三的会有这经验）\n吃 408 计网老本还有平时一些积累考的，区别在于感觉题目更侧重问通信工程相关，做起来没啥太大压力，论文的话感觉没两年工作经验写不动，只能靠先前准备的内容糊上去，感觉会被卡 10%通过率，大概率寄了痛失两百块，下次考也许工作后罢。\n","categories":["归档"],"tags":["日志"]},{"title":"2025-11-05-基于随机加权推断模型（IM）的参数估计算法","url":"/Arknight-notes/posts/10893.html","content":"基于随机加权推断模型（IM）的参数估计方法不可观测的泊松过程  和 ，观测值  和辅助变量 ，目标是估计参数 、m?\n现提出基于随机加权推断模型（Inferential Model, IM）的算法通过引入随机权重处理离散分布，来构造置信区间\n方法概述随机加权 IM 方法的核心是通过引入均匀随机变量和权重，将离散泊松分布连续化，从而逆解参数该方法假设  已知算法分为四个步骤：建立关联模型、引入随机权重连续化、逆解参数、模拟验证覆盖率\n算法步骤1: 建立关联模型对观测值 ，其分布函数为 ，其中 引入辅助变量 ，建立关联：\nF_{θ}(Y-1) \\leq u < F_{θ}(Y)对观测值 ，其分布函数为 ，引入辅助变量 ，建立关联：\nF_{mb}(W-1) \\leq v \\leq F_{mb}(W)2: 引入随机权重进行连续化引入随机权重 ，构造方程：\nG(θ): w_1 F_{θ}(Y-1) + (1-w_1) F_{θ}(Y) = uH(mb): w_2 F_{mb}(W-1) + (1-w_2) F_{mb}(W) = v 和  是关于参数的函数，且由于泊松分布函的单调性，逆函数  和  存在\n3: 逆解参数，使用 brentq 函数进行二分法求根从上述方程解出  和 ：\nθ = G^{-1}(u), \\quad mb = H^{-1}(v)推导参数：\nb = \\frac{H^{-1}(v)}{m}, \\quad q = θ - b = G^{-1}(u) - \\frac{H^{-1}(v)}{m}得到  和  的表达式\n4: 验证覆盖率\n模拟目标：检查构造的置信区间覆盖真实  的概率是否接近 95%\n\n步骤：\n\n\n生成观测数据：从分布生成一对观测值 \n对于固定 ，生成大量样本（如  个）的 \n计算  的候选值：对于每个样本，计算 \n构造置信区间：从 10000 个 q 值中取分位数，得到置信区间 \n检查覆盖率：重复步骤 2-5 多次（  次），每次生成新的 ，计算区间覆盖真实  的比例覆盖率 覆盖次数\n算法实现import numpy as npimport pandas as pdfrom scipy.stats import poisson, gammafrom scipy.optimize import brentqimport matplotlib.pyplot as pltimport seaborn as snsfrom tqdm import tqdmimport warningswarnings.filterwarnings('ignore')# 设置全局字体为 SimHei (黑体) 或其他中文字体plt.rcParams['font.sans-serif'] = ['SimHei']plt.rcParams['axes.unicode_minus'] = Falseclass PoissonSignalInference:    \"\"\"    基于随机加权IM方法的泊松信号推断类    用于估计背景率b、信号率q和尺度参数m    \"\"\"    def __init__(self, b_true=None, q_true=None, m_true=None):        \"\"\"        初始化真实参数值        \"\"\"        self.b_true = b_true        self.q_true = q_true        self.m_true = m_true        self.STA_true = b_true + q_true if b_true is not None and q_true is not None else None    def generate_data(self, n_samples=1):        \"\"\"        生成观测数据Y和W        当前有不可观测的泊松过程 B ∼ Poisson(b) 和 S ∼ Poisson(q)        可观测对象有 Y = B + S ∼ Poisson(b + q) 和辅助变量 W ∼ Poisson(m · b)        目标是估计参数 b、q 和可能的 m        \"\"\"        if self.b_true is None or self.q_true is None or self.m_true is None:            raise ValueError(\"必须先设置真实参数值\")        if self.STA_true is None:            self.STA_true = self.b_true + self.q_true        Y = np.random.poisson(self.STA_true, n_samples)        W = np.random.poisson(self.m_true * self.b_true, n_samples)        return Y, W    def poisson_cdf(self, k, theta):        \"\"\"        计算泊松分布的累积分布函数        \"\"\"        return poisson.cdf(k, theta) #泊松分布的CDF公式，参数为 k 和 theta    def solve_G_inverse(self, u, Y, w1, bracket_low=0, bracket_high=100):        \"\"\"        求解方程 G(STA) = u 的逆函数，得到STA        使用二分法求解 G(STA): w_1 F_{STA}(Y-1) + (1-w_1) F_{STA}(Y) = u        计算泊松混合分布的累积分布函数值与目标值的差值        该函数计算一个泊松混合分布的CDF值，该混合分布由两个泊松分布组成，权重分别为w1和(1-w1)，        然后减去目标值u，通常用于求解分位数或进行概率计算        参数:            Y (int or array-like): 观测值，泊松分布的计数变量            STA (float or array-like): 泊松分布的参数λ（均值）            w1 (float): 第一个泊松分布的权重，取值范围[0,1]            u (float): 目标概率值，用于比较或求解        返回:        \"\"\"        def equation(STA): #返回值:(float or array-like): 泊松混合分布的CDF值与目标值u的差值            if Y == 0:                # 当Y=0时，F_STA(-1)=0，方程简化为F_STA(0)=u                return self.poisson_cdf(0, STA) - u            else:                return w1 * self.poisson_cdf(Y-1, STA) + (1-w1) * self.poisson_cdf(Y, STA) - u                # 求加权泊松混合分布                # 第一项：权重w1乘以P(X &lt;= Y-1)的概率                # 第二项：权重(1-w1)乘以P(X &lt;= Y)的概率                # 最后减去目标值u        try:            \"\"\"            使用二分法求解 G(STA) = u 方程中的 STA 值            \"\"\"            # 设置上下界来初始化搜索区间            low = max(0.00001, bracket_low) #bracket_low下界（）            high = max(10 * Y, bracket_high) if Y &gt; 0 else bracket_high #bracket_high上界，根据观测值 Y 调整上界            # 检查边界值            f_low = equation(low)            f_high = equation(high)            if f_low * f_high &gt; 0:                # 如果 f_low * f_high &gt; 0（同号），则自动扩大搜索区间                attempts = 0                while f_low * f_high &gt; 0 and attempts &lt; 10:                    high *= 2 #最多尝试10次，每次将上界翻倍：high *= 2                    f_high = equation(high)                    attempts += 1            STA_solution = brentq(equation, low, high, xtol=1e-6)            \"\"\"            参数为要求解的方程（加权泊松混合分布），上下区间，精度            使用 brentq 函数进行二分法求根            求解 w1 * self.poisson_cdf(Y-1, STA) + (1-w1) * self.poisson_cdf(Y, STA) - u = 0            即求解方程 G(STA) = u            得到STA            \"\"\"            return STA_solution #返回求解得到的 STA 值        except (ValueError, RuntimeError):            # 如果求解失败，返回保守估计            print(\"ERR solve_G_inverse 求解失败，返回保守估计\")            return max(0.001, Y)    def solve_H_inverse(self, v, W, w2, m, bracket_low=0, bracket_high=100):        \"\"\"        求解方程 H(mb) = v 的逆函数，得到mb        H(mb): w_2 F_{mb}(W-1) + (1-w_2) F_{mb}(W) = v        \"\"\"        def equation(mb):            if W == 0:                return self.poisson_cdf(0, mb) - v            else:                return w2 * self.poisson_cdf(W-1, mb) + (1-w2) * self.poisson_cdf(W, mb) - v        try:            low = max(0.001, bracket_low)            high = max(10 * W, bracket_high) if W &gt; 0 else bracket_high            f_low = equation(low)            f_high = equation(high)            if f_low * f_high &gt; 0:                attempts = 0                while f_low * f_high &gt; 0 and attempts &lt; 10:                    high *= 2                    f_high = equation(high)                    attempts += 1            mb_solution = brentq(equation, low, high, xtol=1e-6)            return mb_solution        except (ValueError, RuntimeError):            return max(0.001, W)    def estimate_parameters_IM(self, Y_obs, W_obs, m_known=True, n_inner_samples=10000):        \"\"\"        使用随机加权IM方法估计三个参数q、b和STA        Y_obs：观测值Y        W_obs：观测值W        m_known：一个布尔值，表示参数m是否已知        n_inner_samples：内部采样次数，默认为10000        \"\"\"        if not m_known:            raise NotImplementedError(\"m未知\")        # 创建三个列表存储候选参数值        q_candidates = []        b_candidates = []        STA_candidates = []        for _ in range(n_inner_samples):            # 生成4个均匀分布的随机权重（u, v, w1, w2）            u = np.random.uniform(0, 1)            v = np.random.uniform(0, 1)            w1 = np.random.uniform(0, 1)            w2 = np.random.uniform(0, 1)            # 使用solve_G_inverse和solve_H_inverse方法计算STA和mb的估计值            STA_est = self.solve_G_inverse(u, Y_obs, w1)            mb_est = self.solve_H_inverse(v, W_obs, w2, self.m_true)            # G(STA): w_1 F_{STA}(Y-1) + (1-w_1) F_{STA}(Y) = u ==&gt; 求解STA            # H(mb): w_2 F_{mb}(W-1) + (1-w_2) F_{mb}(W) = v ==&gt; 求解mb            # 可以得到            # STA = G⁻¹(u), mb = H⁻¹(v)            # 计算b和q            # b = H⁻¹(v)/m            # q = STA - b = G⁻¹(u) - H⁻¹(v)/m            if self.m_true is None:                raise ValueError(\"参数 m_true 未设置，无法计算 b_est\")            b_est = mb_est / self.m_true            q_est = STA_est - b_est            # 确保非负            q_est = max(0, q_est)            b_est = max(0, b_est)            #每次计算出新的 q_est 值后，会将其添加到 q_candidates 列表中            q_candidates.append(q_est)            b_candidates.append(b_est)            STA_candidates.append(STA_est)        return {            'q_candidates': np.array(q_candidates),            'b_candidates': np.array(b_candidates),            'STA_candidates': np.array(STA_candidates)        }    def calculate_confidence_intervals(self, candidates_dict, alpha=0.05):        \"\"\"        计算参数的置信区间        \"\"\"        intervals = {}        for param, values in candidates_dict.items():            # 移除'_candidates'后缀，使键名简化            simple_param = param.replace('_candidates', '')            lower = np.quantile(values, alpha/2)            upper = np.quantile(values, 1 - alpha/2)            intervals[simple_param] = (lower, upper)        return intervals    def coverage_simulation(self, n_outer_trials=1000, n_inner_samples=1000, alpha=0.05):        \"\"\"        进行覆盖率模拟验证        \"\"\"        coverage_results = {            'q': 0.0,            'b': 0.0,            'STA': 0.0        }        interval_lengths = {            'q': [],            'b': [],            'STA': []        }        print(\"正在进行覆盖率模拟...\")        for i in tqdm(range(n_outer_trials)):            # 生成新的观测数据            Y_obs, W_obs = self.generate_data(1)            Y_obs, W_obs = Y_obs[0], W_obs[0]            # 估计参数            candidates_dict = self.estimate_parameters_IM(Y_obs, W_obs,                                                         n_inner_samples=n_inner_samples)            # 计算置信区间            intervals = self.calculate_confidence_intervals(candidates_dict, alpha)            # 检查覆盖率            if intervals['q'][0] &lt;= self.q_true &lt;= intervals['q'][1]:                coverage_results['q'] += 1            if intervals['b'][0] &lt;= self.b_true &lt;= intervals['b'][1]:                coverage_results['b'] += 1            if intervals['STA'][0] &lt;= self.STA_true &lt;= intervals['STA'][1]:                coverage_results['STA'] += 1            # 记录区间长度            interval_lengths['q'].append(intervals['q'][1] - intervals['q'][0])            interval_lengths['b'].append(intervals['b'][1] - intervals['b'][0])            interval_lengths['STA'].append(intervals['STA'][1] - intervals['STA'][0])        # 计算覆盖率        for param in coverage_results:            coverage_results[param] = coverage_results[param] / n_outer_trials        return coverage_results, interval_lengths    def plot_results(self, candidates_dict, intervals, Y_obs, W_obs):        \"\"\"        可视化结果        \"\"\"        fig, axes = plt.subplots(2, 2, figsize=(15, 10))        # q的分布        axes[0, 0].hist(candidates_dict['q_candidates'], bins=50, alpha=0.7, density=True)        axes[0, 0].axvline(self.q_true, color='red', linestyle='--', linewidth=2, label=f'真实 q = {self.q_true}')        axes[0, 0].axvline(intervals['q'][0], color='green', linestyle='--', linewidth=1, label=f'{100*(1-0.05)}% CI')        axes[0, 0].axvline(intervals['q'][1], color='green', linestyle='--', linewidth=1)        axes[0, 0].set_xlabel('q')        axes[0, 0].set_ylabel('密度')        axes[0, 0].set_title('q的后验分布')        axes[0, 0].legend()        # b的分布        axes[0, 1].hist(candidates_dict['b_candidates'], bins=50, alpha=0.7, density=True)        axes[0, 1].axvline(self.b_true, color='red', linestyle='--', linewidth=2, label=f'真实 b = {self.b_true}')        axes[0, 1].axvline(intervals['b'][0], color='green', linestyle='--', linewidth=1, label=f'{100*(1-0.05)}% CI')        axes[0, 1].axvline(intervals['b'][1], color='green', linestyle='--', linewidth=1)        axes[0, 1].set_xlabel('b')        axes[0, 1].set_ylabel('密度')        axes[0, 1].set_title('b的后验分布')        axes[0, 1].legend()        # STA的分布        axes[1, 0].hist(candidates_dict['STA_candidates'], bins=50, alpha=0.7, density=True)        axes[1, 0].axvline(self.STA_true, color='red', linestyle='--', linewidth=2, label=f'真实 STA = {self.STA_true}')        axes[1, 0].axvline(intervals['STA'][0], color='green', linestyle='--', linewidth=1, label=f'{100*(1-0.05)}% CI')        axes[1, 0].axvline(intervals['STA'][1], color='green', linestyle='--', linewidth=1)        axes[1, 0].set_xlabel('STA')        axes[1, 0].set_ylabel('密度')        axes[1, 0].set_title('STA的后验分布')        axes[1, 0].legend()        # 观测数据信息        axes[1, 1].axis('off')        text_str = f'观测数据:\\nY = {Y_obs}\\nW = {W_obs}\\n\\n真实参数:\\nb = {self.b_true}\\nq = {self.q_true}\\nm = {self.m_true}\\nSTA = {self.STA_true}'        axes[1, 1].text(0.1, 0.9, text_str, transform=axes[1, 1].transAxes, fontsize=12,                    verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))        plt.tight_layout()        plt.show()def main():    \"\"\"    主函数：演示完整的推断流程    \"\"\"    # 设置真实参数    b_true = 3.0  # b    q_true = 2.0  # q    m_true = 0.8  # 尺度参数（已知）    STA_true = b_true + q_true    print(\"=== 泊松推断演示 ===\")    print(f\"真实参数: b={b_true}, q={q_true}, m={m_true}, STA={STA_true}\")    # 初始化推断器    inference = PoissonSignalInference(b_true, q_true, m_true)    # 生成单次观测数据    Y_obs, W_obs = inference.generate_data(1)    Y_obs, W_obs = Y_obs[0], W_obs[0]    print(f\"\\n生成的观测数据: Y={Y_obs}, W={W_obs}\")    # 使用IM方法进行参数估计    print(\"\\n正在进行参数估计...\")    candidates_dict = inference.estimate_parameters_IM(Y_obs, W_obs, n_inner_samples=10000)    # 计算置信区间    alpha = 0.05  # 0.95置信区间    intervals = inference.calculate_confidence_intervals(candidates_dict, alpha)    print(\"\\n=== 估计结果 ===\")    for param, (lower, upper) in intervals.items():        true_value = getattr(inference, f\"{param.replace('_candidates', '')}_true\", None)        if true_value is not None:            print(f\"{param}: [{lower:.3f}, {upper:.3f}] (真实值: {true_value:.3f})\")        else:            print(f\"{param}: [{lower:.3f}, {upper:.3f}]\")    # 可视化结果    print(\"\\n生成可视化图表...\")    inference.plot_results(candidates_dict, intervals, Y_obs, W_obs)    # 进行覆盖率模拟（样本量较小以加快演示速度）    print(\"\\n正在进行覆盖率模拟...\")    coverage_results, interval_lengths = inference.coverage_simulation(        n_outer_trials=500,  # 减少试验次数以加快演示        n_inner_samples=1000,  # 减少内部样本数        alpha=0.05    )    print(\"\\n=== 覆盖率结果 ===\")    for param, coverage in coverage_results.items():        print(f\"{param}的覆盖率: {coverage:.3f} (目标: {1-alpha:.3f})\")    # 绘制区间长度分布    plt.figure(figsize=(12, 4))    for i, (param, lengths) in enumerate(interval_lengths.items()):        plt.subplot(1, 3, i+1)        plt.hist(lengths, bins=30, alpha=0.7)        plt.xlabel(f'{param}区间长度')        plt.ylabel('频数')        plt.title(f'{param}置信区间长度分布')    plt.tight_layout()    plt.show()if __name__ == \"__main__\":    main()\n","categories":["归档"],"tags":["日志"]},{"title":"2025-11-04-JavaScript 常用方法速查","url":"/Arknight-notes/posts/36778.html","content":"JavaScript 常用方法速查\n数组\n\n\n\n方法\n说明\n示例\n返回值/副作用\n\n\n\n\npush(...items)\n末尾添加元素\narr.push(4) → 修改原数组\n返回新数组长度\n\n\npop()\n删除末尾元素\narr.pop() → 修改原数组\n返回被删除元素\n\n\nunshift(...items)\n开头添加元素\narr.unshift(0) → 修改原数组\n返回新数组长度\n\n\nshift()\n删除开头元素\narr.shift() → 修改原数组\n返回被删除元素\n\n\nslice(start, end)\n截取数组片段（不修改原数组）\narr.slice(1, 3)\n返回新数组\n\n\nsplice(start, deleteCount, ...items)\n删除/替换元素\narr.splice(1, 2, 'a') → 修改原数组\n返回被删除元素组成的数组\n\n\nmap(callback)\n遍历并返回新数组\n[1,2,3].map(x =&gt; x*2) → [2,4,6]\n新数组\n\n\nfilter(callback)\n过滤符合条件的元素\n[1,2,3].filter(x =&gt; x&gt;1) → [2,3]\n新数组\n\n\nreduce(callback, initialValue)\n累计计算（如求和、统计）\n[1,2,3].reduce((sum, x) =&gt; sum + x, 0) → 6\n最终累计值\n\n\nfind(callback)\n查找第一个符合条件的元素\n[1,2,3].find(x =&gt; x&gt;1) → 2\n元素或  undefined\n\n\nfindIndex(callback)\n查找第一个符合条件的索引\n[1,2,3].findIndex(x =&gt; x&gt;1) → 1\n索引或  -1\n\n\nincludes(value)\n判断是否包含某元素（ES6）\n[1,2,3].includes(2) → true\n布尔值\n\n\nflat(depth)\n扁平化嵌套数组（ES2019）\n[1, [2]].flat() → [1, 2]\n新数组\n\n\n\n\n字符串\n\n\n\n方法\n说明\n示例\n返回值\n\n\n\n\nsplit(separator)\n按分隔符拆分为数组\n\"a,b,c\".split(\",\") → [\"a\", \"b\", \"c\"]\n数组\n\n\nsubstring(start, end)\n截取子字符串（不包含  end  索引）\n\"Hello\".substring(1, 3) → \"el\"\n新字符串\n\n\nslice(start, end)\n截取子字符串（支持负数索引）\n\"Hello\".slice(-3) → \"llo\"\n新字符串\n\n\nreplace(searchValue, newValue)\n替换匹配内容（支持正则表达式）\n\"abc\".replace(\"a\", \"A\") → \"Abc\"\n新字符串\n\n\ntoUpperCase()\n转为大写\n\"hello\".toUpperCase() → \"HELLO\"\n新字符串\n\n\ntoLowerCase()\n转为小写\n\"HELLO\".toLowerCase() → \"hello\"\n新字符串\n\n\ntrim()\n去除首尾空格（ES5）\n\" hello \".trim() → \"hello\"\n新字符串\n\n\nstartsWith(str)\n判断是否以某字符串开头（ES6）\n\"hello\".startsWith(\"he\") → true\n布尔值\n\n\nendsWith(str)\n判断是否以某字符串结尾（ES6）\n\"hello\".endsWith(\"lo\") → true\n布尔值\n\n\npadStart(length, padStr)\n头部填充字符串（ES2017）\n\"5\".padStart(3, \"0\") → \"005\"\n新字符串\n\n\n\n\n对象方法\n\n\n\n方法\n描述\n\n\n\n\nObject.assign()\n方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n\n\nObject.create()\n方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。\n\n\nObject.defineProperties()\n方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。\n\n\nObject.defineProperty()\n方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\n\nObject.entries()\n方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致。\n\n\nObject.freeze()\n方法可以冻结一个对象。\n\n\nObject.fromEntries()\n方法把键值对列表转换为一个对象。\n\n\nObject.getOwnPropertyDescriptor()\n方法返回指定对象上一个自有属性对应的属性描述符。\n\n\nObject.getOwnPropertyDescriptors()\n方法用来获取一个对象的所有自身属性的描述符。\n\n\nObject.getOwnPropertyNames()\n方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。\n\n\nObject.getOwnPropertySymbols()\n方法返回一个给定对象自身的所有 Symbol 属性的数组。\n\n\nObject.getPrototypeOf()\n方法返回指定对象的原型（内部[[Prototype]]属性的值）。\n\n\nObject.is()\n方法判断两个值是否为同一个值。\n\n\nObject.isExtensible()\n方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\n\n\nObject.isFrozen()\n方法判断一个对象是否被冻结。\n\n\nObject.preventExtensions()\n方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。\n\n\nObject.isSealed()\n方法判断一个对象是否被密封。\n\n\nObject.keys()\n方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。\n\n\nObject.setPrototypeOf()\n方法设置一个指定的对象的原型到另一个对象。\n\n\nObject.values()\n方法返回一个给定对象自身的所有可枚举属性值的数组。\n\n\nObject.seal()\n方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。\n\n\n\n\nNumber 方法Number 对象本身有一些静态属性和方法，而 Number 实例的方法是通过 Number.prototype 定义的，但通常我们使用数字字面量时可以直接调用这些方法（因为 JavaScript 会自动装箱）\n\n\n\n\n名称\n描述\n\n\n\n\nconstructor\n返回对创建此对象的 Number 函数的引用。\n\n\nisFinite()\n检查值是否是有限数。\n\n\nisInteger()\n检查值是否为整数。\n\n\nisNaN()\n检查值是否为 Number.NaN。\n\n\nparseFloat()\n检查值是否为整数。\n\n\nparseInt()\n检查值是否为整数。\n\n\nprototype\n允许您向对象添加属性和方法。\n\n\ntoFixed(x)\n把数字转换为字符串，结果的小数点后有指定位数的数字。\n\n\ntoPrecision(x)\n把数字格式化为指定的长度。\n\n\ntoString()\n把数字转换为字符串。\n\n\nvalueOf()​\n返回数字的原始值（基本数字值）。\n\n\n\n\nMath 方法Math 对象是一个静态对象，它包含了许多数学常数和函数。\n\n\n\n\n方法名\n描述\n\n\n\n\nMath.abs(x)\n返回一个数的绝对值。\n\n\nMath.ceil(x)\n返回大于或等于一个数的最小整数（向上取整）。\n\n\nMath.floor(x)\n返回小于或等于一个数的最大整数（向下取整）。\n\n\nMath.round(x)\n返回一个数四舍五入后的整数。\n\n\nMath.max([value1[, value2[, …]]])\n返回一组数中的最大值。\n\n\nMath.min([value1[, value2[, …]]])\n返回一组数中的最小值。\n\n\nMath.pow(x, y)\n返回 x 的 y 次幂。\n\n\nMath.sqrt(x)\n返回一个数的平方根。\n\n\nMath.random()\n返回一个 0 到 1 之间的伪随机数。\n\n\nMath.sin(x)\n返回一个数的正弦值。\n\n\nMath.cos(x)\n返回一个数的余弦值。\n\n\nMath.tan(x)\n返回一个数的正切值。\n\n\nMath.log(x)\n返回一个数的自然对数。\n\n\nMath.exp(x)\n返回 e 的 x 次幂。\n\n\n\n\nDate 对象方法Date 对象用于处理日期和时间\n静态方法\n\n\n\n方法名\n描述\n\n\n\n\nDate.now()\n返回自 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的毫秒数。\n\n\nDate.parse(dateString)\n解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 UTC 所经过的毫秒数。\n\n\nDate.UTC(year, month[, day[, hour[, minute[, second[, millisecond]]]]])\n接受和构造函数最长形式的参数相同的参数，并返回从 1970-1-1 00:00:00 UTC 所经过的毫秒数。\n\n\n\n\n实例方法\n\n\n\n方法名\n描述\n\n\n\n\ngetFullYear()\n根据本地时间返回指定日期对象的年份。\n\n\ngetMonth()\n根据本地时间返回指定日期对象的月份（0-11）。\n\n\ngetDate()\n根据本地时间返回指定日期对象的日期（1-31）。\n\n\ngetDay()\n根据本地时间返回指定日期对象的星期（0-6）。\n\n\ngetHours()\n根据本地时间返回指定日期对象的小时（0-23）。\n\n\ngetMinutes()\n根据本地时间返回指定日期对象的分钟（0-59）。\n\n\ngetSeconds()\n根据本地时间返回指定日期对象的秒数（0-59）。\n\n\ngetMilliseconds()\n根据本地时间返回指定日期对象的毫秒数。\n\n\ngetTime()\n返回从 1970-1-1 00:00:00 UTC 到该日期经过的毫秒数。\n\n\nsetFullYear(year, [month], [day])\n根据本地时间设置指定日期对象的年份。\n\n\nsetMonth(month, [day])\n根据本地时间设置指定日期对象的月份。\n\n\nsetDate(day)\n根据本地时间设置指定日期对象的日期。\n\n\nsetHours(hour, [min], [sec], [ms])\n根据本地时间设置指定日期对象的小时。\n\n\nsetMinutes(min, [sec], [ms])\n根据本地时间设置指定日期对象的分钟。\n\n\nsetSeconds(sec, [ms])\n根据本地时间设置指定日期对象的秒数。\n\n\nsetMilliseconds(ms)\n根据本地时间设置指定日期对象的毫秒数。\n\n\nsetTime(time)\n通过指定从 1970-1-1 00:00:00 UTC 开始经过的毫秒数来设置日期对象。\n\n\ntoISOString()\n返回一个 ISO 格式的字符串：YYYY-MM-DDTHH:mm:ss.sssZ。\n\n\ntoLocaleString()\n返回一个表示日期对象的字符串，该字符串与当地环境的语言相对应。\n\n\n\n\nJSON 对象的方法\n\n\n\n方法名\n描述\n\n\n\n\nJSON.parse(text[, reviver])\n将一个 JSON 字符串转换为对象。\n\n\nJSON.stringify(value[, replacer[, space]])\n将一个值转换为 JSON 字符串。\n\n\n\n\nMap 对象的方法\n\n\n\n方法名\n描述\n\n\n\n\nset(key, value)\n设置 Map 对象中键的值，返回该 Map 对象。\n\n\nget(key)\n返回键对应的值，如果不存在，则返回 undefined。\n\n\nhas(key)\n返回一个布尔值，表示 Map 实例是否包含键对应的值。\n\n\ndelete(key)\n删除 Map 中的元素，删除成功返回 true，否则返回 false。\n\n\nclear()\n移除 Map 对象中的所有元素。\n\n\nkeys()\n返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的键。\n\n\nvalues()\n返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。\n\n\nentries()\n返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的[key, value]数组。\n\n\nforEach(callbackFn[, thisArg])\n按插入顺序，为 Map 对象里的每一键值对调用一次 callbackFn 函数。\n\n\n\n\nSet 对象的方法\n\n\n\n方法名\n描述\n\n\n\n\nadd(value)\n在 Set 对象尾部添加一个元素，返回该 Set 对象。\n\n\nhas(value)\n返回一个布尔值，表示该值在 Set 中存在与否。\n\n\ndelete(value)\n移除 Set 中与这个值相等的元素，返回 Set.prototype.has(value)在这个操作前返回的值。\n\n\nclear()\n移除 Set 对象内的所有元素。\n\n\nkeys()\n返回一个新的 Iterator 对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。\n\n\nvalues()\n与 keys()方法相同，返回一个新的 Iterator 对象。\n\n\nentries()\n返回一个新的 Iterator 对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值的[value, value]数组。\n\n\nforEach(callbackFn[, thisArg])\n按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。\n\n\n\n\nPromise 对象的方法\n\n\n\n方法名\n描述\n\n\n\n\nPromise.all(iterable)\n返回一个新的 Promise，它在 iterable 中所有的 Promise 都成功时才成功，只要有一个失败就失败。\n\n\nPromise.race(iterable)\n返回一个新的 Promise，它在 iterable 中任意一个 Promise 解决或拒绝时立即解决或拒绝。\n\n\nPromise.resolve(value)\n返回一个以给定值解析后的 Promise 对象。\n\n\nPromise.reject(reason)\n返回一个带有拒绝原因的 Promise 对象。\n\n\n\n\n函数与高阶方法\n\n\n\n方法/语法\n说明\n示例\n\n\n\n\nbind(thisArg, ...args)\n绑定  this  并返回新函数\nfunc.bind(obj) → 新函数\n\n\ncall(thisArg, ...args)\n立即调用函数并指定  this\nfunc.call(obj, 1, 2)\n\n\napply(thisArg, [args])\n立即调用函数并指定  this（参数为数组）\nfunc.apply(obj, [1, 2])\n\n\nsetTimeout(callback, delay)\n延迟执行函数（返回定时器 ID）\nsetTimeout(() =&gt; {}, 1000) → ID\n\n\nsetInterval(callback, delay)\n循环执行函数（返回定时器 ID）\nsetInterval(() =&gt; {}, 1000) → ID\n\n\n\n\nRegExp 方法\n\n\n\n方法名\n描述\n\n\n\n\nexec(string)\n在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。\n\n\ntest(string)\n执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。\n\n\n\n\n其他\n\n\n\n方法名\n描述\n\n\n\n\neval(string)\n执行字符串形式的 JavaScript 代码。\n\n\nisNaN(value)\n判断一个值是否是 NaN。注意：全局的 isNaN 会先将参数转换为数值再判断。\n\n\nisFinite(value)\n判断一个值是否是有限数字。\n\n\nparseFloat(string)\n将字符串解析成浮点数。\n\n\nparseInt(string, radix)\n将字符串解析成整数。\n\n\n\n\n【待补充】\n","categories":["归档"],"tags":["前端开发"]},{"title":"数据结构-队列","url":"/Arknight-notes/posts/27379.html","content":"队列（queue）是只允许在一端进行插入操作，在另一端进行删除操作的线性表\n这个的特点是先进先出（First In First Out）然后是允许插入的一端称为队尾（rear），允许删除的一端称为队头(front)。向队列中插入新的数据元素称为入队。从队列中删除队头元素称为出队。\n队列示意图（先进先出 FIFO）：    ┌─────┬─────┬─────┬─────┬─────┐    │  A  │  B  │  C  │  D  │     │    └─────┴─────┴─────┴─────┴─────┘       ↑                       ↑    队头(front)             队尾(rear)元素入队过程：1. 空队列：    [     ][     ][     ][     ]                  ↑            front/rear2. A入队：    [  A  ][     ][     ][     ]                 ↑     ↑               front  rear3. B入队：    [  A  ][  B  ][     ][     ]                 ↑      ↑               front   rear4. C入队：    [  A  ][  B  ][  C  ][     ]                 ↑             ↑               front          rear元素出队过程：1. A出队：    [     ][  B  ][  C  ][     ]                        ↑      ↑                      front   rear2. B出队：    [     ][     ][  C  ][     ]                        ↑      ↑                      front   rear\n队列的顺序存储结构顺序队列用一组地址连续的存储单元，依次存放从队头到队尾的数据元素，称为顺序队列。实现顺序队列需要设两个指针：队头指针（front）和队尾指针（rear），分别指向队头元素和队尾元素。\n顺序队列结构示意图：数组索引:  [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]存储内容:  [A]  [B]  [C]  [D]  [  ] [  ] [  ] [  ]            ↑              ↑          front          rear队列状态：- 队头元素：A（位于索引0）- 队尾元素：D（位于索引3）- 下一个插入位置：索引4- 队列长度：4个元素插入操作：- 新元素将插入到 rear 指针位置- 插入后 rear 指针向后移动一位删除操作：- 从 front 指针位置删除元素- 删除后 front 指针向后移动一位\n如果在插入 E 的基础上再插入元素 F，将会插入失败。因为 rear == MAXSIZE，尾指针已经达到队列的最大长度。但实际上队列存储空间并未全部被占满，这种现象叫做假溢出\n假溢出问题：数组索引:  [0]  [1]  [2]  [3]  [4]  [5]存储内容:  [  ] [  ] [  ] [C]  [D]  [E]                           ↑         ↑                          front    rear问题分析：- 实际可用空间：索引0、1、2（3个位置）- rear指针已到达数组末尾（索引5）- 即使前面有空闲空间，也无法继续插入新元素- 这种现象称为&quot;假溢出&quot;\n通过上图可以发现队头出队、对尾入队造成了数组前面的空间未被利用而出现假溢出。\n为了解决“假溢出”现象，使得队列的存储空间得到充分利用，一个非常巧妙的方法就是将顺序队列的数组看成一个头尾相接的循环结构。\n循环队列graph TD    subgraph &quot;循环队列 (大小=5)&quot;        Cell0[0: a6] --&gt; Cell1[1: 空] --&gt; Cell2[2: a3] --&gt; Cell3[3: a4] --&gt; Cell4[4: a5]        Cell4 -.-&gt; Cell0    end    Front[front指针] --&gt; Cell2    Rear[rear指针] --&gt; Cell1    style Cell2 fill:#e8f5e8    style Cell1 fill:#fff3e0\n现在队满了，但是队头指针和队尾指针相等（队空的时候也是这样）。那么该怎么判断队空还是队满？\n\n两种解决方案\n\n\n设置一个计数器，开始的时候为 0，当有元素入队时+1，有元素出队时-1，值为 MAXSIZE 时队满\n保留一个元素空间，当队尾指针指的空单元的下一个单元是队头指针所指单元是为对满\n\n队满的条件（Queue.rear+1）%MAXSIZE == Queue.front队空的条件 Queue.rear=Queue.front\n循环队列结构\n#define MAXSIZE 20/*循环队列的存储结构*/typedef structQueue&#123;    int data[MAXSIZE];    int front;    //头指针    int rear;    //尾指针&#125;Queue;\n操作\n/*初始化空队列*/int InitSeQueue(Queue* queue);/*获得队列长度*/int GetLength(Queue* queue);/*判空*/bool isEmpty(Queue* queue);/*判满*/bool isFull(Queue* queue);/*入队操作*/int EnterQueue(Queue* queue, int e);/*出队操作*/int ExitQueue(Queue* queue, int e);\n初始化空队列void InitSeQueue(Queue* queue)&#123;    queue-&gt;front = 0;    queue-&gt;rear = 0;    return 0;&#125;\n获得队列长度int GetLength(Queue* queue)&#123;    return (queue-&gt;rear-queue-&gt;front+MAXSIZE)%MAXSIZE;&#125;\n判空bool isEmpty(Queue* queue)&#123;    return queue-&gt;front==queue-&gt;rear;&#125;\n判满bool isFull(Queue* queue)&#123;    return (queue-&gt;rear+1)%MAXSIZE==queue-&gt;front;&#125;\n入队void EnterQueue(Queue* queue, int e)&#123;    if (isFull(queue))    &#123;        printf(&quot;队列满了\\n&quot;);        return;    &#125;    else    &#123;        queue-&gt;data[queue-&gt;rear] = e;        queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE;//求模，rear的值就在[0,MAXSIZE-1]循环    &#125;&#125;\nqueue-&gt;data[queue-&gt;rear] = e;将要入队的元素 e 存储到队尾指针 rear 所指向的位置，这是实际的数据插入操作\nqueue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE;将队尾指针 rear 向后移动一位使用模运算(queue-&gt;rear + 1) % MAXSIZE 实现循环效果当 rear 到达数组末尾时，会自动回到数组开头（索引 0）,利用了数组的存储空间，避免了顺序队列的”假溢出”问题\n出队void ExitQueue(Queue* queue, int*e)&#123;     if (isEmpty(queue))    &#123;        printf(&quot;已经是空队列了\\n&quot;);        return;    &#125;    else    &#123;        *e = queue-&gt;data[queue-&gt;front];        queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE;//注意不要写成(queue-&gt;front - 1)    &#125;&#125;\n其中 *e = queue-&gt;data[queue-&gt;front];\nqueue-&gt;front是队头指针，指向队列的第一个有效元素位置queue-&gt;data[queue-&gt;front]表示获取队头位置存储的数据元素e是一个指向整型变量的指针*e表示对这个指针进行解引用，访问指针指向的内存位置\n整体操作： - 将队头元素的值赋给调用者传入的变量地址 - 这样调用函数就能获取到出队的元素值\n队列的链式存储结构链队列由单链表组成，队头指针指向链表的头结点，队尾指针指向尾节点。空队列时队头指针和队尾指针都指向头节点。\n链队列结构示意图：空队列状态：    front → [头节点] ← rear              ↓             NULL入队元素A后：    front → [头节点] → [A] ← rear             ↓          ↓            [A]       NULL入队元素B后：    front → [头节点] → [A] → [B] ← rear               ↓        ↓     ↓              [A]      [B]   NULL入队元素C后：    front → [头节点] → [A] → [B] → [C] ← rear              ↓         ↓     ↓     ↓             [A]       [B]   [C]   NULL出队元素A后：    front → [头节点] → [B] → [C] ← rear             ↓         ↓      ↓            [B]       [C]    NULL使用单链表实现，front 指针指向头节点rear 指针指向队尾节点头节点不存储数据，仅作为队列的起始标记入队操作在队尾进行，出队操作在队头进行不存在假溢出问题，可根据需要动态分配内存空间\n链队列结构\n/*结点结构*/typedef struct Node&#123;    int data;    struct Node *next;&#125;Node;/*链队列结构*/typedef struct LinkQueue&#123;    Node* front,rear;//队头、队尾指针&#125;LinkQueue;\n初始化链队列void InitLinkQueue(LinkQueue* LinkQ)&#123;    Node* head = malloc(sizeof(Node));    if (LinkQ != NULL &amp;&amp; head != NULL)    &#123;        LinkQ-&gt;front = LinkQ-&gt;rear = head;        head-&gt;next = NULL;    &#125;&#125;\n判空bool isEmpty(LinkQueue* LinkQ)&#123;    return LinkQ-&gt;front == LinkQ-&gt;rear;&#125;\n入队void EnterLinkQueue(LinkQueue* LinkQ, int x)&#123;    /* 创建新节点并分配内存空间 */    Node* node = malloc(sizeof(Node));    /* 将待插入数据存入新节点 */    node-&gt;data = x;    /* 设置新节点的后继指针为空 */    node-&gt;next = NULL;    /* 将新节点连接到当前队尾节点之后 */    LinkQ-&gt;rear-&gt;next = node;    /* 更新队尾指针，指向新插入的节点 */    LinkQ-&gt;rear = node;&#125;\n链队列的入队操作：\n创建新节点：动态分配内存创建新节点设置节点数据：将入队元素 x 存入新节点连接节点：将新节点链接到当前队尾节点之后更新队尾指针：将队尾指针指向新加入的节点\n出队void ExitLinkQueue(LinkQueue* LinkQ, int* x)&#123;    if (isEmpty(LinkQ)) //首先判断队列是否为空，如果为空则直接返回        return;    Node* node = malloc(sizeof(Node));    //保留删除结点的信息    node = LinkQ-&gt;front-&gt;next;    *x = LinkQ-&gt;front-&gt;data; //将队头节点的数据赋值给输出参数x    //建立新联系    LinkQ-&gt;front-&gt;next = node-&gt;next; // 跳过被删除节点，将队头直接连接到下一个节点    //如果队尾出队了，那么就是空队    if (LinkQ-&gt;rear == node)        LinkQ-&gt;front = LinkQ-&gt;rear;    free(node);&#125;\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"2025-11-17-Arch-Linux运行AppImage相关","url":"/Arknight-notes/posts/11830.html","content":"\nAppImage是一种可执行文件格式，类似于 Windows 的 exe 文件，macOS 的 app 文件，不过 AppImage 是运行在 Linux 上的可执行文件，而且是可以运行在不同发行版本的 Linux，如 Ubuntu, Debian, openSUSE, RHEL, CentOS, Fedora, Arch Linux …\n\n运行时\n\n切换到文件路径 cd [文件路径]\n设置文件可以执行权限，chmod +x my.AppImage\n运行 AppImage ./my.AppImage\n\n第一次执行的时候可能会碰到FUSE相关的问题\ndlopen(): error loading libfuse.so.2AppImages require FUSE to run.You might still be able to extract the contents of this AppImageif you run it with the --appimage-extract option.See https://github.com/AppImage/AppImageKit/wiki/FUSEfor more information\n此时在 Arch Linux 上需要安装fuse2\nsudo pacman -S fuse2\n更多关于 FUSE 的问题可以查看：I get some errors related to something called “FUSE”\n在 Arch Linux 中创建 Desktop Entry（桌面条目）可以让你在应用启动器（如 GNOME、KDE 等）中显示应用图标。以下是创建步骤：\n创建 .desktop文件在以下目录之一创建 .desktop文件：\n系统级（所有用户可用）：/usr/share/applications/用户级（仅当前用户可用）：~/.local/share/applications/\n例如，为用户创建条目：\nmkdir -p ~/.local/share/applicationsnano ~/.local/share/applications/myapp.desktop\n\n模板参考（以 VSCode 为例）：\n[Desktop Entry]Version=1.0Type=ApplicationName=My ApplicationComment=应用描述Exec=/path/to/application/executableIcon=/path/to/icon/image.pngTerminal=falseCategories=Utility;Development;\nType: 固定为 Application（也可以是 Link或 Directory）Name: 显示在菜单中的名称Exec: 可执行文件的绝对路径（支持参数，如 %F表示文件）Icon: 图标路径（支持绝对路径或主题图标名，如 firefox）Terminal: 是否在终端中运行（true/false）Categories: 应用分类（参考 freedesktop 规范）\n设置权限chmod +x ~/.local/share/applications/myapp.desktop\n验证语法desktop-file-validate ~/.local/share/applications/myapp.desktop\n更新数据库update-desktop-database ~/.local/share/applications/\n这时候就可以看到桌面上有相关的应用了\n","categories":["归档"]},{"title":"2025-11-19-重拾编程语言设计与计科相关概念","url":"/Arknight-notes/posts/29484.html","content":"计算机类专业结果这些都得自己学，整理一套编程语言设计与计算机科学核心概念集，日后开坑学习，博客狠狠写，知识学爆\n一、内存管理基础概念\n指针（Pointer）\n引用（Reference）\n堆（Heap）\n栈（Stack）\n内存布局（Memory Layout）\n垃圾回收（Garbage Collection）\n内存泄漏（Memory Leak）\n悬挂指针/引用（Dangling Pointer/Reference）\n内存序（Memory Ordering）\n写时复制（Copy-on-Write）\n内存映射文件（Memory-mapped Files）\n缓存一致性协议（Cache Coherence Protocol）\n虚拟内存机制（Virtual Memory）\n内存屏障（Memory Barrier）\n内存对齐（Memory Alignment）\n内存分配器（Memory Allocator）\n内存池（Memory Pool）\n引用计数（Reference Counting）\n弱引用（Weak Reference）\n循环引用（Circular Reference）\n内存碎片（Memory Fragmentation）：包括内部碎片和外部碎片\n分页与分段（Paging and Segmentation）：虚拟内存管理技术\n垃圾回收算法：如标记-清除、复制、标记-整理等具体算法\n内存管理单元（Memory Management Unit）\n内存保护（Memory Protection）\n内存访问（Memory Access）\n\n存储类别\n自动存储期（Automatic Storage Duration）\n静态存储期（Static Storage Duration）\n动态存储期（Dynamic Storage Duration）\n线程存储期（Thread Storage Duration）\n寄存器变量（Register Variable）\n\n二、程序执行模型函数调用机制\n调用栈（Call Stack）\n栈帧（Stack Frame）\n调用约定（Calling Convention）\n参数传递（Parameter Passing）\n尾调用优化（Tail Call Optimization）\n尾递归（Tail Recursion）\nTrampoline 机制\nThunk：延迟计算的代码块\nThunk 函数：用于实现惰性求值的技术\n\n执行上下文\n作用域（Scope）\n词法作用域（Lexical Scope）\n动态作用域（Dynamic Scope）\n作用域链（Scope Chain）\n闭包（Closure）\n执行上下文（Execution Context）\n变量环境（Variable Environment）\n词法环境（Lexical Environment）\n延续（Continuation）\n协程（Coroutine）\n生成器（Generator）\n\n控制流\n事件循环（Event Loop）\n计算器模型（Evaluator Model）\n消息传递接口（Message Passing）\nActor 模型\nCSP（Communicating Sequential Processes）\n控制流图（Control Flow Graph）\n数据流分析（Data Flow Analysis）\n\n三、并发与并行并发模型\n并发（Concurrency）\n并行（Parallelism）\n绿色线程（Green Threads）\n内核线程（Kernel Threads）\n用户态线程（User-level Threads）\n线程池（Thread Pool）\n工作窃取（Work Stealing）\n屏障（Barrier）：同步原语\nfork-join 模型：并行任务执行模型\n数据竞争（Data Race）：并发访问共享数据的问题\n\n同步机制\n原子操作（Atomic Operations）\n比较并交换（Compare-and-Swap）\n锁（Lock）\n自旋锁（Spinlock）\n互斥锁（Mutex）\n读写锁（Read-Write Lock）\n信号量（Semaphore）\n条件变量（Condition Variable）\n无锁编程（Lock-free Programming）\n内存模型（Memory Model）\n顺序一致性（Sequential Consistency）\n释放获取语义（Release-Acquire Semantics）\n\n异步编程\nPromise/Future\nasync/await\n响应式编程（Reactive Programming）\n数据并行（Data Parallelism）\n任务并行（Task Parallelism）\n事务内存（Transactional Memory）\n\n四、类型系统类型分类\n静态类型（Static Typing）\n动态类型（Dynamic Typing）\n强类型（Strong Typing）\n弱类型（Weak Typing）\n基本数据类型（Primitive Data Types）\n复合数据类型（Composite Data Types）\n引用类型（Reference Types）\n值类型（Value Types）\n类型推导（Type Inference）\n类型检查（Type Checking）\n类型擦除（Type Erasure）\n类型转换（Type Casting）\n类型别名（Type Alias）\n类型注解（Type Annotation）\n泛型（Generics）\n类型参数（Type Parameter）\n类型变量（Type Variable）\n类型约束（Type Constraint）\n类型构造器（Type Constructor）\n类型等价（Type Equality）\n类型子类型（Type Subtyping）\n类型上界（Type Upper Bound）\n类型下界（Type Lower Bound）\n类型推断（Type Inference）\n类型检查（Type Checking）\n子类型（Subtyping）：类型之间的关系\n型变（Covariance/Contravariance）：更详细的变型规则说明\n不透明类型（Opaque Types）：隐藏实现细节的类型\n\n高级类型概念\n行多态（Row Polymorphism）\n存在类型（Existential Types）\n高阶类型（Higher-Kinded Types）\n依赖类型（Dependent Types）\n渐进类型（Gradual Typing）\n类型类（Type Classes）\n泛型（Generics）\n变型（Variance）：协变、逆变、不变\n类型安全（Type Safety）\n类型擦除（Type Erasure）\n单态化（Monomorphization）\n\n五、函数与抽象函数概念\n高阶函数（Higher-Order Function）\n回调函数（Callback）\n递归（Recursion）\n匿名函数（Anonymous Function）\nLambda 表达式\n柯里化（Currying）\n部分应用（Partial Application）\n函数组合（Function Composition）\n\n抽象机制\n控制抽象（Control Abstraction）\n数据抽象（Data Abstraction）\n迭代器（Iterator）\n流处理（Stream Processing）\n声明式编程（Declarative Programming）\n函子（Functor）：映射结构的抽象概念\n单子（Monad）：具有绑定操作的计算容器\n\n六、面向对象编程核心概念\n类（Class）\n对象（Object）\n封装（Encapsulation）\n继承（Inheritance）\n多态（Polymorphism）\n接口（Interface）\n抽象类（Abstract Class）\n混入（Mixin）\n特质（Trait）\n\n对象模型\n虚函数表（Virtual Method Table）\n方法解析顺序（Method Resolution Order）\n对象布局（Object Layout）\n多重继承（Multiple Inheritance）\n虚继承（Virtual Inheritance）\n原型继承（Prototypal Inheritance）\n消息传递（Message Passing）：对象间的通信机制\n委托（Delegation）：替代继承的复用机制\n\n七、元编程与反射元编程技术\n反射（Reflection）\n内省（Introspection）\n宏系统（Macro System）\n卫生宏（Hygienic Macro）\n语法宏（Syntax Macro）\n过程宏（Procedural Macro）\n模板元编程（Template Metaprogramming）\n注解处理（Annotation Processing）\n属性导向编程（Attribute-Oriented Programming）\n\n运行时元编程\n动态代理（Dynamic Proxy）\n方法缺失处理（Method Missing）\n代码生成（Code Generation）\nAST 操作（Abstract Syntax Tree Manipulation）\n\n八、编译与解释编译原理\n词法分析（Lexical Analysis）\n语法分析（Syntax Analysis）\n语义分析（Semantic Analysis）\n中间代码生成（Intermediate Code Generation）\n代码优化（Code Optimization）\n目标代码生成（Target Code Generation）\n编译器架构（Compiler Architecture）\n编译器设计（Compiler Design）\n编译器实现（Compiler Implementation）\n链接时优化（Link Time Optimization, LTO）：跨模块优化技术\nProfile-Guided Optimization (PGO)：基于运行时信息的优化\n\n执行引擎\n解释器（Interpreter）\n字节码（Bytecode）\n即时编译（Just-In-Time Compilation）\n抽象语法树（Abstract Syntax Tree, AST）\n单态化（Monomorphization）\n类型擦除（Type Erasure）\n中间表示（Intermediate Representation）\nSSA 形式（Static Single Assignment）\n\n九、系统接口操作系统交互\n系统调用（System Call）\n文件描述符（File Descriptor）\nABI（Application Binary Interface）\n系统 V ABI\nTLS（Thread Local Storage）\n信号处理（Signal Handling）\n\n十、异常与错误处理错误处理机制\n异常处理（Exception Handling）\n返回值错误（Error Return Values）\nResult 类型\n可选值（Option/Maybe）\n断言（Assertion）\n契约编程（Design by Contract）\n\n资源管理\nRAII（Resource Acquisition Is Initialization）\n所有权系统（Ownership System）\n借用检查（Borrow Checking）\n生命周期（Lifetime）\n析构函数（Destructor）\nfinally 块\n\n十一、模块化与代码组织代码组织\n模块化（Modularity）\n命名空间（Namespace）\n包管理（Package Management）\n依赖注入（Dependency Injection）\n接口隔离（Interface Segregation）\n\n链接与加载\n静态链接（Static Linking）\n动态链接（Dynamic Linking）\n符号解析（Symbol Resolution）\n重定位（Relocation）\n名称修饰（Name Mangling）\n\n十二、性能优化编译器优化\n内联优化（Inlining）\n常量传播（Constant Propagation）\n死代码消除（Dead Code Elimination）\n循环优化（Loop Optimization）\n向量化（Vectorization）\n分支目标缓冲（Branch Target Buffer）：提高分支预测准确性的硬件机制\n指令级并行（Instruction Level Parallelism）：CPU 级别的并行执行\n\n运行时优化\n内联缓存（Inline Cache）\n方法缓存（Method Cache）\n逃逸分析（Escape Analysis）\n栈上替换（On-Stack Replacement）\n热点代码检测（Hotspot Detection）\n\n硬件优化\n缓存局部性（Cache Locality）\n分支预测（Branch Prediction）\n流水线冒险（Pipeline Hazard）\n预取（Prefetching）\nSIMD（Single Instruction Multiple Data）\n\n十三、形式化方法与理论形式化验证\n霍尔逻辑（Hoare Logic）\n指称语义（Denotational Semantics）\n操作语义（Operational Semantics）\n公理语义（Axiomatic Semantics）\n进展定理（Progress Theorem）\n保持定理（Preservation Theorem）\n\n计算理论\nλ 演算（Lambda Calculus）\n组合子逻辑（Combinatory Logic）\n图灵完备性（Turing Completeness）\n邱奇-图灵论题（Church-Turing Thesis）\n停机问题（Halting Problem）\n\n十四、现代语言特性语言设计趋势\n空安全（Null Safety）\n模式匹配（Pattern Matching）\n异步/等待（Async/Await）\n记录类型（Record Types）\n代数数据类型（Algebraic Data Types）\n效应系统（Effect System）\n资源安全（Resource Safety）\n所有权与借用（Ownership and Borrowing）：Rust 中的内存安全机制\n异构编程（Heterogeneous Programming）：利用多种计算设备的编程模型\n\n表达式问题\n表达式问题（Expression Problem）\n访问者模式（Visitor Pattern）\n模式匹配解构\n\n十五、编程范式主要范式\n命令式编程（Imperative Programming）\n声明式编程（Declarative Programming）\n函数式编程（Functional Programming）\n逻辑编程（Logic Programming）\n面向对象编程（Object-Oriented Programming）\n面向方面编程（Aspect-Oriented Programming）\n\n混合范式\n多范式编程（Multi-paradigm Programming）\n函数响应式编程（Functional Reactive Programming）\n元对象协议（Metaobject Protocol）\n\n十六、软件开发基础基础概念\n表达式与语句（Expressions vs Statements）\n控制流（Control Flow）\n数据结构（Data Structures）\n算法（Algorithms）\n复杂度分析（Complexity Analysis）\n设计模式（Design Patterns）：常见问题的标准解决方案\nSOLID 原则：面向对象设计的五个基本原则\n\n","categories":["笔记"],"tags":["日志"]},{"title":"2025-11-16-ES6相关","url":"/Arknight-notes/posts/9503.html","content":"ES61、let 和 const\n\n\n\n名称\n描述\n\n\n\n\nlet\n声明变量的关键字，let 声明的变量只在 let 命令所在的代码块内有效\n\n\nconst\n声明常量的关键字，const 声明一个只读的常量，一旦声明，常量的值就不能改变。\n\n\n\n\n2、模板字符串 和 箭头函数\n\n\n\n名称\n描述\n\n\n\n\n``\n使用反引号``包裹的字符串\n\n\n() =&gt;{}\n使用箭头（=&gt;）声明函数，不用再书写 function 关键字 示例： const add = () =&gt;{ console.log(‘add’)}\n\n\nthis\n1、非箭头函数中的 this 指向函数的调用者 2、箭头函数中的 this 指向定义时所在的对象 3、全局作用域中 this 指向 window\n\n\n\n\n3、解构赋值\n\n\n\n名称\n描述\n\n\n\n\n[] = []\n数组的解构赋值 示例：let [a, b, c] = [1, 2, 3]; 可以从数组中提取值，按照对应位置，给左侧变量赋值\n\n\n{} = {}\n对象的解构赋值 示例：let { bar，foo } = { foo: ‘aaa’, bar: ‘bbb’ }; 按照对应的属性，给左侧的变量赋值，等号左边的两个变量的书写顺序，与等号右边两个同名属性的顺序可以不一致\n\n\n[] = “” ，{} = “”\n字符串的解构赋值，在解构前，字符串被转换成了一个类似数组的对象 （不常用，了解即可） 1、以数组的形式解构，const [a, b, c, d, e] = ‘hello’ 2、以对象的形式解构，let { 0: a } = ‘hello’\n\n\n\n\n4、剩余参数，展开运算符\n\n\n\n名称\n描述\n\n\n\n\n…arg\n将一个不定数量的参数表示为一个数组\n\n\n…\n将内容展开\n\n\n\n\n5、数据结构\n\n\n\n名称\n描述\n\n\n\n\nSet\n是一系列无序、没有重复值的集合\n\n\nMap\n是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键\n\n\n\n\n6、Set 和 Map 共有的方法和属性\n\n\n\n名称\n描述\n\n\n\n\nhas()\n判断该值是否为 Set/Map 的成员。\n\n\ndelete()\n删除某个成员\n\n\nclear()\n删除所有成员\n\n\nforEach()\n遍历每个成员\n\n\nsize\n返回 Set/Map 实例的成员总数\n\n\n\n\n7、Set 和 Map 实例的方法\n\n\n\n方法名\n描述\n\n\n\n\nadd()\nSet 实例的方法，添加成员\n\n\nset()\nMap 实例的方法，添加成员\n\n\nget()\nMap 实例的方法，获取成员\n\n\n\n\n8、遍历器\n\n\n\n名称\n描述\n\n\n\n\nIterator\n为各种不同的数据结构提供统一的访问机制\n\n\nfor…of\n遍历成员，for…of 循环可以使用的范围包括数组、 Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）\n\n\n\n\n9、数组的新增方法\n\n\n\n方法名称\n描述\n\n\n\n\nkeys()\n遍历索引\n\n\nvalues()\n遍历值\n\n\nentries()\n遍历索引和值\n\n\nincludes()\n判断数组中是否含某个成员（不常用，了解即可）\n\n\nArray.from()\n将其他数据类型转换为数组\n\n\nfind()\n返回第一个符合条件的数组成员\n\n\nfindIndex()\n返回第一个符合条件的数组成员的位置\n\n\n\n\n10、字符串的新增方法\n\n\n\n方法名称\n描述\n\n\n\n\nincludes()\n判断字符串中是否包含某些字符\n\n\npadStart()\n补全字符串的长度，用于头部补全（不常用，了解即可）\n\n\npadEnd()\n补全字符串的长度，用于尾部补全（不常用，了解即可）\n\n\ntrimLeft() ，trimStart()\n清除字符串头部的空格（不常用，了解即可）\n\n\ntrimEnd() ，trimRight()\n清除字符串尾部的空格（不常用，了解即可）\n\n\n\n\n11、对象的新增方法\n\n\n\n方法名称\n描述\n\n\n\n\nassign()\n合并对象\n\n\nObject.keys()\n返回一个数组，成员是键名\n\n\nObject.values()\n返回一个数组，成员是键值\n\n\nObject.entries()\n返回一个数组，成员是键名和键值\n\n\n\n\n","categories":["归档"],"tags":["前端开发"]},{"title":"2025-10-28-常用杂记","url":"/Arknight-notes/posts/40483.html","content":"综合查找：端口-&gt;进程-&gt;工作目录lsof -i :3001 | awk ‘NR&gt;1 {print $2}’ | xargs -I {} pwdx {} 2&gt;/dev/null\n或者更详细的版本lsof -i :3001 | awk ‘NR&gt;1 {print Extra close brace or missing open brace2}’ | while read pid; do   echo “PID: pid”  echo “工作目录: pid 2&gt;/dev/null)”  echo “命令: pid -o command= 2&gt;/dev/null)”  echo “—-“done\nlsof -ti:3001 | xargs kill -9\n","categories":["归档"],"tags":["日志"]},{"title":"2025-11-21-canvas设计项目杂记其二","url":"/Arknight-notes/posts/39691.html","content":"设计还原 Excalidraw 顶部栏工具样式\n\n\n\n\n工具\n对应代码操作\n\n\n\n\n选择工具 (select)\n1. 当点击画布上的元素时，在  onPointerDown  方法中会设置该元素为选中状态2. 当点击空白区域时，会清空选中状态3. 当拖动时，会移动元素位置\n\n\n手型工具 (hand)\n目前代码中没有实现手型工具的具体功能，仅在工具栏进行了切换\n\n\n矩形工具 (rect)\n1. 在  onPointerDown  中创建新的矩形元素2. 在  onPointerMove  中调整矩形大小3. 在  render  方法中使用  graphic.rect()  或  graphic.roundRect()  绘制矩形\n\n\n菱形工具 (diamond)\n代码中有定义但未实现具体功能，目前不会绘制菱形\n\n\n圆形工具 (circle)\n1. 在  onPointerDown  中创建新的圆形元素2. 在  onPointerMove  中调整圆形大小3. 在  render  方法中使用  graphic.ellipse()  绘制圆形\n\n\n箭头工具 (arrow)\n代码中有定义但未实现具体功能，目前不会绘制箭头\n\n\n直线工具 (line)\n代码中有定义但未实现具体功能，目前不会绘制直线\n\n\n铅笔工具 (pencil)\n代码中有定义但未实现具体功能，目前不会进行自由绘制\n\n\n文本工具 (text)\n代码中有定义但未实现具体功能，目前不会添加文本\n\n\n图像工具 (image)\n代码中有定义但未实现具体功能，目前不会插入图片\n\n\n橡皮擦工具 (eraser)\n代码中有定义但未实现具体功能，目前不会删除元素\n\n\n\n\n重构  Pixi_stageManager.ts我们需要做比较大的改动：\n\n引入  Viewport  并将其添加到  app.stage。\n所有的绘图元素（Graphics）现在都添加到  viewport  中，而不是  app.stage。\n根据当前工具（hand vs rect/select）来启用或禁用 Viewport 的拖拽插件。\n\n如何实现 Minimap（小地图）你提到了 Minimap，虽然代码量较大不便在此全部贴出，但我可以告诉你行业标准的实现思路。\n有了  pixi-viewport  和 Zustand Store，实现 Minimap 其实就是做一个数据映射\n1. 原理Minimap 本质上是一个独立的、微缩的视图。不要尝试去截取 Pixi Canvas 的图（性能太差）。你应该再画一遍，用简化的图形。\n2. 实现步骤A. 创建 Minimap 组件创建一个 React 组件，它固定在右下角。\nB. 坐标映射 (World -&gt; Minimap)假设你的 Minimap 大小是 200x150px。你需要计算当前所有元素的包围盒 (Bounding Box)：\n\nminX, minY: 最左上角的元素位置\nmaxX, maxY: 最右下角的元素位置\ncontentWidth = maxX - minX\nscale = minimapWidth / contentWidth\n\nC. 渲染内容因为我们已经在 Zustand Store 里存了  { type: ‘rect’, x: 100, y: 100 … }  这样的纯数据，所以 Minimap 不需要 PixiJS。直接用 HTML5   或 SVG 渲染即可！\ncodeTsx\n// 伪代码示例：Minimap SVG 实现&lt;svg width=\"200\" height=\"150\" viewBox={`${minX} ${minY} ${width} ${height}`}&gt;   {elements.map(el =&gt; (      &lt;rect x={el.x} y={el.y} width={el.width} height={el.height} fill=\"#ccc\" /&gt;   ))}   {/* 视口框：显示当前你正在看哪个区域 */}   &lt;rect     x={viewport.center.x - viewport.worldScreenWidth/2}     y={viewport.center.y - viewport.worldScreenHeight/2}     width={viewport.worldScreenWidth}     height={viewport.worldScreenHeight}     stroke=\"red\" fill=\"none\"   /&gt;&lt;/svg&gt;\n3. 双向绑定\nView -&gt; Map: 当主画布  viewport  移动 (moved  事件) 时，更新 Minimap 里的红框位置。\nMap -&gt; View: 当拖拽 Minimap 里的红框时，调用  stageManager.viewport.moveCenter(x, y)  来移动主画布。\n\n总结\n无限画布：使用  pixi-viewport  代替原生  app.stage  容器。\n手型工具：\n\n当  tool === ‘hand’  时，调用  viewport.drag()  启用拖拽。\n当  tool !== ‘hand’  时，viewport.plugins.pause(‘drag’)  暂停拖拽，以便进行绘图。\n\n\nMinimap：使用 SVG 或第二个轻量 Canvas，通过 Store 数据渲染所有元素的微缩版，并计算一个“视口矩形”覆盖在上面。\n\n\n改动说明\nupdateViewportState  逻辑变更：\n\n之前：hand  模式开启 drag，其他模式暂停 drag。\n现在：所有模式都开启 drag。\n普通模式：drag({ mouseButtons: ‘middle’ })。中键拖动画布，左键留给选择。\n手型模式：drag({ mouseButtons: ‘all’ })。左键或中键都可以拖动画布。\n\n\n\n\nonPointerDown  拦截：\n\n新增  if (e.button === 1) return。\n这样当用户按下中键时，Pixi_stageManager  的自定义逻辑（选择元素、创建元素）会被跳过，控制权完全交给  pixi-viewport  进行画布平移。\n\n\n默认行为阻止：\n\n在  initApp  中添加了  container.addEventListener(‘mousedown’, …)  来阻止中键点击时的默认滚动图标出现，体验更顺滑。\n\n\n\n现在，你可以在保持“选择工具”激活的情况下，直接按住鼠标中键来拖拽画布，释放中键后继续使用左键选择或移动元素。同时，左侧工具栏的“手型工具”和“空格键”快捷键依然有效（它们会把左键也变成拖拽）。\n“Rubber-band Selection” (框选)  和  “Transformer / Gizmo” (变换控制器)。对  Pixi_stageManager.ts  进行较大幅度的扩展。为了保持代码清晰，我们将逻辑分为两部分：\n\n框选逻辑：在空白处拖拽绘制蓝色半透明矩形，松开时计算碰撞。\n变换逻辑：选中元素时绘制 8 个控制点，拖拽控制点改变元素尺寸。\n\n以下是完整的实现方案。\n1. 核心逻辑修改思路我们需要引入一个新的图层概念（UI Layer），确保框选框和控制手柄永远画在元素之上。\n\n状态增加：增加  interactionMode  状态，区分  idle | panning | dragging (拖拽元素) | selecting (框选) | resizing (调整大小)。\nResize 算法：根据当前拖拽的是哪个角（如 Top-Left），反向计算  x, y, width, height。\n\n2. 更新  Pixi_stageManager.ts\n改用世界坐标系进行计算：\n\n通过  e.getLocalPosition(this.viewport)  获取鼠标在世界坐标系中的当前位置\n计算当前位置与起始位置的差值  dx  和  dy\n直接将这个差值应用到元素的位置上，无需考虑缩放因子\n更新起始位置为当前位置，为下次移动计算做准备\n\n\nStageManager 类├── 类属性定义模块│ ├── PIXI 应用和视口│ ├── 图层管理│ ├── 元素映射│ ├── 交互状态│ ├── 辅助图形│ └── 变换/拖拽相关数据├── 构造函数与初始化模块│ ├── 主构造函数│ │ ├── 应用初始化│ │ ├── 视口设置│ │ ├── 图层结构初始化│ │ ├── UI 元素初始化│ │ ├── 交互设置│ │ └── 状态订阅│ └── 应用初始化方法 (initApp)├── 视口管理模块│ └── 视口设置 (setupViewport)├── 渲染核心模块│ ├── 画布元素渲染 (renderElements)│ └── 变换控制器渲染 (renderTransformer)├── 交互逻辑模块│ ├── 交互设置 (setupInteraction)│ ├── 指针按下处理 (onPointerDown)│ ├── 手柄按下处理 (onHandleDown)│ ├── 指针移动处理 (onPointerMove)│ └── 指针抬起处理 (onPointerUp)├── 辅助函数模块│ ├── 获取手柄光标样式 (getCursorForHandle)│ ├── 更新视口状态 (updateViewportState)│ ├── 设置空格键状态 (setSpacePressed)│ ├── 更新光标 (updateCursor)│ └── 销毁方法 (destroy)\n\n修复了图像创建后没有立即渲染的问题。主要的修改包括：\n\n当图像纹理正在加载时，创建一个占位符图形（灰色矩形）立即显示在画布上，这样用户就能立即看到图像的位置和大小。\n在纹理加载完成后，更新纹理缓存并直接更新已存在的图形，而不是等待下一次重新渲染。\n移除了使用非空断言操作符（!）的代码，使类型检查更加安全。\n简化了图像渲染逻辑，确保在纹理加载完成前也能显示占位符。\n\n这些修改确保了图像元素在创建时能够立即显示（虽然是占位符），而不是完全不可见直到其他操作触发重新渲染。当图像纹理加载完成后，占位符会自动更新为实际的图像。\n图像加载机制详解1. 整体流程图像加载采用异步方式处理，主要分为以下几个步骤：\n\n检查缓存：首先检查纹理是否已经在缓存中存在\n加载纹理：如果不存在，则启动纹理加载过程\n显示占位符：在纹理加载期间，显示一个灰色占位符矩形\n更新显示：纹理加载完成后，将占位符替换为实际图像\n\n2. 核心组件typescript\nprivate spriteMap: Map&lt;string, PIXI.Graphics | HTMLText | PIXI.Sprite&gt; = new Map() private textureCache: Map&lt;string, PIXI.Texture&gt; = new Map() private loadingSet: Set&lt;string&gt; = new Set()\n\nspriteMap：存储所有已创建的图形对象（包括占位符和实际图像）\ntextureCache：缓存已加载的纹理，避免重复加载\nloadingSet：记录正在加载的 URL，防止重复发起加载请求\n\n3. 加载过程详解3.1 检查缓存typescript\nlet texture = this.textureCache.get(data.imageUrl)\n如果纹理已存在缓存中，直接使用，无需重新加载。\n3.2 防止重复加载typescript\nif (!this.loadingSet.has(data.imageUrl)) {   this.loadingSet.add(data.imageUrl)   // 开始加载 }\n通过 loadingSet 确保同一 URL 不会被重复加载。\n3.3 异步加载typescript\nPIXI.Assets.load(data.imageUrl)   .then((loadedTexture) =&gt; {     // 加载成功处理   })   .catch((err) =&gt; {     // 加载失败处理   })\n使用 PIXI 的资源加载器进行异步加载。\n3.4 占位符显示在纹理加载期间，创建一个灰色矩形作为占位符：\ntypescript\ngraphic = new PIXI.Graphics() graphic.rect(0, 0, data.width, data.height) graphic.fill({ color: 0xdddddd }) graphic.stroke({ width: 1, color: 0x999999 })\n3.5 加载完成后更新纹理加载完成后，立即替换占位符：\ntypescript\n// 替换占位符为真实图像 elementLayer.removeChild(graphic) graphic.destroy() // 创建新的Sprite const sprite = new PIXI.Sprite(loadedTexture) // 设置属性... elementLayer.addChild(sprite) this.spriteMap.set(id, sprite)\n4. 性能优化措施\n缓存机制：避免重复加载相同 URL 的图像\n防止重复请求：通过 loadingSet 避免对同一 URL 发起多次加载请求\n及时清理：元素移除时清理相关资源和引用\n立即更新：纹理加载完成后立即更新显示，无需等待其他操作\n\n5. 错误处理当图像加载失败时，会输出错误日志并从加载集合中移除 URL：\ntypescript\n.catch((err) =&gt; {   console.error('Failed to load asset:', err)   this.loadingSet.delete(data.imageUrl) })\n6. 资源清理当元素被移除时，会进行适当的资源清理：\n\n移除图形对象\n销毁不再使用的纹理\n清理相关引用和定时器\n\n这套机制确保了图像加载既高效又用户友好，在图像加载期间提供视觉反馈，并在加载完成后立即显示图像。\n\ntypes.ts: 增加了  initialElementsMap  和  initialGroupBounds  来存储多选时的初始状态。\nStageManagerCore.ts:\n\nonHandleDown: 现在会捕捉所有选中元素的快照，并计算初始的群组包围盒。\nonPointerMove: 重写了  resizing  逻辑。它不再单纯调整单个元素，而是先计算鼠标移动导致的新包围盒，计算出宽高的缩放比例，然后应用到所有选中元素上（包括坐标、宽高和内部点集）。\n\n\n\n这是一个典型的多选缩放问题。\n问题原因：在现有的  StageManagerCore.ts  中，onPointerMove  的  resizing  逻辑只处理了单体元素 (this.state.currentId) 的更新。当你选中多个元素时，虽然  TransformerRenderer  画出了一个大的包围盒，但交互逻辑实际上只在操作第一个被选中的元素，导致其他元素不动，或者计算逻辑完全错误（因为没有基于群组包围盒进行整体缩放），从而出现“锚点脱离”和“大小失控”的现象。\n解决方案：我们需要修改  StageManagerCore.ts  和  types.ts。\n\n状态存储：在  onHandleDown  时，不再只存储单个元素的初始状态，而是需要计算并存储整个选区的初始包围盒 (Group Bounds)  以及所有被选元素的初始状态。\n移动计算：在  onPointerMove  时，根据鼠标位移计算出新的群组包围盒，得出宽高的缩放比例 (scaleX, scaleY)，然后根据这个比例更新所有被选元素的坐标和尺寸。\n\n\n\n使用 Command Pattern：\n\n实现了基本的命令接口  Command\n提供了  SnapshotCommand  类处理完整的状态快照\n使用两个栈管理撤销和重做操作\n\n\n使用 structuredClone 进行快照：\n\n对整个 store 状态进行深克隆\n保证状态回退时不会出现引用问题\n\n\n自动捕获状态变更：\n\n通过包装 Zustand 的 set 方法自动捕获所有状态变更\n无需手动在每个操作后调用记录方法\n\n\n防止递归记录：\n\n使用锁定机制避免在执行撤销/重做操作时记录新命令\n\n\n键盘快捷键支持：\n\n支持标准的 Ctrl+Z 撤销和 Ctrl+Y/Ctrl+Shift+Z 重做\n\n\n\n这种实现方式简单有效，能够满足大部分撤销/重做需求，并且与现有的项目架构很好地集成。\n\n使用  structuredClone() API：\n\n我们使用浏览器内置的  structuredClone()  函数来创建状态对象的深拷贝\n这个 API 可以创建对象的完整副本，包括嵌套的对象和数组\n\n\n只克隆数据部分：\n\n由于 Zustand store 状态既包含数据属性也包含函数属性，而  structuredClone()  无法克隆函数，所以我们需要分离这两部分\n使用解构赋值语法排除所有函数属性：javascriptconst {    setTool, addElement, updateElement, removeElements, setSelected,   setEditingId, copyElements, pasteElements, undo, redo, canUndo, canRedo,   ...dataOnlyState  } = state;\n这样  dataOnlyState  就只包含纯数据属性，如  tool、elements、selectedIds  等\n\n\n在撤销/重做系统中的应用：\n\n在每次状态更改前后捕获快照\n将这些快照传递给  SnapshotCommand  来记录状态变化\n当用户执行撤销或重做操作时，可以从这些快照恢复到之前的状态\n\n\n\n这种机制确保我们可以准确地跟踪和恢复画布状态的变化历史，同时避免了尝试克隆不可序列化函数的错误。\n你提到的问题非常准确。目前的实现方式确实会在创建选框等操作过程中记录每一步的状态变化，这会导致撤销/重做系统产生过多不必要的快照。\n对于绘图应用来说，用户期望的行为通常是：\n\n在开始绘制时标记操作起点\n在绘制结束时才生成一个完整的撤销点\n而不是记录过程中的每个微小变化\n\n针对这个问题，常见的解决方案有几种：\n\n批量操作机制：允许临时锁定 undo/redo 系统，在一系列连续操作完成后再解锁并记录最终状态。\n防抖动机制：在快速连续的操作中，只记录特定时间间隔的状态。\n操作分组：将相关的操作归为一组，作为一个整体进行撤销/重做。\n\n考虑到你们项目的情况，我觉得第一种方案比较适合，即增加开始和结束批量操作的方法。\n不过目前的实现也有它的优势，就是可以精确还原到任意一个中间状态。在实际使用中可以根据用户体验需求来权衡是否需要优化这一点。\n添加一个防抖动机制。这样可以避免在连续操作（如绘制矩形）过程中产生过多的快照。\n更好的方法是在绘制开始时记录初始状态，在绘制结束时记录最终状态，形成一个完整的操作单元。让我来实现这个机制：\n问题分析你当前的代码存在两个主要问题：\n\nMiddleware 过于激进：subscribeWithSelector  会拦截每一次  set  调用。当你拖拽一个矩形移动 100px 时，会触发约 60 次  set，导致历史记录里塞满了 60 个微小的移动快照。这会导致内存爆炸且撤销体验极差（按一次撤销只动 1px）。\n逻辑分散：你试图在  UndoRedoManager  里用计时器（setTimeout）来判断什么时候结束创建，这非常不稳定。\n\n核心思路：Excalidraw 模式Excalidraw 的核心逻辑是：\n\nPointerDown (开始)：记录当前画布的快照（作为“旧状态”）。\nPointerMove (过程)：疯狂更新 Store（瞬时状态），但不推入历史记录。\nPointerUp (结束)：对比当前状态和旧状态。如果有变化，将“旧状态”和“新状态”封装成一个命令，推入历史栈。\n\n\n重构方案我们将移除 Store 中的自动拦截中间件，改为由交互层 (StageManagerCore)  主动控制历史记录的时机。\n1. 重写  UndoRedoManager.ts (简化版)不再需要复杂的计时器和模式判断，回归纯粹的栈管理。\n\n移动（Move/Drag）操作丢失：\n\n在  onPointerDown  中，当检测到点击元素（dragging  模式）时，你调用了  undoRedoManager.lock()。\n在  onPointerMove  中，元素位置被更新，但因为处于锁定状态，canvasStore  的中间件忽略了这些更新（这是正确的，防止产生大量快照）。\n关键缺漏：在  onPointerUp  中，当  mode === ‘dragging’  结束时，代码只执行了  unlock()，没有创建并执行任何 Command。\n结果：Store 中的状态变成了 B，但撤销栈里什么都没记。当你后续进行 Resize 操作（B -&gt; C）并记录了 Command 后，一旦撤销，Resize Command 会把状态恢复到 B。再次撤销时，由于 Move 操作没记录，状态无法回到 A，或者表现为“跳过”了某些步骤。\n\n\nResize 操作的 “Redo 直接到 B” 现象：\n\n这通常是由于历史栈的不连续性造成的。如果 “Move A-&gt;B” 没被记录，那么栈里可能是  [Create(A), Resize(B-&gt;C), Resize(C-&gt;D)]。\n当你撤销  Resize(C-&gt;D) -&gt; 变回 C。\n撤销  Resize(B-&gt;C) -&gt; 变回 B。\n此时再撤销，会直接遇到  Create(A)  或空栈，导致状态突变。\n此外，如果 Resize 的逻辑只依赖于  initialMap，而没有正确处理连续操作间的状态同步，也可能导致此问题。\n\n\n\n解决方案我们需要做一个通用的  UpdateElementCommand（替换或扩展  ResizeCommand），并在  StageManagerCore  的  onPointerUp  中，为移动（Dragging）和调整大小（Resizing）都创建并执行这个命令。\n时间点操作画布状态（实际）命令 ID说明22:40:08创建矩形 A有 A808615第一次画矩形22:40:25创建矩形 B有 A + B825552第二次画矩形22:40:40撤销（Undo）只剩 A825552撤销“添加 B”22:40:47再次撤销（Undo）画布完全为空808615撤销“添加 A”22:41:48重做（Redo）第一次出现 A（但没看到（可能大小为0位置也不对））808615执行“添加 A”的命令22:41:49重做（Redo）第二次出现 A + B825552执行“添加 B”的命令\n第一次重做“没反应”第二次重做突然正常\n修复这个问题\nModel\nThoughts\nExpand to view model thoughts\nchevron_right\n这是一个非常经典的 Canvas 编辑器撤销/重做状态不同步问题。\n问题分析现象：\n\n创建矩形 A（此时宽/高为 0）。\n\n拖拽绘制矩形 A（宽/高变为 100）。\n\n撤销。\n\n重做 -&gt; 矩形 A 虽然出现了，但大小可能为 0 或者不可见。\n\n\n原因：\n\n当你在 onPointerDown 中调用 state.addElement 时，Zustand 的中间件（或监听器）立即捕获了状态变更并创建了一个 SnapshotCommand。\n\n关键点：此时创建的 SnapshotCommand 中记录的 nextState 是元素刚创建时的状态（即 width: 0, height: 0）。\n\n随后你调用了 undoRedoManager.lock()。\n\n在 onPointerMove 和 onPointerUp 过程中，虽然元素的属性更新了，但由于管理器被 Locked，且之前的 SnapshotCommand 已经生成完毕，历史记录中存储的“最终状态”仍然是宽高为 0 的状态。\n\n当你执行 Undo 再 Redo 时，它恢复的是历史记录中的 nextState (宽高为 0)，导致元素看起来“没反应”或不可见。\n\n\n解决方案我们需要在绘制结束（onPointerUp）时，更新历史栈顶那个“创建命令”的 nextState，将其替换为绘制完成后的最终状态。\n以下是修复代码：\n1. 修改 UndoRedoManager.ts我们需要给 SnapshotCommand 和 UndoRedoManager 添加更新状态的能力。\ncodeTypeScript\n// --- UndoRedoManager.ts ---// ... importsexport class UndoRedoManager {  // ... existing code ...  // [新增] 用于在操作结束时更新栈顶命令的最终状态  updateLatestSnapshot(nextState: any) {    if (this.undoStack.length === 0) return    const lastCommand = this.undoStack[this.undoStack.length - 1]        // 确保只更新 SnapshotCommand 类型的命令    if (lastCommand instanceof SnapshotCommand) {      lastCommand.updateNextState(nextState)      logger.debug('[UndoRedoManager] 已更新最近一次快照的最终状态')    }  }}// ... existing code ...export class SnapshotCommand implements Command {  // ... existing properties ...  constructor(prevState: any, nextState: any, description: string) {    // ... existing constructor code ...  }  // [新增] 更新 nextState 的方法  updateNextState(nextState: any) {    this.nextState = nextState    logger.debug(`[SnapshotCommand] 命令 ID: ${this.commandId} 的最终状态已更新`)  }  // ... execute, undo, redo ...}\n2. 修改 StageManagerCore.ts在 onPointerUp 的绘制结束逻辑中，调用刚刚添加的 updateLatestSnapshot 方法。\ncodeTypeScript\n// --- StageManagerCore.ts ---// ... imports ... // 确保引入了 storeimport { useStore } from '@/stores/canvasStore' export class StageManagerCore {  // ... existing code ...  private onPointerUp = () =&gt; {    // 触发防抖检查    this.triggerDebounceSnapshot()    const state = useStore.getState()        // ... erasing logic ...    // ... selecting logic ...    // === 修复的核心位置：Drawing 模式结束 ===    if (this.state.mode === 'drawing' &amp;&amp; this.state.currentId) {      const el = state.elements[this.state.currentId]      if ((el.type === 'pencil' || el.type === 'line' || el.type === 'arrow') &amp;&amp; el.points) {        // ... 计算 points 的逻辑 ...        state.updateElement(this.state.currentId, {          x: newX,          y: newY,          width: maxX - minX,          height: maxY - minY,          points: newPoints,        })      }            // [新增] 修复 Undo/Redo Bug      // 在解锁前或解锁后均可，关键是获取当前的最新 State（包含了最终宽高的 State）      // 并更新掉 onPointerDown 时记录的那个“0宽高”的快照      undoRedoManager.updateLatestSnapshot(useStore.getState())      // 解锁撤销/重做管理器      undoRedoManager.unlock()      console.log('[StageManager] 解锁撤销/重做管理器')    }    // ... dragging logic ...    // ... resizing logic ...        // ... cleanup ...  }}\n为什么这样做有效？\nDown: 创建元素(0x0) -&gt; 触发快照 -&gt; 锁定管理器。栈顶命令记录为：Prev: 无, Next: 元素(0x0)。\n\nMove: 更新元素(100x100) -&gt; 管理器锁定中，不产生新命令。\n\nUp: 更新元素最终位置 -&gt; 调用 updateLatestSnapshot。 栈顶命令变为：Prev: 无, Next: 元素(100x100)。\n\nUndo: 回退到 Prev (无)。\n\nRedo: 前进到 Next (元素 100x100)。现在元素可见了！\n\n\n","categories":["归档"]},{"title":"2025-11-22-canvas状态管理杂记其三","url":"/Arknight-notes/posts/15704.html","content":"撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：\n\n快照命令（SnapshotCommand）：\n\n用于记录整个画布状态的变化\n通常用于添加元素、删除元素等较大范围的操作\n保存完整的状态快照\n\n\n更新元素命令（UpdateElementCommand）：\n\n用于记录特定元素的属性变化\n主要用于拖拽移动和调整大小操作\n只保存相关元素的特定属性变化\n\n\n\n操作序列和撤销栈状态变化初始状态撤销栈：空 重做栈：空\n1. 创建元素A当创建元素A时，系统会生成一个快照命令，记录整个画布状态的变化。\n撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：空\n2. 移动A到一个位置当移动元素A时，系统会生成一个更新元素命令（UpdateElementCommand），只记录A元素位置的变化。\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：空\n3. 创建元素B当创建元素B时，系统会生成另一个快照命令，记录添加B元素后的状态。\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：空\n4. 缩放B到一个位置当缩放元素B时，系统会生成一个更新元素命令，记录B元素尺寸和位置的变化。\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：空\n5. 移动B到一个位置当再次移动元素B时，系统会生成另一个更新元素命令，记录B元素位置的新变化。\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5) 重做栈：空\n执行撤销操作时的状态变化第一次撤销（移动B操作）\n从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB\n执行该命令的undo()方法，将B元素恢复到缩放后的位置\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4) 重做栈：[UpdateElementCommand_MoveB] (大小: 1)\n第二次撤销（缩放B操作）\n从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB\n执行该命令的undo()方法，将B元素恢复到刚创建时的尺寸和位置\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)\n第三次撤销（创建B操作）\n从撤销栈弹出最后一个命令：SnapshotCommand_B\n执行该命令的undo()方法，将整个画布状态恢复到创建B之前的状态（即只包含A元素的状态）\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)\n第四次撤销（移动A操作）\n从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA\n执行该命令的undo()方法，将A元素恢复到初始位置\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A] (大小: 1) 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)\n第五次撤销（创建A操作）\n从撤销栈弹出最后一个命令：SnapshotCommand_A\n执行该命令的undo()方法，将整个画布状态恢复到初始状态（空画布）\n将该命令推入重做栈\n\n撤销栈：空 重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)\nundoRedoManager.lock() 锁定管理器\n\nredo问题\n\n状态快照不完整：当创建元素时，状态快照可能在元素完全初始化之前就被捕获了，导致元素的width、height等属性为默认值（可能是0）。\n\n引用问题：虽然使用了深拷贝，但是在某些情况下，元素对象可能在快照创建后又被修改，导致快照中的数据不是预期的值。\n\n异步更新问题：元素创建和状态更新之间可能存在异步延迟，导致快照捕捉到了中间状态而非最终状态。\n\n\n需要确保在创建状态快照时，所有元素都已经完全初始化，并且使用可靠的方法进行深拷贝。\n修复当用户执行 Undo 后再 Redo 时，恢复的是最初 width:0, height:0 的状态，导致元素不可见的问题，修复日志里“type: ‘未知操作’” 和 “重做无效”的问题，在绘制结束（onPointerUp）时，更新历史栈顶那个“创建命令”的 nextState，将其替换为绘制完成后的最终状态\n\n元素移动（拖拽）实现元素的移动主要在 StageManagerCore.ts 文件中实现：\n\n开始拖拽：\n\n在 onPointerDown 方法中检测到点击的是已选中的元素时，将模式设置为 dragging\n记录所有选中元素的初始状态到 dragInitialStates 中\n\n\n拖拽过程中：\n\n在 onPointerMove 方法中，当 mode 为 dragging 时，计算位移并更新元素位置\n通过调用 state.updateElement(id, { x: el.x + dx, y: el.y + dy }) 来更新元素坐标\n\n\n结束拖拽：\n\n在 onPointerUp 方法中处理拖拽结束逻辑\n创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中\n\n\n\n元素缩放（调整大小）实现元素的缩放也在 StageManagerCore.ts 文件中实现：\n\n开始缩放：\n\n在 onHandleDown 方法中处理控制点按下事件\n将模式设置为 resizing\n记录所有选中元素的初始状态到 resizeInitialStates 和 initialElementsMap 中\n计算初始包围盒并存储在 initialGroupBounds 中\n\n\n缩放过程中：\n\n在 onPointerMove 方法中，当 mode 为 resizing 时处理缩放逻辑\n对于普通元素，基于初始包围盒和鼠标位移重新计算元素的位置和大小\n对于线条和箭头等特殊元素，单独处理端点的拖拽\n\n\n结束缩放：\n\n在 onPointerUp 方法中处理缩放结束逻辑\n创建 UpdateElementCommand 命令并将其添加到撤销/重做管理器中\n\n\n\n关键类和文件\nStageManagerCore.ts - 核心逻辑实现\nTransformerRenderer.ts - 渲染选中元素的控制手柄\nUpdateElementCommand.ts - 撤销/重做命令实现\nUndoRedoManager.ts - 撤销/重做管理器\n\n总的来说，元素的移动和缩放操作都是通过 StageManagerCore 类统一管理和处理的，该类负责监听鼠标事件并根据当前模式执行相应的操作。\n实现元素旋转功能需要涉及三个主要部分的修改：\n\n数据模型与状态定义：支持 rotation 属性和旋转时的临时状态。\n\n交互逻辑 (Math)：处理单个元素旋转和多选组的旋转（组旋转需要处理“公转”和“自转”）。\n\n渲染器支持：虽然这里主要改 StageManagerCore，但你需要确保 TransformerRenderer 能渲染出旋转手柄（通常位于选中框顶部的延长线上）。\n\n\n以下是具体的实现步骤和代码修改。\n第一步：修改类型定义在 types.ts 或 StageManagerCore.ts 的状态定义中，增加旋转相关的临时状态。\ncodeTypeScript\n// 在 StageManagerState 接口中添加：export interface StageManagerState {  // ... 原有属性  mode: 'idle' | 'dragging' | 'resizing' | 'selecting' | 'drawing' | 'erasing' | 'rotating'; // [修改] 添加 rotating  // [新增] 旋转相关状态  rotationInitialStates: Record&lt;string, {     x: number;     y: number;     rotation: number;     cx: number; // 元素中心点 x    cy: number; // 元素中心点 y  }&gt; | null;  rotationCenter: { x: number; y: number } | null; // 旋转中心（群组中心或单元素中心）  startRotationAngle: number; // 鼠标按下时的初始角度}\n第二步：实现旋转数学逻辑 (辅助方法)在 StageManagerCore 类中添加一个用于计算旋转后坐标的辅助方法。\ncodeTypeScript\n// 在 StageManagerCore 类中添加/** * 计算点绕中心旋转后的新坐标 * @param x 点的 x * @param y 点的 y * @param cx 中心点 x * @param cy 中心点 y * @param angle 旋转角度 (弧度) */private rotatePoint(x: number, y: number, cx: number, cy: number, angle: number) {  const cos = Math.cos(angle);  const sin = Math.sin(angle);  const nx = (cos * (x - cx)) - (sin * (y - cy)) + cx;  const ny = (sin * (x - cx)) + (cos * (y - cy)) + cy;  return { x: nx, y: ny };}\n第三步：处理 onHandleDown (开始旋转)你需要修改 onHandleDown 方法。首先，你需要在 TransformerRenderer 中定义一个 ID 为 rotate 的手柄。当捕获到该手柄时，初始化旋转状态。\ncodeTypeScript\n// 修改 onHandleDown 方法private onHandleDown = (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1' | 'rotate', elementId: string) =&gt; {  this.triggerDebounceSnapshot();  e.stopPropagation();  // === [新增] 旋转逻辑分支 ===  if (handle === 'rotate') {    this.state.mode = 'rotating';    this.state.currentId = elementId;        const state = useStore.getState();    const { elements, selectedIds } = state;    const mousePos = e.getLocalPosition(this.viewport);    // 1. 计算旋转中心（选中元素的包围盒中心）    const bounds = this.getSelectionBounds(selectedIds, elements);    if (!bounds) return;        const centerX = bounds.x + bounds.width / 2;    const centerY = bounds.y + bounds.height / 2;    this.state.rotationCenter = { x: centerX, y: centerY };    // 2. 计算鼠标起始角度（相对于中心点）    this.state.startRotationAngle = Math.atan2(mousePos.y - centerY, mousePos.x - centerX);    // 3. 记录所有选中元素的初始状态    const initialMap: Record&lt;string, any&gt; = {};    selectedIds.forEach(id =&gt; {      const el = elements[id];      if (el) {        initialMap[id] = {          x: el.x,          y: el.y,          width: el.width,          height: el.height,          rotation: el.rotation || 0, // 确保你的 CanvasElement 类型里有 rotation          // 记录元素自身的中心点，方便后续计算          cx: el.x + el.width / 2,          cy: el.y + el.height / 2        };      }    });    this.state.rotationInitialStates = initialMap;    undoRedoManager.lock();    console.log('[StageManager] 开始旋转操作');    return;  }  // ... 原有的 resizing 逻辑保持不变 ...  this.state.mode = 'resizing';  // ...}\n第四步：处理 onPointerMove (旋转进行中)修改 onPointerMove，增加 rotating 模式的处理逻辑。\ncodeTypeScript\n// 修改 onPointerMove 方法private onPointerMove = (e: PIXI.FederatedPointerEvent) =&gt; {  this.triggerDebounceSnapshot();  if (this.state.mode === 'idle') return;    const currentPos = e.getLocalPosition(this.viewport);  const state = useStore.getState();  // ... selecting, dragging, resizing 等现有逻辑 ...  // === [新增] 旋转逻辑 ===  if (this.state.mode === 'rotating' &amp;&amp; this.state.rotationInitialStates &amp;&amp; this.state.rotationCenter) {    const { x: cx, y: cy } = this.state.rotationCenter;        // 1. 计算当前鼠标角度    const currentAngle = Math.atan2(currentPos.y - cy, currentPos.x - cx);        // 2. 计算旋转增量（当前角度 - 起始角度）    const deltaAngle = currentAngle - this.state.startRotationAngle;    // 3. 更新每一个选中元素    state.selectedIds.forEach(id =&gt; {      const initEl = this.state.rotationInitialStates![id];      if (!initEl) return;      // A. 计算新的自转角度      const newRotation = initEl.rotation + deltaAngle;      // B. 计算新的位置 (公转)      // 将元素的中心点 (initEl.cx, initEl.cy) 绕着 组中心 (cx, cy) 旋转 deltaAngle      const newCenter = this.rotatePoint(initEl.cx, initEl.cy, cx, cy, deltaAngle);      // C. 根据新的中心点反推 x, y (x = center.x - width/2)      const newX = newCenter.x - initEl.width / 2;      const newY = newCenter.y - initEl.height / 2;      // D. 更新 Store      state.updateElement(id, {        x: newX,        y: newY,        rotation: newRotation      });    });    return;  }  // ... drawing 逻辑 ...}\n第五步：处理 onPointerUp (结束旋转并记录历史)在 onPointerUp 中处理旋转结束，生成 Undo/Redo 命令。\ncodeTypeScript\n// 修改 onPointerUp 方法private onPointerUp = () =&gt; {  this.triggerDebounceSnapshot();  const state = useStore.getState();  // ... erasing, selecting, drawing, dragging 等逻辑 ...  // === [新增] 旋转结束逻辑 ===  if (this.state.mode === 'rotating' &amp;&amp; this.state.rotationInitialStates) {    console.log('[StageManager] 结束旋转操作');    undoRedoManager.unlock();    const operations: any[] = [];    Object.entries(this.state.rotationInitialStates).forEach(([id, initialAttrs]) =&gt; {      const finalElement = state.elements[id];      if (!finalElement) return;      // 获取最终状态      const finalAttrs = {        x: finalElement.x,        y: finalElement.y,        rotation: finalElement.rotation || 0      };      // 检查是否有变化 (对比 x, y, rotation)      // 注意：即使只是自转，x/y 也可能因为精度问题微变，或者如果是多选旋转，x/y 必然变      const hasChanged =         Math.abs(initialAttrs.x - finalAttrs.x) &gt; 0.01 ||        Math.abs(initialAttrs.y - finalAttrs.y) &gt; 0.01 ||        Math.abs(initialAttrs.rotation - finalAttrs.rotation) &gt; 0.001;      if (hasChanged) {        operations.push({          id,          initialAttrs: { x: initialAttrs.x, y: initialAttrs.y, rotation: initialAttrs.rotation },          finalAttrs        });      }    });    if (operations.length &gt; 0) {      const rotateCommand = new UpdateElementCommand(operations, '旋转元素');      undoRedoManager.executeCommand(rotateCommand);    }  }  // ... resizing 逻辑 ...    // 清理状态  this.state.mode = 'idle';  this.state.currentId = null;  this.state.activeHandle = null;  this.state.initialElementState = null;  this.state.initialElementsMap = null;  this.state.initialGroupBounds = null;  this.state.resizeInitialStates = null;  this.state.dragInitialStates = null;  // [新增] 清理旋转状态  this.state.rotationInitialStates = null;  this.state.rotationCenter = null;}\n关键点说明\n公转与自转：\n\n如果是单个元素被选中，计算出的 rotationCenter 就是该元素中心，公式依然成立（点绕自己旋转位置不变，只有 rotation 属性在变）。\n\n如果是多个元素，它们会围绕整体的包围盒中心（Group Center）进行旋转，这实现了符合直觉的群组旋转效果。\n\n\n\nCanvasElement 类型： 请确保你的 CanvasElement 接口定义里加入了 rotation?: number 字段。 同时，在渲染器 ElementRenderer 中，渲染 Sprite 或 Container 时，需要应用这个 rotation：\n codeTypeScript\n // 在 ElementRenderer.ts 中// Pixi 的 rotation 是以弧度为单位，且默认绕左上角旋转。// 为了让元素绕中心旋转，通常做法是：// 1. 设置 anchor 为 0.5 (Sprite) 或 pivot 为 width/2, height/2 (Graphics/Container)// 2. 将 position 设置为 x + width/2, y + height/2// 或者保持现有逻辑 (x,y在左上角)，但渲染时做矩阵变换。// 推荐做法（在 renderElements 循环中）：elementContainer.rotation = element.rotation || 0;// 注意：如果单纯设置 rotation，它会绕着 (x, y) 即左上角旋转。// 如果要绕中心旋转，需要设置 pivot:elementContainer.pivot.set(element.width / 2, element.height / 2);elementContainer.position.set(element.x + element.width / 2, element.y + element.height / 2);\n 注意：如果你修改了渲染器的 pivot/position 逻辑，可能会影响到上面的 onPointerMove 里的坐标计算逻辑。我上面给出的 StageManagerCore 代码是基于 x, y 始终代表左上角坐标 这一假设编写的（这是最通用的做法）。只要渲染器能正确根据左上角坐标 + 旋转角度绘制出绕中心旋转的图形即可。\n\nTransformerRenderer： 你需要去 TransformerRenderer 里添加绘制一个连接到包围盒顶部的线和小圆圈，并给这个小圆圈设置 label = ‘handle:rotate’ 或者在事件传递时传出 rotate 类型，以便 onHandleDown 能识别。\n\n\n在当前的 StageManagerCore.ts 代码中，关于组（Group）的缩放（Resizing）逻辑存在几个显著的问题。这些问题会导致嵌套组操作失效、视觉样式错乱以及撤销/重做数据不一致。\n以下是具体的问题分析及解决方案：\n1. 缺乏递归支持（不支持嵌套组）问题描述：代码中处理组缩放时，只遍历了当前组的一级子元素（actualGroupElement.children.forEach）。如果组内包含了另一个组（嵌套组），内部的组会被移动和缩放，但内部组的子元素（孙子节点）完全不会被处理。\n后果：缩放一个包含组的组时，最内层的元素会“留在原地”或大小不变，导致布局彻底崩坏。\n代码位置：onPointerMove 和 onPointerUp 中的 if (initEl.type === ‘group’) 块。\n修复方案：需要提取一个递归函数来处理子元素的更新。\ncodeTypeScript\n// 伪代码示例：递归更新逻辑private updateGroupChildren recursively(  groupId: string,   scaleX: number,   scaleY: number,   groupNewX: number,   groupNewY: number,   groupInitState: CanvasElement) {  const group = this.state.initialElementsMap[groupId];  // 遍历子元素  group.children.forEach(childId =&gt; {    const childInit = this.state.initialElementsMap[childId];        // 1. 计算子元素新位置/大小 (保持现有逻辑)    // ... Math ...        // 2. 更新 Store    state.updateElement(childId, newAttrs);        // 3. 关键：如果子元素也是组，递归调用    if (childInit.type === 'group') {       this.updateGroupChildren_recursively(childId, scaleX, scaleY, newChildX, newChildY, childInit);    }  });}\n2. 样式属性未跟随缩放（文字和描边）问题描述：当前的缩放逻辑只计算了 x, y, width, height 和 points。但是，文字的 fontSize 和形状的 strokeWidth（描边宽度）没有被缩放。\n后果：\n\n缩小： 组被缩得很小时，文字依然巨大（溢出），描边依然很粗（变成一团色块）。\n\n放大： 组被放很大时，文字显得很小，描边显得极细。\n\n\n修复方案：在计算子元素更新时，加入样式缩放。通常取 scaleX 和 scaleY 的平均值或最小值作为字体/描边的缩放倍率。\ncodeTypeScript\n// 在 onPointerMove 的子元素循环中const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;const updatePayload: any = {  x: newChildX,  y: newChildY,  width: newChildW,  height: newChildH,};// [修复] 缩放字体if (childInitEl.fontSize) {  updatePayload.fontSize = childInitEl.fontSize * avgScale;}// [修复] 缩放描边if (childInitEl.strokeWidth) {  updatePayload.strokeWidth = childInitEl.strokeWidth * avgScale;}\n3. 旋转元素的非等比缩放问题（数学偏差）问题描述：当前的逻辑是基于轴对齐包围盒 (AABB) 的比例来计算子元素位置的：newChildX = finalElX + childRelX * finalElW\n如果组内的某个子元素本身带有旋转角度 (rotation !== 0)，且用户进行了非等比缩放（例如只拉长宽度，不拉高度）：\n\n简单地改变旋转元素的 width 和 height 会导致图形变形（圆变椭圆是预期的，但旋转的矩形会变成菱形/切变，而 Canvas/Pixi 的 width/height 属性通常不支持切变，只会重置包围盒）。\n\n元素的位置计算会发生漂移，因为旋转后的局部坐标系和组的世界坐标系不再对齐。\n\n\n后果：如果组内有旋转过的元素，拉伸组会导致这些元素“飘”出正确的位置，或者形状扭曲方式不符合直觉。\n解决方案（复杂）：这是一个复杂的图形学问题。简单的解决方案是：当组内存在旋转元素时，强制锁定纵横比，禁止非等比缩放；或者在非等比缩放时，不改变子元素的旋转角度，只改变位置（这会导致视觉上的分离）。\n4. 撤销/重做 (Undo/Redo) 记录不完整问题描述：在 onPointerUp 中，你手动构建了 UpdateElementCommand。与问题 1 类似，这里也只处理了一层子元素。\ncodeTypeScript\n// 原代码if (finalElement.type === 'group') {  const groupElement = finalElement as GroupElement;  groupElement.children.forEach(childId =&gt; {     // 只记录了一层子元素  })}\n后果：如果你缩放了一个嵌套组，然后点击撤销：\n\n最外层组恢复大小。\n\n中间层组恢复大小。\n\n最内层元素保持缩放后的大小/位置。 导致撤销操作“损坏”了画布状态。\n\n\n修复方案：同样需要递归地收集所有子孙节点的 initialAttrs 和 finalAttrs 并推入 operations 数组。\n5. 翻转处理的潜在 Bug问题描述：代码中有处理翻转的逻辑：\ncodeTypeScript\nif (finalR &lt; finalL) { [finalL, finalR] = [finalR, finalL] }\n这保证了 Group 的包围盒始终为正。但是，计算子元素位置的 scaleX 会变成负数吗？const scaleX = … newBoundsW / initBounds.width因为你手动交换了 L 和 R，newBoundsW 永远是正的，所以 scaleX 永远是正的。\n后果：当你把右边的手柄拖到左边（翻转）时，组的框会变正，但内部的子元素不会镜像翻转，它们只会挤压到一起然后再变宽（仿佛没有翻转过一样），或者位置计算错误。\n修复方案：不应该手动交换 finalL 和 finalR 来计算 scale。应该允许 newBoundsW 为负数（或者手动标记 flipX），从而算出负的 scaleX。PixiJS 支持负的 scale.x，但你的数据模型是用 width/height (通常为正) 来驱动的。\n\n如果数据模型只允许正宽高：你需要检测翻转，并在计算子元素位置时，用 1 - childRelX 来替代 childRelX（如果是水平翻转）。\n\n\n总结与建议代码为了修复最严重的递归和样式问题，建议重构 onPointerMove 和 onPointerUp 的相关逻辑。\n建议在 Class 内部增加一个通用的递归处理方法：\ncodeTypeScript\n// 辅助方法：递归获取所有需要更新的子节点状态private getGroupResizeUpdates(  groupId: string,  scaleX: number,  scaleY: number,  // 组的新位置  groupX: number,  groupY: number,  // 组的原始尺寸（用于计算相对位置）  groupInitX: number,  groupInitY: number,  groupInitW: number,  groupInitH: number,  elementsSnapshot: Record&lt;string, any&gt; // 传入 initialElementsMap): Record&lt;string, Partial&lt;CanvasElement&gt;&gt; {    const updates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; = {};  const groupEl = elementsSnapshot[groupId] as GroupElement;  if (!groupEl || !groupEl.children) return updates;  groupEl.children.forEach(childId =&gt; {    const childInit = elementsSnapshot[childId];    if (!childInit) return;    // 1. 计算相对比例    const relX = (childInit.x - groupInitX) / groupInitW;    const relY = (childInit.y - groupInitY) / groupInitH;    const relW = childInit.width / groupInitW;    const relH = childInit.height / groupInitH;    // 2. 计算新属性    const newX = groupX + relX * (groupInitW * scaleX);    const newY = groupY + relY * (groupInitH * scaleY);    const newW = childInit.width * scaleX;    const newH = childInit.height * scaleY;        // 字体和描边缩放 (取平均值)    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;    const childUpdate: any = {      x: newX,      y: newY,      width: newW,      height: newH    };    if (childInit.points) {      childUpdate.points = childInit.points.map((p: number[]) =&gt; [p[0] * scaleX, p[1] * scaleY]);    }    if (childInit.fontSize) {      childUpdate.fontSize = childInit.fontSize * avgScale;    }    if (childInit.strokeWidth) {      childUpdate.strokeWidth = childInit.strokeWidth * avgScale;    }    updates[childId] = childUpdate;    // 3. 递归：如果子元素也是组，基于子元素的新状态继续计算孙子元素    if (childInit.type === 'group') {      const nestedUpdates = this.getGroupResizeUpdates(        childId,        scaleX, // 传递累积缩放或保持当前缩放，视逻辑而定。这里简化为直接传递，因为我们是基于最外层组计算的        scaleY,        newX,        newY,        childInit.x,        childInit.y,        childInit.width,        childInit.height,        elementsSnapshot      );      Object.assign(updates, nestedUpdates);    }  });  return updates;}\n然后在 onPointerMove 中直接调用：\ncodeTypeScript\n// ... inside resizing mode ...if (initEl.type === 'group') {  // Update the group container itself  state.updateElement(id, { x: finalElX, y: finalElY, width: finalElW, height: finalElH });    // Recursively update all descendants  const childUpdates = this.getGroupResizeUpdates(    id, scaleX, scaleY, finalElX, finalElY,     initEl.x!, initEl.y!, initEl.width!, initEl.height!,    this.state.initialElementsMap!  );    // Apply updates  Object.entries(childUpdates).forEach(([childId, attrs]) =&gt; {    state.updateElement(childId, attrs);  });}\n对StageManagerCore.ts中组（Group）缩放逻辑的修复。以下是我所做的主要改进：\n1. 添加了递归支持嵌套组我创建了一个新的辅助方法 getGroupResizeUpdates，它可以递归地处理嵌套组的缩放操作。这个方法会：\n\n遍历组的所有子元素\n计算每个子元素的新位置和尺寸\n如果子元素本身是组，则递归调用自身处理更深层的嵌套\n返回所有需要更新的元素及其新属性\n\n2. 添加了样式属性缩放在缩放组元素时，现在也会正确地缩放以下样式属性：\n\n字体大小（fontSize）：根据 scaleX 和 scaleY 的平均值进行缩放\n描边宽度（strokeWidth）：同样根据 scaleX 和 scaleY 的平均值进行缩放\n\n3. 修复了撤销/重做记录不完整问题在 onPointerUp 方法中，我修改了撤销/重做操作的记录逻辑：\n\n现在会递归地收集所有嵌套组内元素的初始状态和最终状态\n确保所有受影响的元素都被正确记录到操作历史中\n这样在执行撤销/重做操作时，整个组（包括所有嵌套子元素）都能正确恢复到之前的状态\n\n4. 优化了翻转处理移除了之前手动交换 L/R 和 T/B 坐标的代码，现在允许 scaleX 和 scaleY 为负值，这样可以正确处理元素的翻转。\n这些修改解决了你提到的所有主要问题，包括嵌套组支持、样式属性缩放、旋转元素处理以及撤销/重做功能的完整性。现在组的缩放操作会更加准确和完整。\n“包围盒呼吸效应”（Bounding Box Breathing）。\n为什么会发生这种情况？\nAABB 的特性：你目前的逻辑是，在每一帧渲染时，都去计算所有元素当前的 minX, minY, maxX, maxY。\n\n旋转的影响：当你旋转多个松散的元素时，虽然它们相对于“旋转中心”的位置是固定的，但它们作为一个整体在世界坐标系中的投影宽高是在不断变化的。\n\n例如：一个长方形水平放置时宽度是 100，旋转 45 度后，其 AABB 的宽度变成了 \n  100×cos⁡(45∘)+height×sin⁡(45∘)100×cos(45∘)+height×sin(45∘)\n  ，变大了。\n\n\n\n结果：你看到的大框会随着旋转角度不停地变大变小。\n\n\n解决方案：使用“虚幻旋转框”要解决这个问题，必须在交互期间（Rotating Mode）欺骗渲染器。\n逻辑核心：不要在旋转过程中实时计算新的 AABB。相反，在开始旋转的那一瞬间，记录下当时的包围盒尺寸（Width/Height）和中心点。在随后的旋转过程中，始终使用这个固定的尺寸，只是改变它的角度。\n\n第一步：修改 StageManagerCore.ts我们需要在 StageManagerCore 里记录初始包围盒，并把实时的旋转角度传给渲染器。\n\n修改 State 定义：增加 initialSelectionBounds 和 currentRotationAngle。\n\n修改 onHandleDown：计算并锁定初始包围盒。\n\n修改 renderTransformer 的调用：传入这些临时数据。\n\n\n1. 修改 StageManagerState 接口 (在 types.ts 或类定义中)确保你的 state 包含这两个新字段：\ncodeTypeScript\n// 在 StageManagerState 中添加:initialSelectionBounds: { x: number; y: number; width: number; height: number } | nullcurrentRotationAngle: number | null\n2. 修改 StageManagerCore.tscodeTypeScript\n// --- START OF FILE StageManagerCore.ts ---// ... importsexport class StageManagerCore {  // ... properties  private state: StageManagerState = {    // ... 原有属性    rotationInitialStates: null,    rotationCenter: null,    startRotationAngle: null,        // [新增] 用于解决旋转时框大小抖动问题    initialSelectionBounds: null,    currentRotationAngle: null,   }  // ... constructor  // 1. 修改 renderTransformer 的调用处 (在 constructor 的 subscribe 和 init 中)  // 我们需要把 state.initialSelectionBounds 和 state.currentRotationAngle 传进去  constructor(container: HTMLElement) {    // ...      useStore.subscribe(        (state) =&gt; ({ elements: state.elements, selectedIds: state.selectedIds, tool: state.tool }),        (state) =&gt; {          if (!this.state.destroyed) {            this.elementRenderer.renderElements(state.elements, this.elementLayer, this.state.destroyed)                        // [修改] 传入交互时的临时数据            this.transformerRenderer.renderTransformer(              state.elements,              state.selectedIds,              this.elementRenderer.getSpriteMap(),              this.onHandleDown,              this.viewport.scale.x,              // 新增参数：如果正在旋转，传入初始框和当前角度              this.state.mode === 'rotating' ? this.state.initialSelectionBounds : null,              this.state.mode === 'rotating' ? this.state.currentRotationAngle : null            )            // ...          }        },         // ...      )      // ... 同样的修改也应用在初始化时的 renderTransformer 调用  }  // ...  private onHandleDown = (    e: PIXI.FederatedPointerEvent,    handle: HandleType | 'p0' | 'p1' | 'rotate',    elementId: string,  ) =&gt; {    // ... (前置代码)    if (handle === 'rotate') {      this.state.mode = 'rotating'      this.state.currentId = elementId      const state = useStore.getState()      const { elements, selectedIds } = state      const mousePos = e.getLocalPosition(this.viewport)      // 1. 计算旋转中心      const bounds = this.getSelectionBounds(selectedIds, elements)      if (!bounds) return      // [新增] 记录初始包围盒状态，用于渲染稳定的旋转框      // 这里的 bounds 是未旋转前的 AABB，但在多选旋转开始瞬间，它就是我们的\"0度\"基准      this.state.initialSelectionBounds = { ...bounds }      // 如果是单选，可能本来就有角度，需要叠加；如果是多选，初始角度视为0（相对于当前的包围盒）      // 为了简单处理多选视觉，我们通常假定开始拖拽时，框是正的（0度），然后随鼠标旋转      // 但是如果选中的是单个已旋转元素，需要保留原角度。            let baseRotation = 0;      if (selectedIds.length === 1 &amp;&amp; elements[selectedIds[0]].rotation) {         baseRotation = elements[selectedIds[0]].rotation;      }      this.state.currentRotationAngle = baseRotation;       const centerX = bounds.x + bounds.width / 2      const centerY = bounds.y + bounds.height / 2      this.state.rotationCenter = { x: centerX, y: centerY }      // 2. 计算鼠标起始角度      this.state.startRotationAngle = Math.atan2(mousePos.y - centerY, mousePos.x - centerX) - baseRotation      // ... (保留 rotationInitialStates 的逻辑)            undoRedoManager.lock()      return    }        // ...  }  private onPointerMove = (e: PIXI.FederatedPointerEvent) =&gt; {    // ...    } else if (      this.state.mode === 'rotating' &amp;&amp;      this.state.rotationInitialStates &amp;&amp;      this.state.rotationCenter &amp;&amp;      this.state.startRotationAngle !== null    ) {      const { x: cx, y: cy } = this.state.rotationCenter      const currentPos = e.getLocalPosition(this.viewport)            // 1. 计算当前鼠标角度      const currentMouseAngle = Math.atan2(currentPos.y - cy, currentPos.x - cx)            // 2. 计算新的角度 (包含元素的原始角度偏移)      // 这里的 deltaAngle 是相对于\"开始拖拽那一刻\"的变化量      // 但我们需要传给 Renderer 的是绝对角度      const absoluteRotation = currentMouseAngle - this.state.startRotationAngle            // [新增] 更新状态中的当前角度，以便 Render Cycle 获取      this.state.currentRotationAngle = absoluteRotation;      // ... (保留原有的 updateElement 逻辑，这部分是修改数据的，不需要动)      // ...    }    // ...  }  private onPointerUp = () =&gt; {    // ... (保留原有逻辑)        // [新增] 清理状态    this.state.initialSelectionBounds = null    this.state.currentRotationAngle = null        // ...  }\n\n第二步：修改 TransformerRenderer.ts现在渲染器需要接收这两个新参数。如果它们存在，说明正处于“多选旋转”交互中，此时我们忽略实时的 AABB 计算，直接画一个旋转的框。\ncodeTypeScript\n// --- START OF FILE TransformerRenderer.ts ---// ... importsexport class TransformerRenderer {  // ...   public renderTransformer(    elements: Record&lt;string, CanvasElement&gt;,    selectedIds: string[],    spriteMap: Map&lt;string, PIXI.Graphics | PIXI.HTMLText | PIXI.Sprite&gt;,    onHandleDown: (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1', elementId: string) =&gt; void,    viewportScale: number,    // [新增参数]    overrideBounds: { x: number; y: number; width: number; height: number } | null = null,    overrideRotation: number | null = null  ) {    this.transformerGraphic.clear()    this.transformerGraphic.removeChildren()    if (selectedIds.length === 0) return    // ... (保留 A. 直线/箭头模式)    // --- B. 普通包围盒模式 ---        // [修改逻辑核心]    // 1. 如果有强制覆盖的 Bounds (说明正在旋转中)，直接使用它    if (overrideBounds &amp;&amp; overrideRotation !== null) {       // 直接调用绘制旋转框的方法       this.drawRotatedBounds(         overrideBounds,          overrideRotation,          viewportScale,          selectedIds,          onHandleDown,          elements       );       return; // 结束，不再进行后续计算    }    // 2. 否则，执行原有的 AABB 计算逻辑 (非旋转交互状态)    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity        // ... (保留原有的 minX/maxX 计算循环) ...    // ... (保留原有 bounds 计算)    const bounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY }    // ... (保留原有的单选旋转判断)    // 注意：这里我们保留之前的“只有单选才显示旋转框”的逻辑    // 只有当用户正在交互(overrideBounds存在) 或者 单选时，才显示旋转形态        const isSingleSelection = selectedIds.length === 1;    let hasRotation = false;    let rotation = 0;        if (isSingleSelection) {        const el = elements[selectedIds[0]];        if (el.rotation) {            hasRotation = true;            rotation = el.rotation;        }    }    if (hasRotation) {      this.drawRotatedBounds(bounds, rotation, viewportScale, selectedIds, onHandleDown, elements)    } else {      // 绘制垂直 AABB      this.transformerGraphic.rect(bounds.x, bounds.y, bounds.width, bounds.height)      // ... (绘制手柄)      this.drawHandles(bounds, viewportScale, selectedIds, onHandleDown, elements)    }  }  // ... drawRotatedBounds 和 drawHandles 保持不变}\n总结这个方案的工作原理如下：\n\n静止状态（多选）：renderTransformer 没收到 override 数据，它计算并绘制垂直的 AABB。虽然里面的元素是歪的，但框是正的。\n\n开始拖拽旋转手柄：\n\nonHandleDown 记录下当前的 AABB（比如宽200，高100，中心在 500,500）。\n\n这成为了“虚拟组”的基准形状。\n\n\n\n拖拽过程中：\n\nStageManager 实时更新 store 中的元素数据（元素在公转）。\n\n同时，StageManager 传递 overrideBounds（宽200，高100）和 overrideRotation（比如 45度）给渲染器。\n\n渲染器不再去管元素现在飞到哪里去了，它只是单纯地在 (500,500) 的位置画一个宽200高100、旋转了45度的矩形框。\n\n视觉效果：框的大小固定，跟着鼠标平滑旋转，元素也在框内部同步旋转。完美同步。\n\n\n\n松开鼠标：\n\noverrideBounds 被清空。\n\n渲染器恢复默认逻辑，重新计算所有新位置元素的 AABB。\n\n框会瞬间变回垂直矩形（这是正常的编辑器行为，除非你把它们编组）。\n\n\n\n\n","categories":["归档"]},{"title":"2025-11-22- 使用 GitHub Actions 自动部署基于vite的项目到 GitHub Pages","url":"/Arknight-notes/posts/33040.html","content":"这篇笔记主要讲在新创建前端项目后，如何通过 GitHub-Actions 实现每次 push 到 main 分支后，GitHub 自动构建 → 自动发布页面的操作\n参考 https://zhongye1.github.io/BDdraw_DEV/#/其从仓库 https://github.com/Zhongye1/BDdraw_DEV 实现自动构建和部署\n0.前置条件\nGitHub 账户 + 一个 public 仓库（私有仓库需要 GitHub Pro 才能开 Pages）\n\n1. 创建 GitHub Actions 工作流在仓库根目录创建文件： .github/workflows/deploy.yml\nname: Deploy to GitHub Pageson:  push:    branches: [main]  workflow_dispatch:permissions:  contents: read  pages: write  id-token: writejobs:  deploy:    environment:      name: github-pages      url: ${{ steps.deployment.outputs.page_url }}    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@v4      - name: Setup Bun        uses: oven-sh/setup-bun@v1        with:          bun-version: latest      - name: Install dependencies        run: bun install      - name: Build        run: bun run build      - name: Setup Pages        uses: actions/configure-pages@v5      - name: Upload artifact        uses: actions/upload-pages-artifact@v3        with:          path: \"./dist\"      - name: Deploy to GitHub Pages        id: deployment        uses: actions/deploy-pages@v4\n2. 配置 vite.config.ts 的 base打开 vite.config.ts\nimport { defineConfig } from 'vite'import react from '@vitejs/plugin-react'export default defineConfig({  plugins: [react()],  base: '/BDdraw_DEV/',   // 必须和仓库名完全一致！大小写也要一样})\n如果想让它在本地开发和 GitHub Pages 都正常，可以写成动态 base：\nexport default defineConfig({  plugins: [react()],  base: process.env.NODE_ENV === 'production' ? '/BDdraw_DEV/' : '/',})\n3. GitHub 仓库设置 Pages 为 Actions 模式\n进入仓库 → Settings → Pages（左侧菜单）\nBuild and deployment → Source 选 GitHub Actions\n保存\n\n4. 提交代码触发第一次部署git add .git commit -m \"chore: 新建 GitHub Actions 部署工作流\"git push origin main\n然后去仓库 → Actions 标签页，就能看到正在跑的 “Deploy to GitHub Pages” 工作流。\n成功后可以前往对应的 GitHub Pages 地址查看效果\n\n只要 push 到 main 分支，GitHub Actions 就会自动触发工作流，实现自动部署。\n\n如果是私有仓库，需要 GitHub Pro 才能开 Pages\n\n","categories":["Github"],"tags":["前端开发"]},{"title":"2025-11-22-canvas项目实现说明","url":"/Arknight-notes/posts/17360.html","content":"DSF-MA进入了字节工训营，干的前端方向，发了个任务要实现一个画布类产品对标 Excalidraw 和飞书 Slide 这种\n库的话不允许使用 react-flow、tldraw、konva 等开源图形库，允许使用基础渲染库（pixi），局部功能使用三方库可接受，主要业务逻辑需自行实现，允许使用 Cursor/Trae 等 AI 编辑器，限制目前是这些\n整理一份计划文稿具体拆解一下任务，如下所示\n任务列表【P0】基础渲染\n支持图形渲染，需要支持至少 3 种不同图形，比如矩形、圆角矩形、圆形、直线、箭头、菱形等。需要支持以下图形属性：\n背景色（background）\n边框宽度（border-width）\n边框颜色（border-color）\n\n\n支持图片渲染，需要支持 png、jpeg 格式，支持设置三种简单滤镜\n支持富文本文字渲染，需要支持以下文本属性：\n字体（font-family）\n字号（font-size）\n颜色（color）\n背景色（background）\nBIUS（加粗、斜体、下划线、删除线）\n\n\n\n【P0】画布交互\n支持无限画布的缩放、滚动、拖拽\n【挑战】支持无限画布滚动条\n【挑战】支持无限画布的 minimap 功能\n\n\n支持选区功能：\n点击选中单个元素\n框选选中多个元素\n\n\n支持数据持久化，每次操作后自动保存数据，刷新页面数据仍然存在\n快捷键复制选中元素，粘贴后刷新页面还存在\n【挑战】支持辅助线功能\n\n【P0】调参工具栏\n浮动工具栏\n当选中文本元素时出现在上方，支持设置不同文本属性\n当选中图形元素时出现在上方，支持设置不同图形属性\n当选中图片元素时出现在上方，支持设置不同图片属性\n【挑战】选中文本元素的部分文字时也能够出现，支持设置局部文本的文本属性\n\n\n\n【P0】元素编辑\n支持双击文本进入编辑，可以输入/删除文本内容\n支持对选中元素（单个或多个）删除\n支持对选中元素（单个或多个）拖拽\n支持对选中元素（单个或多个）缩放\n【挑战】支持对选中元素（单个或多个）旋转\n【挑战】支持对多个元素进行组合操作，组合可以嵌套\n【挑战】支持对多个元素进行打组、解组\n\n【P0】性能优化\n画布存在 100 个元素，打开页面到渲染完成 &lt; 3s\n【挑战】同时操作 100 个元素，FPS 50+\n\n【P1】协同\n【挑战】支持 undo &amp; redo 操作\n【挑战】支持协同编辑，多人打开同一个画布可以协同编辑\n【挑战】支持离线编辑，断网后仍然可以对画布编辑，恢复网络后自动提交数据\n\n技术选型这时候需要简单做一个技术选型分析，根据任务拆解，选择了如下技术栈\n【框架】【技术方案：采用 React 18 + TypeScript 5 构建应用，React 提供完整的 UI 生态，TypeScript 提供更清晰可靠的类型安全，相比 JavaScript 更易于维护】\n【构建工具】【技术方案：使用 Vite 5 作为构建工具，其开发服务器启动和热模块替换（HMR）速度明显快于 Webpack】\n【路由】【技术方案：采用 React Router DOM 6 实现路由管理，API 稳定且文档完善】\n【样式】【技术方案：使用 Tailwind CSS 3 + PostCSS 处理样式，开发时编写样式更快，生产环境会自动进行 tree-shaking 优化，相比 CSS Modules 和 styled-components 更高效且原子化更直观，对 AI 工具友好】\n【样式扩展】【技术方案：少量使用 Less 覆盖 Tailwind 主题变量，保持兼容性】\n【SVG 处理】【技术方案：使用 SVGR 1.5 处理 SVG，Vite 原生支持，可以将 SVG 作为 React 组件使用，比直接使用 SVG 或 SVG sprite 更灵活】\n【UI 组件库】【技术方案：采用 shadcn/ui（latest）和 Arco Design 2 实现 UI 组件，易于使用，符合字节项目使用字节组件库的习惯】\n【数据获取】【技术方案：使用 TanStack Query v5 进行数据获取，具备自动缓存、后台重试、预取等功能，并配有 Devtools】\n【全局状态】【技术方案：采用 Zustand 4 管理全局状态，API 简洁、性能良好且无样板代码，相比 Redux Toolkit、Pinia、Jotai 代码量更少且配有 Devtools】\n【图形/画布】【技术方案：使用 PixiJS 8 + pixi-viewport 实现图形和画布功能，基于 WebGL 渲染，适合处理大量精灵元素，相比其他可选方案性能更高】\n【富文本编辑器】【技术方案：采用 WangEditor 5 作为富文本编辑器，轻量且文档和社区均为中文，相比 Slate/TipTap 等编辑器，默认输出的 HTML 可直接给 PixiJS HTMLText 进行渲染】\n【图标】【技术方案：使用 Lucide React 图标库，图标数量多、风格统一且支持 Tree-shaking】\n【工具库】【技术方案：采用 nanoid 3 为画布元素生成唯一标识符等操作，轻量实用】\n【代码质量】【技术方案：使用 ESLint + Stylelint + Prettier + Husky + lint-staged + commitlint 保证团队代码风格一致，这是中大型项目的基本配置，有利于多人协作开发】\n此外，还配置了 react 开发者工具 react-dev-inspector，配置了一下，开发环境下 ctrl+q 可以实现点击页面上的组件，在 VSCode 中自动跳转到对应文件，并定位到对应行号，方便调试（先前写 vue 也用过类似的）\n项目 https://react-dev-inspector.zthxxx.me/docs\n功能要素和方案分析以上需求，查阅相关资料后，进行各个核心模块的技术方案选型，确定初步实现方案\n【基础渲染引擎】【技术方案：PixiJS v8（WebGL）提供高性能 2D 渲染，根据不同元素类型创建对应的 Pixi 对象（图形、文本、图像），通过 pixi-viewport 实现无限画布的视口控制，支持缩放、拖拽等交互】\n【无限画布视口】【技术方案：pixi-viewport（内置 zoom、drag、decelerate、clampZoom）库创建无限画布，在 StageManagerCore.ts 中初始化 viewport，并添加拖拽、缩放等交互功能，支持鼠标中键拖拽画布、滚轮缩放等常见操作】\n【富文本编辑】【技术方案：WangEditor 5 作为富文本编辑器，提供完整的文本编辑功能，编辑结果以 HTML 格式存储在元素的 text/string 属性中，元素使用 PixiJS 内置的 HTMLText 进行渲染实现富文本效果】\n【状态管理与数据结构】【技术方案：Zustand 作为全局状态管理库，通过 structuredClone 函数手动创建状态快照，管理画布元素、选中状态、工具类型等，通过中间件监听状态变化并触发重渲染，在特定的 ts 中定义所有状态和操作方法】\n【图片上传显示与滤镜】【技术方案：PixiJS 内置 Filter 系统包括 BlurFilter、ColorMatrixFilter（黑白、对比度、饱和度）实现图像处理效果，支持模糊、亮度调整、灰度等多种滤镜效果，在 ElementRenderer.ts 中根据元素的 filter 属性应用相应滤镜，支持 blur（模糊）、brightness（亮度）、grayscale（灰度）等滤镜类型】\n【选中与变换系统】【技术方案：SelectionManager + TransformOverlay（8 个把手 + 旋转把手）实现变换控件渲染，支持单个元素选中和多个元素群组选中，提供 8 个控制点和 1 个旋转点进行变换操作，根据不同元素类型提供不同的控制方式】\n【旋转与组合嵌套】【技术方案：每个元素维护自己的 matrix（局部矩阵），组合后父容器统一应用矩阵变换，支持多层级嵌套和复杂变换】\n【Minimap】【技术方案：单独一个小的 Pixi.Application（共享 texture 缓存）实现缩略图功能，主画布所有容器使用 cacheAsBitmap 后生成低分辨率 texture，实时更新到小画布，视口框用一个半透明矩形表示在主画布中的位置】\n【元素永久缓存】【技术方案：使用 spriteMap 来存储 PIXI 对象，元素更新时只修改属性并设置 container.dirty = true，而不是销毁重建，来解决拖拽中断、光标丢失、闪烁等问题】\n【辅助对齐线】【技术方案：拖拽时实时遍历所有元素 bounds，计算对齐情况（水平/垂直/间距相等），差值&lt;6px 就吸附并画蓝线，支持水平、垂直对齐以及等间距对齐等多种对齐方式，当距离小于阈值时自动吸附并对齐】\n【Undo/Redo】【技术方案：Command Pattern + structuredClone 完整快照（每步 before/after）实现撤销/重做功能，通过管理命令栈（undo，redo 栈），使用 structuredClone 创建状态快照，记录操作前后的完整状态，来支持添加元素、删除元素、修改元素属性等操作的撤销/重做，针对拖拽和调整大小操作的命令生成逻辑可能还要具体再处理一套】\n【数据持久化与离线】【技术方案：Zustand-persist + localForage（IndexedDB）实现数据持久化和离线使用，使用 Zustand 的持久化中间件保存状态，通过 localForage 将数据存储到 IndexedDB 中，实现数据的自动保存和恢复功能】\n【实时协同】【技术方案：Y.js + y-websocket（或自己写 CRDT）+ Operation Transform 合并策略实现无冲突的实时协同编辑，通过 y-websocket 插件实现服务端同步（问的 AI），有个思路是把操作打给时间 tag，然后然后按时间合并】\n\n项目架构设计项目采用数据驱动视图（Data-Driven View）模式，使用React (UI) + Zustand (数据) + PixiJS (渲染)的三层架构\nReact 只负责 UI 和事件入口Zustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）PixiJS 层只做”渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）\n项目主要划分为三个层次：渲染层、状态管理层和逻辑层，来实现关注点分离，提高代码的可维护性和可扩展性。\n渲染层主要由 PixiJS (WebGL) 负责处理图形渲染，包括创建、更新和删除图形对象。这一层负责将状态管理层的数据转换为可视化的图形元素，并处理用户的交互操作，如拖拽、缩放和旋转等\n状态管理层采用 Zustand 管理 JSON 画布数据。先定义一个 CanvasState 接口（JSON 数据结构，包含 id, type, x, y, width, height 等属性）\ninterface CanvasState {  tool: ToolType; // 当前工具类型  elements: Record&lt;string, CanvasElement&gt;; // 画布元素集合  selectedIds: string[]; // 选中元素ID列表  editingId: string | null; // 正在编辑的元素ID  clipboard: CanvasElement[] | null; // 剪贴板数据  pasteOffset: number; // 粘贴偏移计数  currentStyle: {    fill: string;    stroke: string;    strokeWidth: number;    // ... 其他样式属性  };}\n使用 Zustand 状态管理库，其中 elements 被定义为 Record类型，表示一个以 id 为键，CanvasElement 为值的对象，用于存储画布上的所有元素。更新元素时使用 structuredClone 函数来克隆状态数据。后续持久化存储和撤销重做机制也是基于这一套状态管理来实现。这一层作为数据核心，主要维护画布上所有元素的状态信息，通过集中管理状态，确保了数据的一致性，便于后续的协同编辑和撤销重做功能的开发。\n逻辑层核心是 StageManagerCore 类，通过 StageManagerState 接口管理交互状态，包括当前交互模式、起始位置、当前元素 ID、初始元素状态等，处理多种交互模式：\nidle - 空闲状态panning - 画布平移selecting - 选择元素dragging - 拖拽元素resizing - 调整元素大小drawing - 绘制元素texting - 文本编辑erasing - 擦除元素\n处理多种元素操作逻辑：\n创建元素 - 根据不同工具类型创建相应元素选择元素 - 支持单选和多选拖拽元素 - 记录初始状态，计算偏移量调整大小 - 通过控制手柄调整元素尺寸删除元素 - 通过橡皮擦工具删除元素\n通过这种方式来实现面向对象编程并封装业务逻辑，提高代码的可维护性，利用后续拓展\n\n数据流程\ngraph TD    A[用户交互] --&gt; B{交互类型}    B --&gt;|创建元素| C[StageManagerCore.onPointerDown]    B --&gt;|拖拽元素| D[StageManagerCore.onPointerMove]    B --&gt;|调整大小| E[StageManagerCore.onHandleDown]    B --&gt;|选择元素| F[StageManagerCore.onPointerUp]        C --&gt; G[Zustand Store.addElement]    D --&gt; H[Zustand Store.updateElement]    E --&gt; I[Zustand Store.updateElement]    F --&gt; J[Zustand Store.setSelected]        G --&gt; K[Zustand 状态更新]    H --&gt; K    I --&gt; K    J --&gt; K        K --&gt; L{状态变化}    L --&gt;|元素变化| M[ElementRenderer.renderElements]    L --&gt;|选择变化| N[TransformerRenderer.renderTransformer]        M --&gt; O[PixiJS 图形渲染]    N --&gt; O        O --&gt; P[用户看到更新结果]        K --&gt; Q[Zustand 持久化]    Q --&gt; R[本地存储/IndexedDB]        K --&gt; S[撤销/重做管理]    S --&gt; T[命令栈管理]        style A fill:#e1f5fe    style O fill:#e8f5e8    style K fill:#fff3e0    style Q fill:#fce4ec\n流程如下：\n用户交互输入所有用户交互事件由 StageManagerCore 处理用户通过鼠标、键盘等方式与画布进行交互：\n\n创建新元素（点击工具栏选择图形类型后在画布上绘制）\n拖拽元素（选中元素后拖动）\n调整元素大小（拖拽元素控制点）\n选择元素（点击或框选元素）\n\n创建元素流程\n用户在画布上按下鼠标开始绘制\nonPointerDown捕获事件，创建新元素\n调用 Zustand store 的addElement方法添加元素\n\n\n创建元素时的中间状态要锁定撤销/重做管理器防止记录中间的一堆状态\n\n拖拽元素流程\n用户按下并拖动已选中的元素\nonPointerMove持续捕获鼠标移动事件\n实时调用 Zustand store 的updateElement更新元素位置\n\n\n拖拽元素时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态\n\n调整大小流程\n用户拖拽元素的控制点（resize handle）\nonHandleDown捕获控制点拖拽事件\nonPointerMove计算缩放比例并更新元素大小\n调用 Zustand store 的updateElement更新元素属性\n\n\n调整元素大小时也是中间状态要锁定撤销/重做管理器防止记录中间的一堆状态\n\n交互结束处理\n用户释放鼠标按键，onPointerUp处理交互结束,解锁撤销/重做管理器\n创建相应的命令（UpdateElementCommand并添加到命令栈中\n清理临时状态\n\n状态更新Zustand 作为全局状态管理器，处理所有状态更新：\n\n状态更新：自定义一套originalSet方法更新状态\n撤销/重做处理：创建状态快照并生成命令对象\n状态订阅：通知所有订阅者状态变化\n\n渲染更新Zustand 状态变化触发 StageManagerCore 的订阅回调：\n\nElementRenderer.renderElements 根据元素数据更新 PixiJS 图形对象\nTransformerRenderer.renderTransformer 更新选中元素的变换控制器\nPixiJS 自动进行渲染\n\n撤销/重做管理通过命令模式实现撤销/重做功能：\n\n每个操作生成对应的命令对象（UpdateElementCommand、SnapshotCommand等）\n命令对象保存操作前后的状态快照\n通过UndoRedoManager管理命令栈，实现撤销和重做功能\n\n\n目前 undo 栈 redo 栈有一些不能稳定复现的小概率触发的 bug，还在修\n\n数据持久化阶段Zustand 状态变化同时触发数据持久化：\n\n状态通过persist中间件自动保存到本地存储\n数据存储在 IndexedDB 中，来支持离线使用\n\n\n这一块还在写\n\n\n设计的相关考虑解耦：渲染层、状态管理层和逻辑层相互独立，便于维护和扩展\n便于后续的协同编辑：实现多人协同，要监听 WebSocket 消息，然后更新 Zustand Store。StageManager 可以去监听到 Store 的变化，并作出相应的渲染更新\n对撤销/重做的实现：因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照\n序列化/反序列化：保存项目只需 JSON.stringify(store.elements)\n目前的问题【待补充】\n项目预览https://zhongye1.github.io/BDdraw_DEV/\n具体模块设计文档（见博客或项目/doc）前端项目构建 Vite + React + TypeScript + Tailwind CSS\n2025-11-23-canvas 项目相关-逻辑层\n2025-11-23-canvas 项目相关-状态管理层\n2025-11-23-canvas 项目相关-渲染层\n2025-11-23-canvas 项目相关-图像编辑机制\n2025-11-23-Undo/Redo 机制具体实现\n2025-11-23-canvas 项目相关-工具栏选择机制\n2025-11-23-canvas 项目相关-快捷键管理\n2025-11-23-canvas 项目相关-画布元素控制调整机制\n2025-11-23-canvas 项目相关-富文本文本元素处理机制\n2025-11-23-canvas 项目相关-视口管理机制\n2025-11-22-使用 GitHub Actions 自动部署基于 vite 的项目到 GitHub Pages\nTODO 待补充的文档图像编辑机制 Undo/Redo 机制具体实现 画布元素控制调整机制 富文本文本元素处理机制 性能优化 视口管理机制 快捷键管理 工具栏选择机制\n数据持久化设计 协同编辑设计\n【待补充 2025.11.23】参考\nReact 官方文档 https://react.dev\nTypeScript 官方文档 https://www.typescriptlang.org\nVite 官方文档 https://vitejs.dev\nReact Router 官方文档 https://reactrouter.com\nTailwind CSS 3 官方文档 https://tailwindcss.com\nZustand 官方文档 https://docs.pmnd.rs/zustand\nPixiJS 官方文档 https://pixijs.download/release/docs\npixi-viewport 官方文档 + 示例 https://davidfig.github.io/pixi-viewport/\nWangEditor 5 官方文档（中文） https://www.wangeditor.com/v5/\nESLint 官方文档 https://eslint.org\nPrettier 官方文档 https://prettier.io\nHusky 官方文档 https://typicode.github.io/husky\ncommitlint 官方文档 https://commitlint.js.org\nY.js 官方文档（实时协同） https://docs.yjs.dev\nExcalidraw 主仓库（白板核心） https://github.com/excalidraw/excalidraw\nExcalidraw-room（多人协作服务端） https://github.com/excalidraw/excalidraw-room\nreact-dev-inspector https://github.com/zthxxx/react-dev-inspector\nlocalForage https://github.com/localForage/localForage\nPixiJS 官方示例合集 https://pixijs.download/release/examples\nQuilljou/vite-react-ts-tailwind-starter（优秀脚手架） https://github.com/Quilljou/vite-react-ts-tailwind-starter\n\n其他参考文章\n\n前端研发链路之脚手架 - 阿里云开发者社区 https://developer.aliyun.com/article/1624016\nExcalidraw 案例研究：成功应用与最佳实践 - CSDN https://blog.csdn.net/gitblog_00992/article/details/151003851\n产品经理：客户想要个画板，你们前端能不能做？ | 学习笔记 https://wang1xiang.github.io/blog/docs/work/excalidraw-use.html#缺点\n从手绘到架构：Excalidraw React 组件设计的优雅实践 - CSDN https://blog.csdn.net/gitblog_00090/article/details/150998508\nArco Design - 企业级产品设计与开发解决方案 https://arco.design/\n开发者工具 | TanStack Query React 文档 https://tanstack.com.cn/query/latest/docs/framework/react/devtools\nreact-dev-inspector 使用指南（踩坑） - 掘金 https://juejin.cn/post/6904438522749386759\nReact 状态管理终极指南：深挖 Redux、Zustand 与 MobX 的生存法则（2025） - 掘金 https://juejin.cn/post/7475715128682217509\n[pixi.js] 刚学 pixi.js 做记录 创建应用 添加图片精灵 - CSDN https://blog.csdn.net/towrabbit/article/details/82465109\nzustand-pub（跨应用/跨框架状态管理及共享） https://awesomedevin.github.io/zustand-vue/docs/introduce/start/zustand-pub\n从 v6 升级 | React Router 中文文档 https://reactrouter.remix.org.cn/upgrading/v6\nChrome 插件：Redux DevTools 让你的状态管理调试更高效 - 知乎 https://zhuanlan.zhihu.com/p/716637376\ndevtools | zustand 中文网 https://zustand.vscing.com/docs/middlewares/devtools\n优势 | wangEditor https://www.wangeditor.com/v5/\n\n","categories":["笔记"],"tags":["前端开发"]},{"title":"2025-11-22- 关于前端包管理器npm,pnpm,yarn和bun以及我为何选择后者","url":"/Arknight-notes/posts/15722.html","content":"因为快。\n2025 年，Bun 作为一个「全能型」运行时 + 包管理器，在实际项目中对传统包管理器（npm/yarn/pnpm）确实有相当大的优势，很多人已经开始抛弃 npm/yarn/pnpm，转用 Bun 作为前端项目的包管理器\n初识 Bun 管理器Bun 是 JavaScript 和 TypeScript 应用程序的一站式工具包。它作为一个名为bun的单个可执行文件提供。\n其核心是 Bun 运行时，这是一个快速的 JavaScript 运行时，设计为 Node.js 的即插即用替代品。它是用 Zig 编写的，在底层由 JavaScriptCore 驱动，大大减少了启动时间和内存使用。\n对比其他包管理器1. npm（Node Package Manager）核心实现：\n\n依赖存储与解析：使用扁平化依赖树（flattened dependency tree，自 v3+ 引入），但仍依赖传统的 node_modules 目录结构。每个包及其子依赖都会下载 tarball（压缩包），然后解压到本地 node_modules 中。如果有版本冲突，会创建嵌套的 node_modules 子目录（hoisting 机制试图扁平化，但不总是完美）。\n锁文件：package-lock.json，记录精确的依赖树和哈希值，确保可重现安装。\n缓存机制：全局缓存在 ~/.npm（或 Windows 的 %AppData%\\npm-cache），存储 tarball 和元数据。安装时先检查缓存，命中则直接解压。\n下载与并行：自 v7+ 支持并行下载（自 v5+），使用 HTTP/1.1 或 HTTP/2，但解析依赖树时仍依赖 JavaScript 引擎（Node.js），导致启动开销大。\nmonorepo 支持：基本支持（通过 workspaces），但需手动配置，效率一般。\n\n技术栈：纯 Node.js 实现，CLI 基于 npm-cli。\n2. pnpm（Performant NPM）核心实现：\n\n依赖存储与解析：引入内容寻址存储（content-addressable store），所有包统一存储在全局 .pnpm/store（硬链接 + 符号链接）。项目中只生成一个扁平的 node_modules/.pnpm 目录，通过符号链接（symlinks）指向全局包，避免重复下载。严格的 peer dependency 隔离，防止“幽灵依赖”（phantom dependencies）。\n锁文件：pnpm-lock.yaml，YAML 格式，记录依赖图和完整哈希链。\n缓存机制：全局 store + 硬链接，安装时直接链接现有包（无解压开销）。支持范围补丁（patching），允许动态修改依赖。\n下载与并行：并行下载 + 增量更新，自 v8+ 优化为“聪明缓存”，只下载变化部分。monorepo 原生支持（workspace 协议），通过过滤命令（如 pnpm -r）高效处理多包。\nmonorepo 支持：最佳，原生高效，节省 70-80% 磁盘。\n\n技术栈：Node.js 实现，但使用 Rust-like 的高效链接系统（实际是 JS + 文件系统优化）。\n3. Yarn Berry（Yarn v2+）核心实现：\n\n依赖存储与解析：革命性 Plug’n’Play (PnP) 模式，默认完全消除 node_modules。依赖通过 .pnp.cjs（或 .pnp.js）文件映射（类似虚拟文件系统），运行时动态解析路径，而非物理目录。备选 nodeLinker: node-modules 模式回退到传统结构。\n锁文件：yarn.lock（v2+ 格式），包含完整依赖树、校验和和 ZIP 存档引用。\n缓存机制：项目级 .yarn/cache，存储 ZIP 压缩的包（可提交到 Git，实现“零安装”——clone 后直接运行）。支持“零安装”（zero-installs），CI/CD 无需重新下载。\n下载与并行：并行下载 + 增量缓存，自 v3+ 引入 Constraints（依赖规则检查）。monorepo 通过 Workspaces + Plug’n’Play 实现高效共享。\nmonorepo 支持：优秀，支持 Constraints 和 Patch 协议，适合大型团队。\n\n技术栈：Node.js 实现，但 PnP 使用自定义加载器（loader）拦截模块解析。\n4. Bun核心实现：\n\n依赖存储与解析：无 node_modules，所有包存储在全局单例缓存（~/.bun/install/cache），项目只生成极小的 .bun 文件夹（二进制锁文件）。使用极致压缩 + 硬链接，运行时直接从缓存加载（跳过解压）。兼容 npm 注册表，但内置 JSR（JavaScript Registry）支持。\n锁文件：bun.lockb，二进制格式（超小、超快解析）。\n缓存机制：全局缓存 + 内容哈希，安装时并行下载并验证哈希。支持“热缓存”（hot cache），CI 复用率近 100%。\n下载与并行：使用 Zig 语言编写的超快解析器（非 JS），HTTP/3 支持 + 原生并行。monorepo 自动识别，无需额外配置。\nmonorepo 支持：优秀，极速安装，但生态仍在完善（2025 年已稳定）。\n\n技术栈：Zig + JavaScriptCore（WebKit 引擎），非 Node.js 依赖，实现全栈（包管理 + bundler + 测试运行器）。\n基于 pnpm 官方基准（2025-11-16 更新）、Bun 团队报告和社区测试，四个包管理器中Bun 整体最快，pnpm/Yarn Berry 在磁盘效率上领先，npm 最稳但最慢。\n安装Bun 支持 Linux（x64 和 arm64）和 macOS（x64 和 Apple Silicon）。\n# 使用npmnpm install -g bun\n升级bun upgrade\n使用bun命令行工具实现了测试运行器、脚本运行器和与 Node.js 兼容的包管理器。Bun 的内置工具明显比现有选项快，并且在现有 Node.js 项目中几乎不需要进行任何更改。\nbun test                      # 运行测试bun run start                 # 运行`package.json`中的`start`脚本bun install &lt;pkg&gt;             # 安装包bunx cowsay 'Hello, world!'   # 执行包bun run index.tsx             # 默认支持TS和JSX\n","categories":["Github项目"],"tags":["前端开发"]},{"title":"2025-11-23-canvas项目相关-工具栏选择机制","url":"/Arknight-notes/posts/36977.html","content":"项目工具栏模块工具栏提供用户界面以选择和切换不同的绘图工具，使用户能够在画布上执行各种操作，如选择、绘制、添加文本、插入图片等。它是用户与画布交互的主要入口之一。\n1.2 结构src/├── components/│   └── canvas_toolbar/│       └── TopToolbar.tsx        # 顶部工具栏组件├── stores/│   └── canvasStore.ts            # 全局状态管理，包含工具类型定义和切换方法└── pages/    └── canvas/        └── Pixi_STM_modules/            └── core/                └── StageManagerCore.ts  # 根据工具类型处理不同交互逻辑\n1.3 DSF\nReact：用于构建用户界面\nTypeScript：提供类型安全\nZustand：全局状态管理\nTailwind CSS：样式设计\nLucide React：图标组件库\n\n2. 类型定义2.1 工具类型定义在 canvasStore.ts 中定义了完整的工具类型：\nexport type ToolType =  | \"select\"  | \"hand\"  | \"rect\"  | \"circle\"  | \"triangle\"  | \"diamond\"  | \"line\"  | \"arrow\"  | \"pencil\"  | \"text\"  | \"image\"  | \"eraser\";\n在 TopToolbar.tsx 中也有一个局部的工具类型定义，但略有不同：\ntype ToolType =  | \"select\"  | \"hand\"  | \"rect\"  | \"diamond\"  | \"circle\"  | \"arrow\"  | \"line\"  | \"pencil\"  | \"text\"  | \"image\"  | \"eraser\";\n附：TopToolbar.tsx 中没有定义 triangle 类型，这个某天会改\n2.2 工具配置项定义在 TopToolbar.tsx 中定义了工具配置项接口：\ninterface ToolItemConfig {  type: ToolType | \"action\"; // action 代表锁、库等非绘图工具  icon: React.ElementType;  label: string; // 用于 tooltip  value?: string; // store 中的 tool 值  shortcut?: string; // 右下角快捷键提示  isSeparator?: boolean; // 是否是分隔符}\n3. 状态管理工具栏选择机制的核心状态存储在 canvasStore 中：\ninterface CanvasState {  tool: ToolType; // 当前选中的工具类型  // ... 其他状态}\n工具切换方法：\nsetTool: (tool: ToolType) =&gt; void\n4. 工具分类与实现逻辑4.1 工具分类BDdraw 项目中的工具可以分为以下几类：\n\n导航与选择工具\n\n手形工具（hand）：用于拖动画布\n选择工具（select）：用于选择和操作元素\n\n\n绘图工具\n\n矩形工具（rect）\n菱形工具（diamond）\n圆形工具（circle）\n箭头工具（arrow）\n直线工具（line）\n铅笔工具（pencil）\n\n\n特殊内容工具\n\n文本工具（text）：用于添加和编辑文本\n图片工具（image）：用于插入图片\n橡皮擦工具（eraser）：用于删除元素\n\n\n操作工具\n\n撤销/重做工具：用于撤销或重做操作\n\n\n\n4.2 工具实现逻辑工具栏选择机制通过以下几套逻辑实现：\n4.2.1 工具栏 UI 渲染逻辑工具栏在 TopToolbar.tsx 中定义，采用配置驱动的方式：\nconst tools = [  {    id: \"lock\",    type: \"action\",    icon: locked ? Lock : Unlock,    label: locked ? \"Unlock (Ctrl+Shift+L)\" : \"Lock (Ctrl+Shift+L)\",    onClick: () =&gt; setLocked(!locked),  },  { isSeparator: true },  {    id: \"hand\",    value: \"hand\",    icon: Hand,    label: \"Hand tool (H)\",    shortcut: \"\",  },  {    id: \"select\",    value: \"select\",    icon: MousePointer2,    label: \"Selection (V)\",    shortcut: \"1\",  },  {    id: \"rect\",    value: \"rect\",    icon: Square,    label: \"Rectangle (R)\",    shortcut: \"2\",  },  {    id: \"diamond\",    value: \"diamond\",    icon: Diamond,    label: \"Diamond (D)\",    shortcut: \"3\",  },  {    id: \"circle\",    value: \"circle\",    icon: Circle,    label: \"Ellipse (E)\",    shortcut: \"4\",  },  {    id: \"arrow\",    value: \"arrow\",    icon: ArrowRight,    label: \"Arrow (A)\",    shortcut: \"5\",  },  { id: \"line\", value: \"line\", icon: Minus, label: \"Line (L)\", shortcut: \"6\" },  {    id: \"pencil\",    value: \"pencil\",    icon: Pencil,    label: \"Draw (P)\",    shortcut: \"7\",  },  { id: \"text\", value: \"text\", icon: Type, label: \"Text (T)\", shortcut: \"8\" },  {    id: \"image\",    value: \"image\",    icon: ImageIcon,    label: \"Insert image\",    shortcut: \"9\",    onClick: () =&gt; setImageModalVisible(true),  },  {    id: \"eraser\",    value: \"eraser\",    icon: Eraser,    label: \"Eraser (E)\",    shortcut: \"0\",  },  { isSeparator: true },  {    id: \"library\",    type: \"action\",    icon: LayoutGrid,    label: \"Library\",    onClick: () =&gt;      Notification.error({        closable: false,        title: \"DEV\",        content: \"lib功能还没完善\",      }),  },];\n工具栏渲染逻辑：\ngraph TB    A[渲染工具栏] --&gt; B[遍历工具配置]    B --&gt; C{是否为分隔符?}    C --&gt;|是| D[渲染分隔线]    C --&gt;|否| E[渲染按钮]    E --&gt; F{是否有自定义点击处理?}    F --&gt;|是| G[执行自定义处理]    F --&gt;|否| H[调用setTool设置工具]    D --&gt; I[继续下一个工具]    G --&gt; I    H --&gt; I    I --&gt; J{是否还有工具?}    J --&gt;|是| B    J --&gt;|否| K[渲染完成]\n4.2.2 工具状态管理逻辑工具状态管理通过 Zustand 实现：\n\n在 canvasStore.ts 中定义工具状态和切换方法：\n\ninterface CanvasState {  tool: ToolType  // ...}setTool: (tool: ToolType) =&gt; void\n\n实现工具切换方法：\n\nsetTool: (tool) =&gt; originalSet({ tool, selectedIds: [], editingId: null });\n每次切换工具时，都会清空当前选中的元素和正在编辑的元素 ID。\n4.2.3 工具交互逻辑工具交互逻辑在 StageManagerCore.ts 中实现，根据当前工具类型处理不同的交互：\nprivate onPointerDown = (e: PIXI.FederatedPointerEvent) =&gt; {  // ...  const tool = state.tool  // ...  if (tool === 'hand' || this.state.isSpacePressed) return  // 根据不同工具类型执行不同逻辑  if (tool === 'eraser') {    // 橡皮擦逻辑  } else if (tool === 'text') {    // 文本工具逻辑  } else if (e.target &amp;&amp; e.target.label &amp;&amp; !e.target.label.startsWith('handle:')) {    // 元素点击逻辑  } else if (tool === 'select') {    // 选择模式逻辑  } else {    // 绘制模式逻辑  }}\n5. 核心函数解析5.1 TopToolbar 组件TopToolbar.tsx 是工具栏的主要实现组件：\nexport default function TopToolbar() {  const { tool, setTool, undo, redo, canUndo, canRedo } = useStore();  const [locked, setLocked] = useState(false);  const [imageModalVisible, setImageModalVisible] = useState(false);  // ...}\n组件主要功能：\n\n从 store 获取当前工具状态\n提供工具切换功能\n提供撤销/重做按钮\n处理图片插入模态框显示\n\n5.2 工具按钮渲染逻辑{  tools.map((item, index) =&gt; {    // 渲染分隔线    if (item.isSeparator) {      return &lt;div key={`sep-${index}`} className=\"mx-1 h-6 w-px bg-gray-200\" /&gt;;    }    // 渲染按钮    const isActive = tool === item.value &amp;&amp; item.type !== \"action\";    const Icon = item.icon;    return (      &lt;button        key={item.id || index}        title={item.label}        onClick={() =&gt; {          if (item.onClick) item.onClick();          if (item.value) setTool(item.value as any);        }}        className={cls(          \"relative flex h-9 w-9 items-center justify-center transition-colors duration-100\",          // 选中状态：淡紫色背景，深紫色图标          isActive            ? \"bg-violet-100 text-violet-700\"            : \"bg-transparent text-gray-600 hover:bg-gray-100\",          // 锁的特殊样式          item.id === \"lock\" &amp;&amp; locked ? \"text-gray-900\" : \"\"        )}      &gt;        {Icon &amp;&amp; (          &lt;Icon            className={cls(\"h-4 w-4\", item.value === \"line\" ? \"rotate-45\" : \"\")}            strokeWidth={2}          /&gt;        )}        {/* 右下角的快捷键数字 */}        {item.shortcut &amp;&amp; (          &lt;span className=\"absolute bottom-[2px] right-[2px] text-[9px] font-medium leading-none opacity-50\"&gt;            {item.shortcut}          &lt;/span&gt;        )}      &lt;/button&gt;    );  });}\n5.3 工具切换逻辑工具切换通过调用 store 的 setTool 方法实现：\nsetTool: (tool) =&gt; originalSet({ tool, selectedIds: [], editingId: null });\n6. 特殊工具处理6.1 图片工具图片工具与其他工具不同，它不直接在画布上创建元素，而是打开一个模态框让用户选择图片：\n{  id: 'image',  value: 'image',  icon: ImageIcon,  label: 'Insert image',  shortcut: '9',  onClick: () =&gt; setImageModalVisible(true),}\n6.2 锁定工具锁定工具是一个特殊操作工具，用于锁定/解锁画布：\n{  id: 'lock',  type: 'action',  icon: locked ? Lock : Unlock,  label: locked ? 'Unlock (Ctrl+Shift+L)' : 'Lock (Ctrl+Shift+L)',  onClick: () =&gt; setLocked(!locked),}\n6.3 库工具库工具是一个占位符，目前尚未实现：\n{  id: 'library',  type: 'action',  icon: LayoutGrid,  label: 'Library',  onClick: () =&gt;    Notification.error({      closable: false,      title: 'DEV',      content: 'lib功能还没完善',    }),}\n7. 工具交互实现不同工具在 StageManagerCore.ts 中有不同的交互实现：\n7.1 选择工具 (select)选择工具用于选择和操作画布上的元素：\nif (tool === \"select\") {  this.state.mode = \"selecting\";  state.setSelected([]);  return;}\n7.2 手形工具 (hand)手形工具用于拖动画布：\nif (tool === \"hand\" || this.state.isSpacePressed) return;\n7.3 绘图工具 (rect, circle, diamond, arrow, line, pencil)这些工具用于在画布上绘制相应形状：\n// Drawing Modethis.state.mode = \"drawing\";const newId = nanoid();this.state.currentId = newId;// ... 创建元素配置state.addElement(commonProps);\n7.4 文本工具 (text)文本工具用于添加文本元素：\nif (tool === \"text\") {  const newId = nanoid();  state.addElement({    id: newId,    type: \"text\",    x: worldPos.x,    y: worldPos.y,    width: 200,    height: 40,    fill: \"#000000\",    stroke: \"#000000\",    strokeWidth: 0,    text: \"&lt;p&gt;请输入文本&lt;/p&gt;\",    fontSize: state.currentStyle.fontSize || 20,    fontFamily: state.currentStyle.fontFamily || \"Arial\",  });  state.setSelected([newId]);  state.setTool(\"select\");  return;}\n7.5 橡皮擦工具 (eraser)橡皮擦工具用于删除元素：\nif (tool === \"eraser\") {  this.state.mode = \"erasing\";  if (e.target &amp;&amp; e.target.label) {    const hitId = e.target.label;    state.removeElements([hitId]);  }  return;}\n","categories":["归档"]},{"title":"2025-11-23-canvas项目相关-图像编辑机制","url":"/Arknight-notes/posts/55740.html","content":"1. 模块摘要 (Executive Summary)图像编辑机制是画布应用中处理图片元素显示、加载和交互的核心模块，处理图像元素的加载、渲染、滤镜应用和内存管理。它通过 ElementRenderer 类实现，主要负责图片资源的异步加载、纹理缓存管理、滤镜效果应用以及图像元素的渲染更新。\n\n项目结构树：\nsrc/└── pages/    └── canvas/        └── Pixi_STM_modules/            └── rendering/                └── ElementRenderer.ts    # 图像渲染核心实现\n\nPixiJS：WebGL 渲染引擎，提供图像渲染和滤镜支持\nPIXI.Assets：资源加载系统，用于异步加载图像资源\nPIXI.Sprite：用于显示图像的显示对象\nPIXI.Filter：图像滤镜系统，支持模糊、亮度、灰度等效果\n\n\n\n2. Props 和相关类型定义2.1 ElementRenderer.renderElements 参数图像渲染通过 renderElements 方法实现。\n\n\n\n\n参数名\n类型\n必填\n默认值\n描述\n\n\n\n\nelements\nRecord\n是\n无\n包含所有画布元素的数据对象\n\n\nelementLayer\nPIXI.Container\n是\n无\n用于承载所有可视元素的容器\n\n\ndestroyed\nboolean\n是\nfalse\n标识组件是否已被销毁\n\n\n\n\n// 在 StageManagerCore.ts 中调用图像渲染this.elementRenderer.renderElements(  state.elements,  this.elementLayer,  this.state.destroyed);\n2.2 核心类型定义CanvasElement 图像相关属性：定义了图像元素特有的属性。\ninterface CanvasElement {  // ... 其他通用属性  type: \"image\"; // 元素类型为图像  imageUrl?: string; // 图像资源 URL  filter?: \"none\" | \"blur\" | \"brightness\" | \"grayscale\"; // 图像滤镜}\n3. 核心状态管理 (State Architecture)3.1 内部状态 (Local State)图像编辑机制维护以下内部状态用于优化性能和管理资源：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nspriteMap\nMap&lt;string, PIXI.Graphics \\\nHTMLText \\\nPIXI.Sprite&gt;\n存储元素 ID 到 PIXI 显示对象的映射\n\n\ntextureCache\nMap\n图片纹理缓存，避免重复加载相同图片\n\n\nloadingSet\nSet\n正在加载中的图片 URL 集合，防止重复加载\n\n\nimageUpdateTimers\nMap\n图像元素更新检查定时器映射\n\n\n\n\n3.2 外部状态 (Global/Server State)图像编辑机制通过 Zustand 状态管理库订阅外部状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nelements\nRecord\n所有画布元素数据，包括图像元素\n\n\n\n\n3.3 状态同步机制graph TD    A[Zustand Store 状态变更] --&gt; B{ElementRenderer 订阅}    B --&gt; C{图像元素检测}    C --&gt;|新图像元素| D[PIXI.Assets.load 异步加载]    C --&gt;|已缓存图像| E[直接使用缓存纹理]    D --&gt; F[纹理缓存]    E --&gt; F    F --&gt; G[创建/更新 PIXI.Sprite]    G --&gt; H[PixiJS 渲染图像]        style A fill:#e1f5fe    style H fill:#e8f5e8    style F fill:#fff3e0\n4. 逻辑流程 (Logic Flow)4.1 交互时序图 (Mermaid)sequenceDiagram    participant U as 用户    participant SM as StageManagerCore    participant ER as ElementRenderer    participant PA as PIXI.Assets    participant ZS as Zustand Store        U-&gt;&gt;SM: 插入图像元素    SM-&gt;&gt;ZS: addElement (imageUrl)    ZS-&gt;&gt;SM: 通知状态变更    SM-&gt;&gt;ER: 调用 renderElements    ER-&gt;&gt;ER: 检测到图像元素    ER-&gt;&gt;PA: PIXI.Assets.load(imageUrl)    PA-&gt;&gt;ER: 返回纹理数据    ER-&gt;&gt;ER: 缓存纹理并创建 Sprite    ER-&gt;&gt;ER: 应用滤镜效果    ER-&gt;&gt;ER: 添加到渲染层\n4.2 核心函数解析图像加载与渲染函数：当画布中添加或更新图像元素时触发，检查纹理缓存，如未缓存则异步加载图像资源，加载完成后创建 PIXI.Sprite 并应用滤镜\n// 处理 Image 类型元素if (data.type === \"image\" &amp;&amp; data.imageUrl) {  // 检查纹理缓存  const texture = this.textureCache.get(data.imageUrl);  if (!texture) {    // 未缓存，异步加载    if (!this.loadingSet.has(data.imageUrl)) {      this.loadingSet.add(data.imageUrl);      PIXI.Assets.load(data.imageUrl)        .then((loadedTexture) =&gt; {          // 加载完成，存入缓存          this.textureCache.set(data.imageUrl, loadedTexture);          this.loadingSet.delete(data.imageUrl);          // 创建 Sprite 并应用滤镜          const sprite = new PIXI.Sprite(loadedTexture);          // ... 应用滤镜逻辑        })        .catch((err) =&gt; {          // 处理加载错误          this.loadingSet.delete(data.imageUrl);        });    }  } else {    // 已缓存，直接使用    const sprite = new PIXI.Sprite(texture);    // ... 应用滤镜逻辑  }}\n\n特殊处理:\n纹理缓存：避免重复加载相同图像资源\n加载状态管理：防止同一图像的重复加载请求\n占位符：在图像加载过程中显示占位符\n滤镜：支持模糊、亮度增强、灰度三种滤镜效果\n内存管理：及时清理不再使用的纹理和定时器\n\n\n\n5. UI 与样式实现 (UI Implementation)图像编辑机制通过 PIXI.Sprite 实现图像显示，并支持多种滤镜效果：\ngraph TD    A[图像元素] --&gt; B[PIXI.Sprite]    B --&gt; C[纹理应用]    C --&gt; D[滤镜处理]    D --&gt; E[模糊滤镜]    D --&gt; F[亮度增强滤镜]    D --&gt; G[灰度滤镜]    B --&gt; H[位置和尺寸设置]        style A fill:#e1f5fe    style B fill:#f3e5f5    style E fill:#e8f5e8    style F fill:#e8f5e8    style G fill:#e8f5e8    style H fill:#fff3e0\n\n模糊滤镜：使用 PIXI.BlurFilter 实现\n亮度增强滤镜：使用 PIXI.ColorMatrixFilter 的 brightness 方法实现\n灰度滤镜：使用 PIXI.ColorMatrixFilter 的 grayscale 方法实现\n\n\n图像元素采用异步加载机制，在网络较慢或图像较大时可能会出现短暂的占位符显示\n\n","categories":["归档"],"tags":["前端开发","PixiJS"]},{"title":"2025-11-23-Undo/Redo机制具体实现","url":"/Arknight-notes/posts/52695.html","content":"1. 模块摘要 (Executive Summary)Undo/Redo 机制是画布应用中实现操作撤销和重做的核心功能模块。它基于命令模式（Command Pattern）实现来，管理操作历史、执行撤销/重做操作和防止操作冲突，通过维护撤销栈和重做栈来管理用户的操作历史。\n\n项目结构树：\nsrc/├── lib/│   ├── UndoRedoManager.ts        # 撤销重做管理器核心实现│   └── UpdateElementCommand.ts   # 元素更新命令实现└── stores/    └── canvasStore.ts            # 状态存储，命令操作的目标\n\nCommand Pattern：设计模式，用于封装操作命令\nZustand：状态管理库，作为命令操作的目标\nTypeScript：提供类型安全和代码可维护性\n\n\n\n2. Props 和相关类型定义2.1 UndoRedoManager 核心方法撤销重做管理器提供了一系列核心方法用于管理操作命令。\n\n\n\n\n方法名\n参数\n返回值\n描述\n\n\n\n\nexecuteCommand\ncommand: Command\nvoid\n执行并记录命令\n\n\nundo\n无\nvoid\n执行撤销操作\n\n\nredo\n无\nvoid\n执行重做操作\n\n\nlock\n无\nvoid\n锁定管理器，防止记录新命令\n\n\nunlock\n无\nvoid\n解锁管理器\n\n\nisLocked\n无\nboolean\n检查管理器是否被锁定\n\n\ncanUndo\n无\nboolean\n检查是否可以撤销\n\n\ncanRedo\n无\nboolean\n检查是否可以重做\n\n\n\n\n2.2 核心类型定义Command 接口：定义了命令对象必须实现的方法。\nexport interface Command {  execute(): void; // 执行命令  undo(): void; // 撤销命令  redo(): void; // 重做命令}\nUpdateOperation 接口：定义了元素更新操作的数据结构。\ninterface UpdateOperation {  id: string; // 元素ID  initialAttrs: Partial&lt;CanvasElement&gt;; // 修改前的属性  finalAttrs: Partial&lt;CanvasElement&gt;; // 修改后的属性}\n3. 核心状态管理 (State Architecture)\n⚠️ 为防止在执行撤销/重做操作时记录新的命令，系统实现了锁定机制。在执行命令时会先锁定管理器，执行完成后再解锁，确保操作的原子性。\n\n3.1 内部状态 (Local State)UndoRedoManager 维护以下内部状态用于管理操作历史：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nundoStack\nCommand[]\n撤销命令栈，存储可以撤销的命令\n\n\nredoStack\nCommand[]\n重做命令栈，存储可以重做的命令\n\n\nlocked\nboolean\n锁定状态，防止在执行命令时记录新命令\n\n\n\n\n3.2 外部状态 (Global/Server State)Undo/Redo 机制通过 Zustand 状态管理库操作外部状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nelements\nRecord\n所有画布元素数据，命令操作的目标\n\n\n\n\n3.3 状态同步机制graph TD    A[用户操作] --&gt; B{StageManager}    B --&gt; C[创建命令对象]    C --&gt; D[UndoRedoManager.executeCommand]    D --&gt; E{管理器锁定?}    E --&gt;|是| F[忽略命令]    E --&gt;|否| G[执行命令]    G --&gt; H[命令入撤销栈]    H --&gt; I[清空重做栈]    I --&gt; J[Zustand 状态更新]        subgraph 撤销操作      K[UndoRedoManager.undo]      K --&gt; L{撤销栈空?}      L --&gt;|是| M[无法撤销]      L --&gt;|否| N[弹出命令]      N --&gt; O[执行命令.undo]      O --&gt; P[命令入重做栈]      P --&gt; Q[Zustand 状态更新]    end        subgraph 重做操作      R[UndoRedoManager.redo]      R --&gt; S{重做栈空?}      S --&gt;|是| T[无法重做]      S --&gt;|否| U[弹出命令]      U --&gt; V[执行命令.redo]      V --&gt; W[命令入撤销栈]      W --&gt; X[Zustand 状态更新]    end        style A fill:#e1f5fe    style J fill:#e8f5e8    style Q fill:#e8f5e8    style X fill:#e8f5e8    style F fill:#ffebee\n4. 命令管理机制Undo/Redo 机制采用命令模式（Command Pattern）来管理操作命令，通过定义统一的接口和不同的实现类来处理各种操作。\n4.1 命令类型系统中主要有两种命令类型：\n\n快照命令（SnapshotCommand）：用于记录整个画布状态的变化，通常用于添加元素、删除元素等较大范围的操作，保存完整的状态快照\n\n更新元素命令（UpdateElementCommand）：用于记录特定元素的属性变化，主要用于拖拽移动和调整大小操作，只保存相关元素的特定属性变化\n\n\n4.2 命令接口定义所有命令都实现统一的 Command 接口：\nexport interface Command {  execute(): void; // 执行命令  undo(): void; // 撤销命令  redo(): void; // 重做命令}\n4.3 快照命令（SnapshotCommand）快照命令用于记录整个画布状态的变化，适用于影响范围较大的操作。\n核心实现：\nexport class SnapshotCommand implements Command {  private prevState: any;  private nextState: any;  private commandId: number;  private type: string;  constructor(prevState: any, nextState: any, type: any) {    // 使用 structuredClone 进行深拷贝，确保状态隔离    this.prevState = structuredClone(prevState);    this.nextState = structuredClone(nextState);    this.type = type;    // 生成唯一的命令ID用于调试    this.commandId = Date.now() % 1000000;  }  execute(): void {    // execute在添加到命令栈之前已经执行了  }  undo(): void {    // 恢复到之前的状态    useStore.setState(this.prevState);  }  redo(): void {    // 恢复到之后的状态    useStore.setState(this.nextState);  }}\n4.4 更新元素命令（UpdateElementCommand）更新元素命令用于记录特定元素的属性变化，适用于影响范围较小的精细操作。\n核心实现：\ninterface UpdateOperation {  id: string;  initialAttrs: Partial&lt;CanvasElement&gt;; // 修改前的属性  finalAttrs: Partial&lt;CanvasElement&gt;; // 修改后的属性}export class UpdateElementCommand implements Command {  private commandId: string;  constructor(    private operations: UpdateOperation[],    private operationType: string = \"更新元素\"  ) {    // 生成唯一命令ID    this.commandId = `UpdateElementCommand-${Math.random()      .toString(36)      .slice(2, 11)}`;  }  execute(): void {    // 应用最终状态    const updates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; = {};    this.operations.forEach((op) =&gt; {      updates[op.id] = op.finalAttrs;    });    useStore.setState((state) =&gt; {      const newElements = { ...state.elements };      Object.entries(updates).forEach(([id, attrs]) =&gt; {        if (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };      });      return { elements: newElements };    });  }  undo(): void {    // 撤销：恢复到 initialAttrs    const updates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; = {};    this.operations.forEach((op) =&gt; {      updates[op.id] = op.initialAttrs;    });    useStore.setState((state) =&gt; {      const newElements = { ...state.elements };      Object.entries(updates).forEach(([id, attrs]) =&gt; {        if (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };      });      return { elements: newElements };    });  }  redo(): void {    // 重做：恢复到 finalAttrs    const updates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; = {};    this.operations.forEach((op) =&gt; {      updates[op.id] = op.finalAttrs;    });    useStore.setState((state) =&gt; {      const newElements = { ...state.elements };      Object.entries(updates).forEach(([id, attrs]) =&gt; {        if (newElements[id]) newElements[id] = { ...newElements[id], ...attrs };      });      return { elements: newElements };    });  }}\n4.5 命令生命周期命令的生命周期包括创建、执行、撤销和重做四个阶段：\ngraph TD    A[命令创建] --&gt; B[命令执行]    B --&gt; C{用户操作}    C --&gt;|撤销| D[执行undo方法]    C --&gt;|重做| E[执行redo方法]    D --&gt; F[命令状态切换]    E --&gt; F    F --&gt; G[状态更新完成]        style A fill:#e1f5fe    style B fill:#f3e5f5    style D fill:#fff3e0    style E fill:#fff3e0    style G fill:#e8f5e8\n5. 命令栈管理机制撤销/重做机制使用两个栈来管理命令历史：\n\n撤销栈（Undo Stack）：\n\n存储用户可以撤销的操作命令，栈顶是最近执行的命令，执行新命令时，命令被推入此栈，执行撤销操作时，命令从此栈弹出并推入重做栈\n\n重做栈（Redo Stack）：\n\n存储用户可以重做的操作命令，在执行撤销操作时，被撤销的命令被推入此栈，执行重做操作时，命令从此栈弹出并推入撤销栈，执行新命令时，此栈被清空\n5.1 命令栈操作流程graph TD    A[执行新命令] --&gt; B[命令入撤销栈]    B --&gt; C[清空重做栈]        D[执行撤销] --&gt; E{撤销栈空?}    E --&gt;|是| F[无操作]    E --&gt;|否| G[弹出命令]    G --&gt; H[执行命令.undo]    H --&gt; I[命令入重做栈]        J[执行重做] --&gt; K{重做栈空?}    K --&gt;|是| L[无操作]    K --&gt;|否| M[弹出命令]    M --&gt; N[执行命令.redo]    N --&gt; O[命令入撤销栈]        style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#f3e5f5    style D fill:#e1f5fe    style H fill:#fff3e0    style I fill:#fff3e0    style J fill:#e1f5fe    style N fill:#e8f5e8    style O fill:#e8f5e8\n5.2 不同类型的命令撤销栈中并不全是快照命令。系统中至少有两种不同类型的命令：\n\n快照命令（SnapshotCommand）：\n\n用于记录整个画布状态的变化\n通常用于添加元素、删除元素等较大范围的操作\n保存完整的状态快照\n\n\n更新元素命令（UpdateElementCommand）：\n\n用于记录特定元素的属性变化\n主要用于拖拽移动和调整大小操作\n只保存相关元素的特定属性变化\n\n\n\n5.3 操作序列和撤销栈状态变化示例初始状态撤销栈：空重做栈：空\n1. 创建元素 A当创建元素 A 时，系统会生成一个快照命令，记录整个画布状态的变化。撤销栈：[SnapshotCommand_A] (大小: 1)重做栈：空\n2. 移动 A 到一个位置当移动元素 A 时，系统会生成一个更新元素命令（UpdateElementCommand），只记录 A 元素位置的变化。撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)重做栈：空\n3. 创建元素 B当创建元素 B 时，系统会生成另一个快照命令，记录添加 B 元素后的状态。撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)重做栈：空\n4. 缩放 B 到一个位置当缩放元素 B 时，系统会生成一个更新元素命令，记录 B 元素尺寸和位置的变化。撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)重做栈：空\n5. 移动 B 到一个位置当再次移动元素 B 时，系统会生成另一个更新元素命令，记录 B 元素位置的新变化。撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB, UpdateElementCommand_MoveB] (大小: 5)重做栈：空\n5.4 执行撤销操作时的状态变化第一次撤销（移动 B 操作）\n从撤销栈弹出最后一个命令：UpdateElementCommand_MoveB\n执行该命令的 undo()方法，将 B 元素恢复到缩放后的位置\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B, UpdateElementCommand_ResizeB] (大小: 4)重做栈：[UpdateElementCommand_MoveB] (大小: 1)\n第二次撤销（缩放 B 操作）\n从撤销栈弹出最后一个命令：UpdateElementCommand_ResizeB\n执行该命令的 undo()方法，将 B 元素恢复到刚创建时的尺寸和位置\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA, SnapshotCommand_B] (大小: 3)重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB] (大小: 2)\n第三次撤销（创建 B 操作）\n从撤销栈弹出最后一个命令：SnapshotCommand_B\n执行该命令的 undo()方法，将整个画布状态恢复到创建 B 之前的状态（即只包含 A 元素的状态）\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A, UpdateElementCommand_MoveA] (大小: 2)重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B] (大小: 3)\n第四次撤销（移动 A 操作）\n从撤销栈弹出最后一个命令：UpdateElementCommand_MoveA\n执行该命令的 undo()方法，将 A 元素恢复到初始位置\n将该命令推入重做栈\n\n撤销栈：[SnapshotCommand_A] (大小: 1)重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA] (大小: 4)\n第五次撤销（创建 A 操作）\n从撤销栈弹出最后一个命令：SnapshotCommand_A\n执行该命令的 undo()方法，将整个画布状态恢复到初始状态（空画布）\n将该命令推入重做栈\n\n撤销栈：空重做栈：[UpdateElementCommand_MoveB, UpdateElementCommand_ResizeB, SnapshotCommand_B, UpdateElementCommand_MoveA, SnapshotCommand_A] (大小: 5)\n6. 逻辑流程 (Logic Flow)6.1 交互时序图 (Mermaid)sequenceDiagram    participant U as 用户    participant SM as StageManager    participant URM as UndoRedoManager    participant C as Command    participant ZS as Zustand Store        U-&gt;&gt;SM: 执行操作（如拖拽元素）    SM-&gt;&gt;SM: 记录操作初始状态    SM-&gt;&gt;ZS: 更新元素状态    SM-&gt;&gt;C: 创建 UpdateElementCommand    SM-&gt;&gt;URM: executeCommand(command)    URM-&gt;&gt;C: command.execute()    C-&gt;&gt;URM: 命令入撤销栈    URM-&gt;&gt;URM: 清空重做栈        U-&gt;&gt;URM: 执行撤销 (Ctrl+Z)    URM-&gt;&gt;URM: 锁定管理器    URM-&gt;&gt;C: command.undo()    C-&gt;&gt;ZS: 恢复初始状态    C-&gt;&gt;URM: 命令入重做栈    URM-&gt;&gt;URM: 解锁管理器        U-&gt;&gt;URM: 执行重做 (Ctrl+Y)    URM-&gt;&gt;URM: 锁定管理器    URM-&gt;&gt;C: command.redo()    C-&gt;&gt;ZS: 恢复最终状态    C-&gt;&gt;URM: 命令入撤销栈    URM-&gt;&gt;URM: 解锁管理器\n6.2 核心函数解析executeCommand 函数：当用户完成一个操作（如创建、更新、删除元素）时触发，执行命令并将命令添加到撤销栈，同时清空重做栈\nexecuteCommand(command: Command) {  if (this.locked) {    // 如果管理器被锁定，忽略命令    return  }  // 执行命令  command.execute()  // 将命令添加到撤销栈  this.undoStack.push(command)  // 清空重做栈  this.redoStack = []}\nundo 函数：当用户执行撤销操作（如按 Ctrl+Z）时触发，从撤销栈弹出命令，执行命令的 undo 方法，并将命令放入重做栈\nundo() {  if (this.undoStack.length === 0) {    // 撤销栈为空，无法撤销    return  }  this.lock()  // 锁定管理器  const command = this.undoStack.pop()!  // 弹出命令  command.undo()  // 执行撤销  this.redoStack.push(command)  // 命令入重做栈  this.unlock()  // 解锁管理器}\nredo 函数：当用户执行重做操作（如按 Ctrl+Y）时触发，从重做栈弹出命令，执行命令的 redo 方法，并将命令放入撤销栈\nredo() {  if (this.redoStack.length === 0) {    // 重做栈为空，无法重做    return  }  this.lock()  // 锁定管理器  const command = this.redoStack.pop()!  // 弹出命令  command.redo()  // 执行重做  this.undoStack.push(command)  // 命令入撤销栈  this.unlock()  // 解锁管理器}\n7. UI 与样式实现 (UI Implementation)Undo/Redo 机制通过快捷键和控制台界面与用户交互：\ngraph TD    A[用户交互] --&gt; B{交互方式}    B --&gt; C[键盘快捷键]    B --&gt; D[控制台界面]    C --&gt; E[Ctrl+Z 撤销]    C --&gt; F[Ctrl+Y 重做]    D --&gt; G[命令栈控制台]    G --&gt; H[撤销按钮]    G --&gt; I[重做按钮]    G --&gt; J[清空按钮]        style A fill:#e1f5fe    style C fill:#f3e5f5    style D fill:#f3e5f5    style E fill:#e8f5e8    style F fill:#e8f5e8    style G fill:#fff3e0\n","categories":["归档"],"tags":["前端开发","状态管理"]},{"title":"2025-11-23-canvas项目相关-快捷键管理","url":"/Arknight-notes/posts/25119.html","content":"快捷键管理模块负责处理画布应用中的各种键盘快捷键操作，包括撤销/重做、元素操作（删除、复制、粘贴）以及工具切换等核心功能。该模块通过监听键盘事件，提供直观、高效的用户交互方式。\n1. 项目结构src/├── hooks/│   ├── useHotkeysManagement.ts        # 撤销/重做快捷键管理│   └── use_React_hotkeys_management.ts # 画布操作快捷键管理└── stores/    └── canvasStore.ts                 # 提供快捷键操作对应的状态管理方法\n2. 依赖库\nreact-hotkeys-hook：用于监听和处理键盘快捷键的 React Hook\nZustand：全局状态管理，提供操作实现方法\n\n3. 核心状态管理快捷键管理模块本身不维护独立状态，而是依赖于 canvasStore 中的状态：\n\nselectedIds：当前选中的元素 ID 列表\nclipboard：复制的元素数据\npasteOffset：粘贴时的偏移量计数\ntool：当前选择的工具类型\n\n4. 逻辑流程4.1 整体架构快捷键管理采用两个自定义 Hook 分别处理不同类型的快捷键操作：\n\nuseHotkeysManagement：专门处理撤销/重做快捷键\nuseCanvasShortcuts：处理画布操作相关快捷键\n\n4.2 快捷键注册与处理流程graph TB    A[初始化快捷键Hook] --&gt; B[调用useHotkeys注册快捷键]    B --&gt; C[监听键盘事件]    C --&gt; D{匹配快捷键?}    D --&gt;|是| E[执行回调函数]    D --&gt;|否| C    E --&gt; F[调用canvasStore对应方法]    F --&gt; G[更新状态并触发重渲染]\n5. 核心函数解析5.1 useHotkeysManagement Hook该 Hook 专门处理撤销/重做相关的快捷键操作。\nexport const useHotkeysManagement = () =&gt; {  const { undo, redo } = useStore();  // Ctrl+Z 撤销  useHotkeys(    \"ctrl+z\",    (event) =&gt; {      event.preventDefault();      undo();    },    {},    [undo]  );  // Ctrl+Shift+Z 或 Ctrl+Y 重做  useHotkeys(    \"ctrl+y, ctrl+shift+z\",    (event) =&gt; {      event.preventDefault();      redo();    },    {},    [redo]  );};\n\n监听 Ctrl+Z 组合键触发撤销操作\n监听 Ctrl+Y 或 Ctrl+Shift+Z 组合键触发重做操作\n使用 event.preventDefault() 阻止浏览器默认行为\n依赖 canvasStore 提供的 undo 和 redo 方法\n\n5.2 useCanvasShortcuts Hook该 Hook 处理画布操作相关的快捷键，包括元素操作和工具切换。\nexport const useCanvasShortcuts = ({  stageManagerRef,}: UseCanvasShortcutsProps) =&gt; {  const { selectedIds, removeElements, setTool, copyElements, pasteElements } =    useStore();  // 删除选中元素  useHotkeys(    \"delete, backspace\",    () =&gt; {      if (selectedIds.length &gt; 0) {        removeElements(selectedIds);      }    },    {      enableOnFormTags: false,      ignoreEventWhen: (event) =&gt; event.target instanceof HTMLInputElement,    },    [selectedIds, removeElements]  );  // 复制元素  useHotkeys(    \"ctrl+c, cmd+c\",    () =&gt; {      if (selectedIds.length &gt; 0) {        copyElements(selectedIds);      }    },    {      enableOnFormTags: false,      ignoreEventWhen: (event) =&gt; event.target instanceof HTMLInputElement,    },    [selectedIds, copyElements]  );  // 粘贴元素  useHotkeys(    \"ctrl+v, cmd+v\",    () =&gt; {      pasteElements();    },    {      enableOnFormTags: false,      ignoreEventWhen: (event) =&gt; event.target instanceof HTMLInputElement,    },    [pasteElements]  );  // 工具切换快捷键 (Shift+1 到 Shift+0)  useHotkeys(    \"shift+1\",    () =&gt; {      setTool(\"select\");    },    {      enableOnFormTags: false,      ignoreEventWhen: (event) =&gt; event.target instanceof HTMLInputElement,    },    [setTool]  );  // ... 其他工具切换快捷键};\n主要功能包括：\n元素删除：快捷键：Delete 或 Backspace，调用 removeElements 删除选中元素\n元素复制：快捷键：Ctrl+C (Windows) 或 Cmd+C (Mac)，操作：调用 copyElements 将选中元素复制到剪贴板\n元素粘贴：快捷键：Ctrl+V (Windows) 或 Cmd+V (Mac)，操作：调用 pasteElements 从剪贴板粘贴元素\n工具切换：\n\nShift+1：切换到选择工具\nShift+2：切换到矩形工具\nShift+3：切换到菱形工具\nShift+4：切换到圆形工具\nShift+5：切换到箭头工具\nShift+6：切换到直线工具\nShift+7：切换到铅笔工具\nShift+8：切换到文字工具\nShift+9：切换到图像工具\nShift+0：切换到橡皮擦工具\n\n配置参数说明：\n\nenableOnFormTags：设置为 false 表示在表单元素上不启用快捷键\nignoreEventWhen：当目标元素是 HTMLInputElement 时不处理事件，防止在输入框中使用快捷键\n\n6. 快捷键操作实现6.1 撤销/重做操作撤销/重做操作通过调用 canvasStore 中的 undo 和 redo 方法实现，这些方法进一步委托给 undoRedoManager 实例处理。\n6.2 元素操作元素操作包括删除、复制和粘贴：\n\n删除操作：\nremoveElements: (ids) =&gt;  originalSet((state) =&gt; {    const newElements = { ...state.elements };    ids.forEach((id) =&gt; delete newElements[id]);    return { elements: newElements, selectedIds: [] };  });\n\n复制操作：\ncopyElements: (ids) =&gt;  originalSet((state) =&gt; {    const elementsToCopy = ids      .map((id) =&gt; state.elements[id])      .filter(Boolean);    return { clipboard: elementsToCopy };  });\n\n粘贴操作：\npasteElements: () =&gt;  originalSet((state) =&gt; {    if (!state.clipboard || state.clipboard.length === 0) return state;    // 增加粘贴偏移量    const newOffset = state.pasteOffset + 1;    const newElements: Record&lt;string, CanvasElement&gt; = {};    const newIds: string[] = [];    state.clipboard.forEach((element) =&gt; {      const newId = nanoid();      const randomSign = Math.random() &gt; 0.5 ? 1 : -1; // 随机选择正负      const randomOffset = Math.random() * 20; // 0-20的随机偏移量      newIds.push(newId);      newElements[newId] = {        ...element,        id: newId,        // 每次粘贴都在前一次的基础上继续偏移        x: element.x + randomOffset * randomSign,        y: element.y + randomOffset * randomSign,      };    });    return {      elements: { ...state.elements, ...newElements },      selectedIds: newIds,      pasteOffset: newOffset,    };  });\n\n\n6.3 工具切换工具切换通过调用 canvasStore 的 setTool 方法实现，更新当前选择的工具类型并清除选中状态。\n7. 特殊处理与优化7.1 表单元素兼容性处理为了避免在输入框等表单元素中意外触发快捷键，所有快捷键都配置了以下选项：\n{  enableOnFormTags: false,  ignoreEventWhen: (event) =&gt; event.target instanceof HTMLInputElement,}\n7.2 粘贴偏移处理为了区分多次粘贴的元素，每次粘贴时会给新元素添加一个随机偏移量：\nconst randomSign = Math.random() &gt; 0.5 ? 1 : -1 // 随机选择正负const randomOffset = Math.random() * 20 // 0-20的随机偏移量// ...x: element.x + randomOffset * randomSign,y: element.y + randomOffset * randomSign,\nTODO:后续会新增一个自定义快捷键功能\n","categories":["归档"]},{"title":"2025-11-21-canvas项目杂记","url":"/Arknight-notes/posts/14933.html","content":"分析要做的就是一个类 Canva / Figma 的在线图形绘板，完整需求优先级和覆盖范围如下：\n\n\n\n\n优先级\n功能模块\n具体需求\n是否必须\n难度\n\n\n\n\nP0\n基础渲染\n矩形、圆形、三角形任意填充色、边框色、边框宽度、圆角、透明度\nYes\n★☆\n\n\nP0\n图片支持\n上传 png/jpg/webp，任意缩放、圆角、模糊、灰度、亮度调节、裁剪掩模\nYes\n★★\n\n\nP0\n富文本\n字体、字号、颜色、加粗、斜体、下划线、删除线、文本背景色、文字对齐、行距、局部样式支持\nYes\n★★★★\n\n\nP0\n基本交互\n单选、多选（框选 + Shift）、拖拽、删除、复制粘贴、缩放把手（8 个方向）、旋转把手\nYes\n★★\n\n\nP0\n无限画布 + 缩放平移\nCtrl+滚轮缩放、空格拖拽平移、无限滚动\nYes\n★☆\n\n\nP0\n数据持久化\n自动 localStorage 保存、打开页面自动恢复\nYes\n★☆\n\n\nP1\n高级交互\n组合（Group）、解散组合、图层排序、辅助对齐线、吸附、旋转任意角度\nYes\n★★★\n\n\nP1\n工具栏 &amp; 属性面板\n顶部工具栏（切换文本/形状/图片模式）、右侧属性面板实时编辑属性\nYes\n★★\n\n\nP1\n历史记录\nUndo / Redo（支持跨会话）\nYes\n★★\n\n\nP1\n性能要求\n100 个复杂元素（图片+富文本）打开 &lt; 3s，拖拽 60fps 不闪烁\nYes\n★★★★\n\n\nP2\n未来可扩展\n实时协同编辑、离线编辑、模板库、导出 PNG/SVG/PDF、激光笔、箭头、自由画笔等\nNo\n★★★★\n\n\n\n\n架构方案\n渲染层：PixiJS (WebGL) 处理高性能图形渲染 + HTML DOM 处理文本编辑/输入框。\n状态管理：Zustand / Pinia (管理庞大的 JSON 画布数据)。\n逻辑层：自定义 Class 结构（如  Shape, Tool, History）实现面向对象编程。\n\n二、项目设计要素\n\n\n\n设计维度\n推荐技术方案\n\n\n\n\n\n1. 渲染引擎\nPixiJS v8（WebGL） + HTMLText\nWebGL 抗锯齿完美 + 高分屏不模糊；HTMLText 是目前唯一能轻松实现富文本局部样式的方案\n\n\n2. 状态管理\nZustand（或 Jotai + signals）\n轻量、响应式、支持中间件（持久化、历史栈）\n\n\n3. 元素对象缓存\nMap 永久缓存（一个元素一个 Container，永不 destroy）\n彻底解决闪烁、拖拽中断、光标丢失的根本方案\n\n\n4. 历史栈\nCommand Pattern + structuredClone 快照（每操作记录 before/after）\n简单可靠，支持跨页面 Undo\n\n\n5. 选中/变换系统\n单独的 SelectionManager + TransformHandles（旋转、缩放把手层也缓存）\ntldraw/Figma 标配\n\n\n6. 辅助对齐线\n拖拽时实时遍历所有元素 bounds，差值 &lt; 5px 就吸附并画蓝线\n提升专业感\n\n\n7. 组合（Group）\n元素加 groupId 字段；选中时绘制大虚线框；拖拽/缩放/旋转时整体应用矩阵变换\n必须有，属于 P1 核心\n\n\n8. 数据持久化\nZustand middleware persist + localForage（IndexedDB）\n防止 localStorage 炸掉\n\n\n9. 图片处理\nSprite + Graphics mask（圆角）+ BlurFilter + ColorMatrixFilter\nPixiJS 原生支持\n\n\n10. 架构分层\n- store（纯数据） - rendering（Pixi 元素缓存 &amp; 更新） - interaction（拖拽、选中逻辑） - ui（React 面板）\n\n\n\n\ninstalled pixi.js@8.14.3installed zustand@5.0.8installed nanoid@5.1.6\n数据驱动视图”（Data-Driven View）  模式，采用了  React (UI) + Zustand (数据) + PixiJS (渲染)  的三层分离架构\n这种架构的核心理念是：PixiJS 实例不保存“业务状态”，它只是 Zustand 数据的“投影”\n\n其中，\n\nReact 只负责 UI 和事件入口\nZustand 是唯一的真实数据源（纯 JSON，可持久化、可协同）\nPixiJS 层只做“渲染 + 交互计算”，所有对象永久缓存（Map），绝不每帧重建\n所有变换（拖拽、缩放、旋转、组合）都在 Pixi 层完成，最后再同步回 Zustand（单向数据流）\n\n三层架构详解第一层：数据层 (The Source of Truth) - canvasStore.ts这是整个应用的大脑。\n\n职责：只存储纯 JSON 数据（Serializable），不包含任何 UI 实例或 Pixi 对象。\n存储内容：\nelements: 一个 Map 对象（Record），存储所有矩形、圆形的坐标、颜色等。\nselectedIds: 当前选中的 ID 列表。\ntool: 当前使用的工具。\n\n\n特点：\n单一数据源：画布上显示什么，完全由这里的数据决定。\n无副作用：这里的 Action 只修改数据，不直接操作 DOM 或 Canvas。\n\n\n\n第二层：适配层 (The Bridge) - StageManager.ts这是连接 React/Zustand 和 PixiJS 的胶水层，也是架构中最复杂的部分。\n\n职责：将“声明式”的数据（Zustand）转换为“命令式”的 Pixi 调用。\n核心机制 - 增量更新 (Diffing)：\n它维护了一个  spriteMap (Map)。\n订阅 (Subscribe)：它监听 Store 的变化。\n同步 (Sync/Render Loop)：\nCreate: Store 有 ID，Map 里没有 -&gt; new PIXI.Graphics()。\nUpdate: Store 有，Map 里也有 -&gt; 更新  x, y, width, color。\nDelete: Store 没有，Map 里有 -&gt; destroy()。\n\n\n\n\n事件转换：\n它监听 Pixi 的  pointerdown/move/up  事件，将屏幕坐标转换为逻辑坐标，然后调用 Store 的 Action。\n\n\n\n第三层：视图层 (The Container) - Canvas.tsx这是 React 组件层。\n\n职责：\n提供  div  容器供 Pixi 挂载。\n渲染 HTML UI（工具栏、属性面板）。\n生命周期管理：组件 Mount 时初始化  StageManager，Unmount 时销毁。\n\n\n\n—-\n3. 关键数据流转 (Data Flow)让我们以  “拖拽矩形移动”  为例，看数据如何在架构中流转：\nInput (输入):\n\n用户在画布上按住矩形并移动鼠标。\nStageManager  的  onPointerMove  被触发。\n\nLogic (逻辑处理):\n\nStageManager  计算鼠标的偏移量  (dx, dy)。\n它不直接修改 Pixi 图形的  graphics.x (这是关键！)。\n它调用  store.updateElement(id, { x: newX, y: newY })。\n\nState Update (状态更新):\n\nZustand Store 更新内部的 JSON 数据。\nZustand 触发订阅回调 (subscribe)。\n\nRender Sync (渲染同步):\n\nStageManager  的  render  方法被调用。\n它从  spriteMap  找到对应的 Pixi 实例。\n执行  graphic.position.set(newX, newY)。\nPixiJS 在下一个  requestAnimationFrame  自动重绘 Canvas。\n\n—-\n4. 为什么选择这种架构？优点：解耦 (Decoupling)：渲染引擎可以随时替换（比如换成 Konva 或原生 Canvas），只需要重写  StageManager，数据层和 UI 层不需要动。\n协同编辑 (Collaboration) 友好：\n\n如果要实现多入协同，只需要监听 WebSocket 消息，然后更新 Zustand Store。StageManager  会自动把队友的操作画出来，无需写额外的同步绘图逻辑。撤销/重做 (Undo/Redo) 容易：\n因为所有状态都在 Store 里，只需要保存/恢复 Store 的快照（或 Patch）即可。序列化/反序列化：\n保存项目只需  JSON.stringify(store.elements)。\n\n潜在挑战（及优化方案）：性能瓶颈：\n\n问题：高频触发  Store Update -&gt; Diff  循环可能在元素极多时（&gt;2000 个）产生开销。\n优化：对于拖拽这种 60FPS 的操作，可以引入“临时层” (Transient State)。即拖拽时直接修改 Pixi 对象，鼠标松开时再同步到 Store。复杂性：\n相比直接用 Canvas API 画图，这种架构代码量更大，需要维护 ID 映射和 Diff 逻辑。\n\nfeat(canvas): 重构画布实现，应项目要求，删除了基于tldraw的实现转而选择PixiJS 库重构以进行渲染操作，基于Zustand 进行状态管理。新增的文件中canvasStore.ts主要负责维护整个画布项目的全局可序列化状态，是渲染画布系统中唯一数据来源。Pixi_stageManager.ts 负责将声明式数据（Zustand）实时、高性能地映射为命令式渲染实例（PixiJS），并处理所有用户交互的计算与反馈。canvas下的index.ts最轻量的一层，仅负责生命周期管理与组件组装。三层数据驱动架构详情可见文档\n","categories":["归档"]},{"title":"2025-11-23-canvas项目相关-视口管理机制","url":"/Arknight-notes/posts/12487.html","content":"1. 模块摘要 (Executive Summary)视口管理机制是画布应用中实现无限画布、缩放、拖拽等交互功能的核心模块。它基于 pixi-viewport 库实现，提供了完整的视口控制功能，包括平移、缩放、手势控制等。实现了管理画布视口、处理用户交互、实现无限画布功能\n\n项目结构树：\nsrc/└── pages/    └── canvas/        └── Pixi_STM_modules/            └── core/                └── StageManagerCore.ts    # 视口管理核心实现\n\npixi-viewport：视口管理库，提供平移、缩放、手势等交互功能\nPixiJS：WebGL 渲染引擎，作为视口的渲染基础\nTypeScript：提供类型安全和代码可维护性\n\n\n\n2. 视口管理机制类型定义2.1 Viewport 相关配置pixi-viewport 库的主要配置参数：\ninterface ViewportOptions {  screenWidth: number; // 视口宽度  screenHeight: number; // 视口高度  worldWidth: number; // 世界宽度  worldHeight: number; // 世界高度  events: any; // 事件系统}\n2.2 视口交互配置pixi-viewport 支持的交互配置：\n\n\n\n\n方法\n描述\n\n\n\n\ndrag()\n启用拖拽功能\n\n\npinch()\n启用捏合缩放功能\n\n\nwheel()\n启用滚轮缩放功能\n\n\nclampZoom()\n限制缩放范围\n\n\ndecelerate()\n启用惯性滚动\n\n\n\n\n3. 视口管理机制架构3.1 内部状态 (Local State)视口管理机制维护以下内部状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nviewport\nViewport\npixi-viewport 实例\n\n\napp\nPIXI.Application\nPixiJS 应用实例\n\n\nelementLayer\nPIXI.Container\n元素图层容器\n\n\nuiLayer\nPIXI.Container\nUI 图层容器\n\n\n\n\n3.2 外部依赖 (External Dependencies)视口管理机制依赖以下外部组件：\n\n\n\n\n组件\n类型\n描述\n\n\n\n\nHTML Container\nHTMLElement\n用于挂载 PixiJS 画布的 DOM 元素\n\n\nElementRenderer\nElementRenderer\n元素渲染器\n\n\nTransformerRenderer\nTransformerRenderer\n变换控制器渲染器\n\n\n\n\n3.3 视口管理流程graph TD    A[初始化 StageManager] --&gt; B{创建 PIXI.Application}    B --&gt; C[初始化视口]    C --&gt; D[配置视口交互]    D --&gt; E[添加图层]    E --&gt; F[挂载到 DOM]    F --&gt; G[处理用户交互]    G --&gt; H[更新视口状态]    H --&gt; I[重新渲染元素]        style A fill:#e1f5fe    style C fill:#f3e5f5    style D fill:#fff3e0    style G fill:#e8f5e8\n4. 视口初始化与配置4.1 视口初始化流程sequenceDiagram    participant SM as StageManager    participant PA as PixiJS Application    participant PV as pixi-viewport    participant DOM as HTML Container        SM-&gt;&gt;PA: 创建 PIXI.Application    PA-&gt;&gt;SM: 返回应用实例    SM-&gt;&gt;PV: 创建 Viewport 实例    PV-&gt;&gt;SM: 返回视口实例    SM-&gt;&gt;PV: 配置视口交互    SM-&gt;&gt;PA: 添加视口到舞台    SM-&gt;&gt;DOM: 挂载画布到 DOM\n4.2 核心函数解析setupViewport 函数：在 StageManager 初始化时调用，创建并配置 pixi-viewport 实例，设置交互功能\nprivate setupViewport(container: HTMLElement) {  // 创建视口实例  this.viewport = new Viewport({    screenWidth: container.clientWidth,    screenHeight: container.clientHeight,    worldWidth: 1000,    worldHeight: 1000,    events: this.app.renderer.events,  })  // 添加视口到 Pixi 舞台  this.app.stage.addChild(this.viewport)  // 配置视口交互功能  this.viewport    .drag({ mouseButtons: 'middle' })  // 鼠标中键拖拽    .pinch()                           // 触摸捏合缩放    .wheel()                           // 滚轮缩放}\n5. 视口交互功能5.1 拖拽功能用户可以通过鼠标中键拖拽画布，实现视口平移：\n// 鼠标中键拖拽this.viewport.drag({ mouseButtons: \"middle\" });// 空格键+左键拖拽（手型工具）this.viewport.drag({ mouseButtons: \"all\" });\n5.2 缩放功能支持多种缩放方式：\n\n滚轮缩放：\nthis.viewport.wheel(); // 鼠标滚轮缩放\n\n手势缩放：\nthis.viewport.pinch(); // 触摸设备捏合缩放\n\n\n5.3 视口状态更新根据当前工具和用户操作更新视口状态：\npublic updateViewportState(tool: ToolType) {  if (!this.viewport) return  const isHandMode = tool === 'hand' || this.state.isSpacePressed  if (isHandMode) {    // 手型工具或按下空格键时，启用全键拖拽    this.viewport.drag({ mouseButtons: 'all' })    this.viewport.cursor = 'grab'  } else {    // 默认情况下，仅启用中键拖拽    this.viewport.drag({ mouseButtons: 'middle' })    this.viewport.cursor = 'default'  }}\n6. UI 与样式实现6.1 视口层次结构视口内部采用分层结构管理不同类型的元素：\ngraph TD    A[Viewport] --&gt; B[elementLayer]    A --&gt; C[uiLayer]    B --&gt; D[图形元素]    B --&gt; E[文本元素]    B --&gt; F[图像元素]    C --&gt; G[选区框]    C --&gt; H[橡皮擦指示器]    C --&gt; I[变换控制器]        style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#e8f5e8    style D fill:#fff3e0    style E fill:#fff3e0    style F fill:#fff3e0    style G fill:#ffebee    style H fill:#ffebee    style I fill:#ffebee\n6.2 光标样式管理根据不同状态和工具显示不同的光标样式：\n\n\n\n\n状态/工具\n光标样式\n\n\n\n\n默认状态\ndefault\n\n\n手型工具\ngrab\n\n\n拖拽中\ngrabbing\n\n\n选择工具\ndefault\n\n\n绘制工具\ncrosshair\n\n\n\n\n","categories":["归档"],"tags":["前端开发","PixiJS","视口管理"]},{"title":"2025-11-23-canvas项目相关-状态管理层","url":"/Arknight-notes/posts/61173.html","content":"1. 模块摘要 (Executive Summary)状态管理层管理画布元素数据、选中状态、工具状态、剪贴板数据等核心业务数据，是整个画布应用的数据核心，负责维护所有画布元素的状态信息和用户交互相关的全局状态。它采用了 Zustand 作为状态管理库，实现了数据的集中管理和状态变更的响应式更新\n\n项目结构树：\nsrc/└── stores/    └── canvasStore.ts        # Zustand 状态管理核心文件\n\nZustand：轻量级状态管理库，用于管理全局状态\nnanoid：用于生成唯一 ID\nstructuredClone：用于深拷贝状态数据\n\n\n\n2. Props 和相关类型定义2.1 useStore 参数状态管理模块通过 useStore Hook 提供状态访问和更新功能。\n\n\n\n\n参数名\n类型\n必填\n默认值\n描述\n\n\n\n\nsetTool\nFunction\n是\n无\n设置当前使用的工具类型\n\n\naddElement\nFunction\n是\n无\n添加新元素到画布\n\n\nupdateElement\nFunction\n是\n无\n更新指定元素的属性\n\n\nremoveElements\nFunction\n是\n无\n从画布中移除指定元素\n\n\nsetSelected\nFunction\n是\n无\n设置当前选中的元素\n\n\nsetEditingId\nFunction\n是\n无\n设置当前正在编辑的元素\n\n\ncopyElements\nFunction\n是\n无\n复制指定元素到剪贴板\n\n\npasteElements\nFunction\n是\n无\n从剪贴板粘贴元素到画布\n\n\n\n\n代码示例：\n// 设置工具类型useStore.getState().setTool(\"rect\");// 添加元素useStore.getState().addElement({  id: \"element1\",  type: \"rect\",  x: 100,  y: 100,  width: 200,  height: 150,  fill: \"#ff0000\",  stroke: \"#000000\",  strokeWidth: 2,});// 更新元素useStore.getState().updateElement(\"element1\", { fill: \"#00ff00\" });// 移除元素useStore.getState().removeElements([\"element1\"]);\n2.2 核心类型定义CanvasElement 类型：定义了画布上所有元素的基本属性和可选属性。\ninterface CanvasElement {  id: string; // 元素唯一标识符  type: ToolType; // 元素类型  x: number; // 元素左上角 x 坐标  y: number; // 元素左上角 y 坐标  width: number; // 元素宽度  height: number; // 元素高度  fill: string; // 填充颜色  stroke: string; // 描边颜色  strokeWidth: number; // 描边宽度  alpha?: number; // 透明度  points?: number[][]; // 点坐标数组（用于线条类元素）  rotation?: number; // 旋转角度（弧度制）  text?: string; // 文本内容（HTML 格式）  fontSize?: number; // 字体大小  fontFamily?: string; // 字体族  textAlign?: \"left\" | \"center\" | \"right\"; // 文本对齐方式  imageUrl?: string; // 图片 URL  filter?: \"none\" | \"blur\" | \"brightness\" | \"grayscale\"; // 图片滤镜  radius?: number; // 圆角半径}\nToolType 类型：定义了用户可选择的工具类型。\ntype ToolType =  | \"select\" // 选择工具  | \"hand\" // 手型工具  | \"rect\" // 矩形工具  | \"circle\" // 圆形工具  | \"triangle\" // 三角形工具  | \"diamond\" // 菱形工具  | \"line\" // 直线工具  | \"arrow\" // 箭头工具  | \"pencil\" // 铅笔工具  | \"text\" // 文本工具  | \"image\" // 图片工具  | \"eraser\"; // 橡皮擦工具\n3. 核心状态管理 (State Architecture)状态管理层维护以下内部状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\ntool\nToolType\n当前选中的工具类型\n\n\nelements\nRecord&lt;string, [CanvasElement](/src/pages/canvas/Pixi_STM_modules/core/types.ts#L15-L15)&gt;\n所有画布元素的集合\n\n\nselectedIds\nstring[]\n当前选中的元素 ID 数组\n\n\neditingId\nstring \\\nnull\n当前正在编辑的元素 ID\n\n\nclipboard\nCanvasElement[] \\\nnull\n剪贴板数据\n\n\npasteOffset\nnumber\n粘贴偏移计数\n\n\ncurrentStyle\nObject\n当前样式设置\n\n\n\n\n3.3 状态同步机制graph TD    A[Zustand Store 状态变更] --&gt; B{订阅者监听}    B --&gt; C[StageManager 订阅]    B --&gt; D[UI 组件订阅]    C --&gt; E[触发渲染层更新]    D --&gt; F[触发 UI 更新]        style A fill:#e1f5fe    style E fill:#e8f5e8    style F fill:#fff3e0\n4. 逻辑流程 (Logic Flow)4.1 交互时序图 (Mermaid)sequenceDiagram    participant U as 用户    participant C as CanvasStore    participant SM as StageManager    participant R as 渲染层        U-&gt;&gt;C: 调用 Action (如 addElement)    C-&gt;&gt;C: 更新内部状态    C-&gt;&gt;SM: 通知状态变更    SM-&gt;&gt;R: 触发重新渲染    R-&gt;&gt;R: 更新 PIXI 对象    R-&gt;&gt;U: 显示更新结果\n4.2 核心函数addElement 函数：当用户创建新元素时调用，创建新元素并添加到 elements 集合中\naddElement: (el) =&gt;  originalSet((state) =&gt; ({    elements: { ...state.elements, [el.id]: el },  }));\nupdateElement 函数：当用户修改元素属性时调用，更新指定元素的属性并保持其他元素不变\nupdateElement: (id, attrs) =&gt;  originalSet((state) =&gt; {    if (!state.elements[id]) return state;    return {      elements: {        ...state.elements,        [id]: { ...state.elements[id], ...attrs },      },    };  });\n状态管理层作为纯数据层，不直接涉及 UI 和样式实现，但为上层 UI 提供了必要的状态支持，通过状态结构支持上层组件的布局逻辑和状态中的样式属性支持上层组件的样式实现\n","categories":["归档"],"tags":["前端开发","Zustand"]},{"title":"2025-11-23-canvas项目相关-富文本文本元素处理机制","url":"/Arknight-notes/posts/61908.html","content":"1. 模块摘要 (Executive Summary)富文本文本元素处理机制是画布应用中实现文本元素创建、编辑和渲染的核心功能模块。它结合了 WangEditor 5 富文本编辑器和 PixiJS 的 HTMLText 组件，实现了所见即所得的文本编辑体验。用户可以通过工具栏创建文本元素，在画布上直接选中编辑，或通过底部的富文本编辑器进行详细编辑。\n\n项目结构树：\nsrc/├── components/│   ├── Richtext_editor/│   │   ├── Richtext_editor.tsx      # 富文本编辑器组件│   │   └── BottomTextEditor.tsx     # 底部文本编辑器└── pages/    └── canvas/        └── Pixi_STM_modules/            └── rendering/                └── ElementRenderer.ts   # 文本元素渲染器\n\nWangEditor 5：富文本编辑器，提供文本编辑功能\nPIXI.HTMLText：PixiJS 组件，用于在画布上渲染 HTML 文本\nZustand：状态管理，存储文本元素数据\n\n\n\n2. 文本处理机制类型定义2.1 CanvasElement 文本相关属性CanvasElement 接口中与文本相关的属性定义：\ninterface CanvasElement {  // ... 其他通用属性  type: \"text\"; // 元素类型为文本  text?: string; // 存储 HTML 字符串  fontSize?: number; // 字体大小  fontFamily?: string; // 字体族  textAlign?: \"left\" | \"center\" | \"right\"; // 文本对齐方式}\n2.2 富文本编辑器组件 Props富文本编辑器组件的属性定义：\n\n\n\n\n属性名\n类型\n必填\n描述\n\n\n\n\nvalue\nstring\n是\n当前文本内容（HTML 格式）\n\n\nonChange\n(value: string) =&gt; void\n是\n文本内容变化回调\n\n\nclassName\nstring\n否\n自定义 CSS 类名\n\n\n\n\n3. 文本处理机制架构3.1 内部状态 (Local State)文本处理机制涉及多个组件的内部状态：\n\n\n\n\n组件\n状态名\n类型\n描述\n\n\n\n\nBottomTextEditor\nlocalHtml\nstring\n本地中间状态，用于解决输入法冲突\n\n\nElementRenderer\nspriteMap\nMap\n元素 ID 到显示对象的映射\n\n\nRichTextEditor\neditor\nIDomEditor\nWangEditor 编辑器实例\n\n\n\n\n3.2 外部依赖 (External Dependencies)文本处理机制依赖以下外部组件：\n\n\n\n\n组件\n类型\n描述\n\n\n\n\nZustand Store\nCanvasState\n存储文本元素数据\n\n\nPixiJS\nHTMLText\n渲染文本元素\n\n\nWangEditor\nEditor, Toolbar\n提供富文本编辑功能\n\n\n\n\n3.3 文本处理流程graph TD    A[创建文本元素] --&gt; B{ElementRenderer}    B --&gt; C[创建HTMLText对象]    C --&gt; D[渲染到画布]    D --&gt; E[用户选中文本元素]    E --&gt; F{编辑方式}    F --&gt;|直接编辑| G[画布上直接编辑]    F --&gt;|底部编辑器| H[BottomTextEditor显示]    H --&gt; I[WangEditor编辑器]    I --&gt; J[文本内容更新]    J --&gt; K[Zustand Store更新]    K --&gt; B        style A fill:#e1f5fe    style D fill:#e8f5e8    style H fill:#fff3e0    style I fill:#fff3e0    style K fill:#f3e5f5\n4. 文本元素处理流程4.1 文本元素创建用户可以通过工具栏创建文本元素：\nsequenceDiagram    participant U as 用户    participant TB as TopToolbar    participant SM as StageManager    participant ZS as Zustand Store    participant ER as ElementRenderer        U-&gt;&gt;TB: 点击文本工具    TB-&gt;&gt;TB: 设置工具为text    U-&gt;&gt;SM: 在画布上点击    SM-&gt;&gt;ZS: 添加文本元素    ZS-&gt;&gt;ER: 触发重新渲染    ER-&gt;&gt;ER: 创建HTMLText对象    ER-&gt;&gt;ER: 设置文本样式    ER-&gt;&gt;ER: 添加到画布\n4.2 文本元素渲染ElementRenderer 负责将文本元素数据渲染为可视化的 HTMLText 对象：\n// 处理 Text 类型 (HTMLText)if (data.type === \"text\") {  // 创建或更新 HTMLText 对象  if (!graphic) {    graphic = new HTMLText({      text: \"\",      style: {        wordWrap: true,        breakWords: true,      },    });    // 设置标签和事件模式    graphic.label = id;    graphic.eventMode = \"static\";    graphic.cursor = \"move\";    elementLayer.addChild(graphic);    this.spriteMap.set(id, graphic);  }  const textObj = graphic as HTMLText;  // 设置文本内容  const htmlContent =    data.text || '&lt;span style=\"color:#cccccc\"&gt;请输入文本&lt;/span&gt;';  if (textObj.text !== htmlContent) {    textObj.text = htmlContent;  }  // 设置样式  textObj.style = {    wordWrap: true,    wordWrapWidth: data.width || 400,    fontSize: data.fontSize || 20,    fontFamily: data.fontFamily || \"Arial\",    fill: data.fill || \"#000000\",    align: data.textAlign || \"left\",    cssOverrides: [\"p { margin: 0; padding: 0; }\", \"span { display: inline; }\"],  };  textObj.position.set(data.x, data.y);}\n4.3 文本编辑处理\n当用户选中文本元素时，底部自动显示富文本编辑器，使用编辑功能时编辑内容实时同步到 Zustand Store用户可以直接在画布上选中文本元素进行位置调整，也可以用变换控制器调整文本元素的尺寸和位置\n5. 核心组件解析5.1 ElementRenderer 文本渲染ElementRenderer 负责将文本元素数据渲染为可视化的 HTMLText 对象：\n当画布元素数据发生变更时触发，检查是否存在对应的 HTMLText 对象，如不存在则创建，否则更新其内容和样式\n// 处理 Text 类型元素else if (data.type === 'text') {  // 如果之前的 sprite 不是 HTMLText，销毁重建  if (graphic &amp;&amp; !(graphic instanceof HTMLText)) {    elementLayer.removeChild(graphic)    graphic.destroy({ children: true })    graphic = undefined  }    if (!graphic) {    // 创建 HTMLText    graphic = new HTMLText({      text: '',      style: {        wordWrap: true,        breakWords: true,      },    })    // ... 设置属性  }  const textObj = graphic as HTMLText  // 更新文本内容和样式}\n5.2 BottomTextEditor 底部编辑器BottomTextEditor 是一个 React 组件，当用户选中文本元素时自动显示在底部：\n当 Zustand Store 中的 selectedIds 变化且选中单个文本元素时显示，监听选中元素变化，同步元素文本内容到本地状态，通过 WangEditor 编辑后更新 Store\n// 当选中元素改变时，同步 Store 的值到本地状态useEffect(() =&gt; {  if (element &amp;&amp; element.type === \"text\") {    setLocalHtml(element.text || \"\");  }}, [element?.id, element?.text]);const handleChange = (html: string) =&gt; {  setLocalHtml(html);  // 实时更新 Store，驱动 Canvas 重新渲染  updateElement(element.id, { text: html });};\n5.3 RichTextEditor 富文本编辑器RichTextEditor 封装了 WangEditor 的功能，提供富文本编辑功能，包括加粗、斜体、下划线、字体、颜色等通过 toolbarConfig 和 editorConfig 配置编辑器功能\n// 工具栏配置：仅保留基础文本样式const toolbarConfig: Partial&lt;IToolbarConfig&gt; = {  toolbarKeys: [    \"bold\",    \"italic\",    \"underline\",    \"through\",    \"|\",    \"fontSize\",    \"fontFamily\",    \"color\",    \"bgColor\",    \"|\",    \"justifyLeft\",    \"justifyCenter\",    \"justifyRight\",    \"|\",    \"undo\",    \"redo\",  ],};\n6. UI 与 文本渲染样式实现文本元素通过 PIXI.HTMLText 渲染，支持 HTML 标签和内联样式：\ngraph TD    A[文本元素] --&gt; B[HTMLText对象]    B --&gt; C[解析HTML内容]    C --&gt; D[应用CSS样式]    D --&gt; E[渲染到画布]        style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#fff3e0    style D fill:#e8f5e8    style E fill:#e1f5fe\n\n","categories":["归档"],"tags":["前端开发","PixiJS","富文本"]},{"title":"2025-11-23-canvas项目相关-逻辑层","url":"/Arknight-notes/posts/62457.html","content":"1. 模块摘要 (Executive Summary)逻辑层是整个画布应用的中枢神经系统，负责协调状态管理层和渲染层之间的交互。它通过 StageManagerCore 类实现，主要处理用户交互、协调状态更新、管理渲染流程、维护交互状态\n\n项目结构树：\nsrc/└── pages/    └── canvas/        ├── Pixi_stageManager.ts               # StageManager 入口文件        └── Pixi_STM_modules/                  # StageManager 模块目录            ├── core/            │   ├── StageManagerCore.ts        # 核心类            │   └── types.ts                   # 类型定义文件            ├── rendering/            │   ├── ElementRenderer.ts         # 元素渲染器            │   └── TransformerRenderer.ts     # 变换控制器渲染器            ├── interaction/            │   └── InteractionHandler.ts      # 交互处理器            └── utils/                └── cursorUtils.ts             # 光标工具函数\n\nPixiJS：WebGL 渲染引擎，负责图形渲染\npixi-viewport：视口管理插件，处理画布缩放和平移\nZustand：状态管理库，与状态管理层对接\nnanoid：用于生成唯一 ID\n\n\n\n2. Props 和相关类型定义2.1 StageManagerCore 构造函数参数StageManagerCore 类通过构造函数接收容器元素参数。\n\n\n\n\n参数名\n类型\n必填\n默认值\n描述\n\n\n\n\ncontainer\nHTMLElement\n是\n无\n用于挂载 PixiJS 应用的 DOM 容器\n\n\n\n\n代码示例：\n// 创建 StageManager 实例const stageManager = new StageManagerCore(containerElement);\n2.2 核心类型定义StageManagerState 类型：定义了 StageManager 的核心状态。\ninterface StageManagerState {  mode: InteractionMode; // 当前交互模式  startPos: { x: number; y: number }; // 起始坐标  currentId: string | null; // 当前操作元素 ID  initialElementsMap: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; | null; // 初始元素映射  initialGroupBounds: {    x: number;    y: number;    width: number;    height: number;  } | null; // 初始群组边界  initialElementState: Partial&lt;CanvasElement&gt; | null; // 初始元素状态  resizeInitialStates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; | null; // 调整大小初始状态  dragInitialStates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; | null; // 拖拽初始状态  activeHandle: HandleType | null; // 激活的手柄  isSpacePressed: boolean; // 空格键是否按下  destroyed: boolean; // 是否已销毁}\nInteractionMode 类型：定义了用户与画布交互的各种模式。\ntype InteractionMode =  | \"idle\" // 空闲状态  | \"panning\" // 画布平移  | \"selecting\" // 选择元素  | \"dragging\" // 拖拽元素  | \"resizing\" // 调整元素大小  | \"drawing\" // 绘制元素  | \"texting\" // 文本编辑  | \"erasing\"; // 擦除元素\n3. 核心状态管理 (State Architecture)3.1 内部状态 (Local State)StageManagerCore 维护以下内部状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\napp\nPIXI.Application\nPixiJS 应用实例\n\n\nviewport\nViewport\npixi-viewport 实例\n\n\nelementLayer\nPIXI.Container\n元素图层容器\n\n\nuiLayer\nPIXI.Container\nUI 图层容器\n\n\nelementRenderer\nElementRenderer\n元素渲染器实例\n\n\ntransformerRenderer\nTransformerRenderer\n变换控制器渲染器实例\n\n\ninteractionHandler\nInteractionHandler\n交互处理器实例\n\n\nstate\nStageManagerState\n交互状态对象\n\n\nselectionRectGraphic\nPIXI.Graphics\n选区框图形对象\n\n\neraserGraphic\nPIXI.Graphics\n橡皮擦指示器图形对象\n\n\n\n\n3.2 外部状态 (Global/Server State)逻辑层通过 Zustand 状态管理库订阅外部状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nelements\nRecord\n所有画布元素数据\n\n\nselectedIds\nstring[]\n当前选中的元素 ID 数组\n\n\ntool\nToolType\n当前工具类型\n\n\n\n\n3.3 状态同步机制graph TD    A[Zustand Store 状态变更] --&gt; B{StageManager 订阅}    B --&gt; C{状态处理}    C --&gt; D[ElementRenderer.renderElements]    C --&gt; E[TransformerRenderer.renderTransformer]    C --&gt; F[更新视口状态]    C --&gt; G[更新光标样式]    D --&gt; H[PixiJS 渲染元素]    E --&gt; I[PixiJS 渲染变换控制器]        style A fill:#e1f5fe    style H fill:#e8f5e8    style I fill:#e8f5e8    style F fill:#fff3e0    style G fill:#fff3e0\n4. 逻辑流程 (Logic Flow)4.1 交互时序图 (Mermaid)sequenceDiagram    participant U as 用户    participant SM as StageManagerCore    participant IH as InteractionHandler    participant ZS as Zustand Store    participant ER as ElementRenderer    participant TR as TransformerRenderer        U-&gt;&gt;IH: 触发交互事件 (点击/拖拽等)    IH-&gt;&gt;SM: 调用处理函数 (onPointerDown等)    SM-&gt;&gt;SM: 更新内部状态 (mode, startPos等)    SM-&gt;&gt;ZS: 更新画布数据 (addElement等)    ZS-&gt;&gt;SM: 通知状态变更    SM-&gt;&gt;ER: 调用renderElements()    SM-&gt;&gt;TR: 调用renderTransformer()    ER-&gt;&gt;ER: 更新 PIXI 元素    TR-&gt;&gt;TR: 更新变换控制器\n4.2 核心函数解析onPointerDown 函数：当用户在画布上按下鼠标时触发，根据当前工具和点击位置处理不同的交互逻辑（选择、绘制、拖拽等）\nprivate onPointerDown = (e: PIXI.FederatedPointerEvent) =&gt; {  // 处理防抖  this.triggerDebounceSnapshot()  // 获取当前状态  const state = useStore.getState()  const tool = state.tool  const worldPos = e.getLocalPosition(this.viewport)  // 根据工具类型处理不同逻辑  if (tool === 'text') {    // 处理文本工具  } else if (tool === 'eraser') {    // 处理橡皮擦工具  } else if (e.target &amp;&amp; e.target.label) {    // 处理元素点击  } else {    // 处理绘制或选择  }}\nonPointerMove 函数：当用户在画布上移动鼠标时触发，根据当前交互模式处理不同的移动逻辑（绘制、拖拽、调整大小等）\nprivate onPointerMove = (e: PIXI.FederatedPointerEvent) =&gt; {  // 处理防抖  this.triggerDebounceSnapshot()  if (this.state.mode === 'idle') return  const state = useStore.getState()  const currentPos = e.getLocalPosition(this.viewport)  switch (this.state.mode) {    case 'selecting':      // 处理选择框绘制      break    case 'erasing':      // 处理橡皮擦操作      break    case 'dragging':      // 处理元素拖拽      break    case 'resizing':      // 处理元素调整大小      break    case 'drawing':      // 处理元素绘制      break  }}\n5. UI 与样式实现 (UI Implementation)逻辑层通过管理不同图层来实现 UI 布局：\ngraph TD    A[Viewport] --&gt; B[elementLayer]    A --&gt; C[uiLayer]    B --&gt; D[图形元素]    C --&gt; E[选区框]    C --&gt; F[橡皮擦指示器]    C --&gt; G[变换控制器]        style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#e8f5e8    style D fill:#fce4ec    style E fill:#fff3e0    style F fill:#fff3e0    style G fill:#fff3e0\n使用 PixiJS 的容器系统管理图层，分为元素层和 UI 层，通过 PIXI.Graphics API 实现图形绘制，通过 CSS 控制光标样式\n","categories":["归档"],"tags":["前端开发","PixiJS"]},{"title":"2025-11-23-canvas项目相关-渲染层","url":"/Arknight-notes/posts/8350.html","content":"1. 模块摘要 (Executive Summary)渲染层是基于 PixiJS 构建的可视化层，负责将存储在 Zustand 状态管理器中的画布元素数据转化为可视化的图形界面，并处理用户的交互操作。它主要包括元素渲染（ElementRenderer）和变换控制器渲染（TransformerRenderer）两大部分，分别负责绘制元素本身和元素的选中状态、控制手柄等辅助 UI。\n其项目结构树如下：\nsrc/└── pages/    └── canvas/        ├── Pixi_stageManager.ts               # 整合StageManager各模块的入口文件        ├── index.tsx                          # 画布页面组件，整合渲染层到React组件中        └── Pixi_STM_modules/                  # StageManager模块目录            ├── STM_modules.md                 # 模块设计文档            ├── core/            │   ├── StageManagerCore.ts        # 核心类，整合渲染、交互和状态管理            │   └── types.ts                   # 类型定义文件            ├── rendering/            │   ├── ElementRenderer.ts         # 元素渲染器，负责渲染各类画布元素            │   └── TransformerRenderer.ts     # 变换控制器渲染器，负责渲染选中元素的手柄等            ├── interaction/            │   └── InteractionHandler.ts      # 交互处理器，绑定和处理各种交互事件            └── utils/                └── cursorUtils.ts             # 光标工具函数\n该模块主要负责将状态管理层的数据渲染成可视化图形，并处理用户交互反馈\n\npixi.js：WebGL 渲染引擎\npixi-viewport：视口管理插件\nzustand：状态管理库（虽然不是渲染层直接依赖，但与其紧密协作）\n\n2. Props 和相关类型定义渲染层接收来自逻辑层的 props 参数，用于驱动元素渲染和交互控制。这些参数主要包括元素数据、状态信息和事件回调函数。\n2.1 ElementRenderer.renderElements 方法参数ElementRenderer 负责将画布元素数据渲染为 PIXI 可视化对象，其 renderElements 方法接收以下参数：\n\n\n\n\n字段名\n类型\n必填\n默认值\n描述\n\n\n\n\nelements\nRecord\n是\n无\n包含所有画布元素的数据对象\n\n\nelementLayer\nPIXI.Container\n是\n无\n用于承载所有可视元素的容器\n\n\ndestroyed\nboolean\n是\nfalse\n标识组件是否已被销毁\n\n\n\n\n// elements对象结构示例{  \"element1\": {    id: \"element1\",    type: \"rect\",    x: 100,    y: 100,    width: 200,    height: 150,    fill: \"#ff0000\"  },  \"element2\": {    id: \"element2\",    type: \"text\",    x: 50,    y: 50,    width: 300,    height: 100,    text: \"&lt;p&gt;示例文本&lt;/p&gt;\"  }}\nelementLayer: PIXI.Container - PIXI.js 中的容器对象，用于承载所有画布元素的可视化对象。ElementRenderer 会将创建的 PIXI 对象添加到这个容器中，以便在画布上显示。\n// 在StageManagerCore.ts中创建elementLayerprivate elementLayer: PIXI.Container = new PIXI.Container()// 然后传给ElementRendererthis.elementRenderer.renderElements(elements, this.elementLayer, this.state.destroyed)\ndestroyed: boolean - 标识渲染器是否已被销毁。当组件被销毁时，此参数防止在销毁后继续执行渲染操作，避免内存泄漏。\npublic renderElements(elements: Record&lt;string, CanvasElement&gt;, elementLayer: PIXI.Container, destroyed: boolean) {  if (destroyed) return; // 如果已销毁，直接返回不执行渲染  // ... 其他渲染逻辑}\n2.2 TransformerRenderer.renderTransformer 方法参数TransformerRenderer 负责渲染选中元素的变换控制器（手柄、边框等），其 renderTransformer 方法接收以下参数：\n\n\n\n\n参数名\n类型\n描述\n\n\n\n\nelements\nRecord\n所有画布元素的数据\n\n\nselectedIds\nstring[]\n当前选中元素的 ID 数组\n\n\nspriteMap\nMap\n元素 ID 到 PIXI 可视化对象的映射\n\n\nonHandleDown\nFunction\n手柄按下事件的回调函数\n\n\nviewportScale\nnumber\n当前视口的缩放比例\n\n\n\n\nelements: Record - 与 ElementRenderer 中的 elements 相同，提供所有画布元素的数据。TransformerRenderer 需要访问元素数据来计算选中元素的边界框和位置信息。\nselectedIds: string[] - 包含当前选中元素 ID 的数组。TransformerRenderer 根据这个数组决定是否以及如何绘制变换控制器（选中框和手柄）。\n// selectedIds数组示例;['element1', 'element3'] // 表示element1和element3被选中\nspriteMap: Map&lt;string, PIXI.Graphics | PIXI.HTMLText | PIXI.Sprite&gt; - 提供元素 ID 到 PIXI 可视化对象的映射。TransformerRenderer 需要访问实际的 PIXI 对象来准确计算元素的边界（特别是文本元素）。\n// spriteMap结构示例Map(2) {  \"element1\" =&gt; Graphics {},     // 矩形元素的PIXI.Graphics对象  \"element2\" =&gt; HTMLText {}      // 文本元素的PIXI.HTMLText对象}\nonHandleDown: Function - 手柄按下事件的回调函数。当用户点击变换控制器上的手柄时，会调用这个函数开始变换操作（如缩放、旋转）。\n// 在StageManagerCore.ts中定义并传递给TransformerRendererprivate onHandleDown = (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1', elementId: string) =&gt; {  // 处理手柄按下事件  this.state.mode = 'resizing';  this.state.activeHandle = handle as HandleType | null;  // ... 其他逻辑}\nviewportScale: number - 当前视口的缩放比例。TransformerRenderer 使用这个值来调整手柄和控制器的大小，确保在不同缩放级别下都有合适的尺寸。\n// 在StageManagerCore.ts中获取并传递视口缩放比例this.transformerRenderer.renderTransformer(  elements,  selectedIds,  this.elementRenderer.getSpriteMap(),  this.onHandleDown,  this.viewport.scale.x, // 传递视口缩放比例)\n2.3 核心类型定义渲染层涉及到的关键类型定义如下：\nCanvasElement 类型定义了画布元素的基本属性和可选属性：\ninterface CanvasElement {  id: string;  type:    | \"rect\"    | \"circle\"    | \"triangle\"    | \"text\"    | \"image\"    | \"line\"    | \"arrow\"    | \"pencil\";  x: number;  y: number;  width: number;  height: number;  fill: string;  stroke: string;  strokeWidth: number;  // 根据元素类型可能包含额外属性  text?: string; // 文本元素  imageUrl?: string; // 图片元素  points?: number[][]; // 线条/铅笔元素  fontSize?: number; // 文本元素  fontFamily?: string; // 文本元素  alpha?: number; // 透明度  radius?: number; // 圆角矩形}\nHandleType 类型定义了变换控制器上各种手柄的类型：\ntype HandleType =  | \"tl\" // top-left 左上角  | \"t\" // top 顶部中间  | \"tr\" // top-right 右上角  | \"r\" // right 右侧中间  | \"br\" // bottom-right 右下角  | \"b\" // bottom 底部中间  | \"bl\" // bottom-left 左下角  | \"l\" // left 左侧中间  | \"p0\" // 线段起点  | \"p1\" // 线段终点  | \"rotate\"; // 旋转手柄\n3. 核心状态管理 (State Architecture)渲染层采用内外结合的状态管理模式，既维护自身的局部状态，又与外部的 Zustand 状态管理库协同工作。\n3.1 内部状态 (Local State)渲染层维护一组局部状态，用于管理 PIXI 对象和渲染优化：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nspriteMap\n`Map&lt;string, PIXI.Graphics \\\nPIXI.HTMLText \\\nPIXI.Sprite&gt;`\n存储元素 ID 到 PIXI 图形对象的映射关系，用于快速查找和更新元素\n\n\ntextureCache\nMap&lt;string, PIXI.Texture&gt;\n图片纹理缓存，避免重复加载相同图片\n\n\nloadingSet\nSet&lt;string&gt;\n正在加载中的图片 URL 集合，防止重复加载\n\n\nimageUpdateTimers\nMap&lt;string, NodeJS.Timeout&gt;\n图像元素更新检查定时器映射\n\n\ntransformerGraphic\nPIXI.Graphics\n用于绘制变换控制器（选中框、手柄等）的图形对象\n\n\n\n\n// ElementRenderer 内部状态示例private spriteMap: Map&lt;string, PIXI.DisplayObject&gt; = new Map()private textureCache: Map&lt;string, PIXI.Texture&gt; = new Map()private loadingSet: Set&lt;string&gt; = new Set()private imageUpdateTimers: Map&lt;string, NodeJS.Timeout&gt; = new Map()// TransformerRenderer 内部状态示例private transformerGraphic: PIXI.Graphics = new PIXI.Graphics()\n3.2 外部状态 (Global/Server State)渲染层通过订阅 Zustand 状态管理库中的 canvasStore 来获取画布元素数据和选中状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\nelements\nRecord&lt;string, CanvasElement&gt;\n所有画布元素的数据对象\n\n\nselectedIds\nstring[]\n当前选中元素的 ID 数组\n\n\n\n\n// StageManagerCore.ts 中订阅外部状态的方式useStore.subscribe(  (state) =&gt; ({ elements: state.elements, selectedIds: state.selectedIds }),  ({ elements, selectedIds }) =&gt; {    // 当 elements 或 selectedIds 发生变化时触发重新渲染    this.render();  },  { equalityFn: shallow });\n3.3 状态同步机制渲染层通过增量更新（Diffing）算法实现高效的状态同步：\ngraph TDA[Zustand Store 状态变更] --&gt; B{StageManager 订阅}B --&gt; C{Diff 算法对比}C --&gt;|新增元素| D[创建 PIXI 对象]C --&gt;|更新元素| E[更新 PIXI 对象属性]C --&gt;|删除元素| F[销毁 PIXI 对象]D --&gt; G[添加到 spriteMap]E --&gt; GF --&gt; H[从 spriteMap 移除]G --&gt; I[PixiJS 渲染]H --&gt; I    style A fill:#e1f5fe    style I fill:#e8f5e8    style G fill:#fff3e0    style H fill:#ffebee\n4. 逻辑流程 (Logic Flow)4.1 交互时序图 (Mermaid)sequenceDiagram\tparticipant U as 用户\tparticipant SM as StageManagerCore\tparticipant ER as ElementRenderer\tparticipant TR as TransformerRenderer\tparticipant S as Zustand Store\t    U-&gt;&gt;SM: 触发状态变更 (添加/更新元素)    SM-&gt;&gt;S: 更新elements数据    S-&gt;&gt;SM: 通知状态变更    SM-&gt;&gt;ER: 调用renderElements()    ER-&gt;&gt;ER: 根据元素类型创建/更新PIXI对象    ER-&gt;&gt;SM: 更新spriteMap        U-&gt;&gt;SM: 选择元素    SM-&gt;&gt;S: 更新selectedIds    S-&gt;&gt;SM: 通知选中状态变更    SM-&gt;&gt;TR: 调用renderTransformer()    TR-&gt;&gt;TR: 根据选中元素绘制变换控制器\n\n4.2 核心函数解析\nElementRenderer.renderElements():\n\n触发时机: 当画布元素数据发生变更时，通过状态订阅机制触发。每当 Zustand store 中的 elements 对象发生变化时，StageManagerCore 会调用此方法进行重新渲染。\n\n逻辑闭环: 遍历所有元素数据，根据元素类型创建或更新对应的 PIXI 对象，并将其添加到容器中。通过 diff 算法比较现有 spriteMap 和新元素数据（遍历 spriteMap 中的所有元素 ID，检查哪些元素在新的 elements 数据中不存在，这些元素需要被删除，遍历新的 elements 数据中的所有元素 ID，检查哪些是新增的元素需要创建，哪些是已存在的元素需要更新），确定需要创建、更新或删除的元素，最终保持 PIXI 对象与数据状态同步。\n\n核心实现:\n// 核心渲染逻辑public renderElements(  elements: Record&lt;string, CanvasElement&gt;,  elementLayer: PIXI.Container,  destroyed: boolean) {  if (destroyed) return;  // 获取当前所有元素ID  const elementIds = Object.keys(elements);  // 删除已移除的元素  for (const id of this.spriteMap.keys()) {    if (!elementIds.includes(id)) {      const sprite = this.spriteMap.get(id)!;      sprite.destroy({ children: true });      this.spriteMap.delete(id);    }  }  // 更新或创建元素  for (const id of elementIds) {    const data = elements[id];    if (this.spriteMap.has(id)) {      // 更新现有元素      this.updateElement(data, this.spriteMap.get(id)!);    } else {      // 创建新元素      const sprite = this.createElement(data);      elementLayer.addChild(sprite);      this.spriteMap.set(id, sprite);    }  }}\n\n差异化渲染处理:\n// 根据不同类型元素进行差异化渲染处理private createElement(data: CanvasElement): PIXI.DisplayObject {  switch (data.type) {    case 'rect':    case 'circle':    case 'triangle':      // 几何图形处理逻辑：使用Graphics API绘制形状      return this.createGraphicsElement(data);    case 'text':      // 文本元素处理逻辑：使用HTMLText组件渲染富文本      return this.createTextElement(data);    case 'image':      // 图片元素处理逻辑：加载纹理并创建Sprite      return this.createImageElement(data);    case 'line':    case 'arrow':    case 'pencil':      // 线条/铅笔元素处理逻辑：使用Graphics API绘制线条      return this.createLineElement(data);    default:      throw new Error(`Unsupported element type: ${data.type}`);  }}\n\n\n\nTransformerRenderer.renderTransformer():\n\n触发时机: 当选中元素发生变更时触发。每当 Zustand store 中的 selectedIds 数组发生变化时，StageManagerCore 会调用此方法更新变换控制器的显示。\n\n逻辑闭环: 根据选中元素的数量和类型，绘制相应的变换控制器（如缩放手柄、旋转手柄等）。通过清除之前的控制器图形并根据当前选中状态重新绘制，保持变换控制器与选中状态同步。\n\n核心实现:\n// 变换控制器渲染逻辑public renderTransformer(  elements: Record&lt;string, CanvasElement&gt;,  selectedIds: string[],  spriteMap: Map&lt;string, PIXI.DisplayObject&gt;,  onHandleDown: (    e: PIXI.FederatedPointerEvent,    handle: HandleType | 'p0' | 'p1',    elementId: string  ) =&gt; void,  viewportScale: number) {  // 清除之前的变换控制器  this.transformerGraphic.clear();  if (selectedIds.length === 0) return;  if (selectedIds.length === 1) {    // 单个元素选中逻辑    const element = elements[selectedIds[0]];    const sprite = spriteMap.get(selectedIds[0]);    if (sprite) {      this.drawSingleElementTransformer(element, sprite, onHandleDown, viewportScale);    }  } else {    // 多个元素选中逻辑    this.drawMultiElementTransformer(elements, selectedIds, spriteMap, onHandleDown, viewportScale);  }}\n\n\n\n\nUI 与样式实现 (UI Implementation)\n布局策略: 使用 PIXI 的容器系统进行布局管理，分为 elementLayer（元素层）和 uiLayer（UI 层）两个层级，通过坐标系统定位元素\n\nelementLayer: 用于承载所有画布元素的容器层，包括矩形、圆形、文本、图像等各种元素的 PIXI 对象都添加到这一层。这是渲染层的主要内容，负责显示用户创建的所有图形元素。\n\nuiLayer: 用于承载所有 UI 元素的容器层，包括选区框、橡皮擦指示器、变换控制器等辅助 UI 元素。这一层位于元素层之上，确保 UI 元素始终显示在图形元素的前面。\n\n\n// 在 StageManagerCore.ts 中创建两个容器层private elementLayer: PIXI.Container = new PIXI.Container()private uiLayer: PIXI.Container = new PIXI.Container()// 将两个容器层添加到视口中this.viewport.addChild(this.elementLayer)this.viewport.addChild(this.uiLayer)\n\n样式方案:\n\n几何图形使用 PIXI 的绘图 API 进行绘制，支持描边、填充、透明度等样式\n文本元素使用 HTMLText 组件支持富文本渲染\n图片元素使用 PIXI.Sprite 并支持滤镜效果（模糊、亮度、灰度等）\n变换控制器统一使用紫色 (#8b5cf6) 作为主题色\n\n\n条件渲染:\n\n根据元素类型选择不同的渲染方式\n根据选中状态决定是否显示变换控制器\n根据选中元素数量显示不同的控制器形态（单选手柄 vs 群组控制器）\n\n\n\ngraph TD\tA[Viewport] --&gt; B[elementLayer]\tA --&gt; C[uiLayer]\tB --&gt; D[图形元素 1]\tB --&gt; E[图形元素 2]\tB --&gt; F[文本元素]\tB --&gt; G[图像元素]\tC --&gt; H[选区框]\tC --&gt; I[橡皮擦指示器]\tC --&gt; J[变换控制器]\t    style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#e8f5e8    style D fill:#fce4ec    style E fill:#fce4ec    style F fill:#fce4ec    style G fill:#fce4ec    style H fill:#fff3e0    style I fill:#fff3e0    style J fill:#fff3e0\n","categories":["笔记"],"tags":["前端开发"]},{"title":"2025-11-24-canvas项目相关-TransformerRenderer设计","url":"/Arknight-notes/posts/46327.html","content":"TransformerRenderer 设计TransformerRenderer 模块负责渲染画布中选中元素的变换控制器（选择框和控制手柄），包括：\n\n绘制元素选择边界框\n显示控制手柄（用于移动、缩放、旋转等操作）\n处理用户与控制手柄的交互\n\n项目结构树src/└── pages/    └── canvas/        └── Pixi_STM_modules/            └── rendering/                └── TransformerRenderer.ts\n\n\n\n\n\n作用\n\n\n\n\nPixiJS\n2D 渲染引擎，用于绘制图形元素和交互控制器\n\n\nTypeScript\n提供类型安全和更好的开发体验\n\n\nCanvasElement\n数据模型，提供元素属性用于渲染\n\n\n\n\n2. Props 和相关类型定义2.1 renderTransformer 参数\n\n\n\n参数名\n类型\n必填\n默认值\n描述\n\n\n\n\nelements\nRecord&lt;string, CanvasElement&gt;\n是\n-\n所有画布元素的集合\n\n\nselectedIds\nstring[]\n是\n-\n当前选中元素的 ID 数组\n\n\nspriteMap\n`Map&lt;string, PIXI.Graphics \\\nPIXI.HTMLText \\\nPIXI.Sprite&gt;`\n是\n-\n元素 ID 到 Pixi 图形对象的映射\n\n\nonHandleDown\n`(e: PIXI.FederatedPointerEvent, handle: HandleType \\\n‘p0’ \\\n‘p1’, elementId: string) =&gt; void`\n是\n-\n控制手柄按下时的回调函数\n\n\nviewportScale\nnumber\n是\n-\n视口缩放比例，用于调整手柄大小\n\n\n\n\ntransformerRenderer.renderTransformer(  elements, // 所有画布元素  selectedIds, // 选中元素ID数组  spriteMap, // 元素到图形对象的映射  onHandleDown, // 手柄按下回调  viewport.scale.x // 视口缩放比例);\n2.2 类型定义CanvasElement 类型export interface CanvasElement {  id: string;  type: ToolType;  x: number;  y: number;  width: number;  height: number;  fill: string;  stroke: string;  strokeWidth: number;  alpha?: number;  points?: number[][];  rotation?: number; // 旋转角度（弧度）  // 其他文本和图像相关属性...}\n字段说明：\n\nid: 元素唯一标识符\ntype: 元素类型（如’rect’, ‘circle’, ‘text’等）\nx, y: 元素位置坐标\nwidth, height: 元素尺寸\nfill, stroke, strokeWidth: 填充色、边框色和边框宽度\nalpha: 透明度\npoints: 点集（用于 pencil, line, arrow 等）\nrotation: 旋转角度（弧度制）\n\nHandleType 类型export type HandleType =  | \"tl\"  | \"t\"  | \"tr\"  | \"r\"  | \"br\"  | \"b\"  | \"bl\"  | \"l\"  | \"p0\"  | \"p1\"  | \"rotate\";\n各控制手柄类型含义：\n\ntl, t, tr, r, br, b, bl, l: 八个方向的缩放手柄\np0, p1: 线段两个端点的移动手柄\nrotate: 旋转手柄\n\n3. 状态管理 (State Architecture)3.1 内部状态 (Local State)\n\n\n\n状态名\n类型\n描述\n\n\n\n\ntransformerGraphic\nPIXI.Graphics\n用于绘制变换控制器的 Pixi 图形对象\n\n\n\n\n3.2 外部状态 (Global/Server State)TransformerRenderer 是一个纯渲染模块，不直接管理外部状态。它通过以下方式接收外部状态：\n\nelements: 从 Zustand store 获取的所有画布元素\nselectedIds: 从 Zustand store 获取的当前选中元素 ID 数组\nspriteMap: 从 ElementRenderer 获取的元素到图形对象的映射\n\n3.3 状态同步机制graph TD    A[Zustand Store] --&gt; B[StageManager 订阅状态变化]    B --&gt; C[获取 elements 和 selectedIds]    C --&gt; D[调用 TransformerRenderer.renderTransformer]    D --&gt; E[根据选中元素绘制变换控制器]    F[ElementRenderer] --&gt; G[提供 spriteMap]    G --&gt; D\n4. 逻辑流程 (Logic Flow)4.1 交互时序图sequenceDiagram    participant U as 用户    participant TR as TransformerRenderer    participant SM as StageManager    participant CS as CanvasStore    U-&gt;&gt;TR: 点击控制手柄    TR-&gt;&gt;SM: 调用 onHandleDown 回调    SM-&gt;&gt;SM: 设置交互模式(移动/缩放/旋转)    SM-&gt;&gt;CS: 更新元素属性    CS-&gt;&gt;SM: 状态变更通知    SM-&gt;&gt;TR: 重新调用 renderTransformer    TR-&gt;&gt;TR: 重新绘制变换控制器\n4.2 核心函数解析renderTransformer 函数:当画布元素或选中状态发生变化时，由 StageManager 调用，接收当前所有元素和选中元素 ID，根据选中元素类型和状态决定绘制方式，调用相应方法绘制变换控制器\npublic renderTransformer(  elements: Record&lt;string, CanvasElement&gt;,  selectedIds: string[],  spriteMap: Map&lt;string, PIXI.Graphics | PIXI.HTMLText | PIXI.Sprite&gt;,  onHandleDown: (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1', elementId: string) =&gt; void,  viewportScale: number,) {  // 清空之前的绘制内容  this.transformerGraphic.clear()  this.transformerGraphic.removeChildren()  if (selectedIds.length === 0) return  // 根据选中元素类型决定绘制方式  const el = elements[selectedIds[0]]  const isLinearElement = selectedIds.length === 1 &amp;&amp; (el.type === 'line' || el.type === 'arrow') &amp;&amp; el.points?.length === 2  if (isLinearElement) {    // 绘制线段控制手柄    this.drawLinearHandles(el, selectedIds, onHandleDown, viewportScale)  } else {    // 绘制包围盒控制手柄    this.drawBoundingBoxHandles(elements, selectedIds, spriteMap, onHandleDown, viewportScale)  }}\n一些处理\n\n区分线性元素（line/arrow）和普通元素的不同控制手柄绘制方式\n根据是否有旋转属性决定绘制普通边界框还是旋转边界框\n根据选中元素数量决定是否显示控制手柄\n\ndrawRotatedBounds 函数:当选中元素具有旋转属性时，在 renderTransformer 中被调用，接收边界框信息和旋转角度，计算旋转后各角点坐标，绘制旋转后的边界框和控制手柄\nprivate drawRotatedBounds(  bounds: { x: number; y: number; width: number; height: number },  rotation: number,  viewportScale: number,  selectedIds: string[],  onHandleDown: (e: PIXI.FederatedPointerEvent, handle: HandleType | 'p0' | 'p1', elementId: string) =&gt; void,) {  const centerX = bounds.x + bounds.width / 2  const centerY = bounds.y + bounds.height / 2  // 计算旋转后的四个角点  const halfWidth = bounds.width / 2  const halfHeight = bounds.height / 2  const corners = [    { x: -halfWidth, y: -halfHeight }, // 左上    { x: halfWidth, y: -halfHeight },  // 右上    { x: halfWidth, y: halfHeight },   // 右下    { x: -halfWidth, y: halfHeight }   // 左下  ]  // 应用旋转矩阵计算实际坐标  const rotatedCorners = corners.map(corner =&gt; {    const cos = Math.cos(rotation)    const sin = Math.sin(rotation)    return {      x: centerX + corner.x * cos - corner.y * sin,      y: centerY + corner.x * sin + corner.y * cos    }  })  // 绘制旋转后的边界框  this.transformerGraphic.poly(rotatedCorners)  this.transformerGraphic.stroke({ width: 1, color: 0x8b5cf6 })  this.transformerGraphic.closePath()  // 绘制控制手柄和其他UI元素  // ...}\n\n使用三角函数计算旋转后坐标\n正确放置旋转手柄位置，使其始终位于边界框上方\n保持手柄与边界框一同旋转\n\n5. UI 与样式实现 (UI Implementation)布局策略graph TD    A[transformerGraphic 容器] --&gt; B[边界框/多边形]    A --&gt; C[控制手柄]    A --&gt; D[旋转手柄]    A --&gt; E[手柄点击区域]    C --&gt; C1[左上手柄]    C --&gt; C2[上边手柄]    C --&gt; C3[右上手柄]    C --&gt; C4[右边手柄]    C --&gt; C5[右下手柄]    C --&gt; C6[下边手柄]    C --&gt; C7[左下手柄]    C --&gt; C8[左边手柄]    D --&gt; D1[旋转手柄圆形]    D --&gt; D2[连接线]    E --&gt; E1[手柄透明点击区域]\n样式方案TransformerRenderer 使用 PixiJS 的 Graphics API 进行绘制：\n\n边界框样式:\n\n颜色: 紫色 (#8b5cf6)\n线宽: 1px\n\n\n控制手柄样式:\n\n形状: 矩形\n填充色: 白色\n边框色: 紫色 (#8b5cf6)\n边框宽度: 1px\n\n\n旋转手柄样式:\n\n形状: 圆形\n填充色: 白色\n边框色: 紫色 (#8b5cf6)\n边框宽度: 1px\n\n\n手柄大小自适应:根据视口缩放比例调整手柄大小:\nconst handleSize = 8 / viewportScale;\n\n\n元素操作机制实现旋转操作\n检测元素是否有 rotation 属性\n计算元素中心点和旋转后各角点坐标\n绘制旋转后的边界框\n旋转手柄位置通过以下方式计算:\n// 计算未旋转时顶部中心点const topCenterX = centerX;const topCenterY = bounds.y;// 将顶部中心点也进行旋转const rotatedTopCenterX =  centerX +  (topCenterX - centerX) * Math.cos(rotation) -  (topCenterY - centerY) * Math.sin(rotation);const rotatedTopCenterY =  centerY +  (topCenterX - centerX) * Math.sin(rotation) +  (topCenterY - centerY) * Math.cos(rotation);\n\n\n缩放操作\n根据手柄类型确定缩放方向\n通过拖拽距离计算新的元素尺寸\n更新元素的 width/height 属性\n\n移动操作\n通过拖拽偏移量更新元素的 x/y 属性\n对于多选元素，保持相对位置不变\n\n元素打组机制当前实现中，多元素选择时:\n\n计算所有选中元素的包围盒\n在包围盒周围显示控制手柄\n操作时同时影响所有选中元素\n\n","categories":["归档"]},{"title":"CHATGLM-6B清华AI语言模型","url":"/Arknight-notes/posts/26397.html","content":"猜猜我在清华找到了什么好东西模型可以装在电脑里跑的，然后发现电脑带不动（悲）\nChatGLM-6Bhttps://gitclone.com/aiit/chat/页面嵌入各种bug\n新一代开源模型 ChatGLM3-6B 已发布，拥有10B以下最强的基础模型，支持工具调用（Function Call）、代码执行（Code Interpreter）、Agent 任务等功能。\n介绍ChatGLM-6B 是一个开源的、支持中英双语的对话语言模型，基于 General Language Model (GLM) 架构，具有 62 亿参数。结合模型量化技术，用户可以在消费级的显卡上进行本地部署（INT4 量化级别下最低只需 6GB 显存）。ChatGLM-6B 使用了和 ChatGPT 相似的技术，针对中文问答和对话进行了优化。经过约 1T 标识符的中英双语训练，辅以监督微调、反馈自助、人类反馈强化学习等技术的加持，62 亿参数的 ChatGLM-6B 已经能生成相当符合人类偏好的回答，更多信息请参考我们的博客。欢迎通过 chatglm.cn 体验更大规模的 ChatGLM 模型。\n为了方便下游开发者针对自己的应用场景定制模型，我们同时实现了基于 P-Tuning v2 的高效参数微调方法 (使用指南) ，INT4 量化级别下最低只需 7GB 显存即可启动微调。\nChatGLM-6B 权重对学术研究完全开放，在填写问卷进行登记后亦允许免费商业使用。\n\nChatGLM-6B 开源模型旨在与开源社区一起推动大模型技术发展，恳请开发者和大家遵守开源协议，勿将开源模型和代码及基于开源项目产生的衍生物用于任何可能给国家和社会带来危害的用途以及用于任何未经过安全评估和备案的服务。目前，本项目团队未基于 ChatGLM-6B 开发任何应用，包括网页端、安卓、苹果 iOS 及 Windows App 等应用。\n尽管模型在训练的各个阶段都尽力确保数据的合规性和准确性，但由于 ChatGLM-6B 模型规模较小，且模型受概率随机性因素影响，无法保证输出内容的准确性，且模型易被误导（详见局限性）。本项目不承担开源模型和代码导致的数据安全、舆情风险或发生任何模型被误导、滥用、传播、不当利用而产生的风险和责任。\n更新信息[2023/07/25] 发布 CodeGeeX2 ，基于 ChatGLM2-6B 的代码生成模型，代码能力全面提升，更多特性包括：\n\n更强大的代码能力：CodeGeeX2-6B 进一步经过了 600B 代码数据预训练，相比 CodeGeeX 一代模型，在代码能力上全面提升，HumanEval-X 评测集的六种编程语言均大幅提升 (Python +57%, C++ +71%, Java +54%, JavaScript +83%, Go +56%, Rust +321\\%)，在Python上达到 35.9\\% 的 Pass@1 一次通过率，超越规模更大的 StarCoder-15B。\n更优秀的模型特性：继承 ChatGLM2-6B 模型特性，CodeGeeX2-6B 更好支持中英文输入，支持最大 8192 序列长度，推理速度较一代 大幅提升，量化后仅需6GB显存即可运行，支持轻量级本地化部署。\n更全面的AI编程助手：CodeGeeX插件（VS Code, Jetbrains）后端升级，支持超过100种编程语言，新增上下文补全、跨文件补全等实用功能。结合 Ask CodeGeeX 交互式AI编程助手，支持中英文对话解决各种编程问题，包括且不限于代码解释、代码翻译、代码纠错、文档生成等，帮助程序员更高效开发。\n\n[2023/06/25] 发布 ChatGLM2-6B，ChatGLM-6B 的升级版本，在保留了了初代模型对话流畅、部署门槛较低等众多优秀特性的基础之上，ChatGLM2-6B 引入了如下新特性：\n\n更强大的性能：基于 ChatGLM 初代模型的开发经验，我们全面升级了 ChatGLM2-6B 的基座模型。ChatGLM2-6B 使用了 GLM 的混合目标函数，经过了 1.4T 中英标识符的预训练与人类偏好对齐训练，评测结果显示，相比于初代模型，ChatGLM2-6B 在 MMLU（+23%）、CEval（+33%）、GSM8K（+571%） 、BBH（+60%）等数据集上的性能取得了大幅度的提升，在同尺寸开源模型中具有较强的竞争力。\n更长的上下文：基于 FlashAttention 技术，我们将基座模型的上下文长度（Context Length）由 ChatGLM-6B 的 2K 扩展到了 32K，并在对话阶段使用 8K 的上下文长度训练，允许更多轮次的对话。但当前版本的 ChatGLM2-6B 对单轮超长文档的理解能力有限，我们会在后续迭代升级中着重进行优化。\n更高效的推理：基于 Multi-Query Attention 技术，ChatGLM2-6B 有更高效的推理速度和更低的显存占用：在官方的模型实现下，推理速度相比初代提升了 42%，INT4 量化下，6G 显存支持的对话长度由 1K 提升到了 8K。\n\n更多信息参见 ChatGLM2-6B。\n[2023/06/14] 发布 WebGLM，一项被接受于KDD 2023的研究工作，支持利用网络信息生成带有准确引用的长回答。\n[2023/05/17] 发布 VisualGLM-6B，一个支持图像理解的多模态对话语言模型。\n可以通过本仓库中的 cli_demo_vision.py 和 web_demo_vision.py 来运行命令行和网页 Demo。注意 VisualGLM-6B 需要额外安装 SwissArmyTransformer 和 torchvision。更多信息参见 VisualGLM-6B。\n[2023/05/15] 更新 v1.1 版本 checkpoint，训练数据增加英文指令微调数据以平衡中英文数据比例，解决英文回答中夹杂中文词语的现象。\n友情链接对 ChatGLM 进行加速的开源项目：\n\nlyraChatGLM: 对 ChatGLM-6B 进行推理加速，最高可以实现 9000+ tokens/s 的推理速度\nChatGLM-MNN: 一个基于 MNN 的 ChatGLM-6B C++ 推理实现，支持根据显存大小自动分配计算任务给 GPU 和 CPU\nJittorLLMs：最低3G显存或者没有显卡都可运行 ChatGLM-6B FP16， 支持Linux、windows、Mac部署\nInferLLM：轻量级 C++ 推理，可以实现本地 x86，Arm 处理器上实时聊天，手机上也同样可以实时运行，运行内存只需要 4G\n\n基于或使用了 ChatGLM-6B 的开源项目：\n\nlangchain-ChatGLM：基于 langchain 的 ChatGLM 应用，实现基于可扩展知识库的问答\n闻达：大型语言模型调用平台，基于 ChatGLM-6B 实现了类 ChatPDF 功能\nglm-bot：将ChatGLM接入Koishi可在各大聊天平台上调用ChatGLM\nChuanhu Chat: 为各个大语言模型和在线模型API提供美观易用、功能丰富、快速部署的用户界面，支持ChatGLM-6B。\n\n支持 ChatGLM-6B 和相关应用在线训练的示例项目：\n\nChatGLM-6B 的部署与微调教程\nChatGLM-6B 结合 langchain 实现本地知识库 QA Bot\n\n第三方评测：\n\nMeasuring Massive Multitask Chinese Understanding\n\n更多开源项目参见 PROJECT.md\n使用方式硬件需求\n\n\n\n量化等级\n最低 GPU 显存（推理）\n最低 GPU 显存（高效参数微调）\n\n\n\n\nFP16（无量化）\n13 GB\n14 GB\n\n\nINT8\n8 GB\n9 GB\n\n\nINT4\n6 GB\n7 GB\n\n\n\n\n环境安装使用 pip 安装依赖：pip install -r requirements.txt，其中 transformers 库版本推荐为 4.27.1，但理论上不低于 4.23.1 即可。\n此外，如果需要在 cpu 上运行量化后的模型，还需要安装 gcc 与 openmp。多数 Linux 发行版默认已安装。对于 Windows ，可在安装 TDM-GCC 时勾选 openmp。 Windows 测试环境 gcc 版本为 TDM-GCC 10.3.0， Linux 为 gcc 11.3.0。在 MacOS 上请参考 Q1。\n代码调用可以通过如下代码调用 ChatGLM-6B 模型来生成对话：\n&gt;&gt;&gt; from transformers import AutoTokenizer, AutoModel&gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(&quot;THUDM/chatglm-6b&quot;, trust_remote_code=True)&gt;&gt;&gt; model = AutoModel.from_pretrained(&quot;THUDM/chatglm-6b&quot;, trust_remote_code=True).half().cuda()&gt;&gt;&gt; model = model.eval()&gt;&gt;&gt; response, history = model.chat(tokenizer, &quot;你好&quot;, history=[])&gt;&gt;&gt; print(response)你好👋!我是人工智能助手 ChatGLM-6B,很高兴见到你,欢迎问我任何问题。&gt;&gt;&gt; response, history = model.chat(tokenizer, &quot;晚上睡不着应该怎么办&quot;, history=history)&gt;&gt;&gt; print(response)晚上睡不着可能会让你感到焦虑或不舒服,但以下是一些可以帮助你入睡的方法:1. 制定规律的睡眠时间表:保持规律的睡眠时间表可以帮助你建立健康的睡眠习惯,使你更容易入睡。尽量在每天的相同时间上床,并在同一时间起床。2. 创造一个舒适的睡眠环境:确保睡眠环境舒适,安静,黑暗且温度适宜。可以使用舒适的床上用品,并保持房间通风。3. 放松身心:在睡前做些放松的活动,例如泡个热水澡,听些轻柔的音乐,阅读一些有趣的书籍等,有助于缓解紧张和焦虑,使你更容易入睡。4. 避免饮用含有咖啡因的饮料:咖啡因是一种刺激性物质,会影响你的睡眠质量。尽量避免在睡前饮用含有咖啡因的饮料,例如咖啡,茶和可乐。5. 避免在床上做与睡眠无关的事情:在床上做些与睡眠无关的事情,例如看电影,玩游戏或工作等,可能会干扰你的睡眠。6. 尝试呼吸技巧:深呼吸是一种放松技巧,可以帮助你缓解紧张和焦虑,使你更容易入睡。试着慢慢吸气,保持几秒钟,然后缓慢呼气。如果这些方法无法帮助你入睡,你可以考虑咨询医生或睡眠专家,寻求进一步的建议。\n模型的实现仍然处在变动中。如果希望固定使用的模型实现以保证兼容性，可以在 from_pretrained 的调用中增加 revision=&quot;v1.1.0&quot; 参数。v1.1.0 是当前最新的版本号，完整的版本列表参见 Change Log。\n从本地加载模型以上代码会由 transformers 自动下载模型实现和参数。完整的模型实现可以在 Hugging Face Hub。如果你的网络环境较差，下载模型参数可能会花费较长时间甚至失败。此时可以先将模型下载到本地，然后从本地加载。\n从 Hugging Face Hub 下载模型需要先安装Git LFS，然后运行git clone https://huggingface.co/THUDM/chatglm-6b\n如果你从 Hugging Face Hub 上下载 checkpoint 的速度较慢，可以只下载模型实现GIT_LFS_SKIP_SMUDGE=1 git clone https://huggingface.co/THUDM/chatglm-6b然后从这里手动下载模型参数文件，并将下载的文件替换到本地的 chatglm-6b 目录下。\n将模型下载到本地之后，将以上代码中的 THUDM/chatglm-6b 替换为你本地的 chatglm-6b 文件夹的路径，即可从本地加载模型。\nOptional 模型的实现仍然处在变动中。如果希望固定使用的模型实现以保证兼容性，可以执行git checkout v1.1.0\nDemo &amp; API我们提供了一个基于 Gradio 的网页版 Demo 和一个命令行 Demo。使用时首先需要下载本仓库：\ngit clone https://github.com/THUDM/ChatGLM-6Bcd ChatGLM-6B\n网页版 Demo\n首先安装 Gradio：pip install gradio，然后运行仓库中的 web_demo.py： \npython web_demo.py\n程序会运行一个 Web Server，并输出地址。在浏览器中打开输出的地址即可使用。最新版 Demo 实现了打字机效果，速度体验大大提升。注意，由于国内 Gradio 的网络访问较为缓慢，启用 demo.queue().launch(share=True, inbrowser=True) 时所有网络会经过 Gradio 服务器转发，导致打字机体验大幅下降，现在默认启动方式已经改为 share=False，如有需要公网访问的需求，可以重新修改为 share=True 启动。\n感谢 @AdamBear 实现了基于 Streamlit 的网页版 Demo，运行方式见#117.\n命令行 Demo\n运行仓库中 cli_demo.py：\npython cli_demo.py\n程序会在命令行中进行交互式的对话，在命令行中输入指示并回车即可生成回复，输入 clear 可以清空对话历史，输入 stop 终止程序。\nAPI部署首先需要安装额外的依赖 pip install fastapi uvicorn，然后运行仓库中的 api.py：python api.py默认部署在本地的 8000 端口，通过 POST 方法进行调用curl -X POST &quot;http://127.0.0.1:8000&quot; \\     -H &#x27;Content-Type: application/json&#x27; \\     -d &#x27;&#123;&quot;prompt&quot;: &quot;你好&quot;, &quot;history&quot;: []&#125;&#x27;得到的返回值为&#123;  &quot;response&quot;:&quot;你好👋！我是人工智能助手 ChatGLM-6B，很高兴见到你，欢迎问我任何问题。&quot;,  &quot;history&quot;:[[&quot;你好&quot;,&quot;你好👋！我是人工智能助手 ChatGLM-6B，很高兴见到你，欢迎问我任何问题。&quot;]],  &quot;status&quot;:200,  &quot;time&quot;:&quot;2023-03-23 21:38:40&quot;&#125;\n低成本部署模型量化默认情况下，模型以 FP16 精度加载，运行上述代码需要大概 13GB 显存。如果你的 GPU 显存有限，可以尝试以量化方式加载模型，使用方法如下：\n# 按需修改，目前只支持 4/8 bit 量化model = AutoModel.from_pretrained(&quot;THUDM/chatglm-6b&quot;, trust_remote_code=True).quantize(8).half().cuda()\n进行 2 至 3 轮对话后，8-bit 量化下 GPU 显存占用约为 10GB，4-bit 量化下仅需 6GB 占用。随着对话轮数的增多，对应消耗显存也随之增长，由于采用了相对位置编码，理论上 ChatGLM-6B 支持无限长的 context-length，但总长度超过 2048（训练长度）后性能会逐渐下降。\n模型量化会带来一定的性能损失，经过测试，ChatGLM-6B 在 4-bit 量化下仍然能够进行自然流畅的生成。使用 GPT-Q 等量化方案可以进一步压缩量化精度/提升相同量化精度下的模型性能，欢迎大家提出对应的 Pull Request。\n量化过程需要在内存中首先加载 FP16 格式的模型，消耗大概 13GB 的内存。如果你的内存不足的话，可以直接加载量化后的模型，INT4 量化后的模型仅需大概 5.2GB 的内存：# INT8 量化的模型将&quot;THUDM/chatglm-6b-int4&quot;改为&quot;THUDM/chatglm-6b-int8&quot;model = AutoModel.from_pretrained(&quot;THUDM/chatglm-6b-int4&quot;, trust_remote_code=True).half().cuda()量化模型的参数文件也可以从这里手动下载。\nCPU 部署如果你没有 GPU 硬件的话，也可以在 CPU 上进行推理，但是推理速度会更慢。使用方法如下（需要大概 32GB 内存）model = AutoModel.from_pretrained(&quot;THUDM/chatglm-6b&quot;, trust_remote_code=True).float()\n如果你的内存不足，可以直接加载量化后的模型：# INT8 量化的模型将&quot;THUDM/chatglm-6b-int4&quot;改为&quot;THUDM/chatglm-6b-int8&quot;model = AutoModel.from_pretrained(&quot;THUDM/chatglm-6b-int4&quot;,trust_remote_code=True).float()\n如果遇到了报错 Could not find module &#39;nvcuda.dll&#39; 或者 RuntimeError: Unknown platform: darwin (MacOS) ，请从本地加载模型\nMac 部署对于搭载了 Apple Silicon 或者 AMD GPU 的Mac，可以使用 MPS 后端来在 GPU 上运行 ChatGLM-6B。需要参考 Apple 的 官方说明 安装 PyTorch-Nightly（正确的版本号应该是2.1.0.dev2023xxxx，而不是2.0.0）。\n目前在 MacOS 上只支持从本地加载模型。将代码中的模型加载改为从本地加载，并使用 mps 后端：model = AutoModel.from_pretrained(&quot;your local path&quot;, trust_remote_code=True).half().to(&#x27;mps&#x27;)\n加载半精度的 ChatGLM-6B 模型需要大概 13GB 内存。内存较小的机器（比如 16GB 内存的 MacBook Pro），在空余内存不足的情况下会使用硬盘上的虚拟内存，导致推理速度严重变慢。此时可以使用量化后的模型如 chatglm-6b-int4。因为 GPU 上量化的 kernel 是使用 CUDA 编写的，因此无法在 MacOS 上使用，只能使用 CPU 进行推理。# INT8 量化的模型将&quot;THUDM/chatglm-6b-int4&quot;改为&quot;THUDM/chatglm-6b-int8&quot;model = AutoModel.from_pretrained(&quot;THUDM/chatglm-6b-int4&quot;,trust_remote_code=True).float()为了充分使用 CPU 并行，还需要单独安装 OpenMP。\n多卡部署如果你有多张 GPU，但是每张 GPU 的显存大小都不足以容纳完整的模型，那么可以将模型切分在多张GPU上。首先安装 accelerate: pip install accelerate，然后通过如下方法加载模型：from utils import load_model_on_gpusmodel = load_model_on_gpus(&quot;THUDM/chatglm-6b&quot;, num_gpus=2)即可将模型部署到两张 GPU 上进行推理。你可以将 num_gpus 改为你希望使用的 GPU 数。默认是均匀切分的，你也可以传入 device_map 参数来自己指定。 \n高效参数微调基于 P-tuning v2 的高效参数微调。具体使用方法详见 ptuning/README.md。\nChatGLM-6B 示例以下是一些使用 web_demo.py 得到的示例截图。\n局限性由于 ChatGLM-6B 的小规模，其能力仍然有许多局限性。以下是我们目前发现的一些问题：\n\n模型容量较小：6B 的小容量，决定了其相对较弱的模型记忆和语言能力。在面对许多事实性知识任务时，ChatGLM-6B 可能会生成不正确的信息；它也不擅长逻辑类问题（如数学、编程）的解答。\n\n\n产生有害说明或有偏见的内容：ChatGLM-6B 只是一个初步与人类意图对齐的语言模型，可能会生成有害、有偏见的内容。（内容可能具有冒犯性，此处不展示）\n\n英文能力不足：ChatGLM-6B 训练时使用的指示/回答大部分都是中文的，仅有极小一部分英文内容。因此，如果输入英文指示，回复的质量远不如中文，甚至与中文指示下的内容矛盾，并且出现中英夹杂的情况。\n\n易被误导，对话能力较弱：ChatGLM-6B 对话能力还比较弱，而且 “自我认知” 存在问题，并很容易被误导并产生错误的言论。例如当前版本的模型在被误导的情况下，会在自我认知上发生偏差。\n\n\n\n协议本仓库的代码依照 Apache-2.0 协议开源，ChatGLM-6B 模型的权重的使用则需要遵循 Model License。ChatGLM-6B 权重对学术研究完全开放，在填写问卷进行登记后亦允许免费商业使用。\n引用如果你觉得我们的工作有帮助的话，请考虑引用下列论文\n@article&#123;zeng2022glm,  title=&#123;Glm-130b: An open bilingual pre-trained model&#125;,  author=&#123;Zeng, Aohan and Liu, Xiao and Du, Zhengxiao and Wang, Zihan and Lai, Hanyu and Ding, Ming and Yang, Zhuoyi and Xu, Yifan and Zheng, Wendi and Xia, Xiao and others&#125;,  journal=&#123;arXiv preprint arXiv:2210.02414&#125;,  year=&#123;2022&#125;&#125;\n@inproceedings&#123;du2022glm,  title=&#123;GLM: General Language Model Pretraining with Autoregressive Blank Infilling&#125;,  author=&#123;Du, Zhengxiao and Qian, Yujie and Liu, Xiao and Ding, Ming and Qiu, Jiezhong and Yang, Zhilin and Tang, Jie&#125;,  booktitle=&#123;Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)&#125;,  pages=&#123;320--335&#125;,  year=&#123;2022&#125;&#125;\n```\n","categories":["Github项目"],"tags":["github"]},{"title":"2025-11-23-canvas项目相关-画布元素控制调整机制","url":"/Arknight-notes/posts/38568.html","content":"1. 模块摘要 (Executive Summary)画布元素控制调整机制是画布应用中实现元素选中、变换和调整的核心功能模块。它通过变换控制器渲染器(TransformerRenderer)实现，在用户选中元素时显示控制手柄和边界框，并处理用户的调整操作，支持单个元素和多个元素的控制调整\n\n项目结构：\nsrc/└── pages/    └── canvas/        └── Pixi_STM_modules/            └── rendering/                └── TransformerRenderer.ts    # 变换控制器渲染器实现\n依赖库\n\nPixiJS：WebGL 渲染引擎，用于绘制控制手柄和边界框\nPIXI.Graphics：用于绘制变换控制器的图形对象\nTypeScript：提供类型安全和代码可维护性\n\n\n\n2. 控制调整机制类型定义2.1 HandleType 类型定义了变换控制器上各种手柄的类型：\ntype HandleType =  | \"tl\" // top-left 左上角  | \"t\" // top 顶部中间  | \"tr\" // top-right 右上角  | \"r\" // right 右侧中间  | \"br\" // bottom-right 右下角  | \"b\" // bottom 底部中间  | \"bl\" // bottom-left 左下角  | \"l\" // left 左侧中间  | \"p0\" // 线段起点  | \"p1\" // 线段终点  | \"rotate\"; // 旋转手柄\n2.2 TransformerRenderer.renderTransformer 参数变换控制器渲染方法的参数定义：\n\n\n\n\n参数名\n类型\n描述\n\n\n\n\nelements\nRecord\n所有画布元素的数据\n\n\nselectedIds\nstring[]\n当前选中元素的 ID 数组\n\n\nspriteMap\nMap\n元素 ID 到 PIXI 对象的映射\n\n\nonHandleDown\nFunction\n手柄按下事件的回调函数\n\n\nviewportScale\nnumber\n当前视口的缩放比例\n\n\n\n\n3. 控制调整机制架构3.1 内部状态 (Local State)TransformerRenderer 维护以下内部状态：\n\n\n\n\n状态名\n类型\n描述\n\n\n\n\ntransformerGraphic\nPIXI.Graphics\n用于绘制变换控制器的图形对象\n\n\n\n\n3.2 外部依赖 (External Dependencies)控制调整机制依赖以下外部组件：\n\n\n\n\n组件\n类型\n描述\n\n\n\n\nelements\nRecord\n画布元素数据\n\n\nselectedIds\nstring[]\n选中元素 ID 数组\n\n\nspriteMap\nMap\n元素到显示对象的映射\n\n\nonHandleDown\nFunction\n手柄事件处理回调\n\n\n\n\n3.3 控制调整机制流程graph TD    A[元素选中状态变化] --&gt; B{TransformerRenderer}    B --&gt; C[清除之前的控制器]    C --&gt; D{选中元素数量}    D --&gt;|0| E[无操作]    D --&gt;|1:线性元素| F[绘制端点手柄]    D --&gt;|1:普通元素| G[绘制8个控制手柄]    D --&gt;|&gt;1| H[绘制群组控制手柄和旋转手柄]    F --&gt; I[添加手柄点击区域]    G --&gt; I    H --&gt; I    I --&gt; J[绑定事件处理]    J --&gt; K[显示变换控制器]        style A fill:#e1f5fe    style K fill:#e8f5e8    style E fill:#ffebee\n4. 控制调整类型控制调整机制根据选中元素的不同类型和数量，提供不同的控制方式：\n4.1 线性元素控制（单个线段/箭头）对于线段和箭头元素，提供两个端点控制手柄：\ngraph TD    A[线段元素] --&gt; B[端点p0控制手柄]    A --&gt; C[端点p1控制手柄]    B --&gt; D[移动端点位置]    C --&gt; D        style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#f3e5f5    style D fill:#e8f5e8\n4.2 单个元素控制对于单个普通元素（矩形、圆形、文本等），提供 8 个控制手柄：\ngraph TD    A[单个元素] --&gt; B[tl手柄]    A --&gt; C[t手柄]    A --&gt; D[tr手柄]    A --&gt; E[r手柄]    A --&gt; F[br手柄]    A --&gt; G[b手柄]    A --&gt; H[bl手柄]    A --&gt; I[l手柄]        style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#f3e5f5    style D fill:#f3e5f5    style E fill:#f3e5f5    style F fill:#f3e5f5    style G fill:#f3e5f5    style H fill:#f3e5f5    style I fill:#f3e5f5\n4.3 多个元素控制对于多个选中元素，提供群组控制手柄和旋转手柄：\ngraph TD    A[多个元素] --&gt; B[计算包围盒]    B --&gt; C[tl手柄]    B --&gt; D[t手柄]    B --&gt; E[tr手柄]    B --&gt; F[r手柄]    B --&gt; G[br手柄]    B --&gt; H[b手柄]    B --&gt; I[bl手柄]    B --&gt; J[l手柄]    B --&gt; K[旋转手柄]        style A fill:#e1f5fe    style B fill:#fff3e0    style C fill:#f3e5f5    style D fill:#f3e5f5    style E fill:#f3e5f5    style F fill:#f3e5f5    style G fill:#f3e5f5    style H fill:#f3e5f5    style I fill:#f3e5f5    style J fill:#f3e5f5    style K fill:#f3e5f5\n5. 控制调整交互流程5.1 交互时序图sequenceDiagram    participant U as 用户    participant TR as TransformerRenderer    participant SM as StageManager    participant ZS as Zustand Store        U-&gt;&gt;TR: 点击控制手柄    TR-&gt;&gt;TR: 识别手柄类型    TR-&gt;&gt;SM: 调用onHandleDown回调    SM-&gt;&gt;SM: 设置调整模式和激活手柄    SM-&gt;&gt;SM: 记录初始状态    SM-&gt;&gt;ZS: 锁定撤销管理器    U-&gt;&gt;SM: 拖拽鼠标    SM-&gt;&gt;SM: 计算元素新位置和尺寸    SM-&gt;&gt;ZS: 更新元素状态    U-&gt;&gt;SM: 释放鼠标    SM-&gt;&gt;SM: 创建更新命令    SM-&gt;&gt;ZS: 解锁撤销管理器    ZS-&gt;&gt;SM: 触发状态变更    SM-&gt;&gt;TR: 重新渲染变换控制器\n5.2 核心函数解析renderTransformer 函数：\n当选中元素发生变化时触发，根据选中元素的类型和数量，绘制相应的控制手柄和边界框\npublic renderTransformer(  elements: Record&lt;string, CanvasElement&gt;,  selectedIds: string[],  spriteMap: Map&lt;string, PIXI.DisplayObject&gt;,  onHandleDown: Function,  viewportScale: number) {  // 清除之前的控制器  this.transformerGraphic.clear()  this.transformerGraphic.removeChildren()  if (selectedIds.length === 0) return  // 根据选中元素类型和数量绘制不同的控制器  if (isLinearElement) {    // 绘制线性元素控制器  } else if (selectedIds.length === 1) {    // 绘制单个元素控制器  } else {    // 绘制多个元素控制器  }}\n6. UI 与样式实现6.1 控制手柄样式控制手柄使用统一的视觉样式：\ngraph TD    A[控制手柄] --&gt; B[白色填充]    A --&gt; C[紫色边框#8b5cf6]    A --&gt; D[尺寸8px/10px]    A --&gt; E[点击区域16px/20px]        style A fill:#e1f5fe    style B fill:#f3e5f5    style C fill:#f3e5f5    style D fill:#fff3e0    style E fill:#fff3e0\n6.2 光标样式不同类型的控制手柄提供不同的光标样式，提升用户体验：\n\n\n\n\n手柄类型\n光标样式\n\n\n\n\ntl, br\nnwse-resize\n\n\ntr, bl\nnesw-resize\n\n\nt, b\nns-resize\n\n\nl, r\new-resize\n\n\nrotate\ngrab\n\n\np0, p1\nmove\n\n\n\n\n\n控制调整机制通过 hitZone（点击区域）来处理用户交互\n\n","categories":["归档"],"tags":["前端开发","PixiJS","画布控制"]},{"title":"2025-11-24-canvas项目相关-元素操作和打组机制实现","url":"/Arknight-notes/posts/54304.html","content":"元素操作机制和元素打组机制实现文档1. DES元素操作机制（移动、缩放、旋转）和元素打组机制的实现方案，包括数据结构、交互逻辑、状态管理和相关组件的实现细节。\n项目结构树src/├── pages/│   └── canvas/│       └── Pixi_STM_modules/│           ├── core/│           │   └── StageManagerCore.ts     # 主要操作逻辑实现│           ├── rendering/│           │   ├── ElementRenderer.ts      # 元素渲染│           │   └── TransformerRenderer.ts  # 选择框和控制手柄渲染│           └── core/│               └── types.ts                # 相关类型定义├── stores/│   └── canvasStore.ts                      # CanvasElement 接口定义和状态管理└── lib/    └── UpdateElementCommand.ts             # 撤销/重做命令实现\n\n\n\n\n\n作用\n\n\n\n\nPixiJS\n2D 渲染引擎，用于绘制图形元素和交互控制器\n\n\npixi-viewport\n提供无限画布支持和视口控制\n\n\nTypeScript\n提供类型安全和更好的开发体验\n\n\nZustand\n全局状态管理\n\n\nnanoid\n生成元素唯一标识符\n\n\n\n\n2. Props 和相关类型定义2.1 核心方法参数StageManagerCore 交互方法：\nonPointerDown 方法处理指针按下事件，开始各种操作\n\n\n\n\n参数名\n类型\n必填\n默认值\n描述\n\n\n\n\ne\nPIXI.FederatedPointerEvent\n是\n-\nPixiJS 指针事件对象\n\n\n\n\nonPointerMove 方法处理指针移动事件，执行操作过程\n\n\n\n\n参数名\n类型\n必填\n默认值\n描述\n\n\n\n\ne\nPIXI.FederatedPointerEvent\n是\n-\nPixiJS 指针事件对象\n\n\n\n\nonPointerUp 方法处理指针释放事件，结束操作\n\n\n\n\n参数名\n类型\n必填\n默认值\n描述\n\n\n\n\n无参数\n-\n-\n-\n无参数\n\n\n\n\n代码示例// 在 StageManagerCore 中注册指针事件处理this.interactionHandler = new InteractionHandler(  this.viewport,  this.onPointerDown, // 指针按下处理  this.onPointerMove, // 指针移动处理  this.onPointerUp, // 指针释放处理)\n2.2 类型定义StageManagerState 类型export interface StageManagerState {  mode: InteractionMode // 当前交互模式  startPos: { x: number; y: number } // 操作起始位置  currentId: string | null // 当前操作元素ID  initialElementsMap: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; | null // 调整大小初始状态  initialGroupBounds: { x: number; y: number; width: number; height: number } | null // 群组初始边界  activeHandle: HandleType | null // 激活的控制手柄  isSpacePressed: boolean // 空格键是否按下  destroyed: boolean // 是否已销毁  resizeInitialStates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; | null // 缩放初始状态  dragInitialStates: Record&lt;string, Partial&lt;CanvasElement&gt;&gt; | null // 拖拽初始状态  rotationInitialStates: Record&lt;    string,    {      // 旋转初始状态      x: number      y: number      width: number      height: number      rotation: number      cx: number      cy: number    }  &gt; | null  rotationCenter: { x: number; y: number } | null // 旋转中心点  startRotationAngle: number | null // 起始旋转角度}\nInteractionMode 类型export type InteractionMode =  | 'idle' // 空闲状态  | 'panning' // 画布平移  | 'selecting' // 选择元素  | 'dragging' // 拖拽元素  | 'resizing' // 调整大小  | 'drawing' // 绘制元素  | 'texting' // 文本编辑  | 'erasing' // 擦除元素  | 'rotating' // 旋转元素\nHandleType 类型export type HandleType =  | 'tl'  | 't'  | 'tr' // 上方三个手柄  | 'r' // 右侧手柄  | 'br'  | 'b'  | 'bl' // 下方三个手柄  | 'l' // 左侧手柄  | 'p0'  | 'p1' // 线段端点手柄  | 'rotate' // 旋转手柄\n3. 状态管理 (State Architecture)3.1 内部状态 (Local State)\n\n\n\n状态名\n类型\n描述\n\n\n\n\nmode\nInteractionMode\n当前交互模式\n\n\nstartPos\n{ x: number; y: number }\n操作起始位置\n\n\ncurrentId\n`string\nnull`\n当前操作元素 ID\n\n\nactiveHandle\n`HandleType\nnull`\n激活的控制手柄\n\n\nisSpacePressed\nboolean\n空格键是否按下\n\n\ndestroyed\nboolean\n是否已销毁\n\n\nresizeInitialStates\n`Record","categories":["归档"]},{"title":"SITE-193","url":"/Arknight-notes/posts/4183.html","content":"\n\nZhongye /From an Open Source Organization in Guangzhou-University*\nhttps://github.com/Guangzhou-University-SITE-193\n💻 Skills🥪 Front End / 🥗 Backend / 🍊 Network Security / 🍑 Machine Learning\n📋 Tech Stack\n关注站长博客！本站：         https://zhongye1.github.io/Arknight-notes/\n本站RSS订阅：  https://zhongye1.github.io/Arknight-notes/rss.xml\n主站：         https://zhongye1.github.io\n主站RSS订阅：  https://zhongye1.github.io/atom.xml\n193工作站：      https://github.com/Guangzhou-University-SITE-193\nGitHub：       https://github.com/Zhongye1\nQQ：2760913192\n关于本站用于做归档页面整理和知识储备，建设中\n","categories":["日志"],"tags":["日志"]},{"title":"利用chrome F12 测试应用实践详解","url":"/Arknight-notes/posts/41925.html","content":"首先介绍 Chrome 开发者工具中，调试时使用最多的三个功能页面是：元素（ELements）、控制台（Console）、源代码（Sources），此外还有网络（Network）等。\n\n\n元素（Elements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件、断点等。\n控制台（Console）：控制台一般用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。\n源代码（Sources）：该页面用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给 JS 代码添加断点等。\n网络（Network）：网络页面主要用于查看 header 等与网络连接相关的信息。\n\n1、元素（Elements）\n查看元素代码：点击如图\n\n箭头（或用者用快捷键 Ctrl+Shift+C）进入选择元素模式，然后从页面中选择需要查看的元素，然后可以在开发者工具元素（Elements）一栏中定位到该元素源代码的具体位置 。\n查看元素属性：可从被定位的源码中查看部分，如 class、src，也可在右边的侧栏中查看全部的属性，如下图位置查看\n\n修改元素的代码与属性：可直接双击想要修改的部分，然后就进行修改，或者选中要修改部分后点击右键进行修改，如下图\n**\n\n**\n注意：这个修改也仅对当前的页面渲染生效，不会修改服务器的源代码，故而这个功能也是作为调试页面效果而使用。\n右边的侧栏个功能的介绍:如下图所示\n\n2、控制台（Console）\n\n查看 JS 对象的及其属性\n执行 JS 语句\n查看控制台日志：当网页的 JS 代码中使用了 console.log()函数时，该函数输出的日志信息会在控制台中显示。日志信息一般在开发调试时启用，而当正式上线后，一般会将该函数去掉。\n\n3、源代码（Sources）其主要功能如下介绍\n\n4、网络（Network）大体功能如下：\n\n\n打开浏览器,按 f12,点击 Network,可以查看相关网络请求信息,记得是打开 f12 之后再刷新页面才会开始记录的\n\n\n\n查看 Network 基本信息,请求了哪些地址及每个 URL 的网络相关请求信息都可以看的到 URL，响应状态码，响应数据类型，响应数据大小，响应时间\n\n\n\n请求 URL 可进行筛选和分类，选择不同分类,查看请求 URL,方便查找\n\n\n\n也可以直接 Filter 搜索查询相关 URL，可以输入关键字或者正则表达式进行查询\n\n\n\nWaterfall 能分割重要的请求耗时,查看具体请求耗时在哪个地方,鼠标指到相关区域可以看到具体耗时\n\n\n\n我们具体分析下里面每个各代表什么意思,分别耗时多少,通过这个来分析服务器到底是哪个环节出了问题\n\n\nQueueing 是排队的意思\nStalled 是阻塞 请求访问该 URL 的主机是有并发和连接数限制的,必须要等之前的执行才能执行之后的,这段时间的耗时\nDNS Lookup 是指域名解析所耗时间\nInitial connection 初始化连接时间,这里一般是 TCP 3 次连接握手时间\nSSL https 特有,是一种协议\nRequest sent 发送请求所消耗的时间\nWaiting 等待响应时间,这里一般是最耗时的\nContent Download 下载内容所需要消耗的时间\n\n请求文件具体说明\n\n一共分为四个模块：\n\nHeader：面板列出资源的请求 url、HTTP 方法、响应状态码、请求头和响应头及它们各自的值、请求参数等等\nPreview：预览面板，用于资源的预览。\nResponse：响应信息面板包含资源还未进行格式处理的内容\nTiming：资源请求的详细信息花费时间\n\n转载自 chrome 浏览器中 F12 功能的简单介绍 - 知乎 (zhihu.com)\n","categories":["笔记"],"tags":["前端开发"]},{"title":"使用Neo4j图数据科学库（GDS）进行中心度分析","url":"/Arknight-notes/posts/19918.html","content":"安装并加载GDS库  \n​    确保已安装并启用GDS插件。若未安装，需从Neo4j官网下载对应版本。​    \n创建图投影在 GDS 中创建内存中的图投影：\nCALL gds.graph.project(  'nodeGraph',      // 图名称  'Node',           // 节点标签  'NEIGHBOR',       // 关系类型  {    nodeProperties: ['degree'],  // 需要加载的节点属性    relationshipProperties: {}  // 关系属性（可选）  });\n\n运行度中心性算法并写入属性 \n使用gds.degree.write方法计算每个节点的度（可指定入度、出度或总度数），并将结果存储为节点属性degree：\nCALL gds.degree.write('nodeGraph', {    writeProperty: 'degree',   // 写入的属性名    orientation: 'UNDIRECTED'  // 方向：UNDIRECTED（总度数）、NATURAL（出度）、REVERSE（入度）})YIELD nodePropertiesWritten\n\n计算中心性指标1. PageRankCALL gds.pageRank.write('nodeGraph', {  maxIterations: 20,  dampingFactor: 0.85,  writeProperty: 'pagerank'});\n2. 度中心性 (Degree Centrality)CALL gds.degree.write('nodeGraph', {  writeProperty: 'degree_centrality'});\n3. 亲密中心性 (Closeness Centrality)CALL gds.closeness.write('nodeGraph', {  writeProperty: 'closeness_centrality'});\n4. 介数中心性 (Betweenness Centrality)CALL gds.betweenness.write('nodeGraph', {  writeProperty: 'betweenness_centrality'});\n\n查询结果MATCH (n:Node)RETURN   n.address AS Address,  n.pagerank AS PageRank,  n.degree_centrality AS DegreeCentrality,  n.closeness_centrality AS ClosenessCentrality,  n.betweenness_centrality AS BetweennessCentralityORDER BY PageRank DESC;\n╒═════════════╤═══════════════════╤════════════════╤═══════════════════╤═════════════════════╕│Address      │PageRank           │DegreeCentrality│ClosenessCentrality│BetweennessCentrality│╞═════════════╪═══════════════════╪════════════════╪═══════════════════╪═════════════════════╡│\"10.104.0.73\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.105.0.71\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.105.0.72\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.101.0.73\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.103.0.71\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.101.0.71\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.107.0.73\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.108.0.73\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.107.0.71\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.103.0.73\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.106.0.71\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.101.0.72\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.104.0.71\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.109.0.72\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.109.0.73\"│0.17143947585331437│0.0             │1.0                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.103.0.72\"│0.16639351504031516│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.102.0.73\"│0.16639351504031516│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.102.0.71\"│0.16639351504031516│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.107.0.72\"│0.16638840173142871│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.106.0.73\"│0.16638840173142871│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.100.0.72\"│0.16638840173142871│28.0            │1.0                │6.833333333333333    │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.104.0.73\"│0.16620703459522992│27.0            │1.0                │4.166666666666666    │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.102.0.72\"│0.16620703459522992│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.109.0.71\"│0.16532947619296923│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.100.0.72\"│0.16532947619296923│23.0            │1.0                │2.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.105.0.73\"│0.16532947619296923│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.108.0.71\"│0.16532947619296923│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.104.0.72\"│0.16532947619296923│0.0             │0.8                │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.100.0.74\"│0.16028351537997002│27.0            │0.75               │2.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.106.0.72\"│0.16009703493488484│0.0             │0.6666666666666666 │0.0                  │├─────────────┼───────────────────┼────────────────┼───────────────────┼─────────────────────┤│\"10.108.0.72\"│0.16009703493488484│0.0             │0.6666666666666666 │0.0                  │└─────────────┴───────────────────┴────────────────┴───────────────────┴─────────────────────┘\n```\n","categories":["笔记"],"tags":["Neo4j"]},{"title":"数据结构-算法复杂度","url":"/Arknight-notes/posts/25842.html","content":"算法复杂度算法复杂度旨在计算在输入数据量 N的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数据大小 N」而增大的速度。\n算法复杂度主要可从 时间 、空间 两个角度评价：\n\n时间： 假设各操作的运行时间为固定常数，统计算法运行的「计算操作的数量」 ，以代表算法运行所需时间；\n空间： 统计在最差情况下，算法运行所需使用的「最大空间」；\n\n「输入数据大小N」指算法处理的输入数据量；根据不同算法，具有不同定义，例如：\n\n排序算法： N代表需要排序的元素数量；\n搜索算法： N代表搜索范围的元素总数，例如数组大小、矩阵大小、二叉树节点数、图节点和边数等；\n\n接下来，我们将分别从概念定义、符号表示、常见种类、时空权衡、示例解析、示例题目等角度入手，学习「时间复杂度」和「空间复杂度」。\n时间复杂度代码执行次数的简化估算值就是时间复杂度。\n一些例子\n\n线性复杂度O(N)：单层循环，如遍历数组求和。\n\n对数复杂度O(logN)：二分查找。\n\n线性对数复杂度O(NlogN)：快速排序或归并排序的分治策略。\n\n平方复杂度O(N^2)：双重循环，如冒泡排序。\n\n指数复杂度O(2^N)：递归斐波那契。\n\n阶乘复杂度O(N!)：全排列生成。\n\n\n   其中有：O(1)&lt;O(logN)&lt;O(N)&lt;O(NlogN)&lt;O(N^2)&lt;O(2^N)&lt;O(N!)\n\n基本复杂度计算层层（循环、递归）相加：比如有2层循环，第一层循环共执行n次基本语句，每个基本语句执行1次，也就是n个“1”次相加，为n；第二层循环执行log2n次第一次循环，每个第一次循环执行n次，总的也就是log2n个“n”次相加为nlog2n，故时间复杂度为O(nlogn)。\n复杂度计算的核心规则\n单层循环：直接取循环次数，如 O(n).  \n嵌套循环：各层循环次数相乘，如 O(n²) 或 O(n log n).  \n递归算法：• 递归次数 × 每次递归的操作次数，如斐波那契数列的 O(2ⁿ).• 分治策略（如归并排序）通过主定理计算，结果为 O(n log n).  \n忽略低阶项：如 T(n) = 3n² + 2n + 1 简化为 O(n²).  \n\n1. O(1) — 常数复杂度特点：运行次数与 N 大小呈常数关系，即不随输入数据大小 N 的变化而变化。\n示例：访问数组元素或交换变量。  \n// 访问数组元素int getElement(int arr[], int index) &#123;    return arr[index]; // 无论数组大小，直接访问固定位置&#125;// 交换变量void swap(int *a, int *b) &#123;    int temp = *a;    *a = *b;    *b = temp; // 仅需三次赋值操作&#125;\n\n\n2. O(log n) — 对数复杂度特点：每次操作将问题规模缩减为固定比例（如折半）。示例：二分查找。  \nint binarySearch(int arr[], int left, int right, int target) &#123;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (arr[mid] == target) return mid;        if (arr[mid] &lt; target) left = mid + 1;        else right = mid - 1; // 每次搜索范围减半    &#125;    return -1;&#125;\n如下图所示，为二分查找的时间复杂度示意图，每次二分将搜索区间缩小一半。\n\n\n3. O(n) — 线性复杂度特点：执行时间与输入规模成线性正比。示例：遍历数组求和。  \nint sumArray(int arr[], int size) &#123;    int sum = 0;    for (int i = 0; i &lt; size; i++) &#123;        sum += arr[i]; // 遍历所有元素，执行次数为n    &#125;    return sum;&#125;\n\n\n4. O(n log n) — 对数线性复杂度特点：两层循环相互独立，第一层和第二层时间复杂度分别为 O(log⁡N) 和 O(N)，则总体时间复杂度为 O(Nlog⁡N)\n结合线性与对数操作，常见于分治算法。示例：快速排序。  \nvoid quickSort(int arr[], int low, int high) &#123;    if (low &lt; high) &#123;        int pivot = partition(arr, low, high); // 分区操作O(n)        quickSort(arr, low, pivot - 1);  // 递归左半部分        quickSort(arr, pivot + 1, high); // 递归右半部分    &#125;&#125;// 每次递归将问题规模分半，递归深度为log n，每层总操作次数为n\n线性对数阶常出现于排序算法，例如「快速排序」、「归并排序」、「堆排序」等，其时间复杂度原理如下图所示。\n\n\n5. O(nᵏ) — 多项式复杂度（k=2为例）特点：嵌套循环导致时间复杂度为输入规模的k次方。示例：冒泡排序。 第一层和第二层时间复杂度分别为 O(N) 和 O(N)，则总体时间复杂度为 O(N^2) \nvoid bubbleSort(int arr[], int size) &#123;    for (int i = 0; i &lt; size-1; i++) &#123;        for (int j = 0; j &lt; size-i-1; j++) &#123;            if (arr[j] &gt; arr[j+1]) &#123;                swap(&amp;arr[j], &amp;arr[j+1]); // 双重循环，操作次数为n²            &#125;        &#125;    &#125;&#125;\n\n\n6. O(kⁿ) — 指数复杂度特点：问题规模每增加1，计算量翻倍。示例：斐波那契数列的递归实现。  \nint fibonacci(int n) &#123;    if (n &lt;= 1) return n;    return fibonacci(n-1) + fibonacci(n-2); // 每次递归分裂为两次调用，复杂度为O(2ⁿ)&#125;\n\n\n7. O(n!) — 阶乘复杂度特点：问题规模每增加1，计算量增长为阶乘级。示例：生成全排列，给定 NN 个互不重复的元素，求其所有可能的排列方案（递归回溯）。  \nint algorithm(int N) &#123;    if (N &lt;= 0) return 1;    int count = 0;    for (int i = 0; i &lt; N; i++) &#123;        count += algorithm(N - 1);    &#125;    return count;&#125;\n\n时间复杂度的意义时间复杂度不同，随着输入数据量的增加，代码运行的时间也会增加。\n例如O(1)无论输入数据如何增多，代码运行时间都不变。而O(n)的运行时间和输入数据量成正比。如果时间复杂度过高，例如O(2^n)，那么在小数据情况下，代码还可以运行，一旦数据量增大，则代码的运行时间将会几何级增加。\n\n\n代码执行时间总结如下：\n\n\n\n\n名称\n时间复杂度\n\n\n\n\n常数时间\nO(1)\n\n\n对数时间\nO(log n)\n\n\n线性时间\nO(n)\n\n\n线性对数时间\nO(nlog n)\n\n\n二次时间\nO(n^2)\n\n\n三次时间\nO(n^3)\n\n\n指数时间\nO(2^n)\n\n\n\n\n常见的时间复杂度\n\n\n\n空间复杂度\n空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少字节的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟时间复杂度类似，也使用大O渐进表示法。\n\n常数 O(1)//计算冒泡排序函数的空间复杂度void BubbleSort(int* a, int N)&#123;\tassert(a);\tfor (int i = 0; i &lt; N; i++)\t&#123;\t\tint exchange = 0;\t\tfor (int j = 0; j &lt; N - 1 - i; j++)\t\t&#123;\t\t\tif (a[j]&gt;a[j + 1])\t\t\t&#123;\t\t\t\tint tmp = a[j];\t\t\t\ta[j] = a[j + 1];\t\t\t\ta[j + 1] = tmp;\t\t\t\texchange = 1;\t\t\t&#125;\t\t&#125;\t\tif (exchange == 0)\t\t\tbreak;\t&#125;&#125;\n冒泡排序函数中使用了常数个额外空间（即常数个变量），所以用大O的渐进表示法表示冒泡排序函数的空间复杂度为O(1) 。\n线性 O(N)//计算阶乘递归函数的空间复杂度long long Factorial(size_t N)&#123;\treturn N &lt; 2 ? N : Factorial(N - 1)*N;&#125;\n阶乘递归函数会依次调用Factorial(N),Factorial(N-1),…,Factorial(2),Factorial(1)，开辟了N个空间，所以空间复杂度为O(N) 。\n\n平方 O(N²)元素数量与 N呈平方关系的任意类型集合（常见于矩阵），皆使用平方大小的空间。\n\n递归调用栈的深度每次递归调用参数递减 1，直到 N ≤ 0。递归深度为 N 次（例如 N=5 时调用链为 algorithm(5) → algorithm(4) → … → algorithm(0)）\n每次递归的临时空间占用每次递归调用时，会在栈上动态创建一个大小为 N 的整型数组 int nums[N]。随着递归深度增加，数组长度的变化为 N, N-1, N-2, …, 1\n空间累计计算总空间占用为各次递归调用中数组大小的累加：S(N)=N+(N−1)+(N−2)+⋯+1=2N(N+1)​根据大 O 表示法，简化为 ​​O(N²)​​\n\nint algorithm(int N) &#123;    if (N &lt;= 0) return 0;    int nums[N];    return algorithm(N - 1);&#125;\n\n指数 O(2ᴺ)指数阶常见于二叉树、多叉树的空间分析，例如：\n\n满二叉树\n高度为 N 的满二叉树，节点总数为 2ᴺ，空间复杂度为 O(2ᴺ)。\n\n满 m 叉树\n高度为 N 的满 m 叉树，节点总数为 mᴺ。\n当 m 为常数时，O(mᴺ) = O(2ᴺ)（指数级增长性质相同）。\n\n\n指数阶常见于二叉树、多叉树。例如，高度为 N的「满二叉树」的节点数量为 2^N，占用 O(2^N)大小的空间；同理，高度为 N的「满 m叉树」的节点数量为 m^N，占用 O(m^N)大小的空间。\n\n对数 O(log N)对数阶常出现于分治算法的栈帧空间累计、数据类型转换等，例如：\n\n快速排序，平均空间复杂度为 Θ(log N)，最差空间复杂度为 O(N)。通过应用尾递归优化，可以将快速排序的最差空间复杂度限定至 O(N)。\n数字转化为字符串，设某正整数为 N，则字符串的空间复杂度为 O(log N)。正整数 N 的位数为 log₁₀ N，即转化的字符串长度为 log₁₀ N，因此空间复杂度为 O(log N)。\n\n注：递归算法的空间复杂度通常是递归的深度（即递归多少层）。\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"数据结构-线性表（链表）","url":"/Arknight-notes/posts/42928.html","content":"链表（链式存储结构）链表又称单链表、链式存储结构，用于存储逻辑关系为“一对一”的数据。\n和顺序表不同，使用链表存储数据，不强制要求数据在内存中集中存储，各个元素可以分散存储在内存中。例如，使用链表存储 {1,2,3}，各个元素在内存中的存储状态可能是：\n\n可以看到，数据不仅没有集中存放，在内存中的存储次序也是混乱的。那么，链表是如何存储数据间逻辑关系的呢？\n链表存储数据间逻辑关系的实现方案是：为每一个元素配置一个指针，每个元素的指针都指向自己的直接后继元素，如下图所示：\n\n显然，我们只需要记住元素 1 的存储位置，通过它的指针就可以找到元素 2，通过元素 2 的指针就可以找到元素 3，以此类推，各个元素的先后次序一目了然。\n像图 2 这样，数据元素随机存储在内存中，通过指针维系数据之间“一对一”的逻辑关系，这样的存储结构就是链表。\n结点（节点）\n很多教材中，也将“结点”写成“节点”，它们是一个意思。\n\n在链表中，每个数据元素都配有一个指针，这意味着，链表上的每个“元素”都长下图这个样子：\n\n数据域用来存储元素的值，指针域用来存放指针。数据结构中，通常将图 3 这样的整体称为结点。\n也就是说，链表中实际存放的是一个一个的结点，数据元素存放在各个结点的数据域中。举个简单的例子，图 2 中 {1,2,3} 的存储状态用链表表示，如下图所示：\n\n在 C 语言中，可以用结构体表示链表中的结点，例如：\ntypedef struct link&#123;    char elem; //代表数据域    struct link * next; //代表指针域，指向直接后继元素&#125;Link;\n\n我们习惯将结点中的指针命名为 next，因此指针域又常称为“Next 域”。\n\n头结点、头指针和首元结点图 4 所示的链表并不完整，一个完整的链表应该由以下几部分构成：\n\n头指针：一个和结点类型相同的指针，它的特点是：永远指向链表中的第一个结点。上文提到过，我们需要记录链表中第一个元素的存储位置，就是用头指针实现。\n结点：链表中的节点又细分为头结点、首元结点和其它结点：\n\n\n头结点：某些场景中，为了方便解决问题，会故意在链表的开头放置一个空结点，这样的结点就称为头结点。也就是说，头结点是位于链表开头、数据域为空（不利用）的结点。\n首元结点：指的是链表开头第一个存有数据的结点。\n其他节点：链表中其他的节点。\n\n也就是说，一个完整的链表是由头指针和诸多个结点构成的。每个链表都必须有头指针，但头结点不是必须的。\n例如，创建一个包含头结点的链表存储 {1,2,3}，如下图所示：\n\n再次强调，头指针永远指向链表中的第一个结点。换句话说，如果链表中包含头结点，那么头指针指向的是头结点，反之头指针指向首元结点。\n链表的创建创建一个链表，实现步骤如下：\n\n定义一个头指针；\n创建一个头结点或者首元结点，让头指针指向它；\n每创建一个结点，都令其直接前驱结点的指针指向它。\n\n例如，创建一个存储 {1,2,3,4} 且无头节点的链表，C 语言实现代码为：\nLink* initLink() &#123;    int i;    //1、创建头指针    Link* p = NULL;    //2、创建首元结点    Link* temp = (Link*)malloc(sizeof(Link));    temp-&gt;elem = 1;    temp-&gt;next = NULL;    //头指针指向首元结点    p = temp;    //3、每创建一个结点，都令其直接前驱结点的指针指向它    for (i = 2; i &lt; 5; i++) &#123;        //创建一个结点        Link* a = (Link*)malloc(sizeof(Link));        a-&gt;elem = i;        a-&gt;next = NULL;        //每次 temp 指向的结点就是 a 的直接前驱结点        temp-&gt;next = a;        //temp指向下一个结点（也就是a),为下次添加结点做准备        temp = temp-&gt;next;    &#125;    return p;&#125;\n再比如，创建一个存储 {1,2,3,4} 且含头节点的链表，则 C 语言实现代码为：\nLink* initLink() &#123;    int i;    //1、创建头指针    Link* p = NULL;    //2、创建头结点    Link* temp = (Link*)malloc(sizeof(Link));    temp-&gt;elem = 0;    temp-&gt;next = NULL;    //头指针指向头结点    p = temp;    //3、每创建一个结点，都令其直接前驱结点的指针指向它    for (i = 1; i &lt; 5; i++) &#123;        //创建一个结点        Link* a = (Link*)malloc(sizeof(Link));        a-&gt;elem = i;        a-&gt;next = NULL;        //每次 temp 指向的结点就是 a 的直接前驱结点        temp-&gt;next = a;        //temp指向下一个结点（也就是a),为下次添加结点做准备        temp = temp-&gt;next;    &#125;    return p;&#125;\n链表的使用对于创建好的链表，我们可以依次获取链表中存储的数据，例如：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//链表中节点的结构typedef struct link &#123;    int  elem;    struct link* next;&#125;Link;Link* initLink() &#123;    int i;    //1、创建头指针    Link* p = NULL;    //2、创建头结点    Link* temp = (Link*)malloc(sizeof(Link));    temp-&gt;elem = 0;    temp-&gt;next = NULL;    //头指针指向头结点    p = temp;    //3、每创建一个结点，都令其直接前驱结点的指针指向它    for (i = 1; i &lt; 5; i++) &#123;        //创建一个结点        Link* a = (Link*)malloc(sizeof(Link));        a-&gt;elem = i;        a-&gt;next = NULL;        //每次 temp 指向的结点就是 a 的直接前驱结点        temp-&gt;next = a;        //temp指向下一个结点（也就是a),为下次添加结点做准备        temp = temp-&gt;next;    &#125;    return p;&#125;void display(Link* p) &#123;    Link* temp = p;//temp指针用来遍历链表    //只要temp指向结点的next值不是NULL，就执行输出语句。    while (temp) &#123;        Link* f = temp;//准备释放链表中的结点        printf(&quot;%d &quot;, temp-&gt;elem);        temp = temp-&gt;next;        free(f);    &#125;    printf(&quot;\\n&quot;);&#125;int main() &#123;    Link* p = NULL;    printf(&quot;初始化链表为：\\n&quot;);    //创建链表&#123;1,2,3,4&#125;    p = initLink();    //输出链表中的数据    display(p);    return 0;&#125;\n程序中创建的是带头结点的链表，头结点的数据域存储的是元素 0，因此最终的输出结果为：\n\n0 1 2 3 4\n\n如果不想输出头结点的值，可以将 p-&gt;next 作为实参传递给 display() 函数。\n如果程序中创建的是不带头结点的链表，最终的输出结果应该是：\n\n1 2 3 4\n\n单链表的基本操作学会创建链表之后，本节继续讲解链表的一些基本操作，包括向链表中添加数据、删除链表中的数据、查找和更改链表中的数据。\n首先，创建一个带头结点的链表，链表中存储着 {1,2,3,4}：\n//链表中节点的结构typedef struct link &#123;    int  elem;    struct link* next;&#125;Link;Link* initLink() &#123;    int i;    //1、创建头指针    Link* p = NULL;    //2、创建头结点    Link* temp = (Link*)malloc(sizeof(Link));    temp-&gt;elem = 0;    temp-&gt;next = NULL;    //头指针指向头结点    p = temp;    //3、每创建一个结点，都令其直接前驱结点的指针指向它    for (i = 1; i &lt; 5; i++) &#123;        //创建一个结点        Link* a = (Link*)malloc(sizeof(Link));        a-&gt;elem = i;        a-&gt;next = NULL;        //每次 temp 指向的结点就是 a 的直接前驱结点        temp-&gt;next = a;        //temp指向下一个结点（也就是a),为下次添加结点做准备        temp = temp-&gt;next;    &#125;    return p;&#125;\n链表插入元素同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：\n\n插入到链表的头部，作为首元节点；\n插入到链表中间的某个位置；\n插入到链表的最末端，作为链表中最后一个结点；\n\n对于有头结点的链表，3 种插入元素的实现思想是相同的，具体步骤是：\n\n将新结点的 next 指针指向插入位置后的结点；\n将插入位置前结点的 next 指针指向插入结点；\n\n例如，在链表 {1,2,3,4}的基础上分别实现在头部、中间、尾部插入新元素 5，其实现过程如下图所示：\n\n从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。实现代码如下：\nvoid insertElem(Link* p, int elem, int add) &#123;    int i;    Link* c = NULL;    Link* temp = p;//创建临时结点temp    //首先找到要插入位置的上一个结点    for (i = 1; i &lt; add; i++) &#123;        temp = temp-&gt;next;        if (temp == NULL) &#123;            printf(&quot;插入位置无效\\n&quot;);            return;        &#125;    &#125;    //创建插入结点c    c = (Link*)malloc(sizeof(Link));    c-&gt;elem = elem;    //① 将新结点的 next 指针指向插入位置后的结点    c-&gt;next = temp-&gt;next;    //② 将插入位置前结点的 next 指针指向插入结点；    temp-&gt;next = c;&#125;\n注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 1。\n对于没有头结点的链表，在头部插入结点比较特殊，需要单独实现。\n\n和 2)、3) 种情况相比，由于链表没有头结点，在头部插入新结点，此结点之前没有任何结点，实现的步骤如下：\n\n将新结点的指针指向首元结点；\n将头指针指向新结点。\n\n实现代码如下：\nLink* insertElem(Link* p, int elem, int add) &#123;    if (add == 1) &#123;        //创建插入结点c        Link* c = (Link*)malloc(sizeof(Link));        c-&gt;elem = elem;        c-&gt;next = p;        p = c;        return p;    &#125;    else &#123;        int i;        Link* c = NULL;        Link* temp = p;//创建临时结点temp        //首先找到要插入位置的上一个结点        for (i = 1; i &lt; add-1; i++) &#123;            temp = temp-&gt;next;            if (temp == NULL) &#123;                printf(&quot;插入位置无效\\n&quot;);                return p;            &#125;        &#125;        //创建插入结点c        c = (Link*)malloc(sizeof(Link));        c-&gt;elem = elem;        //向链表中插入结点        c-&gt;next = temp-&gt;next;        temp-&gt;next = c;        return p;    &#125;&#125;\n\n注意当 add==1 成立时，形参指针 p 的值会发生变化，因此需要它的新值作为函数的返回值返回。\n\n链表删除元素从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除。\n对于有头结点的链表来说，无论删除头部（首元结点）、中部、尾部的结点，实现方式都一样，执行以下三步操作：\n\n找到目标元素所在结点的直接前驱结点；\n将目标结点从链表中摘下来;\n手动释放结点占用的内存空间；\n\n从链表上摘除目标节点，只需找到该节点的直接前驱节点 temp，执行如下操作：\ntemp-&gt;next=temp-&gt;next-&gt;next;\n例如，从存有 {1,2,3,4}的链表中删除存储元素 3 的结点，则此代码的执行效果如图 3 所示：\n\n实现代码如下：\n//p为原链表，elem 为要删除的目标元素int delElem(Link* p, int elem) &#123;    Link* del = NULL, *temp = p;    int find = 0;    //1、找到目标元素的直接前驱结点    while (temp-&gt;next) &#123;        if (temp-&gt;next-&gt;elem == elem) &#123;            find = 1;            break;        &#125;        temp = temp-&gt;next;    &#125;    if (find == 0) &#123;        return -1;//删除失败    &#125;    else    &#123;        //标记要删除的结点        del = temp-&gt;next;        //2、将目标结点从链表上摘除        temp-&gt;next = temp-&gt;next-&gt;next;        //3、释放目标结点        free(del);        return 1;    &#125;&#125;\n对于不带头结点的链表，需要单独考虑删除首元结点的情况，删除其它结点的方式和上图完全相同，如下图所示：\n\n实现代码如下：\n//p为原链表，elem 为要删除的目标元素int delElem(Link** p, int elem) &#123;    Link* del = NULL, *temp = *p;    //删除首元结点需要单独考虑    if (temp-&gt;elem == elem) &#123;        (*p) = (*p)-&gt;next;        free(temp);        return 1;    &#125;    else    &#123;        int find = 0;        //1、找到目标元素的直接前驱结点        while (temp-&gt;next) &#123;            if (temp-&gt;next-&gt;elem == elem) &#123;                find = 1;                break;            &#125;            temp = temp-&gt;next;        &#125;        if (find == 0) &#123;            return -1;//删除失败        &#125;        else        &#123;            //标记要删除的结点            del = temp-&gt;next;            //2、将目标结点从链表上摘除            temp-&gt;next = temp-&gt;next-&gt;next;            //3、释放目标结点            free(del);            return 1;        &#125;    &#125;&#125;\n函数返回 1 时，表示删除成功；返回 -1，表示删除失败。注意，该函数的形参 p 为二级指针，调用时需要传递链表头指针的地址。\n链表查找元素在链表中查找指定数据元素，最常用的方法是：从首元结点开始依次遍历所有节点，直至找到存储目标元素的结点。如果遍历至最后一个结点仍未找到，表明链表中没有存储该元素。\n因此，链表中查找特定数据元素的 C 语言实现代码为：\n//p为原链表，elem表示被查找元素int selectElem(Link* p, int elem) &#123;    int i = 1;    //带头结点，p 指向首元结点    p = p-&gt;next;    while (p) &#123;        if (p-&gt;elem == elem) &#123;            return i;        &#125;        p = p-&gt;next;        i++;    &#125;    return -1;//返回-1，表示未找到&#125;\n注意第 5 行代码，对于有结点的链表，需要先将 p 指针指向首元结点；反之，对于不带头结点的链表，注释掉第 5 行代码即可。\n链表更新元素更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。\n直接给出链表中更新数据元素的 C 语言实现代码：\n//p 为有头结点的链表，oldElem 为旧元素，newElem 为新元素int amendElem(Link* p, int oldElem, int newElem) &#123;    p = p-&gt;next;    while (p) &#123;        if (p-&gt;elem == oldElem) &#123;            p-&gt;elem = newElem;            return 1;        &#125;        p = p-&gt;next;    &#125;    return -1;&#125;\n函数返回 1，表示更改成功；返回数字 -1，表示更改失败。如果是没有头结点的链表，直接删除第 3 行代码即可。\n\n双向链表目前我们所学到的链表，无论是动态链表还是静态链表，表中各个节点都只包含一个指针（游标），且都统一指向直接后继节点，这类链表又统称为单向链表或单链表。\n虽然单链表能 100% 存储逻辑关系为 “一对一” 的数据，但在解决某些实际问题时，单链表的执行效率并不高。例如，若实际问题中需要频繁地查找某个结点的前驱结点，使用单链表存储数据显然没有优势，因为单链表的强项是从前往后查找目标元素，不擅长从后往前查找元素。\n解决此类问题，可以建立双向链表（简称双链表）。\n双向链表是什么从名字上理解双向链表，即链表是 “双向” 的，如下图所示：\n\n“双向”指的是各节点之间的逻辑关系是双向的，头指针通常只设置一个。\n从上图中可以看到，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：\n\n指针域：用于指向当前节点的直接前驱节点；\n数据域：用于存储数据元素。\n指针域：用于指向当前节点的直接后继节点；\n\n\n因此，双链表的节点结构用 C 语言实现为：\ntypedef struct line&#123;    struct line * prior; //指向直接前趋    int data;    struct line * next; //指向直接后继&#125;Line;\n双向链表的创建同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。\n需要注意的是，与单链表不同，双链表创建过程中，每创建一个新节点都要与其前驱节点建立两次联系，分别是：\n\n将新节点的 prior 指针指向直接前驱节点；\n将直接前驱节点的 next 指针指向新节点；\n\n这里给出创建双向链表的 C 语言实现代码：\nLine* initLine(Line* head) &#123;    Line* list = NULL;    head = (Line*)malloc(sizeof(Line));//创建链表第一个结点（首元结点）    head-&gt;prior = NULL;    head-&gt;next = NULL;    head-&gt;data = 1;    list = head;    for (int i = 2; i &lt;= 5; i++) &#123;        //创建并初始化一个新结点        Line* body = (Line*)malloc(sizeof(Line));        body-&gt;prior = NULL;        body-&gt;next = NULL;        body-&gt;data = i;        //直接前趋结点的next指针指向新结点        list-&gt;next = body;        //新结点指向直接前趋结点        body-&gt;prior = list;        list = list-&gt;next;    &#125;    return head;&#125;\n我们可以尝试着在 main 函数中输出创建的双链表，C 语言代码如下：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct line &#123;    struct line* prior; //指向直接前趋    int data;    struct line* next; //指向直接后继&#125;Line;Line* initLine(Line* head) &#123;    int i;    Line* list = NULL;    head = (Line*)malloc(sizeof(Line));//创建链表第一个结点（首元结点）    head-&gt;prior = NULL;    head-&gt;next = NULL;    head-&gt;data = 1;    list = head;    for (i = 2; i &lt;= 5; i++) &#123;        //创建并初始化一个新结点        Line* body = (Line*)malloc(sizeof(Line));        body-&gt;prior = NULL;        body-&gt;next = NULL;        body-&gt;data = i;        //直接前趋结点的next指针指向新结点        list-&gt;next = body;        //新结点指向直接前趋结点        body-&gt;prior = list;        list = list-&gt;next;    &#125;    return head;&#125;//输出链表中的数据void display(Line* head) &#123;    Line* temp = head;    while (temp) &#123;        //如果该节点无后继节点，说明此节点是链表的最后一个节点        if (temp-&gt;next == NULL) &#123;            printf(&quot;%d\\n&quot;, temp-&gt;data);        &#125;        else &#123;            printf(&quot;%d &lt;-&gt; &quot;, temp-&gt;data);        &#125;        temp = temp-&gt;next;    &#125;&#125;//释放链表中结点占用的空间void free_line(Line* head) &#123;    Line* temp = head;    while (temp) &#123;        head = head-&gt;next;        free(temp);        temp = head;    &#125;&#125;int main()&#123;    //创建一个头指针    Line* head = NULL;    //调用链表创建函数    head = initLine(head);    //输出创建好的链表    display(head);    //显示双链表的优点    printf(&quot;链表中第 4 个节点的直接前驱是：%d&quot;, head-&gt;next-&gt;next-&gt;next-&gt;prior-&gt;data);    free_line(head);    return 0;&#125;\n程序运行结果：\n\n1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 链表中第 4 个节点的直接前驱是：3\n\n双向链表基本操作前面学习了如何创建一个双向链表，本节学习有关双向链表的一些基本操作，即如何在双向链表中添加、删除、查找或更改数据元素。\n本节知识基于已熟练掌握双向链表创建过程的基础上，我们继续上节所创建的双向链表来学习本节内容，创建好的双向链表如下图所示：\n\n图 双向链表示意图\n双向链表添加节点根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：\n1) 添加至表头\n将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。\n换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：\n\ntemp-&gt;next=head; head-&gt;prior=temp;\n将 head 移至 temp，重新指向新的表头；\n\n例如，将新元素 7 添加至双链表的表头，则实现过程如图 2 所示：\n\n图 添加元素至双向链表的表头\n2) 添加至表的中间位置\n同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，如下图所示：\n\n新节点先与其直接后继节点建立双层逻辑关系；\n新节点的直接前驱节点与之建立双层逻辑关系；\n\n\n图 双向链表中间位置添加数据元素\n3) 添加至表尾\n与添加到表头是一个道理，实现过程如下（如图 4 所示）：\n\n找到双链表中最后一个节点；\n让新节点与最后一个节点进行双层逻辑关系；\n\n\n图 双向链表尾部添加数据元素\n因此，我们可以试着编写双向链表添加数据的 C 语言代码，参考代码如下：\nLine* insertLine(Line* head, int data, int add) &#123;    //新建数据域为data的结点    Line* temp = (Line*)malloc(sizeof(Line));    temp-&gt;data = data;    temp-&gt;prior = NULL;    temp-&gt;next = NULL;    //插入到链表头，要特殊考虑    if (add == 1) &#123;        temp-&gt;next = head;        head-&gt;prior = temp;        head = temp;    &#125;    else &#123;        int i;        Line* body = head;        //找到要插入位置的前一个结点        for (i = 1; i &lt; add - 1; i++) &#123;            body = body-&gt;next;            //只要 body 不存在，表明插入位置输入错误            if (!body) &#123;                printf(&quot;插入位置有误！\\n&quot;);                return head;            &#125;        &#125;        //判断条件为真，说明插入位置为链表尾，实现第 2 种情况        if (body &amp;&amp; (body-&gt;next == NULL)) &#123;            body-&gt;next = temp;            temp-&gt;prior = body;        &#125;        else &#123;            //第 2 种情况的具体实现            body-&gt;next-&gt;prior = temp;            temp-&gt;next = body-&gt;next;            body-&gt;next = temp;            temp-&gt;prior = body;        &#125;    &#125;    return head;&#125;\n双向链表删除节点和添加结点的思想类似，在双向链表中删除目标结点也分为 3 种情况。\n1) 删除表头结点\n删除表头结点的过程如下图所示：\n\n删除表头结点的实现过程是：\n\n新建一个指针指向表头结点；\n断开表头结点和其直接后续结点之间的关联，更改 head 头指针的指向，同时将其直接后续结点的 prior 指针指向 NULL；\n释放表头结点占用的内存空间。\n删除表中结点\n\n删除表中结点的过程如下图所示：\n\n删除表中结点的实现过程是：\n\n找到目标结点，新建一个指针指向改结点；\n将目标结点从链表上摘除；\n释放该结点占用的内存空间。\n删除表尾结点\n\n删除表尾结点的过程如下图所示：\n\n删除表尾结点的实现过程是：\n\n找到表尾结点，新建一个指针指向该结点；\n断点表尾结点和其直接前驱结点的关联，并将其直接前驱结点的 next 指针指向 NULL；\n释放表尾结点占用的内存空间。\n\n双向链表删除节点的 C 语言实现代码如下：\n//删除结点的函数，data为要删除结点的数据域的值Line* delLine(Line* head, int data) &#123;    Line* temp = head;    while (temp) &#123;        if (temp-&gt;data == data) &#123;            //删除表头结点            if (temp-&gt;prior == NULL) &#123;                head = head-&gt;next;                if (head) &#123;                    head-&gt;prior = NULL;                    temp-&gt;next = NULL;                &#125;                free(temp);                return head;            &#125;            //删除表中结点            if (temp-&gt;prior &amp;&amp; temp-&gt;next) &#123;                temp-&gt;next-&gt;prior = temp-&gt;prior;                temp-&gt;prior-&gt;next = temp-&gt;next;                free(temp);                return head;            &#125;            //删除表尾结点            if (temp-&gt;next == NULL) &#123;                temp-&gt;prior-&gt;next = NULL;                temp-&gt;prior = NULL;                free(temp);                return head;            &#125;        &#125;        temp = temp-&gt;next;    &#125;    printf(&quot;表中没有目标元素，删除失败\\n&quot;);    return head;&#125;\n双向链表查找节点通常情况下，双向链表和单链表一样都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，也是从表头依次遍历表中元素。\nC 语言实现代码为：\n//head为原双链表，elem表示被查找元素int selectElem(line * head,int elem)&#123;//新建一个指针t，初始化为头指针 head    line * t=head;    int i=1;    while (t) &#123;        if (t-&gt;data==elem) &#123;            return i;        &#125;        i++;        t=t-&gt;next;    &#125;    //程序执行至此处，表示查找失败    return -1;&#125;\n双向链表更改节点更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。\n实现此操作的 C 语言实现代码如下：\n//更新函数，其中，add 表示要修改的元素，newElem 为新数据的值void amendElem(Line* p, int oldElem, int newElem) &#123;    Line* temp = p;    int find = 0;    //找到要修改的目标结点    while (temp)    &#123;        if (temp-&gt;data == oldElem) &#123;            find = 1;            break;        &#125;        temp = temp-&gt;next;    &#125;    //成功找到，则进行更改操作    if (find == 1) &#123;        temp-&gt;data = newElem;        return;    &#125;    //查找失败，输出提示信息    printf(&quot;链表中未找到目标元素，更改失败\\n&quot;);&#125;\n循环链表无论静态链表还是动态链表，有时在解决具体问题时，需要我们对其结构进行稍微地调整。比如，可以把链表的两头连接，使其成为了一个环状链表，通常称为循环链表。\n和它名字的表意一样，只需要将表中最后一个结点的指针指向头结点，链表就能成环儿，如下图所示。\n\n需要注意的是，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。\n这里给大家一个循环链表的实例，用循环链表实现约瑟夫环\n循环链表实现约瑟夫环 - 玩转C语言和数据结构xiexuewu.github.io/view/7.html\n双向循环链表我们知道，单链表通过首尾连接可以构成单向循环链表，如下图所示：\n\n同样，双向链表也可以进行首尾连接，构成双向循环链表。如下图所示：\n\n解决某些问题，可能既需要正向遍历数据，又需要逆向遍历数据，这时就可以考虑使用双向循环链表。\n双向循环链表的创建创建双向循环链表，只需在创建完成双向链表的基础上，将其首尾节点进行双向连接即可。\nC 语言实现代码如下：\n//创建双向循环链表Line* initLine(Line* head) &#123;    int i;    Line* list = NULL;    head = (Line*)malloc(sizeof(Line));//创建链表第一个结点（首元结点）    head-&gt;prior = NULL;    head-&gt;next = NULL;    head-&gt;data = 1;    list = head;    for (i = 2; i &lt;= 3; i++) &#123;        //创建并初始化一个新结点        Line* body = (Line*)malloc(sizeof(Line));        body-&gt;prior = NULL;        body-&gt;next = NULL;        body-&gt;data = i;        //直接前趋结点的next指针指向新结点        list-&gt;next = body;        //新结点指向直接前趋结点        body-&gt;prior = list;        list = list-&gt;next;    &#125;    //通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接    list-&gt;next=head;    head-&gt;prior=list;    return head;&#125;\n通过向 main 函数中调用 initLine 函数，就可以成功创建一个存储有 {1,2,3} 数据的双向循环链表，其完整的 C 语言实现代码为：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct line &#123;    struct line* prior; //指向直接前趋    int data;    struct line* next; //指向直接后继&#125;Line;//创建双向循环链表Line* initLine(Line* head) &#123;    int i;    Line* list = NULL;    head = (Line*)malloc(sizeof(Line));//创建链表第一个结点（首元结点）    head-&gt;prior = NULL;    head-&gt;next = NULL;    head-&gt;data = 1;    list = head;    for (i = 2; i &lt;= 3; i++) &#123;        //创建并初始化一个新结点        Line* body = (Line*)malloc(sizeof(Line));        body-&gt;prior = NULL;        body-&gt;next = NULL;        body-&gt;data = i;        //直接前趋结点的next指针指向新结点        list-&gt;next = body;        //新结点指向直接前趋结点        body-&gt;prior = list;        list = list-&gt;next;    &#125;    //通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接    list-&gt;next = head;    head-&gt;prior = list;    return head;&#125;//输出链表中的数据void display(Line* head) &#123;    Line* temp = head;    //由于是循环链表，所以当遍历指针temp指向的下一个节点是head时，证明此时已经循环至链表的最后一个节点    while (temp-&gt;next != head) &#123;        if (temp-&gt;next == NULL) &#123;            printf(&quot;%d\\n&quot;, temp-&gt;data);        &#125;        else &#123;            printf(&quot;%d-&gt;&quot;, temp-&gt;data);        &#125;        temp = temp-&gt;next;    &#125;    //输出循环链表中最后一个节点的值    printf(&quot;%d&quot;, temp-&gt;data);&#125;//释放链表中结点占用的空间void free_line(Line* head) &#123;    Line* temp = NULL;    //切断循环    head-&gt;prior-&gt;next = NULL;    //从第一个结点开始，依次 free    temp = head;    while (temp) &#123;        head = head-&gt;next;        free(temp);        temp = head;    &#125;&#125;int main()&#123;    //创建一个头指针    Line* head = NULL;    //调用链表创建函数    head = initLine(head);    //输出创建好的链表    display(head);    //手动释放链表占用的内存    free_line(head);    return 0;&#125;\n程序输出结果如下：\n\n1-&gt;2-&gt;3\n\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"数据结构-绪论","url":"/Arknight-notes/posts/45088.html","content":"1.1 数据结构的基本概念　　数据、数据元素、数据对象、数据结构、存储结构、数据类型和抽象数据类型。\n\n数据(data)是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。数据元素(data element)是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。数据对象(data object)是性质相同的数据元素的集合，是数据的一个子集。数据结构(data structure)是相互之间存在一种或多种特定关系的数据元素的集合。存储结构（物理结构）是数据结构在计算机中的表示（又称映像）。数据类型(data type)是一个值的集合和定义在这个值集上的一组操作的总称。抽象数据类型(Abstract Data Type)是指一个数学模型以及定义在该模型上的一组操作。\n\n抽象数据类型的定义ADT 抽象数据类型名&#123;    数据对象：数据对象的定义    数据关系：数据关系的定义    基本操作：基本操作的定义&#125;ADT 抽象数据类型名\n例子如下\n抽象数据类型复数和有理数的定义（有理数是其分子、分母均为自然数且分母不为零的分数）。\n复数定义：ADT Complex  //复数定义 a±bi&#123;    数据对象：D = &#123;a, b | a,b为实数&#125;    数据关系：R = &#123;&lt;a, b&gt;&#125;    基本操作：        InitComplex(&amp;C, re, im)            操作结果：构造一个复数C，其实部和虚部分别为re和im        DestroyCmoplex(&amp;C)            操作结果：销毁复数C        Get(C, k, &amp;e)            初始条件：复数C已存在            操作结果：用e返回复数C的第k元的值        Put(&amp;C, k, e)            初始条件：复数C已存在            操作结果：改变复数C的第k元的值为e        IsAscending(C)            初始条件：复数C已存在            操作结果：如果复数C的两个元素按升序排列，则返回1，否则返回0        IsDescending(C)            初始条件：复数C已存在            操作结果：如果复数C的两个元素按降序排列，则返回1，否则返回0        Max(C, &amp;e)            初始条件：复数C已存在            操作结果：用e返回复数C的两个元素中值较大的一个        Min(C, &amp;e)            初始条件：复数C已存在            操作结果：用e返回复数C的两个元素中值较小的一个&#125;ADT Complex\n有理数定义：ADT RationalNumber  //有理数定义&#123;    数据对象：D=&#123;s, m | s,m为自然数，且m不为0&#125;    数据关系：R=&#123;&lt;s, m&gt;&#125;    基本操作：        InitRationalNumber(&amp;R, s, m)            操作结果：构造一个有理数R，其分子和分母分别为s和m        DestroyRationalNumber(&amp;R)            操作结果：销毁有理数R        Get(R, k, &amp;e)            初始条件：有理数R已存在            操作结果：用e返回有理数R的第k元的值        Put(&amp;R, k, e)            初始条件：有理数R已存在            操作结果：改变有理数R的第k元的值为e        IsAscending(R)            初始条件：有理数R已存在            操作结果：若有理数R的两个元素按升序排列，则返回1，否则返回0        IsDescending(R)            初始条件：有理数R已存在            操作结果：若有理数R的两个元素按降序排列，则返回1，否则返回0        Max(R, &amp;e)            初始条件：有理数R已存在            操作结果：用e返回有理数R的两个元素中值较大的一个        Min(R, &amp;e)            初始条件：有理数R已存在            操作结果：用e返回有理数R的两个元素中值较小的一个&#125;ADT RationalNumber\n　　\n根据数据元素之间关系的 不同特性，通常有下列几种类基本结构：\n(1) 集合 结构中的 如生 数据元素之间除了“同属千一个集合”的关系外，别无其他关系\n(2) 线性结构 结构中的数据元素之间存在一个对 一个的关系；\n(3) 树形结构 结构中的数据元素之间存在一 个对多个的关系； \n(4) 图状结构或网状结构 结构中的数据 元素之间存在多个对多个的关系。\n1.1.2 数据结构三要素　　　　① 逻辑结构\n　　　　　　逻辑结构指数据元素之间存在的逻辑关系，是固有的客观联系；\n　　　　　　逻辑结构分为线性结构与非线性结构，比如：线性表、树、图等；\n　　　　② 存储结构\n　　　　　　存储结构又称为物理结构，指数据结构在计算机中的表示（映像），是计算机内部的存储方法；\n　　　　　　存储结构主要有顺序存储、链式存储、索引存储和散列存储；\n　　　　　　一种逻辑结构通过映像便可以得到它的存储结构；\n　　　　　　诸如顺序表、哈希表、链表这样的表述，它们既体现了逻辑结构（均为线性），又体现了存储结构（顺序、散列、链式）；\n　　　　　　而这样的表述我们往往就直接称之为数据结构；\n　　　　　　诸如有序表，它只体现了逻辑结构（线性），而存储结构是未知的（可以是顺序、链式……）；\n　　　　　　不存在只体现存储结构而不体现逻辑结构的表述；\n　　　　　　所以，我们认为：逻辑结构独立于存储结构。\n　　　　③ 数据的运算（算法）\n　　　　　　算法包括运算的定义（取决于逻辑结构，体现算法功能）与实现（取决于存储结构，体现于操作步骤）。\n1.2 算法的基本概念　　算法的 5 个重要特性：有穷性、确定性、有效性（可行性）、输入，输出；\n　　一个好的算法的目标：正确性、可读性、鲁棒性、效率与低存储量需求。\n1.3 算法分析\n　　时间复杂度指算法所有语句被重复执行次数总和的数量级。\n　　常见时间复杂度比较：\n　　　　O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)\n　　　　(log 表示以 2 为底的对数)\n　　空间复杂度指算法耗费存储空间的数量级。\n1.4 时间复杂度的计算\n计算时间复杂度问题规模——&gt; 输入量的多少\n语句频度——&gt; 一条语句的重复执行次数\n执行时间&lt;—— 所有语句频度之和\n\n1.基本操作，即只有常数项，认为其时间复杂度为O(1)2.顺序结构，时间复杂度按加法进行计算3.循环结构，时间复杂度按乘法进行计算4.分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略5.在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度\n\n　　\n循环条件包含主体变量\n将执行次数代入循环条件进行求解：\n示例1：\nint i = 1;while (i &lt;= n)     i = i * 2;\n\n每次循环后 i =2t（t 为执行次数）\n终止条件：2t ≤ n\n解得 t ≤ log2n\n时间复杂度：T(n) = O(logn)\n\n示例2：\nint i = 3;while ((i + 1) * (i + 1) &lt; n)     i = i + 1;\n\n令 t=i−3，则 i=t+3\n代入条件：(t+3+1)2&lt;n⟹(t+4)2&lt;n\n解得 t&lt;n−4\n时间复杂度：T(n)=O(n)\n\n\n循环条件与主体变量无关\n通过数学归纳法或递归展开直接计数：\n示例（递归函数）：\nint fact(int n) &#123;    if (n &lt;= 1) return 1;    return n * fact(n - 1);&#125;\n\n递归方程：T(n)=1+T(n−1)\n展开递推：T(n)=1+T(n−1)=1+1+T(n−2) ⋮=k+T(n−k)(当 k=n−1)=(n−1)+T(1)=O(n)\n时间复杂度：T(n)=O(n)\n\n常见的数据结构如下图所示，常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。\n\n\n数组数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。\n如下图所示，构建此数组需要在初始化时给定长度，并对数组每个索引元素赋值，代码如下：\n// 初始化一个长度为 5 的数组 arrayint array[5];// 元素赋值array[0] = 2;array[1] = 3;array[2] = 1;array[3] = 0;array[4] = 2;\n或者可以使用直接赋值的初始化方式，代码如下：\nint array[] = &#123;2, 3, 1, 0, 2&#125;;\n\n「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。\n// 初始化可变数组vector&lt;int&gt; array;// 向尾部添加元素array.push_back(2);array.push_back(3);array.push_back(1);array.push_back(0);array.push_back(2);\n\n链表链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 val」，「后继节点引用 next」 。\nstruct ListNode &#123;    int val;        // 节点值    ListNode *next; // 后继节点引用    ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;\n如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。\n// 实例化节点ListNode *n1 = new ListNode(4); // 节点 headListNode *n2 = new ListNode(5);ListNode *n3 = new ListNode(1);// 构建引用指向n1-&gt;next = n2;n2-&gt;next = n3;\n\n\n栈栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。\nstack&lt;int&gt; stk;\n如下图所示，通过常用操作「入栈 push()」,「出栈 pop()」，展示了栈的先入后出特性。\nstk.push(1); // 元素 1 入栈stk.push(2); // 元素 2 入栈stk.pop();   // 出栈 -&gt; 元素 2stk.pop();   // 出栈 -&gt; 元素 1\n\n\n队列队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。\nqueue&lt;int&gt; que;\n如下图所示，通过常用操作「入队 push()」,「出队 pop()」，展示了队列的先入先出特性。\nque.push(1); // 元素 1 入队que.push(2); // 元素 2 入队que.pop();   // 出队 -&gt; 元素 1que.pop();   // 出队 -&gt; 元素 2\n\n\n树树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。\nstruct TreeNode &#123;    int val;         // 节点值    TreeNode *left;  // 左子节点    TreeNode *right; // 右子节点    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;\n如下图所示，建立此二叉树需要实例化每个节点，并构建各节点的引用指向。\n// 初始化节点TreeNode *n1 = new TreeNode(3); // 根节点 rootTreeNode *n2 = new TreeNode(4);TreeNode *n3 = new TreeNode(5);TreeNode *n4 = new TreeNode(1);TreeNode *n5 = new TreeNode(2);// 构建引用指向n1-&gt;left = n2;n1-&gt;right = n3;n2-&gt;left = n4;n2-&gt;right = n5;\n\n\n图图是一种非线性数据结构，由「节点（顶点）vertex」和「边 edge」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。本文 以无向图为例 开展介绍。\n如下图所示，此无向图的 顶点 和 边 集合分别为：\n\n顶点集合： vertices = &#123;1, 2, 3, 4, 5&#125;\n边集合： edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;\n\n\n表示图的方法通常有两种：\n邻接矩阵：\nint vertices[5] = &#123;1, 2, 3, 4, 5&#125;;int edges[5][5] = &#123;&#123;0, 1, 1, 1, 1&#125;,                   &#123;1, 0, 0, 1, 0&#125;,                   &#123;1, 0, 0, 0, 1&#125;,                   &#123;1, 1, 0, 0, 1&#125;,                   &#123;1, 0, 1, 1, 0&#125;&#125;;\n\n邻接表：\n\n顶点存储: 数组 vertices 存储顶点值\n边存储: 二维容器 edges 存储边关系\n第一维 i 表示顶点索引（对应 vertices[i]）\n第二维 edges[i] 存储该顶点连接的目标顶点值集合\nedges[i] 中的数字直接表示目标顶点值**（非索引）\n例如 edges[0] = [1,2,3,4] 表示顶点1连接到值2/3/4/5（注意实际值比索引大1）\n\n\n\nint vertices[5] = &#123;1, 2, 3, 4, 5&#125;;vector&lt;vector&lt;int&gt;&gt; edges;vector&lt;int&gt; edge_1 = &#123;1, 2, 3, 4&#125;;vector&lt;int&gt; edge_2 = &#123;0, 3&#125;;vector&lt;int&gt; edge_3 = &#123;0, 4&#125;;vector&lt;int&gt; edge_4 = &#123;0, 1, 4&#125;;vector&lt;int&gt; edge_5 = &#123;0, 2, 3&#125;;edges.push_back(edge_1);edges.push_back(edge_2);edges.push_back(edge_3);edges.push_back(edge_4);edges.push_back(edge_5);\n\n邻接矩阵 VS 邻接表 ：\n邻接矩阵的大小只与节点数量有关，即 N2N2 ，其中 NN 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。因此，邻接表 适合存储稀疏图（顶点较多、边较少）； 邻接矩阵 适合存储稠密图（顶点较少、边较多）。\n\n\n散列表散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 key」映射至对应的「值 value」，以实现高效的元素查找。\n\n设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。现需求从「姓名」查找「学号」。\n\n则可通过建立姓名为 key ，学号为 value 的散列表实现此需求，代码如下：\n// 初始化散列表unordered_map&lt;string, int&gt; dic;// 添加 key -&gt; value 键值对dic[&quot;小力&quot;] = 10001;dic[&quot;小特&quot;] = 10002;dic[&quot;小扣&quot;] = 10003;// 从姓名查找学号dic.find(&quot;小力&quot;)-&gt;second; // -&gt; 10001dic.find(&quot;小特&quot;)-&gt;second; // -&gt; 10002dic.find(&quot;小扣&quot;)-&gt;second; // -&gt; 10003\n\nHash 函数设计示例 ：\n\n假设需求：从「学号」查找「姓名」。\n\n将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2 。\nstring names[] = &#123; &quot;小力&quot;, &quot;小特&quot;, &quot;小扣&quot; &#125;;\n此时，我们构造一个简单的 Hash 函数（ %% 为取余符号 ），公式和封装函数如下所示：\nhash(key)=(key−1)%10000\nint hash(int id) &#123;    int index = (id - 1) % 10000;    return index;&#125;\n则我们构建了以学号为 key 、姓名对应的数组索引为 value 的散列表。利用此 Hash 函数，则可在 O(1)O(1) 时间复杂度下通过学号查找到对应姓名，即：\nnames[hash(10001)] // 小力names[hash(10002)] // 小特names[hash(10003)] // 小扣\n\n以上设计只适用于此示例，实际的 Hash 函数需保证低碰撞率、 高鲁棒性等，以适用于各类数据和场景。\n\n堆堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。\n\n完全二叉树定义： 设二叉树深度为 kk ，若二叉树除第 kk 层外的其它各层（第 11 至 k−1k−1 层）的节点达到最大个数，且处于第 kk 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。\n\n如下图所示，为包含 1, 4, 2, 6, 8 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。\n\n通过使用「优先队列」的「压入 push()」和「弹出 pop()」操作，即可完成堆排序，实现代码如下：\n// 初始化小顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;// 元素入堆heap.push(1);heap.push(4);heap.push(2);heap.push(6);heap.push(8);// 元素出堆（从小到大）heap.pop(); // -&gt; 1heap.pop(); // -&gt; 2heap.pop(); // -&gt; 4heap.pop(); // -&gt; 6heap.pop(); // -&gt; 8\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"关于数据结构的一些想法","url":"/Arknight-notes/posts/12835.html","content":"\n鉴于我校 [已编辑] 的教学安排，在刚学完c语言程序设计后，大一下就开始了基于c++的数据结构的学习，由于算法基础过于薄弱，数据结构拼尽全力期末复习只考了70而且掌握不足，写不出东西来，现在重拾旧事把数据结构重新学一遍\n个人认为学不明白踩过的坑有几点：\n\n第一，在大学的课程里并没有讲明白一个问题，就是数据结构算法应该怎么样和实际场景结合。比如，老师讲到树形结构的时候会说，树形效率很高，它的插入和查找时间复杂度都是O(LogN)，是一种非常重要的数据结构，在计算机中应用非常广泛，讲到这里就讲完了,留下我们一头雾水。\n\n第二，在实际其实没有机会从零开始手写一个数据结构和算法，在主流的编程语言中都已经封装好了。\n\n第三，你广州大学的数据结构排课极少，这么难学的课竟然课时还没思政课多。不知道计算机学院那边是什么情况，蹭课时那边一个时间复杂度讲了三节课，心死了，还是得靠自己学\n\n\n  很多时候我们能说出队列是什么原理，栈是什么原理，树的旋转是怎么回事， 但如果让我们自己实现一个队列或者栈还是有点难度的，尤其是在需要考虑一些性能问题的时候，遂决定把这些重新拾起来。\n\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"数据结构-线性表（顺序表）","url":"/Arknight-notes/posts/23014.html","content":"\n线性表说起这个问题，我们一定不陌生。打开QQ或微信，我们可以看到好友列表，打开PTA，我们能看到题目列表，打开音乐软件，我们可以看见歌曲列表，线性表在我们的生活中无处不在。线性表是怎么呈现的呢？线性表把我们在生活中需要的信息，按照顺序进行排列，使得这些信息直观、有条理，如果是按照某种顺序排列的列表，我们可以做到信息的快速检索。\n\n1) 线性表（线性存储结构）线性表又称线性存储结构，是最简单的一种存储结构，专门用来存储逻辑关系为“一对一”的数据。\n在一个数据集中，如果每个数据的左侧都有且仅有一个数据和它有关系，数据的右侧也有且仅有一个数据和它有关系，那么这些数据之间就是“一对一“的逻辑关系。\n所谓线性表，是零个或多个数据元素的有限序列，线性表的元素具有相同的特征，数据元素之间的关系是一对一的关系。\n\n如上图所示，在 {1,2,3,4,5} 数据集中，每个数据的左侧都有且仅有一个数据和它紧挨着（除 1 外），右侧也有且仅有一个数据和它紧挨着（除 5 外），这些数据之间就是“一对一“的关系。\n使用线性表存储具有“一对一“逻辑关系的数据，不仅可以将所有数据存储到内存中，还可以将“一对一”的逻辑关系也存储到内存中。\n线性表存储数据的方案可以这样来理解，先用一根线将所有数据按照先后次序“串”起来，如下图所示：\n\n数据和“一对一”的逻辑关系\n左侧是“串”起来的数据，右侧是空闲的物理空间。将这“一串儿”数据存放到物理空间中，有以下两种方法：\n\n两种存储方式都可以将数据之间的关系存储起来，从线的一头开始捋，可以依次找到每个数据，且数据的前后位置没有发生改变。\n像上图这样，用一根线将具有“一对一”逻辑关系的数据存储起来，这样的存储方式就称为线性表或者线性存储结构。\n顺序存储结构和链式存储结构从图 3 不难看出，线性表存储数据的实现方案有两种，分别是：\n\n像图 3a) 那样，不破坏数据的前后次序，将它们连续存储在内存空间中，这样的存储方案称为顺序存储结构（简称顺序表）；\n像图 3b) 那样，将所有数据分散存储在内存中，数据之间的逻辑关系全靠“一根线”维系，这样的存储方案称为链式存储结构（简称链表）。\n\n也就是说，使用线性表存储数据，有两种真正可以落地的存储方案，分别是顺序表和链表。\n前驱和后继在具有“一对一“逻辑关系的数据集中，每个个体习惯称为数据元素（简称元素）。例如，图 1 显示的这组数据集中，一共有 5 个元素，分别是 1、2、3、4 和 5。\n此外，很多教程中喜欢用前驱和后继来描述元素之间的前后次序：\n\n某一元素的左侧相邻元素称为该元素的“直接前驱”，此元素左侧的所有元素统称为该元素的“前驱元素”；\n某一元素的右侧相邻元素称为该元素的“直接后继”，此元素右侧的所有元素统称为该元素的“后继元素”；\n\n以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。\n\n2) 顺序表（顺序存储结构）顺序表又称顺序存储结构，是线性表的一种，专门存储逻辑关系为“一对一”的数据。\n顺序表存储数据的具体实现方案是：将数据全部存储到一整块内存空间中，数据元素之间按照次序挨个存放。\n举个简单的例子，将 {1,2,3,4,5} 这些数据使用顺序表存储，数据最终的存储状态如下图所示：\n\n线性表的抽象数据结构ADT List&#123;    Data:        D = &#123;ai | 1 ≤ i ≤ n, n ≥ 0, ai 为 ElemType 类型&#125;    Relation：        R = &#123; &lt;ai,ai+1&gt; | ai,ai+1 ∈ D, i = 1, i ∈ (0,n)&#125;    Operation:        InitList(&amp;L);    //初始化，建立一个空的线性表L        MakeList(&amp;L);    //建立线性表，向表中存入数据        ListEmpty(*L);    //空表判断，是则返回true,否则返回false        DestroyList(&amp;L);    //清除操作，清空线性表的元素        GetElem(L,i,&amp;e);    //获取线性表的元素，将线性表L的第i个元素的值返回给e        LocateElem(L,e);    //按值查找元素，在线性表L中查找与e元素相等的元素，查找成功返回对应的序号，查找失败则返回0        ListInsert(&amp;L,i,e);    //插入操作，在线性表L的第i个位置插入元素e        ListDelete(&amp;L,i,&amp;e);    //删除操作，删除线性表L中的第i个位置的元素，并将其用e返回        ListLength(L);    //计算表长，返回线性表L的元素个数        DispList(L);    //输出线性表，当线性表不为空表时，按顺序输出表中的每一个元素&#125;\n顺序表的建立使用顺序表存储数据，除了存储数据本身的值以外，通常还会记录以下两样数据：\n\n顺序表的最大存储容量：顺序表最多可以存储的数据个数；\n顺序表的长度：当前顺序表中存储的数据个数。\n\nC 语言中，可以定义一个结构体来表示顺序表：\ntypedef struct&#123;    int * head; //定义一个名为head的长度不确定的数组，也叫“动态数组”    int length; //记录当前顺序表的长度    int size; //记录顺序表的存储容量&#125;Table;\n尝试建立一个顺序表，例如：\n#define Size 5 //对Size进行宏定义，表示顺序表的最大容量void initTable(Table * t) &#123;    //构造一个空的顺序表，动态申请存储空间    t-&gt;head = (int*)malloc(Size * sizeof(int)); //申请内存空间    //如果申请失败，作出提示并直接退出程序    if (!t-&gt;head)    &#123;        printf(&quot;初始化失败&quot;);        exit(0);    &#125;    //空表的长度初始化为0    t-&gt;length = 0;    //空表的初始存储空间为Size    t-&gt;size = Size;&#125;\n如上所示，整个建立顺序表的过程都封装在一个函数中，建好的顺序表可以存储 5 个逻辑关系为“一对一”的整数。\n在顺序表的实现中，t-&gt;head 是一个指向动态数组基地址的指针，其核心作用是为顺序表提供存储数据的连续内存空间。以下是具体解析：\n\n1. t-&gt;head 的定义与作用• 定义：  t-&gt;head 是顺序表结构体中的一个成员变量，通常声明为动态数组的起始地址指针。例如在 C 语言中，顺序表的结构体定义如下：  typedef struct &#123;    int *head;  // 动态数组基地址    int length; // 当前元素个数    int size;   // 总存储容量&#125; Table;\n顺序表的使用通过调用 initTable() 函数，就可以成功地创建一个顺序表，还可以往顺序表中存储一些元素。\n例如，将 {1,2,3,4,5} 存储到顺序表中，实现代码如下：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Size 5 //对Size进行宏定义，表示顺序表的最大容量typedef struct&#123;    int* head;    int length;    int size;&#125;Table;void initTable(Table * t) &#123;    //构造一个空的顺序表，动态申请存储空间    t-&gt;head = (int*)malloc(Size * sizeof(int));    //如果申请失败，作出提示并直接退出程序    if (!t-&gt;head) //无头（申请失败）    &#123;        printf(&quot;初始化失败&quot;);        exit(0);    &#125;    //空表的长度初始化为0    t-&gt;length = 0; //t-&gt;length：当前元素个数    //空表的初始存储空间为Size    t-&gt;size = Size; //t-&gt;size：总存储容量&#125;//输出顺序表中元素的函数void displayTable(Table t) &#123;    int i;    for (i = 0; i &lt; t.length; i++) &#123;        printf(&quot;%d &quot;, t.head[i]);    &#125;    printf(&quot;\\n&quot;);&#125;int main() &#123;    int i;    Table t = &#123; NULL,0,0 &#125;;    initTable(&amp;t);    //向顺序表中添加&#123;1,2,3,4,5&#125;    for (i = 1; i &lt;= Size; i++) &#123;        t.head[i - 1] = i;        t.length++;    &#125;    printf(&quot;顺序表中存储的元素分别是：\\n&quot;);    displayTable(t);    free(t.head);//释放申请的堆内存    return 0;&#125;\n程序运行结果如下：\n\n顺序表中存储的元素分别是： 1 2 3 4 5\n\n3) 顺序表的基本操作我们学习了顺序表及初始化的过程，本节学习有关顺序表的一些基本操作，以及如何使用 C 语言实现它们。\n顺序表插入元素向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：\n\n插入到顺序表的表头；\n在表的中间位置插入元素；\n尾随顺序表中已有元素，作为顺序表中的最后一个元素；\n\n虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：\n\n将要插入位置元素以及后续的元素整体向后移动一个位置；\n将元素放到腾出来的位置上；\n\n例如，在 {1,2,3,4,5} 的第 3 个位置上插入元素 6，实现过程如下：\n\n遍历至顺序表存储第 3 个数据元素的位置\n\n\n\n将元素 3、4 和 5 整体向后移动一个位置\n\n\n\n将新元素 6 放入腾出的位置\n\n\n因此，顺序表插入数据元素的 C 语言实现代码如下：\n//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置void insertTable(Table* t, int elem, int add)&#123;    int i;            //如果插入元素位置(add)比整张表的长度+1(t-&gt;length + 1)还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出    if (add &gt; t-&gt;length + 1 || add &lt; 1) &#123;        printf(&quot;插入位置有问题\\n&quot;);        return;    &#125;            //做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，有就是(t-&gt;length &lt; t-&gt;size)，如果没有就是(t-&gt;length == t-&gt;size)，需要申请    if (t-&gt;length == t-&gt;size) &#123;        t-&gt;head = (int*)realloc(t-&gt;head, (t-&gt;size + 1) * sizeof(int));        //重新分配内存，动态数组额外申请更多物理空间        if (!t-&gt;head) &#123;            printf(&quot;存储分配失败\\n&quot;);            return;        &#125;        t-&gt;size += 1;    &#125;            //插入操作，需要将自插入位置之后的所有元素(从t-&gt;length - 1倒数到add - 1)全部后移一位    for (i = t-&gt;length - 1; i &gt;= add - 1; i--) &#123;        t-&gt;head[i + 1] = t-&gt;head[i];    &#125;        //后移完成后，直接插入元素    t-&gt;head[add - 1] = elem;    t-&gt;length++;&#125;\n注意，动态数组额外申请更多物理空间使用的是 realloc 函数。此外在实现元素整体后移的过程中，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。\n顺序表删除元素从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。\n后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。\n例如，从 {1,2,3,4,5} 中删除元素 3 的过程如图 4 所示：\n\n因此，顺序表删除元素的 C 语言实现代码为：\nvoid delTable(Table* t, int add) &#123;    int i;    if (add &gt; t-&gt;length || add &lt; 1) &#123;  //删除元素位置大于表长或小于0        printf(&quot;被删除元素的位置有误\\n&quot;);        return;    &#125;    //删除操作    for (i = add; i &lt; t-&gt;length; i++) &#123;        t-&gt;head[i - 1] = t-&gt;head[i];    &#125;    t-&gt;length--;//表长减短&#125;\n顺序表查找元素顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、插值查找算法等。\n这里，我们选择顺序查找算法，具体实现代码为：\n//查找函数，其中，elem表示要查找的数据元素的值int selectTable(table t,int elem)&#123;    for (int i=0; i&lt;t.length; i++) &#123;        if (t.head[i]==elem) &#123;            return i+1;        &#125;    &#125;    return -1;//如果查找失败，返回-1&#125;\n顺序表更改元素顺序表更改元素的实现过程是：\n\n找到目标元素；\n直接修改该元素的值；\n\n顺序表更改元素的 C 语言实现代码为：\nvoid amendTable(Table* t, int elem, int newElem) &#123;    int add = selectTable(*t, elem);    if (add == -1) &#123;        printf(&quot;顺序表中没有找到目标元素\\n&quot;);        return;    &#125;    t-&gt;head[add - 1] = newElem;&#125;\n关于 t-&gt;head,t-&gt;length和 t-&gt;size• 物理存储管理：  t-&gt;head 指向通过 malloc 或 realloc 动态申请的内存块的首地址。顺序表中的所有元素按逻辑顺序连续存储在这段内存中。\n• 操作接口：  通过 t-&gt;head 可直接访问顺序表的元素，例如：  • 插入：t-&gt;head[add-1] = elem 将元素写入指定位置。  • 遍历：通过 t-&gt;head[i] 访问第 i 个元素。\n顺序表初始化时，t-&gt;head 被赋予动态分配的内存地址。例如：  \nvoid initTable(Table *t) &#123;    t-&gt;head = (int*)malloc(Size * sizeof(int));  // 申请初始内存    t-&gt;length = 0;    t-&gt;size = Size;&#125;\n若内存分配失败，t-&gt;head 会指向 NULL，此时需进行错误处理。\n所有对顺序表元素的增删查改均通过 t-&gt;head 实现：• 插入元素：将后续元素右移后，直接通过 t-&gt;head[add-1] 写入新值。• 删除元素：左移覆盖目标元素后，通过 t-&gt;head 重新定位后续元素。\nt-&gt;head 是顺序表实现中动态内存管理的核心，它指向存储数据的连续内存块，并通过指针操作支持元素的增删查改。\n在顺序表的实现中，t-&gt;length和t-&gt;size是两个关键字段，它们的含义及设计逻辑如下：\n\n1. t-&gt;length：当前元素个数\n• 定义：表示顺序表中实际存储的有效元素数量，即当前表内数据的逻辑长度。• 作用：  • 控制插入/删除操作的合法性（例如插入位置不能超过length+1，删除位置不能超过length）。  • 遍历时确定元素范围（从下标0到length-1）。• 示例：若顺序表存储&#123;1,2,3&#125;，则length=3。\n\n2. t-&gt;size：总存储容量\n• 定义：表示顺序表已申请的内存空间能容纳的最大元素数量，即物理存储容量。• 作用：  • 判断是否需要扩容（当length == size时，表已满需扩展内存）。  • 动态调整内存时记录当前分配的空间上限。• 示例：若初始分配容量为size=5，插入5个元素后length=5，此时需扩容才能继续插入。\n\n3. 两者的区别与联系\n\n\n\n\n字段\n意义\n操作触发条件\n命名逻辑\n\n\n\n\nlength\n实际元素个数（动态变化）\n插入时位置需满足1 ≤ add ≤ length+1\n直观体现“逻辑长度”，类似数组的size()\n\n\nsize\n最大容量（静态/动态）\n扩容条件为length == size\n体现“物理容量上限”，类似容器的capacity()\n\n\n\n\n\n逻辑与物理分离：• length关注数据逻辑层面的使用情况，size关注物理内存的管理，两者分离便于维护动态内存。\n\n操作安全性：• 通过length限制插入/删除位置，避免越界访问；通过size判断内存是否耗尽，防止溢出。\n\n动态扩容机制：• 当length达到size时，触发realloc扩展内存（例如每次扩容固定步长或按倍数增长），保证数据连续性。\n插入函数中：\n\n\nif (add &gt; t-&gt;length + 1 || add &lt; 1) &#123;    printf(&quot;插入位置有问题\\n&quot;);    return;&#125;if (t-&gt;length == t-&gt;size) &#123;    t-&gt;head = (int*)realloc(t-&gt;head, (t-&gt;size + 1) * sizeof(int));    // 扩容逻辑...&#125;\n• add &gt; t-&gt;length + 1：确保插入位置不超过逻辑长度的下一个合法位置（如length=3时，允许插入到第4位，但不可到第5位）。• t-&gt;length == t-&gt;size：触发扩容的条件，保证物理空间始终足够容纳逻辑元素。\nt-&gt;length和t-&gt;size是顺序表实现中动态内存管理与逻辑操作控制的核心字段。通过两者的协同，既能高效利用内存，又能确保数据操作的合法性。\n其他操作的实现逆序void reverseTable(Table* t) &#123;    if (t-&gt;length &lt;= 1) return; // 空表或单元素表无需处理        for (int i = 0; i &lt; t-&gt;length / 2; i++) &#123;        int temp = t-&gt;head[i];        t-&gt;head[i] = t-&gt;head[t-&gt;length - 1 - i];        t-&gt;head[t-&gt;length - 1 - i] = temp;    &#125;&#125;\n输出表长int ListLength(Table* t) &#123;    return L-&gt;length; // 直接返回顺序表的当前长度&#125;\n删除全表void SeqListDestory(Table* t) &#123;    assert(t);  // 确保传入的指针非空    free(t-&gt;head);  // 释放动态数组内存    t-&gt;head = NULL;  // 指针置空    t-&gt;size = 0;  // 容量归零    t-&gt;length = 0;  // 元素个数归零&#125;\n完整代码实现以下是一个完整的顺序表操作示例代码，包含初始化、插入、删除、查找、修改、逆序、销毁等操作，并在main函数中展示了具体调用逻辑：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#define INIT_SIZE 5  // 初始容量typedef struct &#123;    int* head;    // 动态数组基地址    int length;   // 当前元素个数    int size;     // 总存储容量&#125; Table;// 初始化顺序表void initTable(Table* t) &#123;    t-&gt;head = (int*)malloc(INIT_SIZE * sizeof(int));    if (!t-&gt;head) &#123;        printf(&quot;内存分配失败\\n&quot;);        exit(EXIT_FAILURE);    &#125;    t-&gt;length = 0;    t-&gt;size = INIT_SIZE;&#125;// 插入元素（位置从1开始）void insertTable(Table* t, int elem, int pos) &#123;    if (pos &lt; 1 || pos &gt; t-&gt;length + 1) &#123;        printf(&quot;非法插入位置: %d\\n&quot;, pos);        return;    &#125;        // 容量检查与扩容    if (t-&gt;length == t-&gt;size) &#123;        int new_size = t-&gt;size * 2;  // 容量翻倍        int* new_head = (int*)realloc(t-&gt;head, new_size * sizeof(int));        if (!new_head) &#123;            printf(&quot;扩容失败\\n&quot;);            return;        &#125;        t-&gt;head = new_head;        t-&gt;size = new_size;        printf(&quot;已扩容至 %d\\n&quot;, new_size);    &#125;    // 元素后移    for (int i = t-&gt;length; i &gt;= pos; i--) &#123;        t-&gt;head[i] = t-&gt;head[i - 1];    &#125;        t-&gt;head[pos - 1] = elem;    t-&gt;length++;&#125;// 删除元素（位置从1开始）void delTable(Table* t, int pos) &#123;    if (pos &lt; 1 || pos &gt; t-&gt;length) &#123;        printf(&quot;非法删除位置: %d\\n&quot;, pos);        return;    &#125;        // 元素前移覆盖    for (int i = pos; i &lt; t-&gt;length; i++) &#123;        t-&gt;head[i - 1] = t-&gt;head[i];    &#125;    t-&gt;length--;&#125;// 查找元素（返回位置，从1开始）int selectTable(Table* t, int elem) &#123;    for (int i = 0; i &lt; t-&gt;length; i++) &#123;        if (t-&gt;head[i] == elem) &#123;            return i + 1;// 返回元素位置        &#125;    &#125;    return -1;  // 未找到&#125;// 修改元素值void amendTable(Table* t, int old_elem, int new_elem) &#123;    int pos = selectTable(t, old_elem); // 查找元素    if (pos == -1) &#123;        printf(&quot;元素 %d 不存在\\n&quot;, old_elem);        return;    &#125;    t-&gt;head[pos - 1] = new_elem;&#125;// 逆序顺序表void reverseTable(Table* t) &#123;    for (int i = 0; i &lt; t-&gt;length / 2; i++) &#123;        int temp = t-&gt;head[i];        t-&gt;head[i] = t-&gt;head[t-&gt;length - 1 - i];        t-&gt;head[t-&gt;length - 1 - i] = temp;    &#125;&#125;// 销毁顺序表void destroyTable(Table* t) &#123;    free(t-&gt;head);    t-&gt;head = NULL;    t-&gt;length = 0;    t-&gt;size = 0;&#125;// 打印顺序表void displayTable(Table* t) &#123;    printf(&quot;[当前表长: %d, 总容量: %d]\\n&quot;, t-&gt;length, t-&gt;size);    for (int i = 0; i &lt; t-&gt;length; i++) &#123;        printf(&quot;%d &quot;, t-&gt;head[i]);    &#125;    printf(&quot;\\n\\n&quot;);&#125;int main() &#123;    Table my_table; //声明一个名为 my_table 的变量，其类型为 Table 结构体        // 1. 初始化    initTable(&amp;my_table);    //&amp;my_table的作用是将结构体的地址传递给函数，使函数能通过指针直接修改原始变量    printf(&quot;=== 初始化顺序表 ===\\n&quot;);    displayTable(&amp;my_table);    // 2. 插入初始元素    for (int i = 1; i &lt;= 5; i++) &#123;        insertTable(&amp;my_table, i, i);    &#125;    printf(&quot;=== 插入5个元素 ===\\n&quot;);    displayTable(&amp;my_table);    // 3. 测试扩容插入    insertTable(&amp;my_table, 6, 3);  // 在第3位插入6    printf(&quot;=== 插入第6个元素触发扩容 ===\\n&quot;);    displayTable(&amp;my_table);    // 4. 删除元素    delTable(&amp;my_table, 2);  // 删除第2个元素    printf(&quot;=== 删除第2个元素 ===\\n&quot;);    displayTable(&amp;my_table);    // 5. 查找元素    int target = 6;    int pos = selectTable(&amp;my_table, target);    printf(&quot;=== 查找元素 %d ===\\n&quot;, target);    if (pos != -1) &#123;        printf(&quot;元素 %d 位于第 %d 位\\n&quot;, target, pos);    &#125; else &#123;        printf(&quot;元素不存在\\n&quot;);    &#125;    // 6. 修改元素    amendTable(&amp;my_table, 6, 66);    printf(&quot;=== 修改元素 6 → 66 ===\\n&quot;);    displayTable(&amp;my_table);    // 7. 逆序操作    reverseTable(&amp;my_table);    printf(&quot;=== 逆序顺序表 ===\\n&quot;);    displayTable(&amp;my_table);    // 8. 销毁顺序表    destroyTable(&amp;my_table);    printf(&quot;=== 销毁后的状态 ===\\n&quot;);    printf(&quot;指针状态: %s\\n&quot;, (my_table.head == NULL) ? &quot;已释放&quot; : &quot;未释放&quot;);        return 0;&#125;\n关键调用逻辑说明：\n初始化顺序表 \ninitTable(&amp;my_table);\n• 创建空表，初始容量为5• 时间复杂度：O(1)\n\n批量插入元素\nfor (int i = 1; i &lt;= 5; i++) &#123;    insertTable(&amp;my_table, i, i);&#125;\n• 插入5个元素填满初始容量• 时间复杂度：O(n)\n\n触发扩容插入 \ninsertTable(&amp;my_table, 6, 3);\n• 当插入第6个元素时触发动态扩容（容量翻倍为10）• 时间复杂度：O(n)\n\n删除元素 \ndelTable(&amp;my_table, 2);\n• 删除第2个元素（值为2），后续元素前移• 时间复杂度：O(n)\n\n元素查找 \nselectTable(&amp;my_table, target);\n• 使用顺序查找，返回元素位置• 时间复杂度：O(n)\n\n逆序操作\nreverseTable(&amp;my_table);\n• 通过对称交换实现逆序• 时间复杂度：O(n)\n\n销毁顺序表 \ndestroyTable(&amp;my_table);\n• 释放动态内存并将指针置空• 防止内存泄漏的关键操作\n\n\n执行结果示例：=== 初始化顺序表 ===[当前表长: 0, 总容量: 5]=== 插入5个元素 ===[当前表长: 5, 总容量: 5]1 2 3 4 5 已扩容至 10=== 插入第6个元素触发扩容 ===[当前表长: 6, 总容量: 10]1 2 6 3 4 5 === 删除第2个元素 ===[当前表长: 5, 总容量: 10]1 6 3 4 5 === 查找元素 6 ===元素 6 位于第 2 位=== 修改元素 6 → 66 ===[当前表长: 5, 总容量: 10]1 66 3 4 5 === 逆序顺序表 ===[当前表长: 5, 总容量: 10]5 4 3 66 1 === 销毁后的状态 ===指针状态: 已释放\n复杂度对比：\n\n\n\n操作\n最好情况\n最坏情况\n平均情况\n\n\n\n\n插入\nO(1)\nO(n)\nO(n)\n\n\n删除\nO(1)\nO(n)\nO(n)\n\n\n查找\nO(1)\nO(n)\nO(n)\n\n\n逆序\n-\nO(n)\nO(n)\n\n\n初始化\nO(1)\nO(1)\nO(1)\n\n\n\n\n​    首先是插入操作，插入操作时间复杂度最小的情况是，当元素要插入到最后一个位置时，你就不需要移动任何元素即可实现，只需要将需要插入的元素插在表的末端即可，时间复杂度O(1)，最费时的操作就是插入的元素要放在表头，那我们就需要把表中的所有元素都移动了,时间复杂度为O(n)。\n​    删除操作也如此，当我们要删除最后一个元素，也不需要移动顺序表，而删除第一个元素时需要移动整个表。我们知道，在实际的操作中，删除表中的任何一个位置需要被插入删除的可能性是相同的，因此从平均角度来分析，移动表的平均次数为 (n - 1) / 2，时间复杂度为O(n)。​    因此我们可以看出，顺序表在插入、删除操作时是比较费时间的，然而其他的基本操作例如初始化、建表或者销毁，时间复杂度都是O(1)，因此我们在使用顺序表的时候，要尽量让表保持不变，而是多多使用顺序表的存储和随机提取等优点。\n优缺点分析顺序表主要有如下一些优点：\n\n顺序表进行随机提取元素的效率较高，能够快速存储、提取元素；\n建表时无需对表中元素的逻辑关系进行描述，各元素在存储地址上是连续的；\n对于CPU，顺序表的高速缓存效率更高，且CPU流水线也不会总是被打断。\n\n顺序表主要有如下一些缺点：\n\n申请顺序表时，顺序表存储元素的上限是固定的，这就导致了存在溢出的可能性；\n插入、删除元素时，时间复杂度较大，需要大范围移动表中的元素；\n由于我们在很多情况下无法预知需要存储多少元素，因此容易导致内存碎片的现象，即申请了空间却没有充分利用。\n\n关于链表再新开一个页面\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"数据结构-栈","url":"/Arknight-notes/posts/33985.html","content":"栈的基本概念栈的定义栈：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。栈顶（Top）：线性表允许进行插入删除的那一端。栈底（Bottom)：固定的，不允许进行插入和删除的另一端。空栈：不含任何元素的空表。\n栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构\n栈的常见基本操作InitStack(&amp;S)：初始化一个空栈S\nStackEmpty(S)：判断一个栈是否为空，若栈为空则返回true，否则返回false\nPush(&amp;S, x)：进栈（栈的插入操作），若栈S未满，则将x加入使之成为新栈顶\nPop(&amp;S, &amp;x)：出栈（栈的删除操作），若栈S非空，则弹出栈顶元素，并用x返回\nGetTop(S, &amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素\nDestroyStack(&amp;S)：栈销毁，并释放S占用的存储空间（“&amp;”表示引用调用）\n栈的顺序存储结构栈的顺序存储采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。若存储栈的长度为MAXSIZE，则栈顶位置top必须小于MAXSIZE。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。栈的顺序存储结构可描述为：\n#define MAXSIZE 5  //定义栈中元素的最大个数typedef struct SqStack&#123;    int data[MAXSIZE];    int top;&#125;SqStack;\n若现在有一个栈，MAXSIZE是5，则栈的普通情况、空栈、满栈的情况分别如下图所示：\n\n初始化void InitStack(SqStack* S)&#123;     //SqStack&amp; S 是 C++ 的引用参数，用于直接修改外部栈对象    //若用 C 语言，需改用指针（SqStack* S）    S-&gt;top = -1;             //初始化栈顶指针&#125;\n为什么要用 S-&gt;top = -1？\n顺序栈的本质是一个数组，栈顶指针 top 表示当前栈顶元素在数组中的位置索引。初始化时 top = -1 有\n空栈条件：top == -1当栈中没有元素时，top 指向数组的“前一个位置”（即无效索引），逻辑上表示“无元素”。\n入栈操作\n先让 top++，移动到下一个可用位置；将新元素存入 data[top]。例如，第一次入栈时，top 从 -1 变为 0，元素存入 data[0]，对应数组的第一个索引。\n判断栈满\n栈满条件：top == MAX_SIZE - 1如果数组大小为 MAX_SIZE，当 top 指向最后一个位置（即 MAX_SIZE - 1）时，表示栈已满。\n判断栈空bool StackEmpty(SqStack* S)&#123;    if( S-&gt;top == -1)&#123;        return true;        //栈中没有元素时，`top` 指向数组的“前一个位置”（即无效索引），逻辑上表示“无元素”    &#125;    return false;&#125;\n进栈bool Push(SqStack* S, int x)&#123;    if( S-&gt;top == MAXSIZE - 1 )&#123; //栈满，报错        return false;            &#125;    S-&gt;top++ ;                  //栈顶指针加1    S-&gt;data[S-&gt;top] = x;         //入栈,写入元素到新栈顶位置    //S-&gt;data[S-&gt;top]代表栈顶元素    return true;&#125;\n出栈bool Pop(SqStack* S, int* x) &#123;//通过指针修改外部变量    if (StackEmpty(S)) &#123;        printf(&quot;栈空，无法出栈\\n&quot;);        return false;    &#125;    *x = S-&gt;data[S-&gt;top];    S-&gt;top--;    printf(&quot;出栈元素: %d\\n&quot;, *x);    return x;&#125;\n读栈顶元素bool GetTop(SqStack* S, int* x) &#123;//通过指针修改外部变量    if (StackEmpty(S)) &#123;        printf(&quot;栈空，无栈顶元素\\n&quot;);        return false;    &#125;    *x = S-&gt;data[S-&gt;top];    printf(&quot;当前栈顶元素: %d\\n&quot;, *x);    return true;&#125;\n出栈和读栈顶元素操作需要返回两个信息：\n\n是否成功（通过 bool 返回值）。\n得到的元素值（通过 int* x 指针参数）。\n\n完整代码实现#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define MAXSIZE 5  // 示例栈容量设为5//栈结构定义typedef struct SqStack &#123;    int data[MAXSIZE];    int top;&#125; SqStack;// 初始化栈void InitStack(SqStack* S) &#123;    S-&gt;top = -1;&#125;// 判断栈空bool StackEmpty(SqStack* S) &#123;    return (S-&gt;top == -1);&#125;// 判断栈满bool StackFull(SqStack* S) &#123;    return (S-&gt;top == MAXSIZE - 1);&#125;// 入栈bool Push(SqStack* S, int x) &#123;    if (StackFull(S)) &#123;        printf(&quot;栈已满，无法入栈 %d\\n&quot;, x);        return false;    &#125;    S-&gt;top++;    S-&gt;data[S-&gt;top] = x;    printf(&quot;入栈元素: %d\\n&quot;, x);    return true;&#125;// 出栈（通过指针返回栈顶元素）bool Pop(SqStack* S, int* x) &#123;    if (StackEmpty(S)) &#123;        printf(&quot;栈空，无法出栈\\n&quot;);        return false;    &#125;    *x = S-&gt;data[S-&gt;top];    S-&gt;top--;    printf(&quot;出栈元素: %d\\n&quot;, *x);    return x;&#125;// 获取栈顶元素（通过指针返回）bool GetTop(SqStack* S, int* x) &#123;    if (StackEmpty(S)) &#123;        printf(&quot;栈空，无栈顶元素\\n&quot;);        return false;    &#125;    *x = S-&gt;data[S-&gt;top];    printf(&quot;当前栈顶元素: %d\\n&quot;, *x);    return true;&#125;// 打印栈内容（辅助函数）void PrintStack(SqStack* S) &#123;    if (StackEmpty(S)) &#123;        printf(&quot;栈空\\n&quot;);        return;    &#125;    printf(&quot;栈内容 (从底到顶): &quot;);    for (int i = 0; i &lt;= S-&gt;top; i++) &#123;        printf(&quot;%d &quot;, S-&gt;data[i]);    &#125;    printf(&quot;\\n&quot;);&#125;int main() &#123;    SqStack S;    int val;  // 用于接收出栈/栈顶元素的值    InitStack(&amp;S);    PrintStack(&amp;S);  // 栈空    // 入栈测试    Push(&amp;S, 10);    Push(&amp;S, 20);    Push(&amp;S, 30);    Push(&amp;S, 40);    Push(&amp;S, 50);   // 栈满    Push(&amp;S, 60);   // 触发栈满报错    PrintStack(&amp;S);  // 10 20 30 40 50    // 获取栈顶    GetTop(&amp;S, &amp;val);  // 50    // 出栈测试    Pop(&amp;S, &amp;val);     // 50出栈    Pop(&amp;S, &amp;val);     // 40出栈    PrintStack(&amp;S);    // 10 20 30    // 继续出栈直到栈空    Pop(&amp;S, &amp;val);     // 30    Pop(&amp;S, &amp;val);     // 20    Pop(&amp;S, &amp;val);     // 10    Pop(&amp;S, &amp;val);     // 触发栈空报错    PrintStack(&amp;S);    // 栈空    return 0;&#125;\n\n栈的链式存储结构采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头节点，Lhead指向栈顶元素\n\n对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。\n链栈的结构定义：// 定义链式栈的节点结构体typedef struct LinkedStackNode &#123;\t    int data;                       // 存储栈元素    struct LinkedStackNode * next;  // 指向下一节点的指针&#125; LinkedStackNode, * LinkedStack;   // 类型别名：LinkedStackNode表示节点，LinkedStack表示节点指针LinkedStack top; // 声明一个栈顶指针（本质是LinkedStackNode*类型）\n初始化空栈//初始化LinkedStack Init_LinkedStack()                                       &#123;\t\tLinkedStack top=(LinkedStackNode * )malloc (sizeof( LinkedStackNode));\tif(top!=NULL)//申请空间成功\ttop-&gt;next=NULL;//设置栈顶指针为空\treturn top;&#125;\n判断栈空//判栈空int LinkedStack_Empty(LinkedStack top)                            &#123;\t\tif(top-&gt;next==NULL)//检查栈顶指针的值 \t&#123;\t\treturn 1;//栈S为空，函数返回1\t&#125;\t\telse\t&#123;\t\treturn 0;\t&#125;&#125;\n入栈int Push_LinkedStack(LinkedStack top,elemtype x)                     \t//插入数据元素x为新的栈顶元素&#123;\t\tLinkedStackNode * node;\tnode=(LinkedStackNode * )malloc(sizeof(LinkedStackNode));\tif(node==NULL)\t&#123;\t\treturn 0;//申请结点空间失败,插入失败，函数返回0\t&#125;\telse\t&#123;\t\tnode-&gt;data=x;//设置新结点的数据域\t\tnode-&gt;next=top-&gt;next;//设置新结点的指针城\t\ttop-&gt;next=node;//设置头结点指针城指向新的栈顶元素\t\treturn 1;//插入成功，函数返回1\t&#125;&#125;\n出栈int Pop_LinkedStack(LinkedStack top, elemtype *x)                    &#123;\tLinkedStackNode * node;\tif(top-&gt;next==NULL)\t&#123;\t\treturn 0;\t&#125;\telse\t&#123;\t\tnode=top-&gt;next;//将原栈顶数据元素弹出并赋给node\t\t*x=node-&gt;data;//将原栈顶数据元素的数据赋值给x\t\ttop-&gt;next=node-&gt;next;//top指向链栈中的下一个数据元素\t\tfree (node);//释放原栈顶数据元素所占的空间\t\treturn 1;\t&#125;&#125;  \n取栈顶元素int GetTop_LinkedStack(LinkedStack top)                &#123; \tif(top-&gt;next)      &#123;            return top-&gt;next-&gt;data;      &#125;      return -1;&#125;\n求栈长设置计数器，随top指针后移，计数器加1，直到遍历完所有元素。\n//求栈长int Length_LinkedStack(LinkedStack top)                                       &#123;\tint count = 0;\twhile(top-&gt;next!=NULL) \t&#123;\t\t++count;\t\ttop=top-&gt;next;\t&#125;\treturn count;&#125;\n完整代码实现#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 定义链式栈的节点结构体typedef struct LinkedStackNode &#123;\t    int data;                       // 存储栈元素    struct LinkedStackNode * next;  // 指向下一节点的指针&#125; LinkedStackNode, * LinkedStack;   // 类型别名：LinkedStackNode表示节点，LinkedStack表示节点指针LinkedStack top; // 声明一个栈顶指针（本质是LinkedStackNode*类型）//初始化LinkedStack Init_LinkedStack()                                       &#123;\t\tLinkedStack top=(LinkedStackNode * )malloc (sizeof( LinkedStackNode));\tif(top!=NULL)//申请空间成功\ttop-&gt;next=NULL;//设置栈顶指针为空\treturn top;&#125;//判栈空int LinkedStack_Empty(LinkedStack top)                            &#123;\t\tif(top-&gt;next==NULL)//检查栈顶指针的值 \t&#123;\t\treturn 1;//栈S为空，函数返回1\t&#125;\t\telse\t&#123;\t\treturn 0;\t&#125;&#125;//入栈int Push_LinkedStack(LinkedStack top,elemtype x)                     \t//插入数据元素x为新的栈顶元素&#123;\t\tLinkedStackNode * node;\tnode=(LinkedStackNode * )malloc(sizeof(LinkedStackNode));\tif(node==NULL)\t&#123;\t\treturn 0;//申请结点空间失败,插入失败，函数返回0\t&#125;\telse\t&#123;\t\tnode-&gt;data=x;//设置新结点的数据域\t\tnode-&gt;next=top-&gt;next;//设置新结点的指针城\t\ttop-&gt;next=node;//设置头结点指针城指向新的栈顶元素\t\treturn 1;//插入成功，函数返回1\t&#125;&#125;//求栈长int Length_LinkedStack(LinkedStack top)                                       &#123;\tint count = 0;\twhile(top-&gt;next!=NULL) \t&#123;\t\t++count;\t\ttop=top-&gt;next;\t&#125;\treturn count;&#125;//出栈int Pop_LinkedStack(LinkedStack top, elemtype *x)                    &#123;\tLinkedStackNode * node;\tif(top-&gt;next==NULL)\t&#123;\t\treturn 0;\t&#125;\telse\t&#123;\t\tnode=top-&gt;next;//将原栈顶数据元素弹出并赋给node\t\t*x=node-&gt;data;//将原栈顶数据元素的数据赋值给x\t\ttop-&gt;next=node-&gt;next;//top指向链栈中的下一个数据元素\t\tfree (node);//释放原栈顶数据元素所占的空间\t\treturn 1;\t&#125;&#125;  //取栈顶元素int GetTop_LinkedStack(LinkedStack top)                &#123; \tif(top-&gt;next)      &#123;            return top-&gt;next-&gt;data;      &#125;      return -1;&#125;//主函数void main()&#123;\tint i,t,x,a[20];\tLinkedStack top=Init_LinkedStack();//初始化栈\tx=LinkedStack_Empty(top);//判栈空结果赋值给X\tif(x=0)\t&#123;\t\tprintf(&quot;栈为空\\n&quot;);\t&#125;\tprintf(&quot;请依次输入5个数,开始入栈：\\n&quot;);\tfor(i=0;i&lt;5;i++) \t&#123;\t\tscanf(&quot;%d&quot;,&amp;a[i]);\t\tPush_LinkedStack(top,a[i]);\t\tx=GetTop_LinkedStack(top);\t\tif(x!=-1)\t\t&#123;\t\t\tprintf(&quot;当前栈顶元素为%d\\n&quot;,x);\t\t&#125;\t&#125;\tprintf(&quot;入栈结束\\n&quot;);\tprintf(&quot;栈长为%d\\n&quot;,Length_LinkedStack(top));\tprintf(&quot;开始出栈:\\n&quot;);\tfor (i=0;i&lt;5;i++)\t&#123;\t\tPop_LinkedStack(top,&amp;t);        printf(&quot;%d&quot;,t);\t&#125;\tprintf(&quot;\\n&quot;);\tprintf(&quot;出栈后栈长为%d\\n&quot;,Length_LinkedStack(top));&#125;\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"前端项目安装和配置指南 Vite + React + TypeScript + Tailwind CSS","url":"/Arknight-notes/posts/39845.html","content":"Vite + React + TypeScript + Tailwind CSS 脚手架搭建指南本文记录从零搭建 Vite + React + Tailwind CSS 项目，省去一个个官网去查阅文档，旨在方便快速丝滑的创建项目\n概览\nVite 4.2.0 - 新一代构建工具，提供极快的冷启动和热更新。基于原生 ES 模块实现，开发时按需编译，相比传统打包工具具有显著的速度优势。\nReact 18.2.0 - 流行的前端 UI 库，采用组件化架构和虚拟 DOM 技术，提供高效的渲染性能和良好的开发体验。\nTypeScript 5.3.3 - JavaScript 的超集，提供静态类型检查，在编译阶段发现潜在错误，增强代码可维护性和开发效率。\nTailwind CSS 3.3.1 - 实用优先的 CSS 框架，通过组合预定义的原子类来构建界面，无需编写自定义 CSS 即可实现复杂设计。\nESLint &amp; Prettier - 代码规范和格式化工具。ESLint 用于检测代码质量问题和潜在错误，Prettier 专注于代码格式统一，共同保障代码质量。\nHusky &amp; lint-staged - Git 钩子工具，用于提交前代码检查。Husky 简化 Git 钩子配置，lint-staged 仅对暂存文件执行操作，提升提交前检查效率。\nReact Router DOM 6 - React 应用的路由管理工具，提供声明式路由配置，支持动态路由、嵌套路由等特性，是构建单页应用的核心组件。\n\n结构BDdraw_DEV/├── .husky/                     # Git hooks 配置├── .vscode/                    # VSCode 配置├── docs/                       # 文档目录├── public/                     # 静态资源目录├── src/                        # 源代码主目录│   ├── api/                    # API 接口定义│   ├── assets/                 # 静态资源文件│   ├── components/             # 公共组件│   ├── hooks/                  # 自定义 React Hooks│   ├── lib/                    # 工具库和核心功能模块│   ├── pages/                  # 页面组件│   ├── router/                 # 路由配置│   │   └── router.tsx          # 路由定义│   ├── stores/                 # 状态管理│   ├── styles/                 # 样式文件│   ├── app.tsx                 # 应用入口组件│   ├── main.tsx                # 主入口文件│   └── vite-env.d.ts           # Vite 环境声明文件├── .editorconfig               # 编辑器配置├── .eslintrc                  # ESLint 配置├── .gitignore                 # Git 忽略文件配置├── .prettierrc.js             # Prettier 配置├── .stylelintrc.json          # Stylelint 配置├── commitlint.config.cjs      # Commitlint 配置├── components.json            # 组件配置├── index.html                 # HTML 入口├── lint-staged.config.js      # Lint-staged 配置├── package.json               # 项目依赖和脚本配置├── postcss.config.js          # PostCSS 配置├── tailwind.config.js         # Tailwind CSS 配置├── transmart.config.ts        # Transmart 配置├── tsconfig.json              # TypeScript 配置├── tsconfig.node.json         # Node.js TypeScript 配置├── vite.config.ts             # Vite 配置└── README.md                  # 项目说明文档\n初始化项目使用 Vite 创建项目\nnpm create vite@latest [项目名] -- --template react-tscd [项目名]\n安装依赖\nnpm install\n集成 Tailwind CSS v3Tailwind CSS 是一个功能类优先的 CSS 框架，它提供了大量的实用类，可以直接在 HTML 中组合使用来构建任何设计。通过配置文件可以自定义主题、颜色、间距等设计系统，并且只生成实际使用的样式，使得最终的 CSS 文件非常精简。其 JIT（Just-In-Time）模式可以按需生成样式，大大提高了编译速度并支持更多功能。\n安装 Tailwind CSS v3 及其依赖\nnpm install -D tailwindcss postcss autoprefixernpx tailwindcss init -p\n如果出问题可以去翻一下官方文档，v4 改变了一些部署方式\n配置 Tailwind CSS\n编辑 tailwind.config.js 文件：\n/** @type {import('tailwindcss').Config} */module.exports = {  content: [\"./index.html\", \"./src/**/*.{js,ts,jsx,tsx}\"],  theme: {    extend: {},  },  plugins: [],};\n引入 Tailwind CSS v3在 src/index.css 文件中添加：\n@tailwind base;@tailwind components;@tailwind utilities;\n并在入口文件中导入该 CSS 文件：\nTailwind CSS 的三个核心层：\n\n@tailwind base - 包含 Normalize.css 和一些基础样式重置\n@tailwind components - 包含框架的组件类，可用于添加结构样式\n@tailwind utilities - 包含所有实用类，这是 Tailwind 的核心部分\n\n通过这种分层方式，Tailwind 提供了一种灵活的方式来组织和扩展样式。\n配置 TypeScriptTypeScript 是 JavaScript 的超集，添加了可选的静态类型。它可以帮助开发者在编码阶段捕获错误，提供更好的代码补全和重构支持。通过配置 tsconfig.json，我们可以控制 TypeScript 编译器的行为，如目标 JavaScript 版本、模块解析策略、严格性级别等。在本项目中，我们启用了严格的类型检查，同时配置了 React JSX 支持。\n项目中的 tsconfig.json 文件已经包含了基本的 TypeScript 配置。根据项目需求，我们可以对其进行定制：\n{  \"compilerOptions\": {    \"target\": \"ESNext\",    \"useDefineForClassFields\": true,    \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"],    \"allowJs\": false,    \"skipLibCheck\": true,    \"esModuleInterop\": false,    \"allowSyntheticDefaultImports\": true,    \"strict\": true,    \"forceConsistentCasingInFileNames\": true,    \"module\": \"ESNext\",    \"moduleResolution\": \"Node\",    \"resolveJsonModule\": true,    \"isolatedModules\": true,    \"noEmit\": true,    \"jsx\": \"react-jsx\"  },  \"include\": [\"src\"],  \"references\": [{ \"path\": \"./tsconfig.node.json\" }]}\n配置 ESLint 和 PrettierESLint 是一个可插拔的 JavaScript 和 TypeScript 代码质量检查工具，它可以识别语法错误和代码风格问题。Prettier 是一个代码格式化工具，专注于代码风格统一。两者结合使用可以确保团队代码质量和风格的一致性。通过配置规则，我们可以自定义检查标准，例如是否使用分号、引号类型、缩进大小等。\n安装相关依赖\nnpm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser\n配置 ESLint\n创建 .eslintrc 文件：\n{  \"env\": {    \"browser\": true,    \"es2021\": true  },  \"extends\": [    \"eslint:recommended\",    \"plugin:@typescript-eslint/recommended\",    \"plugin:react/recommended\",    \"plugin:react-hooks/recommended\",    \"prettier\"  ],  \"parser\": \"@typescript-eslint/parser\",  \"parserOptions\": {    \"ecmaVersion\": \"latest\",    \"sourceType\": \"module\"  },  \"plugins\": [\"@typescript-eslint\", \"react\", \"prettier\"],  \"rules\": {    \"prettier/prettier\": \"error\",    \"react/react-in-jsx-scope\": \"off\"  },  \"settings\": {    \"react\": {      \"version\": \"detect\"    }  }}\n配置 Prettier\n创建 .prettierrc 文件：\n{  \"semi\": false,  \"singleQuote\": true,  \"tabWidth\": 2,  \"trailingComma\": \"es5\"}\n配置 Git HooksGit Hooks 允许我们在 Git 操作的不同阶段执行自定义脚本。通过 Husky 和 lint-staged，我们可以在代码提交前自动运行 ESLint 和 Prettier，确保只有符合规范的代码才能进入代码库。lint-staged 只会针对暂存区的文件运行检查，提高效率。这有助于保持整个项目的代码质量和一致性。\n使用 Husky 和 lint-staged 在代码提交前自动运行代码检查和格式化。\n安装依赖\nnpm install -D husky lint-staged\n初始化 Husky\nnpx husky install\n配置 lint-staged\n创建 lint-staged.config.js 文件：\nmodule.exports = {  \"*.{ts,tsx}\": [\"eslint --fix\", \"prettier --write\"],  \"*.{css,md}\": \"prettier --write\",};\n添加 pre-commit 钩子\nnpx husky add .husky/pre-commit \"npx lint-staged\"\n集成 React RouterReact Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。\n安装 React Router\nnpm install react-router-domnpm install -D @types/react-router-dom\n创建路由配置\n创建 src/router/router.tsx 文件：\nimport { createBrowserRouter } from \"react-router-dom\";import Home from \"../pages/Home\";import About from \"../pages/About\";const router = createBrowserRouter([  {    path: \"/\",    element: &lt;Home /&gt;,  },  {    path: \"/about\",    element: &lt;About /&gt;,  },]);export default router;\n在应用中使用路由\n更新 src/App.tsx 文件：\nimport { RouterProvider } from \"react-router-dom\";import router from \"./router/router\";function App() {  return &lt;RouterProvider router={router} /&gt;;}export default App;\n创建页面组件\n创建 src/pages/Home.tsx 和 src/pages/About.tsx 文件：\n// src/pages/Home.tsximport React from \"react\";const Home: React.FC = () =&gt; {  return (    &lt;div&gt;      &lt;h1&gt;首页&lt;/h1&gt;    &lt;/div&gt;  );};export default Home;\n// src/pages/About.tsximport React from \"react\";const About: React.FC = () =&gt; {  return (    &lt;div&gt;      &lt;h1&gt;关于&lt;/h1&gt;    &lt;/div&gt;  );};export default About;\nReact Router 是 React 应用中最流行的路由解决方案，它允许我们构建单页应用程序(SPA)，通过 URL 的变化来展示不同的视图组件。它提供了声明式的路由配置，支持嵌套路由、动态路由参数、编程式导航等功能。通过使用 React Router，我们可以轻松地管理应用的不同页面和视图之间的导航关系。\n配置 Vite项目的 vite.config.ts 文件配置如下：\nimport { defineConfig } from \"vite\";import react from \"@vitejs/plugin-react\";import path from \"path\";// https://vitejs.dev/config/export default defineConfig({  plugins: [react()],  resolve: {    alias: {      \"@\": path.resolve(__dirname, \"./src\"),    },  },  css: {    postcss: \"./postcss.config.js\",  },  server: {    port: 3000,  },});\n配置 PostCSSPostCSS 是一个使用 JavaScript 插件转换 CSS 的工具。在这个项目中，我们使用了两个关键插件：\n\nTailwind CSS 插件：处理 Tailwind CSS 相关的样式生成\nAutoprefixer 插件：自动添加厂商前缀以确保样式在不同浏览器中的兼容性\n\n通过 PostCSS，我们可以自动化处理 CSS，减少手动工作并提高样式兼容性。\npostcss.config.js 文件配置如下：\nmodule.exports = {  plugins: {    tailwindcss: {},    autoprefixer: {},  },};\n添加常用组件和工具通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。\n创建基础 UI 组件：在 src/components/ui 目录下创建一些基础 UI 组件，例如按钮、输入框等\n创建自定义 Hooks：在 src/hooks 目录下创建常用的自定义 Hooks，例如 useLocalStorage、useToggle 等\n配置路径别名：在 tsconfig.json 中配置路径别名，方便导入模块：\n{  \"compilerOptions\": {    // ... 其他配置    \"baseUrl\": \".\",    \"paths\": {      \"@/*\": [\"src/*\"]    }  }}\n通过创建可复用的 UI 组件和自定义 Hooks，可以大大提高开发效率并保证界面一致性。路径别名的配置使得导入模块更加简洁，避免了复杂的相对路径引用。\n其他重要配置文件说明.gitignore.gitignore 文件用于指定 Git 应当忽略的文件和目录，防止不必要的文件被提交到代码仓库。在本项目中，该文件包含了以下几类被忽略的内容：\n\n系统文件：如 macOS 系统生成的 .DS_Store 文件\n日志文件：如 npm、yarn 等生成的日志文件\n依赖目录：如 node_modules/ 目录\n构建输出：如构建工具生成的 dist/、.next/ 等目录\n缓存文件：如各种工具生成的缓存文件\n环境变量文件：如 .env 及其变体文件，防止敏感信息泄露\n编辑器配置：如编辑器生成的临时文件\n\n通过合理配置 .gitignore，可以减小代码仓库体积，保护敏感信息，并避免无关文件干扰开发。\n.editorconfig.editorconfig 文件用于统一不同编辑器和 IDE 的代码格式设置。在团队协作中，不同开发者可能使用不同的编辑器，该文件可以确保所有人使用相同的编码规范：\n\n使用空格缩进，缩进大小为 2 个空格\n行尾符使用 LF (Unix 风格)\n字符编码使用 UTF-8\n自动删除行尾空白字符\n文件末尾自动添加新行\n\n这有助于保持代码风格的一致性，避免因编辑器差异导致的格式混乱。\n.prettierrc.jsPrettier 配置文件，用于统一代码格式化风格：\n\n不使用分号结尾\n对象和数组末尾保留逗号\n使用单引号而非双引号\n单行最大宽度为 120 字符\n缩进使用 2 个空格\n行尾符自动适应操作系统\n\nPrettier 会在保存文件或执行格式化命令时自动应用这些规则，确保整个项目的代码风格统一。\ncommitlint.config.cjsCommitlint 配置文件，用于校验 Git 提交信息的格式。它继承了 @commitlint/config-conventional 规则，要求提交信息遵循约定式提交规范：\n&lt;type&gt;[optional scope]: &lt;description&gt;[optional body][optional footer(s)]\n其中 type 必须是以下几种之一：\n\nfeat: 新功能\nfix: 修复 bug\nchore: 构建过程或辅助工具的变动\ndocs: 文档更新\nstyle: 代码格式调整\nrefactor: 重构\nperf: 性能优化\ntest: 测试用例\n\n这有助于生成标准化的变更日志，便于团队理解和维护项目历史。\n.stylelintrc.jsonStylelint 配置文件，用于检查 CSS/LESS 样式代码的质量和风格。该项目配置了：\n\n继承标准规则集和 Prettier 推荐规则\n支持 LESS 语法\n启用 Prettier 规则\n自定义类名命名规范（小写字母和连字符）\n允许未知的 at-rule（为了支持 LESS 特性）\n\n通过 Stylelint 可以确保样式代码的一致性和质量，避免常见的样式错误。\nlint-staged.config.jsLint-staged 配置文件，用于对 Git 暂存区的文件执行检查和格式化：\n\n对 TypeScript 文件执行 ESLint 和 Prettier\n对 JavaScript 文件执行 ESLint 和 Prettier\n对 LESS 和 CSS 文件执行 Stylelint\n对其他文件执行相应检查\n\n这确保只有符合规范的代码才能被提交到仓库，提升整体代码质量。\n开发环境和生产环境配置开发环境启动\nnpm run dev\n构建生产版本\nnpm run build\n预览生产构建\nnpm run preview\n","categories":["Github"],"tags":["前端开发"]}]